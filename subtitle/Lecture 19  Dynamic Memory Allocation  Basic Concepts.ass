[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video File: ../../../Desktop/csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 760
Active Line: 773
Video Position: 119215

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:02.08,0:00:03.44,csapp,,0,0,0,,all right good afternoon everybody
Dialogue: 0,0:00:04.56,0:00:09.10,csapp,,0,0,0,,welcome good to see you all welcome also to our our viewers on video 
Dialogue: 0,0:00:10.56,0:00:15.12,csapp,,0,0,0,, so last week we looked at this this virtual memory mechanism 
Dialogue: 0,0:00:17.44,0:00:21.40,csapp,,0,0,0,,and how it provides so many different useful functionalities to the system 
Dialogue: 0,0:00:22.94,0:00:30.40,csapp,,0,0,0,, along with this sort of abstraction of having this large contiguous array of bytes 
Dialogue: 0,0:00:32.54,0:00:35.00,csapp,,0,0,0,,now once we're given that that large array of bytes 
Dialogue: 0,0:00:36.64,0:00:37.86,csapp,,0,0,0,,now we have to manage it 
Dialogue: 0,0:00:39.48,0:00:46.72,csapp,,0,0,0,,and we have to we have to have some mechanism to to manage and use that that resource 
Dialogue: 0,0:00:47.14,0:00:54.46,csapp,,0,0,0,,okay so that's the topic of our our lectures this week is a storage allocation 
Dialogue: 0,0:00:54.80,0:00:57.04,csapp,,0,0,0,, and how storage allocators work 
Dialogue: 0,0:00:57.12,0:01:02.28,csapp,,0,0,0,,and how you use them to manage the matter the virtual memory in your system  
Dialogue: 0,0:01:06.30,0:01:10.48,csapp,,0,0,0,,so the the basic idea of a dynamic memory allocator
Dialogue: 0,0:01:10.60,0:01:21.48,csapp,,0,0,0,,is that applications use it to to manipulate virtual memory to create to to allocate and free chunks of virtual memory
Dialogue: 0,0:01:21.72,0:01:22.94,csapp,,0,0,0,, that you need in your program 
Dialogue: 0,0:01:23.94,0:01:28.46,csapp,,0,0,0,,and it's this this memory is maintained in it in an area of virtual memory called the heap
Dialogue: 0,0:01:30.52,0:01:37.20,csapp,,0,0,0,, okay and although all all languages have some ask some mechanism for we're acquiring and manipulating
Dialogue: 0,0:01:40.38,0:01:42.36,csapp,,0,0,0,,this this this dynamic memory 
Dialogue: 0,0:01:44.08,0:01:53.36,csapp,,0,0,0,,so in NC it's a phone it's the malloc package languages like Java  have the new the new method 
Dialogue: 0,0:01:56.26,0:02:00.96,csapp,,0,0,0,,now the allocator the allocator maintains the heap as a contiguous collection of blocks 
Dialogue: 0,0:02:02.56,0:02:05.22,csapp,,0,0,0,,where and it blocks can be allocated or free 
Dialogue: 0,0:02:05.96,0:02:11.34,csapp,,0,0,0,,ok allocated meaning that they're they're being used by some program application 
Dialogue: 0,0:02:13.08,0:02:17.86,csapp,,0,0,0,, free meaning that there available to be for use by an application 
Dialogue: 0,0:02:19.46,0:02:25.34,csapp,,0,0,0,,and there's there's two types of allocators the kind of allocator that you find in c  such as the malloc package
Dialogue: 0,0:02:25.92,0:02:31.20,csapp,,0,0,0,, it's up to the application to both explicitly allocate the the memory 
Dialogue: 0,0:02:31.58,0:02:35.46,csapp,,0,0,0,,and explicitly free it when when the when the application is finished with it 
Dialogue: 0,0:02:35.62,0:02:40.50,csapp,,0,0,0,,okay so the system won't won't free up any memory that you allocate unless you do it 
Dialogue: 0,0:02:40.96,0:02:45.34,csapp,,0,0,0,,explicitly by calling the by calling the free function
Dialogue: 0,0:02:46.40,0:02:51.62,csapp,,0,0,0,,but there's other languages that that support implicit allocators 
Dialogue: 0,0:02:51.94,0:02:58.90,csapp,,0,0,0,,and in these in these implicit allocators the programmer al explicitly allocates memory 
Dialogue: 0,0:02:59.62,0:03:02.40,csapp,,0,0,0,,but then the system takes care of freeing the memory 
Dialogue: 0,0:03:02.82,0:03:11.42,csapp,,0,0,0,,okay so it's that the burden of freeing the memory is shifted from the application program to the to the system 
Dialogue: 0,0:03:12.04,0:03:16.86,csapp,,0,0,0,,and it it frees this memory implicitly sort of behind the scenes using a process called garbage collection 
Dialogue: 0,0:03:18.24,0:03:26.18,csapp,,0,0,0,,okay so languages like Java,ML,Lisp um they all do implicit implicit they all support in close at allocators 
Dialogue: 0,0:03:26.78,0:03:30.82,csapp,,0,0,0,,now today we're going to just we're going to discuss explicit memory alligators
Dialogue: 0,0:03:31.24,0:03:35.38,csapp,,0,0,0,, on Thursday we'll get into implicit alligators and how they work
Dialogue: 0,0:03:37.50,0:03:41.64,csapp,,0,0,0,,now the alligator and C is provided it by the standard c library 
Dialogue: 0,0:03:43.54,0:03:46.02,csapp,,0,0,0,,in a set of function called malloc package
Dialogue: 0,0:03:48.34,0:03:51.34,csapp,,0,0,0,, the the malloc function is used to to allocate memory 
Dialogue: 0,0:03:52.08,0:03:55.38,csapp,,0,0,0,,and it takes as input a size argument which is in bytes 
Dialogue: 0,0:03:57.44,0:04:04.16,csapp,,0,0,0,,okay and then it returns a pointer to a to a memory block that contains at least size bytes
Dialogue: 0,0:04:05.22,0:04:12.06,csapp,,0,0,0,,and that block is aligned to on x86 systems to 8-bytes on x86-64 systems to 16-bytes
Dialogue: 0,0:04:13.02,0:04:16.74,csapp,,0,0,0,, if size is 0 it returns null
Dialogue: 0,0:04:18.50,0:04:24.34,csapp,,0,0,0,,and then it returns -1 like like most typical system calls
Dialogue: 0,0:04:25.68,0:04:30.02,csapp,,0,0,0,, the programmer frees memory by calling the free function 
Dialogue: 0,0:04:30.80,0:04:36.57,csapp,,0,0,0,,it takes as an argument a pointer that was returned from some prior invocation of malloc 
Dialogue: 0,0:04:37.06,0:04:38.92,csapp,,0,0,0,,and it returns nothing 
Dialogue: 0,0:04:40.38,0:04:41.78,csapp,,0,0,0,,and it frees that 
Dialogue: 0,0:04:43.34,0:04:49.24,csapp,,0,0,0,,I've given this pointer that was returned by the prior indication of malloc it  frees the block at that address 
Dialogue: 0,0:04:51.46,0:04:54.36,csapp,,0,0,0,,and then returns that block to the pool of available memory 
Dialogue: 0,0:04:55.50,0:04:57.72,csapp,,0,0,0,,now there's some there's some other functions 
Dialogue: 0,0:04:59.60,0:05:05.88,csapp,,0,0,0,,so sialic is a version of malloc that gives you an initialized block of memory that's initialized to 0
Dialogue: 0,0:05:06.78,0:05:13.48,csapp,,0,0,0,,and realloc you can malloc a block and then call realloc to change the size of that  previously allocated block 
Dialogue: 0,0:05:14.86,0:05:20.52,csapp,,0,0,0,,and then there's a function called S break which is used internally by allocators to grow and shrink the heap
Dialogue: 0,0:05:20.88,0:05:22.62,csapp,,0,0,0,,so when an allocator needs more memory
Dialogue: 0,0:05:23.04,0:05:27.26,csapp,,0,0,0,,it calls S break to to get that additional virtual memory 
Dialogue: 0,0:05:27.54,0:05:30.60,csapp,,0,0,0,,and then that that's added to the heap that the portion 
Dialogue: 0,0:05:31.16,0:05:36.52,csapp,,0,0,0,,that grows the heap and then it adds it to the memory that the the allocator is is manipulating
Dialogue: 0,0:05:40.24,0:05:44.24,csapp,,0,0,0,,so here's an example of how we would use Malik and it's in a simple program 
Dialogue: 0,0:05:45.02,0:05:51.90,csapp,,0,0,0,,we have a pointer to an int  *p  and we call malloc 
Dialogue: 0,0:05:52.56,0:05:54.92,csapp,,0,0,0,,and we we want to allocate an array of N in
Dialogue: 0,0:05:55.66,0:05:58.66,csapp,,0,0,0,, so this is that this is sort of the standard way you call it 
Dialogue: 0,0:05:59.24,0:06:03.70,csapp,,0,0,0,, we want n int and so we we call it with n times the size of int 
Dialogue: 0,0:06:04.48,0:06:06.38,csapp,,0,0,0,,because remember the argument is in bytes 
Dialogue: 0,0:06:08.00,0:06:09.58,csapp,,0,0,0,,malloc returns a pointer
Dialogue: 0,0:06:10.94,0:06:13.64,csapp,,0,0,0,,  it returns that generic pointer void* pointer so
Dialogue: 0,0:06:14.86,0:06:19.66,csapp,,0,0,0,,so we cast it to a pointer to an int to keep keep the compiler happy 
Dialogue: 0,0:06:20.20,0:06:21.86,csapp,,0,0,0,,and then assign it to to p
Dialogue: 0,0:06:24.32,0:06:28.10,csapp,,0,0,0,,we check for a we check for a null return value 
Dialogue: 0,0:06:30.56,0:06:35.56,csapp,,0,0,0,,so I should I should point out the it returns 0 on error 
Dialogue: 0,0:06:35.56,0:06:40.76,csapp,,0,0,0,, so we check we recheck recheck for this NULL, the no pointer which is 0 
Dialogue: 0,0:06:43.02,0:06:44.36,csapp,,0,0,0,,in print an error if it's NULL 
Dialogue: 0,0:06:45.68,0:06:49.46,csapp,,0,0,0,,now once we've got that pointer now P we can treat it just like an array 
Dialogue: 0,0:06:50.22,0:06:54.52,csapp,,0,0,0,,so we can so inside the loop if we want to initialize it we loop 
Dialogue: 0,0:06:55.98,0:07:00.20,csapp,,0,0,0,,across the elements of the array initializing each one to some value 
Dialogue: 0,0:07:01.10,0:07:09.56,csapp,,0,0,0,,now when we're finished when we're finished with this chunk of memory that we've allocated then we free it by calling free with the pointer P
Dialogue: 0,0:07:12.54,0:07:18.44,csapp,,0,0,0,, okay now the so we're going to look today at how functions like malloc and free are implemented 
Dialogue: 0,0:07:19.68,0:07:22.68,csapp,,0,0,0,,so we're going to make a few simplifying assumptions 
Dialogue: 0,0:07:23.93,0:07:28.52,csapp,,0,0,0,,so I'm going to memory it is byte address
Dialogue: 0,0:07:28.62,0:07:32.82,csapp,,0,0,0,,we know that but for the purposes of this lecture we're going to assume that it's it's word address 
Dialogue: 0,0:07:32.96,0:07:35.00,csapp,,0,0,0,,okay so we're just going to look at word size units
Dialogue: 0,0:07:38.76,0:07:42.02,csapp,,0,0,0,,and I'm going to assume that words are 4 bytes 
Dialogue: 0,0:07:44.60,0:07:47.82,csapp,,0,0,0,,so they basically the size of an int
Dialogue: 0,0:07:50.86,0:07:53.98,csapp,,0,0,0,,so this isn't actually this this isn't true I need to fix that 
Dialogue: 0,0:07:56.26,0:08:02.78,csapp,,0,0,0,,so basically we're going to we're going to think of words as four byte quantity sort of integer size quantities 
Dialogue: 0,0:08:05.10,0:08:09.66,csapp,,0,0,0,,and then our blocks or contiguous chunks of those words that can be either allocated or free 
Dialogue: 0,0:08:10.50,0:08:13.18,csapp,,0,0,0,,so here we have a portion of the heap
Dialogue: 0,0:08:13.76,0:08:18.94,csapp,,0,0,0,,which consists of a four word allocated block followed by a two word free block 
Dialogue: 0,0:08:20.06,0:08:24.80,csapp,,0,0,0,,followed by another for word allocated block followed by a three word free blocking
Dialogue: 0,0:08:25.50,0:08:33.34,csapp,,0,0,0,, and we'll indicate these free blocks by white and will indicate allocated blocks with some shade of color 
Dialogue: 0,0:08:36.42,0:08:41.10,csapp,,0,0,0,,so let's look now how a sequence of of allocations and freeze would work 
Dialogue: 0,0:08:42.28,0:08:46.02,csapp,,0,0,0,,and now notice I'm calling malloc with the size of in words 
Dialogue: 0,0:08:46.68,0:08:51.14,csapp,,0,0,0,,not bytes just to keep just to keep things keep these pictures simpler
Dialogue: 0,0:08:55.04,0:09:00.88,csapp,,0,0,0,,so in this first we call malloc  and allocate of a forward block 
Dialogue: 0,0:09:03.88,0:09:06.14,csapp,,0,0,0,,then we can that and that gives us a pointer p1 
Dialogue: 0,0:09:06.14,0:09:09.32,csapp,,0,0,0,,then we call malloc again to get a five-word block 
Dialogue: 0,0:09:09.44,0:09:14.40,csapp,,0,0,0,,so it just takes it one of the free words and allocates it 
Dialogue: 0,0:09:15.58,0:09:17.94,csapp,,0,0,0,,we call malloc again to get a six word block 
Dialogue: 0,0:09:19.76,0:09:24.28,csapp,,0,0,0,,and then we free the block that's pointed at by P to this purple block
Dialogue: 0,0:09:26.24,0:09:28.56,csapp,,0,0,0,,okay so now we that frees up that block
Dialogue: 0,0:09:29.12,0:09:32.80,csapp,,0,0,0,,and then we do another allocation for a two word block
Dialogue: 0,0:09:33.10,0:09:39.96,csapp,,0,0,0,, and so the the allocator looks to see if it can find a free block that has enough enough room and
Dialogue: 0,0:09:40.28,0:09:45.34,csapp,,0,0,0,, it finds that it finds this free block here that has five free words and then it
Dialogue: 0,0:09:46.26,0:09:52.00,csapp,,0,0,0,,allocates the the requested block inside of that that free block 
Dialogue: 0,0:09:55.62,0:10:00.74,csapp,,0,0,0,,now allocators work under a lot of a lot of different constraints
Dialogue: 0,0:10:01.30,0:10:04.00,csapp,,0,0,0,, okay so it's hard to write an allocator because of all these constraints 
Dialogue: 0,0:10:05.88,0:10:10.80,csapp,,0,0,0,,applications can choose any combination of allocated and free blocks
Dialogue: 0,0:10:10.88,0:10:14.12,csapp,,0,0,0,,so you can't predict what what an application is going to request
Dialogue: 0,0:10:15.54,0:10:22.06,csapp,,0,0,0,, and and the application is required to free a block by when it frees a block to pass a pointer
Dialogue: 0,0:10:22.64,0:10:25.80,csapp,,0,0,0,, that was returned from a previous invocation of malloc 
Dialogue: 0,0:10:26.82,0:10:29.50,csapp,,0,0,0,, okay so the the application has a few constraints
Dialogue: 0,0:10:31.08,0:10:34.50,csapp,,0,0,0,, but but really the only one that it has is that the fact that the
Dialogue: 0,0:10:35.18,0:10:39.23,csapp,,0,0,0,,when it frees something it has to be a pointer from a previous invocation of malloc
Dialogue: 0,0:10:39.68,0:10:45.66,csapp,,0,0,0,,now the malloc operates or allocators like malloc operate under a lot of different constraints 
Dialogue: 0,0:10:46.36,0:10:49.56,csapp,,0,0,0,,they can't control the size or the number of the allocated blocks
Dialogue: 0,0:10:50.32,0:10:53.40,csapp,,0,0,0,, because they have no control over the what the application is doing
Dialogue: 0,0:10:54.92,0:10:58.66,csapp,,0,0,0,, if an application calls Malik Malik has to respond right away 
Dialogue: 0,0:10:59.18,0:11:03.98,csapp,,0,0,0,,it might you might be able to do a better more efficient version by batching up requests 
Dialogue: 0,0:11:04.78,0:11:06.76,csapp,,0,0,0,,and then responding to all those requests at once
Dialogue: 0,0:11:07.45,0:11:12.98,csapp,,0,0,0,,which the allocator can't do it when it gets called it has to process the request and then return right away
Dialogue: 0,0:11:14.80,0:11:17.32,csapp,,0,0,0,,  it has to of course it has to allocate blocks from free memory
Dialogue: 0,0:11:17.34,0:11:20.84,csapp,,0,0,0,,  so it can't in general I can't touch any allocated block 
Dialogue: 0,0:11:21.46,0:11:25.74,csapp,,0,0,0,,right once it allocates a block that block belongs to the application and the
Dialogue: 0,0:11:26.36,0:11:29.06,csapp,,0,0,0,, the malloc package can't touch it
Dialogue: 0,0:11:29.34,0:11:31.30,csapp,,0,0,0,, now this this has a number of implications
Dialogue: 0,0:11:31.92,0:11:38.94,csapp,,0,0,0,,  so this means that the allocator can't it can't move blocks around like it 
Dialogue: 0,0:11:38.94,0:11:44.26,csapp,,0,0,0,,can't compress blocks like an alligator might want to take allocated blocks and smoosh them all together
Dialogue: 0,0:11:44.70,0:11:47.64,csapp,,0,0,0,, to create larger free blocks hey but it can't do that 
Dialogue: 0,0:11:48.42,0:11:52.86,csapp,,0,0,0,,okay so once you know in a language like C once once an alligator 
Dialogue: 0,0:11:53.90,0:11:57.42,csapp,,0,0,0,,gives a block to a an application it can't touch it 
Dialogue: 0,0:11:58.68,0:12:03.98,csapp,,0,0,0,,okay now blocks like blocked because blocks are holding data structures like strux
Dialogue: 0,0:12:04.76,0:12:12.80,csapp,,0,0,0,,or you know scalar scalar objects it has to be aligned to the size of the largest object that that can occur 
Dialogue: 0,0:12:13.46,0:12:19.54,csapp,,0,0,0,,okay so for 64-bit systems that's 16 byte alignment for 32-bit systems it's 8 byte alignment
Dialogue: 0,0:12:24.06,0:12:27.90,csapp,,0,0,0,,now alligators are really interesting objects 
Dialogue: 0,0:12:27.90,0:12:30.72,csapp,,0,0,0,,because they they combine a trade-off of both 
Dialogue: 0,0:12:32.48,0:12:35.50,csapp,,0,0,0,,so running time sort of speed and space 
Dialogue: 0,0:12:35.90,0:12:38.64,csapp,,0,0,0,,so it's kind of a space and performance trade-off 
Dialogue: 0,0:12:38.64,0:12:42.04,csapp,,0,0,0,,you're trying to optimize both you want it to run as quickly as possible
Dialogue: 0,0:12:42.50,0:12:47.72,csapp,,0,0,0,, but you want to you wanted to use the virtual memory in the heap as efficiently as possible
Dialogue: 0,0:12:48.14,0:12:48.74,csapp,,0,0,0,,okay so let's and 
Dialogue: 0,0:12:50.28,0:12:58.76,csapp,,0,0,0,, we define these these sort of speed and and efficiency memory efficiency 
Dialogue: 0,0:12:59.10,0:13:02.40,csapp,,0,0,0,,metrics  we have we have two metrics that we use one is called throughput 
Dialogue: 0,0:13:03.44,0:13:10.52,csapp,,0,0,0,,so given some sequence of malloc and free requests  R[0] through R[n-1] 
Dialogue: 0,0:13:10.72,0:13:13.96,csapp,,0,0,0,, so just some where R is either a malloc or free 
Dialogue: 0,0:13:15.88,0:13:18.08,csapp,,0,0,0,,our goal is to maximize throughput 
Dialogue: 0,0:13:19.14,0:13:21.28,csapp,,0,0,0,,and the peak memory utilization 
Dialogue: 0,0:13:22.40,0:13:28.46,csapp,,0,0,0,,and what makes malloc such a fascinating and interesting study is that these often conflict like 
Dialogue: 0,0:13:29.12,0:13:34.50,csapp,,0,0,0,,it's very easy to make a really fast malloc that that has terrible memory utilization 
Dialogue: 0,0:13:36.56,0:13:41.02,csapp,,0,0,0,,so throughput is just the number of recomputed requests per unit time 
Dialogue: 0,0:13:41.12,0:13:46.04,csapp,,0,0,0,,so if we have 5,000 malloc calls and 5,000 free calls in 10 seconds 
Dialogue: 0,0:13:46.78,0:13:49.70,csapp,,0,0,0,,then our throughput is a thousand operations per second 
Dialogue: 0,0:13:51.66,0:13:57.62,csapp,,0,0,0,,so it's just measuring sort of how efficiently are our malloc can can process these requests from an application
Dialogue: 0,0:14:00.56,0:14:02.20,csapp,,0,0,0,,now peak memory utilization 
Dialogue: 0,0:14:05.42,0:14:10.44,csapp,,0,0,0,,is a measure sort of how how much useful space 
Dialogue: 0,0:14:11.20,0:14:16.02,csapp,,0,0,0,,so how much it measured how efficiently the allocator uses the heat 
Dialogue: 0,0:14:16.50,0:14:20.34,csapp,,0,0,0,,sort of how much is wasted on sort of overheads in the data structures
Dialogue: 0,0:14:20.34,0:14:25.00,csapp,,0,0,0,, that the allocator has to uses to in its implementation
Dialogue: 0,0:14:26.16,0:14:27.68,csapp,,0,0,0,, so we'll define a payload 
Dialogue: 0,0:14:29.02,0:14:31.16,csapp,,0,0,0,,when when malloc returns a block 
Dialogue: 0,0:14:31.66,0:14:38.14,csapp,,0,0,0,,what when it I'm sorry what an application makes a call to malloc it's requesting a certain size block 
Dialogue: 0,0:14:39.10,0:14:40.96,csapp,,0,0,0,, and that that block is called the payload 
Dialogue: 0,0:14:40.98,0:14:44.50,csapp,,0,0,0,,so if we call malloc with an argument of 10 bytes 
Dialogue: 0,0:14:45.12,0:14:50.10,csapp,,0,0,0,,we're requesting a block that has a payload of it that's at least size 10 
Dialogue: 0,0:14:50.98,0:14:53.76,csapp,,0,0,0,,okay and the 10 bytes that we request that are called the payload
Dialogue: 0,0:14:54.18,0:14:57.06,csapp,,0,0,0,,everything else in that block is is overhead 
Dialogue: 0,0:15:00.74,0:15:04.66,csapp,,0,0,0,,okay so after after we've run a sequence of requests 
Dialogue: 0,0:15:06.12,0:15:11.72,csapp,,0,0,0,,the aggregate payload is the sum of all the the payloads in the currently allocated blocks 
Dialogue: 0,0:15:13.26,0:15:14.84,csapp,,0,0,0,,okay so in a perfect allocator 
Dialogue: 0,0:15:15.80,0:15:21.46,csapp,,0,0,0,,the the aggregate payload would would would equal the amount of memory 
Dialogue: 0,0:15:21.88,0:15:25.22,csapp,,0,0,0,,the total size of all the allocated blocks right because there'd be no overhead
Dialogue: 0,0:15:25.54,0:15:29.00,csapp,,0,0,0,,would just be we just be pure every block would be pure payload
Dialogue: 0,0:15:33.62,0:15:39.44,csapp,,0,0,0,,now we're going to assume that the heap is is monotonically non-decreasing so it always gets bigger 
Dialogue: 0,0:15:39.98,0:15:45.00,csapp,,0,0,0,,okay so are this is a simplifying assumption it's not  it's not true in a real Malak package 
Dialogue: 0,0:15:45.44,0:15:49.98,csapp,,0,0,0,,but we'll just assume that the allocator never decreases the size of the heap 
Dialogue: 0,0:15:50.04,0:15:52.40,csapp,,0,0,0,,it only increases the size of the heap okay 
Dialogue: 0,0:15:57.06,0:16:02.90,csapp,,0,0,0,,so the peak given those given those notions of aggregate payload and heap size 
Dialogue: 0,0:16:03.78,0:16:07.94,csapp,,0,0,0,,the peak memory utilization after k+1 requests
Dialogue: 0,0:16:08.90,0:16:17.10,csapp,,0,0,0,,It's the sum of all the is the sum of all the payloads  divided by the total size of the heap
Dialogue: 0,0:16:19.98,0:16:21.40,csapp,,0,0,0,, so the in the best case 
Dialogue: 0,0:16:22.64,0:16:27.28,csapp,,0,0,0,,each each block in the heap consists of pure payload
Dialogue: 0,0:16:27.92,0:16:29.72,csapp,,0,0,0,, so the utilization would be 1 
Dialogue: 0,0:16:30.16,0:16:32.24,csapp,,0,0,0,,that's the best we can do 
Dialogue: 0,0:16:32.26,0:16:39.86,csapp,,0,0,0,,but in practice each block the allocator is going to place have data structures and padding inside of each block 
Dialogue: 0,0:16:40.44,0:16:45.78,csapp,,0,0,0,,that that that keep it from getting a perfect utilization 
Dialogue: 0,0:16:46.22,0:16:49.64,csapp,,0,0,0,,now one one obvious thing is that since blocks have to be aligned 
Dialogue: 0,0:16:50.78,0:16:56.14,csapp,,0,0,0,, to some you know if they're 16-byte aligned then blocks have to start on 16 byte boundaries 
Dialogue: 0,0:16:56.14,0:16:58.32,csapp,,0,0,0,,and they have to be at least 16 bytes 
Dialogue: 0,0:16:58.96,0:17:01.64,csapp,,0,0,0,,so if you were to request a payload of 2 bytes
Dialogue: 0,0:17:01.76,0:17:06.78,csapp,,0,0,0,,you'd have a lot of wasted bytes right that would sort of decrease the utilization 
Dialogue: 0,0:17:07.56,0:17:11.90,csapp,,0,0,0,,so this is some of this some of this overhead is unavoidable 
Dialogue: 0,0:17:11.90,0:17:18.46,csapp,,0,0,0,,but your job as a someone who writes them implements malloc is to try to keep that as small as possible
Dialogue: 0,0:17:22.40,0:17:29.82,csapp,,0,0,0,,so poor memory utilization is this example that we just talked about is an example of what we call fragmentation
Dialogue: 0,0:17:30.54,0:17:32.88,csapp,,0,0,0,, and there's there's two types of fragmentation
Dialogue: 0,0:17:34.36,0:17:38.08,csapp,,0,0,0,, internal fragmentation occurs if the payload is smaller than the block size 
Dialogue: 0,0:17:38.10,0:17:40.20,csapp,,0,0,0,,so it's just what we're talking about 
Dialogue: 0,0:17:40.70,0:17:48.02,csapp,,0,0,0,,and this can be caused by either padding in the block or some kind of data structure in the block that the allocator needs 
Dialogue: 0,0:17:50.82,0:17:54.06,csapp,,0,0,0,,sometimes to it you might make a policy decision 
Dialogue: 0,0:17:54.06,0:17:59.80,csapp,,0,0,0,,that if at if application requests a small block you might return a larger block just to keep 
Dialogue: 0,0:18:00.50,0:18:07.24,csapp,,0,0,0,,so the blocks don't get sort of splintered up into little chunks you might want to keep blocks at some minimum size
Dialogue: 0,0:18:12.60,0:18:17.56,csapp,,0,0,0,,now internal fragmentation you know given a series of requests 
Dialogue: 0,0:18:19.54,0:18:21.68,csapp,,0,0,0,,we can we can just stop and freeze the heap 
Dialogue: 0,0:18:21.84,0:18:26.06,csapp,,0,0,0,,and it's very easy to sort of compute the amount of internal fragmentation 
Dialogue: 0,0:18:26.06,0:18:32.14,csapp,,0,0,0,,we can at any point in time we can just look at all the previous requests that  we we've made 
Dialogue: 0,0:18:32.62,0:18:35.78,csapp,,0,0,0,,and and look at the size of the payload for each one of those requests 
Dialogue: 0,0:18:36.86,0:18:39.22,csapp,,0,0,0,,and so we can 
Dialogue: 0,0:18:41.76,0:18:44.30,csapp,,0,0,0,,so we can determine the level you know get at a point in time
Dialogue: 0,0:18:44.30,0:18:49.38,csapp,,0,0,0,, we can determine the level of internal fragmentation just by looking at the previous request 
Dialogue: 0,0:18:50.26,0:18:50.62,csapp,,0,0,0,,so
Dialogue: 0,0:18:52.22,0:18:58.62,csapp,,0,0,0,, there's another form of fragmentation called external fragmentation which is a little more difficult to to deal with 
Dialogue: 0,0:18:59.50,0:19:04.20,csapp,,0,0,0,,so external fragmentation occurs when there's enough memory in the heap 
Dialogue: 0,0:19:05.12,0:19:09.42,csapp,,0,0,0,, but there's there's no single free block that can satisfy a particular request 
Dialogue: 0,0:19:10.22,0:19:15.36,csapp,,0,0,0,,ok so external fragmentation occurs when the application makes a request for a block
Dialogue: 0,0:19:16.70,0:19:23.02,csapp,,0,0,0,,but nowhere in the heap is there a free block a free block that's large enough to satisfy that request
Dialogue: 0,0:19:26.22,0:19:28.46,csapp,,0,0,0,,so an example of this like suppose
Dialogue: 0,0:19:28.72,0:19:30.58,csapp,,0,0,0,,here's the previous example we looked at 
Dialogue: 0,0:19:30.58,0:19:35.38,csapp,,0,0,0,,now where we have after a series of malloc and free calls 
Dialogue: 0,0:19:36.40,0:19:38.10,csapp,,0,0,0,,we have two free blocks in the heap 
Dialogue: 0,0:19:38.98,0:19:41.86,csapp,,0,0,0,,one containing five words and the other containing two words
Dialogue: 0,0:19:41.96,0:19:47.02,csapp,,0,0,0,,so the total the total number of free words in our heap is seven seven words
Dialogue: 0,0:19:47.90,0:19:51.10,csapp,,0,0,0,,and now we get a request for six words
Dialogue: 0,0:19:52.34,0:19:56.22,csapp,,0,0,0,,hey we have enough free blocks we have enough free words in the heap 
Dialogue: 0,0:19:57.42,0:19:59.30,csapp,,0,0,0,,but we can't satisfy that request 
Dialogue: 0,0:20:00.76,0:20:05.92,csapp,,0,0,0,,and it's it's because of it's because of this phenomenon called external fragmentation
Dialogue: 0,0:20:06.26,0:20:11.42,csapp,,0,0,0,,for example if we'd have if we'd have somehow allocated
Dialogue: 0,0:20:15.27,0:20:16.54,csapp,,0,0,0,,Oh
Dialogue: 0,0:20:18.52,0:20:22.34,csapp,,0,0,0,,yeah I don't know in this case I don't think we could have avoided the external fragmentation 
Dialogue: 0,0:20:22.98,0:20:29.78,csapp,,0,0,0,,but nonetheless there's enough memory here we just just the way that our blocks are configured in the
Dialogue: 0,0:20:29.78,0:20:31.30,csapp,,0,0,0,,heap we can't satisfy the request 
Dialogue: 0,0:20:31.78,0:20:37.24,csapp,,0,0,0,,so in this in this in this case that the allocator has to go and get more more virtual memory 
Dialogue: 0,0:20:37.58,0:20:42.80,csapp,,0,0,0,,would have to go and it would have to get more virtual memory and extend the heap out this way
Dialogue: 0,0:20:44.10,0:20:45.64,csapp,,0,0,0,, and to get a large enough free block
Dialogue: 0,0:20:47.26,0:20:53.00,csapp,,0,0,0,, so you know assessing and sort of understanding external fragmentation is difficult
Dialogue: 0,0:20:53.88,0:20:58.58,csapp,,0,0,0,,because unlike internal fragmentation which depended on the previous requests
Dialogue: 0,0:20:59.08,0:21:01.92,csapp,,0,0,0,,external fragmentation depends on future requests 
Dialogue: 0,0:21:03.00,0:21:04.44,csapp,,0,0,0,,so if we look back at this point 
Dialogue: 0,0:21:04.78,0:21:07.92,csapp,,0,0,0,,we say is is our is our heap externally fragmented 
Dialogue: 0,0:21:08.72,0:21:10.84,csapp,,0,0,0,,well we it depends right we can't say  
Dialogue: 0,0:21:11.80,0:21:16.40,csapp,,0,0,0,,it turns out it is because the next request is is for a block of size six 
Dialogue: 0,0:21:16.84,0:21:18.22,csapp,,0,0,0,,but if all of the future blocks 
Dialogue: 0,0:21:18.70,0:21:22.88,csapp,,0,0,0,,or future requests were for bullet we're for blocks of you know say small blocks 
Dialogue: 0,0:21:23.44,0:21:28.86,csapp,,0,0,0,,then we be able to satisfy those than and we wouldn't we wouldn't suffer from external fragmentation
Dialogue: 0,0:21:33.48,0:21:36.16,csapp,,0,0,0,,okay now when we build an alligator 
Dialogue: 0,0:21:37.90,0:21:39.42,csapp,,0,0,0,,all kinds of issues come up 
Dialogue: 0,0:21:42.36,0:21:45.04,csapp,,0,0,0,,and that I've glossed over with my simple examples right 
Dialogue: 0,0:21:46.32,0:21:47.36,csapp,,0,0,0,,you know how do we know 
Dialogue: 0,0:21:49.04,0:21:52.88,csapp,,0,0,0,,if we call free how does free know how much memory to free up
Dialogue: 0,0:21:53.14,0:21:56.64,csapp,,0,0,0,, right we don't call free with a block size we call it with a pointer
Dialogue: 0,0:21:57.36,0:22:00.02,csapp,,0,0,0,,so how does free know how big that block is 
Dialogue: 0,0:22:01.96,0:22:03.64,csapp,,0,0,0,,how do we keep track of all the free blocks 
Dialogue: 0,0:22:07.54,0:22:11.64,csapp,,0,0,0,,when we have you know when we're satisfying an allocation request 
Dialogue: 0,0:22:12.94,0:22:14.72,csapp,,0,0,0,,we're going to fight we're going to look for a free block
Dialogue: 0,0:22:14.88,0:22:18.10,csapp,,0,0,0,, that is larger than the the requested size 
Dialogue: 0,0:22:19.02,0:22:22.08,csapp,,0,0,0,,on that that case what do we do with the extra space in the block
Dialogue: 0,0:22:22.52,0:22:24.04,csapp,,0,0,0,,we do we just keep it in the block 
Dialogue: 0,0:22:25.14,0:22:27.56,csapp,,0,0,0,, you know and and suffer some internal fragmentation 
Dialogue: 0,0:22:27.96,0:22:30.76,csapp,,0,0,0,,do we split that block into a smaller block
Dialogue: 0,0:22:33.68,0:22:36.72,csapp,,0,0,0,, there's a lot of free blocks  in the in the heap 
Dialogue: 0,0:22:36.72,0:22:41.72,csapp,,0,0,0,,how do we when we make an out when the allocator gets a allocation request 
Dialogue: 0,0:22:42.20,0:22:46.72,csapp,,0,0,0,,how does it pick from all among all of those different free blocks  make as many choices 
Dialogue: 0,0:22:49.04,0:22:53.90,csapp,,0,0,0,,and then once when free tries to insert a free block we're in the heap
Dialogue: 0,0:22:55.52,0:22:56.72,csapp,,0,0,0,,you know where does it insert
Dialogue: 0,0:22:57.68,0:22:59.00,csapp,,0,0,0,, it okay when it's when it's freed 
Dialogue: 0,0:22:59.38,0:23:02.12,csapp,,0,0,0,,and how do we reinsert a free block what does that mean
Dialogue: 0,0:23:02.96,0:23:05.74,csapp,,0,0,0,, okay so today we're going to look at at all of these issues 
Dialogue: 0,0:23:07.60,0:23:10.38,csapp,,0,0,0,,starting with knowing how much to free 
Dialogue: 0,0:23:10.68,0:23:12.08,csapp,,0,0,0,,so how big our block sizes 
Dialogue: 0,0:23:13.38,0:23:15.60,csapp,,0,0,0,,so the typical the standard method 
Dialogue: 0,0:23:17.52,0:23:21.98,csapp,,0,0,0,,is to keep sort of a word sized quantity at the beginning of each block
Dialogue: 0,0:23:22.28,0:23:26.84,csapp,,0,0,0,,that gives the size of that block in in some units 
Dialogue: 0,0:23:27.62,0:23:29.68,csapp,,0,0,0,,I'm showing them here in word size units 
Dialogue: 0,0:23:30.74,0:23:39.16,csapp,,0,0,0,,okay so that if if the application Malick's a payload of size wants to wants to now like a payload of size four 
Dialogue: 0,0:23:41.12,0:23:46.62,csapp,,0,0,0,,then the allocator needs to find a block of size five 
Dialogue: 0,0:23:47.96,0:23:52.10,csapp,,0,0,0,,so consisting of four payload words at least four payload words 
Dialogue: 0,0:23:52.84,0:24:01.28,csapp,,0,0,0,,and then a header block a header word at the beginning that that indicates the size the total size of that block 
Dialogue: 0,0:24:02.76,0:24:06.90,csapp,,0,0,0,,and then it returns a pointer p0 in this case to the beginning of the payload
Dialogue: 0,0:24:12.60,0:24:15.48,csapp,,0,0,0,,okay so now we know how big each block is that's pretty simple 
Dialogue: 0,0:24:15.82,0:24:19.40,csapp,,0,0,0,,and how we keep track of the free blocks and this is where it gets interesting 
Dialogue: 0,0:24:20.58,0:24:25.38,csapp,,0,0,0,,the simplest method is to use that we call an implicit list 
Dialogue: 0,0:24:25.86,0:24:27.48,csapp,,0,0,0,,an implicit list of free blocks 
Dialogue: 0,0:24:28.74,0:24:34.26,csapp,,0,0,0,,and the idea here is to just put a header in the front of every block in the heap 
Dialogue: 0,0:24:34.26,0:24:36.10,csapp,,0,0,0,,whether allocated or free 
Dialogue: 0,0:24:38.86,0:24:44.76,csapp,,0,0,0,,and then we can use that starting at the beginning of the heap we can use that size to walk the heat 
Dialogue: 0,0:24:47.14,0:24:50.20,csapp,,0,0,0,,okay so here's a block of size five so we can we can jump
Dialogue: 0,0:24:50.60,0:24:53.86,csapp,,0,0,0,, we know that the next block starts at an offset of five 
Dialogue: 0,0:24:56.06,0:25:01.96,csapp,,0,0,0,,with the second block we know the then the next block starts at an offset of four  and so on 
Dialogue: 0,0:25:02.58,0:25:05.00,csapp,,0,0,0,,okay so we call it an implicit free list 
Dialogue: 0,0:25:06.32,0:25:08.38,csapp,,0,0,0,,because there's there's no real list of free blocks
Dialogue: 0,0:25:09.06,0:25:13.26,csapp,,0,0,0,, but we can trick an traverse that all of the free blocks in the heap 
Dialogue: 0,0:25:14.04,0:25:18.46,csapp,,0,0,0,,by traversing all of the blocks in the heat
Dialogue: 0,0:25:18.56,0:25:21.74,csapp,,0,0,0,,and then just ignoring the the allocated blocks okay so
Dialogue: 0,0:25:25.84,0:25:27.10,csapp,,0,0,0,,now another thing we could do is 
Dialogue: 0,0:25:27.10,0:25:31.38,csapp,,0,0,0,,we could actually use some of the some of the words in the block
Dialogue: 0,0:25:31.70,0:25:34.30,csapp,,0,0,0,, to create a linked list of some kind either us
Dialogue: 0,0:25:35.44,0:25:36.96,csapp,,0,0,0,,singly or doubly linked lists 
Dialogue: 0,0:25:38.48,0:25:43.56,csapp,,0,0,0,,and in this case we it's an explicit list of the free blocks 
Dialogue: 0,0:25:44.06,0:25:45.54,csapp,,0,0,0,,and we can just walk that list 
Dialogue: 0,0:25:48.56,0:25:50.50,csapp,,0,0,0,,so we here we visit the first free block 
Dialogue: 0,0:25:51.50,0:25:55.26,csapp,,0,0,0,,and then there's a pointer to the next free block and so on 
Dialogue: 0,0:25:55.28,0:25:58.26,csapp,,0,0,0,,so this you can see this might be a little more efficient because
Dialogue: 0,0:25:59.14,0:26:00.62,csapp,,0,0,0,, if we want to traverse the free list 
Dialogue: 0,0:26:01.86,0:26:07.54,csapp,,0,0,0,,in this case it's a it's going to be ordered the number of blocks in the list 
Dialogue: 0,0:26:08.06,0:26:10.84,csapp,,0,0,0,, okay it's going to be linear in the total number of blocks in the heap 
Dialogue: 0,0:26:11.24,0:26:14.84,csapp,,0,0,0,,which might be quite large there could be lots of allocated blocks 
Dialogue: 0,0:26:15.88,0:26:17.76,csapp,,0,0,0,,in this case with an explicit list 
Dialogue: 0,0:26:18.98,0:26:23.64,csapp,,0,0,0,,any traversal just just be linear in the size of the free list 
Dialogue: 0,0:26:24.18,0:26:24.66,csapp,,0,0,0,,question
Dialogue: 0,0:26:25.92,0:26:29.74,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:26:29.76,0:26:33.02,csapp,,0,0,0,,yeah that's the question is done we need a free bit and we do
Dialogue: 0,0:26:33.62,0:26:35.96,csapp,,0,0,0,, and I'll we have that's the next question
Dialogue: 0,0:26:45.68,0:26:49.66,csapp,,0,0,0,,now another method a more sophisticated method instead of having one free list
Dialogue: 0,0:26:50.38,0:26:51.74,csapp,,0,0,0,,we can have multiple free lists 
Dialogue: 0,0:26:52.52,0:26:58.88,csapp,,0,0,0,,where each free list contains blocks of a certain size or certain range of sizes
Dialogue: 0,0:27:03.42,0:27:08.20,csapp,,0,0,0,,or we can get really fancy and use some kind of some kind of a balance tree 
Dialogue: 0,0:27:09.76,0:27:13.76,csapp,,0,0,0,,to sort the blocks to use the tree to sort them by size order 
Dialogue: 0,0:27:16.32,0:27:18.78,csapp,,0,0,0,,now today we're going to look at the implicit list 
Dialogue: 0,0:27:19.56,0:27:21.22,csapp,,0,0,0,,the simplest kind of free list 
Dialogue: 0,0:27:21.90,0:27:27.72,csapp,,0,0,0,,and this will identify a lot of basic concepts that are used in the more sophisticated free list 
Dialogue: 0,0:27:28.54,0:27:29.04,csapp,,0,0,0,,question 
Dialogue: 0,0:27:33.42,0:27:38.06,csapp,,0,0,0,,okay the question is what do you what do we mean by different free lists for different size classes 
Dialogue: 0,0:27:39.32,0:27:44.80,csapp,,0,0,0,,so what what I mean is that you identify a range of sizes
Dialogue: 0,0:27:45.96,0:27:50.10,csapp,,0,0,0,, and you associate that range with with each of these individual free lists 
Dialogue: 0,0:27:50.88,0:27:54.40,csapp,,0,0,0,,okay so one free list might hold blocks of size 0 to 8 
Dialogue: 0,0:27:55.42,0:27:58.64,csapp,,0,0,0,,and another free list might hold blocks of size 9 to 16
Dialogue: 0,0:27:59.72,0:28:04.06,csapp,,0,0,0,,and the other another free list may be 17 to 32 you know some 
Dialogue: 0,0:28:06.12,0:28:08.02,csapp,,0,0,0,,and so you're guaranteed you now know 
Dialogue: 0,0:28:10.44,0:28:15.50,csapp,,0,0,0,,when you're traversing a certain list you know the range of sizes of the blocks in that list 
Dialogue: 0,0:28:18.50,0:28:20.58,csapp,,0,0,0,,the the reason you might want to do that 
Dialogue: 0,0:28:20.88,0:28:27.26,csapp,,0,0,0,,by the way is that imagine you had an infinite number of of these  lists 
Dialogue: 0,0:28:28.06,0:28:29.70,csapp,,0,0,0,,one for each possible size 
Dialogue: 0,0:28:31.54,0:28:33.64,csapp,,0,0,0,,then every time you allocated a block 
Dialogue: 0,0:28:34.12,0:28:36.26,csapp,,0,0,0,,you'd get a block of exactly the size you needed
Dialogue: 0,0:28:37.52,0:28:43.86,csapp,,0,0,0,, so there'd be a minimum amount of fragmentation if you had an infinite number of these of these size classes
Dialogue: 0,0:28:44.78,0:28:47.42,csapp,,0,0,0,,now if we of course we can't have an infinite number but
Dialogue: 0,0:28:48.14,0:28:52.26,csapp,,0,0,0,, the more of these size classes we have the closer we get to that ideal
Dialogue: 0,0:28:55.56,0:28:59.80,csapp,,0,0,0,,all right so let's look at how we would build imprint implicit free lists
Dialogue: 0,0:29:01.20,0:29:03.54,csapp,,0,0,0,, so as you correctly point it out for each 
Dialogue: 0,0:29:04.42,0:29:08.08,csapp,,0,0,0,,each block we need we need both size and the allocation status 
Dialogue: 0,0:29:08.96,0:29:09.54,csapp,,0,0,0,,question
Dialogue: 0,0:29:09.84,0:29:17.00,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:29:17.42,0:29:19.40,csapp,,0,0,0,,why can't we map every size class
Dialogue: 0,0:29:19.56,0:29:32.40,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:29:32.40,0:29:35.44,csapp,,0,0,0,,yeah that's so why can't we have an infinite number of size classes
Dialogue: 0,0:29:43.62,0:29:48.40,csapp,,0,0,0,,I suppose you know that'd be an interesting strategy to to think about
Dialogue: 0,0:29:48.92,0:29:51.24,csapp,,0,0,0,,so you can't have an infinite number of size classes 
Dialogue: 0,0:29:51.50,0:29:56.10,csapp,,0,0,0,,but you could create a new size class for every new size that you get 
Dialogue: 0,0:29:57.04,0:30:02.64,csapp,,0,0,0,,and that that might work but it just depends on the the range of these size classes 
Dialogue: 0,0:30:03.40,0:30:09.00,csapp,,0,0,0,,and the frequency and one problem you might have is that you you would get 
Dialogue: 0,0:30:10.76,0:30:15.60,csapp,,0,0,0,, maybe if you only get it depends on the distribution of your sizes that you get 
Dialogue: 0,0:30:15.60,0:30:20.58,csapp,,0,0,0,,if you're getting an equal number if your distribution of sizes is is fairly uniform
Dialogue: 0,0:30:20.94,0:30:22.20,csapp,,0,0,0,, that would probably work pretty well 
Dialogue: 0,0:30:22.90,0:30:26.10,csapp,,0,0,0,,if you're getting if you have requests
Dialogue: 0,0:30:27.16,0:30:33.40,csapp,,0,0,0,, if if you have a lot of requests for different size classes you'd have a lot of sort of wasted free lists I think
Dialogue: 0,0:30:35.28,0:30:39.06,csapp,,0,0,0,,so it's a good question it depends on it depends on your workload 
Dialogue: 0,0:30:39.90,0:30:46.56,csapp,,0,0,0,,and there and that is for that and that is a really useful strategy for 
Dialogue: 0,0:30:47.48,0:30:51.44,csapp,,0,0,0,,so you if you have really popular size classes in your request
Dialogue: 0,0:30:52.38,0:30:58.46,csapp,,0,0,0,, then you could just make you know special case special case free lists to handle those requests
Dialogue: 0,0:30:59.68,0:31:03.26,csapp,,0,0,0,, and then and then let the other free list sort of handle a wider range 
Dialogue: 0,0:31:04.26,0:31:07.24,csapp,,0,0,0,,and imagine if you had a free list where all the blocks were the same 
Dialogue: 0,0:31:07.72,0:31:09.70,csapp,,0,0,0,,it could be a lot more efficient right because 
Dialogue: 0,0:31:10.60,0:31:12.80,csapp,,0,0,0,,you won't make you only need like a bit vector 
Dialogue: 0,0:31:13.68,0:31:17.62,csapp,,0,0,0,,1 1 bit for each potential block to tell you whether it's allocated or free 
Dialogue: 0,0:31:18.66,0:31:23.16,csapp,,0,0,0,,so it could be very efficient you wouldn't you wouldn't need to walk any any lists or anything
Dialogue: 0,0:31:26.88,0:31:32.04,csapp,,0,0,0,,that's a good question and that's the kind of thing you'll be thinking about when you do your Mallik lab it's one of
Dialogue: 0,0:31:34.22,0:31:38.50,csapp,,0,0,0,,the there's a huge design space in implementing malloc function 
Dialogue: 0,0:31:39.16,0:31:42.14,csapp,,0,0,0,,and we just we just explored a one tiny part of it just now
Dialogue: 0,0:31:44.68,0:31:50.82,csapp,,0,0,0,,so with this implicit list we're going to need both the size of the block 
Dialogue: 0,0:31:50.82,0:31:53.66,csapp,,0,0,0,,and then its allocation status whether it's allocated or free 
Dialogue: 0,0:31:54.28,0:31:57.24,csapp,,0,0,0,,now we could do this in two words right but that would be wasteful
Dialogue: 0,0:31:58.10,0:32:02.80,csapp,,0,0,0,,so the standard trick is to take advantage of the fact that blocks have to be aligned 
Dialogue: 0,0:32:04.42,0:32:08.02,csapp,,0,0,0,,okay so this is actually it's kind of a pain in the neck to always have to align these blocks 
Dialogue: 0,0:32:08.72,0:32:10.58,csapp,,0,0,0,,but we can take advantage of it in this case
Dialogue: 0,0:32:11.84,0:32:17.32,csapp,,0,0,0,,and the reason is is that if a block is aligned to some  say 8 by 8 or 16 byte boundary
Dialogue: 0,0:32:17.96,0:32:20.10,csapp,,0,0,0,, then the lower order bits are always going to be 0 
Dialogue: 0,0:32:20.80,0:32:22.56,csapp,,0,0,0,,so if it's aligned to an 8 byte boundary 
Dialogue: 0,0:32:23.30,0:32:27.48,csapp,,0,0,0,,the lower order 3 the 3 low order bits will always be 0
Dialogue: 0,0:32:28.08,0:32:30.78,csapp,,0,0,0,,right 8 is 1000. 
Dialogue: 0,0:32:31.62,0:32:34.14,csapp,,0,0,0,,16 10000
Dialogue: 0,0:32:35.72,0:32:38.50,csapp,,0,0,0,,24(=)11000 
Dialogue: 0,0:32:38.64,0:32:40.58,csapp,,0,0,0,,right so there any any 8 byte 
Dialogue: 0,0:32:42.80,0:32:51.92,csapp,,0,0,0,,any 8 byte aligned block has to be size 8 and it has to start on address that's a multiple of 8  all right 
Dialogue: 0,0:32:52.78,0:32:57.00,csapp,,0,0,0,,so those the the size will always the size of that block will always have 
Dialogue: 0,0:32:59.20,0:33:02.96,csapp,,0,0,0,,0 the 3 3 or 4 a low-order bits set to 0 
Dialogue: 0,0:33:03.88,0:33:05.85,csapp,,0,0,0,,so we can take it we can take advantage of that 
Dialogue: 0,0:33:06.42,0:33:11.84,csapp,,0,0,0,,and we'll just make will just have 1 I will just have one header word 
Dialogue: 0,0:33:13.20,0:33:17.18,csapp,,0,0,0,,and we'll use the lower order bit to store the allocation status 
Dialogue: 0,0:33:18.34,0:33:21.48,csapp,,0,0,0,,okay and we can do that because we know it's always zero 
Dialogue: 0,0:33:21.96,0:33:26.92,csapp,,0,0,0,,so when we so we use that low order bit to store the allocation status
Dialogue: 0,0:33:26.98,0:33:30.54,csapp,,0,0,0,, and then the remaining bits correspond to the size
Dialogue: 0,0:33:31.24,0:33:37.22,csapp,,0,0,0,, and then whenever we want to extract the size we just mask out this allocation status and always set it to zero 
Dialogue: 0,0:33:37.76,0:33:38.64,csapp,,0,0,0,,because we know that it's zero
Dialogue: 0,0:33:48.88,0:33:53.76,csapp,,0,0,0,,so let's look in detail what given this given this form of implicit list 
Dialogue: 0,0:33:54.62,0:33:56.08,csapp,,0,0,0,,how we might set things up 
Dialogue: 0,0:33:58.10,0:34:04.46,csapp,,0,0,0,,so in this case we're going to assume for bite words okay in sized words 
Dialogue: 0,0:34:05.66,0:34:07.78,csapp,,0,0,0,,and we're going to align on eight byte boundaries 
Dialogue: 0,0:34:10.46,0:34:15.56,csapp,,0,0,0,,okay so remember the payload of our blocks always has to start on an eight eight byte boundary 
Dialogue: 0,0:34:16.58,0:34:20.68,csapp,,0,0,0,,so the way we do that is we create this unused word at the beginning of the heap
Dialogue: 0,0:34:21.08,0:34:24.02,csapp,,0,0,0,, that's aligned on this eight byte boundary 
Dialogue: 0,0:34:25.02,0:34:31.42,csapp,,0,0,0,,and then the the first block and the heap starts at an offset of four from that
Dialogue: 0,0:34:32.24,0:34:33.28,csapp,,0,0,0,, from the beginning of the heap 
Dialogue: 0,0:34:34.26,0:34:37.48,csapp,,0,0,0,,so we have the header which is is not aligned 
Dialogue: 0,0:34:39.40,0:34:41.56,csapp,,0,0,0,,and then we have the payload which follows
Dialogue: 0,0:34:42.18,0:34:46.52,csapp,,0,0,0,, in this case it's a payload of one one word and that starts on this
Dialogue: 0,0:34:48.46,0:34:50.74,csapp,,0,0,0,, that begins on this this eight word boundary 
Dialogue: 0,0:34:50.74,0:34:58.88,csapp,,0,0,0,,and then the next block and and here we're indicating a free block consisting of eight bytes 
Dialogue: 0,0:35:01.50,0:35:03.64,csapp,,0,0,0,,and then that's followed by an allocated block
Dialogue: 0,0:35:04.24,0:35:08.28,csapp,,0,0,0,, the one here of sixteen bytes or four forwards
Dialogue: 0,0:35:11.88,0:35:16.12,csapp,,0,0,0,,and now the payload is only two words so we have to pad 
Dialogue: 0,0:35:17.12,0:35:21.28,csapp,,0,0,0,,right all of our blocks because we're assuming that they're aligned on eight byte boundary 
Dialogue: 0,0:35:21.74,0:35:25.40,csapp,,0,0,0,,all of our blocks have to be a multiple of size multiple of eight 
Dialogue: 0,0:35:26.38,0:35:29.56,csapp,,0,0,0,,okay so here's the case of internal fragmentation where we have this extra
Dialogue: 0,0:35:30.42,0:35:33.14,csapp,,0,0,0,, this extra block in order to maintain the alignment requirement 
Dialogue: 0,0:35:33.76,0:35:42.16,csapp,,0,0,0,,so that that ensures that the next block payload starts at a an eight byte aligned boundary and so on
Dialogue: 0,0:35:43.70,0:35:48.24,csapp,,0,0,0,,and so we can walk this heap by just following these headers masking out the allocation bits 
Dialogue: 0,0:35:49.50,0:35:54.00,csapp,,0,0,0,,and then we have this special epilogue block 
Dialogue: 0,0:35:55.00,0:35:59.62,csapp,,0,0,0,,which is a zero it's a block of with a zero sized payload
Dialogue: 0,0:36:00.86,0:36:02.96,csapp,,0,0,0,,it's an allocated block of size zero 
Dialogue: 0,0:36:04.26,0:36:06.44,csapp,,0,0,0,,and this is a this is a trick 
Dialogue: 0,0:36:06.84,0:36:08.38,csapp,,0,0,0,,this is a trick you should use to 
Dialogue: 0,0:36:09.14,0:36:13.56,csapp,,0,0,0,,so this and we'll see when we look at coalescing why this is  why this helps
Dialogue: 0,0:36:13.70,0:36:16.64,csapp,,0,0,0,, but this this allocated block at the very end
Dialogue: 0,0:36:17.16,0:36:21.72,csapp,,0,0,0,,eliminates some sort of special cases when we when we start to coalesce free blocks 
Dialogue: 0,0:36:22.52,0:36:25.16,csapp,,0,0,0,,we'll talk about that in just a just a moment 
Dialogue: 0,0:36:26.16,0:36:27.96,csapp,,0,0,0,,but you can finish your 
Dialogue: 0,0:36:28.64,0:36:34.22,csapp,,0,0,0,,like this this this this allocated block of size zero is also helpful in terminating 
Dialogue: 0,0:36:34.82,0:36:36.00,csapp,,0,0,0,,when you're walking this list 
Dialogue: 0,0:36:36.00,0:36:40.46,csapp,,0,0,0,,you can you can check for a size allocated block of size zero to terminate your search
Dialogue: 0,0:36:44.06,0:36:47.28,csapp,,0,0,0,,okay so given this kind of structure then how do we find a free block 
Dialogue: 0,0:36:48.36,0:36:50.02,csapp,,0,0,0,,okay there's a there's a number of different ways 
Dialogue: 0,0:36:50.74,0:36:53.82,csapp,,0,0,0,,the first the first way which is called first fit up 
Dialogue: 0,0:36:54.42,0:36:57.98,csapp,,0,0,0,,first fit is to search the free list from the beginning
Dialogue: 0,0:36:58.38,0:37:03.04,csapp,,0,0,0,,and just look for the first block we can find that satisfies the request 
Dialogue: 0,0:37:07.06,0:37:10.74,csapp,,0,0,0,,so we're allocating we're asking for a block of size 10 
Dialogue: 0,0:37:11.20,0:37:15.36,csapp,,0,0,0,,we start at the beginning of the heap and we walked a list we walk the heap 
Dialogue: 0,0:37:17.12,0:37:20.60,csapp,,0,0,0,,looking for a free block that's at least size 10 
Dialogue: 0,0:37:23.08,0:37:26.88,csapp,,0,0,0,,and we needs to be actually it needs to be 10 plus the size of our header 2 
Dialogue: 0,0:37:29.68,0:37:30.04,csapp,,0,0,0,,so once 
Dialogue: 0,0:37:32.68,0:37:34.64,csapp,,0,0,0,,so that's a simple idea now 
Dialogue: 0,0:37:35.12,0:37:38.10,csapp,,0,0,0,,some people have proposed an alternative called next fit
Dialogue: 0,0:37:38.72,0:37:44.78,csapp,,0,0,0,,so the idea here is that instead of starting over each time from the beginning of the heap  to find a block that fits
Dialogue: 0,0:37:45.62,0:37:47.90,csapp,,0,0,0,, we just pick up where we left off the last time 
Dialogue: 0,0:37:48.50,0:37:50.78,csapp,,0,0,0,,okay so we look we scan the heap 
Dialogue: 0,0:37:51.72,0:37:55.08,csapp,,0,0,0,,and we find a block that's that's big enough to satisfy the request
Dialogue: 0,0:37:55.16,0:37:57.48,csapp,,0,0,0,,and then we remember where that where we left off 
Dialogue: 0,0:37:58.82,0:38:02.98,csapp,,0,0,0,,and the next time the request comes in we pick up the search starting where we left off 
Dialogue: 0,0:38:04.04,0:38:08.76,csapp,,0,0,0,,now this seems like would be a good idea but but studies peer achill studies that people have done
Dialogue: 0,0:38:09.26,0:38:13.02,csapp,,0,0,0,, have shown that this actually results in worse fragmentation 
Dialogue: 0,0:38:13.74,0:38:18.26,csapp,,0,0,0,,so you know you can you can consider it but it it generally 
Dialogue: 0,0:38:19.06,0:38:21.14,csapp,,0,0,0,,it's generally probably not the best thing to do 
Dialogue: 0,0:38:22.86,0:38:29.52,csapp,,0,0,0,,now another alternative is to find that the Block in the heap
Dialogue: 0,0:38:29.58,0:38:32.52,csapp,,0,0,0,,  if a free block in the heap that's the best fit 
Dialogue: 0,0:38:33.30,0:38:40.40,csapp,,0,0,0,,so look at so in general look at all the blocks in the heap and find the block that fits the best 
Dialogue: 0,0:38:41.50,0:38:43.08,csapp,,0,0,0,,ok so if we ask for 10 bytes 
Dialogue: 0,0:38:44.58,0:38:48.40,csapp,,0,0,0,,try to scan the heap for the block that has the closest to 10 bytes in it 
Dialogue: 0,0:38:49.34,0:38:50.52,csapp,,0,0,0,,okay so that's called best fit 
Dialogue: 0,0:38:51.34,0:38:57.42,csapp,,0,0,0,,and best fit you can see it might be more it sounds like it would be a lot more expensive right 
Dialogue: 0,0:38:57.74,0:39:00.54,csapp,,0,0,0,,because you'd have to look instead of just looking until you find a fit 
Dialogue: 0,0:39:00.90,0:39:03.70,csapp,,0,0,0,,you'd have to scan all the free blocks and then pick the best one
Dialogue: 0,0:39:04.82,0:39:08.02,csapp,,0,0,0,,okay but it has a nice property that it improves memory utilization 
Dialogue: 0,0:39:09.48,0:39:12.72,csapp,,0,0,0,,okay so if this isn't this is a classic example the space time trade-off 
Dialogue: 0,0:39:13.44,0:39:18.74,csapp,,0,0,0,,so it's slower but it improves it improves our use of the efficiency of the way we use memory
Dialogue: 0,0:39:24.04,0:39:24.82,csapp,,0,0,0,,and there's 
Dialogue: 0,0:39:26.68,0:39:33.46,csapp,,0,0,0,,now we mentioned we mentioned an alternative way to organize the free list using multiple free lists for different size classes 
Dialogue: 0,0:39:34.74,0:39:38.20,csapp,,0,0,0,,now going back to that example again if we had an infinite number of size classes 
Dialogue: 0,0:39:38.22,0:39:42.16,csapp,,0,0,0,,one for each size that would implement best fit
Dialogue: 0,0:39:42.66,0:39:47.56,csapp,,0,0,0,,with a constant time search we don't we'd know exactly which free list  to get the block from
Dialogue: 0,0:39:49.58,0:39:54.02,csapp,,0,0,0,, the problem of course is how much memory such  a organization would use
Dialogue: 0,0:39:55.42,0:39:59.32,csapp,,0,0,0,, but the interesting thing about using multiple free lists 
Dialogue: 0,0:39:59.90,0:40:06.28,csapp,,0,0,0,,is that the more the more of these free lists you have the closer you get to it to a true best fit 
Dialogue: 0,0:40:07.42,0:40:09.04,csapp,,0,0,0,,okay so you can approach best fit 
Dialogue: 0,0:40:09.70,0:40:12.22,csapp,,0,0,0,,and then at some point you begin to get diminishing returns 
Dialogue: 0,0:40:12.78,0:40:18.26,csapp,,0,0,0,,so so that's another sort of design decision is how many of these multiple free lists do you need and what 
Dialogue: 0,0:40:18.48,0:40:22.00,csapp,,0,0,0,,what's sort of what what should be the size ranges associated with them
Dialogue: 0,0:40:25.50,0:40:27.98,csapp,,0,0,0,,okay another question now once we found a block 
Dialogue: 0,0:40:28.06,0:40:30.60,csapp,,0,0,0,,so the application is made a call to malloc 
Dialogue: 0,0:40:32.86,0:40:36.98,csapp,,0,0,0,,the malloc package is look in the free list that somehow using some 
Dialogue: 0,0:40:37.50,0:40:40.80,csapp,,0,0,0,,some policy it's identified a block that 
Dialogue: 0,0:40:41.08,0:40:44.34,csapp,,0,0,0,, in which the requested block a free block in which the requested block will fit 
Dialogue: 0,0:40:45.94,0:40:51.00,csapp,,0,0,0,,okay so now what does it do it has to the malloc package has to allocate
Dialogue: 0,0:40:52.48,0:40:53.64,csapp,,0,0,0,, it has to sort of take that
Dialogue: 0,0:40:57.14,0:41:00.82,csapp,,0,0,0,, but so there's a question how does it it could allocate the whole block 
Dialogue: 0,0:41:02.28,0:41:06.98,csapp,,0,0,0,,and return that back to the programmer or it could it could choose to split out
Dialogue: 0,0:41:07.70,0:41:11.72,csapp,,0,0,0,, a portion just only the portion of block that's needed and then create a smaller free block 
Dialogue: 0,0:41:14.06,0:41:19.46,csapp,,0,0,0,,okay so for example if if we if our 
Dialogue: 0,0:41:20.54,0:41:24.98,csapp,,0,0,0,,if our application is has requested a block of size 4 
Dialogue: 0,0:41:26.14,0:41:26.90,csapp,,0,0,0,,or I'm sorry 
Dialogue: 0,0:41:27.64,0:41:32.87,csapp,,0,0,0,,it if the malloc package is determined that that it in order to satisfy the application request
Dialogue: 0,0:41:32.87,0:41:34.50,csapp,,0,0,0,,it needs a block of size 4 
Dialogue: 0,0:41:36.16,0:41:37.58,csapp,,0,0,0,,okay including the header 
Dialogue: 0,0:41:39.28,0:41:45.28,csapp,,0,0,0,,then it would look and it would try to find a free block  of at least size forward 
Dialogue: 0,0:41:45.36,0:41:50.20,csapp,,0,0,0,,so let's say it chooses this block for some reason 
Dialogue: 0,0:41:50.78,0:41:54.10,csapp,,0,0,0,,maybe because it was a next fit picked up here
Dialogue: 0,0:41:55.50,0:41:57.26,csapp,,0,0,0,,so this free block is actually six
Dialogue: 0,0:42:00.25,0:42:01.98,csapp,,0,0,0,,contains six words 
Dialogue: 0,0:42:04.38,0:42:07.36,csapp,,0,0,0,,so the allocator has to decide whether just to keep this block of size six 
Dialogue: 0,0:42:07.40,0:42:12.02,csapp,,0,0,0,,and just return that back to the to the application 
Dialogue: 0,0:42:12.98,0:42:18.06,csapp,,0,0,0,,or whether to split that block into two blocks into an allocated block of size four 
Dialogue: 0,0:42:18.82,0:42:24.62,csapp,,0,0,0,, which it then returns to the application  followed by a free block of of size two
Dialogue: 0,0:42:30.96,0:42:34.38,csapp,,0,0,0,,okay now another question  is  how to free a block 
Dialogue: 0,0:42:34.38,0:42:39.82,csapp,,0,0,0,,so the application is requested the elec is called free and it's asked the allocator to free up a particular block 
Dialogue: 0,0:42:41.88,0:42:43.22,csapp,,0,0,0,,so this is pretty simple
Dialogue: 0,0:42:48.06,0:42:51.32,csapp,,0,0,0,,so if we want to free up this block you just clear the allocated flag 
Dialogue: 0,0:42:52.92,0:42:54.94,csapp,,0,0,0,,so if we want to free up the block we just created 
Dialogue: 0,0:42:55.80,0:42:58.84,csapp,,0,0,0,, you just clear you just set the allocated bit to zero 
Dialogue: 0,0:42:59.64,0:43:01.08,csapp,,0,0,0,,and you're done it's really simple 
Dialogue: 0,0:43:01.76,0:43:05.68,csapp,,0,0,0,,but the problem now is this this creates external fragmentation 
Dialogue: 0,0:43:07.50,0:43:11.92,csapp,,0,0,0,,so here now if if we just free that block of size for 
Dialogue: 0,0:43:13.06,0:43:15.04,csapp,,0,0,0,,what used to be a block of size six 
Dialogue: 0,0:43:16.24,0:43:21.48,csapp,,0,0,0,,now consists of two contiguous smaller blocks one of size four and one of size two 
Dialogue: 0,0:43:24.08,0:43:27.14,csapp,,0,0,0,,and so now if that's followed by a request for five blocks 
Dialogue: 0,0:43:27.90,0:43:29.32,csapp,,0,0,0,,now we're stuck right so this 
Dialogue: 0,0:43:30.96,0:43:33.82,csapp,,0,0,0,,but we've got plenty of memory and it's even worse in this case
Dialogue: 0,0:43:34.96,0:43:37.16,csapp,,0,0,0,, that memory is all contiguous just because 
Dialogue: 0,0:43:38.72,0:43:42.62,csapp,,0,0,0,,but just because we just oh we just cleared the free block 
Dialogue: 0,0:43:43.30,0:43:46.92,csapp,,0,0,0,,we didn't we didn't really notice that it was contiguous 
Dialogue: 0,0:43:46.94,0:43:50.56,csapp,,0,0,0,,and so we ended up in with the situation where we have these two contiguous free blocks
Dialogue: 0,0:43:54.82,0:43:56.62,csapp,,0,0,0,,so this this suggests that 
Dialogue: 0,0:43:57.32,0:43:59.10,csapp,,0,0,0,,when we do when we free up blocks
Dialogue: 0,0:44:00.04,0:44:03.66,csapp,,0,0,0,, that we somehow need to coalesce any neighboring blocks
Dialogue: 0,0:44:04.28,0:44:06.74,csapp,,0,0,0,,to keep blocks as big as possible right so we cannot 
Dialogue: 0,0:44:08.00,0:44:11.62,csapp,,0,0,0,,one of the invariance of any decent allocator is that
Dialogue: 0,0:44:12.94,0:44:15.86,csapp,,0,0,0,, they're never there never contiguous free blocks like this 
Dialogue: 0,0:44:16.32,0:44:19.82,csapp,,0,0,0,,it's always a free block followed by an allocated block 
Dialogue: 0,0:44:22.72,0:44:28.00,csapp,,0,0,0,,okay so the idea is that if we free a particular so here we have this allocated block 
Dialogue: 0,0:44:29.78,0:44:34.22,csapp,,0,0,0,,and if we free that block and we somehow have to check
Dialogue: 0,0:44:34.22,0:44:38.68,csapp,,0,0,0,, and see if there's any adjacent free blocks either following
Dialogue: 0,0:44:39.64,0:44:43.20,csapp,,0,0,0,,either neck either next in memory or previous in memory 
Dialogue: 0,0:44:44.26,0:44:48.14,csapp,,0,0,0,,and if there are we need to as part of the freeing process
Dialogue: 0,0:44:48.14,0:44:54.00,csapp,,0,0,0,,we need to coalesce those two blocks into a into a larger block the largest possible block possible 
Dialogue: 0,0:44:55.24,0:45:01.36,csapp,,0,0,0,,now it's pretty easy if we're if we're asked to free this block this green block 
Dialogue: 0,0:45:02.78,0:45:05.80,csapp,,0,0,0,,it's pretty easy to check the the next block because you just 
Dialogue: 0,0:45:06.36,0:45:08.04,csapp,,0,0,0,,we have the size we have this header 
Dialogue: 0,0:45:08.94,0:45:11.66,csapp,,0,0,0,,so we know that the next block starts at an offset of four 
Dialogue: 0,0:45:13.06,0:45:16.08,csapp,,0,0,0,,so we just we just  we just check 
Dialogue: 0,0:45:16.84,0:45:19.72,csapp,,0,0,0,,we know and we know that the header for that block is at your offset of four 
Dialogue: 0,0:45:20.20,0:45:24.10,csapp,,0,0,0,,so we just check the allocated status of that next block using the 
Dialogue: 0,0:45:24.46,0:45:27.40,csapp,,0,0,0,,using the size using the size field in our header 
Dialogue: 0,0:45:27.94,0:45:29.16,csapp,,0,0,0,,but what about the previous block 
Dialogue: 0,0:45:30.86,0:45:32.64,csapp,,0,0,0,,what about this block how do we check that
Dialogue: 0,0:45:34.86,0:45:37.40,csapp,,0,0,0,,well given given all that we've talked about 
Dialogue: 0,0:45:37.40,0:45:41.14,csapp,,0,0,0,,now the only thing the only way we could do it would be to start at the beginning of the heap 
Dialogue: 0,0:45:42.22,0:45:48.98,csapp,,0,0,0,,and now walk the free list until we get to this current block  remembering the previous block 
Dialogue: 0,0:45:49.35,0:45:53.54,csapp,,0,0,0,,so each time we each time we traverse we remember the previous block 
Dialogue: 0,0:45:54.66,0:45:57.76,csapp,,0,0,0,,okay so that but that would be very inefficient right that would be 
Dialogue: 0,0:45:58.68,0:46:02.06,csapp,,0,0,0,,that what that would make free linear in the size of the heat
Dialogue: 0,0:46:02.62,0:46:07.06,csapp,,0,0,0,,because we'd have to in order to check the previous block we'd have to walk starting at the very beginning
Dialogue: 0,0:46:07.42,0:46:08.64,csapp,,0,0,0,,and walk the entire heap 
Dialogue: 0,0:46:10.72,0:46:17.44,csapp,,0,0,0,,so the solution for that is was proposed by a famous computer scientist Don Knuth in 1973
Dialogue: 0,0:46:17.96,0:46:21.12,csapp,,0,0,0,,it's very clever it very simple like all really good ideas
Dialogue: 0,0:46:21.76,0:46:29.24,csapp,,0,0,0,, it seems obvious that when you see it but it turns out to be very clever and a very very useful technique 
Dialogue: 0,0:46:29.76,0:46:33.58,csapp,,0,0,0,, and the idea is just to replicate for each block 
Dialogue: 0,0:46:33.62,0:46:37.96,csapp,,0,0,0,,replicate the header block at the end of the block
Dialogue: 0,0:46:38.70,0:46:43.90,csapp,,0,0,0,,okay so each block now contains a header and a footer identical header and footer
Dialogue: 0,0:46:45.70,0:46:49.96,csapp,,0,0,0,,and then this creates sort of an implicit backwards 
Dialogue: 0,0:46:51.88,0:46:53.18,csapp,,0,0,0,,backwards link that we can use 
Dialogue: 0,0:46:55.22,0:46:58.46,csapp,,0,0,0,,so now given given some block 
Dialogue: 0,0:46:58.52,0:47:03.08,csapp,,0,0,0,,that we want to given some block that we want to free 
Dialogue: 0,0:47:04.62,0:47:11.96,csapp,,0,0,0,,we knew the size of that block will just be one one word previous in memory so
Dialogue: 0,0:47:12.86,0:47:16.78,csapp,,0,0,0,,  so we can just and it's always a fixed fixed offset of one word 
Dialogue: 0,0:47:18.64,0:47:22.60,csapp,,0,0,0,,so given you know given a pointer to the header of this block 
Dialogue: 0,0:47:22.70,0:47:27.84,csapp,,0,0,0,,we can look one word back to see the size and the allocated allocation status of the previous block 
Dialogue: 0,0:47:28.86,0:47:31.92,csapp,,0,0,0,,okay so and so that allows us to do that in constant time
Dialogue: 0,0:47:33.30,0:47:38.98,csapp,,0,0,0,,and so this footer is sometimes called the boundary tag  and Knuth call that a boundary tag 
Dialogue: 0,0:47:38.98,0:47:46.62,csapp,,0,0,0,,but we'll just and we can call it a footer  to be sort of parallel with with with the notion of a header
Dialogue: 0,0:47:47.26,0:47:51.88,csapp,,0,0,0,,but the the key thing is that it's just identical has the identical size and allocation status
Dialogue: 0,0:47:55.56,0:47:57.78,csapp,,0,0,0,,and also given yes question 
Dialogue: 0,0:48:02.50,0:48:06.68,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:48:06.68,0:48:08.58,csapp,,0,0,0,,so the question is if we want to have a boundary tag 
Dialogue: 0,0:48:08.58,0:48:12.26,csapp,,0,0,0,,when we allocate a block do we need to set aside space for it and the answer is yes 
Dialogue: 0,0:48:15.38,0:48:20.84,csapp,,0,0,0,,most of the time I'll show you a one I'll show you one optimization in a bit 
Dialogue: 0,0:48:24.54,0:48:29.86,csapp,,0,0,0,,okay so given given this idea of a over the boundary tag 
Dialogue: 0,0:48:34.36,0:48:38.31,csapp,,0,0,0,,and and and given that we have some allocated block that we want to free
Dialogue: 0,0:48:39.24,0:48:40.04,csapp,,0,0,0,,this yellow block 
Dialogue: 0,0:48:41.18,0:48:41.74,csapp,,0,0,0,,yes question
Dialogue: 0,0:48:41.74,0:48:52.24,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:48:52.24,0:48:57.52,csapp,,0,0,0,,yeah we so they quit yeah so just to summarize the question
Dialogue: 0,0:48:59.60,0:49:02.76,csapp,,0,0,0,, you need to when you allocate when you're looking for blocks that fit 
Dialogue: 0,0:49:02.76,0:49:06.64,csapp,,0,0,0,,you have to include the the size of the header and the boundary tag
Dialogue: 0,0:49:06.64,0:49:11.34,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:49:11.34,0:49:17.60,csapp,,0,0,0,, it would you then you'd have and then you have to insert padding to get a size a total block size
Dialogue: 0,0:49:17.72,0:49:22.44,csapp,,0,0,0,, that's a multiple of that set of multiple that satisfies your alignment requirement
Dialogue: 0,0:49:24.04,0:49:24.78,csapp,,0,0,0,,sorry 
Dialogue: 0,0:49:28.26,0:49:30.08,csapp,,0,0,0,,yeah I mean it can yeah 
Dialogue: 0,0:49:30.74,0:49:36.80,csapp,,0,0,0,,if you have it the question is wouldn't I use a lot of memory and it can if again it depends on the requests
Dialogue: 0,0:49:37.70,0:49:41.60,csapp,,0,0,0,, the request pattern if if the application is requesting lots of small payloads then
Dialogue: 0,0:49:42.38,0:49:44.20,csapp,,0,0,0,,then it's going to it's going to waste a lot of memory
Dialogue: 0,0:49:44.50,0:49:47.40,csapp,,0,0,0,, if it's requesting big payloads not so bad
Dialogue: 0,0:49:52.44,0:49:55.34,csapp,,0,0,0,,okay so given that we have some block that we want to free 
Dialogue: 0,0:49:55.88,0:49:59.94,csapp,,0,0,0,,there's four cases that we need to consider when when coalescing 
Dialogue: 0,0:50:00.86,0:50:05.86,csapp,,0,0,0,,the case where the the next block is allocated and the previous block is free is allocated 
Dialogue: 0,0:50:08.66,0:50:11.84,csapp,,0,0,0,,a case where the next block is free and the previous block is allocated 
Dialogue: 0,0:50:13.26,0:50:19.76,csapp,,0,0,0,,a case where the the previous block is free and the next block is allocated in the case where both the previous and next block are free 
Dialogue: 0,0:50:22.56,0:50:25.54,csapp,,0,0,0,,okay so in case one where we have our allocated block 
Dialogue: 0,0:50:26.70,0:50:29.86,csapp,,0,0,0,,that we want to free surrounded by two allocated blocks 
Dialogue: 0,0:50:30.68,0:50:33.32,csapp,,0,0,0,,we don't do anything right because we only call us free memory 
Dialogue: 0,0:50:35.34,0:50:41.46,csapp,,0,0,0,,so so in this case we just set keep the size of the header and footer stays the same 
Dialogue: 0,0:50:41.48,0:50:45.64,csapp,,0,0,0,,and we just set the allocation status to to shift free
Dialogue: 0,0:50:49.84,0:50:55.16,csapp,,0,0,0,,now if the if the next block is is free and the previous block is allocated 
Dialogue: 0,0:50:56.58,0:51:01.76,csapp,,0,0,0,,what we do is we we check the boundary tag of the the previous block 
Dialogue: 0,0:51:01.76,0:51:04.26,csapp,,0,0,0,,and we see that it's allocated so there's nothing to do there 
Dialogue: 0,0:51:06.12,0:51:09.72,csapp,,0,0,0,,we use the size to check the allocation status of the next block 
Dialogue: 0,0:51:10.72,0:51:13.70,csapp,,0,0,0,,we use n to jump to the header of the next block 
Dialogue: 0,0:51:14.62,0:51:17.84,csapp,,0,0,0,,we see that it's allocations status is free 
Dialogue: 0,0:51:18.86,0:51:21.28,csapp,,0,0,0,,so these two blocks need to be coalesced 
Dialogue: 0,0:51:23.06,0:51:30.08,csapp,,0,0,0,,so we do that by just adding adding the two sizes together to create this larger coalesce block 
Dialogue: 0,0:51:30.12,0:51:32.68,csapp,,0,0,0,,and setting its allocation status to zero
Dialogue: 0,0:51:35.30,0:51:38.56,csapp,,0,0,0,,now in the case where the previous block is is free 
Dialogue: 0,0:51:39.82,0:51:45.26,csapp,,0,0,0,,again we we check the boundary tech footer when we see that it's we see it it's free 
Dialogue: 0,0:51:46.66,0:51:49.34,csapp,,0,0,0,,so in this case we create 
Dialogue: 0,0:51:50.64,0:51:59.78,csapp,,0,0,0,,we have to update the size of the the old the header of the old previous block to create this now new larger coalesce block 
Dialogue: 0,0:52:00.16,0:52:03.84,csapp,,0,0,0,,can we and we update the header and the boundary check footer accordingly
Dialogue: 0,0:52:07.18,0:52:09.78,csapp,,0,0,0,, and then in the case where where both the previous 
Dialogue: 0,0:52:10.48,0:52:12.42,csapp,,0,0,0,,and the next block are free 
Dialogue: 0,0:52:16.08,0:52:17.30,csapp,,0,0,0,,we create a single block 
Dialogue: 0,0:52:20.84,0:52:24.10,csapp,,0,0,0,,a single block that's the sum of all three of those sizes
Dialogue: 0,0:52:27.92,0:52:29.54,csapp,,0,0,0,,okay so is that is that clear to everybody
Dialogue: 0,0:52:36.54,0:52:38.78,csapp,,0,0,0,,now as you pointed out correctly pointed out that 
Dialogue: 0,0:52:39.32,0:52:42.36,csapp,,0,0,0,,boundary tags can create additional internal fragmentation
Dialogue: 0,0:52:42.72,0:52:45.88,csapp,,0,0,0,,because they're they're not part of payload so by definition 
Dialogue: 0,0:52:46.50,0:52:47.50,csapp,,0,0,0,,they're their overhead 
Dialogue: 0,0:52:48.84,0:52:55.24,csapp,,0,0,0,,and so you might you might ask yourself are there any cases where 
Dialogue: 0,0:52:56.94,0:52:58.38,csapp,,0,0,0,,you don't need a boundary tag
Dialogue: 0,0:53:06.78,0:53:08.42,csapp,,0,0,0,,so which which blocks need 
Dialogue: 0,0:53:10.64,0:53:12.40,csapp,,0,0,0,,which blocks need a boundary tag
Dialogue: 0,0:53:29.50,0:53:31.56,csapp,,0,0,0,,could you get away with does an allocated block need one?
Dialogue: 0,0:53:47.82,0:53:52.56,csapp,,0,0,0,,yeah you're if you're not going to if you're not if you don't need to coalesce
Dialogue: 0,0:53:54.08,0:53:57.62,csapp,,0,0,0,,and you don't need to that footer and what kind of blocks don't you call us
Dialogue: 0,0:54:00.06,0:54:01.00,csapp,,0,0,0,,allocated blocks
Dialogue: 0,0:54:05.40,0:54:06.14,csapp,,0,0,0,,  so what
Dialogue: 0,0:54:09.18,0:54:14.76,csapp,,0,0,0,,so maybe we can maybe maybe we don't need those at those boundary tech footers on allocated blocks 
Dialogue: 0,0:54:15.30,0:54:16.48,csapp,,0,0,0,,right just on free blocks 
Dialogue: 0,0:54:18.40,0:54:20.62,csapp,,0,0,0,,but then how are we going to determine that the previous
Dialogue: 0,0:54:21.56,0:54:23.10,csapp,,0,0,0,, block is allocated or free
Dialogue: 0,0:54:24.38,0:54:28.08,csapp,,0,0,0,, if an allocated block doesn't have a boundary tag footer 
Dialogue: 0,0:54:30.22,0:54:30.54,csapp,,0,0,0,,yes 
Dialogue: 0,0:54:30.54,0:54:36.60,csapp,,0,0,0,,sorry 
Dialogue: 0,0:54:36.60,0:54:38.64,csapp,,0,0,0,,well yeah you would give it one when you free it 
Dialogue: 0,0:54:39.44,0:54:43.32,csapp,,0,0,0,,but somehow when we're doing coalescing we need to check somehow that that previous block 
Dialogue: 0,0:54:44.00,0:54:46.08,csapp,,0,0,0,,whether it's allocated or free okay 
Dialogue: 0,0:54:50.10,0:54:52.66,csapp,,0,0,0,,but how does it know it's whether it's a boundary tag
Dialogue: 0,0:54:55.66,0:54:58.66,csapp,,0,0,0,,or not not sure no that's okay 
Dialogue: 0,0:54:59.28,0:55:06.14,csapp,,0,0,0,,okay yes
Dialogue: 0,0:55:06.26,0:55:11.22,csapp,,0,0,0,, bingo you got it so remember this remember remember because of our alignment
Dialogue: 0,0:55:13.06,0:55:18.44,csapp,,0,0,0,, we've got we've got multiple at least three bits in three or four bits that are always zero
Dialogue: 0,0:55:19.96,0:55:21.08,csapp,,0,0,0,,we're only using one of them 
Dialogue: 0,0:55:22.32,0:55:26.96,csapp,,0,0,0,,so why not use another one to contain the allocation status of the previous block
Dialogue: 0,0:55:28.50,0:55:32.02,csapp,,0,0,0,,okay so very good that was
Dialogue: 0,0:55:39.72,0:55:40.72,csapp,,0,0,0,,it's so the idea 
Dialogue: 0,0:55:45.08,0:55:46.70,csapp,,0,0,0,,so here's the block that we want to free 
Dialogue: 0,0:55:48.00,0:55:48.96,csapp,,0,0,0,,and here's its header 
Dialogue: 0,0:55:51.34,0:55:53.92,csapp,,0,0,0,,and we pass the P to it and we wonder if we want to free it 
Dialogue: 0,0:55:54.68,0:55:57.42,csapp,,0,0,0,,and we've got we've got one bit we know that
Dialogue: 0,0:55:58.72,0:56:00.78,csapp,,0,0,0,, if we have a eight byte alignment 
Dialogue: 0,0:56:01.56,0:56:03.54,csapp,,0,0,0,,we know that these are all implicitly zero 
Dialogue: 0,0:56:04.82,0:56:11.82,csapp,,0,0,0,,so we're using this is a allocated block that we want to free so it has an allocation status of 1 
Dialogue: 0,0:56:14.98,0:56:18.72,csapp,,0,0,0,,and let's use this let's use one of these spare bits 
Dialogue: 0,0:56:19.92,0:56:22.96,csapp,,0,0,0,,to indicate the allocation status of the previous block
Dialogue: 0,0:56:24.72,0:56:25.60,csapp,,0,0,0,,okay so far 
Dialogue: 0,0:56:28.04,0:56:32.26,csapp,,0,0,0,,if the previous block is is allocated 
Dialogue: 0,0:56:34.36,0:56:35.44,csapp,,0,0,0,,and this would be a 1 
Dialogue: 0,0:56:37.54,0:56:40.20,csapp,,0,0,0,,and when we're checking to see whether we need to coalesce 
Dialogue: 0,0:56:40.70,0:56:43.14,csapp,,0,0,0,,we just check that we just check that 
Dialogue: 0,0:56:43.86,0:56:47.40,csapp,,0,0,0,,that that's 2nd allocated bit the allocated bit of the previous block
Dialogue: 0,0:56:48.48,0:56:51.78,csapp,,0,0,0,,and if it's 1 we don't need to know  what its size is 
Dialogue: 0,0:56:52.42,0:56:55.28,csapp,,0,0,0,,okay we don't need to know where that block is because we're not going to coalesce it 
Dialogue: 0,0:56:56.42,0:56:58.42,csapp,,0,0,0,,okay so in that we don't need 
Dialogue: 0,0:56:59.08,0:57:02.82,csapp,,0,0,0,,so here we don't need a boundary tag for an allocated block 
Dialogue: 0,0:57:04.32,0:57:07.76,csapp,,0,0,0,,but now if that if that block is free
Dialogue: 0,0:57:09.78,0:57:10.92,csapp,,0,0,0,, it'll have a boundary tag 
Dialogue: 0,0:57:13.58,0:57:15.58,csapp,,0,0,0,,so we'll check if that block is free
Dialogue: 0,0:57:18.06,0:57:24.62,csapp,,0,0,0,,  then the the allocation status will be will indicate free 
Dialogue: 0,0:57:25.50,0:57:28.06,csapp,,0,0,0,,and then we know we need to we need to coalesce 
Dialogue: 0,0:57:28.92,0:57:29.78,csapp,,0,0,0,,and we're going to need
Dialogue: 0,0:57:31.66,0:57:36.24,csapp,,0,0,0,,we're going to need a boundary tag because we need to know where that block starts we need to know its size 
Dialogue: 0,0:57:37.16,0:57:39.76,csapp,,0,0,0,,so that we can go back and 
Dialogue: 0,0:57:40.22,0:57:45.88,csapp,,0,0,0,,and update this size to include the  you know the total coalesce size of those two blocks
Dialogue: 0,0:57:48.88,0:57:51.90,csapp,,0,0,0,,so is that that clear yes 
Dialogue: 0,0:57:55.54,0:57:58.24,csapp,,0,0,0,,oh I just uh it's just the allocated bit so 
Dialogue: 0,0:57:58.66,0:58:01.16,csapp,,0,0,0,,zero means not allocated one means allocated
Dialogue: 0,0:58:09.80,0:58:13.22,csapp,,0,0,0,,oh why are those bits that are why are the bits always zero why 
Dialogue: 0,0:58:14.38,0:58:19.66,csapp,,0,0,0,,okay so blocks have to be aligned to eight byte boundaries 
Dialogue: 0,0:58:20.60,0:58:23.44,csapp,,0,0,0,,okay oil payloads have to be aligned to eight byte boundaries
Dialogue: 0,0:58:24.72,0:58:31.74,csapp,,0,0,0,, okay that means that that blocks have to be the size of blocks has to be a multiple of eight
Dialogue: 0,0:58:33.20,0:58:37.08,csapp,,0,0,0,,because it's the same thing as when we were doing padding alignment instructs
Dialogue: 0,0:58:37.82,0:58:42.40,csapp,,0,0,0,,the next each block has to be a size has to be a multiple of eight 
Dialogue: 0,0:58:42.80,0:58:48.08,csapp,,0,0,0,, so that the the block that follows that in memory is aligned properly 
Dialogue: 0,0:58:48.24,0:58:51.42,csapp,,0,0,0,, okay so you're guaranteed because of the alignment requirement 
Dialogue: 0,0:58:51.42,0:58:58.74,csapp,,0,0,0,,you're guaranteed that of eight or sixteen you're guaranteed that the size of the blocks are always multiples of either 8 or 16 
Dialogue: 0,0:58:59.90,0:59:05.28,csapp,,0,0,0,,okay and so that and that so that because that size is always a multiple of eight or sixteen
Dialogue: 0,0:59:05.76,0:59:12.52,csapp,,0,0,0,,you're guaranteed that either three or four four bits are all zeros
Dialogue: 0,0:59:17.22,0:59:18.14,csapp,,0,0,0,,okay
Dialogue: 0,0:59:23.18,0:59:24.10,csapp,,0,0,0,,any other questions
Dialogue: 0,0:59:32.50,0:59:35.22,csapp,,0,0,0,, okay let me summarize then some key policies 
Dialogue: 0,0:59:37.48,0:59:39.28,csapp,,0,0,0,,when when implementing an allocator 
Dialogue: 0,0:59:39.56,0:59:44.66,csapp,,0,0,0,,and I mentioned that there's the design spaces for these things is really large and really interesting
Dialogue: 0,0:59:45.36,0:59:50.72,csapp,,0,0,0,,there's a lot of things that you a lot of decisions that you have to make about various policies 
Dialogue: 0,0:59:51.64,0:59:53.82,csapp,,0,0,0,,so the first is the placement policy where 
Dialogue: 0,0:59:54.70,0:59:59.12,csapp,,0,0,0,,when we when we're trying to find when we're trying to place a free block 
Dialogue: 0,1:00:00.12,1:00:01.02,csapp,,0,0,0,,I mean and out 
Dialogue: 0,1:00:01.60,1:00:05.72,csapp,,0,0,0,,when we're trying to place an allocated block somewhere in a free block somewhere in the list 
Dialogue: 0,1:00:06.34,1:00:10.08,csapp,,0,0,0,,what what what policy do we use first fit next fit or best fit 
Dialogue: 0,1:00:11.24,1:00:16.62,csapp,,0,0,0,,and generally these things they trade-off throughput for fragmentation
Dialogue: 0,1:00:17.54,1:00:23.18,csapp,,0,0,0,, all right so the the faster faster versions like
Dialogue: 0,1:00:27.68,1:00:32.06,csapp,,0,0,0,,if you're willing to if you're willing to deal with with lower throughput like in the case of best fit 
Dialogue: 0,1:00:33.42,1:00:35.28,csapp,,0,0,0,,then you can get better memory utilization 
Dialogue: 0,1:00:38.46,1:00:43.94,csapp,,0,0,0,,now there are interesting there are interesting ways to improve the performance of best fit
Dialogue: 0,1:00:44.78,1:00:47.20,csapp,,0,0,0,, you might you might consider something like good fit
Dialogue: 0,1:00:48.28,1:00:51.42,csapp,,0,0,0,, which is sort of a mix of first fit and best fit so maybe 
Dialogue: 0,1:00:51.86,1:00:53.28,csapp,,0,0,0,,maybe you only search the first 
Dialogue: 0,1:00:55.38,1:00:58.08,csapp,,0,0,0,,you know a portion of the heap and then identify the best fit 
Dialogue: 0,1:00:58.40,1:01:00.54,csapp,,0,0,0,,you know maybe instead of searching the entire heap 
Dialogue: 0,1:01:01.14,1:01:03.30,csapp,,0,0,0,,you just search some some portion of the heap 
Dialogue: 0,1:01:03.70,1:01:08.72,csapp,,0,0,0,,and then cut off the search and then within that region that you search do you pick the best block 
Dialogue: 0,1:01:10.94,1:01:13.24,csapp,,0,0,0,,so that's something that called good fit 
Dialogue: 0,1:01:15.04,1:01:17.02,csapp,,0,0,0,,so that that kind of approximates best fit
Dialogue: 0,1:01:18.88,1:01:22.22,csapp,,0,0,0,,  or you can use these multiple free lists to approximate best fit 
Dialogue: 0,1:01:22.88,1:01:28.82,csapp,,0,0,0,,and that's and then and there you the real advantage of using multiple free lists
Dialogue: 0,1:01:29.90,1:01:32.66,csapp,,0,0,0,,Is that it not only improves memory utilization 
Dialogue: 0,1:01:32.68,1:01:37.22,csapp,,0,0,0,,but it improves performance too because the individual lists that you're looking for 
Dialogue: 0,1:01:37.74,1:01:41.48,csapp,,0,0,0,,you know that they contain blocks that are close to what you're asking for 
Dialogue: 0,1:01:42.74,1:01:48.98,csapp,,0,0,0,,and since you're dividing all the free blocks up amongst multiple amongst multiple free lists 
Dialogue: 0,1:01:49.64,1:01:50.86,csapp,,0,0,0,,those free lists will be shorter
Dialogue: 0,1:01:51.84,1:01:53.68,csapp,,0,0,0,,okay so your searches will take less time 
Dialogue: 0,1:01:54.40,1:01:58.26,csapp,,0,0,0,,and your your probability of finding a block that fits goes up
Dialogue: 0,1:01:59.18,1:02:02.18,csapp,,0,0,0,,because you're segregating these different size classes
Dialogue: 0,1:02:05.34,1:02:09.84,csapp,,0,0,0,,now there's a we also have to decide on some splitting policy so 
Dialogue: 0,1:02:10.82,1:02:13.40,csapp,,0,0,0,,when we find when we find a free block that's big enough 
Dialogue: 0,1:02:14.14,1:02:17.92,csapp,,0,0,0,,what do we do with the leftover the leftover part of that block 
Dialogue: 0,1:02:18.14,1:02:22.86,csapp,,0,0,0,,you know once we placed our allocated block into that into that free block 
Dialogue: 0,1:02:23.38,1:02:26.12,csapp,,0,0,0,,what do we do with the leftovers do we just leave the leftover part 
Dialogue: 0,1:02:26.70,1:02:29.63,csapp,,0,0,0,,in the block itself and return that back to the application
Dialogue: 0,1:02:30.18,1:02:34.38,csapp,,0,0,0,,you know avoiding so that  sort of keeping keeping larger blocks 
Dialogue: 0,1:02:35.28,1:02:38.40,csapp,,0,0,0,,or do we go ahead and split it like like I showed before 
Dialogue: 0,1:02:38.96,1:02:46.42,csapp,,0,0,0,,and splitting we go ahead and splitting that block and creating the creating the original free block
Dialogue: 0,1:02:47.32,1:02:50.66,csapp,,0,0,0,,allocating a portion of it and then creating a smaller free block 
Dialogue: 0,1:02:51.58,1:02:55.22,csapp,,0,0,0,,so that's you know that's a policy we may you may want to 
Dialogue: 0,1:02:55.76,1:02:59.64,csapp,,0,0,0,,you may want to for small requests for small payloads y
Dialogue: 0,1:02:59.64,1:03:06.92,csapp,,0,0,0,,You may up to a certain size you may not want to split so you may not you may decide not to split blocks smaller 
Dialogue: 0,1:03:08.08,1:03:13.86,csapp,,0,0,0,,you may not you may decide not to create free blocks that are smaller than some threshold 
Dialogue: 0,1:03:15.18,1:03:18.46,csapp,,0,0,0,,and only splitting for 4 requests for larger blocks 
Dialogue: 0,1:03:20.28,1:03:22.80,csapp,,0,0,0,,and then there's the there's a coalescing policy 
Dialogue: 0,1:03:25.02,1:03:31.52,csapp,,0,0,0,,now we've seen freeing is pretty quick now  it's constant time because of the boundary tag footers 
Dialogue: 0,1:03:32.44,1:03:34.74,csapp,,0,0,0,,but you may you may want to 
Dialogue: 0,1:03:35.56,1:03:40.82,csapp,,0,0,0,,you may want to try to just speed that up even more by by deferring the coalescing 
Dialogue: 0,1:03:42.28,1:03:46.16,csapp,,0,0,0,,so you could you can do coalescing it 
Dialogue: 0,1:03:47.70,1:03:50.64,csapp,,0,0,0,,every time the free is called like like we just looked at 
Dialogue: 0,1:03:51.92,1:03:54.86,csapp,,0,0,0,,or you could defer coalescing to some later time 
Dialogue: 0,1:03:55.12,1:03:57.60,csapp,,0,0,0,,you know maybe when you're scanning the free list 
Dialogue: 0,1:03:58.52,1:04:00.04,csapp,,0,0,0,,when you're scanning the free list looking 
Dialogue: 0,1:04:00.88,1:04:05.34,csapp,,0,0,0,, set try trying to find trying to place an allocated block in response to a malloc call 
Dialogue: 0,1:04:06.04,1:04:11.16,csapp,,0,0,0,,maybe as you scan that free list you could go ahead and do the coalescing at that time 
Dialogue: 0,1:04:13.78,1:04:17.74,csapp,,0,0,0,,right so I'm not saying which one is better it's hard to it's really hard to argue for
Dialogue: 0,1:04:18.18,1:04:26.00,csapp,,0,0,0,,deferred colas and giving the constant time performance of   a boundary tag-based coalescing 
Dialogue: 0,1:04:25.98,1:04:27.37,csapp,,0,0,0,,but it but it is an option
Dialogue: 0,1:04:31.12,1:04:33.30,csapp,,0,0,0,,okay so here's the summary then of implicit lists 
Dialogue: 0,1:04:34.62,1:04:36.52,csapp,,0,0,0,,this is the simplest well
Dialogue: 0,1:04:38.06,1:04:40.26,csapp,,0,0,0,,it's a very simple kind of allocator i
Dialogue: 0,1:04:41.02,1:04:44.14,csapp,,0,0,0,,it's it's 
Dialogue: 0,1:04:44.98,1:04:50.72,csapp,,0,0,0,,the cost to allocate is linear in the in the size of the heap  worst case
Dialogue: 0,1:04:52.14,1:04:56.12,csapp,,0,0,0,, that the cost of free is constant time even with coalescing
Dialogue: 0,1:04:57.24,1:05:02.18,csapp,,0,0,0,, memory usage will be will depend on the placement policy first fit next fit or best fit 
Dialogue: 0,1:05:03.28,1:05:05.46,csapp,,0,0,0,,um it's not used in practice 
Dialogue: 0,1:05:06.54,1:05:11.10,csapp,,0,0,0,,because of the linear time the linear time cost of allocation 
Dialogue: 0,1:05:12.18,1:05:15.90,csapp,,0,0,0,,okay but it it can be used in sort of special-purpose 
Dialogue: 0,1:05:16.18,1:05:20.14,csapp,,0,0,0,,allocators where you have a small number of size classes maybe or 
Dialogue: 0,1:05:20.18,1:05:24.04,csapp,,0,0,0,,you have a very you know that you have a very small or a fairly small free list 
Dialogue: 0,1:05:25.86,1:05:31.08,csapp,,0,0,0,,but the ideas of splitting and coalescing that we looked at or general to all allocators 
Dialogue: 0,1:05:31.36,1:05:34.46,csapp,,0,0,0,,okay so the idea of a boundary tag boundary tag-based coalescing 
Dialogue: 0,1:05:34.98,1:05:40.30,csapp,,0,0,0,,is is u is used regardless of the structure of your free list 
Dialogue: 0,1:05:41.58,1:05:43.60,csapp,,0,0,0,,so implicit lists are useful to study
Dialogue: 0,1:05:44.86,1:05:47.52,csapp,,0,0,0,,because they introduce some important concepts
Dialogue: 0,1:05:47.58,1:05:52.42,csapp,,0,0,0,, but generally they're not they're not they're not that useful
Dialogue: 0,1:05:53.80,1:06:00.46,csapp,,0,0,0,,so next next class we'll look at some more sophisticated organizations of free less 
Dialogue: 0,1:06:00.68,1:06:05.40,csapp,,0,0,0,,the explicit list and multiple free lists in particular 
Dialogue: 0,1:06:06.98,1:06:10.52,csapp,,0,0,0,,alright so we'll see you then good luck on your shell lab due tonight 
Dialogue: 0,1:06:11.52,1:06:13.86,csapp,,0,0,0,,and we'll see you on Thursday
