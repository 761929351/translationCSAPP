[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 845
Active Line: 858
Video Position: 142535

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.94,English,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.86,0:00:03.68,English,,0,0,0,,很高兴再次见到你们
Dialogue: 0,0:00:05.02,0:00:08.52,English,,0,0,0,,今天我们继续学习异常控制流
Dialogue: 0,0:00:09.56,0:00:16.24,English,,0,0,0,,主要是看看一些高层次的机制，比如说 Linux 信号机制和 C 中的非本地跳转
Dialogue: 0,0:00:16.90,0:00:21.42,English,,0,0,0,,我们会把大多数时间花在信号机制上
Dialogue: 0,0:00:21.62,0:00:26.60,English,,0,0,0,,因为它有一些巧妙的地方会让你产生疑惑
Dialogue: 0,0:00:26.60,0:00:28.62,English,,0,0,0,,所以我们要我们要把大部分时间花在那里
Dialogue: 0,0:00:29.36,0:00:33.70,English,,0,0,0,,我也会提到非本地跳转的概念
Dialogue: 0,0:00:36.08,0:00:38.70,English,,0,0,0,,但是更详细的内容你得看你的课本
Dialogue: 0,0:00:38.84,0:00:43.40,English,,0,0,0,,还有幻灯片末尾的补充内容
Dialogue: 0,0:00:45.64,0:00:48.06,English,,0,0,0,,现在我们把注意力集中在信号上
Dialogue: 0,0:00:49.00,0:00:54.40,English,,0,0,0,,我想先说一丢丢 shell 程序的内容
Dialogue: 0,0:00:56.08,0:01:01.54,English,,0,0,0,,正如我们上次提到的，我们只有一种方法在 Linux 下创建进程
Dialogue: 0,0:01:01.56,0:01:03.24,English,,0,0,0,,那就是使用 fork 调用
Dialogue: 0,0:01:04.14,0:01:09.84,English,,0,0,0,,In fact the all of the processes on the system actually form a hierarchy
Dialogue: 0,0:01:09.88,0:01:15.68,English,,0,0,0,,当你启动系统时第一个创建的进程是 init 进程
Dialogue: 0,0:01:16.08,0:01:17.92,English,,0,0,0,,它的进程 id 是 1
Dialogue: 0,0:01:18.48,0:01:23.81,English,,0,0,0,,系统上其它所有的进程都是 init 进程的子进程
Dialogue: 0,0:01:24.68,0:01:29.04,English,,0,0,0,,init 进程启动时会创建守护进程
Dialogue: 0,0:01:29.76,0:01:33.38,English,,0,0,0,,守护进程一般是一个长期运行的程序，通常用来提供服务
Dialogue: 0,0:01:33.42,0:01:41.44,English,,0,0,0,,比如说 web 服务器，或者其它那些你希望一直在系统上运行的服务
Dialogue: 0,0:01:42.26,0:01:45.90,English,,0,0,0,,最后会创建登录进程，也就是登陆 shell
Dialogue: 0,0:01:46.50,0:01:49.34,English,,0,0,0,,它为用户提供了命令行接口
Dialogue: 0,0:01:50.10,0:01:52.48,English,,0,0,0,,所以当你登录到一个 Linux 系统
Dialogue: 0,0:01:53.10,0:01:55.84,English,,0,0,0,,你最后得到的是一个登陆 shell
Dialogue: 0,0:01:56.12,0:01:58.98,English,,0,0,0,,它希望你输入命令
Dialogue: 0,0:02:01.72,0:02:07.36,English,,0,0,0,,然后登陆 shell 会以你的身份执行程序
Dialogue: 0,0:02:08.52,0:02:11.92,English,,0,0,0,,所以当我们在 shell 里输入什么东西的时候
Dialogue: 0,0:02:13.00,0:02:21.62,English,,0,0,0,,比如说 ls 命令，我们其实是在要求 shell 运行名为 ls 的可执行程序
Dialogue: 0,0:02:22.80,0:02:25.68,English,,0,0,0,,那么接下来 shell 会做什么呢，它会创建一个子进程
Dialogue: 0,0:02:26.38,0:02:30.16,English,,0,0,0,,然后它会在这个子进程中执行 ls
Dialogue: 0,0:02:31.12,0:02:37.28,English,,0,0,0,,并且这个子进程也有可能创建其它的子进程
Dialogue: 0,0:02:40.36,0:02:44.34,English,,0,0,0,,所以其实 shell 这个程序和其它的程序没啥区别
Dialogue: 0,0:02:45.02,0:02:47.78,English,,0,0,0,,它们以用户的身份执行程序
Dialogue: 0,0:02:49.62,0:02:52.56,English,,0,0,0,,在 Linux 下，默认的 shell 叫做 bash
Dialogue: 0,0:02:52.72,0:03:01.66,English,,0,0,0,,但在早期版本的 UNIX 上也有其它的 shell
Dialogue: 0,0:03:02.26,0:03:07.38,English,,0,0,0,,sh 是最原始的 shell，它被称为 Bourne shell，因为它是由 Stephen Bourne 创造的
Dialogue: 0,0:03:07.82,0:03:10.26,English,,0,0,0,,还有当 Berkeley 推出他们的 UNIX 发行版时
Dialogue: 0,0:03:10.72,0:03:13.18,English,,0,0,0,,推出了一款叫做 csh 的 shell
Dialogue: 0,0:03:14.68,0:03:21.90,English,,0,0,0,,执行程序就是在 shell 中的一系列读/求值的步骤
Dialogue: 0,0:03:22.80,0:03:24.96,English,,0,0,0,,首先，shell 打印一个提示符
Dialogue: 0,0:03:25.84,0:03:30.96,English,,0,0,0,,然后等待你在命令行中输入一个命令，然后敲击 return
Dialogue: 0,0:03:32.24,0:03:38.14,English,,0,0,0,,通常来说，你输入的东西是一个命令，它仅仅是。。
Dialogue: 0,0:03:38.74,0:03:44.10,English,,0,0,0,,所以你输入的第一个东西是一个命令，然后再跟上用空格分隔开的可选参数
Dialogue: 0,0:03:44.90,0:03:50.90,English,,0,0,0,,所以一旦你输入一个命令和一些可选的参数，并且敲下 return
Dialogue: 0,0:03:51.72,0:04:00.36,English,,0,0,0,,shell 会检查文件末尾的字符，对终端来说是 ctrl-d
Dialogue: 0,0:04:00.60,0:04:04.56,English,,0,0,0,,如果是则退出，否则计算此命令行
Dialogue: 0,0:04:05.46,0:04:06.96,English,,0,0,0,,求值内容包括
Dialogue: 0,0:04:10.48,0:04:14.14,English,,0,0,0,,And then when it returns from the evaluation it just does the same thing over in it
Dialogue: 0,0:04:14.66,0:04:21.40,English,,0,0,0,,求值由以下几步开始
Dialogue: 0,0:04:22.50,0:04:24.18,English,,0,0,0,,它解析命令行
Dialogue: 0,0:04:25.92,0:04:32.76,English,,0,0,0,,在这个过程中，它获取命令行，在本例中是保存在 buff 里
Dialogue: 0,0:04:33.10,0:04:37.46,English,,0,0,0,,它会生成一个数组 argv，其中 argv[0] 是一个命令
Dialogue: 0,0:04:37.92,0:04:41.16,English,,0,0,0,,之后的 argv[1]，argv[2] 等是可选参数
Dialogue: 0,0:04:42.82,0:04:48.24,English,,0,0,0,,在 shell 中有个约定，那就是如果命令行以
Dialogue: 0,0:04:49.56,0:04:55.14,English,,0,0,0,,一个 & 符号作为结尾，那么你可以使 shell 在后台运行此作业
Dialogue: 0,0:04:56.02,0:04:58.18,English,,0,0,0,,这意味着 shell 不会等待这个作业完成
Dialogue: 0,0:04:58.78,0:05:00.68,English,,0,0,0,,Before it goes through its next read stub
Dialogue: 0,0:05:01.44,0:05:05.72,English,,0,0,0,,如果你输入的行里没有 & 符号
Dialogue: 0,0:05:05.72,0:05:10.38,English,,0,0,0,,那么你就是要求 shell 在前台运行此作业，shell 会等待它完成
Dialogue: 0,0:05:13.56,0:05:19.38,English,,0,0,0,,所以我们首先把这个命令行解析成一个 argv 数组
Dialogue: 0,0:05:19.42,0:05:25.46,English,,0,0,0,,然后我们要返回它是否以 & 符号结尾，bg 是后台的意思
Dialogue: 0,0:05:26.42,0:05:31.90,English,,0,0,0,,如果 argv[0] 为空，那么就是说我们只输入了一个 return，所以得到空行
Dialogue: 0,0:05:32.58,0:05:35.04,English,,0,0,0,,所以我们返回即可，不用管这些
Dialogue: 0,0:05:36.54,0:05:41.66,English,,0,0,0,,shell 也实现了一些内建的命令
Dialogue: 0,0:05:41.90,0:05:47.36,English,,0,0,0,,比如 jobs, bg, fg 这样的东西
Dialogue: 0,0:05:47.82,0:05:51.96,English,,0,0,0,,都是 shell 本身就实现了的内建命令的例子
Dialogue: 0,0:05:53.14,0:05:55.32,English,,0,0,0,,所以，如果你输入。。。如果你输入的第一个东西
Dialogue: 0,0:05:56.20,0:05:58.48,English,,0,0,0,,如果你输入的是一个内建的命令
Dialogue: 0,0:05:59.24,0:06:06.02,English,,0,0,0,,shell 会检查它，看看 argv[0] 是否是一个内建 shell 命令
Dialogue: 0,0:06:06.64,0:06:11.70,English,,0,0,0,,如果是，那么不管你让它干什么，它都会照做
Dialogue: 0,0:06:13.76,0:06:20.14,English,,0,0,0,,此外，如果它不是内建的，这意味着你在要求 shell 运行一些程序
Dialogue: 0,0:06:22.42,0:06:24.92,English,,0,0,0,,在这种情况下 shell 会 fork 一个子进程
Dialogue: 0,0:06:26.34,0:06:31.60,English,,0,0,0,,这个子进程会使用 execve 调用来运行这个程序
Dialogue: 0,0:06:32.98,0:06:35.50,English,,0,0,0,,将命令的名字作为第一个参数传递
Dialogue: 0,0:06:36.18,0:06:41.24,English,,0,0,0,,将环境信息分别作为 argv 的第二、第三个等等
Dialogue: 0,0:06:42.10,0:06:46.86,English,,0,0,0,,Now execve if you recall from last time never returns unless there's an error
Dialogue: 0,0:06:47.37,0:06:51.48,English,,0,0,0,,所以我们检查 execve 的返回值
Dialogue: 0,0:06:52.70,0:06:56.98,English,,0,0,0,,And if it returns less than zero fact the only time it will return
Dialogue: 0,0:06:57.54,0:07:01.90,English,,0,0,0,,如果它返回，那么它总是会返回 -1
Dialogue: 0,0:07:02.32,0:07:04.56,English,,0,0,0,,但我们在这得小心点
Dialogue: 0,0:07:05.24,0:07:12.32,English,,0,0,0,,我们检查是否有错误，如果有，那么把错误信息打印出来，然后退出
Dialogue: 0,0:07:15.26,0:07:22.06,English,,0,0,0,,一旦父进程再次获得控制权
Dialogue: 0,0:07:22.76,0:07:25.20,English,,0,0,0,,那么等待这个前台作业结束
Dialogue: 0,0:07:26.22,0:07:28.52,English,,0,0,0,,所以如果它不是个后台进程
Dialogue: 0,0:07:29.30,0:07:32.18,English,,0,0,0,,则通过调用 waitpid 等待进程结束
Dialogue: 0,0:07:33.34,0:07:38.70,English,,0,0,0,,然后等待那个前台作业结束，之后获取它
Dialogue: 0,0:07:39.44,0:07:43.96,English,,0,0,0,,如果它是个后台进程，那么输出一条信息并继续执行
Dialogue: 0,0:07:44.82,0:07:46.44,English,,0,0,0,,这里很有趣
Dialogue: 0,0:07:46.74,0:07:50.98,English,,0,0,0,,在 shell 中后台进程和前台进程相差的，仅仅是
Dialogue: 0,0:07:51.76,0:07:53.62,English,,0,0,0,,仅仅是有没有使用 waitpid
Dialogue: 0,0:07:54.02,0:07:57.46,English,,0,0,0,,除此之外没什么不同的地方
Dialogue: 0,0:07:58.78,0:08:03.68,English,,0,0,0,,那么现在出现什么问题了呢？我们的例子展示出来了一个
Dialogue: 0,0:08:05.88,0:08:09.88,English,,0,0,0,,那么问题是，我们对前台进程做了正确的事情
Dialogue: 0,0:08:10.40,0:08:13.72,English,,0,0,0,,我们需要收集它子进程的信息
Dialogue: 0,0:08:15.10,0:08:17.54,English,,0,0,0,,以便能够释放它们
Dialogue: 0,0:08:19.82,0:08:23.62,English,,0,0,0,,但是我们不会收集后台进程的任何东西
Dialogue: 0,0:08:23.80,0:08:26.78,English,,0,0,0,,Right when if the background job so if not bg
Dialogue: 0,0:08:27.26,0:08:29.38,English,,0,0,0,,我们仅仅显示一条信息就退出
Dialogue: 0,0:08:30.30,0:08:32.80,English,,0,0,0,,然后我们又开始执行 eval 步骤
Dialogue: 0,0:08:33.58,0:08:38.82,English,,0,0,0,,我们不会再去关心那个后台进程
Dialogue: 0,0:08:40.40,0:08:44.24,English,,0,0,0,,所以这就有个问题，后台进程最后会变成
Dialogue: 0,0:08:45.82,0:08:51.46,English,,0,0,0,,如果我们有太多这样的作业，，那么就会引起内存泄漏，这可能让系统崩溃掉，所以这是一处错误
Dialogue: 0,0:08:52.36,0:08:53.72,English,,0,0,0,,那么怎么解决呢
Dialogue: 0,0:08:54.38,0:08:59.10,English,,0,0,0,,很好，这就引出了异常控制流来帮助我们解决这个问题
Dialogue: 0,0:09:00.08,0:09:04.72,English,,0,0,0,,会发生什么呢，内核会告知
Dialogue: 0,0:09:05.18,0:09:08.54,English,,0,0,0,,会在 shell 的子进程结束时告知 shell
Dialogue: 0,0:09:09.78,0:09:14.82,English,,0,0,0,,Okay and then the shell can then react to that and issue a waitpid 接下来 shell 会对此作出反应，并放出
Dialogue: 0,0:09:15.46,0:09:21.18,English,,0,0,0,,好的，其实内核用到的这个通知机制就是所谓的信号
Dialogue: 0,0:09:25.92,0:09:28.22,English,,0,0,0,,所以信号就是一条小小的信息
Dialogue: 0,0:09:29.98,0:09:36.82,English,,0,0,0,,它通知进程系统中发生了一次某种类型的事件
Dialogue: 0,0:09:37.66,0:09:44.18,English,,0,0,0,,这与我们上次学习的异常机制很像
Dialogue: 0,0:09:44.34,0:09:47.52,English,,0,0,0,,当然，除了它是完全由软件实现的
Dialogue: 0,0:09:49.12,0:09:53.02,English,,0,0,0,,内核信号总是由内核发出的
Dialogue: 0,0:09:53.02,0:09:56.38,English,,0,0,0,,但有时它是在某些进程请求时发送的
Dialogue: 0,0:09:56.82,0:10:00.42,English,,0,0,0,,是的，有时内核会告知一些事件
Dialogue: 0,0:10:01.22,0:10:07.06,English,,0,0,0,,有时候某个进程会请求内核发送信息给另外一些进程
Dialogue: 0,0:10:08.52,0:10:11.52,English,,0,0,0,,我们说它是一条小小的信息
Dialogue: 0,0:10:12.22,0:10:15.42,English,,0,0,0,,是因为它仅仅只有信号的信息
Dialogue: 0,0:10:16.00,0:10:18.66,English,,0,0,0,,是一个唯一的整数
Dialogue: 0,0:10:19.66,0:10:23.50,English,,0,0,0,,是的，就是这样
Dialogue: 0,0:10:24.34,0:10:27.94,English,,0,0,0,,没错，除了它以外，信号中没啥别的
Dialogue: 0,0:10:28.18,0:10:31.88,English,,0,0,0,,这是一些特殊的信号 id
Dialogue: 0,0:10:33.04,0:10:37.26,English,,0,0,0,,比如说这个 sigint
Dialogue: 0,0:10:37.48,0:10:41.60,English,,0,0,0,,所以信号有，，这些独特的 id 都有自己的名字
Dialogue: 0,0:10:44.80,0:10:51.32,English,,0,0,0,,当你在命令行中按下 ctrl-c 的时候就会触发 sigint 信号
Dialogue: 0,0:10:51.64,0:10:56.90,English,,0,0,0,,内核向每个前台进程发送信号
Dialogue: 0,0:10:57.26,0:11:00.52,English,,0,0,0,,收到 sigint 时的默认操作是终止任务
Dialogue: 0,0:11:00.52,0:11:04.06,English,,0,0,0,,所以如果你对一个正在运行的前台任务按下 crtl-c
Dialogue: 0,0:11:04.52,0:11:07.08,English,,0,0,0,,你会得到一条提示，因为你 kill 了它
Dialogue: 0,0:11:08.36,0:11:13.84,English,,0,0,0,,信号 9 是 sigkill，可以在 kill 程序的时候用
Dialogue: 0,0:11:15.78,0:11:22.74,English,,0,0,0,,所以对我来说 sigint 和 sigkill 的效果是一样的，它们都 kill 了程序
Dialogue: 0,0:11:23.02,0:11:30.36,English,,0,0,0,,sigkill 的特殊之处是它不能被任何方式忽略或覆盖掉
Dialogue: 0,0:11:30.89,0:11:32.18,English,,0,0,0,,这就像失效保护一样
Dialogue: 0,0:11:33.36,0:11:38.48,English,,0,0,0,,我们很快就能看到有一些方法可以捕获并忽略其它像 sigint 这样的信号
Dialogue: 0,0:11:40.22,0:11:43.32,English,,0,0,0,,Sigsegv is the our favorite segment
Dialogue: 0,0:11:43.54,0:11:51.24,English,,0,0,0,,如果你试图访问受保护的，或不合法的内存区域，就会出现段错误
Dialogue: 0,0:11:52.48,0:11:57.74,English,,0,0,0,,然后我们的程序会，内核会向这个进程发送 sigsegv 信号
Dialogue: 0,0:11:58.46,0:12:06.40,English,,0,0,0,,信号和默认的效果是终止这个程序
Dialogue: 0,0:12:07.08,0:12:11.72,English,,0,0,0,,sigalrm 信号 是一种你可以自行安排的信号，你可以将信号发送给你自己
Dialogue: 0,0:12:12.32,0:12:18.94,English,,0,0,0,,所以你可以在你的程序里写每隔三秒给自己发送一个 sigalrm 信号
Dialogue: 0,0:12:21.58,0:12:27.00,English,,0,0,0,,所以这是一种设置定时器的方式，你可以按照你的需求设置超时
Dialogue: 0,0:12:27.60,0:12:32.88,English,,0,0,0,,如果你想设置一个超时变量并且做一些作业，比如
Dialogue: 0,0:12:33.28,0:12:39.76,English,,0,0,0,,你想要防止这项作业运行太长时间，你可以用 sigalrm 来设置超时
Dialogue: 0,0:12:40.64,0:12:46.72,English,,0,0,0,,那么接下来我们会看到有一个对 shell 来说非常重要的信号 sigchild
Dialogue: 0,0:12:47.30,0:12:54.48,English,,0,0,0,,每当子进程被终止或结束时 kernel 就会通知它们的父进程
Dialogue: 0,0:12:55.48,0:12:57.90,English,,0,0,0,,就是我们看到的
Dialogue: 0,0:12:58.44,0:13:02.58,English,,0,0,0,,我们会看到。。这就是 shell 回收进程的做法
Dialogue: 0,0:13:02.66,0:13:08.40,English,,0,0,0,,It's all of its children right is by taking advantage of the sigchild signal
Dialogue: 0,0:13:09.78,0:13:11.92,English,,0,0,0,,在我们看它之前
Dialogue: 0,0:13:12.46,0:13:18.58,English,,0,0,0,,我们得搞定关于信号的一些概念
Dialogue: 0,0:13:20.00,0:13:24.32,English,,0,0,0,,比如说我说过的信号的语义
Dialogue: 0,0:13:24.74,0:13:27.54,English,,0,0,0,,这可能是 Linux 上比较棘手的一个地方
Dialogue: 0,0:13:28.94,0:13:40.98,English,,0,0,0,,它是在 Linux 早期就出现的，可能不像你们想的那样简洁
Dialogue: 0,0:13:41.44,0:13:47.24,English,,0,0,0,,为了处理信号，我们定义术语时得非常小心
Dialogue: 0,0:13:47.62,0:13:48.88,English,,0,0,0,,我们现在就是在讨论这个
Dialogue: 0,0:13:50.26,0:13:57.46,English,,0,0,0,,所以我们说内核给目标进程发送或传递一个信号
Dialogue: 0,0:13:58.52,0:14:04.98,English,,0,0,0,,它通过为目标进程的上下文设置一些状态来实现
Dialogue: 0,0:14:05.76,0:14:14.00,English,,0,0,0,,除了目标进程上下文中的一些位被改变了，再没有其它的
Dialogue: 0,0:14:14.32,0:14:19.02,English,,0,0,0,,这里并没有影响。。直接发送信号的影响
Dialogue: 0,0:14:22.94,0:14:24.80,English,,0,0,0,,现在内核发送一个信号
Dialogue: 0,0:14:25.92,0:14:29.68,English,,0,0,0,,也可以是因为它监测到系统中的一些事件
Dialogue: 0,0:14:30.38,0:14:33.02,English,,0,0,0,,比如说一个子进程被终止
Dialogue: 0,0:14:34.66,0:14:41.42,English,,0,0,0,,Or another process has asked the kernel (to send) to deliver a process on a signal on its behalf
Dialogue: 0,0:14:43.38,0:14:47.04,English,,0,0,0,,有很多方式可以做到这一点，系统调用 kill 就是其中一种
Dialogue: 0,0:14:48.88,0:14:51.48,English,,0,0,0,,It's kind of an unfortunate tournament
Dialogue: 0,0:14:52.18,0:14:55.50,English,,0,0,0,,我的意思是说， kill 是一个发送信号的方式
Dialogue: 0,0:14:56.10,0:15:01.50,English,,0,0,0,,当然有时候 kill 掉一个程序不太好
Dialogue: 0,0:15:01.52,0:15:04.36,English,,0,0,0,,但因为某些理由，人们把它叫做 kill
Dialogue: 0,0:15:07.72,0:15:11.70,English,,0,0,0,,现在目标进程收到一个信号
Dialogue: 0,0:15:13.08,0:15:20.54,English,,0,0,0,,当内核强制它在收到信号后作出应答时
Dialogue: 0,0:15:22.34,0:15:29.02,English,,0,0,0,,好的，那么在设置目标进程上下文里的状态时，有两种差异很大的方式
Dialogue: 0,0:15:29.84,0:15:36.82,English,,0,0,0,,收到信号是目标进程最终发生的事情
Dialogue: 0,0:15:37.16,0:15:40.90,English,,0,0,0,,内核强制它以某种方式作出响应
Dialogue: 0,0:15:41.82,0:15:45.70,English,,0,0,0,,那么有个可行的响应是忽视此信号
Dialogue: 0,0:15:49.14,0:15:50.46,English,,0,0,0,,也可以终止此进程
Dialogue: 0,0:15:52.98,0:15:58.50,English,,0,0,0,,或者用用户级的信号处理函数来捕获它
Dialogue: 0,0:15:59.10,0:16:04.18,English,,0,0,0,,在这里我们捕获信号的方式很像。。
Dialogue: 0,0:16:04.94,0:16:06.38,English,,0,0,0,,执行一个信号处理程序
Dialogue: 0,0:16:06.38,0:16:13.74,English,,0,0,0,,很像响应某些系统事件的异常处理程序
Dialogue: 0,0:16:14.20,0:16:17.52,English,,0,0,0,,它们的区别在于异常处理是内核级别的
Dialogue: 0,0:16:18.18,0:16:21.28,English,,0,0,0,,信号处理实际上是在你的 C 代码里
Dialogue: 0,0:16:22.74,0:16:25.31,English,,0,0,0,,它们在你的程序里执行
Dialogue: 0,0:16:26.86,0:16:34.66,English,,0,0,0,,让我们想想如果我们用信号处理的方式捕获信号
Dialogue: 0,0:16:35.20,0:16:37.72,English,,0,0,0,,我们有我们的进程执行指令
Dialogue: 0,0:16:39.00,0:16:41.72,English,,0,0,0,,接着进程会收到信号
Dialogue: 0,0:16:43.02,0:16:47.10,English,,0,0,0,,所以内核将控制权转移给了信号处理程序
Dialogue: 0,0:16:47.10,0:16:55.14,English,,0,0,0,,它是一段仅仅在当前进程执行的代码，是你 C 代码里的一个函数，
Dialogue: 0,0:16:56.18,0:17:01.52,English,,0,0,0,,当这段信号处理程序执行完，它会返回到下一条指令
Dialogue: 0,0:17:02.22,0:17:04.00,English,,0,0,0,,接着我们继续
Dialogue: 0,0:17:04.24,0:17:08.70,English,,0,0,0,,好吧，这就像一次中断，我们先暂停一下
Dialogue: 0,0:17:09.36,0:17:16.22,English,,0,0,0,,在继续之前，我们要在处理程序里做什么呢
Dialogue: 0,0:17:18.98,0:17:21.16,English,,0,0,0,,我们说这个信号现在是待处理的
Dialogue: 0,0:17:21.80,0:17:25.98,English,,0,0,0,,如果它已经由内核发出但你还没有收到
Dialogue: 0,0:17:27.98,0:17:34.92,English,,0,0,0,,那么如果在某些给定的时刻，只能有一个相同类型的待处理信号
Dialogue: 0,0:17:36.84,0:17:40.70,English,,0,0,0,,这对使用信号来说有很大影响
Dialogue: 0,0:17:40.70,0:17:47.32,English,,0,0,0,,因为你无法随时提醒信号的接收，所以只能有一个待处理的 sigchild 信号
Dialogue: 0,0:17:47.66,0:17:51.02,English,,0,0,0,,信号的例子
Dialogue: 0,0:17:51.84,0:17:55.38,English,,0,0,0,,如果还有后续的 sigchild 信号被发送
Dialogue: 0,0:17:55.94,0:18:00.51,English,,0,0,0,,这上面已经写了，你可以想到，它是没有影响的
Dialogue: 0,0:18:00.78,0:18:04.04,English,,0,0,0,,如果已经有一个待处理的信号，那新来的就会被丢弃
Dialogue: 0,0:18:04.04,0:18:06.66,English,,0,0,0,,它们不存在排队的说法
Dialogue: 0,0:18:09.58,0:18:12.50,English,,0,0,0,,现在我们的进程可以阻塞某些信号的接收
Dialogue: 0,0:18:13.62,0:18:16.42,English,,0,0,0,,它没办法阻止信号的传递
Dialogue: 0,0:18:17.04,0:18:23.76,English,,0,0,0,,但是它可以阻止进程在收到信号后的响应
Dialogue: 0,0:18:27.84,0:18:34.10,English,,0,0,0,,所以被阻塞的信号可以被传递，但在阻塞解除前不能被接收
Dialogue: 0,0:18:38.88,0:18:41.30,English,,0,0,0,,还有，待处理信号最多被接收一次
Dialogue: 0,0:18:46.34,0:18:49.36,English,,0,0,0,,现在内核会跟踪这些待处理和阻塞的进程
Dialogue: 0,0:18:49.90,0:18:54.42,English,,0,0,0,,位向量中的信号会调用它们
Dialogue: 0,0:18:55.24,0:18:58.62,English,,0,0,0,,待处理表示所有待处理信号的集合
Dialogue: 0,0:18:58.74,0:19:04.24,English,,0,0,0,,待处理位向量中的每一个位都对应着一个特定的信号
Dialogue: 0,0:19:04.84,0:19:07.06,English,,0,0,0,,这就是为什么它们不会有排队的说法
Dialogue: 0,0:19:08.18,0:19:12.38,English,,0,0,0,,因为每一个信号仅有一个位表示，在位向量里只有一个位
Dialogue: 0,0:19:12.84,0:19:18.00,English,,0,0,0,,如果我们。。。当我们传递一个信号我们仅仅是在设置，设置那个位，内核会设置那个位
Dialogue: 0,0:19:18.30,0:19:24.26,English,,0,0,0,,我们传递同类型的另一个信号，它仅仅会再次设置那个位，其实什么都没有做
Dialogue: 0,0:19:26.80,0:19:32.68,English,,0,0,0,,当信号被传递过来时，内核设置这个位到待处理中，并且将对应位清零
Dialogue: 0,0:19:32.80,0:19:34.18,English,,0,0,0,,当信号被接收
Dialogue: 0,0:19:35.68,0:19:43.22,English,,0,0,0,,内核也向用户提供了可以阻塞信号的阻塞位向量
Dialogue: 0,0:19:43.22,0:19:49.34,English,,0,0,0,,阻塞位向量与待处理位向量基本相同，它们都是一个 32 位的 int 类型
Dialogue: 0,0:19:51.86,0:19:54.32,English,,0,0,0,,它可以被置位也可以被清零
Dialogue: 0,0:19:54.46,0:19:58.10,English,,0,0,0,,使用系统调用 sigprocmask 就可以置位或清零它
Dialogue: 0,0:19:59.10,0:20:05.18,English,,0,0,0,,在一些 Linux 资料中，阻塞位向量有时也被称为信号掩码
Dialogue: 0,0:20:10.28,0:20:14.40,English,,0,0,0,,那么我们来看看发送和接收信号的细节
Dialogue: 0,0:20:14.40,0:20:16.76,English,,0,0,0,,我们从发送信号开始
Dialogue: 0,0:20:18.56,0:20:21.34,English,,0,0,0,,我们首先得理解进程组的概念
Dialogue: 0,0:20:22.48,0:20:25.84,English,,0,0,0,,每一个进程都属于某个进程组
Dialogue: 0,0:20:28.38,0:20:31.48,English,,0,0,0,,在这里，我展示的这些，shell 也在一个进程中
Dialogue: 0,0:20:31.88,0:20:35.38,English,,0,0,0,,它的进程 id 是 10，进程组 id 是 10
Dialogue: 0,0:20:36.82,0:20:38.92,English,,0,0,0,,创建了一个前台作业
Dialogue: 0,0:20:41.12,0:20:44.80,English,,0,0,0,,它的进程 id 是 20，进程组 id 是 20
Dialogue: 0,0:20:45.34,0:20:51.88,English,,0,0,0,,这个前台作业创建的所有子进程都有相同的进程组 id 20
Dialogue: 0,0:20:53.94,0:20:59.20,English,,0,0,0,,这些进程组可以使用系统调用 setpgid 设置
Dialogue: 0,0:21:01.30,0:21:06.96,English,,0,0,0,,你也可以使用系统调用获取进程组 id
Dialogue: 0,0:21:07.62,0:21:14.04,English,,0,0,0,,你可以在例子中看到，shell 做了什么，它创建了一个前台子进程
Dialogue: 0,0:21:14.04,0:21:22.42,English,,0,0,0,,它创建了这个子进程并修改了它的进程组 id，使之等于它的进程 id
Dialogue: 0,0:21:24.06,0:21:27.04,English,,0,0,0,,当这个子进程创建了其它的子进程时
Dialogue: 0,0:21:27.68,0:21:30.52,English,,0,0,0,,它们会继承相同的进程组 id
Dialogue: 0,0:21:34.74,0:21:37.34,English,,0,0,0,,这个进程组的概念很有用
Dialogue: 0,0:21:37.78,0:21:43.26,English,,0,0,0,,这是因为它允许你可以同时给一组进程发送信号
Dialogue: 0,0:21:43.74,0:21:46.08,English,,0,0,0,,你可以用一个叫 kill 的程序做到
Dialogue: 0,0:21:46.64,0:21:49.46,English,,0,0,0,,它一般都在 /bin 目录下
Dialogue: 0,0:21:50.56,0:21:55.60,English,,0,0,0,,你可以用这个 kill 程序发送一个任意信号给
Dialogue: 0,0:21:55.78,0:22:00.56,English,,0,0,0,,给某个进程，或者某个进程组中的所有进程
Dialogue: 0,0:22:02.88,0:22:10.46,English,,0,0,0,,我们看一个例子，这个程序创建了两个子进程
Dialogue: 0,0:22:13.70,0:22:17.96,English,,0,0,0,,它们的进程组 id 是 24817
Dialogue: 0,0:22:18.86,0:22:21.86,English,,0,0,0,,当然，它们的进程 id 是不同的
Dialogue: 0,0:22:23.36,0:22:29.58,English,,0,0,0,,所以如果我们使用 ps 命令，可以看到有两个进程在运行
Dialogue: 0,0:22:30.90,0:22:34.50,English,,0,0,0,,它们陷入了死循环
Dialogue: 0,0:22:36.10,0:22:37.50,English,,0,0,0,,那么
Dialogue: 0,0:22:40.30,0:22:43.48,English,,0,0,0,,我们可以使用 kill 来 kill 掉某个进程
Dialogue: 0,0:22:44.00,0:22:51.08,English,,0,0,0,,比如，如果我们用第一个参数表示你想传递的信号
Dialogue: 0,0:22:51.08,0:22:55.30,English,,0,0,0,,在这里，信号 9 是 sigkill 信号
Dialogue: 0,0:22:55.88,0:23:02.98,English,,0,0,0,,kill -9 很常用，如果你想 kill 掉某个进程，那使用 kill -9 准没错
Dialogue: 0,0:23:03.94,0:23:13.10,English,,0,0,0,,实际上，我最喜欢的 213 自动实验室的昵称之一是 kill -9 15-213
Dialogue: 0,0:23:16.10,0:23:23.20,English,,0,0,0,,第二个参数是进程的 id
Dialogue: 0,0:23:23.22,0:23:29.54,English,,0,0,0,,所以这是请求内核 kill 进程 24818
Dialogue: 0,0:23:30.12,0:23:32.44,English,,0,0,0,,因为传递了 sigkill 信号
Dialogue: 0,0:23:33.64,0:23:38.58,English,,0,0,0,,如果在横杠符号之前出现了进程 id
Dialogue: 0,0:23:40.86,0:23:45.12,English,,0,0,0,,那么它的意思是发送信号给该进程组中的每一个进程
Dialogue: 0,0:23:45.64,0:23:48.30,English,,0,0,0,,它是被当作进程组 id 处理的
Dialogue: 0,0:23:48.78,0:23:52.46,English,,0,0,0,,它会发送信号给进程组中的每一个进程
Dialogue: 0,0:23:52.96,0:23:58.82,English,,0,0,0,,在这种情况下，它会向这两个子进程都发送信号
Dialogue: 0,0:24:00.48,0:24:05.40,English,,0,0,0,,这时我们再执行 ps，这两个进程都没了
Dialogue: 0,0:24:05.62,0:24:07.90,English,,0,0,0,,好的，的确如此
Dialogue: 0,0:24:09.78,0:24:15.24,English,,0,0,0,,另一种发送信号的方法是在命令行里
Dialogue: 0,0:24:15.62,0:24:18.26,English,,0,0,0,,使用 ctrl-c 或 ctrl-z
Dialogue: 0,0:24:19.44,0:24:25.50,English,,0,0,0,,会使内核向前台进程组下的所有作业发送信号
Dialogue: 0,0:24:25.84,0:24:35.58,English,,0,0,0,,而 ctrl-z 会使向所有前台进程组下的作业发送 sigtstp 信号
Dialogue: 0,0:24:36.38,0:24:39.28,English,,0,0,0,,sigint 的默认行为是终止进程
Dialogue: 0,0:24:39.28,0:24:43.88,English,,0,0,0,,sigtstp 信号的默认行为是挂起进程
Dialogue: 0,0:24:44.34,0:24:48.24,English,,0,0,0,,在收到 sigcont 信号之前停止它
Dialogue: 0,0:24:54.90,0:24:58.58,English,,0,0,0,,这有个例子，我们有这么一个程序
Dialogue: 0,0:25:00.90,0:25:07.27,English,,0,0,0,,创建一个父进程，其一个子进程在前台运行，当然父进程也在前台
Dialogue: 0,0:25:08.10,0:25:11.04,English,,0,0,0,,当我们在命令行敲下 ctrl-z
Dialogue: 0,0:25:12.70,0:25:16.36,English,,0,0,0,,会告诉我们它已经挂起了这个进程
Dialogue: 0,0:25:16.80,0:25:23.90,English,,0,0,0,,如果我们用 ps，呢么可以看到父进程和子进程都被挂起了
Dialogue: 0,0:25:23.94,0:25:28.72,English,,0,0,0,,So the ps indicates that it's suspended or stopped using T
Dialogue: 0,0:25:33.04,0:25:37.04,English,,0,0,0,,下面我们用 shell 内建的指令 fg
Dialogue: 0,0:25:37.16,0:25:42.36,English,,0,0,0,,fg 把这些被挂起的进程恢复到后台运行
Dialogue: 0,0:25:44.70,0:25:50.06,English,,0,0,0,,后面我们再输入 fg，我们的作业又到前台运行了
Dialogue: 0,0:25:51.58,0:25:54.28,English,,0,0,0,,接下来我们用 ctrl-c kill 掉它
Dialogue: 0,0:25:54.78,0:25:58.84,English,,0,0,0,,这会触发 sigint，它的默认行为是终止进程
Dialogue: 0,0:25:59.18,0:26:03.30,English,,0,0,0,,再使用 ps，它们都没了
Dialogue: 0,0:26:06.96,0:26:11.40,English,,0,0,0,,第三种发送信号的方式是使用系统调用 kill
Dialogue: 0,0:26:15.44,0:26:17.60,English,,0,0,0,,这是展示它如何工作的例子
Dialogue: 0,0:26:18.04,0:26:21.82,English,,0,0,0,,在这个例子中，我们创建了 N 个子进程
Dialogue: 0,0:26:23.00,0:26:25.14,English,,0,0,0,,且都陷入了死循环
Dialogue: 0,0:26:25.84,0:26:29.90,English,,0,0,0,,我们记录了所有创建的进程的进程 id
Dialogue: 0,0:26:31.92,0:26:34.90,English,,0,0,0,,然后我们到。。到另一个循环去
Dialogue: 0,0:26:34.90,0:26:40.02,English,,0,0,0,,我们使用 kill 函数 kill 掉了所有那些子进程
Dialogue: 0,0:26:40.74,0:26:45.56,English,,0,0,0,,Passing it the process id and the signal that we want sent to that process
Dialogue: 0,0:26:47.72,0:26:52.24,English,,0,0,0,,好的，我们回收了所有应该被回收的
Dialogue: 0,0:26:52.64,0:26:54.64,English,,0,0,0,,被我们终止的子进程
Dialogue: 0,0:26:55.56,0:27:02.28,English,,0,0,0,,Now this isn't strictly necessary because we're going to exit as soon as this fork12 function
Dialogue: 0,0:27:02.80,0:27:06.58,English,,0,0,0,,Returns we're going to exit the code so but we're just being
Dialogue: 0,0:27:07.38,0:27:11.90,English,,0,0,0,,You know careful here and maybe a little pedantic but
Dialogue: 0,0:27:16.02,0:27:20.26,English,,0,0,0,,Okay now let's look at how we process receive signals 好的，那我们来看看进程是如何接收信号的
Dialogue: 0,0:27:22.58,0:27:29.72,English,,0,0,0,,Now suppose process A is running along executing its user code and then 假设有一个进程 A，正在执行用户代码
Dialogue: 0,0:27:30.48,0:27:34.94,English,,0,0,0,,There's a control passes into the kernel because of some exception 然后由于出现了异常，控制权转移给内核
Dialogue: 0,0:27:36.12,0:27:40.36,English,,0,0,0,,Now that exception can be either a timer going off 这个异常可以是定时器到时
Dialogue: 0,0:27:40.90,0:27:45.12,English,,0,0,0,,They've been interrupts or it can be a trap user calls a system call 可以是一个中断或一个陷阱，用户调用系统调用
Dialogue: 0,0:27:45.76,0:27:50.50,English,,0,0,0,,Okay but it's always caused that the trap into the 但它通常用作陷阱
Dialogue: 0,0:27:51.20,0:27:54.26,English,,0,0,0,,Or the transferring control into the kernel is always caused by some exception 控制权转移到内核经常就经常由一些异常引起
Dialogue: 0,0:27:56.18,0:27:59.48,English,,0,0,0,,So at this point the kernel calls its scheduler function 在这里，内核调用它的调度函数
Dialogue: 0,0:28:00.12,0:28:07.34,English,,0,0,0,,And it decides do a context switch from process A to process B 它决定做一个从进程 A 到进程 B 的上下文切换
Dialogue: 0,0:28:09.46,0:28:15.50,English,,0,0,0,,And it gets processed B all set up and right before it returns from that exception 它在从异常返回之前会获取进程 B 的有关设置
Dialogue: 0,0:28:16.26,0:28:24.24,English,,0,0,0,,And right before it's ready to pass control back to process the user code and process B 在它准备好将控制权返还给进程用户代码和进程 B 之前
Dialogue: 0,0:28:25.30,0:28:29.34,English,,0,0,0,,It checks for any signals that any pending signals 它会检查所有待处理的信号
Dialogue: 0,0:28:32.58,0:28:38.50,English,,0,0,0,,Okay and it does this by computing a bit vector pnb so pending nonblocked 它通过计算位向量 pnb 来做到这一点，使之不会阻塞
Dialogue: 0,0:28:39.42,0:28:42.58,English,,0,0,0,,Which is the logical and of the pending bit vector
Dialogue: 0,0:28:44.00,0:28:46.48,English,,0,0,0,,And the inverse of the blocked bit vector 反转阻塞位向量
Dialogue: 0,0:28:47.74,0:28:52.10,English,,0,0,0,,Okay so pnb is a list of all the pending signals that aren't blocked pnb 是所有未阻塞待处理信号的列表
Dialogue: 0,0:28:53.34,0:28:56.08,English,,0,0,0,,Okay so these are all the pending signals that should be received 所以，所有的待处理信号都应该被接收了
Dialogue: 0,0:28:59.12,0:29:02.84,English,,0,0,0,,Now if pnb is all zeros then there's no pending signals 如果 pub 全为 0，那么就是说没有待处理的信号
Dialogue: 0,0:29:03.04,0:29:05.86,English,,0,0,0,,So it just returns it passes control back 只要返回，返还控制权就好
Dialogue: 0,0:29:07.18,0:29:10.98,English,,0,0,0,,It passes control back to process B which can continue executing 它将控制权返还给进程 B，让它可以继续执行
Dialogue: 0,0:29:11.64,0:29:14.18,English,,0,0,0,,However if pnb is nonzero then 然而，如果 pub 是非 0 的
Dialogue: 0,0:29:15.10,0:29:19.70,English,,0,0,0,,It chooses the smallest nonzero bit in pnb 那么它会选择 pub 中最小的非零位
Dialogue: 0,0:29:19.70,0:29:24.56,English,,0,0,0,,And it forces process p to receive that signal the corresponding signal 它会让进程 p 接收相应的信号
Dialogue: 0,0:29:27.74,0:29:32.20,English,,0,0,0,,The receipt of the signal triggers some action in the process 这个信号的接收会引起这个进程的一些行为
Dialogue: 0,0:29:36.24,0:29:44.34,English,,0,0,0,,And then we repeat that for all the nonzero signals k that are nonzero bits that are set in pnb 然后我们对 pub 中的每一个非零位对应的信号 k 重复此过程
Dialogue: 0,0:29:44.78,0:29:47.60,English,,0,0,0,,And finally when we've gone all through all the nonzero bits 最后我们会处理完所有的非零位
Dialogue: 0,0:29:48.14,0:29:56.70,English,,0,0,0,,Then we pass control to the next instruction in process p 接着我们将控制权转移给进程 p 的下一条指令
Dialogue: 0,0:30:00.72,0:30:03.96,English,,0,0,0,,所以每一个信号的接收都会触发一些行为
Dialogue: 0,0:30:04.46,0:30:06.93,English,,0,0,0,,也包括进程的终止
Dialogue: 0,0:30:07.86,0:30:11.40,English,,0,0,0,,线程在收到 sigcont 信号之前保持停止
Dialogue: 0,0:30:12.42,0:30:14.52,English,,0,0,0,,进程忽略这个信号
Dialogue: 0,0:30:15.36,0:30:18.42,English,,0,0,0,,这里有一些预定义的默认行为
Dialogue: 0,0:30:21.72,0:30:29.72,English,,0,0,0,,但我们可以使用一个叫做 signal 的系统调用来修改默认行为
Dialogue: 0,0:30:31.66,0:30:37.28,English,,0,0,0,,Ok so we can...now signals a little that's another sort of misleading kind of term just like kill right because when we 所以我们可以。。。
Dialogue: 0,0:30:37.74,0:30:40.50,English,,0,0,0,,When we send a signal to a process we don't always want to kill it 我们给一个进程发送信号时，并不是总是要 kill 掉它
Dialogue: 0,0:30:41.74,0:30:44.02,English,,0,0,0,,And signal doesn't actually signal anything
Dialogue: 0,0:30:44.40,0:30:49.22,English,,0,0,0,,It just modifies the default action associated with some something 它可以修改为与默认操作相关的某些操作
Dialogue: 0,0:30:50.74,0:30:55.02,English,,0,0,0,,Okay so if the signal function takes out a signal number(signum) 如果 signal 函数取出了一个信号数（signum）
Dialogue: 0,0:30:56.90,0:31:01.98,English,,0,0,0,,And then specifies a change in the default action for that signal
Dialogue: 0,0:31:04.16,0:31:07.46,English,,0,0,0,,And those default actions can be either to ignore the signal(sig_ign)
Dialogue: 0,0:31:08.30,0:31:14.96,English,,0,0,0,,Ok ignore signals of type signal,revert to the default behavior for that signal
Dialogue: 0,0:31:17.48,0:31:21.96,English,,0,0,0,,Or we can give it...or it can be the address of a user level signal handler 我们也可以给它一个。。。也可以是一个用户级信号处理函数的地址
Dialogue: 0,0:31:22.64,0:31:26.38,English,,0,0,0,,Which is a function that we've declared in our C program 也就是那个我们在 C 程序中定义的函数
Dialogue: 0,0:31:26.76,0:31:32.92,English,,0,0,0,,Ok there's nothing special about the function it has a certain prototype that has it takes a single argument 这个函数没什么特别的地方，它有一个明确声明了的信号参数
Dialogue: 0,0:31:33.60,0:31:40.06,English,,0,0,0,,Which is the signal number so when that function gets called in response to receiving a signal  就是这个信号编号，所以当响应这个被接收到的信号时这个函数会被调用
Dialogue: 0,0:31:41.24,0:31:44.02,English,,0,0,0,,That argument will be set to the signal number 然后这个参数会设置这个信号标号
Dialogue: 0,0:31:47.80,0:31:54.54,English,,0,0,0,,So calling signal with a specifying a signal handler is called installing a handler 所以用指定的信号处理函数调用信号，被称作
Dialogue: 0,0:31:55.42,0:31:59.68,English,,0,0,0,,And then executing the handlers referred to as catching or executing 然后将这个处理程序作为捕获或者执行运行
Dialogue: 0,0:31:59.68,0:32:01.52,English,,0,0,0,,They were handling the signal 这就是信号的处理
Dialogue: 0,0:32:03.78,0:32:06.64,English,,0,0,0,,And and this handler then is just like an exception handler 这些信号处理就像异常处理一样
Dialogue: 0,0:32:06.66,0:32:12.56,English,,0,0,0,,When it returns it will be when it's executed it will interrupt the 当它返回时，它会。。当它执行后，它会中断
Dialogue: 0,0:32:13.16,0:32:16.66,English,,0,0,0,,Whatever is currently executing in the process when it returns 当他返回时，不论这个进程执行到哪里
Dialogue: 0,0:32:16.92,0:32:19.94,English,,0,0,0,,It will return back to that point and continue executing 它都会返回到这里并继续执行
Dialogue: 0,0:32:22.74,0:32:26.74,English,,0,0,0,,Okay so here's a simple example of installing a handler 这是一个安装处理程序的例子
Dialogue: 0,0:32:28.62,0:32:32.48,English,,0,0,0,,So here in main where we're going to install a sigint handler 在 main 里，我们来安装 sigint 的处理程序
Dialogue: 0,0:32:34.92,0:32:38.80,English,,0,0,0,,Which is called sigint_handler which is defined up here 它叫做 sigint_handler，被定义在这
Dialogue: 0,0:32:39.80,0:32:43.12,English,,0,0,0,,And the prototype for this function is returns nothing 这个函数的原型没有返回值
Dialogue: 0,0:32:43.80,0:32:48.12,English,,0,0,0,,And it takes a single integer argument which is the signal number and returns nothing 它需要一个信号编号数字作为参数，并且没有返回值
Dialogue: 0,0:32:50.76,0:32:52.42,English,,0,0,0,,Okay and after we install that handler 然后我们来安装它
Dialogue: 0,0:32:53.12,0:32:59.24,English,,0,0,0,,Then we're going to execute the pause this call which just waits for a signal handler to execute
Dialogue: 0,0:32:59.48,0:33:03.20,English,,0,0,0,,Ok so pause terminates the current or suspends the current process
Dialogue: 0,0:33:04.28,0:33:08.38,English,,0,0,0,,Until a signal is received and a handler executes in that process
Dialogue: 0,0:33:08.92,0:33:10.68,English,,0,0,0,,And then pause then pause returns
Dialogue: 0,0:33:13.36,0:33:16.36,English,,0,0,0,,So we're going to wait until the sigint happens
Dialogue: 0,0:33:16.40,0:33:19.54,English,,0,0,0,,So sigint entry call is when we type ctrl-c 当我们按下 ctrl-c 时，sigint 开始执行
Dialogue: 0,0:33:21.98,0:33:27.04,English,,0,0,0,,So when you're doing your bombs did you panic at some point and try to hit ctrl-c to get out of it
Dialogue: 0,0:33:28.50,0:33:30.86,English,,0,0,0,,Okay so that snarky message you got that was
Dialogue: 0,0:33:32.04,0:33:37.20,English,,0,0,0,,We did that by installing a sigint handler in your bomb
Dialogue: 0,0:33:38.78,0:33:43.14,English,,0,0,0,,Okay so when you type ctrl-c that elicits a sigint 当你按下 ctrl-c 时，就会触发 sigint
Dialogue: 0,0:33:43.60,0:33:51.60,English,,0,0,0,,When that sigint is received,we printed this message and then eventually let you exit 收到 sigint 信号后，我们输出一条信息然后退出
Dialogue: 0,0:33:56.90,0:34:01.38,English,,0,0,0,,Now signals are another examples of concurrency 信号也是并发的一个例子
Dialogue: 0,0:34:02.16,0:34:06.92,English,,0,0,0,,Now we've seen concurrency earlier in the form of processes 我们已经见到过进程的并发了
Dialogue: 0,0:34:07.84,0:34:12.90,English,,0,0,0,,Right concurrent flows overlapping in time 并发流在时间上是重叠的
Dialogue: 0,0:34:14.14,0:34:19.32,English,,0,0,0,,Okay logical flows overlapping in time by definition are concurrent 逻辑流
Dialogue: 0,0:34:20.58,0:34:26.62,English,,0,0,0,,Now with processes the because they have separate address spaces 进程有它们各自的独立地址空间
Dialogue: 0,0:34:26.84,0:34:29.46,English,,0,0,0,,Those concurrent flows never interfere with each other 并发流不会妨碍彼此
Dialogue: 0,0:34:29.58,0:34:33.62,English,,0,0,0,,Right so in some sense processes are very easy to deal with 从某种意义上说，进程是很好处理的
Dialogue: 0,0:34:34.10,0:34:40.18,English,,0,0,0,,And we don't really have to worry one process doesn't have to worry about being interfered with by another process 我们不必担心一个进程。。不必担心被其它进程影响
Dialogue: 0,0:34:42.02,0:34:47.46,English,,0,0,0,,In fact you have to go to great lengths to share like to share things between processes 实际上，你必须想办法在进程之间共享东西
Dialogue: 0,0:34:47.46,0:34:53.78,English,,0,0,0,,You have to use specific system calls in order to say share memory between two processes 为了在两个进程间共享内存，你得使用特定的系统调用
Dialogue: 0,0:34:55.22,0:34:59.90,English,,0,0,0,,Now signals are another form of concurrency this is the second time in this class that 信号是并发的一种形式，这是这节课上第二次提到
Dialogue: 0,0:35:01.42,0:35:03.08,English,,0,0,0,,That you've experienced concurrency 现在你已经对并发有概念了
Dialogue: 0,0:35:03.98,0:35:08.22,English,,0,0,0,,And so a signal is just a concurrent flow,it's just a logical flow a sit 信号是一个并发流，
Dialogue: 0,0:35:08.86,0:35:13.82,English,,0,0,0,,So a handler is just another logical flow that runs concurrently with your program 一个处理程序是你程序中并发执行的一个逻辑流
Dialogue: 0,0:35:14.92,0:35:19.28,English,,0,0,0,,Right so we're...let's say we're executing a while loop in process A 所以。。让我们在进程 A 中执行一个 while 循环
Dialogue: 0,0:35:20.76,0:35:22.90,English,,0,0,0,,Okay that while loop is executing 好的，while 循环开始了
Dialogue: 0,0:35:23.46,0:35:25.56,English,,0,0,0,,And in process a receives the signal 进程收到了一个信号
Dialogue: 0,0:35:26.54,0:35:29.22,English,,0,0,0,,Which causes a transfer of control to this handler 这使得控制权被转移给这个处理程序
Dialogue: 0,0:35:31.84,0:35:35.30,English,,0,0,0,,This handler executes so this is a concurrent flow 这个处理程序是并发执行的
Dialogue: 0,0:35:36.12,0:35:42.24,English,,0,0,0,,That overlaps in time with the while loop in process A eventually this handler returns 它与进程 A 中的 while 循环在时间上是重叠的，最终该处理程序返回
Dialogue: 0,0:35:43.24,0:35:48.42,English,,0,0,0,,And we return for the back tip to back to process A
Dialogue: 0,0:35:50.34,0:35:58.26,English,,0,0,0,,Now one of the reasons signals are so tricky is because of this overlapping concurrent flow
Dialogue: 0,0:35:59.86,0:36:06.06,English,,0,0,0,,This concurrency because the signal handler runs in the same process  as the main program 因为这个信号处理程序与 main 程序运行在同一个进程里，所以我们说它是并发的
Dialogue: 0,0:36:06.68,0:36:10.12,English,,0,0,0,,So it shares all the global variables of that program 所以它们共享程序中的所有全局变量
Dialogue: 0,0:36:11.76,0:36:15.26,English,,0,0,0,,Okay so you're that signal handler is a function 信号处理程序是一个函数
Dialogue: 0,0:36:15.26,0:36:21.54,English,,0,0,0,,That you've declared and it has access to all the state,all the global state in the program 你之前定义的，它可以访问所有的状态，程序中的所有全局状态
Dialogue: 0,0:36:23.40,0:36:27.86,English,,0,0,0,,Okay and the existence of the shared global state can create real problems 全局状态共享的存在使得我们可以创建真正的问题
Dialogue: 0,0:36:37.50,0:36:40.48,English,,0,0,0,,And we'll get into more details about some of those problems 接下来我们会讲更多关于这些问题的细节
Dialogue: 0,0:36:42.08,0:36:49.90,English,,0,0,0,,So another way to look at these signal handlers disking as concurrent flows is using this context switch diagram 将这些信号处理程序看作并发流的另一种方式是用这个上下文切换图
Dialogue: 0,0:36:50.62,0:36:53.32,English,,0,0,0,,So suppose we're executing in process A 假设我们执行一个进程 A
Dialogue: 0,0:36:54.50,0:37:00.85,English,,0,0,0,,And now at some point a signal delivered to process  A 某时刻，一个信号被传递给进程 A
Dialogue: 0,0:37:01.70,0:37:06.78,English,,0,0,0,,Now nothing happens right just the pending bit gets set in process A at this point 现在还什么都没有发生，现在只有进程 A 的待处理位被置位
Dialogue: 0,0:37:08.64,0:37:12.52,English,,0,0,0,,Now at some point there's a transfer of control into the kernel 在某些时刻，控制权被转移给了内核
Dialogue: 0,0:37:13.44,0:37:17.20,English,,0,0,0,,And the kernel decides to do a context switch from A to B 内核决定进行从 A 到 B 的上下文切换
Dialogue: 0,0:37:18.08,0:37:22.34,English,,0,0,0,,And now B gets to run for a while there's another transfer of control to the kernel 现在 B 开始运行一段时间，这是另一个对内核控制权的转移
Dialogue: 0,0:37:24.30,0:37:27.02,English,,0,0,0,,And the kernel decides to schedule process A 内核决定调度进程 A
Dialogue: 0,0:37:28.62,0:37:32.90,English,,0,0,0,,And now right before it returns control to process A 在它将控制权返还给进程 A 之前
Dialogue: 0,0:37:33.26,0:37:37.36,English,,0,0,0,,It notices that the pending bit for this signal is set 注意这时，此信号的未处理信号未是置位的
Dialogue: 0,0:37:37.76,0:37:40.38,English,,0,0,0,,So it causes process A to receive that signal 所以进程 A 收到了这个信号
Dialogue: 0,0:37:41.00,0:37:42.88,English,,0,0,0,,So that executes the handler code 然后执行处理程序
Dialogue: 0,0:37:43.68,0:37:48.12,English,,0,0,0,,When the handler returns, it returns for brief briefly to the kernel 当处理程序返回，它会返回到内核去
Dialogue: 0,0:37:48.18,0:37:53.76,English,,0,0,0,,Which then transfers control back to the the next instruction that the process was going to execute 然后控制权会被交给进程要执行的下一条指令
Dialogue: 0,0:37:56.48,0:38:00.56,English,,0,0,0,,Now handlers are also tricky because they can be interrupted by other handlers 因为处理程序可以被其它处理程序中断，这使它很麻烦
Dialogue: 0,0:38:01.34,0:38:06.56,English,,0,0,0,,So suppose we have our main program that catches a signal s 假如我们的 main 程序捕获到了一个信号 s
Dialogue: 0,0:38:08.00,0:38:10.70,English,,0,0,0,,Which causes a transfer of control to handler S 我们得将控制权转移给 s 的处理程序
Dialogue: 0,0:38:11.44,0:38:13.76,English,,0,0,0,,And then we'll handler S did you have a question okay
Dialogue: 0,0:38:15.24,0:38:19.00,English,,0,0,0,,Well handler S is executing 处理程序 s 执行完后
Dialogue: 0,0:38:22.96,0:38:28.28,English,,0,0,0,,The program catches a signal t 程序又捕获了信号 t
Dialogue: 0,0:38:30.62,0:38:35.78,English,,0,0,0,,Which causes a transfer of control to the handler first for t 那么控制权就得先转移给 t 的处理程序
Dialogue: 0,0:38:36.38,0:38:39.30,English,,0,0,0,,And when at handler returns,it returns to the point to the 这个处理程序返回时，它返回到。。
Dialogue: 0,0:38:40.36,0:38:45.80,English,,0,0,0,,To the to the instruction and handle or else that was where it was interrupted
Dialogue: 0,0:38:46.36,0:38:50.50,English,,0,0,0,,And then handle or us continues its execution and eventually 然后处理程序或我们自己继续执行
Dialogue: 0,0:38:50.50,0:38:54.34,English,,0,0,0,,Return back to the the point in the main program where it was interrupted 最终返回到 main 程序被中断的地方
Dialogue: 0,0:38:58.70,0:39:02.61,English,,0,0,0,,Now signals that the kernel always blocks 内核的信号总会被一直阻塞
Dialogue: 0,0:39:03.32,0:39:06.44,English,,0,0,0,,Pending signals of the type currently being handled right so
Dialogue: 0,0:39:07.56,0:39:12.46,English,,0,0,0,,A handler for a signal of type t can't be interrupted 具有 t 信号类型的处理程序不能被中断
Dialogue: 0,0:39:13.20,0:39:16.16,English,,0,0,0,,By the receipt of another signal of that same type 被其它具有相同类型的信号中断
Dialogue: 0,0:39:16.96,0:39:20.98,English,,0,0,0,,Okay can be as I showed in the previous slide it can be interrupted by a signal of another type 它可以被我上一张幻灯片展示的，其它类型的信号中断
Dialogue: 0,0:39:21.46,0:39:23.42,English,,0,0,0,,But not by a signal of the same type 但现在它们是同一类型的
Dialogue: 0,0:39:23.88,0:39:28.12,English,,0,0,0,,So that's sort of an implicit form of blocking 
Dialogue: 0,0:39:29.22,0:39:36.70,English,,0,0,0,,But there's the kernel also provides a system call that allows you to explicitly block and unblock signals
Dialogue: 0,0:39:37.30,0:39:40.01,English,,0,0,0,,In the form of the sigprocmask function
Dialogue: 0,0:39:41.96,0:39:48.66,English,,0,0,0,,And then there's associated so this allows you to block and unblock a set of signals
Dialogue: 0,0:39:49.42,0:39:54.04,English,,0,0,0,,And then there some support functions that allow you to create those sets
Dialogue: 0,0:39:55.40,0:39:58.34,English,,0,0,0,,So just think of these as bit vectors
Dialogue: 0,0:39:58.38,0:40:05.34,English,,0,0,0,,And these functions will set in set and reset the bits and those those bit vectors
Dialogue: 0,0:40:07.16,0:40:12.72,English,,0,0,0,,So let's see how we can use sigprocmasks to temporarily block and unblock a signal
Dialogue: 0,0:40:13.32,0:40:16.00,English,,0,0,0,,So this is going to turn out to be very important for you
Dialogue: 0,0:40:16.00,0:40:21.24,English,,0,0,0,,When you working on your shells that which is your next lab assignment okay
Dialogue: 0,0:40:25.98,0:40:31.34,English,,0,0,0,,So what we do...we'll use sigemptyset to create an empty mask so this is a mask with all zeros
Dialogue: 0,0:40:31.96,0:40:33.80,English,,0,0,0,,Okay with no elements in the set
Dialogue: 0,0:40:34.80,0:40:39.46,English,,0,0,0,,And then we're going to add a single element to this set which is sigint
Dialogue: 0,0:40:42.46,0:40:47.88,English,,0,0,0,,And now we temp...we have some code that we don't want to be interrupted by the seed of sigint
Dialogue: 0,0:40:49.36,0:40:53.08,English,,0,0,0,,Okay so we want to temporarily block the receipt of sig n signals
Dialogue: 0,0:40:54.08,0:40:58.70,English,,0,0,0,,And we do it by calling sigprocmask with the command
Dialogue: 0,0:40:59.20,0:41:02.56,English,,0,0,0,,Say I want to block I want to block the signals
Dialogue: 0,0:41:03.84,0:41:08.78,English,,0,0,0,,That are spent that are in the set specified by mask
Dialogue: 0,0:41:12.36,0:41:16.22,English,,0,0,0,,And I'll assign the so this will become my new mask
Dialogue: 0,0:41:16.64,0:41:19.72,English,,0,0,0,,So this becomes the new blocked bit vector
Dialogue: 0,0:41:20.68,0:41:24.52,English,,0,0,0,,Okay or the not the this the new signal mask
Dialogue: 0,0:41:24.62,0:41:31.28,English,,0,0,0,,And it makes a copy of the old one and stores it at the address specified in the third argument
Dialogue: 0,0:41:32.82,0:41:35.50,English,,0,0,0,,So at this point after we returned from sigprocmask
Dialogue: 0,0:41:36.04,0:41:38.50,English,,0,0,0,,Sigint signals are blocked and they won't be received
Dialogue: 0,0:41:40.94,0:41:47.02,English,,0,0,0,,And then we...so we can execute this code knowing that we won't be interrupted by receipt of a sigint
Dialogue: 0,0:41:49.56,0:41:57.20,English,,0,0,0,,And then we can restore the previous block set by using the sig_setmask in stopper ation
Dialogue: 0,0:41:57.78,0:42:03.44,English,,0,0,0,,And passing in the previous mask that we saved up here when we initially blocks again
Dialogue: 0,0:42:09.96,0:42:15.12,English,,0,0,0,,Okay so signals and signal handling is a really tricky business
Dialogue: 0,0:42:15.54,0:42:17.48,English,,0,0,0,,And there's sort of three things that make them
Dialogue: 0,0:42:18.82,0:42:21.44,English,,0,0,0,,So tricky and kind of nasty really
Dialogue: 0,0:42:21.88,0:42:26.80,English,,0,0,0,,One is that you have to be very careful to write handlers that are safe
Dialogue: 0,0:42:27.54,0:42:33.96,English,,0,0,0,,Okay so there's you can write signal handlers that are unsafe in the sense that they'll create a deadlock in your program
Dialogue: 0,0:42:36.68,0:42:41.68,English,,0,0,0,,Okay or you can write signal handlers that will corrupt a global data structure
Dialogue: 0,0:42:42.58,0:42:46.24,English,,0,0,0,,That's being modified by the main program
Dialogue: 0,0:42:46.24,0:42:54.06,English,,0,0,0,,So I mean imagine your main programming is updating some data structure like a linked list
Dialogue: 0,0:42:54.84,0:42:59.72,English,,0,0,0,,And right in the middle of updating that data structure when it's no longer consistent
Dialogue: 0,0:43:01.44,0:43:04.02,English,,0,0,0,,The program gets interrupted by the receipt of a signal
Dialogue: 0,0:43:05.22,0:43:11.54,English,,0,0,0,,And if that signal handler is updating that same data structure reading that structure or modifying it
Dialogue: 0,0:43:12.62,0:43:17.18,English,,0,0,0,,Then it's going to encounter it in an inconsistent state and and you're in trouble
Dialogue: 0,0:43:19.92,0:43:27.28,English,,0,0,0,,Okay so this the fact that it's easy to write signal handlers
Dialogue: 0,0:43:27.30,0:43:32.04,English,,0,0,0,,That are unsafe is is is one aspect of that makes them tough to deal with
Dialogue: 0,0:43:32.66,0:43:37.16,English,,0,0,0,,Another aspect is they have this funny semantics that signals aren't cued
Dialogue: 0,0:43:38.04,0:43:40.60,English,,0,0,0,,And so if you're not really careful about this
Dialogue: 0,0:43:41.12,0:43:45.68,English,,0,0,0,,It's very easy to use the receipt of signals to count events
Dialogue: 0,0:43:46.76,0:43:49.94,English,,0,0,0,,And you can't do that if signals were cued you could use
Dialogue: 0,0:43:50.12,0:43:54.34,English,,0,0,0,,You could use the receipt of a signal to count events in the system but you can't do it because
Dialogue: 0,0:43:54.80,0:43:56.08,English,,0,0,0,,Their signals aren't cued
Dialogue: 0,0:43:57.28,0:44:00.82,English,,0,0,0,,And then a third aspect of signals which makes them tough is that
Dialogue: 0,0:44:01.66,0:44:05.18,English,,0,0,0,,They're not even portable across different versions of Linux
Dialogue: 0,0:44:07.52,0:44:12.94,English,,0,0,0,,Okay so if you use solaris or some form of bsd it's not necessarily
Dialogue: 0,0:44:13.24,0:44:16.70,English,,0,0,0,,The single handling semantics aren't necessarily the same as they are in Linux
Dialogue: 0,0:44:17.82,0:44:21.36,English,,0,0,0,,Okay so we'll look at all three of these in a little more detail
Dialogue: 0,0:44:21.36,0:44:24.34,English,,0,0,0,,And first we'll start with writing safe handlers
Dialogue: 0,0:44:26.94,0:44:32.40,English,,0,0,0,,So let me give you some guidelines for how to write safe handlers
Dialogue: 0,0:44:33.24,0:44:38.16,English,,0,0,0,,And this is just a collection of...
Dialogue: 0,0:44:39.16,0:44:43.78,English,,0,0,0,,Collection of sort of collected wisdom from various sources
Dialogue: 0,0:44:44.16,0:44:48.58,English,,0,0,0,,But it covers a lot of aspects of signal handlers
Dialogue: 0,0:44:49.34,0:44:53.66,English,,0,0,0,,So the first guideline is to keep your handlers as simple as possible for example
Dialogue: 0,0:44:54.04,0:44:58.94,English,,0,0,0,,The simplest possible handle I can think of just sets a global variable and then it returns
Dialogue: 0,0:45:00.52,0:45:10.62,English,,0,0,0,,Okay and in fact cert the CMU cert provides guidelines for sort of compliant programs
Dialogue: 0,0:45:11.38,0:45:17.88,English,,0,0,0,,And this is the only signal handler that they allow this is the only compliant signal handler
Dialogue: 0,0:45:18.10,0:45:20.64,English,,0,0,0,,One that just sets a global variable and then returns
Dialogue: 0,0:45:26.26,0:45:33.24,English,,0,0,0,,Okay guideline number one call only functions in your handlers that are that have this property of async-signals-safety
Dialogue: 0,0:45:35.82,0:45:41.16,English,,0,0,0,,We'll look at this in a second but I want to point out that printf, sprintf,malloc,exit
Dialogue: 0,0:45:42.18,0:45:45.64,English,,0,0,0,,Functions that are very common and commonly used are not safe
Dialogue: 0,0:45:48.88,0:45:54.80,English,,0,0,0,,Okay guideline number two is to always save and restore errno on entry and exit
Dialogue: 0,0:45:55.14,0:45:56.62,English,,0,0,0,,So you know errno is a global
Dialogue: 0,0:45:57.40,0:46:01.44,English,,0,0,0,,Global variable that's set when there's whenever there's an error in a system-level function
Dialogue: 0,0:46:02.56,0:46:06.42,English,,0,0,0,,So you need to save and restore it on entry and exit
Dialogue: 0,0:46:06.70,0:46:10.86,English,,0,0,0,,So that it doesn't get overwritten if you're interrupted by another handler
Dialogue: 0,0:46:15.92,0:46:18.32,English,,0,0,0,,Okay if you're accessing any shared data structures
Dialogue: 0,0:46:19.00,0:46:25.24,English,,0,0,0,,Inside a signal handler that are also accessed by your main routine
Dialogue: 0,0:46:25.34,0:46:29.16,English,,0,0,0,,Then you need to temporarily block signals while you access that data structure
Dialogue: 0,0:46:29.80,0:46:31.98,English,,0,0,0,,Both in the main routine and your signal handler
Dialogue: 0,0:46:32.86,0:46:35.43,English,,0,0,0,,Right and the reason for this is what I described earlier
Dialogue: 0,0:46:36.04,0:46:39.88,English,,0,0,0,,If your main routine is updating that global data structure and then it gets interrupted
Dialogue: 0,0:46:40.40,0:46:44.46,English,,0,0,0,,And the signal handler is reading that data structure it's going to find it in an inconsistent state
Dialogue: 0,0:46:44.88,0:46:46.40,English,,0,0,0,,And bad things will happen
Dialogue: 0,0:46:50.88,0:46:55.76,English,,0,0,0,,Okay you want to be sure to declare your any global variables that are shared between signal handlers
Dialogue: 0,0:46:55.96,0:46:57.94,English,,0,0,0,,And the main routine as volatile
Dialogue: 0,0:46:58.56,0:47:04.38,English,,0,0,0,,Okay the volatile attribute will prevent the compiler from putting that value in a register
Dialogue: 0,0:47:07.62,0:47:09.96,English,,0,0,0,,So if you declare a global variable as volatile
Dialogue: 0,0:47:10.58,0:47:14.58,English,,0,0,0,,It will always be reads and writes will always go to and from memory
Dialogue: 0,0:47:15.94,0:47:22.76,English,,0,0,0,,Okay so this is very important right you might if you don't declare these global variables at volatile
Dialogue: 0,0:47:22.86,0:47:28.22,English,,0,0,0,,And the compiler chooses to put one of those in a register
Dialogue: 0,0:47:29.64,0:47:33.04,English,,0,0,0,,Then you may miss that variable being updated
Dialogue: 0,0:47:33.06,0:47:37.68,English,,0,0,0,,So suppose your signal handlers is setting a global variable
Dialogue: 0,0:47:39.26,0:47:44.74,English,,0,0,0,,And now suppose your main routine is spinning waiting for that global variable to get set
Dialogue: 0,0:47:46.56,0:47:51.82,English,,0,0,0,,Well if it's in a register the write to that variable will just update the register
Dialogue: 0,0:47:51.92,0:47:58.70,English,,0,0,0,,Right and so your main routine is in danger of just of spinning forever not seeing the change right
Dialogue: 0,0:48:00.54,0:48:04.62,English,,0,0,0,,Okay so always use volatility so that they're not stored in registers
Dialogue: 0,0:48:06.22,0:48:10.60,English,,0,0,0,,And then if you have fun if you have a special kind of global called a flag
Dialogue: 0,0:48:11.18,0:48:19.22,English,,0,0,0,,Which by definition is a variable it's only read or written not incremented or updated it's just read or written
Dialogue: 0,0:48:20.64,0:48:27.18,English,,0,0,0,,If you have a variable with that property then you can declare it with this sig_atomic_t tribute
Dialogue: 0,0:48:28.72,0:48:34.46,English,,0,0,0,,And if you do that then the system guarantees that reads and writes to that variable will be atomic
Dialogue: 0,0:48:34.68,0:48:39.22,English,,0,0,0,,So you don't have to in other words you don't have to protect accesses to the shared
Dialogue: 0,0:48:39.82,0:48:43.58,English,,0,0,0,,To accesses or references to those global variables
Dialogue: 0,0:48:44.52,0:48:53.56,English,,0,0,0,,Okay and so by atomic which means that the read or write of that flag will always happen in one uninterruptible step
Dialogue: 0,0:48:54.86,0:48:58.12,English,,0,0,0,,Okay one uninterruptible load or store particular
Dialogue: 0,0:49:00.16,0:49:03.94,English,,0,0,0,,Now in practice on most systems this sig_atomic_t is an int
Dialogue: 0,0:49:05.80,0:49:12.00,English,,0,0,0,,So you can read or write an int with one one instruction okay so it's atomic
Dialogue: 0,0:49:12.62,0:49:16.06,English,,0,0,0,,But if you want to be portable you declare it with sig_atomic_t
Dialogue: 0,0:49:16.30,0:49:21.94,English,,0,0,0,,And then it'll work on none it will work on all systems
Dialogue: 0,0:49:24.78,0:49:27.44,English,,0,0,0,,Okay we mentioned this property of a sync signal safety
Dialogue: 0,0:49:28.66,0:49:32.66,English,,0,0,0,,Now a function is safe to be used inside of a signal handler
Dialogue: 0,0:49:33.56,0:49:38.54,English,,0,0,0,,If it's either reentrant or if it can't be interrupted by signals
Dialogue: 0,0:49:39.30,0:49:44.62,English,,0,0,0,,And will...a reentrant function as we'll see when we study threads is a function where all of its
Dialogue: 0,0:49:45.16,0:49:48.20,English,,0,0,0,,All of the data that it accesses is on its own stack
Dialogue: 0,0:49:50.64,0:49:56.06,English,,0,0,0,,Okay so no global variables no pointers to global variables everything's stored on the stack locally
Dialogue: 0,0:49:58.00,0:50:00.42,English,,0,0,0,,Okay so that means you can be it's called reentrant
Dialogue: 0,0:50:00.42,0:50:03.36,English,,0,0,0,,Because you can write have multiple instances of that function
Dialogue: 0,0:50:03.36,0:50:08.52,English,,0,0,0,,And they all have their own separate copies of all of the variables that they're using
Dialogue: 0,0:50:10.02,0:50:16.58,English,,0,0,0,,Now the posix standard guarantees 117 different functions to be a sync-signal-safe
Dialogue: 0,0:50:19.80,0:50:24.42,English,,0,0,0,,These include _exit,write,wait,waitpid,sleep,kill
Dialogue: 0,0:50:25.52,0:50:30.81,English,,0,0,0,,But unfortunately there's some very popular functions that aren't on this list printf,sprintf
Dialogue: 0,0:50:31.28,0:50:32.70,English,,0,0,0,,Things that you really want to use
Dialogue: 0,0:50:33.14,0:50:37.84,English,,0,0,0,,And in fact write is the only output function that's async-signal-safe
Dialogue: 0,0:50:41.06,0:50:43.14,English,,0,0,0,,So this is kind of a problem because
Dialogue: 0,0:50:44.34,0:50:50.52,English,,0,0,0,,Especially when you know you something you'd often like your signal handlers to output information
Dialogue: 0,0:50:51.52,0:50:56.38,English,,0,0,0,,But you can't if you want to really be pedantic and careful you can't use printf in fact
Dialogue: 0,0:50:57.48,0:50:59.28,English,,0,0,0,,It's possible to write a program
Dialogue: 0,0:51:00.46,0:51:04.16,English,,0,0,0,,And I'll try to...it's possible to write a program
Dialogue: 0,0:51:05.12,0:51:09.24,English,,0,0,0,,That does a tight loop of printouts in the main routine
Dialogue: 0,0:51:10.96,0:51:18.32,English,,0,0,0,,And then a steady stream of interrupts which execute a handler which also does a printf
Dialogue: 0,0:51:22.94,0:51:28.70,English,,0,0,0,,The printf call has to acquire what's called a lock on the terminal
Dialogue: 0,0:51:29.24,0:51:32.88,English,,0,0,0,,Okay each printf inside that library function
Dialogue: 0,0:51:33.70,0:51:40.06,English,,0,0,0,,It acquires a lock which means only one instance of printf can write to the terminal at a point in time
Dialogue: 0,0:51:40.90,0:51:44.94,English,,0,0,0,,If another function tries to acquire that lock it has to wait
Dialogue: 0,0:51:46.28,0:51:50.12,English,,0,0,0,,Until whatever function owns the lock releases it
Dialogue: 0,0:51:50.84,0:51:58.30,English,,0,0,0,,Okay so a lock prevents a lock is a way for to get mutually exclusive access to two shared resources
Dialogue: 0,0:51:59.68,0:52:04.90,English,,0,0,0,,So if we have a tight loop in our main routine with executing printf
Dialogue: 0,0:52:05.66,0:52:10.22,English,,0,0,0,,Imagine what happens if one of those printfs acquires a lock on the terminal
Dialogue: 0,0:52:10.68,0:52:16.18,English,,0,0,0,,And then gets interrupted not by the receipt of a signal
Dialogue: 0,0:52:16.88,0:52:20.58,English,,0,0,0,,Now within the signal handler it calls another printf
Dialogue: 0,0:52:22.08,0:52:26.88,English,,0,0,0,,And that printf tries to acquire that lock and it blocks forever
Dialogue: 0,0:52:27.10,0:52:32.28,English,,0,0,0,,Because nothing's going to release that lock because the main routine was interrupted by the handler
Dialogue: 0,0:52:35.28,0:52:40.48,English,,0,0,0,,So you have what's called a classical condition called deadlock
Dialogue: 0,0:52:41.06,0:52:44.32,English,,0,0,0,,Which is we have a process waiting for an event that will never occur
Dialogue: 0,0:52:44.36,0:52:50.48,English,,0,0,0,,In this case the the printf and the signal handler is waiting for a lock to be released that will never be released
Dialogue: 0,0:52:51.70,0:52:56.66,English,,0,0,0,,So it's interesting you can try this it's
Dialogue: 0,0:52:57.42,0:53:01.40,English,,0,0,0,,It's not too hard to to create this deadlock situation
Dialogue: 0,0:53:02.90,0:53:05.74,English,,0,0,0,,So to deal with this I really didn't want to tell you guys
Dialogue: 0,0:53:05.74,0:53:09.92,English,,0,0,0,,That you couldn't have any output in your programs and writes a very difficult thing to deal with
Dialogue: 0,0:53:11.10,0:53:16.84,English,,0,0,0,,So I created a small little library called the safe I/O library
Dialogue: 0,0:53:18.50,0:53:25.46,English,,0,0,0,,Consists of three routines and they're available to you in the csapp.c file
Dialogue: 0,0:53:25.46,0:53:28.02,English,,0,0,0,,Which is distributed on the website
Dialogue: 0,0:53:28.94,0:53:31.42,English,,0,0,0,,And it consists of three reentrant routines
Dialogue: 0,0:53:33.64,0:53:37.50,English,,0,0,0,,sio_puts prints string
Dialogue: 0,0:53:38.84,0:53:41.48,English,,0,0,0,,(sio_)putl prints a long
Dialogue: 0,0:53:42.82,0:53:48.04,English,,0,0,0,,And sio_error prints a message and then exits
Dialogue: 0,0:53:50.82,0:53:55.92,English,,0,0,0,,Okay so you can safely use take my word for it you can safely use this in your signal handlers
Dialogue: 0,0:53:56.54,0:54:01.94,English,,0,0,0,,So if we were going to rewrite our sigint_handler from the binary bomb
Dialogue: 0,0:54:02.60,0:54:08.38,English,,0,0,0,,We could rewrite it like this and now we have every function is async-signal-safe
Dialogue: 0,0:54:11.60,0:54:16.58,English,,0,0,0,,All right now signals are also tucked because of this funky non cueing semantics
Dialogue: 0,0:54:19.56,0:54:21.70,English,,0,0,0,,And so it's really easy to make mistakes
Dialogue: 0,0:54:23.92,0:54:26.14,English,,0,0,0,,When you have an implicit assumption that
Dialogue: 0,0:54:27.94,0:54:33.18,English,,0,0,0,,The that the receipt of a signal it can be used to count the occurrence of an event
Dialogue: 0,0:54:34.82,0:54:38.32,English,,0,0,0,,So let's look at this, let's look at this example program
Dialogue: 0,0:54:40.88,0:54:42.92,English,,0,0,0,,We install a sick child handler
Dialogue: 0,0:54:43.92,0:54:49.40,English,,0,0,0,,Okay and this is actually this sort of close the loop member we talked about our example shell
Dialogue: 0,0:54:49.96,0:54:53.38,English,,0,0,0,,We're wondering how are we going to reap those background children
Dialogue: 0,0:54:53.76,0:54:57.42,English,,0,0,0,,Well we do it by installing a sick child handle like we're doing in this example
Dialogue: 0,0:54:58.26,0:55:03.62,English,,0,0,0,,So this here we have a program that installs this sig child handler
Dialogue: 0,0:55:04.28,0:55:08.86,English,,0,0,0,,And then it creates N different child processes
Dialogue: 0,0:55:09.64,0:55:12.86,English,,0,0,0,,Where each child sleeps for a little bit and exits
Dialogue: 0,0:55:17.02,0:55:22.16,English,,0,0,0,,And then it spins until the ccount variable becomes zero
Dialogue: 0,0:55:23.86,0:55:29.16,English,,0,0,0,,That the parent, I'm sorry, the parent spins until the ccount variable becomes zero
Dialogue: 0,0:55:30.76,0:55:40.32,English,,0,0,0,,Now in our child handler we have a global that's initialized to zero ccount
Dialogue: 0,0:55:43.94,0:55:48.40,English,,0,0,0,,And then we wait,we're going to wait so this child,when the child handler gets called that means
Dialogue: 0,0:55:48.84,0:55:51.14,English,,0,0,0,,It's called because we received a sig_child signal
Dialogue: 0,0:55:53.30,0:55:58.52,English,,0,0,0,,Okay so in our handler we're going to reap that child by calling weight
Dialogue: 0,0:56:00.04,0:56:03.60,English,,0,0,0,,And we're going to dec...will decrement ccount
Dialogue: 0,0:56:04.00,0:56:10.56,English,,0,0,0,,Okay so once all of the children if then have been reaped ccount will be zero
Dialogue: 0,0:56:10.56,0:56:13.88,English,,0,0,0,,And then the parent can exit this while loop
Dialogue: 0,0:56:15.54,0:56:18.48,English,,0,0,0,,Okay now in this particular example N was 5
Dialogue: 0,0:56:20.20,0:56:26.72,English,,0,0,0,,But will you run this code,we only the handle or only gets called twice
Dialogue: 0,0:56:29.46,0:56:35.38,English,,0,0,0,,Okay so the the message handler reap child only gets executed twice right
Dialogue: 0,0:56:35.38,0:56:37.76,English,,0,0,0,,Which means the handler was only called twice
Dialogue: 0,0:56:38.04,0:56:42.62,English,,0,0,0,,We created five children,we terminated five children
Dialogue: 0,0:56:43.58,0:56:45.16,English,,0,0,0,,But we only reaped two
Dialogue: 0,0:56:47.26,0:56:51.94,English,,0,0,0,,Okay so that the problem is that when we the problem is that we assumed
Dialogue: 0,0:56:52.76,0:56:54.84,English,,0,0,0,,That the receipt...
Dialogue: 0,0:56:56.94,0:57:03.36,English,,0,0,0,,The execution of the child handled our correspondent to the single receipt of a single sig_child signal
Dialogue: 0,0:57:04.78,0:57:09.38,English,,0,0,0,,Okay when in reality there signals are true
Dialogue: 0,0:57:10.40,0:57:15.90,English,,0,0,0,,We had in reality multiple sig_child signals were delivered to that child
Dialogue: 0,0:57:15.90,0:57:19.10,English,,0,0,0,,Which kept overriding that at bit in the pending bit vector
Dialogue: 0,0:57:20.26,0:57:26.68,English,,0,0,0,,And the delivery of those signals didn't cause any reaction in the process
Dialogue: 0,0:57:26.68,0:57:30.00,English,,0,0,0,,Until that process was just about ready to be rescheduled
Dialogue: 0,0:57:30.44,0:57:33.02,English,,0,0,0,,And only then was where was a signal received
Dialogue: 0,0:57:33.92,0:57:37.84,English,,0,0,0,,But even though like say three signals were delivered only one was received
Dialogue: 0,0:57:41.04,0:57:43.80,English,,0,0,0,,Okay so you can't use events in this case we're using event
Dialogue: 0,0:57:44.58,0:57:50.40,English,,0,0,0,,We're using signals to count events which in this case is the termination of a child
Dialogue: 0,0:57:51.30,0:57:55.52,English,,0,0,0,,Okay so the receipt of a signal in this case
Dialogue: 0,0:57:55.62,0:58:00.04,English,,0,0,0,,It only indicates that at least one child terminated
Dialogue: 0,0:58:00.40,0:58:04.06,English,,0,0,0,,Right not one child terminated
Dialogue: 0,0:58:05.36,0:58:10.60,English,,0,0,0,,All we can infer from the receipt of that signal is that at least one child has terminated
Dialogue: 0,0:58:11.70,0:58:17.88,English,,0,0,0,,Okay so to fix that when we receive a sigchild
Dialogue: 0,0:58:18.68,0:58:23.80,English,,0,0,0,,We have to put we have to put the wait,that's reaping on our children
Dialogue: 0,0:58:24.36,0:58:26.62,English,,0,0,0,,We have to put that in a loop
Dialogue: 0,0:58:27.30,0:58:29.48,English,,0,0,0,,So we have to assume that the receipt of a sigchild
Dialogue: 0,0:58:29.80,0:58:34.16,English,,0,0,0,,If we get a sigchild there could be multiple terminated children
Dialogue: 0,0:58:34.82,0:58:37.92,English,,0,0,0,,That we have to that we have to reap
Dialogue: 0,0:58:38.68,0:58:42.78,English,,0,0,0,,And so we put that in this loop and we execute this loop
Dialogue: 0,0:58:43.08,0:58:48.78,English,,0,0,0,,Until there's no more terminated children in which case wait will...
Dialogue: 0,0:58:49.24,0:58:53.22,English,,0,0,0,,Will exit with an error code of -1 and a error know of a child
Dialogue: 0,0:58:53.80,0:58:58.00,English,,0,0,0,,So this isn't really an error it's just means there's no more terminated children
Dialogue: 0,0:58:58.00,0:59:03.30,English,,0,0,0,,So we check as long as if our errno naughty child then we have an error
Dialogue: 0,0:59:03.82,0:59:06.72,English,,0,0,0,,Otherwise we terminated normally as we expect it
Dialogue: 0,0:59:07.54,0:59:09.12,English,,0,0,0,,Now if we run this code
Dialogue: 0,0:59:10.46,0:59:15.94,English,,0,0,0,,Now we we see that we reap all five children as as we should
Dialogue: 0,0:59:18.70,0:59:23.30,English,,0,0,0,,Okay so let's the litany of problems with signals first
Dialogue: 0,0:59:24.14,0:59:27.18,English,,0,0,0,,It's easy to write handlers that aren't safe
Dialogue: 0,0:59:27.72,0:59:31.02,English,,0,0,0,,Second it's easy to get the semantics wrong third
Dialogue: 0,0:59:32.30,0:59:35.88,English,,0,0,0,,They're often not even portable across different versions of UNIX
Dialogue: 0,0:59:36.82,0:59:39.86,English,,0,0,0,,So there's some older systems I don't know if any
Dialogue: 0,0:59:40.68,0:59:47.74,English,,0,0,0,,There's some earlier versions of UNIX that after you catch a signal it restores the default action
Dialogue: 0,0:59:47.82,0:59:50.70,English,,0,0,0,,So you have to reinstall the handler every time
Dialogue: 0,0:59:51.64,0:59:57.64,English,,0,0,0,,Well every time a handler gets called you have to reinstall that handler by calling signal inside the handler itself
Dialogue: 0,0:59:58.62,1:00:00.88,English,,0,0,0,,We don't have to do that for Linux systems
Dialogue: 0,1:00:03.22,1:00:08.52,English,,0,0,0,,On some systems when you have so-called slow syscalls
Dialogue: 0,1:00:09.66,1:00:10.70,English,,0,0,0,,For example read
Dialogue: 0,1:00:11.96,1:00:13.54,English,,0,0,0,,You know if you do a read system call
Dialogue: 0,1:00:15.38,1:00:18.68,English,,0,0,0,,The kernel doesn't wait around for that data to arrive
Dialogue: 0,1:00:20.48,1:00:25.46,English,,0,0,0,,It you know it sends a request to the disk controller and that schedules another process
Dialogue: 0,1:00:26.70,1:00:31.22,English,,0,0,0,,Right so in a way that the read call is sort of and then only when the data arrives
Dialogue: 0,1:00:31.54,1:00:34.64,English,,0,0,0,,And the interrupt comes in announcing that the data arrives
Dialogue: 0,1:00:35.14,1:00:38.92,English,,0,0,0,,Does that read call finish and then restore and return
Dialogue: 0,1:00:39.58,1:00:43.86,English,,0,0,0,,So you can think of read is actually kind of broken up into two parts right
Dialogue: 0,1:00:45.90,1:00:54.14,English,,0,0,0,,Then and so that functions like read these kind of functions are called slow syscalls
Dialogue: 0,1:00:55.36,1:00:59.68,English,,0,0,0,,And on some systems if the process receives a signal
Dialogue: 0,1:01:00.16,1:01:02.54,English,,0,0,0,,Before a slow system calls has finished
Dialogue: 0,1:01:04.24,1:01:09.22,English,,0,0,0,,The kernel will just abort that system call and return from that system call with an error
Dialogue: 0,1:01:09.92,1:01:14.54,English,,0,0,0,,Okay so from users point of view you're doing a read call
Dialogue: 0,1:01:15.22,1:01:19.64,English,,0,0,0,,And it returns with this e enter signal this e enter error
Dialogue: 0,1:01:20.72,1:01:24.82,English,,0,0,0,,You did nothing wrong you just happen to have the bad luck of being interrupted by some signal
Dialogue: 0,1:01:25.14,1:01:27.26,English,,0,0,0,,And so in your user code you have to check for that
Dialogue: 0,1:01:27.32,1:01:33.34,English,,0,0,0,,And if a slow system call like read is interrupted by signal you have to redo it
Dialogue: 0,1:01:33.82,1:01:39.04,English,,0,0,0,,So you have to put which is really a pain right because you have to put these read calls in a loop
Dialogue: 0,1:01:39.04,1:01:41.72,English,,0,0,0,,And keep looping until it succeeds
Dialogue: 0,1:01:42.90,1:01:46.90,English,,0,0,0,,And finally some systems don't block signals of the type being handled right
Dialogue: 0,1:01:48.92,1:01:52.32,English,,0,0,0,,So that the solution for this is a replacement for signal
Dialogue: 0,1:01:52.32,1:01:54.32,English,,0,0,0,,So the problem is with the signal syscall
Dialogue: 0,1:01:54.94,1:01:58.52,English,,0,0,0,,And the solution is a newer syscall called sigaction
Dialogue: 0,1:01:59.00,1:02:02.32,English,,0,0,0,,Which provides a mechanism a replacement for signal
Dialogue: 0,1:02:02.80,1:02:06.70,English,,0,0,0,,That provides a mechanism for portable and predictable signal handling
Dialogue: 0,1:02:07.54,1:02:14.18,English,,0,0,0,,And so what I've done is created a rapper called uppercase signal
Dialogue: 0,1:02:15.76,1:02:19.56,English,,0,0,0,,That takes the same arguments as that the signal call
Dialogue: 0,1:02:20.88,1:02:26.04,English,,0,0,0,,But inside it calls the sigaction function to get portable signal handling
Dialogue: 0,1:02:27.44,1:02:32.22,English,,0,0,0,,And so it's not really important to go into detail about this
Dialogue: 0,1:02:34.22,1:02:42.78,English,,0,0,0,,The point is in your code you always want to call Signal using the  rapper that provided in csapp.c
Dialogue: 0,1:02:43.28,1:02:47.26,English,,0,0,0,,And then if you do that then you'll always block signals of the typing
Dialogue: 0,1:02:47.70,1:02:50.84,English,,0,0,0,,Handle the system will automatically restart
Dialogue: 0,1:02:52.02,1:02:55.28,English,,0,0,0,,Slow syscalls that have been interrupted by by signals
Dialogue: 0,1:02:58.60,1:03:00.84,English,,0,0,0,,Okay so fortunately there's an easy fix for this
Dialogue: 0,1:03:04.48,1:03:06.74,English,,0,0,0,,Now let's finish up with them
Dialogue: 0,1:03:08.78,1:03:11.60,English,,0,0,0,,There's some interesting I mentioned that signals are difficult
Dialogue: 0,1:03:11.60,1:03:14.56,English,,0,0,0,,Because of these the fact that they're concurrent flows
Dialogue: 0,1:03:15.10,1:03:20.36,English,,0,0,0,,So I want to look at some sort of subtle issues that you can run into because of this concurrency
Dialogue: 0,1:03:21.98,1:03:26.56,English,,0,0,0,,And I want to talk about how to identify those errors and how to fix them
Dialogue: 0,1:03:31.20,1:03:35.60,English,,0,0,0,,So here's a program that this is like a simple shell program
Dialogue: 0,1:03:36.40,1:03:41.58,English,,0,0,0,,That maintains a jobs list right so every time it creates a new child
Dialogue: 0,1:03:42.30,1:03:48.04,English,,0,0,0,,It adds it to the jobs list and every time that child terminates it removes it from the jobs list
Dialogue: 0,1:03:51.06,1:04:01.76,English,,0,0,0,,Okay so our simple show just in a loop it just creates a child and then executes the program within that child
Dialogue: 0,1:04:02.46,1:04:09.72,English,,0,0,0,,And then in the parent it correctly blocks all of the signals temporarily while it adds the job to the job queue
Dialogue: 0,1:04:12.60,1:04:16.26,English,,0,0,0,,And then it unblocks and then it unblocks those signals
Dialogue: 0,1:04:17.78,1:04:22.76,English,,0,0,0,,Okay so this is correct and that it's protecting access to this the shared job queue
Dialogue: 0,1:04:25.76,1:04:31.88,English,,0,0,0,,Because job queue is also manipulated by the sick child handler
Dialogue: 0,1:04:32.06,1:04:37.68,English,,0,0,0,,So when a child terminates and the parent receives the sigchild
Dialogue: 0,1:04:38.26,1:04:40.54,English,,0,0,0,,This handler runs
Dialogue: 0,1:04:41.98,1:04:47.02,English,,0,0,0,,And this handler goes through and it reaps all of the children potentially terminated children
Dialogue: 0,1:04:47.82,1:04:52.42,English,,0,0,0,,And then for each one it deletes that job from the job queue
Dialogue: 0,1:04:52.92,1:04:57.66,English,,0,0,0,,All right so here's a classic case we have two concurrent flows our main routine
Dialogue: 0,1:04:58.44,1:05:00.74,English,,0,0,0,,And our signal handler
Dialogue: 0,1:05:01.82,1:05:06.50,English,,0,0,0,,They're each accessing a shared data structure in this case the job queue
Dialogue: 0,1:05:08.78,1:05:16.62,English,,0,0,0,,Okay and they're there correctly blocking signals while they update this this job queue
Dialogue: 0,1:05:19.12,1:05:23.26,English,,0,0,0,,But this program has a really subtle and nasty bug in it
Dialogue: 0,1:05:25.42,1:05:26.58,English,,0,0,0,,Can you see what it is
Dialogue: 0,1:05:30.60,1:05:32.26,English,,0,0,0,,What's the sequence of events that would
Dialogue: 0,1:05:33.58,1:05:36.50,English,,0,0,0,,Cause this program to fail
Dialogue: 0,1:05:40.82,1:05:41.34,English,,0,0,0,,Yes
Dialogue: 0,1:05:47.22,1:05:52.58,English,,0,0,0,,Exactly that's exactly it,so is it possible that the the child process
Dialogue: 0,1:05:53.34,1:05:58.02,English,,0,0,0,,Could terminate before the parent has a chance to add that job to the queue and the answer is yes
Dialogue: 0,1:05:58.66,1:06:04.78,English,,0,0,0,,Right we you cannot make any assumptions about the execution ordering of the child in the process
Dialogue: 0,1:06:05.14,1:06:06.40,English,,0,0,0,,Or about how long they run right
Dialogue: 0,1:06:06.78,1:06:09.42,English,,0,0,0,,So it's very possible
Dialogue: 0,1:06:10.10,1:06:16.20,English,,0,0,0,,That the child can connect after the four control returns to the child instead of the parent
Dialogue: 0,1:06:16.76,1:06:22.90,English,,0,0,0,,And then the child terminates before the parent ever has a chance to add that job to the job queue
Dialogue: 0,1:06:23.38,1:06:30.10,English,,0,0,0,,So now what's happened is that the child is deleting
Dialogue: 0,1:06:30.92,1:06:35.43,English,,0,0,0,,A deleting a job that hasn't been added to the job queue right
Dialogue: 0,1:06:35.62,1:06:40.30,English,,0,0,0,,Now when the parent finally gets around to running it adds that job to the job queue
Dialogue: 0,1:06:40.58,1:06:42.06,English,,0,0,0,,And that job will never be deleted
Dialogue: 0,1:06:43.96,1:06:50.42,English,,0,0,0,,Right so this is the kind of subtle nasty horrible kind of bug that you run into
Dialogue: 0,1:06:50.78,1:06:52.46,English,,0,0,0,,When you're dealing with concurrency
Dialogue: 0,1:06:53.00,1:06:56.06,English,,0,0,0,,Trying to keep track of all of these interleaving of events
Dialogue: 0,1:06:56.82,1:06:58.78,English,,0,0,0,,Can just make your head explode all right
Dialogue: 0,1:06:59.62,1:07:04.90,English,,0,0,0,,Now and it happens and sig... it happens with any kind of concurrency
Dialogue: 0,1:07:05.30,1:07:09.82,English,,0,0,0,,Where you have concurrent flows accessing shared resources and signal handlers are no different
Dialogue: 0,1:07:10.68,1:07:15.88,English,,0,0,0,,Now we'll look at principled ways where we can deal with this kind of sharing when we study threads later on
Dialogue: 0,1:07:17.34,1:07:22.16,English,,0,0,0,,But I just want to point this out to him scare you a little bit
Dialogue: 0,1:07:23.34,1:07:24.96,English,,0,0,0,,All right so here's how we would fix that
Dialogue: 0,1:07:27.28,1:07:37.74,English,,0,0,0,,What we have to do is somehow avoid the possibility of the child handle or executing
Dialogue: 0,1:07:38.38,1:07:43.28,English,,0,0,0,,Before the parent can add the corresponding job to the job queue
Dialogue: 0,1:07:44.18,1:07:48.54,English,,0,0,0,,Now we can't control whether the child executes first or the parent execute first
Dialogue: 0,1:07:49.62,1:07:51.74,English,,0,0,0,,And we can't control how long the child runs
Dialogue: 0,1:07:52.50,1:07:58.10,English,,0,0,0,,But we can control when the the sigchild handler runs because we can block signals
Dialogue: 0,1:07:58.81,1:08:00.84,English,,0,0,0,,Okay so what we'll do
Dialogue: 0,1:08:02.44,1:08:04.34,English,,0,0,0,,We'll modify our program
Dialogue: 0,1:08:07.36,1:08:12.88,English,,0,0,0,,We'll use sigprocmask to block sigchild signals before we create the child
Dialogue: 0,1:08:14.50,1:08:19.44,English,,0,0,0,,Okay so at this point after this invocation of sigproc,sigchild, signals are blocked
Dialogue: 0,1:08:21.64,1:08:23.32,English,,0,0,0,,Okay then we create the child
Dialogue: 0,1:08:24.68,1:08:27.54,English,,0,0,0,,And before we do execev
Dialogue: 0,1:08:27.90,1:08:34.30,English,,0,0,0,,Since we don't know that child may may need to reap its children right we don't know if it
Dialogue: 0,1:08:34.82,1:08:42.82,English,,0,0,0,,By default children inherit the the blocked a bit vector of their parents okay so when this child runs
Dialogue: 0,1:08:44.60,1:08:51.74,English,,0,0,0,,After it returns from fork at this point right after the fork sigchild is blocked in the child as well right
Dialogue: 0,1:08:52.34,1:08:55.28,English,,0,0,0,,So if we didn't do anything if and the child created children
Dialogue: 0,1:08:56.74,1:09:01.58,English,,0,0,0,,And tried to reap you know reap them with a sick child handle that sick child handler wouldn't run right
Dialogue: 0,1:09:01.60,1:09:02.44,English,,0,0,0,,So that would be a problem
Dialogue: 0,1:09:03.42,1:09:08.30,English,,0,0,0,,So in the child before we execute that the program itself we unblock sigchild
Dialogue: 0,1:09:09.16,1:09:11.60,English,,0,0,0,,And this was an example that I was alluding to last time
Dialogue: 0,1:09:12.40,1:09:19.44,English,,0,0,0,,How it's useful sometimes to separate creating processes with executing programs right then
Dialogue: 0,1:09:20.72,1:09:27.52,English,,0,0,0,,So this allows us to get our signal mask set up the way we want it before we run our program in the child
Dialogue: 0,1:09:29.34,1:09:33.82,English,,0,0,0,,So now even if the child terminates early
Dialogue: 0,1:09:36.26,1:09:43.94,English,,0,0,0,,The sigchild handler won't run until after we've added the job to the to the job queue
Dialogue: 0,1:09:44.42,1:09:49.74,English,,0,0,0,,Because we don't unblock sigchild until after the until after we call a job
Dialogue: 0,1:09:57.82,1:09:58.98,English,,0,0,0,,Okay now there's another
Dialogue: 0,1:09:59.26,1:10:04.40,English,,0,0,0,,So this sort of scenario be very relevant to you when you do your shell lab
Dialogue: 0,1:10:05.10,1:10:08.52,English,,0,0,0,,Okay so you want to be careful not to make that mistake
Dialogue: 0,1:10:12.28,1:10:15.84,English,,0,0,0,,Another thing that you're going to need to do in your shell lab
Dialogue: 0,1:10:16.92,1:10:20.22,English,,0,0,0,,Now you remember in our simple our simple shell example we did the wait
Dialogue: 0,1:10:20.74,1:10:24.65,English,,0,0,0,,Inside the main routine so we waited for foreground jobs using wait
Dialogue: 0,1:10:25.48,1:10:31.28,English,,0,0,0,,But now in a real shell we're going to have our sigchild handler do all the all the wait call all the waits
Dialogue: 0,1:10:32.28,1:10:37.58,English,,0,0,0,,And so we can't put the weight has to go in the sigchild handler can't go in the main routine
Dialogue: 0,1:10:40.48,1:10:45.66,English,,0,0,0,,Okay so high if we can't put a weight in the main routine
Dialogue: 0,1:10:46.88,1:10:50.88,English,,0,0,0,,How are we going to detect that our foreground job is finished
Dialogue: 0,1:10:56.50,1:11:01.42,English,,0,0,0,,Okay so somehow so what we could do?we could define in the sigchild handler
Dialogue: 0,1:11:03.00,1:11:05.16,English,,0,0,0,,When we read the foreground job
Dialogue: 0,1:11:06.84,1:11:10.42,English,,0,0,0,,Right we've created a foreground job when we read that foreground job
Dialogue: 0,1:11:11.18,1:11:14.92,English,,0,0,0,,We could set this global flag
Dialogue: 0,1:11:16.02,1:11:18.48,English,,0,0,0,,We could declare the process this process id
Dialogue: 0,1:11:19.14,1:11:21.98,English,,0,0,0,,A variable pid as a global flag
Dialogue: 0,1:11:22.64,1:11:27.86,English,,0,0,0,,And then just assign the process id of the foreground job
Dialogue: 0,1:11:29.50,1:11:34.06,English,,0,0,0,,Okay so this is an example of a handler it just all it does it sets a flag and then exits
Dialogue: 0,1:11:38.92,1:11:45.56,English,,0,0,0,,And then in our main routine,okay we want to block sigchild just by just like before
Dialogue: 0,1:11:45.94,1:11:51.24,English,,0,0,0,,Okay to avoid that race condition between the parent and the child
Dialogue: 0,1:11:53.48,1:11:55.42,English,,0,0,0,,And then we create the child
Dialogue: 0,1:11:57.40,1:12:01.54,English,,0,0,0,,And then in the and then the parent we set pid to zero
Dialogue: 0,1:12:03.92,1:12:05.70,English,,0,0,0,,Okay then we unblock sigchild
Dialogue: 0,1:12:07.30,1:12:11.76,English,,0,0,0,,And then we wait for the sick child handler to run and set pid to nonzero
Dialogue: 0,1:12:15.56,1:12:18.34,English,,0,0,0,,Okay everybody see that I mean this so this is correct right
Dialogue: 0,1:12:19.70,1:12:21.30,English,,0,0,0,,But it's extremely wasteful right
Dialogue: 0,1:12:21.64,1:12:29.96,English,,0,0,0,,We're spinning...we're using valuable processor cycles in this tight spin loop
Dialogue: 0,1:12:30.14,1:12:33.74,English,,0,0,0,,Just executing over and over and over and over and over and over, for who knows how long
Dialogue: 0,1:12:35.14,1:12:38.72,English,,0,0,0,,Okay so that's not a good solution alright
Dialogue: 0,1:12:38.80,1:12:41.86,English,,0,0,0,,So let's look at a couple other things we might consider
Dialogue: 0,1:12:42.64,1:12:46.30,English,,0,0,0,,And that have been considered by generations of 213 students
Dialogue: 0,1:12:49.70,1:12:54.92,English,,0,0,0,,So one thing you might think well I'll just instead of just putting a semicolon here
Dialogue: 0,1:12:55.50,1:12:56.62,English,,0,0,0,,I'll pause
Dialogue: 0,1:12:58.56,1:13:02.06,English,,0,0,0,,And then I'll wait for the sigchild handler to run
Dialogue: 0,1:13:03.44,1:13:05.34,English,,0,0,0,,And then I'll go back up and I'll check
Dialogue: 0,1:13:06.26,1:13:07.44,English,,0,0,0,,I'll check pid again
Dialogue: 0,1:13:08.80,1:13:11.64,English,,0,0,0,,Now you have to put this in a loop it still has to be in a loop
Dialogue: 0,1:13:12.56,1:13:16.72,English,,0,0,0,,Because we have other signal handlers in our program we have a sigint handler
Dialogue: 0,1:13:17.72,1:13:22.50,English,,0,0,0,,So it might be if we do the pause here and this again comes in and say get sigint handler runs
Dialogue: 0,1:13:24.02,1:13:27.14,English,,0,0,0,,That would cause us to exit the pause function and go back up
Dialogue: 0,1:13:27.36,1:13:29.80,English,,0,0,0,,So we have to keep checking pid because we're not sure
Dialogue: 0,1:13:30.66,1:13:37.66,English,,0,0,0,,We have to keep checking for the specific signal handler sigchild handler to run instead of other handlers that might run
Dialogue: 0,1:13:39.32,1:13:41.28,English,,0,0,0,,But this is actually wrong
Dialogue: 0,1:13:44.36,1:13:47.74,English,,0,0,0,,Because it has a race can you see what the race is
Dialogue: 0,1:13:54.54,1:13:58.62,English,,0,0,0,,What's wrong with this there's a good chance that this thing will block forever
Dialogue: 0,1:14:03.50,1:14:15.92,English,,0,0,0,,Yes
Dialogue: 0,1:14:16.06,1:14:20.46,English,,0,0,0,,Yeah that's so the problem with this is like
Dialogue: 0,1:14:20.90,1:14:26.12,English,,0,0,0,,So if the signal is received after pid is checked
Dialogue: 0,1:14:27.00,1:14:28.66,English,,0,0,0,,But before the pause executes
Dialogue: 0,1:14:29.54,1:14:31.82,English,,0,0,0,,Okay which is possible right
Dialogue: 0,1:14:33.14,1:14:35.76,English,,0,0,0,,It's unlikely but it's possible
Dialogue: 0,1:14:37.54,1:14:41.52,English,,0,0,0,,If that signal is arrives here
Dialogue: 0,1:14:42.62,1:14:45.36,English,,0,0,0,,Then the handler will set pid to nonzero and
Dialogue: 0,1:14:46.08,1:14:47.82,English,,0,0,0,,Then we'll execute the pause
Dialogue: 0,1:14:49.00,1:14:53.32,English,,0,0,0,,And the pause will be blocked forever waiting for a signal that will never arrive right
Dialogue: 0,1:14:53.84,1:14:56.14,English,,0,0,0,,Because the sigchild signal already already came
Dialogue: 0,1:14:57.56,1:14:58.80,English,,0,0,0,,Very subtle right
Dialogue: 0,1:15:00.28,1:15:03.42,English,,0,0,0,,So this code looks okay it looks benign but it's wrong
Dialogue: 0,1:15:04.46,1:15:08.48,English,,0,0,0,,And your program would just hang forever
Dialogue: 0,1:15:09.60,1:15:11.26,English,,0,0,0,,So we say well okay that's no good
Dialogue: 0,1:15:11.80,1:15:16.36,English,,0,0,0,,We could replace the pause with asleep so we could say let's check pid
Dialogue: 0,1:15:17.26,1:15:22.52,English,,0,0,0,,And then sleep for some predetermined amount of time in this case one second
Dialogue: 0,1:15:24.68,1:15:26.98,English,,0,0,0,,And then go back up and check pid again
Dialogue: 0,1:15:28.42,1:15:34.00,English,,0,0,0,,So this while this is correct it's way too slow right we're asking the system to wait for a second which is an eternity
Dialogue: 0,1:15:35.10,1:15:40.02,English,,0,0,0,,And there's forms of sleep nanosecond where you can wait instead of units of seconds
Dialogue: 0,1:15:40.02,1:15:41.76,English,,0,0,0,,You can wait in units of nanoseconds
Dialogue: 0,1:15:42.26,1:15:44.32,English,,0,0,0,,But that what value do you use right
Dialogue: 0,1:15:45.16,1:15:51.48,English,,0,0,0,,If it's it that so that's if you choose a value that's too large then you have this problem the slowness problem
Dialogue: 0,1:15:51.82,1:15:54.90,English,,0,0,0,,If you choose a sleep time that's too small
Dialogue: 0,1:15:55.30,1:15:57.64,English,,0,0,0,,Then you have the other problem that it's inefficient
Dialogue: 0,1:15:59.20,1:16:01.14,English,,0,0,0,,So the solution is to use sigsuspend
Dialogue: 0,1:16:03.04,1:16:05.70,English,,0,0,0,,Which is the last thing we're going to look at today
Dialogue: 0,1:16:06.84,1:16:11.58,English,,0,0,0,,So sigsuspend is a function that takes a signal mask
Dialogue: 0,1:16:12.94,1:16:17.64,English,,0,0,0,,And it's equivalent to an uninterruptible version of these three statements
Dialogue: 0,1:16:18.88,1:16:23.40,English,,0,0,0,,So we block the signals that are specified in the signal mask
Dialogue: 0,1:16:25.18,1:16:27.46,English,,0,0,0,,And then it's atomic in the sense that
Dialogue: 0,1:16:30.28,1:16:36.22,English,,0,0,0,,After that this these two statements can't be interrupted they're always executed together
Dialogue: 0,1:16:37.28,1:16:39.34,English,,0,0,0,,Okay so we blocked these signals
Dialogue: 0,1:16:40.34,1:16:41.84,English,,0,0,0,,And then we execute the pause
Dialogue: 0,1:16:44.08,1:16:45.30,English,,0,0,0,,Okay so there's no chance
Dialogue: 0,1:16:46.18,1:16:51.60,English,,0,0,0,,Of a signal interrupting this program in between the sigprocmask and the pause
Dialogue: 0,1:16:54.58,1:16:58.74,English,,0,0,0,,Okay and then when a signal does come in and
Dialogue: 0,1:17:00.28,1:17:05.80,English,,0,0,0,,The execution of the handle or causes pause to exit then we set the mask back to what it was before
Dialogue: 0,1:17:08.34,1:17:10.82,English,,0,0,0,,Okay so the proper way then to wait for a signal
Dialogue: 0,1:17:11.74,1:17:13.88,English,,0,0,0,,Is to use sigsuspend in the following way
Dialogue: 0,1:17:14.82,1:17:16.52,English,,0,0,0,,So here's our here's our program again
Dialogue: 0,1:17:17.82,1:17:20.80,English,,0,0,0,,We before we create the child we block sigchild
Dialogue: 0,1:17:21.54,1:17:22.78,English,,0,0,0,,Then we create the child
Dialogue: 0,1:17:23.96,1:17:26.42,English,,0,0,0,,And now we're going to wait for the sigchild to be received
Dialogue: 0,1:17:27.72,1:17:29.48,English,,0,0,0,,Now sigchild is still blocked
Dialogue: 0,1:17:30.26,1:17:34.90,English,,0,0,0,,Okay so there's no danger of the sigchild handler running
Dialogue: 0,1:17:35.42,1:17:38.26,English,,0,0,0,,Okay so we set that global variable to zero
Dialogue: 0,1:17:39.74,1:17:44.52,English,,0,0,0,,And then while it's while it's nonzero we repeatedly call sigsuspend
Dialogue: 0,1:17:46.22,1:17:48.48,English,,0,0,0,,And sigsuspend is using the previous mask
Dialogue: 0,1:17:49.02,1:17:51.76,English,,0,0,0,,That was set up here so sigsuspend is using the mask
Dialogue: 0,1:17:52.50,1:17:54.53,English,,0,0,0,,Where sigchild is unblocked
Dialogue: 0,1:17:55.42,1:18:01.48,English,,0,0,0,,Okay when we entered this first sigprocmask,sigchild was unblocked
Dialogue: 0,1:18:03.32,1:18:08.70,English,,0,0,0,,So this allows inside the sigsuspend sigchild is unblocked
Dialogue: 0,1:18:09.80,1:18:15.42,English,,0,0,0,,Okay so it allows for the handler now to be received or to be executed
Dialogue: 0,1:18:17.16,1:18:21.20,English,,0,0,0,,Okay so in and it does it safely because of the...
Dialogue: 0,1:18:21.72,1:18:24.84,English,,0,0,0,, The atomic nature of those those first two instructions
Dialogue: 0,1:18:27.44,1:18:33.16,English,,0,0,0,,So once the so it's possible that implicit pause inside of sigchild
Dialogue: 0,1:18:33.16,1:18:37.02,English,,0,0,0,,Could be interrupted by say another signal like sigint
Dialogue: 0,1:18:38.28,1:18:42.60,English,,0,0,0,,Okay in which case we'd loop back up we notice that pid was still zero
Dialogue: 0,1:18:42.96,1:18:47.18,English,,0,0,0,,And we go back into sigsuspend with sigchild unblocked
Dialogue: 0,1:18:47.56,1:18:50.16,English,,0,0,0,,Okay so that makes sense to everybody
Dialogue: 0,1:18:50.16,1:18:55.42,English,,0,0,0,,And now so this is exactly the behavior we want where we're not wasting resources but we've eliminated the race
Dialogue: 0,1:18:59.28,1:19:04.44,English,,0,0,0,,Okay so that's it for today if you're interested nonlocal jumps are this weird thing in C
Dialogue: 0,1:19:04.94,1:19:08.92,English,,0,0,0,,That allows a function to return to some other function that didn't call it
Dialogue: 0,1:19:11.14,1:19:17.37,English,,0,0,0,,Okay but it's described in your textbook and also in some additional slides here if you if you're interested
