[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 04  Floating Point.mp4
Video File: ../../../../Desktop/csapp/Lecture 04  Floating Point.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 757
Active Line: 768
Video Position: 128529

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.86,0:00:02.36,English,,0,0,0,,Good afternoon everybody
Dialogue: 0,0:00:03.42,0:00:04.36,English,,0,0,0,,Welcome
Dialogue: 0,0:00:05.64,0:00:06.70,English,,0,0,0,,Good to see you
Dialogue: 0,0:00:11.32,0:00:17.46,English,,0,0,0,,So today we're going to study an arcane area of computer systems known as floating point
Dialogue: 0,0:00:17.98,0:00:22.34,English,,0,0,0,,Which is the way that computer systems represent the real numbers
Dialogue: 0,0:00:24.54,0:00:31.06,English,,0,0,0,,So you're all familiar with decimal you know something like 3.14
Dialogue: 0,0:00:31.52,0:00:36.36,English,,0,0,0,,And there's a similar idea with binary numbers
Dialogue: 0,0:00:36.82,0:00:50.04,English,,0,0,0,,Okay so what does a fractional binary number like 10111.01 represent and how does that work
Dialogue: 0,0:00:51.96,0:00:58.34,English,,0,0,0,, Well it works just like the fractional decimal numbers that you used to
Dialogue: 0,0:01:04.92,0:01:08.76,English,,0,0,0,,So you have a in this case it's a binary point
Dialogue: 0,0:01:08.76,0:01:10.62,English,,0,0,0,,And to the left of the binary point
Dialogue: 0,0:01:12.50,0:01:16.46,English,,0,0,0,,You have bit positions to representing powers-of-2
Dialogue: 0,0:01:16.46,0:01:20.00,English,,0,0,0,,So 2^0,2^1,2^2
Dialogue: 0,0:01:20.64,0:01:26.60,English,,0,0,0,,So 1/2.I'm sorry 1,2,4 and so on
Dialogue: 0,0:01:27.34,0:01:30.50,English,,0,0,0,,And to the right of the binary point
Dialogue: 0,0:01:31.04,0:01:40.46,English,,0,0,0,,You have 2^-1=1/2,2^-2=1/4, 2^-3=1/8 and so on
Dialogue: 0,0:01:41.20,0:01:46.80,English,,0,0,0,,So we can represent that any fractional binary number
Dialogue: 0,0:01:47.54,0:01:57.36,English,,0,0,0,,Using this notation where we sum each the bit at position k*2^k
Dialogue: 0,0:01:58.76,0:02:05.46,English,,0,0,0,,Ok so it's really works exactly the same way as with base 10, just with base 2
Dialogue: 0,0:02:08.94,0:02:13.94,English,,0,0,0,,So let's look at some of these values
Dialogue: 0,0:02:13.94,0:02:20.24,English,,0,0,0,,So 5 3/4 we would represent as 101.11
Dialogue: 0,0:02:21.96,0:02:27.96,English,,0,0,0,,So this is before plus 1 is 5
Dialogue: 0,0:02:29.30,0:02:32.58,English,,0,0,0,,+1/2, +1/4
Dialogue: 0,0:02:32.88,0:02:38.40,English,,0,0,0,,Ok so 2/4+1/4=3/4. so 5 3/4
Dialogue: 0,0:02:38.92,0:02:40.50,English,,0,0,0,,Ok so that's pretty simple
Dialogue: 0,0:02:41.34,0:02:51.92,English,,0,0,0,,2 7/8 is 10.111 so that 10 is 2 of course
Dialogue: 0,0:02:53.90,0:03:08.66,English,,0,0,0,,And then .111 is 1/2,so 4/8+1/4=2/8 + 1/8,okay so 7/8
Dialogue: 0,0:03:11.58,0:03:21.04,English,,0,0,0,,And 1 7/16 would be 1.0111
Dialogue: 0,0:03:21.16,0:03:24.20,English,,0,0,0,,So that the 1 to the left of the binary point is 1
Dialogue: 0,0:03:25.08,0:03:31.04,English,,0,0,0,,And then we have 1/4+1/8+1/16
Dialogue: 0,0:03:32.00,0:03:47.70,English,,0,0,0,,So 1/4 is 4/16, 1/8 is 2/16 and 1/16,so you add those up you get 7/16
Dialogue: 0,0:03:49.48,0:03:51.66,English,,0,0,0,,Okay now notice that for some of these numbers
Dialogue: 0,0:03:51.66,0:03:57.90,English,,0,0,0,,This bit pattern 101.11
Dialogue: 0,0:03:58.50,0:04:02.82,English,,0,0,0,,If we shift it to the right to get 10.111
Dialogue: 0,0:04:04.36,0:04:08.58,English,,0,0,0,,We've divided by 2 right so we've taken 5 3/4 and divided it by 2
Dialogue: 0,0:04:09.20,0:04:12.00,English,,0,0,0,,And it works the other way too
Dialogue: 0,0:04:12.00,0:04:17.28,English,,0,0,0,,If you shift to the left you multiply if you shift to the left by 1 you multiply by 1
Dialogue: 0,0:04:19.02,0:04:26.12,English,,0,0,0,,And these numbers that are all ones to the right of the of the binary point
Dialogue: 0,0:04:26.12,0:04:31.62,English,,0,0,0,,These are numbers that are just slightly less than 1 okay
Dialogue: 0,0:04:33.50,0:04:36.14,English,,0,0,0,,So well when we want to represent those
Dialogue: 0,0:04:36.14,0:04:43.36,English,,0,0,0,,We will sometimes refer to those numbers of that form is 1- ℇ
Dialogue: 0,0:04:43.36,0:04:50.16,English,,0,0,0,,And epsilon just depends on how many bits you have to the right of the binary point
Dialogue: 0,0:04:50.38,0:04:56.40,English,,0,0,0,,So epsilon gets smaller the more,the more of those bits you have there it gets closer to 1
Dialogue: 0,0:04:56.90,0:04:59.30,English,,0,0,0,,And epsilon gets smaller the more of those bits you have
Dialogue: 0,0:05:00.92,0:05:08.08,English,,0,0,0,,Now there's limitations in this kind of representation
Dialogue: 0,0:05:08.08,0:05:14.18,English,,0,0,0,,So first of all we can only represent rational numbers of the form x/2^k
Dialogue: 0,0:05:14.18,0:05:16.80,English,,0,0,0,,We can only represent numbers of that form exactly
Dialogue: 0,0:05:17.20,0:05:23.70,English,,0,0,0,,Other numbers have to get have repeating bit representations that can't be represented
Dialogue: 0,0:05:24.06,0:05:27.82,English,,0,0,0,,With a finite number of bits that we have in a computer system
Dialogue: 0,0:05:29.14,0:05:38.54,English,,0,0,0,,So for example things like a 1/3 is this repeating representation 1/5 and 1/10 or other examples of that
Dialogue: 0,0:05:39.28,0:05:42.06,English,,0,0,0,,Now the other problem we have is that
Dialogue: 0,0:05:42.68,0:05:45.18,English,,0,0,0,,We can only...
Dialogue: 0,0:05:45.18,0:05:49.02,English,,0,0,0,,There's only so many bits to the left and the right of the the binary point
Dialogue: 0,0:05:49.88,0:05:52.06,English,,0,0,0,,So we're kind of...
Dialogue: 0,0:05:52.12,0:05:55.48,English,,0,0,0,,If we move the binary point to the left
Dialogue: 0,0:05:56.98,0:06:02.90,English,,0,0,0,,Then we don't have as many we can't represent as many large numbers
Dialogue: 0,0:06:02.90,0:06:04.62,English,,0,0,0,,We can only represent small numbers
Dialogue: 0,0:06:04.62,0:06:07.54,English,,0,0,0,,But we have more precision to the right of the binary point
Dialogue: 0,0:06:07.76,0:06:10.18,English,,0,0,0,, so we can represent more fractional values
Dialogue: 0,0:06:10.60,0:06:13.70,English,,0,0,0,,Just the range of those values will be much smaller
Dialogue: 0,0:06:14.56,0:06:16.98,English,,0,0,0,,Similarly if we move the binary point to the right
Dialogue: 0,0:06:17.78,0:06:20.32,English,,0,0,0,,We'll have a larger range of values
Dialogue: 0,0:06:20.54,0:06:23.18,English,,0,0,0,, But we won't build represent as many fractions
Dialogue: 0,0:06:24.82,0:06:32.06,English,,0,0,0,,So there's this kind of trade-off  and floating point is a representation
Dialogue: 0,0:06:32.80,0:06:42.76,English,,0,0,0,,To try that enables us to move that basically to move that binary point to represent sort of as wide a range as possible
Dialogue: 0,0:06:43.14,0:06:46.26,English,,0,0,0,,With as much precision given the number of bits
Dialogue: 0,0:06:46.78,0:06:49.14,English,,0,0,0,,The finite number of bits that we have to work with
Dialogue: 0,0:06:49.50,0:06:54.56,English,,0,0,0,,So that the float and floating point is this sort of shifting binary point right
Dialogue: 0,0:06:54.56,0:06:57.16,English,,0,0,0,,This floating, the floating binary point
Dialogue: 0,0:06:59.24,0:07:02.24,English,,0,0,0,,Now up until 1985
Dialogue: 0,0:07:02.64,0:07:05.94,English,,0,0,0,,A floating point was just a disaster 
Dialogue: 0,0:07:06.48,0:07:11.18,English,,0,0,0,,And every computer manufacturer had their own representation
Dialogue: 0,0:07:12.40,0:07:16.22,English,,0,0,0,,You couldn't...and it was just terrible,because you couldn't predict
Dialogue: 0,0:07:16.90,0:07:21.46,English,,0,0,0,,What would happen if you moved your program from one machine to another
Dialogue: 0,0:07:21.84,0:07:24.66,English,,0,0,0,,The behavior would be different the rounding would be different
Dialogue: 0,0:07:25.86,0:07:35.13,English,,0,0,0,,It was a very difficult situation and people really computer scientists in particular really disliked floating point
Dialogue: 0,0:07:35.62,0:07:45.02,English,,0,0,0,,In 1985 IEEE which is the professional association for electrical engineers
Dialogue: 0,0:07:45.44,0:07:51.02,English,,0,0,0,,Introduced a...and it's also a very important standards body
Dialogue: 0,0:07:51.34,0:07:56.54,English,,0,0,0,,They introduced a standard floating-point representation called IEEE floating point
Dialogue: 0,0:07:57.16,0:08:00.52,English,,0,0,0,,Which was then adopted by all computer manufacturers
Dialogue: 0,0:08:00.52,0:08:02.16,English,,0,0,0,,So now the situation is much better
Dialogue: 0,0:08:02.60,0:08:06.96,English,,0,0,0,,Everybody supports the same kind of floating point representation
Dialogue: 0,0:08:06.98,0:08:08.84,English,,0,0,0,,Which is what we're going to learn about today
Dialogue: 0,0:08:14.66,0:08:18.38,English,,0,0,0,,So the floating point has the form
Dialogue: 0,0:08:19.34,0:08:24.26,English,,0,0,0,,It represents numbers in a this is like a scientific notation
Dialogue: 0,0:08:24.46,0:08:36.66,English,,0,0,0,, It represents numbers of the form (-1)^s,where s is a sign bit,times a significant m
Dialogue: 0,0:08:38.00,0:08:43.60,English,,0,0,0,,Ok times 2^E
Dialogue: 0,0:08:43.94,0:08:51.86,English,,0,0,0,,Ok so all of the numbers that we can represent in floating point have to be represented in this form
Dialogue: 0,0:08:53.04,0:08:59.42,English,,0,0,0,,So the sign bit s determines whether the number is negative or positive obviously
Dialogue: 0,0:08:59.86,0:09:04.02,English,,0,0,0,,The significant m and this is sometimes sometimes called the mantissa
Dialogue: 0,0:09:04.02,0:09:05.68,English,,0,0,0,,Where the m comes from
Dialogue: 0,0:09:06.16,0:09:13.06,English,,0,0,0,,The significant m normally is a fractional value in the range between 1 and 2
Dialogue: 0,0:09:13.06,0:09:16.00,English,,0,0,0,,And we'll see why that is in a second
Dialogue: 0,0:09:16.52,0:09:19.88,English,,0,0,0,,And then the exponent e weights the value by some power-of-2
Dialogue: 0,0:09:20.48,0:09:25.76,English,,0,0,0,,Okay so this is encoded either 32-bit or 64-bit
Dialogue: 0,0:09:26.28,0:09:30.42,English,,0,0,0,,In the following way the the sign bit s is the most significant bit
Dialogue: 0,0:09:31.26,0:09:34.62,English,,0,0,0,,And then this is followed by some number of
Dialogue: 0,0:09:34.64,0:09:37.86,English,,0,0,0,,By some number of bits called the exp field
Dialogue: 0,0:09:38.74,0:09:42.20,English,,0,0,0,,Which encodes the exponent e
Dialogue: 0,0:09:43.24,0:09:47.70,English,,0,0,0,,But it's not identical to e,it encodes e we'll see how that works
Dialogue: 0,0:09:48.18,0:09:54.54,English,,0,0,0,,And then the frac. And then that's followed the remaining bits are the the frac field
Dialogue: 0,0:09:55.96,0:09:59.38,English,,0,0,0,, Which encodes m but isn't identical to m
Dialogue: 0,0:10:02.02,0:10:09.46,English,,0,0,0,, Now we are...IEEE floating point has provides two different kinds of floating-point
Dialogue: 0,0:10:09.46,0:10:14.47,English,,0,0,0,,The single precision 32 bits and so-called double precision which is 64 bits
Dialogue: 0,0:10:15.12,0:10:20.38,English,,0,0,0,,There's this funky intel extended precision
Dialogue: 0,0:10:20.38,0:10:22.84,English,,0,0,0,,Which is non-standard and we won't talk about it anymore
Dialogue: 0,0:10:25.18,0:10:27.82,English,,0,0,0,,And so in the single precision 32 bits
Dialogue: 0,0:10:27.82,0:10:30.30,English,,0,0,0,,You have one sign bit, there's always a sign bit
Dialogue: 0,0:10:30.30,0:10:34.68,English,,0,0,0,,You have 8 exp bits and you have 23 frac bits
Dialogue: 0,0:10:35.34,0:10:40.20,English,,0,0,0,,In double precision you have 11 exp and 52 frac bits
Dialogue: 0,0:10:42.58,0:10:47.60,English,,0,0,0,,Now there's a number of different kinds of floating-point representations
Dialogue: 0,0:10:48.12,0:10:54.22,English,,0,0,0,,The sort of the default and sort of the common representation is called normalized
Dialogue: 0,0:10:55.38,0:10:57.17,English,,0,0,0,,So called normalized values
Dialogue: 0,0:10:58.26,0:11:00.28,English,,0,0,0,,And normalized values are
Dialogue: 0,0:11:01.12,0:11:05.46,English,,0,0,0,,All the values where the exp field is not equal to 0
Dialogue: 0,0:11:06.06,0:11:10.78,English,,0,0,0,,And not equal to all zeros and not equal to all ones 
Dialogue: 0,0:11:11.46,0:11:17.48,English,,0,0,0,,So everything all zeros and all ones are special kinds of numbers we'll look at second
Dialogue: 0,0:11:18.58,0:11:20.80,English,,0,0,0,,So the exponent
Dialogue: 0,0:11:21.74,0:11:30.54,English,,0,0,0,,This exponent e remember our numbers are (-1)^s*m*2^E
Dialogue: 0,0:11:31.36,0:11:37.94,English,,0,0,0,,The exponent e is encoded as this biased value
Dialogue: 0,0:11:39.76,0:11:42.74,English,,0,0,0,,Which is the called exp
Dialogue: 0,0:11:43.44,0:11:48.06,English,,0,0,0,,So the x the exponent E is Exp - bias
Dialogue: 0,0:11:48.50,0:11:50.88,English,,0,0,0,,And exp is the value
Dialogue: 0,0:11:51.10,0:11:57.56,English,,0,0,0,,Exp is the value of the exp bits, the bits in the exp field treated as a positive number
Dialogue: 0,0:11:57.96,0:12:09.72,English,,0,0,0,,Okay so Exp you just look at it as an unsigned  7-bit in case of single precision 7-bit number
Dialogue: 0,0:12:11.40,0:12:20.44,English,,0,0,0,, Okay now the bias=2^(k-1) - 1,where k is number of exponent bits
Dialogue: 0,0:12:21.08,0:12:26.85,English,,0,0,0,,Okay so for single precision we have 8 exponent bits
Dialogue: 0,0:12:27.72,0:12:39.86,English,,0,0,0,,So 2^8, 2^(8-1=7) so 2^7=128 - 1 is 127
Dialogue: 0,0:12:40.00,0:12:43.36,English,,0,0,0,,Ok so the bias for single precision is 127
Dialogue: 0,0:12:43.88,0:12:47.00,English,,0,0,0,,And similarly for double precision it's 1023
Dialogue: 0,0:12:49.82,0:12:54.94,English,,0,0,0,,Okay so you just have to memorize this formula
Dialogue: 0,0:12:54.94,0:13:03.02,English,,0,0,0,,The exponent E is the exp field interpret it as an unsigned number minus the the bias
Dialogue: 0,0:13:04.24,0:13:10.58,English,,0,0,0,,This is kind of a strange thing the first time you encounter floating-point
Dialogue: 0,0:13:10.78,0:13:13.66,English,,0,0,0,,It seems kind of odd right so why not
Dialogue: 0,0:13:14.92,0:13:16.78,English,,0,0,0,,I mean we've already learned about two's complement
Dialogue: 0,0:13:16.78,0:13:20.66,English,,0,0,0,,That's a perfectly fine way to represent positive and negative numbers
Dialogue: 0,0:13:21.28,0:13:26.42,English,,0,0,0,,Okay we have exponents that are negative and positive right
Dialogue: 0,0:13:26.42,0:13:29.04,English,,0,0,0,,So why not just use the exp field to represent
Dialogue: 0,0:13:29.98,0:13:37.12,English,,0,0,0,,Why not just use a two's complement in the exp field to represent those positive and negative exponents right
Dialogue: 0,0:13:37.88,0:13:42.14,English,,0,0,0,,So it turns out that the reason they do this is
Dialogue: 0,0:13:44.72,0:13:45.72,English,,0,0,0,, is that...
Dialogue: 0,0:13:46.28,0:13:49.72,English,,0,0,0,,And if you think about think about this and we'll come back to it
Dialogue: 0,0:13:49.74,0:13:56.90,English,,0,0,0,,But if we encode the the exponent E using this bias representation
Dialogue: 0,0:13:57.82,0:14:02.40,English,,0,0,0,,The smallest negative exponent is represented by all zeros
Dialogue: 0,0:14:05.10,0:14:12.38,English,,0,0,0,,And the largest exponent is represented by 01111
Dialogue: 0,0:14:15.22,0:14:20.64,English,,0,0,0,,So the smallest, the number with the smallest exponent
Dialogue: 0,0:14:21.34,0:14:22.98,English,,0,0,0,,If we were just to compare the bits
Dialogue: 0,0:14:22.98,0:14:30.12,English,,0,0,0,,Using a just some kind of unsigned representation just comparing the bits  treating it as an unsigned number
Dialogue: 0,0:14:30.70,0:14:33.52,English,,0,0,0,, By using this biased representation
Dialogue: 0,0:14:33.52,0:14:38.40,English,,0,0,0,, We can just compare two floating-point numbers just as unsigned
Dialogue: 0,0:14:38.40,0:14:43.10,English,,0,0,0,, We can treat the whole floating-point number as an unsigned integer and compare two numbers
Dialogue: 0,0:14:43.50,0:14:46.24,English,,0,0,0,,And get a true comparison
Dialogue: 0,0:14:50.58,0:14:54.56,English,,0,0,0,,So the exponent uses this this sort of biasing encoding
Dialogue: 0,0:14:55.22,0:15:00.98,English,,0,0,0,,And then the significant is encoded with an implied one
Dialogue: 0,0:15:01.52,0:15:06.52,English,,0,0,0,,So and this is where they are...this is where the normalized
Dialogue: 0,0:15:07.04,0:15:09.04,English,,0,0,0,, In the normalized representation comes from
Dialogue: 0,0:15:09.70,0:15:11.84,English,,0,0,0,,That we're always going to represent our numbers
Dialogue: 0,0:15:12.44,0:15:16.74,English,,0,0,0,, So m we're always going to normalize m
Dialogue: 0,0:15:16.74,0:15:19.24,English,,0,0,0,, No matter what the number we want to represent
Dialogue: 0,0:15:19.24,0:15:23.26,English,,0,0,0,, We're always going to normalize m as one point something
Dialogue: 0,0:15:23.98,0:15:26.52,English,,0,0,0,,And then we adjust the exponent accordingly
Dialogue: 0,0:15:26.94,0:15:32.66,English,,0,0,0,, So if the value we want to represent is 100.01
Dialogue: 0,0:15:33.56,0:15:37.68,English,,0,0,0,,We're going to shift it over and it will be 1.00
Dialogue: 0,0:15:40.60,0:15:45.04,English,,0,0,0,, Okay and then we'll adjust the exponent to represent that shift
Dialogue: 0,0:15:47.44,0:15:54.34,English,,0,0,0,,Okay so the bits in the frac field xxxx...x are
Dialogue: 0,0:15:54.86,0:15:58.10,English,,0,0,0,,All of the numbers to the right of the binary point right
Dialogue: 0,0:15:58.10,0:16:00.18,English,,0,0,0,,So there's always this implied one
Dialogue: 0,0:16:01.48,0:16:03.52,English,,0,0,0,,But we don't even encode it we just throw it away
Dialogue: 0,0:16:03.52,0:16:05.14,English,,0,0,0,,Because it's always there right
Dialogue: 0,0:16:05.14,0:16:08.90,English,,0,0,0,,So this is a little trick just to get it one more bit for free
Dialogue: 0,0:16:10.18,0:16:14.40,English,,0,0,0,,Okay so the the xxx bits in the frac field
Dialogue: 0,0:16:15.06,0:16:21.72,English,,0,0,0,,All the bits to the right of the binary point after one point the one point
Dialogue: 0,0:16:22.66,0:16:27.54,English,,0,0,0,,And this is,the so this is the smallest fractal is all zeros
Dialogue: 0,0:16:27.56,0:16:31.10,English,,0,0,0,, Which corresponds to a significant of 1.0
Dialogue: 0,0:16:34.26,0:16:39.64,English,,0,0,0,,A frac field of all ones corresponds to 2-ɛ
Dialogue: 0,0:16:39.64,0:16:43.04,English,,0,0,0,,So that's 1.111...
Dialogue: 0,0:16:47.08,0:16:50.64,English,,0,0,0,,So let's look at an example
Dialogue: 0,0:16:51.82,0:16:56.06,English,,0,0,0,,So let's look at how we would encode 15213 which our favorite number 
Dialogue: 0,0:16:58.84,0:17:01.12,English,,0,0,0,,In two's complement in floating point
Dialogue: 0,0:17:02.52,0:17:05.22,English,,0,0,0,,So the if we represent that so it's an integer
Dialogue: 0,0:17:06.60,0:17:15.34,English,,0,0,0,,And we represent it using these bits take my word for it correspond to the integer 213
Dialogue: 0,0:17:16.22,0:17:18.56,English,,0,0,0,,So now we want to convert it we want to normalize it
Dialogue: 0,0:17:20.88,0:17:26.70,English,,0,0,0,, By expressing it as 1.110 and so on times 2^13
Dialogue: 0,0:17:27.22,0:17:29.50,English,,0,0,0,,Okay same number we just normalized it
Dialogue: 0,0:17:29.78,0:17:32.26,English,,0,0,0,,So that there's always this leading 1
Dialogue: 0,0:17:36.76,0:17:45.62,English,,0,0,0,, So the significant m is 1.11011 and so on
Dialogue: 0,0:17:46.74,0:17:50.78,English,,0,0,0,,The frac field is everything to the right of the binary point
Dialogue: 0,0:17:50.94,0:17:54.60,English,,0,0,0,,So we just,we throw this one away
Dialogue: 0,0:17:54.60,0:17:59.44,English,,0,0,0,,And we just take the the values to the right of the binary point
Dialogue: 0,0:17:59.74,0:18:04.62,English,,0,0,0,,And then we pat it out with zeros 2 to get the 23 bits that we need for single precision
Dialogue: 0,0:18:07.40,0:18:09.10,English,,0,0,0,, Ok so now we've got our frac field
Dialogue: 0,0:18:11.14,0:18:12.22,English,,0,0,0,, The exponent
Dialogue: 0,0:18:13.12,0:18:15.74,English,,0,0,0,,So in this case right E is
Dialogue: 0,0:18:16.98,0:18:20.72,English,,0,0,0,,We're multiplying by 2 ^13.So E is 13
Dialogue: 0,0:18:21.26,0:18:25.36,English,,0,0,0,,So we want to represent the value 13 using this bias encoding
Dialogue: 0,0:18:27.84,0:18:29.86,English,,0,0,0,,So the bias is 127
Dialogue: 0,0:18:32.26,0:18:41.38,English,,0,0,0,,And so the exponent the value of the exp field should be 140
Dialogue: 0,0:18:41.58,0:18:49.32,English,,0,0,0,,Because if we take 140-127 we get 13
Dialogue: 0,0:18:50.98,0:18:54.52,English,,0,0,0,,Okay so 140 is represented using these 8 bits
Dialogue: 0,0:18:55.58,0:18:58.02,English,,0,0,0,,And that becomes our exp field
Dialogue: 0,0:19:00.02,0:19:01.92,English,,0,0,0,, Okay so the resulting floating-point number
Dialogue: 0,0:19:01.92,0:19:05.08,English,,0,0,0,, And of course it's a positive number so the significand bit is zero
Dialogue: 0,0:19:06.96,0:19:09.72,English,,0,0,0,, So the resulting floating point number has these eight
Dialogue: 0,0:19:10.30,0:19:19.30,English,,0,0,0,,The 8 bits and exp field that we computed by subtracting 127 from 140
Dialogue: 0,0:19:20.00,0:19:27.68,English,,0,0,0,,And then the frack field are these bits that we got here by just taking everything to the right of the binary point
Dialogue: 0,0:19:32.12,0:19:33.10,English,,0,0,0,, So this...
Dialogue: 0,0:19:35.88,0:19:38.18,English,,0,0,0,,So let's look at this exponent just a little bit more
Dialogue: 0,0:19:38.18,0:19:41.80,English,,0,0,0,,Because I think can be a little confusing
Dialogue: 0,0:19:46.90,0:19:54.94,English,,0,0,0,,So in our example
Dialogue: 0,0:19:55.02,0:20:00.32,English,,0,0,0,,If we want to look at the range of exp
Dialogue: 0,0:20:00.32,0:20:07.14,English,,0,0,0,,So what's the smallest value of exp
Dialogue: 0,0:20:07.26,0:20:10.82,English,,0,0,0,,What's the smallest value of exp?
Dialogue: 0,0:20:10.82,0:20:14.86,English,,0,0,0,,No way,no doughnut, don't confuse the encoding with the value it represents
Dialogue: 0,0:20:15.38,0:20:17.60,English,,0,0,0,, Exp is just the encoding
Dialogue: 0,0:20:17.70,0:20:21.14,English,,0,0,0,,So what's...  what's the smallest value of exp?
Dialogue: 0,0:20:22.02,0:20:26.08,English,,0,0,0,, 0 that's right
Dialogue: 0,0:20:26.18,0:20:29.82,English,,0,0,0,,Okay and the largest value is? is what?
Dialogue: 0,0:20:29.82,0:20:34.56,English,,0,0,0,,It's... what's the largest value?
Dialogue: 0,0:20:34.76,0:20:35.62,English,,0,0,0,,Yes
Dialogue: 0,0:20:35.62,0:20:38.22,English,,0,0,0,,[student speaking]
Dialogue: 0,0:20:38.22,0:20:43.88,English,,0,0,0,,Well the largest value would be remember it can't be all ones
Dialogue: 0,0:20:45.72,0:20:48.94,English,,0,0,0,,Right so the largest value would be 2^8-1
Dialogue: 0,0:20:51.04,0:20:55.32,English,,0,0,0,,So okay so the largest value would be 01111...
Dialogue: 0,0:20:55.32,0:20:57.20,English,,0,0,0,,0 followed by 7 ones
Dialogue: 0,0:20:59.88,0:21:03.62,English,,0,0,0,,So that's a 2^8-1 is ...
Dialogue: 0,0:21:03.64,0:21:13.06,English,,0,0,0,,255 good
Dialogue: 0,0:21:13.12,0:21:16.42,English,,0,0,0,,Okay so then what's the range the of E
Dialogue: 0,0:21:16.56,0:21:19.90,English,,0,0,0,,Which is the actual value that we want to encode
Dialogue: 0,0:21:24.28,0:21:26.94,English,,0,0,0,,Okay member use this we have this definition
Dialogue: 0,0:21:27.54,0:21:29.98,English,,0,0,0,,So we have the range of values for exp
Dialogue: 0,0:21:30.46,0:21:32.52,English,,0,0,0,,We have our bias
Dialogue: 0,0:21:32.52,0:21:34.64,English,,0,0,0,,So what is the range of values for E
Dialogue: 0,0:21:34.64,0:21:37.66,English,,0,0,0,,This is the actual exponents that we're encoding
Dialogue: 0,0:21:38.74,0:21:47.20,English,,0,0,0,,So what's the smallest exponent,-127 good
Dialogue: 0,0:21:47.36,0:21:53.66,English,,0,0,0,,Right because that's zero is our smallest exp-bias which is 127
Dialogue: 0,0:21:53.66,0:21:59.06,English,,0,0,0,,Okay so the smallest value of E is 127
Dialogue: 0,0:21:59.06,0:22:02.42,English,,0,0,0,,And the largest value of E is ?
Dialogue: 0,0:22:08.64,0:22:25.16,English,,0,0,0,,So if we take the largest value of exp that's 255-127=128
Dialogue: 0,0:22:25.16,0:22:30.80,English,,0,0,0,,Okay so the numbers that we can represent using this bias notation
Dialogue: 0,0:22:31.70,0:22:35.40,English,,0,0,0,,We have the smallest exponent will be 2^ -127
Dialogue: 0,0:22:36.12,0:22:41.65,English,,0,0,0,,And the largest exponent will be 2 to the raised to the power 128
Dialogue: 0,0:22:42.40,0:22:46.24,English,,0,0,0,,Okay so you see what's going on here
Dialogue: 0,0:22:46.24,0:22:49.78,English,,0,0,0,,So we have a range of values for E
Dialogue: 0,0:22:49.96,0:22:54.74,English,,0,0,0,,Here's the largest value,here's the smallest value,here's 0 right in the middle
Dialogue: 0,0:22:55.30,0:22:58.52,English,,0,0,0,,These are the values we want to represent this biasing is like a shift
Dialogue: 0,0:22:59.08,0:23:03.40,English,,0,0,0,, We've just now we're shifting up by 127
Dialogue: 0,0:23:03.62,0:23:07.32,English,,0,0,0,,So that now the smallest exponent is represented by 0
Dialogue: 0,0:23:09.50,0:23:13.34,English,,0,0,0,,Okay any questions about that
Dialogue: 0,0:23:23.20,0:23:30.66,English,,0,0,0,,Now these normalized values always have this implied one
Dialogue: 0,0:23:31.68,0:23:36.92,English,,0,0,0,,Okay which... when we want to represent numbers closer to zero
Dialogue: 0,0:23:37.22,0:23:40.22,English,,0,0,0,,That limits us right
Dialogue: 0,0:23:40.22,0:23:46.40,English,,0,0,0,,So there's another type of floating-point number called the denormalized value
Dialogue: 0,0:23:47.18,0:23:50.94,English,,0,0,0,,Which is characterized by an exp field of all 0
Dialogue: 0,0:23:52.72,0:23:58.42,English,,0,0,0,,And in a denormalized number or denorm there's no implied one
Dialogue: 0,0:23:59.20,0:24:09.24,English,,0,0,0,,Okay so the the significant m is represented exactly is encoded identically in the frac field
Dialogue: 0,0:24:09.98,0:24:11.38,English,,0,0,0,,So there's no implied one
Dialogue: 0,0:24:12.08,0:24:18.56,English,,0,0,0,,And all of the numbers are the form zero point something something something after them
Dialogue: 0,0:24:21.18,0:24:28.58,English,,0,0,0,,And the exponent value E instead of you remember for denorms we subtracted bias from exp
Dialogue: 0,0:24:29.18,0:24:33.64,English,,0,0,0,, For denorm we subtract the bias from one
Dialogue: 0,0:24:33.68,0:24:37.12,English,,0,0,0,,Okay now if we just use the definition
Dialogue: 0,0:24:37.12,0:24:40.86,English,,0,0,0,,We use for normalized numbers that would be...exp would be zero
Dialogue: 0,0:24:41.88,0:24:45.18,English,,0,0,0,,So we don't do that instead
Dialogue: 0,0:24:45.92,0:24:47.72,English,,0,0,0,,E is 1 - bias
Dialogue: 0,0:24:49.18,0:24:54.78,English,,0,0,0,,And then the significant is coded with an implied leading 0 instead of a leading one like a mentioned
Dialogue: 0,0:24:57.98,0:25:02.86,English,,0,0,0,,So when exp is zero and also I mean
Dialogue: 0,0:25:02.86,0:25:08.06,English,,0,0,0,,We think about it. If we only had denormalized numbers
Dialogue: 0,0:25:08.06,0:25:12.58,English,,0,0,0,, We wouldn't be able to represent zero right because there'd always be a 1 in there
Dialogue: 0,0:25:13.72,0:25:16.92,English,,0,0,0,, So the denorms allow us to represent zero
Dialogue: 0,0:25:16.92,0:25:20.96,English,,0,0,0,,And they allow us to represent values that are very close to zero
Dialogue: 0,0:25:22.70,0:25:24.26,English,,0,0,0,,So when the exponent is zero
Dialogue: 0,0:25:24.52,0:25:29.74,English,,0,0,0,, And the exp field is zero and the frac field is zero then this is the zero value
Dialogue: 0,0:25:30.60,0:25:35.08,English,,0,0,0,,And so this is nice because all zeros represents zero
Dialogue: 0,0:25:35.12,0:25:37.22,English,,0,0,0,,Which is you know sort of which one
Dialogue: 0,0:25:38.56,0:25:40.42,English,,0,0,0,,There is the sort of weird thing though that
Dialogue: 0,0:25:41.08,0:25:46.48,English,,0,0,0,,If you have a the sign bit is 1
Dialogue: 0,0:25:46.48,0:25:52.32,English,,0,0,0,,And then your frac and exp is 0 then you have -0
Dialogue: 0,0:25:52.32,0:25:55.58,English,,0,0,0,, So you have this kind of odd situation where there's a positive and negative zero
Dialogue: 0,0:26:00.42,0:26:04.34,English,,0,0,0,,Okay and other values if exp is zero and you have a nonzero frac
Dialogue: 0,0:26:04.34,0:26:08.98,English,,0,0,0,,And those are the equally spaced numbers that are closest to zero
Dialogue: 0,0:26:12.14,0:26:14.86,English,,0,0,0,,Now there's a couple of other special values
Dialogue: 0,0:26:15.04,0:26:21.14,English,,0,0,0,,When exp is all ones and frac is all zeros
Dialogue: 0,0:26:21.14,0:26:23.08,English,,0,0,0,,This represents the value infinity
Dialogue: 0,0:26:24.78,0:26:27.44,English,,0,0,0,,So this is a value that that we get
Dialogue: 0,0:26:27.44,0:26:31.66,English,,0,0,0,,When is some kind of addition or multiplication and we overflow
Dialogue: 0,0:26:32.46,0:26:38.48,English,,0,0,0,, So in floating point always overflows to the special value called infinity there positive or negative infinity
Dialogue: 0,0:26:38.74,0:26:41.02,English,,0,0,0,,So it's different from two's complement right where
Dialogue: 0,0:26:41.44,0:26:48.52,English,,0,0,0,,You sort of overflowed into in this modular way back  just back it round into the range of numbers
Dialogue: 0,0:26:48.52,0:26:56.54,English,,0,0,0,, In floating point we just overflow to the sticky value called infinity and then everything we do on that remains infinity
Dialogue: 0,0:26:59.80,0:27:01.62,English,,0,0,0,, So for example if we did...
Dialogue: 0,0:27:06.70,0:27:14.84,English,,0,0,0,, If we did 1/0 or -1/-0 we'd get positive infinity
Dialogue: 0,0:27:14.84,0:27:19.46,English,,0,0,0,, If we divide 1 by 0 negative 0 we get negative infinity
Dialogue: 0,0:27:20.72,0:27:33.06,English,,0,0,0,,The fourth kind of special case special number is the case where  the exponent again is all once but the frac is nonzero in a nonzero value
Dialogue: 0,0:27:33.26,0:27:36.56,English,,0,0,0,,And this represents what's called not a number so this is
Dialogue: 0,0:27:37.22,0:27:41.92,English,,0,0,0,,This handles cases where there's no,there's no answer
Dialogue: 0,0:27:41.92,0:27:46.52,English,,0,0,0,,There's no feasible answer for example if we you know try to take the square root of -1
Dialogue: 0,0:27:46.84,0:27:49.10,English,,0,0,0,,What we'll get back is not a number
Dialogue: 0,0:27:55.26,0:28:02.10,English,,0,0,0,,So I think it's helpful to to visualize these the number line now so the
Dialogue: 0,0:28:02.86,0:28:11.48,English,,0,0,0,,We have +0,-0 sort of right next to each other and then to the right of that are the positive denorms
Dialogue: 0,0:28:13.14,0:28:19.54,English,,0,0,0,,And then those sort of transition into the normalized numbers
Dialogue: 0,0:28:20.32,0:28:23.90,English,,0,0,0,, And then you have infinity positive infinity
Dialogue: 0,0:28:24.44,0:28:29.20,English,,0,0,0,,You have a similar similar situation on the for the negative numbers
Dialogue: 0,0:28:30.36,0:28:34.48,English,,0,0,0,,And then negative and positive not a numbers
Dialogue: 0,0:28:39.58,0:28:43.28,English,,0,0,0,,So I think the you know you've probably discovered
Dialogue: 0,0:28:43.50,0:28:50.38,English,,0,0,0,,The really good way to try to understand these numeric and Coatings is just to do examples with only a few number of bits
Dialogue: 0,0:28:50.86,0:28:54.02,English,,0,0,0,,You know if you want to understand like for example in two's complement
Dialogue: 0,0:28:54.60,0:28:59.20,English,,0,0,0,,If you want to understand Tmin and Tmax and how they relate to each other
Dialogue: 0,0:28:59.56,0:29:03.88,English,,0,0,0,,Just do a three bit two's complement system
Dialogue: 0,0:29:03.88,0:29:07.08,English,,0,0,0,,You know imagine just have a system with two's complement of three bits
Dialogue: 0,0:29:07.68,0:29:11.68,English,,0,0,0,,And then you can just enumerate all those all the possibilities and you can see
Dialogue: 0,0:29:12.38,0:29:17.96,English,,0,0,0,,And then you see where you know the Tmin is actually one greater than Tmax
Dialogue: 0,0:29:17.96,0:29:22.58,English,,0,0,0,,You know so if you add one to Tmax it actually overflows into Tmin
Dialogue: 0,0:29:25.20,0:29:29.98,English,,0,0,0,,Similar thing for floating point it's...I would really encourage you to do this
Dialogue: 0,0:29:29.98,0:29:36.80,English,,0,0,0,,Just try some simple examples with a sort of tyent with a small number  of exp and frack bits
Dialogue: 0,0:29:37.32,0:29:43.48,English,,0,0,0,,So in this case we're going to look at a floating point system based on IEEE
Dialogue: 0,0:29:43.50,0:29:47.58,English,,0,0,0,,That has 4 exp bits and three frack bits
Dialogue: 0,0:29:48.64,0:29:51.48,English,,0,0,0,,As always the sign bit is the most significant bit
Dialogue: 0,0:29:52.04,0:29:54.20,English,,0,0,0,,Followed by exp followed by frac
Dialogue: 0,0:29:55.92,0:30:03.08,English,,0,0,0,,Okay so this is identical to IEEE floating point except for the size of that  exp in fractals
Dialogue: 0,0:30:04.42,0:30:10.72,English,,0,0,0,,So it's actually small enough that we can now just enumerate these values
Dialogue: 0,0:30:11.56,0:30:22.96,English,,0,0,0,,And now you can, you can start to see why these weird definitions for the exponent in the denominator
Dialogue: 0,0:30:23.84,0:30:27.02,English,,0,0,0,,So let's just look at...
Dialogue: 0,0:30:27.76,0:30:32.52,English,,0,0,0,,So we will stand here,we've just 
Dialogue: 0,0:30:33.46,0:30:40.92,English,,0,0,0,,All of 2^7 possibilities possible combinations of exp and frac fields starting with zero
Dialogue: 0,0:30:42.50,0:30:45.16,English,,0,0,0,,Okay so when exp is all zeros
Dialogue: 0,0:30:45.52,0:30:48.38,English,,0,0,0,,That's a denorm right by definition
Dialogue: 0,0:30:49.72,0:30:59.34,English,,0,0,0,,And then we have the three frac bits or all zero
Dialogue: 0,0:30:59.66,0:31:03.04,English,,0,0,0,,Okay so remember the exp is all zeros
Dialogue: 0,0:31:03.44,0:31:13.20,English,,0,0,0,,Right so the for denorm the, exponent value is 1- bias, bias here is 7
Dialogue: 0,0:31:14.12,0:31:18.71,English,,0,0,0,,Okay so 1-7 gives us a value for the exponent of  -6
Dialogue: 0,0:31:19.56,0:31:21.42,English,,0,0,0,,So we're going to take the frac
Dialogue: 0,0:31:23.20,0:31:28.70,English,,0,0,0,, The bits in the frac field times
Dialogue: 0,0:31:30.02,0:31:31.24,English,,0,0,0,,So m is 0
Dialogue: 0,0:31:32.06,0:31:38.42,English,,0,0,0,,So m in this case is 0*2^-6 gives us 0
Dialogue: 0,0:31:38.76,0:31:42.12,English,,0,0,0,,So this is our representation of 0
Dialogue: 0,0:31:42.12,0:31:44.72,English,,0,0,0,,And like I said it's really it's nice that it actually is
Dialogue: 0,0:31:45.16,0:31:50.12,English,,0,0,0,,If we just treated this as an unsigned integer, it would be 0
Dialogue: 0,0:31:50.50,0:31:52.08,English,,0,0,0,,Okay so that's kind of pleasing
Dialogue: 0,0:31:53.20,0:31:54.94,English,,0,0,0,,Now let's look at the very next number right
Dialogue: 0,0:31:54.96,0:32:00.10,English,,0,0,0,,The x exp is still 0 and we've just bumped up frac by 1
Dialogue: 0,0:32:01.40,0:32:06.74,English,,0,0,0,,Ok so again it's a 1-bias which is -6
Dialogue: 0,0:32:08.22,0:32:18.62,English,,0,0,0,,And now this,this frac field represents this is 1/2,1/4,1/8
Dialogue: 0,0:32:19.12,0:32:23.62,English,,0,0,0,,So it represents,so this is a value of amaz it is 1/8
Dialogue: 0,0:32:24.72,0:32:31.08,English,,0,0,0,, So 1/8*2^-6(1/64)=1/512
Dialogue: 0,0:32:31.46,0:32:34.14,English,,0,0,0,,So in this floating point system the smallest nonzero number
Dialogue: 0,0:32:34.14,0:32:38.58,English,,0,0,0,,We can represent is the denormalized representation of 1/512
Dialogue: 0,0:32:39.42,0:32:41.12,English,,0,0,0,, The next smallest number is 0
Dialogue: 0,0:32:44.74,0:32:49.24,English,,0,0,0,,Okay now let's look at, so let's take, let's bump this up by one
Dialogue: 0,0:32:49.24,0:32:54.16,English,,0,0,0,, So now we get a frac field of 010
Dialogue: 0,0:32:54.16,0:32:57.88,English,,0,0,0,,So this represents 1/4
Dialogue: 0,0:32:59.46,0:33:05.12,English,,0,0,0,,So m is 1/4 that significant is 1/4*2^-6
Dialogue: 0,0:33:05.26,0:33:10.06,English,,0,0,0,,So 2/8*1/64 is 2/512
Dialogue: 0,0:33:11.08,0:33:19.74,English,,0,0,0,,Okay so the the numbers were just it by incrementing this  by incrementing are significant 
Dialogue: 0,0:33:20.12,0:33:23.78,English,,0,0,0,,We're increasing the numbers by 1/512
Dialogue: 0,0:33:26.32,0:33:33.34,English,,0,0,0,,Now the largest denorm in this number system is the case where the frac field is all ones
Dialogue: 0,0:33:34.48,0:33:44.68,English,,0,0,0,,And so this encodes 1/2+1/4+1/8 which is 7/8
Dialogue: 0,0:33:44.68,0:33:52.90,English,,0,0,0,,And then our value is 7/8*2^-6(1/64) =7/512
Dialogue: 0,0:33:54.94,0:34:01.10,English,,0,0,0,,So this 7/512 is the largest denormalized number we can represent in this system
Dialogue: 0,0:34:02.50,0:34:09.70,English,,0,0,0,,And now if we bump our number up by one the the frac field resets to zero
Dialogue: 0,0:34:09.72,0:34:13.48,English,,0,0,0,,And now the exp field goes from 0 to 1
Dialogue: 0,0:34:17.02,0:34:19.86,English,,0,0,0,,Now because the exp field is nonzero
Dialogue: 0,0:34:19.86,0:34:23.38,English,,0,0,0,,This is no longer a denormalized number,It's a normalized number
Dialogue: 0,0:34:25.06,0:34:33.44,English,,0,0,0,,Okay so now we're changing the definition of E from 1-bias to exp - bias
Dialogue: 0,0:34:35.34,0:34:38.08,English,,0,0,0,,So what's exp in this case ?
Dialogue: 0,0:34:40.50,0:34:46.50,English,,0,0,0,,1-7,the bias is -6
Dialogue: 0,0:34:46.52,0:34:57.08,English,,0,0,0,, So lower in hold,it's the same exponent as the previous denormalized number
Dialogue: 0,0:34:57.50,0:35:00.72,English,,0,0,0,,So this is actually very clever by the IEEE folks
Dialogue: 0,0:35:01.10,0:35:06.54,English,,0,0,0,,Because you get the spirit,you get this nice smooth transition from denorm to normalize
Dialogue: 0,0:35:07.44,0:35:13.30,English,,0,0,0,,So you can see that our exponent E is -6 still
Dialogue: 0,0:35:15.08,0:35:29.54,English,,0,0,0,,And now,because we're taking 1-bias(7) And are significant now remember this is a normalized number
Dialogue: 0,0:35:29.54,0:35:32.92,English,,0,0,0,,Because the exp field is nonzero
Dialogue: 0,0:35:35.74,0:35:41.26,English,,0,0,0,,They are a frac field of all zeros represents a significant of 1.000
Dialogue: 0,0:35:43.00,0:35:47.96,English,,0,0,0,,Okay so this normalized number this the smallest normalized number
Dialogue: 0,0:35:49.06,0:35:59.70,English,,0,0,0,,Represents is 1.000 which is 8/8*2^-6(1/64) which gives us 8/512
Dialogue: 0,0:35:59.80,0:36:05.72,English,,0,0,0,,So we've made this nice smooth transition from 7/512 to 8/512
Dialogue: 0,0:36:07.28,0:36:08.82,English,,0,0,0,,And how do one more
Dialogue: 0,0:36:08.82,0:36:09.90,English,,0,0,0,, I don't want to
Dialogue: 0,0:36:10.60,0:36:15.46,English,,0,0,0,,So if we bump keeping the exp field 1
Dialogue: 0,0:36:15.46,0:36:17.94,English,,0,0,0,,If we bump our frac field from 0 to 1
Dialogue: 0,0:36:18.86,0:36:31.12,English,,0,0,0,,Now this represents the the significant of 1.0, 1.001 
Dialogue: 0,0:36:32.92,0:36:36.66,English,,0,0,0,,Which is 8/8+1/8
Dialogue: 0,0:36:38.48,0:36:48.10,English,,0,0,0,,So that's 9/8 times...and then the value is 9/8*2^-6(1/64) which is equal to 9/512
Dialogue: 0,0:36:48.54,0:36:52.07,English,,0,0,0,,Okay
Dialogue: 0,0:36:52.44,0:36:53.68,English,,0,0,0,,Any questions about that?
Dialogue: 0,0:36:59.42,0:37:00.44,English,,0,0,0,,Question back here
Dialogue: 0,0:37:00.74,0:37:04.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:37:04.68,0:37:09.68,English,,0,0,0,,Okay the question is why do you choose the bias that to be 2^(k-1) - 1
Dialogue: 0,0:37:10.04,0:37:13.16,English,,0,0,0,,Well go back to my finger diagram here
Dialogue: 0,0:37:13.78,0:37:18.46,English,,0,0,0,, so this is the range of exp fields that you want to
Dialogue: 0,0:37:18.82,0:37:22.14,English,,0,0,0,,This is the range of E that you want to represent with 0 in the middle
Dialogue: 0,0:37:23.54,0:37:26.96,English,,0,0,0,,Okay and so you want to bias
Dialogue: 0,0:37:26.96,0:37:32.62,English,,0,0,0,,So that this is halfway 0 the smallest exponent is halfway to 0
Dialogue: 0,0:37:34.36,0:37:36.20,English,,0,0,0,,So you want the bias to shift it up
Dialogue: 0,0:37:36.20,0:37:42.86,English,,0,0,0,,So it's the smallest value of exp corresponds to the smallest exponent
Dialogue: 0,0:37:43.56,0:37:51.70,English,,0,0,0,,Right so 2^(k-1)-1 is just giving you a value that's halfway between the smallest exponent and the largest exponent
Dialogue: 0,0:37:53.40,0:37:53.76,English,,0,0,0,,Okay
Dialogue: 0,0:37:56.58,0:37:57.84,English,,0,0,0,,That's good.Any other questions?
Dialogue: 0,0:38:05.20,0:38:10.74,English,,0,0,0,,Okay if we take a little smaller six bit format same thing as we did before 
Dialogue: 0,0:38:10.74,0:38:14.20,English,,0,0,0,,Just different numbers of bits in exp and frac
Dialogue: 0,0:38:14.84,0:38:18.66,English,,0,0,0,,And then we plot these on the number line
Dialogue: 0,0:38:18.66,0:38:24.74,English,,0,0,0,,You can see that the values are very dense around zero
Dialogue: 0,0:38:24.74,0:38:27.50,English,,0,0,0,,So they're very spaced very closely together
Dialogue: 0,0:38:28.12,0:38:33.32,English,,0,0,0,,And then every time you increase the exponent by one
Dialogue: 0,0:38:33.94,0:38:40.38,English,,0,0,0,,The numbers are spaced twice as far apart as the previous
Dialogue: 0,0:38:40.38,0:38:45.18,English,,0,0,0,,The numbers that were represented by the previous exponent
Dialogue: 0,0:38:46.26,0:38:48.66,English,,0,0,0,, So you can see like in this little example
Dialogue: 0,0:38:50.72,0:38:55.92,English,,0,0,0,,You see these...these values here are all equally spaced
Dialogue: 0,0:38:56.82,0:39:00.38,English,,0,0,0,,These four values are equally spaced and they're right next to each other
Dialogue: 0,0:39:01.06,0:39:07.48,English,,0,0,0,,And then you see this jump in the spacing that represents an increase in the exp field by one
Dialogue: 0,0:39:09.52,0:39:14.02,English,,0,0,0,,And then that spacing doubles as we go out
Dialogue: 0,0:39:16.54,0:39:21.25,English,,0,0,0,,And you can see it even better here this if we zoom in
Dialogue: 0,0:39:21.68,0:39:27.36,English,,0,0,0,,These blue values or denorms
Dialogue: 0,0:39:28.36,0:39:34.20,English,,0,0,0,,And then we have the the next set of normalized values where the frac field is 1
Dialogue: 0,0:39:34.20,0:39:39.32,English,,0,0,0,,They're spaced the same right we saw this when we kept increasing by 1/512
Dialogue: 0,0:39:41.42,0:39:45.36,English,,0,0,0,,And then we increase the the exponent by one and the spacing doubles
Dialogue: 0,0:39:51.46,0:39:55.46,English,,0,0,0,,Okay so this like i mentioned this encoding has some pretty nice properties
Dialogue: 0,0:39:55.82,0:40:02.66,English,,0,0,0,,The floating point zero  is encoded as integer zero which is nice
Dialogue: 0,0:40:04.50,0:40:14.48,English,,0,0,0,,And with the exception of not a number,with the exception of not a number
Dialogue: 0,0:40:14.78,0:40:16.98,English,,0,0,0,,You can compare any floating-point numbers
Dialogue: 0,0:40:17.28,0:40:22.60,English,,0,0,0,,Including infinity by just treating it as doing an unsigned comparison
Dialogue: 0,0:40:23.16,0:40:24.78,English,,0,0,0,,So that's really nice too
Dialogue: 0,0:40:30.90,0:40:35.42,English,,0,0,0,,Um now if you, when you add and multiply floating point numbers
Dialogue: 0,0:40:35.42,0:40:38.22,English,,0,0,0,,Right we're dealing with a limited set of bits here
Dialogue: 0,0:40:39.14,0:40:44.12,English,,0,0,0,,So if we take two numbers encoded as floating-point
Dialogue: 0,0:40:44.12,0:40:48.26,English,,0,0,0,,And we add them together there's no guarantee that we'll be able to fit all those bits
Dialogue: 0,0:40:48.80,0:40:52.64,English,,0,0,0,,In the bits we have available to us
Dialogue: 0,0:40:52.64,0:40:55.74,English,,0,0,0,,There's no guarantee that we'll be able to fit the the bits and the result
Dialogue: 0,0:40:56.64,0:40:59.84,English,,0,0,0,,So what we do in this case is
Dialogue: 0,0:41:00.14,0:41:06.58,English,,0,0,0,,You can imagine the model you want to have a floating-point operations addition to multiplication
Dialogue: 0,0:41:06.58,0:41:12.42,English,,0,0,0,,It's that you add or multiply you do the addition or multiplication
Dialogue: 0,0:41:12.78,0:41:14.34,English,,0,0,0,,And you compute the exact result
Dialogue: 0,0:41:14.34,0:41:18.12,English,,0,0,0,, You just assume that you have an infinite amount of number of bits
Dialogue: 0,0:41:19.02,0:41:25.24,English,,0,0,0,,And then you round use the technique called rounding to get it to fit into the of the available bits
Dialogue: 0,0:41:25.64,0:41:27.48,English,,0,0,0,,So the the effect
Dialogue: 0,0:41:28.20,0:41:35.22,English,,0,0,0,,Is like you doing say x + y is getting the precise value of x + y at an infinite number of bits
Dialogue: 0,0:41:35.22,0:41:38.60,English,,0,0,0,,And then rounding into the available bits
Dialogue: 0,0:41:39.74,0:41:42.54,English,,0,0,0,,So let's look at this idea of rounding
Dialogue: 0,0:41:42.54,0:41:47.46,English,,0,0,0,,This can be confusing the first you see it requires 
Dialogue: 0,0:41:48.02,0:41:52.62,English,,0,0,0,,You need to think about it carefully to get it right
Dialogue: 0,0:41:52.76,0:41:55.54,English,,0,0,0,, Now in IEEE there's four different kinds of rounding
Dialogue: 0,0:41:55.54,0:42:05.88,English,,0,0,0,,There's round towards zero round down route or round to minus infinity Round up to which is rounding it to positive infinity
Dialogue: 0,0:42:06.34,0:42:07.58,English,,0,0,0,, And then the default case
Dialogue: 0,0:42:07.58,0:42:09.94,English,,0,0,0,,Which is the only one route we're really going to consider
Dialogue: 0,0:42:10.24,0:42:12.92,English,,0,0,0,,Which is round to the nearest even
Dialogue: 0,0:42:14.30,0:42:17.12,English,,0,0,0,,And this is what IEEE does by default
Dialogue: 0,0:42:17.98,0:42:18.84,English,,0,0,0,,You can,you can...
Dialogue: 0,0:42:19.22,0:42:22.14,English,,0,0,0,,If you go into assembly language you can change the rounding
Dialogue: 0,0:42:22.24,0:42:25.26,English,,0,0,0,,But we're not going to consider it any more.Yes question
Dialogue: 0,0:42:25.26,0:42:30.18,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:30.18,0:42:33.54,English,,0,0,0,,I'm sorry
Dialogue: 0,0:42:33.54,0:42:35.02,English,,0,0,0,,There is right because there's one
Dialogue: 0,0:42:35.18,0:42:40.62,English,,0,0,0,,So the question is there a distinct negative infinity and a distinct positive infinity
Dialogue: 0,0:42:40.92,0:42:47.42,English,,0,0,0,,And there is they have the exact same bit representation except the most significant bit for negative infinity is one
Dialogue: 0,0:42:48.30,0:42:50.30,English,,0,0,0,,And for positive infinity it's zero
Dialogue: 0,0:42:52.96,0:42:54.00,English,,0,0,0,, Yes question
Dialogue: 0,0:42:54.00,0:42:58.14,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:58.16,0:42:59.08,English,,0,0,0,,Why is nearest even?
Dialogue: 0,0:42:59.08,0:43:00.20,English,,0,0,0,,[student speaking]
Dialogue: 0,0:43:00.20,0:43:02.04,English,,0,0,0,,Oh I'll show you,let me go over the others
Dialogue: 0,0:43:02.22,0:43:04.12,English,,0,0,0,,The question was about nearest even.yes
Dialogue: 0,0:43:04.12,0:43:08.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:43:08.42,0:43:10.48,English,,0,0,0,,Well that was the exception right
Dialogue: 0,0:43:11.22,0:43:15.76,English,,0,0,0,,That's right so aside from infinity you can't do that comparison
Dialogue: 0,0:43:17.72,0:43:21.52,English,,0,0,0,, Positive infinity works right but not negative so you're right
Dialogue: 0,0:43:21.52,0:43:22.88,English,,0,0,0,,But good point
Dialogue: 0,0:43:24.02,0:43:29.08,English,,0,0,0,,Let's look at these rounding modes and i'll explain why the neuro steven works
Dialogue: 0,0:43:29.46,0:43:32.12,English,,0,0,0,,But let's look at so rounding towards zero what we're going to do
Dialogue: 0,0:43:32.68,0:43:35.98,English,,0,0,0,,We'll use dollars,so we want to round to the nearest dollar
Dialogue: 0,0:43:37.64,0:43:43.38,English,,0,0,0,,Towards zero just anything less than you just round towards zero
Dialogue: 0,0:43:43.38,0:43:45.14,English,,0,0,0,,So dollar forty would go to one
Dialogue: 0,0:43:45.42,0:43:47.22,English,,0,0,0,, A dollar sixty would go down to one
Dialogue: 0,0:43:47.52,0:43:48.86,English,,0,0,0,,A dollar fifty to one
Dialogue: 0,0:43:49.30,0:43:50.70,English,,0,0,0,,Two fifty would go to two
Dialogue: 0,0:43:51.16,0:43:53.66,English,,0,0,0,,-150 you round towards zero
Dialogue: 0,0:43:53.68,0:43:56.27,English,,0,0,0,,So that would be negative one
Dialogue: 0,0:43:56.70,0:44:06.40,English,,0,0,0,,Round down or towards negative infinity It's similar the only difference is that for negative one point 
Dialogue: 0,0:44:07.04,0:44:12.47,English,,0,0,0,,Negative a dollar Fifty you drown towards negative infinity which would be -2
Dialogue: 0,0:44:12.84,0:44:18.56,English,,0,0,0,,Rounding up is symmetric to round down
Dialogue: 0,0:44:18.78,0:44:24.22,English,,0,0,0,, The interesting case is round to nearest even
Dialogue: 0,0:44:25.24,0:44:29.58,English,,0,0,0,,Interesting because it's what IEEE floating point actually uses
Dialogue: 0,0:44:30.22,0:44:37.66,English,,0,0,0,,So the idea here if you have a value that's less than half  then you round down
Dialogue: 0,0:44:37.94,0:44:43.61,English,,0,0,0,,If you have a value that's more than halfway between two dollar amounts you round up
Dialogue: 0,0:44:44.38,0:44:50.60,English,,0,0,0,,The route that nearest even part comes when you have something that's exactly halfway
Dialogue: 0,0:44:51.50,0:44:54.28,English,,0,0,0,, Then what you do is you round towards the nearest even number
Dialogue: 0,0:44:56.44,0:44:59.76,English,,0,0,0,, Okay so in this example a dollar forty
Dialogue: 0,0:45:00.38,0:45:05.14,English,,0,0,0,,Because it's less than half rounds down to one dollar
Dialogue: 0,0:45:05.44,0:45:08.74,English,,0,0,0,,A dollar sixty is greater than half so we round up to two dollars
Dialogue: 0,0:45:10.16,0:45:16.24,English,,0,0,0,,A dollar fifty right in the middle we round up to the nearest even
Dialogue: 0,0:45:16.50,0:45:18.48,English,,0,0,0,,Dollar amount which is two dollars
Dialogue: 0,0:45:20.04,0:45:25.26,English,,0,0,0,, Two dollars and fifty cents we round down to the nearest even
Dialogue: 0,0:45:25.26,0:45:28.84,English,,0,0,0,, Right if we round it up it would be three which is it odd number
Dialogue: 0,0:45:29.66,0:45:36.68,English,,0,0,0,,And minus a dollar fifty we round two we round down to minus two dollars
Dialogue: 0,0:45:37.94,0:45:44.50,English,,0,0,0,,So the reason we do this the reason they chose this is that statistically
Dialogue: 0,0:45:45.62,0:45:46.86,English,,0,0,0,,If you would imagine
Dialogue: 0,0:45:47.42,0:45:50.60,English,,0,0,0,,If you have a uniform distribution of sort of numbers
Dialogue: 0,0:45:50.60,0:45:53.78,English,,0,0,0,,They're going to round up or down about 50% of the times
Dialogue: 0,0:45:53.78,0:45:57.78,English,,0,0,0,,So there won't be a statistical bias rounding up or down one way or the other
Dialogue: 0,0:45:57.96,0:46:00.72,English,,0,0,0,,So that's the reason they did that
Dialogue: 0,0:46:03.62,0:46:10.72,English,,0,0,0,,Now you can apply this you can do this rounding to any value
Dialogue: 0,0:46:11.38,0:46:15.00,English,,0,0,0,,So in the last example we did it to the nearest dollar
Dialogue: 0,0:46:15.00,0:46:19.80,English,,0,0,0,,But let's suppose we wanted to round to the nearest hundredth using round two even
Dialogue: 0,0:46:20.60,0:46:22.26,English,,0,0,0,,The default round two even mode
Dialogue: 0,0:46:23.02,0:46:31.00,English,,0,0,0,,So we want to round to the the nearest hundredth is this second position this
Dialogue: 0,0:46:31.66,0:46:33.68,English,,0,0,0,,First do we have tenths then hundreds
Dialogue: 0,0:46:35.24,0:46:39.44,English,,0,0,0,,So if we have a value 7.8949999
Dialogue: 0,0:46:40.46,0:46:42.55,English,,0,0,0,,That's less than halfway
Dialogue: 0,0:46:43.44,0:46:51.60,English,,0,0,0,,Halfway would be any number that had a five followed by all zeros
Dialogue: 0,0:46:52.96,0:46:55.38,English,,0,0,0,, So 49999 is less than that
Dialogue: 0,0:46:56.40,0:46:59.78,English,,0,0,0,,So we would just round down to 7.89
Dialogue: 0,0:47:01.46,0:47:03.36,English,,0,0,0,,Even though 9 is odd
Dialogue: 0,0:47:03.84,0:47:07.68,English,,0,0,0,,The only time we're going to apply round 2 even is when we're exactly halfway
Dialogue: 0,0:47:08.94,0:47:14.96,English,,0,0,0,, Okay our next example 7.895001that's greater than halfway
Dialogue: 0,0:47:16.76,0:47:24.64,English,,0,0,0,,Right if this was a zero it would be exactly halfway so we round up to 7.9
Dialogue: 0,0:47:25.30,0:47:32.74,English,,0,0,0,,Here's the interesting case where we have 7.895 followed by all zeroes that's exactly halfway
Dialogue: 0,0:47:33.02,0:47:36.08,English,,0,0,0,, So now we apply the round to nearest even rule
Dialogue: 0,0:47:40.06,0:47:44.74,English,,0,0,0,,Nine is an odd number so that doesn't work so we round up
Dialogue: 0,0:47:45.34,0:47:50.36,English,,0,0,0,,And we do that basically by adding a five here
Dialogue: 0,0:47:51.20,0:47:54.20,English,,0,0,0,,So five and five is ten and then that carries over
Dialogue: 0,0:47:56.36,0:48:03.54,English,,0,0,0,,To the next position and nine and one is zero, nine and one is 10,so that carries over
Dialogue: 0,0:48:04.24,0:48:10.48,English,,0,0,0,,And so 8+1=9,so the result is set of rounding up is 7.90
Dialogue: 0,0:48:12.42,0:48:14.64,English,,0,0,0,,Okay is that clear do you see
Dialogue: 0,0:48:16.28,0:48:18.44,English,,0,0,0,,There's a very mechanical way when you round up
Dialogue: 0,0:48:18.44,0:48:20.56,English,,0,0,0,, It's always it's a very mechanical like that
Dialogue: 0,0:48:20.56,0:48:24.68,English,,0,0,0,,You always just add the half-way number in this case five
Dialogue: 0,0:48:25.66,0:48:29.34,English,,0,0,0,,And then just propagate it out just do the addition and that will give you the nearest
Dialogue: 0,0:48:30.44,0:48:35.28,English,,0,0,0,,The nearest that will round you up to the nearest hundredth in this case
Dialogue: 0,0:48:36.02,0:48:40.73,English,,0,0,0,, Okay now the last case 7.885 followed by all zeros
Dialogue: 0,0:48:40.73,0:48:50.42,English,,0,0,0,,That's another number that's halfway between two numbers rounded to the nearest hundredth
Dialogue: 0,0:48:51.58,0:48:56.08,English,,0,0,0,,So in this case eight is even
Dialogue: 0,0:48:56.10,0:48:59.10,English,,0,0,0,,So we just we round down and to round down we just truncate
Dialogue: 0,0:48:59.18,0:49:04.98,English,,0,0,0,, Just throw these bits these these digits away and we get 7.88
Dialogue: 0,0:49:05.58,0:49:07.28,English,,0,0,0,,So there any questions about this
Dialogue: 0,0:49:10.94,0:49:12.18,English,,0,0,0,,Question back here yes
Dialogue: 0,0:49:12.20,0:49:25.04,English,,0,0,0,,[student speaking]
Dialogue: 0,0:49:25.04,0:49:28.02,English,,0,0,0,,Yes that's... so the question was
Dialogue: 0,0:49:28.02,0:49:30.88,English,,0,0,0,,Numbers that have the same exp field
Dialogue: 0,0:49:31.60,0:49:37.52,English,,0,0,0,,Will those numbers be equally spaced on the number line and the answer is yes
Dialogue: 0,0:49:40.42,0:49:41.42,English,,0,0,0,,Yes question
Dialogue: 0,0:49:41.64,0:49:54.32,English,,0,0,0,,[student question]
Dialogue: 0,0:49:54.32,0:49:55.04,English,,0,0,0,,It would round up
Dialogue: 0,0:49:56.18,0:50:01.58,English,,0,0,0,,Yeah the only,the half way values are always in this case because it's base 10
Dialogue: 0,0:50:02.50,0:50:04.54,English,,0,0,0,,The the half way number in base 10 is 5
Dialogue: 0,0:50:05.18,0:50:08.72,English,,0,0,0,,And then it's always the half way number in this case 5 followed by all zeroes
Dialogue: 0,0:50:12.08,0:50:18.86,English,,0,0,0,,You'll always have that the half way, if a value is halfway between  like 200 it'll always have that form
Dialogue: 0,0:50:22.84,0:50:27.52,English,,0,0,0,,Alright now we can do the same thing with binary fractional numbers as well
Dialogue: 0,0:50:28.56,0:50:32.62,English,,0,0,0,,Now a binary number is even
Dialogue: 0,0:50:32.62,0:50:36.98,English,,0,0,0,,If the least significant digit is 0
Dialogue: 0,0:50:37.54,0:50:41.44,English,,0,0,0,,Ok we only have 2 digits right so odd is 1 and 0 is even
Dialogue: 0,0:50:42.14,0:50:51.07,English,,0,0,0,,And the halfway,so the halfway value is going to be a 1 followed by all zeros
Dialogue: 0,0:50:51.90,0:50:54.42,English,,0,0,0,,Ok that represents exactly halfway
Dialogue: 0,0:50:55.46,0:50:59.60,English,,0,0,0,,So it's analogous to the base 10 example
Dialogue: 0,0:51:00.00,0:51:04.38,English,,0,0,0,, Except where the halfway value is going to be one followed by all zeros
Dialogue: 0,0:51:05.26,0:51:07.74,English,,0,0,0,, So let's look at some examples
Dialogue: 0,0:51:08.82,0:51:16.24,English,,0,0,0,,So suppose we have, we want to represent 2 3/32
Dialogue: 0,0:51:17.20,0:51:20.05,English,,0,0,0,,And suppose we only have four bits to do that in
Dialogue: 0,0:51:20.84,0:51:27.70,English,,0,0,0,,Okay well to represent that exact we need seven bits
Dialogue: 0,0:51:30.30,0:51:31.66,English,,0,0,0,,And so we have to round
Dialogue: 0,0:51:34.40,0:51:35.68,English,,0,0,0,, Okay so let's look at
Dialogue: 0,0:51:37.10,0:51:41.68,English,,0,0,0,,So we're going to round to this two bits right of the binary point
Dialogue: 0,0:51:43.10,0:51:45.44,English,,0,0,0,,And so let's look at all the bits that follow that
Dialogue: 0,0:51:46.72,0:51:48.90,English,,0,0,0,,So since it starts with zero
Dialogue: 0,0:51:49.64,0:51:52.76,English,,0,0,0,,This is going to be less than halfway
Dialogue: 0,0:51:53.28,0:51:55.86,English,,0,0,0,,So since it's less than halfway we just truncate
Dialogue: 0,0:51:57.26,0:52:02.44,English,,0,0,0,, Just chop those out and the result is 10.00
Dialogue: 0,0:52:03.32,0:52:08.10,English,,0,0,0,,Now our next example is 10.00110
Dialogue: 0,0:52:08.10,0:52:16.30,English,,0,0,0,,So if we look at these the bits to the right of the  to the right of the the bit we're rounding to
Dialogue: 0,0:52:17.38,0:52:20.96,English,,0,0,0,,Since it starts with one and it's not followed by all zeros
Dialogue: 0,0:52:21.40,0:52:22.60,English,,0,0,0,,That's greater than half
Dialogue: 0,0:52:25.40,0:52:30.50,English,,0,0,0,,So in this case we have to round up and so the way we do that
Dialogue: 0,0:52:31.48,0:52:37.88,English,,0,0,0,,That is, we take one and we add it to this leftmost one right here and
Dialogue: 0,0:52:38.72,0:52:43.34,English,,0,0,0,,Add just do the addition and the result is 10.01
Dialogue: 0,0:52:45.24,0:52:47.12,English,,0,0,0,,Now let's look at 2 7/8
Dialogue: 0,0:52:48.80,0:52:54.43,English,,0,0,0,,This is represented as 10.11100
Dialogue: 0,0:52:55.30,0:52:59.00,English,,0,0,0,,Now here's that halfway marker that we were looking for
Dialogue: 0,0:53:00.88,0:53:05.38,English,,0,0,0,,It's a 1 followed by all 0,so this is exactly halfway
Dialogue: 0,0:53:05.98,0:53:08.12,English,,0,0,0,,So now we have to round to the nearest even
Dialogue: 0,0:53:09.44,0:53:15.70,English,,0,0,0,,Number now that if we can't just truncate,because then it would be an odd number
Dialogue: 0,0:53:15.70,0:53:19.24,English,,0,0,0,, Right we would end 10.11 is an odd number
Dialogue: 0,0:53:19.82,0:53:21.40,English,,0,0,0,,So we have to round up
Dialogue: 0,0:53:22.46,0:53:27.52,English,,0,0,0,,And we do that by adding,we do that by adding a 1
Dialogue: 0,0:53:28.34,0:53:34.72,English,,0,0,0,,Right here it is to this less leftmost red bit,we add one to that And then just do the addition
Dialogue: 0,0:53:35.02,0:53:40.86,English,,0,0,0,,And we end up with 11.00 which is 3
Dialogue: 0,0:53:40.86,0:53:46.38,English,,0,0,0,,So the nearest value to 2 7/8
Dialogue: 0,0:53:47.34,0:53:49.84,English,,0,0,0,,The nearest rounded value is that is 3
Dialogue: 0,0:53:51.40,0:53:53.52,English,,0,0,0,,Okay last example 2 5/8
Dialogue: 0,0:53:54.38,0:53:59.38,English,,0,0,0,,We have the same halfway marker again 100
Dialogue: 0,0:53:59.94,0:54:03.12,English,,0,0,0,,But in this case the hundredths bit
Dialogue: 0,0:54:03.58,0:54:07.22,English,,0,0,0,,Are the 1/4 bit is 0
Dialogue: 0,0:54:07.22,0:54:10.42,English,,0,0,0,,So that's even,so we can just truncate we just throw those bits away
Dialogue: 0,0:54:10.76,0:54:13.40,English,,0,0,0,,And the result is simply 10.10
Dialogue: 0,0:54:15.82,0:54:18.66,English,,0,0,0,,It makes sense
Dialogue: 0,0:54:18.68,0:54:24.78,English,,0,0,0,,So it's very mechanical mainly you just need to be able to recognize that halfway marker
Dialogue: 0,0:54:25.58,0:54:28.20,English,,0,0,0,,And then figure out if you need to round up or down
Dialogue: 0,0:54:28.20,0:54:29.76,English,,0,0,0,,If you're going to round down just truncate
Dialogue: 0,0:54:30.02,0:54:34.68,English,,0,0,0,,If you're going to round up add a 1 and just propagate it to get your result
Dialogue: 0,0:54:37.20,0:54:42.14,English,,0,0,0,,Okay now we won't spend much time
Dialogue: 0,0:54:42.14,0:54:45.18,English,,0,0,0,, I just want to mention a few things about multiplication in addition
Dialogue: 0,0:54:48.24,0:54:50.72,English,,0,0,0,,So if we multiply two numbers
Dialogue: 0,0:54:50.94,0:54:54.42,English,,0,0,0,,So we have different mantises significance and exponents
Dialogue: 0,0:54:55.16,0:55:01.58,English,,0,0,0,,And suppose that the result is m*2^e
Dialogue: 0,0:55:02.20,0:55:08.34,English,,0,0,0,,The sign bit will be the xor of the two sign bits of the two operands
Dialogue: 0,0:55:10.02,0:55:15.62,English,,0,0,0,, The significant m will be the multiplying m1*m2
Dialogue: 0,0:55:15.62,0:55:17.36,English,,0,0,0,,And the exponents are added right
Dialogue: 0,0:55:17.36,0:55:20.84,English,,0,0,0,,Because they just missed by the rules of exponents
Dialogue: 0,0:55:22.42,0:55:27.78,English,,0,0,0,,So if m >= 2 and this is a normalized number
Dialogue: 0,0:55:27.78,0:55:36.44,English,,0,0,0,,We have to put it in the range between 1 and 2 by shifting to the right and incrementing the exponent
Dialogue: 0,0:55:37.96,0:55:41.72,English,,0,0,0,,If e is out of range then we overflow 2 to infinity
Dialogue: 0,0:55:43.70,0:55:48.02,English,,0,0,0,,And then if m has too many bits we have to use round 2 even
Dialogue: 0,0:55:48.34,0:55:51.52,English,,0,0,0,,To fit it into the available fragments
Dialogue: 0,0:55:54.48,0:55:59.80,English,,0,0,0,,Ok addition,so suppose we're trying to add two floating point numbers
Dialogue: 0,0:56:01.02,0:56:05.34,English,,0,0,0,,Conceptually what you do is think of those numbers as fractional binary numbers
Dialogue: 0,0:56:05.34,0:56:19.68,English,,0,0,0,,You want to line up the binary points and then do the addition and then normalize the number
Dialogue: 0,0:56:20.20,0:56:23.70,English,,0,0,0,,So that the normalized the significant so it's between 1 & 2
Dialogue: 0,0:56:28.34,0:56:32.24,English,,0,0,0,,And either do that by shifting right or left
Dialogue: 0,0:56:32.68,0:56:34.80,English,,0,0,0,,If e is too big then you overflow
Dialogue: 0,0:56:35.16,0:56:40.44,English,,0,0,0,,And then you round the the bits and m to fit into the available frac field
Dialogue: 0,0:56:42.66,0:56:44.54,English,,0,0,0,,Now remember when we the first day of class
Dialogue: 0,0:56:44.62,0:56:47.74,English,,0,0,0,,We talked about what you call these great realities
Dialogue: 0,0:56:47.74,0:56:52.50,English,,0,0,0,,That ints aren't really integers and floats aren't really reals
Dialogue: 0,0:56:53.30,0:56:59.92,English,,0,0,0,,Just as we saw when we looked at two's complement representation of integers
Dialogue: 0,0:57:00.44,0:57:04.76,English,,0,0,0,, It's not exactly,they're not exactly like real integers
Dialogue: 0,0:57:04.76,0:57:07.42,English,,0,0,0,,And operations on them aren't exactly like real integers
Dialogue: 0,0:57:07.68,0:57:10.26,English,,0,0,0,,But they follow very predictable mathematical properties
Dialogue: 0,0:57:11.18,0:57:14.78,English,,0,0,0,,Okay that are similar to integers but not quite
Dialogue: 0,0:57:15.22,0:57:17.36,English,,0,0,0,,So the same thing holds for floating-point numbers
Dialogue: 0,0:57:18.78,0:57:22.06,English,,0,0,0,,They follow very predictable
Dialogue: 0,0:57:22.64,0:57:25.06,English,,0,0,0,,They have very predictable mathematical properties
Dialogue: 0,0:57:25.06,0:57:28.66,English,,0,0,0,,But they're somewhat different from the reals
Dialogue: 0,0:57:29.02,0:57:34.28,English,,0,0,0,,And the big thing is that
Dialogue: 0,0:57:35.04,0:57:38.96,English,,0,0,0,,The big thing with addition is that it doesn't associate
Dialogue: 0,0:57:39.76,0:57:43.08,English,,0,0,0,,Okay it's commutative but it's not associative
Dialogue: 0,0:57:43.88,0:57:51.84,English,,0,0,0,,And this usually happens when you're dealing with numbers  that have very large dynamic ranges
Dialogue: 0,0:57:51.84,0:57:58.42,English,,0,0,0,,So if you're trying to add and subtract really big numbers with really little numbers
Dialogue: 0,0:57:58.80,0:58:02.04,English,,0,0,0,,You run into this this problem of non associativity
Dialogue: 0,0:58:03.06,0:58:09.44,English,,0,0,0,,So the example was if we take 3.14 +  2^10
Dialogue: 0,0:58:10.54,0:58:14.88,English,,0,0,0,,2^10 is so much larger than 3.14
Dialogue: 0,0:58:15.42,0:58:20.76,English,,0,0,0,, That when we ,the bits that would be 2^10 + 3.14
Dialogue: 0,0:58:20.76,0:58:23.22,English,,0,0,0,,The the bits that represent the 3.14
Dialogue: 0,0:58:23.78,0:58:25.78,English,,0,0,0,,You know there's bits way out here that represent
Dialogue: 0,0:58:26.38,0:58:28.46,English,,0,0,0,,There's one bit out here that represents 2^10
Dialogue: 0,0:58:28.46,0:58:32.20,English,,0,0,0,,Then there's a few bits here they represent 3.14
Dialogue: 0,0:58:32.92,0:58:36.30,English,,0,0,0,,And there's just not enough we don't have enough bits to represent all those
Dialogue: 0,0:58:36.30,0:58:39.72,English,,0,0,0,,So we have the 3.14 goes away
Dialogue: 0,0:58:39.72,0:58:46.22,English,,0,0,0,,So adding a big number to a little number essentially gives the big number
Dialogue: 0,0:58:46.22,0:58:48.96,English,,0,0,0,,And then if you subtract that big number you get zero
Dialogue: 0,0:58:49.62,0:58:53.74,English,,0,0,0,,Now if we change the the associate 
Dialogue: 0,0:58:54.38,0:58:58.40,English,,0,0,0,,If we take this big number and subtract it from itself we get zero
Dialogue: 0,0:58:58.46,0:59:03.34,English,,0,0,0,,And then,so the result will be instead of zero as before we get 3.14
Dialogue: 0,0:59:06.52,0:59:11.46,English,,0,0,0,,So other than that you you have all of the things that you would normally expect
Dialogue: 0,0:59:11.82,0:59:16.90,English,,0,0,0,,Closed under addition it's commutative there's a additive identity of zero
Dialogue: 0,0:59:18.26,0:59:22.18,English,,0,0,0,,Except for infinities and nan's there's an additive inverse
Dialogue: 0,0:59:22.56,0:59:24.50,English,,0,0,0,,You can take for any number there's
Dialogue: 0,0:59:24.58,0:59:30.80,English,,0,0,0,, There's an inverse that will give you zero when you add it together and you get monotonicity
Dialogue: 0,0:59:31.44,0:59:36.64,English,,0,0,0,,Monotonicity between values except of course for infinities and ends
Dialogue: 0,0:59:37.44,0:59:41.42,English,,0,0,0,,Now multiplication has... it's similar
Dialogue: 0,0:59:41.66,0:59:46.72,English,,0,0,0,,You get it's closed generally under multiplication it's commutative
Dialogue: 0,0:59:47.50,0:59:51.22,English,,0,0,0,,But it's not associative and it doesn't distribute over addition
Dialogue: 0,0:59:52.08,1:00:06.13,English,,0,0,0,,And it's the same,so here you can see we're taking 1e^20*1e^20*1e^20 and then so that gives infinity
Dialogue: 0,1:00:06.58,1:00:10.16,English,,0,0,0,,But if we reassociate and we take...
Dialogue: 0,1:00:10.16,1:00:15.50,English,,0,0,0,,I'm sorry to to the (1e20*1e20)*1e-20
Dialogue: 0,1:00:16.06,1:00:19.24,English,,0,0,0,,Well this first multiplication is infinity
Dialogue: 0,1:00:19.24,1:00:24.39,English,,0,0,0,,And anything you do with infinity is just infinity so the result is infinity
Dialogue: 0,1:00:24.64,1:00:30.72,English,,0,0,0,,However if we reassociate and 1e^20*(1e^20*1e^-20)
Dialogue: 0,1:00:31.66,1:00:37.48,English,,0,0,0,,That gives us 1,and then 1e^20 and so we get 1e^20
Dialogue: 0,1:00:38.26,1:00:40.84,English,,0,0,0,,So the big takeaway point here is that
Dialogue: 0,1:00:42.66,1:00:46.48,English,,0,0,0,,A floating point is an associative
Dialogue: 0,1:00:48.78,1:00:52.14,English,,0,0,0,,Ok now is that a problem
Dialogue: 0,1:00:54.32,1:00:56.38,English,,0,0,0,,It's something you have to be aware of and
Dialogue: 0,1:00:57.20,1:01:06.38,English,,0,0,0,,But generally I mean I've done a lot of scientific computing in particular modeling earthquake ground motion in southern California
Dialogue: 0,1:01:06.38,1:01:11.30,English,,0,0,0,,So basically we would we would build models of southern California in the computer
Dialogue: 0,1:01:11.60,1:01:12.92,English,,0,0,0,,And then we would shake them
Dialogue: 0,1:01:13.54,1:01:16.70,English,,0,0,0,,And then we would see how the ground moves in like Los Angeles
Dialogue: 0,1:01:18.12,1:01:23.56,English,,0,0,0,,And those that's shaking we used a numerical method called finite elements
Dialogue: 0,1:01:23.98,1:01:27.94,English,,0,0,0,,And it was all it used all floating point single precision floating point numbers
Dialogue: 0,1:01:28.38,1:01:32.90,English,,0,0,0,,And we never ran into a problem this with this associativity right
Dialogue: 0,1:01:32.90,1:01:35.28,English,,0,0,0,,We would do operations in different orders
Dialogue: 0,1:01:35.64,1:01:38.90,English,,0,0,0,,We couldn't always guarantee that we would do the operations in the exact same order
Dialogue: 0,1:01:39.34,1:01:41.54,English,,0,0,0,,But we never ran into a problem with this because
Dialogue: 0,1:01:42.08,1:01:45.70,English,,0,0,0,,Nature and generally in general is kind of smooth right that
Dialogue: 0,1:01:46.56,1:01:50.92,English,,0,0,0,,If you look at the,you know if one part of the ground is shaking like this and
Dialogue: 0,1:01:50.92,1:01:54.72,English,,0,0,0,,You look at the next part it might be shaking a little more or a little less
Dialogue: 0,1:01:54.72,1:01:57.62,English,,0,0,0,,But you're not going to have like huge differences
Dialogue: 0,1:01:58.42,1:02:01.06,English,,0,0,0,,And so we never ran into those kind of problems
Dialogue: 0,1:02:01.06,1:02:06.44,English,,0,0,0,,But in some,so generally if you're simulating natural phenomena
Dialogue: 0,1:02:06.44,1:02:09.28,English,,0,0,0,,You don't often see these kind of huge dynamic ranges
Dialogue: 0,1:02:09.72,1:02:14.02,English,,0,0,0,,But other times you know if it's not non natural financial
Dialogue: 0,1:02:14.02,1:02:16.88,English,,0,0,0,,Maybe financial systems they use floating point
Dialogue: 0,1:02:17.30,1:02:21.94,English,,0,0,0,,Then you might see this larger dynamic the numbers and it might become a problem
Dialogue: 0,1:02:22.38,1:02:26.14,English,,0,0,0,,So as a programmer you just generally have to be aware of this
Dialogue: 0,1:02:26.14,1:02:29.34,English,,0,0,0,, You have to have a good sense for the dynamic range of your numbers
Dialogue: 0,1:02:29.74,1:02:33.76,English,,0,0,0,,And you have to keep in mind that if you reassociate or change the order of things
Dialogue: 0,1:02:34.16,1:02:38.10,English,,0,0,0,,You may not get exactly the same exactly the same answer
Dialogue: 0,1:02:42.44,1:02:47.60,English,,0,0,0,,Okay now see gives us two different kinds of floating points
Dialogue: 0,1:02:47.60,1:02:54.14,English,,0,0,0,,So they the float is the IEEE single precision and double is the IEEE double precision
Dialogue: 0,1:02:54.82,1:03:01.80,English,,0,0,0,, Now you remember when we did casting between ints and unsigned values back and forth
Dialogue: 0,1:03:02.24,1:03:05.88,English,,0,0,0,,The cast never changed the bit representation it just changed the way that
Dialogue: 0,1:03:06.36,1:03:11.52,English,,0,0,0,,In fact it never even changed the the be what the a...
Dialogue: 0,1:03:11.52,1:03:14.24,English,,0,0,0,, How the a or you manipulated those bits
Dialogue: 0,1:03:14.36,1:03:19.32,English,,0,0,0,,It's really just a how were interpreting and how we're viewing those those values
Dialogue: 0,1:03:19.58,1:03:24.14,English,,0,0,0,,However when you do cast between floats and ints and doubles
Dialogue: 0,1:03:24.52,1:03:26.05,English,,0,0,0,,The bit representation changes
Dialogue: 0,1:03:26.80,1:03:31.18,English,,0,0,0,,Right so a cast here has a dramatic effect on the actual bits themselves
Dialogue: 0,1:03:31.78,1:03:37.20,English,,0,0,0,,Now if we go from a double or a float to an int
Dialogue: 0,1:03:38.00,1:03:47.02,English,,0,0,0,,It's going to truncate the fractional part and give us the
Dialogue: 0,1:03:47.48,1:03:52.80,English,,0,0,0,,Give us the the integer part and then round to fit
Dialogue: 0,1:03:55.24,1:03:56.70,English,,0,0,0,,Oh actually no there won't be...
Dialogue: 0,1:03:58.72,1:04:07.58,English,,0,0,0,,Okay so think about this how many there were you said 23 frac bits and float
Dialogue: 0,1:04:08.52,1:04:14.78,English,,0,0,0,,And I forget exactly how many in doubles
Dialogue: 0,1:04:17.18,1:04:23.62,English,,0,0,0,,Doesn't matter it's some number,well no it does matter
Dialogue: 0,1:04:24.84,1:04:28.10,English,,0,0,0,,Let's so for a float if we cast a float to an int
Dialogue: 0,1:04:28.88,1:04:41.08,English,,0,0,0,,We're casting 23 something that we can represent with 23 at most 23 frac bits into a 32 bit
Dialogue: 0,1:04:41.08,1:04:45.06,English,,0,0,0,,It so we won't will never lose so we won't we'll never need to do any rounding
Dialogue: 0,1:04:51.02,1:04:59.00,English,,0,0,0,,But double-precision has 52 bits
Dialogue: 0,1:05:00.08,1:05:07.58,English,,0,0,0,,Okay so there we may not be able to fit the represented integer into the int
Dialogue: 0,1:05:09.58,1:05:11.10,English,,0,0,0,,So they'll have to be some rounding
Dialogue: 0,1:05:40.10,1:06:15.82,English,,0,0,0,,Sorry powerpoint crashed
Dialogue: 0,1:06:15.82,1:06:23.50,English,,0,0,0,,Okay right now if we cast,if we cast from an int to a double
Dialogue: 0,1:06:25.44,1:06:30.18,English,,0,0,0,,There's will have will have enough debt,so we won't lose anything right
Dialogue: 0,1:06:31.82,1:06:37.21,English,,0,0,0,,The 32 bits will fit in the double precision frac field
Dialogue: 0,1:06:37.21,1:06:44.58,English,,0,0,0,,And but int to float has there's more bits than an int that then there are in the frac field of a float
Dialogue: 0,1:06:44.58,1:06:47.14,English,,0,0,0,,So we'll have to do some rounding right so the
Dialogue: 0,1:06:47.50,1:06:50.24,English,,0,0,0,,So casting works the same way as any other operation
Dialogue: 0,1:06:50.36,1:06:55.97,English,,0,0,0,,You can think of it as just taking the assume you have an infinite number of bits
Dialogue: 0,1:06:55.97,1:06:58.94,English,,0,0,0,,Get the exact result and then round it to fit into the available bits
Dialogue: 0,1:07:01.20,1:07:12.36,English,,0,0,0,,All right so let's the final thing I want to do today is Sort of test your understanding do solve some puzzles to test
Dialogue: 0,1:07:12.36,1:07:16.32,English,,0,0,0,,Test our understanding of these properties of floating-point numbers
Dialogue: 0,1:07:17.32,1:07:22.14,English,,0,0,0,, So imagine that we have three values x as an int, f is a float and d is a double
Dialogue: 0,1:07:23.52,1:07:27.30,English,,0,0,0,,And then we're evaluating the c, c expressions
Dialogue: 0,1:07:27.32,1:07:34.24,English,,0,0,0,,So x is, x == (int)(float) x
Dialogue: 0,1:07:34.24,1:07:42.26,English,,0,0,0,,Yeah[student speaking]
Dialogue: 0,1:07:42.28,1:07:45.80,English,,0,0,0,,How you can edit out the,you can edit out that other stuff
Dialogue: 0,1:07:53.32,1:07:54.76,English,,0,0,0,,Okay all right so what do you think if we...
Dialogue: 0,1:07:59.13,1:08:03.88,English,,0,0,0,,So if we take x which is an int cast it to a float
Dialogue: 0,1:08:04.74,1:08:07.96,English,,0,0,0,,And then cast that back to an int will that always be equal to x
Dialogue: 0,1:08:09.20,1:08:09.86,English,,0,0,0,,No
Dialogue: 0,1:08:10.24,1:08:14.30,English,,0,0,0,,Right as we lose some bits right we don't have enough frac bits in float
Dialogue: 0,1:08:15.12,1:08:21.56,English,,0,0,0,,What about if we take x cast it to a double and then cast it back to int
Dialogue: 0,1:08:21.56,1:08:24.62,English,,0,0,0,,Well we always get equivalent value yeah
Dialogue: 0,1:08:27.58,1:08:30.12,English,,0,0,0,,Because we have enough frac bits and none in double
Dialogue: 0,1:08:31.34,1:08:36.12,English,,0,0,0,,Now what if we take a float f,cast it to a double,and then cast it back to a float
Dialogue: 0,1:08:36.12,1:08:38.08,English,,0,0,0,,Well that always equal the original f
Dialogue: 0,1:08:39.42,1:08:42.38,English,,0,0,0,,Yeah,what about the converse though?
Dialogue: 0,1:08:42.38,1:08:47.06,English,,0,0,0,,What if we take the double d cast it to a float and cast it back to a double
Dialogue: 0,1:08:47.46,1:08:50.20,English,,0,0,0,,No
Dialogue: 0,1:08:50.44,1:08:56.48,English,,0,0,0,,How about this, how about if we take f Negate it and then negate that again will that always equal f
Dialogue: 0,1:08:57.56,1:08:59.50,English,,0,0,0,,Yeah because we're just toggling a bit right
Dialogue: 0,1:09:02.22,1:09:07.10,English,,0,0,0,,Okay how about 2/3 == 2/3.0
Dialogue: 0,1:09:08.16,1:09:10.66,English,,0,0,0,,No because 2/3 is 0
Dialogue: 0,1:09:12.72,1:09:20.50,English,,0,0,0,,And 2/3.0 is a is a floating point value 2/3 the floating point representation of 2/3
Dialogue: 0,1:09:21.82,1:09:25.72,English,,0,0,0,, Okay how about if the double d is less than 0
Dialogue: 0,1:09:27.66,1:09:31.94,English,,0,0,0,,Does that imply that d*2 is also less than 0?
Dialogue: 0,1:09:32.68,1:09:37.94,English,,0,0,0,,Yeah even if no matter what even if 2*d overflows
Dialogue: 0,1:09:38.22,1:09:46.90,English,,0,0,0,,It will overflow to negative infinity which is less than,which is less than zero
Dialogue: 0,1:09:47.52,1:09:54.75,English,,0,0,0,,Okay how about does the double d greater than f imply that -f is greater than -d
Dialogue: 0,1:09:55.48,1:09:59.04,English,,0,0,0,,Yeah that's that monotonicity right and again it's just...yes
Dialogue: 0,1:09:59.44,1:10:07.54,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:07.54,1:10:09.58,English,,0,0,0,,Oh that's a good question I think it'd be a float
Dialogue: 0,1:10:11.36,1:10:16.92,English,,0,0,0,,I think if you put there's an annotation and see to to give it a double
Dialogue: 0,1:10:16.92,1:10:23.32,English,,0,0,0,,But actually I'd have to check that out that's....enough yeah that's a good question I don't know
Dialogue: 0,1:10:24.44,1:10:29.36,English,,0,0,0,,We'd have to check after to go and look in the c guide
Dialogue: 0,1:10:35.54,1:10:44.02,English,,0,0,0,,How about it is d squared the double d squared always greater than or equal to zero yes
Dialogue: 0,1:10:44.86,1:10:48.62,English,,0,0,0,,And how about does d plus f minus d always equal f
Dialogue: 0,1:10:49.42,1:10:51.88,English,,0,0,0,,No because of a lack of associativity
Dialogue: 0,1:10:54.90,1:10:59.10,English,,0,0,0,,Okay so that was that was that was fun right
Dialogue: 0,1:10:59.10,1:11:01.14,English,,0,0,0,,Floating points always fun
Dialogue: 0,1:11:01.68,1:11:07.30,English,,0,0,0,,So anyway that the big thing is just to realize that floats aren't exactly really reals
Dialogue: 0,1:11:07.30,1:11:10.24,English,,0,0,0,,But they have very predictable properties
Dialogue: 0,1:11:11.12,1:11:16.80,English,,0,0,0,,And that they're not associative or commutative,they're not associative
Dialogue: 0,1:11:16.80,1:11:19.06,English,,0,0,0,,So you have to be careful about that
Dialogue: 0,1:11:19.54,1:11:24.31,English,,0,0,0,,All right we'll have a good weekend we'll see you on Tuesday
