[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 889
Active Line: 898
Video Position: 144672

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.70,English,,0,0,0,,Well good afternoon everybody
Dialogue: 0,0:00:02.68,0:00:07.94,English,,0,0,0,,Welcome good to see you and welcome to our viewers on video as well
Dialogue: 0,0:00:09.54,0:00:15.96,English,,0,0,0,,Okay so today we're going to look at some additional issues around the problem of synchronizing threaded programs
Dialogue: 0,0:00:17.72,0:00:21.44,English,,0,0,0,,First so let's review from last time of a few of the concepts
Dialogue: 0,0:00:22.32,0:00:29.56,English,,0,0,0,,So recall that a semaphore is a non-negative global synchronization variable
Dialogue: 0,0:00:29.56,0:00:31.36,English,,0,0,0,,It's manipulated by P and V operations
Dialogue: 0,0:00:32.28,0:00:36.92,English,,0,0,0,,And the P operation takes as an argument a semaphore
Dialogue: 0,0:00:38.70,0:00:44.96,English,,0,0,0,,If the semaphore values nonzero it decrements the semaphore and then continues
Dialogue: 0,0:00:45.74,0:00:48.08,English,,0,0,0,,If the semaphore values zero
Dialogue: 0,0:00:49.58,0:00:55.98,English,,0,0,0,,Then it blocks waiting for that semaphore value to be incremented by a V operation
Dialogue: 0,0:00:56.86,0:01:01.82,English,,0,0,0,,After the V operation increments after some V operation increments the semaphore
Dialogue: 0,0:01:03.24,0:01:08.92,English,,0,0,0,,The P operation continues by decrementing s and then returning control to the caller
Dialogue: 0,0:01:10.06,0:01:12.46,English,,0,0,0,,The V operation never blocks
Dialogue: 0,0:01:14.00,0:01:17.66,English,,0,0,0,,It first it increments the semaphore value s
Dialogue: 0,0:01:18.42,0:01:22.94,English,,0,0,0,,And then it looks in the queue of four to see if there's any processes that are blocked
Dialogue: 0,0:01:23.10,0:01:25.96,English,,0,0,0,,Waiting for that some afford to be nonzero
Dialogue: 0,0:01:27.66,0:01:33.52,English,,0,0,0,,If there are then it selects one of those using some unspecified criteria
Dialogue: 0,0:01:34.08,0:01:36.14,English,,0,0,0,,And then it restarts that
Dialogue: 0,0:01:38.12,0:01:43.96,English,,0,0,0,,It restarts that thread that's or that P operation that's waiting on the semaphore
Dialogue: 0,0:01:47.72,0:01:51.38,English,,0,0,0,,Okay and then this the semantics of the P and V
Dialogue: 0,0:01:51.94,0:01:55.70,English,,0,0,0,,Ensure that semaphore values are always greater than or equal to zero
Dialogue: 0,0:01:57.62,0:02:05.10,English,,0,0,0,,Now the first thing we saw how to protect shared variables by using a semaphore called the mutex
Dialogue: 0,0:02:05.72,0:02:11.74,English,,0,0,0,,That guarantees mutually exclusive access to the critical sections that are updating that
Dialogue: 0,0:02:12.48,0:02:14.62,English,,0,0,0,,Those variables are structures
Dialogue: 0,0:02:15.64,0:02:18.84,English,,0,0,0,,And and the way that we do this is very simple
Dialogue: 0,0:02:18.84,0:02:25.58,English,,0,0,0,,We initialize the mutex to one and then surround the critical section with a P and V
Dialogue: 0,0:02:27.74,0:02:30.06,English,,0,0,0,,Now there's other ways that we can
Dialogue: 0,0:02:30.06,0:02:34.64,English,,0,0,0,,So here's an example where we're using semaphore is to provide mutual exclusion
Dialogue: 0,0:02:35.76,0:02:43.32,English,,0,0,0,,But we can also use seminar semaphores to coordinate access to shared data structures in different ways
Dialogue: 0,0:02:44.16,0:02:49.82,English,,0,0,0,,And so the idea here before we were using the semaphore just to protect the access to a shared variable
Dialogue: 0,0:02:50.36,0:02:58.24,English,,0,0,0,,But we can also coordinate access in different ways by keep and this in this in these in these kind of scenarios
Dialogue: 0,0:02:58.28,0:03:04.14,English,,0,0,0,,We're using the semaphore to keep track of state to count things to keep track of state
Dialogue: 0,0:03:04.58,0:03:10.16,English,,0,0,0,,And to notify other other threads of changes in state okay so it's a very different usage model
Dialogue: 0,0:03:11.02,0:03:17.86,English,,0,0,0,,And two classic examples that we're going to look at are the producer consumer problem and a readers writers problem
Dialogue: 0,0:03:18.82,0:03:20.44,English,,0,0,0,,So let's look at producer consumer first
Dialogue: 0,0:03:21.62,0:03:24.90,English,,0,0,0,,So the idea in the producer consumer problem is that
Dialogue: 0,0:03:25.42,0:03:28.94,English,,0,0,0,,You have a resource in the form of a buffer
Dialogue: 0,0:03:29.66,0:03:32.44,English,,0,0,0,,The buffer has a bounded size
Dialogue: 0,0:03:32.50,0:03:36.60,English,,0,0,0,,So it consists of n slots and each slot can hold an item
Dialogue: 0,0:03:39.08,0:03:40.80,English,,0,0,0,,Okay the there's a producer thread
Dialogue: 0,0:03:41.44,0:03:42.70,English,,0,0,0,,Which produces items
Dialogue: 0,0:03:44.52,0:03:46.48,English,,0,0,0,,And then inserts them into the buffer
Dialogue: 0,0:03:47.50,0:03:49.02,English,,0,0,0,,And there's a consumer thread
Dialogue: 0,0:03:49.56,0:03:52.82,English,,0,0,0,,That retrieves removes items from the buffer
Dialogue: 0,0:03:52.90,0:03:57.74,English,,0,0,0,,And then consumes them by acting on them in some way processing on them in some way
Dialogue: 0,0:03:59.02,0:04:04.12,English,,0,0,0,,So the synchronization variable the synchronization pattern is that
Dialogue: 0,0:04:04.84,0:04:07.02,English,,0,0,0,,The producer waits for an empty slot right
Dialogue: 0,0:04:07.02,0:04:12.76,English,,0,0,0,,So if there's,if the buffer is full the producer can't insert an item into the buffer
Dialogue: 0,0:04:13.52,0:04:15.08,English,,0,0,0,,So it waits for an empty slot
Dialogue: 0,0:04:16.10,0:04:20.18,English,,0,0,0,,And then when it finds an empty slot when an empty slot becomes available
Dialogue: 0,0:04:20.48,0:04:22.56,English,,0,0,0,,It inserts the item into the buffer
Dialogue: 0,0:04:23.24,0:04:29.66,English,,0,0,0,,And then it notifies the consumer that there's now a new item in the buffer
Dialogue: 0,0:04:31.20,0:04:37.42,English,,0,0,0,,The consumer of course that has to wait for an item to show up in the buffer right
Dialogue: 0,0:04:37.64,0:04:41.44,English,,0,0,0,,Otherwise I mean you can't remove an item from an empty buffer
Dialogue: 0,0:04:41.80,0:04:46.36,English,,0,0,0,,So it has to wait for an item to be available in the buffer
Dialogue: 0,0:04:46.84,0:04:51.24,English,,0,0,0,,And when an item becomes available it removes it from the buffer
Dialogue: 0,0:04:51.64,0:04:55.54,English,,0,0,0,,And then notifies the producer that there's now an available slot
Dialogue: 0,0:04:58.80,0:05:06.18,English,,0,0,0,,Okay so this Actually this very simple pattern is actually really useful and shows up in a lot of applications
Dialogue: 0,0:05:06.70,0:05:08.64,English,,0,0,0,,So for example a multimedia application
Dialogue: 0,0:05:09.14,0:05:17.82,English,,0,0,0,,In a multimedia application the producer might be producing say MPEG frames in a video
Dialogue: 0,0:05:18.22,0:05:24.28,English,,0,0,0,,And a consumer would be consuming those MPEG frames and then painting the screen appropriately
Dialogue: 0,0:05:24.90,0:05:29.08,English,,0,0,0,,Another important application is in graphical user interfaces
Dialogue: 0,0:05:29.92,0:05:34.52,English,,0,0,0,,So graphical user interfaces are typically implemented using this producer-consumer model
Dialogue: 0,0:05:35.26,0:05:44.86,English,,0,0,0,,Where the mouse clicks,motions and the in the of the mouse,keyboard clicks
Dialogue: 0,0:05:45.30,0:05:46.88,English,,0,0,0,,Those are all recorded as events
Dialogue: 0,0:05:47.26,0:05:52.74,English,,0,0,0,,They're detected by the system recorded as events and placed into a some kind of a queue
Dialogue: 0,0:05:53.70,0:05:58.94,English,,0,0,0,,And then...there is other parts of the system retrieve items from the queue and react to them
Dialogue: 0,0:05:58.96,0:06:07.26,English,,0,0,0,,So for example the graphic system will retrieve events like mouse events and mouse movements mouse clicks
Dialogue: 0,0:06:07.72,0:06:09.70,English,,0,0,0,,And it will paint the screen accordingly right
Dialogue: 0,0:06:09.72,0:06:17.22,English,,0,0,0,,so that it will reflect it will repaint the screen ,so that to show you that the cursor is moving
Dialogue: 0,0:06:17.80,0:06:21.20,English,,0,0,0,,Right or if you change the focus it will repaint it
Dialogue: 0,0:06:21.90,0:06:25.68,English,,0,0,0,,So it's a very common model
Dialogue: 0,0:06:25.68,0:06:31.70,English,,0,0,0,,And as we'll see later multi-threaded we can build multi-threaded concurrent servers using this model
Dialogue: 0,0:06:34.48,0:06:38.56,English,,0,0,0,,So let's see how we would implement producer/consumer on an n-element buffer
Dialogue: 0,0:06:39.52,0:06:47.16,English,,0,0,0,,So this the implementation requires a mutex to guarantee mutually exclusive access to the resource of course
Dialogue: 0,0:06:47.84,0:06:52.06,English,,0,0,0,,And then it requires then two other semaphores counting semaphores
Dialogue: 0,0:06:53.74,0:06:58.48,English,,0,0,0,,Slots is a semaphore that counts the available slots in the buffer
Dialogue: 0,0:06:59.10,0:07:02.61,English,,0,0,0,,And items is counts the available items okay
Dialogue: 0,0:07:03.38,0:07:07.90,English,,0,0,0,,And we've can implement it with this package called sbuf
Dialogue: 0,0:07:10.98,0:07:17.92,English,,0,0,0,,So sbuf the sbuf package defines a type called sbuf_t
Dialogue: 0,0:07:17.92,0:07:24.12,English,,0,0,0,,that packages up all of the data structures that are needed to implement the shared buffer
Dialogue: 0,0:07:24.80,0:07:30.12,English,,0,0,0,,So there's a pointer to the buffer which we were going to implement as an array and
Dialogue: 0,0:07:30.62,0:07:34.52,English,,0,0,0,,And we'll implement a circular buffer on this array
Dialogue: 0,0:07:36.26,0:07:39.59,English,,0,0,0,,The maximum number of slots n,so the size of the buffer
Dialogue: 0,0:07:40.14,0:07:47.50,English,,0,0,0,,And then two pointers front and rear to keep track of the front and rear of the of the buffer
Dialogue: 0,0:07:47.50,0:07:50.57,English,,0,0,0,,So to keep track of the first and last items in the buffer
Dialogue: 0,0:07:51.26,0:07:55.56,English,,0,0,0,,And then the three semaphores the mutex and in the two counting semaphores
Dialogue: 0,0:07:56.48,0:07:59.84,English,,0,0,0,,And then the package consists of these four public functions
Dialogue: 0,0:08:00.36,0:08:11.96,English,,0,0,0,,sbuf_init which creates the is called once to create the buffer and initialize everything Allocate the space and initialize things
Dialogue: 0,0:08:11.96,0:08:14.44,English,,0,0,0,,And the (sbuf_)deinit which frees up the space
Dialogue: 0,0:08:15.38,0:08:24.08,English,,0,0,0,,And then a function to insert an item into the queue and a function to remove an item from a queue and return that item
Dialogue: 0,0:08:24.88,0:08:26.42,English,,0,0,0,,So in this case items are just int
Dialogue: 0,0:08:31.30,0:08:38.70,English,,0,0,0,,So to create the...to initialize the this buffer
Dialogue: 0,0:08:39.28,0:08:44.58,English,,0,0,0,,With n slots we first allocate the space for the buffer and n ints
Dialogue: 0,0:08:45.38,0:08:50.80,English,,0,0,0,,We set the size to be the value n that was passed in
Dialogue: 0,0:08:52.72,0:08:58.02,English,,0,0,0,,We indicate the empty buffer by setting front-and-rear to be zero
Dialogue: 0,0:08:58.78,0:09:03.20,English,,0,0,0,,Okay and so whenever front and rear are zero that's we have an empty buffer
Dialogue: 0,0:09:04.34,0:09:06.70,English,,0,0,0,,And then we initialize the three semaphore
Dialogue: 0,0:09:06.70,0:09:11.30,English,,0,0,0,,So the mutex like all mutex is initialized to 1
Dialogue: 0,0:09:13.32,0:09:19.48,English,,0,0,0,,The slot semaphore which keeps track of the number of available slots is initialized to n
Dialogue: 0,0:09:20.38,0:09:23.20,English,,0,0,0,,And the item semaphore is initialized to zero
Dialogue: 0,0:09:25.18,0:09:31.20,English,,0,0,0,,Okay and deinit is really simple it just frees up the heap space that we allocated
Dialogue: 0,0:09:33.10,0:09:36.74,English,,0,0,0,,Okay so now let's look at how we insert an item into the buffer
Dialogue: 0,0:09:36.94,0:09:43.18,English,,0,0,0,,So we call...we want to insert this integer item into this buffer pointed at by sp
Dialogue: 0,0:09:44.74,0:09:49.70,English,,0,0,0,,So first the thread waits for an available slot
Dialogue: 0,0:09:50.12,0:09:54.52,English,,0,0,0,,Okay by doing a p on the semaphore before alright so p will block
Dialogue: 0,0:09:55.50,0:09:59.44,English,,0,0,0,,Until the slots is greater than or equal to one
Dialogue: 0,0:10:01.14,0:10:02.82,English,,0,0,0,,Okay once there's an available slot
Dialogue: 0,0:10:03.76,0:10:13.76,English,,0,0,0,,Then it if then it's going to update the rear of the buffer
Dialogue: 0,0:10:14.26,0:10:16.74,English,,0,0,0,,Okay so we're going to put this item on to the rear of the buffer
Dialogue: 0,0:10:17.08,0:10:21.56,English,,0,0,0,,And so it needs to protect that access to that shared buffer with the mutex
Dialogue: 0,0:10:22.76,0:10:26.00,English,,0,0,0,,Then it does the by doing a p on the mutex
Dialogue: 0,0:10:26.78,0:10:29.92,English,,0,0,0,,Updating updating our rear pointer
Dialogue: 0,0:10:30.20,0:10:37.18,English,,0,0,0,,Okay so we pre increment it so we increment the rear pointer and then take the mod of that n
Dialogue: 0,0:10:37.80,0:10:43.86,English,,0,0,0,,To compute the index that we're going to insert the item
Dialogue: 0,0:10:44.80,0:10:47.74,English,,0,0,0,,Okay then we do a V on the mutex
Dialogue: 0,0:10:48.20,0:10:54.54,English,,0,0,0,,Okay so that other threads can update that shared data structure
Dialogue: 0,0:10:55.52,0:11:00.56,English,,0,0,0,,And then we do a V on the number of items to notify any consumers
Dialogue: 0,0:11:00.56,0:11:02.86,English,,0,0,0,,That there's now an item in the buffer
Dialogue: 0,0:11:04.68,0:11:12.48,English,,0,0,0,,So this V is kind of interesting you think it was kind of like a signal right so you're sort of signaling consumers that now
Dialogue: 0,0:11:13.14,0:11:14.86,English,,0,0,0,,Some event has occurred in the system
Dialogue: 0,0:11:18.08,0:11:20.92,English,,0,0,0,,Now to remove an item it's symmetric
Dialogue: 0,0:11:21.04,0:11:26.48,English,,0,0,0,,But instead of operating on the slots that before it operates on the items semaphore
Dialogue: 0,0:11:27.30,0:11:33.88,English,,0,0,0,,So to remove an item a consumer first does a P on the items semaphore
Dialogue: 0,0:11:33.94,0:11:38.78,English,,0,0,0,,So this now is waiting for an available item it's waiting for the semaphore to be greater than equal to one
Dialogue: 0,0:11:39.96,0:11:43.80,English,,0,0,0,,When that happens then the P returns
Dialogue: 0,0:11:44.44,0:11:49.00,English,,0,0,0,,And then we do the update protected by a mutex
Dialogue: 0,0:11:49.62,0:11:54.40,English,,0,0,0,,By pre-incrementing front taking the mod n
Dialogue: 0,0:11:54.86,0:12:03.70,English,,0,0,0,,And then reading that value and returning it and placing it into this local local variable item
Dialogue: 0,0:12:04.50,0:12:06.22,English,,0,0,0,,Then we release the mutex
Dialogue: 0,0:12:07.82,0:12:10.04,English,,0,0,0,,And then we do a V on the number of slots which
Dialogue: 0,0:12:10.48,0:12:15.50,English,,0,0,0,,Which is an announcement to any producers that there's now a new available slot
Dialogue: 0,0:12:19.54,0:12:20.70,English,,0,0,0,,So any questions about that
Dialogue: 0,0:12:24.72,0:12:26.32,English,,0,0,0,,So it's a little more subtle
Dialogue: 0,0:12:26.56,0:12:31.28,English,,0,0,0,,This looks really simple but like all concurrency problems it's actually very subtle
Dialogue: 0,0:12:33.26,0:12:39.64,English,,0,0,0,,So you can have potential,you can have many producers and many many consumers all operating on the same
Dialogue: 0,0:12:40.36,0:12:42.26,English,,0,0,0,,You know the same shared buffer
Dialogue: 0,0:12:44.32,0:12:47.70,English,,0,0,0,,So this...so what would happen
Dialogue: 0,0:12:48.84,0:12:52.02,English,,0,0,0,,If we had two consumers did
Dialogue: 0,0:12:52.58,0:12:56.84,English,,0,0,0,,A P on this item semaphore at the exact same time say we're running on two cores
Dialogue: 0,0:12:57.68,0:13:01.68,English,,0,0,0,,And and we have two threads and they each execute that P
Dialogue: 0,0:13:03.76,0:13:07.84,English,,0,0,0,,At the same time on that that same item semaphore
Dialogue: 0,0:13:08.72,0:13:14.30,English,,0,0,0,,Okay so even though they access it at the same time the kernel will make sure that one of them will execute first
Dialogue: 0,0:13:14.58,0:13:18.40,English,,0,0,0,,Okay so the kernel will serialize those P operations
Dialogue: 0,0:13:20.40,0:13:25.00,English,,0,0,0,,And it there's no telling which one gets it first but whoever runs
Dialogue: 0,0:13:25.40,0:13:31.48,English,,0,0,0,,There P first will decrement this item semaphore
Dialogue: 0,0:13:33.44,0:13:35.92,English,,0,0,0,,And then when the next when the next thread executes
Dialogue: 0,0:13:36.26,0:13:40.78,English,,0,0,0,,Its P items will either be zero or nonzero
Dialogue: 0,0:13:41.34,0:13:45.28,English,,0,0,0,,Okay as a result so somebody wins there's kind of a ton of like a controlled race
Dialogue: 0,0:13:45.72,0:13:50.44,English,,0,0,0,,And somebody wins the race always wins the race because the kernel is serializing
Dialogue: 0,0:13:50.84,0:13:54.94,English,,0,0,0,,These P operations and it's executing them atomically okay
Dialogue: 0,0:13:58.46,0:14:06.68,English,,0,0,0,,Okay now the there's a generalization of the mutual exclusion problem called the reader writer problem
Dialogue: 0,0:14:07.30,0:14:10.22,English,,0,0,0,,So with the mutual exclusion problem
Dialogue: 0,0:14:10.86,0:14:19.50,English,,0,0,0,,We were guaranteeing each thread mutually exclusive access to its critical section
Dialogue: 0,0:14:19.50,0:14:23.82,English,,0,0,0,,That's updating a particular resource or accessing a particular resource
Dialogue: 0,0:14:23.82,0:14:27.64,English,,0,0,0,,And we did this the exact same way whether that access was a read or write
Dialogue: 0,0:14:29.34,0:14:31.94,English,,0,0,0,,Okay but that's overly conservative in this case
Dialogue: 0,0:14:33.72,0:14:39.48,English,,0,0,0,,Because we could if all we were doing if we had multiple threads that were just reading the resource
Dialogue: 0,0:14:40.30,0:14:44.42,English,,0,0,0,,There would be no reason to do ps and vs on that resource or if we're not changing
Dialogue: 0,0:14:45.50,0:14:50.24,English,,0,0,0,,If we're not changing the resource for just reading it and there's nobody else writing it
Dialogue: 0,0:14:51.12,0:14:53.76,English,,0,0,0,,Then there's no need to protect right so it
Dialogue: 0,0:14:54.42,0:15:03.04,English,,0,0,0,,For readers we can have as many readers as we want all at the same time reading the resource the variable or set of variables
Dialogue: 0,0:15:04.74,0:15:07.20,English,,0,0,0,,And there's no need for any kind of synchronization at all
Dialogue: 0,0:15:08.08,0:15:14.40,English,,0,0,0,,Okay so the producer consumer is sort of a generalization of that mutual exclusion problem
Dialogue: 0,0:15:14.70,0:15:17.84,English,,0,0,0,,Which enforces mutual exclusion only when it's absolutely necessary
Dialogue: 0,0:15:18.46,0:15:23.66,English,,0,0,0,,Okay so there can be is there can be as many readers reading the resource
Dialogue: 0,0:15:23.68,0:15:28.74,English,,0,0,0,,But when a writer wants to write then it has to have mutual exclusive access to the resource
Dialogue: 0,0:15:34.62,0:15:38.18,English,,0,0,0,,Okay so this is a kind of thing...this is also a very useful pattern
Dialogue: 0,0:15:38.78,0:15:44.54,English,,0,0,0,,You have in an online airline reservation system you have multiple clients accessing a shared database
Dialogue: 0,0:15:45.60,0:15:49.44,English,,0,0,0,,Okay so as long as those clients are reading the database you can have
Dialogue: 0,0:15:50.06,0:15:54.90,English,,0,0,0,,They can all be reading at the same time but as soon as somebody wants to make a reservation and update the database
Dialogue: 0,0:15:55.52,0:15:59.16,English,,0,0,0,,Then that update has to happen a mutually exclusive way
Dialogue: 0,0:16:00.90,0:16:05.40,English,,0,0,0,,You know if you had also if you had like any kind of shared data structure like a cache
Dialogue: 0,0:16:06.54,0:16:11.14,English,,0,0,0,,In a concurrent proxy like that you're going to be writing soon
Dialogue: 0,0:16:11.66,0:16:13.72,English,,0,0,0,,Or if you haven't already started
Dialogue: 0,0:16:15.04,0:16:17.52,English,,0,0,0,,That cache is being shared by multiple threads
Dialogue: 0,0:16:18.24,0:16:20.84,English,,0,0,0,,And multiple threads may be reading that cache
Dialogue: 0,0:16:21.38,0:16:26.08,English,,0,0,0,,But when some...when you get a new page and you want to cache it
Dialogue: 0,0:16:26.86,0:16:32.14,English,,0,0,0,,Then that constitutes a right and that right needs to happen in our mutually exclusive way
Dialogue: 0,0:16:33.72,0:16:37.12,English,,0,0,0,,Now the initial research the researchers that
Dialogue: 0,0:16:40.12,0:16:42.60,English,,0,0,0,,That pose this readers writers problems
Dialogue: 0,0:16:43.88,0:16:48.78,English,,0,0,0,,In define sort of several classes of reader writer problems
Dialogue: 0,0:16:49.30,0:16:56.74,English,,0,0,0,,The first reader writer, readers writers problems is an implementation that favors readers right
Dialogue: 0,0:16:57.72,0:17:01.10,English,,0,0,0,,So the idea is that no reader should be kept waiting
Dialogue: 0,0:17:02.98,0:17:13.42,English,,0,0,0,,Right unless an a writer already has a P as has sort of acquired the lock on that or the mutex on that resource
Dialogue: 0,0:17:14.70,0:17:16.46,English,,0,0,0,,So it in this case
Dialogue: 0,0:17:17.24,0:17:21.76,English,,0,0,0,,You know say there's a writer waiting to get to acquire the mutex
Dialogue: 0,0:17:22.06,0:17:23.70,English,,0,0,0,,And another reader comes in
Dialogue: 0,0:17:24.34,0:17:27.54,English,,0,0,0,,Then in this implementation that reader would give priority over the writer
Dialogue: 0,0:17:28.30,0:17:34.02,English,,0,0,0,,And it would be able to read the to add to do its read
Dialogue: 0,0:17:34.38,0:17:35.66,English,,0,0,0,,And the writer would have to wait
Dialogue: 0,0:17:36.68,0:17:43.05,English,,0,0,0,,And so of court now if multiple readers keep coming in then this could starve out the writer right that
Dialogue: 0,0:17:43.58,0:17:48.14,English,,0,0,0,,So a writer could be starved sort of indefinitely waiting for all these readers to finish
Dialogue: 0,0:17:49.88,0:17:53.68,English,,0,0,0,,And it's just based on you know based based on
Dialogue: 0,0:17:54.82,0:17:59.36,English,,0,0,0,,How the operating system decides to schedule these various reader threads
Dialogue: 0,0:18:00.94,0:18:06.57,English,,0,0,0,,The writer could be starved out so that's what we mean by when we say that it favors readers
Dialogue: 0,0:18:07.22,0:18:14.68,English,,0,0,0,,Now the second reader saris problem is the sort of the opposite of that so it favors writers right
Dialogue: 0,0:18:14.90,0:18:18.52,English,,0,0,0,,So any once a writer is ready to write
Dialogue: 0,0:18:18.54,0:18:21.22,English,,0,0,0,,Then it gets priority over any waiting readers
Dialogue: 0,0:18:21.58,0:18:25.62,English,,0,0,0,,So in this case if we have multiple writers
Dialogue: 0,0:18:26.10,0:18:28.92,English,,0,0,0,,That want to write they could starve out readers
Dialogue: 0,0:18:32.76,0:18:39.52,English,,0,0,0,,And now there's other variants that sort of deal with this starvation issue potential starvation issue
Dialogue: 0,0:18:39.52,0:18:41.88,English,,0,0,0,,But we won't look at them here
Dialogue: 0,0:18:43.38,0:18:47.58,English,,0,0,0,,So the let's look at the solution to the first readers writers problem
Dialogue: 0,0:18:50.62,0:18:56.84,English,,0,0,0,,So write initially a thread is either a reader in this sort of simplification or it's a writer
Dialogue: 0,0:18:59.44,0:19:01.76,English,,0,0,0,,If we look at the writers this is pretty simple
Dialogue: 0,0:19:01.76,0:19:09.20,English,,0,0,0,,It's just the writers are just doing a P on this semaphore
Dialogue: 0,0:19:09.40,0:19:17.66,English,,0,0,0,,So this the semaphore w is the sort of serves as like a mutex that protects the resource for writer
Dialogue: 0,0:19:17.72,0:19:25.74,English,,0,0,0,,So it ensures that there's at most one writer at any time executing its critical section
Dialogue: 0,0:19:26.54,0:19:34.00,English,,0,0,0,,And it does that by just this this very from this familiar P followed followed by a V
Dialogue: 0,0:19:35.60,0:19:37.42,English,,0,0,0,,In the readers are a little more interesting
Dialogue: 0,0:19:38.88,0:19:40.30,English,,0,0,0,,So with the reader
Dialogue: 0,0:19:40.92,0:19:46.16,English,,0,0,0,,We have the shared this global variable called read count which is going to keep track of the number of readers
Dialogue: 0,0:19:46.50,0:19:51.58,English,,0,0,0,,That are waiting to read the resource
Dialogue: 0,0:19:52.34,0:19:57.94,English,,0,0,0,,And there's a mutex semaphore mutex that protects the accesses the updates to read count
Dialogue: 0,0:19:58.66,0:20:01.80,English,,0,0,0,,Okay the reads and the rights to up to read count
Dialogue: 0,0:20:02.74,0:20:04.64,English,,0,0,0,,And then there's this w semaphore
Dialogue: 0,0:20:05.12,0:20:10.68,English,,0,0,0,,Which as we saw here is used to protect the critical section in the writer
Dialogue: 0,0:20:11.60,0:20:13.90,English,,0,0,0,,And initially both of these are set to one
Dialogue: 0,0:20:16.70,0:20:20.52,English,,0,0,0,,So the reader in this infinite loop in each iteration of this infinite loop
Dialogue: 0,0:20:21.34,0:20:28.90,English,,0,0,0,,It is going to increment read count so it protects that that access by doing a P(&mutex)
Dialogue: 0,0:20:28.90,0:20:30.64,English,,0,0,0,,Which is associated with recount
Dialogue: 0,0:20:33.04,0:20:36.80,English,,0,0,0,,So only one reader can be
Dialogue: 0,0:20:36.96,0:20:44.36,English,,0,0,0,,So this region between the P and the V constitutes the critical section corresponding to read count
Dialogue: 0,0:20:45.66,0:20:50.54,English,,0,0,0,,So after the P completes then it
Dialogue: 0,0:20:51.30,0:20:55.40,English,,0,0,0,,Then we increment the read count so now there's an additional reader
Dialogue: 0,0:20:56.20,0:20:58.80,English,,0,0,0,,Alright so we can have potentially arbitrary number of these reader threads
Dialogue: 0,0:20:58.80,0:21:03.18,English,,0,0,0,,Right so this we're indicating that there's a new reader now
Dialogue: 0,0:21:04.54,0:21:07.90,English,,0,0,0,,And if read count is one that means we're the first reader
Dialogue: 0,0:21:08.46,0:21:14.82,English,,0,0,0,,Okay so this is sort of the first reader into this implicit queue of waiting readers
Dialogue: 0,0:21:17.00,0:21:20.04,English,,0,0,0,,So if read count is one if we're the first reader
Dialogue: 0,0:21:21.46,0:21:23.36,English,,0,0,0,,Then we do a P(&w)
Dialogue: 0,0:21:25.26,0:21:29.26,English,,0,0,0,,Okay which now will lock out any future writers
Dialogue: 0,0:21:30.58,0:21:36.90,English,,0,0,0,,Now if there's already a writer that's done it's P(&w) then this will block waiting for that writer to finish
Dialogue: 0,0:21:38.74,0:21:43.58,English,,0,0,0,,Okay but if there's no writer in inside of its critical section
Dialogue: 0,0:21:44.36,0:21:48.30,English,,0,0,0,,Then this p will just decrement the semaphore w
Dialogue: 0,0:21:49.08,0:21:52.76,English,,0,0,0,,From 1 to 0 and then lock out any subsequent writers
Dialogue: 0,0:21:54.76,0:22:01.54,English,,0,0,0,,Okay after so now after it's done this increment and read of the recount variable then it releases the mutex
Dialogue: 0,0:22:02.40,0:22:06.00,English,,0,0,0,,So that other readers can access recount
Dialogue: 0,0:22:09.92,0:22:11.36,English,,0,0,0,,Okay now but it's still holding
Dialogue: 0,0:22:15.30,0:22:22.76,English,,0,0,0,,It's holding,so this is this is kind of interesting right, it's holding the semaphore that locks out the writers
Dialogue: 0,0:22:24.20,0:22:33.10,English,,0,0,0,,But it's not holding the any mutex right so the reader now can just read,it can do its read
Dialogue: 0,0:22:34.32,0:22:41.12,English,,0,0,0,,And other readers that are in the same section of the code can also do their reads right so
Dialogue: 0,0:22:42.04,0:22:42.60,English,,0,0,0,,So we're not...
Dialogue: 0,0:22:45.60,0:22:49.15,English,,0,0,0,,So we're allowing multiple readers now inside this critical section
Dialogue: 0,0:22:49.62,0:22:51.16,English,,0,0,0,,But but no writers
Dialogue: 0,0:22:52.64,0:22:57.54,English,,0,0,0,,Okay so everything works looks like it works good,now after after we read
Dialogue: 0,0:22:58.24,0:23:02.30,English,,0,0,0,,Now the number of readers now is going to be we want to decrement the number of readers
Dialogue: 0,0:23:03.18,0:23:05.92,English,,0,0,0,,So we acquire the mutex on readcnt
Dialogue: 0,0:23:06.54,0:23:07.86,English,,0,0,0,,We decrement readcnt
Dialogue: 0,0:23:09.50,0:23:11.80,English,,0,0,0,,And then we check to see if we're the last reader
Dialogue: 0,0:23:12.52,0:23:13.76,English,,0,0,0,,Okay so if there's no more readers
Dialogue: 0,0:23:14.51,0:23:16.32,English,,0,0,0,,In other words if read count is zero
Dialogue: 0,0:23:18.14,0:23:20.96,English,,0,0,0,,Then now we can release the mutex for the writer
Dialogue: 0,0:23:21.34,0:23:24.24,English,,0,0,0,,So that any now writers can access that resource
Dialogue: 0,0:23:25.98,0:23:33.52,English,,0,0,0,,And after we release that the writers mutex then we release the mutex for recount
Dialogue: 0,0:23:37.20,0:23:39.16,English,,0,0,0,,So any questions about about this
Dialogue: 0,0:23:43.20,0:23:45.36,English,,0,0,0,,So an interesting for you to think about just...
Dialogue: 0,0:23:46.18,0:23:47.36,English,,0,0,0,,If you have any spare time
Dialogue: 0,0:23:47.80,0:23:56.16,English,,0,0,0,,How you might write a version of this readers writers problem or that favors writers instead of readers
Dialogue: 0,0:23:59.80,0:24:00.18,English,,0,0,0,,Yes
Dialogue: 0,0:24:00.30,0:24:05.96,English,,0,0,0,,[student speaking]
Dialogue: 0,0:24:05.96,0:24:09.44,English,,0,0,0,,Oh no okay so the question is a mutex allows for multiple readers
Dialogue: 0,0:24:11.08,0:24:15.36,English,,0,0,0,,The fact that we...No,the fact that we're releasing this mutex here
Dialogue: 0,0:24:15.42,0:24:19.40,English,,0,0,0,,That this mutex is only protecting access to readcnt
Dialogue: 0,0:24:19.74,0:24:21.84,English,,0,0,0,,So we acquire it here and we release it here
Dialogue: 0,0:24:22.30,0:24:25.48,English,,0,0,0,,After we've...after we've accessed read count
Dialogue: 0,0:24:27.22,0:24:31.72,English,,0,0,0,,Okay but we're not protecting the critical section of the reader with any mutex
Dialogue: 0,0:24:33.42,0:24:39.18,English,,0,0,0,,Except for we're keeping writers out by...if we're the first one in
Dialogue: 0,0:24:39.84,0:24:40.98,English,,0,0,0,,If we're the first reader
Dialogue: 0,0:24:42.84,0:24:47.38,English,,0,0,0,,You commanders like this implicit queue of readers that we're keeping track of with readcnt
Dialogue: 0,0:24:48.40,0:24:52.96,English,,0,0,0,,Okay so if we're the first ones in meaning
Dialogue: 0,0:24:53.54,0:24:59.04,English,,0,0,0,,We're the first reader then we we acquire this the p on the writers mutex
Dialogue: 0,0:24:59.24,0:25:04.24,English,,0,0,0,,Now if there's of course if there's a writer inside this critical section then
Dialogue: 0,0:25:04.88,0:25:07.86,English,,0,0,0,,This P will wait until the writer releases
Dialogue: 0,0:25:09.88,0:25:14.72,English,,0,0,0,,Okay but once we've acquired this mutex w
Dialogue: 0,0:25:16.30,0:25:18.54,English,,0,0,0,,Then we're block...we're locking out any writers
Dialogue: 0,0:25:19.24,0:25:28.12,English,,0,0,0,,Okay because they'll any writer that arrives we'll do a P and it will block right here on waiting for that w to be nonzero
Dialogue: 0,0:25:29.54,0:25:36.98,English,,0,0,0,,Okay so we're just blocking out any writers but then we're allowing any readers to just to access the resource
Dialogue: 0,0:25:40.08,0:25:40.52,English,,0,0,0,,Okay
Dialogue: 0,0:25:41.84,0:25:42.50,English,,0,0,0,,Okay good
Dialogue: 0,0:25:45.14,0:25:45.72,English,,0,0,0,,Yes question
Dialogue: 0,0:25:45.72,0:25:49.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:25:49.64,0:25:51.02,English,,0,0,0,,Question is blocking slow
Dialogue: 0,0:25:51.50,0:25:56.00,English,,0,0,0,,It can be depends well first of all you're making a call into the kernel so it's a system call
Dialogue: 0,0:25:56.56,0:26:00.10,English,,0,0,0,,So you're crossing that boundary and there's always overhead associated with that
Dialogue: 0,0:26:01.00,0:26:07.08,English,,0,0,0,,And then blocking you're blocked until you know it can be sort of an arbitrary amount of time right
Dialogue: 0,0:26:07.08,0:26:09.58,English,,0,0,0,,Until someone doesn't,some thread does a V
Dialogue: 0,0:26:10.32,0:26:11.92,English,,0,0,0,,So yeah it can't be slow
Dialogue: 0,0:26:13.22,0:26:18.34,English,,0,0,0,,Right it just depends you can't,it's really hard to bound the time that you're going to be blocked
Dialogue: 0,0:26:19.22,0:26:22.44,English,,0,0,0,,Now if you write the program correctly eventually you'll be unblocked
Dialogue: 0,0:26:23.10,0:26:25.48,English,,0,0,0,,You know eventually some thread will execute a V
Dialogue: 0,0:26:27.88,0:26:35.50,English,,0,0,0,,But when we're sort of assuming that the kernel does some kind of when it implements its V it does some kind of fair scheduling that
Dialogue: 0,0:26:36.26,0:26:44.42,English,,0,0,0,,So a blocked P won't be in its queue for forever right that the kernel does some kind of something that's fair
Dialogue: 0,0:26:44.78,0:26:48.70,English,,0,0,0,,So it guarantees that a P won't remain blocked indefinitely
Dialogue: 0,0:26:54.80,0:26:55.60,English,,0,0,0,,Other questions
Dialogue: 0,0:27:00.86,0:27:02.86,English,,0,0,0,,Okay so we can kind of put all of this together
Dialogue: 0,0:27:04.42,0:27:08.46,English,,0,0,0,,And and use our producer-consumer model
Dialogue: 0,0:27:09.30,0:27:13.26,English,,0,0,0,,To implement a pre threaded concurrent echo server
Dialogue: 0,0:27:13.78,0:27:16.44,English,,0,0,0,,Now so far when we've used threads to
Dialogue: 0,0:27:16.78,0:27:20.12,English,,0,0,0,,In all our examples of using threads and processes for servers
Dialogue: 0,0:27:20.70,0:27:24.54,English,,0,0,0,,We created a new thread or process whenever a new connection requests arrived
Dialogue: 0,0:27:25.92,0:27:27.06,English,,0,0,0,,And then when
Dialogue: 0,0:27:28.04,0:27:30.66,English,,0,0,0,,And then that thread interacted with the client
Dialogue: 0,0:27:31.66,0:27:36.36,English,,0,0,0,,And then whenever that interaction was finished it closed the connection and exited
Dialogue: 0,0:27:36.66,0:27:38.58,English,,0,0,0,,And killed the thread or process
Dialogue: 0,0:27:39.34,0:27:42.64,English,,0,0,0,,Now that's okay but it's inefficient
Dialogue: 0,0:27:43.50,0:27:49.14,English,,0,0,0,,Because we're this creating and killing threads introduces overhead
Dialogue: 0,0:27:50.28,0:27:59.02,English,,0,0,0,,So another way to do this is to create the treads or processes ahead of time create a pool of threads
Dialogue: 0,0:27:59.34,0:28:04.20,English,,0,0,0,,Where each thread so we create a pool of these worker threads
Dialogue: 0,0:28:04.20,0:28:08.88,English,,0,0,0,,Where each of these worker threads interacts with can interact with a client
Dialogue: 0,0:28:11.10,0:28:14.84,English,,0,0,0,,Okay so instead of sort of creating processes and threads on on-demand
Dialogue: 0,0:28:14.86,0:28:22.84,English,,0,0,0,,We create a,what we call a set of pre threaded or pre threaded threads or pre forked processes
Dialogue: 0,0:28:23.80,0:28:24.52,English,,0,0,0,,That do the work
Dialogue: 0,0:28:25.48,0:28:30.44,English,,0,0,0,,So the idea is that we have this master thread in our server
Dialogue: 0,0:28:30.96,0:28:36.82,English,,0,0,0,,That's waiting for connection requests from clients by repeated calls to accept
Dialogue: 0,0:28:38.40,0:28:41.72,English,,0,0,0,,And then when this thread receives the connection request
Dialogue: 0,0:28:42.40,0:28:48.52,English,,0,0,0,,From the client the accept call the accept function returns a connected file descriptor
Dialogue: 0,0:28:49.32,0:28:52.62,English,,0,0,0,,Ok associated with the connection to the client
Dialogue: 0,0:28:53.82,0:28:58.38,English,,0,0,0,,And then it inserts that descriptor into a into a buffer
Dialogue: 0,0:28:58.76,0:29:01.74,English,,0,0,0,,Ok now remember descriptors are just small integers
Dialogue: 0,0:29:02.48,0:29:04.74,English,,0,0,0,,That index the descriptor table
Dialogue: 0,0:29:05.28,0:29:09.10,English,,0,0,0,,Right so they can be passed around from thread to thread
Dialogue: 0,0:29:09.22,0:29:10.94,English,,0,0,0,,Because all the threads are sharing the same
Dialogue: 0,0:29:12.00,0:29:15.50,English,,0,0,0,,The same set that same descriptor table right
Dialogue: 0,0:29:17.76,0:29:19.48,English,,0,0,0,,So the master thread puts
Dialogue: 0,0:29:21.32,0:29:28.90,English,,0,0,0,,The repeatedly accepts connection requests and inserts the corresponding connected file descriptor into the buffer
Dialogue: 0,0:29:30.32,0:29:37.00,English,,0,0,0,,Now each worker thread waits for the...so in this case the items are descriptors
Dialogue: 0,0:29:37.88,0:29:43.25,English,,0,0,0,,So the worker threads they're all waiting on this for items to appear in this buffer
Dialogue: 0,0:29:44.80,0:29:48.14,English,,0,0,0,,Okay and when an item appears one of the threads will remove that item
Dialogue: 0,0:29:51.56,0:29:55.86,English,,0,0,0,,And then use that descriptor to interact with the client
Dialogue: 0,0:29:55.86,0:30:02.76,English,,0,0,0,,Over the connected file descriptor associated with the connection that exists between the client and the server
Dialogue: 0,0:30:04.46,0:30:12.38,English,,0,0,0,,Okay so now we have the concurrency comes in the form of these multiple worker threads interacting with multiple clients
Dialogue: 0,0:30:13.24,0:30:18.16,English,,0,0,0,,And then when a worker thread finishes servicing a particular client
Dialogue: 0,0:30:19.70,0:30:23.44,English,,0,0,0,,Then it just goes and it checks for the next file descriptor in the buffer
Dialogue: 0,0:30:24.14,0:30:29.00,English,,0,0,0,,Okay so this is much more efficient than our previous model where
Dialogue: 0,0:30:29.70,0:30:32.50,English,,0,0,0,,For each new client we had to create a thread or a process
Dialogue: 0,0:30:32.90,0:30:35.64,English,,0,0,0,,And then destroy that thread or process once we were finished
Dialogue: 0,0:30:35.98,0:30:39.20,English,,0,0,0,,Okay so we're sort of re amortize that
Dialogue: 0,0:30:40.40,0:30:44.50,English,,0,0,0,,That we had to go through to create these worker threads by leaving them running
Dialogue: 0,0:30:45.02,0:30:53.24,English,,0,0,0,,And then replacing the destruction or the killing of that thread with replacing it with just a simple
Dialogue: 0,0:30:54.38,0:30:59.98,English,,0,0,0,,As simple and very fast operation of removing an item from the buffer
Dialogue: 0,0:31:02.80,0:31:05.60,English,,0,0,0,,Okay so let's see how we would implement this
Dialogue: 0,0:31:07.16,0:31:10.24,English,,0,0,0,,And like all of these server examples it's surprisingly simple right
Dialogue: 0,0:31:10.44,0:31:18.64,English,,0,0,0,,This is a fully functioning a real server but we can do it in one page of code
Dialogue: 0,0:31:20.44,0:31:24.18,English,,0,0,0,,So for this preth... we're going to use threads for our concurrent server
Dialogue: 0,0:31:25.14,0:31:28.08,English,,0,0,0,,And we're going to use the sbuf package so we're going to create this
Dialogue: 0,0:31:28.68,0:31:33.04,English,,0,0,0,,This shared buffer global variable called sbuf
Dialogue: 0,0:31:36.28,0:31:41.02,English,,0,0,0,,And we have listening descriptor and connected descriptor
Dialogue: 0,0:31:41.24,0:31:45.90,English,,0,0,0,,And we have the clientlen and clientaddr that that will be used in the accept call
Dialogue: 0,0:31:46.32,0:31:52.44,English,,0,0,0,,And we have the thread id(t_id) that will be used in the when we create that this thread
Dialogue: 0,0:31:53.80,0:31:59.32,English,,0,0,0,,So now that we start by...we're going to in this program,we're going to pass in the port number
Dialogue: 0,0:31:59.34,0:32:02.00,English,,0,0,0,,So the server is going to be listening on some port
Dialogue: 0,0:32:02.66,0:32:06.60,English,,0,0,0,,So we passed that port number in as the first argument
Dialogue: 0,0:32:09.42,0:32:12.30,English,,0,0,0,,So we call Open_listenfd(argv[1])
Dialogue: 0,0:32:13.92,0:32:17.38,English,,0,0,0,,An open_listenfd creates a listening descriptor and returns it
Dialogue: 0,0:32:18.04,0:32:20.78,English,,0,0,0,,Returns the value of that descriptor and listenfd
Dialogue: 0,0:32:22.06,0:32:26.50,English,,0,0,0,,And then we call sbuf_init to initialize a shared buffer
Dialogue: 0,0:32:28.36,0:32:31.58,English,,0,0,0,,With SBUFSIZE file descriptors
Dialogue: 0,0:32:33.92,0:32:37.36,English,,0,0,0,,And then we create a collection of NTHREADS worker threads
Dialogue: 0,0:32:38.34,0:32:44.24,English,,0,0,0,,Each of which will execute the thread routine which we've called thread  and no argument
Dialogue: 0,0:32:46.78,0:32:50.42,English,,0,0,0,,So once we create these all of these threads then we go in this infinite loop
Dialogue: 0,0:32:52.26,0:32:56.66,English,,0,0,0,,Where we call Accept
Dialogue: 0,0:32:59.38,0:33:05.06,English,,0,0,0,,On this listening descriptor so in that except we'll block until a connection request arrives
Dialogue: 0,0:33:05.62,0:33:11.72,English,,0,0,0,,And when it does the accept returns with a connected file descriptor that can be used to interact with the client
Dialogue: 0,0:33:14.22,0:33:18.56,English,,0,0,0,,And once we get that connected file descriptor then we just simply insert it
Dialogue: 0,0:33:19.48,0:33:24.02,English,,0,0,0,,We insert that that connected file descriptor into a shared buffer
Dialogue: 0,0:33:24.76,0:33:28.26,English,,0,0,0,,And then wait for the connection request the next connection request
Dialogue: 0,0:33:28.26,0:33:34.98,English,,0,0,0,,So our servers very efficient right we're just doing an accept and then a very fast insert into the buffer
Dialogue: 0,0:33:35.72,0:33:44.60,English,,0,0,0,,Okay and then we're going to let the worker threads do all the work associated with that queue of descriptors
Dialogue: 0,0:33:47.44,0:33:51.50,English,,0,0,0,,Now the thread routine first detaches
Dialogue: 0,0:33:51.86,0:33:53.98,English,,0,0,0,,Okay so this is a case where we don't want to run joinable
Dialogue: 0,0:33:54.88,0:33:57.64,English,,0,0,0,,Because we're never going to to join
Dialogue: 0,0:33:58.10,0:34:05.56,English,,0,0,0,,We're never going to wait for these threads or have any reason to I kill them from the main thread
Dialogue: 0,0:34:06.64,0:34:12.16,English,,0,0,0,,So this so now this this worker thread and in this infinite loop each iteration it removes
Dialogue: 0,0:34:12.82,0:34:18.70,English,,0,0,0,,An item from the buffer so it blocks until there's an item that it can remove from the buffer
Dialogue: 0,0:34:19.60,0:34:25.36,English,,0,0,0,,And it sets it to this local variable connfd
Dialogue: 0,0:34:26.22,0:34:30.58,English,,0,0,0,,And then it calls a helper sort of this is like the the helper function
Dialogue: 0,0:34:31.42,0:34:36.90,English,,0,0,0,,That implements the logic for this this particular server and in this case it's an echo server
Dialogue: 0,0:34:38.20,0:34:42.54,English,,0,0,0,,So this echo count routine will interact with the client
Dialogue: 0,0:34:42.56,0:34:46.54,English,,0,0,0,,Echoing whatever the client sends us until the client closes the connection
Dialogue: 0,0:34:48.26,0:34:50.60,English,,0,0,0,,And then when it so whenever the client is finished then
Dialogue: 0,0:34:52.26,0:35:00.66,English,,0,0,0,,Then we close the we close the an end of the connection and go back and get the next item out of the buffer
Dialogue: 0,0:35:02.38,0:35:06.70,English,,0,0,0,,And as you point out that echo count is just a placeholder this could be anything
Dialogue: 0,0:35:06.70,0:35:11.72,English,,0,0,0,,This could be the logic for a web server for any kind of web service or any kind of service
Dialogue: 0,0:35:15.66,0:35:16.42,English,,0,0,0,,Now
Dialogue: 0,0:35:18.38,0:35:22.44,English,,0,0,0,,The to initialize this echo count(init_echo_cnt) function
Dialogue: 0,0:35:24.38,0:35:28.90,English,,0,0,0,,We need to initialize the mutex
Dialogue: 0,0:35:30.78,0:35:38.54,English,,0,0,0,,So we're...so this echo count function is going to have it has it defines a global variable called byte_cnt
Dialogue: 0,0:35:39.34,0:35:45.12,English,,0,0,0,,So this in this echo server we're going to keep track of the number of bytes that we've received from all the clients
Dialogue: 0,0:35:45.42,0:35:46.74,English,,0,0,0,,That we're interacting with
Dialogue: 0,0:35:47.48,0:35:52.00,English,,0,0,0,,Okay so there's a global variable called byte_cnt which is shared by all the threads
Dialogue: 0,0:35:52.56,0:35:57.04,English,,0,0,0,,And we're going to update this byte_cnt variable every time we receive
Dialogue: 0,0:35:57.86,0:36:01.34,English,,0,0,0,,Something every time we receive data from the client
Dialogue: 0,0:36:01.96,0:36:06.24,English,,0,0,0,,And we're going to use mutex to protect the accesses to byte_cnt
Dialogue: 0,0:36:07.98,0:36:11.80,English,,0,0,0,,Okay so we're going to initially have to initialize
Dialogue: 0,0:36:13.02,0:36:15.78,English,,0,0,0,,We have to call a function that initializes
Dialogue: 0,0:36:18.10,0:36:24.14,English,,0,0,0,,That initializes this by first initializing the mutex and then setting byte_cnt to zero
Dialogue: 0,0:36:27.06,0:36:28.76,English,,0,0,0,,And then within echo count itself
Dialogue: 0,0:36:35.98,0:36:39.10,English,,0,0,0,,There's...we've already seen...
Dialogue: 0,0:36:39.92,0:36:42.24,English,,0,0,0,,We've already seen a way to initialize a package
Dialogue: 0,0:36:42.90,0:36:47.50,English,,0,0,0,,You know if we have some kind of package of library functions that are going to be used by multiple threads
Dialogue: 0,0:36:48.24,0:36:51.72,English,,0,0,0,,There's several ways to actually initialize this package
Dialogue: 0,0:36:52.40,0:36:59.88,English,,0,0,0,,So one way is to explicitly call have the main thread call this initialization function once
Dialogue: 0,0:37:00.72,0:37:05.92,English,,0,0,0,,Okay so we've seen that with like the sbuf package right the main thread has to call
Dialogue: 0,0:37:08.80,0:37:11.02,English,,0,0,0,,The main thread calls sbuf_init at once
Dialogue: 0,0:37:12.40,0:37:16.68,English,,0,0,0,,Okay before any of the peer threads execute any of the worker threads executes
Dialogue: 0,0:37:18.64,0:37:20.42,English,,0,0,0,,But there's another way we can do this too
Dialogue: 0,0:37:20.42,0:37:24.86,English,,0,0,0,,We can have that the worker threads actually call the initialization function
Dialogue: 0,0:37:26.08,0:37:30.88,English,,0,0,0,,And we can use this technique provided by pthreads
Dialogue: 0,0:37:31.94,0:37:35.28,English,,0,0,0,,Where we define a static variable
Dialogue: 0,0:37:35.66,0:37:42.08,English,,0,0,0,,So this is a static local variable but you recall that, this is actually treated like a global variable
Dialogue: 0,0:37:42.62,0:37:47.08,English,,0,0,0,,So it every thread has access to this variable
Dialogue: 0,0:37:48.00,0:37:53.94,English,,0,0,0,,Okay but its scope is limited to the echo_cnt function
Dialogue: 0,0:37:53.96,0:37:59.16,English,,0,0,0,,So no other function connect can access this variable
Dialogue: 0,0:37:59.50,0:38:05.48,English,,0,0,0,,But each thread that executes this thread routine has access to it
Dialogue: 0,0:38:05.96,0:38:09.64,English,,0,0,0,,And in this context it's treated like a global right
Dialogue: 0,0:38:09.72,0:38:15.34,English,,0,0,0,,So if one thread updates the value every other every thread sees that same value
Dialogue: 0,0:38:16.54,0:38:21.92,English,,0,0,0,,Okay so we can use this mechanism from pthreads
Dialogue: 0,0:38:22.76,0:38:31.42,English,,0,0,0,,But so we can create this variable of type pthread_once_t and initialize it to this special pthreads value
Dialogue: 0,0:38:31.78,0:38:36.98,English,,0,0,0,,Which is sort of like the pthreads uninitialized value
Dialogue: 0,0:38:37.04,0:38:41.04,English,,0,0,0,,So this is a value that pthreads knows about that indicates that
Dialogue: 0,0:38:41.90,0:38:45.88,English,,0,0,0,,That this variable wants hasn't been initialized
Dialogue: 0,0:38:48.20,0:38:51.98,English,,0,0,0,,And then we call the pthread once function
Dialogue: 0,0:38:52.78,0:38:58.50,English,,0,0,0,,Passing at this variable that we the address of this variable created that we created
Dialogue: 0,0:38:59.12,0:39:02.84,English,,0,0,0,,And the address of the function to call to initialize
Dialogue: 0,0:39:04.68,0:39:07.98,English,,0,0,0,,Whatever it is we want to initialize in this case the echo_cnt
Dialogue: 0,0:39:10.88,0:39:12.72,English,,0,0,0,,The the echo_cnt variable
Dialogue: 0,0:39:14.16,0:39:18.66,English,,0,0,0,,And so what this does every thread will call Pthread_once
Dialogue: 0,0:39:18.86,0:39:26.24,English,,0,0,0,,But only one thread will actually call the initialization function
Dialogue: 0,0:39:27.68,0:39:32.66,English,,0,0,0,,Only the very first thread that executes Pthread_once will we'll call it
Dialogue: 0,0:39:32.66,0:39:37.24,English,,0,0,0,,The other threads this Pthread call will be like a no op
Dialogue: 0,0:39:37.90,0:39:38.54,English,,0,0,0,,Yes question
Dialogue: 0,0:39:38.54,0:39:42.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:39:42.80,0:39:43.88,English,,0,0,0,,Well that's the other option
Dialogue: 0,0:39:44.66,0:39:47.88,English,,0,0,0,,So the advantage of this is that
Dialogue: 0,0:39:50.46,0:39:57.06,English,,0,0,0,,You can...I guess the advantage is I don't know that it's just another way you can do it
Dialogue: 0,0:39:58.64,0:40:02.96,English,,0,0,0,,You...I guess it avoids having to do it in the master thread that
Dialogue: 0,0:40:03.20,0:40:08.24,English,,0,0,0,,You can make your...you can make this package sort of self-contained right that
Dialogue: 0,0:40:08.50,0:40:11.20,English,,0,0,0,,You're not really counting on the master doing anything
Dialogue: 0,0:40:12.54,0:40:17.94,English,,0,0,0,,But yeah that's the other way we could have done it so I just wanted to show you this other technique
Dialogue: 0,0:40:19.62,0:40:24.26,English,,0,0,0,,Okay so once we initialize...once we once
Dialogue: 0,0:40:24.50,0:40:26.14,English,,0,0,0,,Some thread calls the init_echo_cnt
Dialogue: 0,0:40:28.46,0:40:30.26,English,,0,0,0,,Then we initialize the Rio package
Dialogue: 0,0:40:32.00,0:40:34.98,English,,0,0,0,,For all of our accesses on this connected descriptor
Dialogue: 0,0:40:36.42,0:40:40.48,English,,0,0,0,,And then we repeatedly read a line of text from the client
Dialogue: 0,0:40:42.26,0:40:44.22,English,,0,0,0,,Okay and then
Dialogue: 0,0:40:45.78,0:40:50.48,English,,0,0,0,,In a protected way we increment byte_cnt with the number of bytes that
Dialogue: 0,0:40:50.54,0:40:56.28,English,,0,0,0,,We received  from the client which is returned by this rio read line b function
Dialogue: 0,0:40:57.68,0:41:00.90,English,,0,0,0,,And then we print a little message just to sort of keep track
Dialogue: 0,0:41:01.04,0:41:04.40,English,,0,0,0,,So we can see keep track of our running total
Dialogue: 0,0:41:04.98,0:41:09.42,English,,0,0,0,,And then we release the mutex on this on the byte_cnt the global byte_cnt variable
Dialogue: 0,0:41:09.74,0:41:12.46,English,,0,0,0,,And then we echo that line back to the client
Dialogue: 0,0:41:15.54,0:41:16.62,English,,0,0,0,,Okay so any questions about that
Dialogue: 0,0:41:18.00,0:41:18.62,English,,0,0,0,,Yes question
Dialogue: 0,0:41:18.62,0:41:28.26,English,,0,0,0,,[student speaking]
Dialogue: 0,0:41:28.28,0:41:33.16,English,,0,0,0,,Okay the question is the line that declares the static variable
Dialogue: 0,0:41:33.92,0:41:37.08,English,,0,0,0,,Once will it only be executed the first time
Dialogue: 0,0:41:38.08,0:41:41.44,English,,0,0,0,,A thread executes that statement
Dialogue: 0,0:41:41.84,0:41:46.62,English,,0,0,0,,No it's so the answer is no every thread will define this variable
Dialogue: 0,0:41:47.00,0:41:53.28,English,,0,0,0,,And assign it this to this pthread once value
Dialogue: 0,0:41:53.94,0:41:58.66,English,,0,0,0,,Okay what will only happen once is the call to a init_echo_cnt
Dialogue: 0,0:41:59.42,0:42:05.36,English,,0,0,0,,Okay so the first thread that executes this Pthread_once call
Dialogue: 0,0:42:05.92,0:42:08.20,English,,0,0,0,,Will actually call an init_echo_cnt
Dialogue: 0,0:42:09.44,0:42:13.58,English,,0,0,0,,Every other thread every subsequent thread will not call it it'll be like a no op
Dialogue: 0,0:42:14.84,0:42:18.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:18.54,0:42:20.80,English,,0,0,0,,Yeah uses the ones it's just an opaque
Dialogue: 0,0:42:20.86,0:42:33.44,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:33.46,0:42:39.54,English,,0,0,0,,Yeah somehow it will but somehow the pthread wants is keeping track that it's executed
Dialogue: 0,0:42:41.60,0:42:44.58,English,,0,0,0,,Okay so I I'm really not sure how its implemented
Dialogue: 0,0:42:45.18,0:42:48.54,English,,0,0,0,,Okay so somehow Pthread_once
Dialogue: 0,0:42:49.64,0:42:51.12,English,,0,0,0,,Yeah I guess every you know this
Dialogue: 0,0:42:52.02,0:42:54.70,English,,0,0,0,,I mean this is just the C declaration right so there's no
Dialogue: 0,0:42:55.14,0:42:59.00,English,,0,0,0,,The pthreads has no control over declarations right
Dialogue: 0,0:42:59.54,0:43:06.92,English,,0,0,0,,So every thread will get...every thread will sort of update this static variable
Dialogue: 0,0:43:08.72,0:43:10.76,English,,0,0,0,,And you're wright if the first thread
Dialogue: 0,0:43:14.68,0:43:18.18,English,,0,0,0,,The second thread would overwrite this value again
Dialogue: 0,0:43:19.02,0:43:23.50,English,,0,0,0,,But somehow Pthread_once can keeps track of that
Dialogue: 0,0:43:23.74,0:43:27.10,English,,0,0,0,,Okay in some way that I'm not sure about how that works
Dialogue: 0,0:43:28.56,0:43:31.62,English,,0,0,0,,But this is the way you get that behavior
Dialogue: 0,0:43:36.84,0:43:43.44,English,,0,0,0,,Can others there's some other issues around synchronizing threads sort of correctness issues that we have to be aware of
Dialogue: 0,0:43:45.66,0:43:51.56,English,,0,0,0,,And so I hope you're sort of getting the sense that this threaded programming is kind of a tricky business right
Dialogue: 0,0:43:52.36,0:43:57.50,English,,0,0,0,,And so one issue that we always have to be aware of is this idea called thread safety
Dialogue: 0,0:43:58.68,0:44:06.30,English,,0,0,0,,So in general a thread routine should only call functions that are thread safe
Dialogue: 0,0:44:06.76,0:44:08.66,English,,0,0,0,,That have this property called thread safety
Dialogue: 0,0:44:09.74,0:44:11.90,English,,0,0,0,,Okay and a function is thread safe
Dialogue: 0,0:44:13.00,0:44:18.76,English,,0,0,0,,If and only if that function can be invoked by multiple threads at the same time
Dialogue: 0,0:44:19.76,0:44:22.20,English,,0,0,0,,Okay so if we have a function f
Dialogue: 0,0:44:24.42,0:44:29.10,English,,0,0,0,,Its thread safe if and only if its execution can be interleaved by multiple threads
Dialogue: 0,0:44:34.70,0:44:38.96,English,,0,0,0,,And so we can identify a four different classes of thread-unsafe functions
Dialogue: 0,0:44:39.86,0:44:46.06,English,,0,0,0,,So one classes is the functions that fail to protect shared variables with mutexes
Dialogue: 0,0:44:48.22,0:44:50.06,English,,0,0,0,,Okay so we've already seen that with bad count
Dialogue: 0,0:44:50.66,0:44:56.06,English,,0,0,0,,That was an example of a thread-unsafe that main routine was an example of an unsafe thread function
Dialogue: 0,0:44:58.66,0:45:02.14,English,,0,0,0,,Or no the thread function was an example of an unsafe thread function
Dialogue: 0,0:45:02.40,0:45:06.24,English,,0,0,0,,Because it didn't protect the act the update of the count variable
Dialogue: 0,0:45:09.04,0:45:16.90,English,,0,0,0,,Another class of functions that a thread-unsafe is are those functions that keep track of state across multiple invocations
Dialogue: 0,0:45:17.74,0:45:26.14,English,,0,0,0,,So if they're storing state in some global variable,private or public global variable, that's thread unsafe
Dialogue: 0,0:45:26.80,0:45:30.94,English,,0,0,0,,Because multiple threads will be accessing that state
Dialogue: 0,0:45:33.44,0:45:38.74,English,,0,0,0,,Another way,another kind of thread-unsafe function or functions that return a pointer to a static variable
Dialogue: 0,0:45:40.22,0:45:43.34,English,,0,0,0,,So there's a number of functions in the standard C library
Dialogue: 0,0:45:44.04,0:45:47.52,English,,0,0,0,,That were written before threads or even on anybody's radar
Dialogue: 0,0:45:48.86,0:45:53.06,English,,0,0,0,,And so an example is the C time function
Dialogue: 0,0:45:53.82,0:45:57.94,English,,0,0,0,,Which takes as an argument a time struct,a binary time struct
Dialogue: 0,0:45:58.92,0:46:02.52,English,,0,0,0,,And returns a pointer to a string date and time string
Dialogue: 0,0:46:04.18,0:46:07.46,English,,0,0,0,,But the address in that pointer is always the same
Dialogue: 0,0:46:07.62,0:46:11.52,English,,0,0,0,,Right so the this function is defining some kind of static variable
Dialogue: 0,0:46:12.48,0:46:18.00,English,,0,0,0,,And it's always returned and then it's converting that the binary time struct
Dialogue: 0,0:46:18.94,0:46:24.22,English,,0,0,0,,Into a string that's always at the same location and it's returning the address of that string
Dialogue: 0,0:46:24.86,0:46:27.64,English,,0,0,0,,So every invocation returns the exact same address
Dialogue: 0,0:46:28.52,0:46:30.74,English,,0,0,0,,But with different content at that address
Dialogue: 0,0:46:31.76,0:46:36.46,English,,0,0,0,,Okay and this...you know they just...they didn't realize that this was a bad thing to do
Dialogue: 0,0:46:36.72,0:46:40.66,English,,0,0,0,,For threaded programs because nobody was writing threaded programs at the time
Dialogue: 0,0:46:42.26,0:46:46.82,English,,0,0,0,,And then obviously any function that calls and thread-unsafe function is threat unsafe
Dialogue: 0,0:46:47.94,0:46:51.50,English,,0,0,0,,Okay so let's look at these different classes of functions
Dialogue: 0,0:46:52.14,0:46:56.32,English,,0,0,0,,Okay so the class one functions fail to protect shared variables
Dialogue: 0,0:46:57.18,0:47:04.90,English,,0,0,0,,And so the fix as we've seen is to use P and V to guarantee mutually exclusive access and thereby protect the accesses to the variable
Dialogue: 0,0:47:05.02,0:47:07.56,English,,0,0,0,,So we saw this with that good count program
Dialogue: 0,0:47:08.50,0:47:14.18,English,,0,0,0,,And then the problem is it also as we saw with goodcnt is that the synchronization operations can be slow
Dialogue: 0,0:47:14.20,0:47:15.75,English,,0,0,0,,So if they're in a tight inner loop
Dialogue: 0,0:47:16.38,0:47:18.68,English,,0,0,0,,It can really slow your program down
Dialogue: 0,0:47:21.42,0:47:25.32,English,,0,0,0,,Okay the class 2 thread-unsafe functions rely on
Dialogue: 0,0:47:25.66,0:47:29.56,English,,0,0,0,,Some kind of persistent state across invocations of that function
Dialogue: 0,0:47:30.32,0:47:35.28,English,,0,0,0,,Okay so the classic example is the lib.c rand function
Dialogue: 0,0:47:36.54,0:47:43.68,English,,0,0,0,,Whose in an implementation of which is I took from the k in our book
Dialogue: 0,0:47:45.82,0:47:52.36,English,,0,0,0,,So this rand,this is a pseudo-random number generator
Dialogue: 0,0:47:53.22,0:47:55.32,English,,0,0,0,,A pseudo random in the sense that
Dialogue: 0,0:47:56.08,0:48:00.84,English,,0,0,0,,If you give it the same key it'll return the same sequence of values okay
Dialogue: 0,0:48:01.60,0:48:06.60,English,,0,0,0,,So this is kind of nice because it allows when you're testing it allows repeatability
Dialogue: 0,0:48:07.38,0:48:12.22,English,,0,0,0,,So every time you call it,if you call it with the same seed you're guaranteed you'll get the same results
Dialogue: 0,0:48:13.48,0:48:14.86,English,,0,0,0,,And the way this is implemented
Dialogue: 0,0:48:16.92,0:48:19.66,English,,0,0,0,,Is that there's at the seed
Dialogue: 0,0:48:22.40,0:48:24.90,English,,0,0,0,,There's a seed variable called next
Dialogue: 0,0:48:25.44,0:48:28.60,English,,0,0,0,,Which is used in each iteration of the random number generator
Dialogue: 0,0:48:28.68,0:48:33.82,English,,0,0,0,,And it's defined as a global private
Dialogue: 0,0:48:33.96,0:48:38.58,English,,0,0,0,,So static makes it private,so it's not accessible to programs that are calling
Dialogue: 0,0:48:39.22,0:48:42.92,English,,0,0,0,,The rand function but it's used by the rand function
Dialogue: 0,0:48:43.70,0:48:45.94,English,,0,0,0,,And so this variable is initialized to 1
Dialogue: 0,0:48:48.20,0:48:52.76,English,,0,0,0,,There's a function called srand which allows the user to set the seed value
Dialogue: 0,0:48:52.82,0:48:55.64,English,,0,0,0,,So the default seed value is 1
Dialogue: 0,0:48:56.48,0:48:59.48,English,,0,0,0,,But if the user calls srand they can pass in a seed
Dialogue: 0,0:48:59.86,0:49:05.34,English,,0,0,0,,Which will be then...which will be...which is just would assign to this next variable
Dialogue: 0,0:49:06.78,0:49:08.58,English,,0,0,0,,And then each iteration of rand
Dialogue: 0,0:49:10.48,0:49:12.52,English,,0,0,0,,And does an operation on the seed
Dialogue: 0,0:49:13.50,0:49:21.54,English,,0,0,0,,So it takes that the next value that's going to be used is a property of the previous value,the function of the previous value
Dialogue: 0,0:49:22.58,0:49:24.74,English,,0,0,0,,And then it returns a pseudo-random number
Dialogue: 0,0:49:25.08,0:49:26.88,English,,0,0,0,,That's a function of that next value
Dialogue: 0,0:49:28.60,0:49:32.74,English,,0,0,0,,Okay so it's relying on this each iteration each time you call rand
Dialogue: 0,0:49:33.16,0:49:39.48,English,,0,0,0,,You're relying on the this next value that was computed by the previous time that you called rand
Dialogue: 0,0:49:41.28,0:49:44.30,English,,0,0,0,,Okay now this is perfectly fine and there's no problem with this
Dialogue: 0,0:49:44.70,0:49:47.46,English,,0,0,0,,In a non-threaded situation
Dialogue: 0,0:49:48.26,0:49:50.56,English,,0,0,0,,But what happens if multiple threads now
Dialogue: 0,0:49:51.44,0:49:53.06,English,,0,0,0,,So suppose you have multiple threads
Dialogue: 0,0:49:54.06,0:50:01.08,English,,0,0,0,,And they're each calling this rand function sort of interleaving calls to rand
Dialogue: 0,0:50:02.52,0:50:07.94,English,,0,0,0,,Okay the fact that rand is relying on the this previous state
Dialogue: 0,0:50:10.40,0:50:14.26,English,,0,0,0,,If multiple threads are calling rand it's going to break the pseudo-random property
Dialogue: 0,0:50:14.58,0:50:19.78,English,,0,0,0,,So each thread that the random numbers that each thread gets back
Dialogue: 0,0:50:19.78,0:50:26.04,English,,0,0,0,,Are not only a function of the previous the seed from the previous time that thread called the function
Dialogue: 0,0:50:26.04,0:50:31.98,English,,0,0,0,,But also a function of the other threads that are calling it right
Dialogue: 0,0:50:32.90,0:50:38.40,English,,0,0,0,,So if a particular thread calls this random number generator multiple times
Dialogue: 0,0:50:39.28,0:50:44.72,English,,0,0,0,,It potentially won't see the same sequence of pseudo-random numbers because other threads will be jumping in
Dialogue: 0,0:50:45.42,0:50:46.78,English,,0,0,0,,Okay and
Dialogue: 0,0:50:48.88,0:50:55.08,English,,0,0,0,,Okay so it's not incorrect and that the program will fail
Dialogue: 0,0:50:55.34,0:51:01.22,English,,0,0,0,,But if the program is counting on the pseudo random property then it creates a problem okay
Dialogue: 0,0:51:02.66,0:51:07.66,English,,0,0,0,,So the solution to this is to rewrite rand
Dialogue: 0,0:51:08.80,0:51:15.16,English,,0,0,0,,And require it to require the caller to keep track of this next variable
Dialogue: 0,0:51:15.70,0:51:21.68,English,,0,0,0,,Okay so each caller will keep its own local copy of next and it will pass in a pointer to rand
Dialogue: 0,0:51:22.84,0:51:28.28,English,,0,0,0,,rand we'll compute that value so now this will be updating state in the calling thread
Dialogue: 0,0:51:28.30,0:51:32.66,English,,0,0,0,,But this is local state on the thread stack okay
Dialogue: 0,0:51:32.82,0:51:37.16,English,,0,0,0,,So every thread will have its own copy of next
Dialogue: 0,0:51:40.14,0:51:44.32,English,,0,0,0,,So we...but we have to create a new function and what we'll call it underscore r
Dialogue: 0,0:51:44.76,0:51:48.54,English,,0,0,0,,The stands for reentrant which is a property we'll look at in just a second
Dialogue: 0,0:51:50.56,0:51:54.06,English,,0,0,0,,But it's more work for the programmer because now the programmer has to maintain this
Dialogue: 0,0:51:54.76,0:51:58.10,English,,0,0,0,,This sort of this next value okay
Dialogue: 0,0:52:01.68,0:52:05.08,English,,0,0,0,,Okay another way that threads the functions are unsafe
Dialogue: 0,0:52:06.08,0:52:14.52,English,,0,0,0,,are these functions that always retain a return a pointer(to some global) to the same global variable
Dialogue: 0,0:52:15.02,0:52:17.18,English,,0,0,0,,Typically it's a static variable
Dialogue: 0,0:52:17.60,0:52:22.36,English,,0,0,0,,But they always return the same value each time the same address
Dialogue: 0,0:52:24.36,0:52:27.90,English,,0,0,0,,Okay so you can see this is similar to that race that we encountered before
Dialogue: 0,0:52:28.20,0:52:32.64,English,,0,0,0,,Where we were passing the address of a connected file descriptor to a worker thread
Dialogue: 0,0:52:34.50,0:52:36.90,English,,0,0,0,,Okay so now we're creating a race so let's say one thread
Dialogue: 0,0:52:37.42,0:52:40.68,English,,0,0,0,,Let's say one thread calls this function so for example
Dialogue: 0,0:52:41.66,0:52:46.06,English,,0,0,0,,ctime takes this this time struct as an argument
Dialogue: 0,0:52:46.74,0:52:50.22,English,,0,0,0,,Okay which can correspond to an arbitrary time it could be the current time
Dialogue: 0,0:52:50.22,0:52:53.20,English,,0,0,0,,Or just some arbitrary time that the caller constructed
Dialogue: 0,0:52:54.26,0:52:58.28,English,,0,0,0,,And it returns a pointer to a char*
Dialogue: 0,0:52:58.30,0:53:02.66,English,,0,0,0,,So it just returns a pointer to a string that represents the date and the time
Dialogue: 0,0:53:02.76,0:53:09.16,English,,0,0,0,,Its own ascii string that represents the date and time
Dialogue: 0,0:53:12.58,0:53:19.34,English,,0,0,0,,But it's always returning a pointer to the same location in memory
Dialogue: 0,0:53:21.98,0:53:26.02,English,,0,0,0,,Okay so you can see the problem if thread a calls this ctime function
Dialogue: 0,0:53:27.20,0:53:29.42,English,,0,0,0,,With one...with one time struck
Dialogue: 0,0:53:30.30,0:53:35.98,English,,0,0,0,,It gets back a pointer to the character string corresponding to that time struct
Dialogue: 0,0:53:37.04,0:53:39.94,English,,0,0,0,,But now let's say before thread a can use that
Dialogue: 0,0:53:41.30,0:53:45.06,English,,0,0,0,,Read that string another thread calls ctime
Dialogue: 0,0:53:46.84,0:53:55.40,English,,0,0,0,,And that instance of ctime will overwrite that copy of the time string for that that thread a computed
Dialogue: 0,0:53:56.34,0:53:58.68,English,,0,0,0,,So when thread a finally gets a chance to access
Dialogue: 0,0:53:59.48,0:54:04.70,English,,0,0,0,,That time string its accessing thread b time string and not threat a time string
Dialogue: 0,0:54:06.08,0:54:11.28,English,,0,0,0,,Okay and it just depends if thread a can get to that and read that variable before thread b
Dialogue: 0,0:54:12.00,0:54:13.96,English,,0,0,0,,Over writes it then everything's fine
Dialogue: 0,0:54:14.58,0:54:18.34,English,,0,0,0,,And otherwise threat a accessing the wrong time string
Dialogue: 0,0:54:19.06,0:54:22.48,English,,0,0,0,,Okay so there's there's a couple of ways to fix this like
Dialogue: 0,0:54:23.24,0:54:27.05,English,,0,0,0,,We could rewrite the the function the ctime function to take
Dialogue: 0,0:54:27.70,0:54:31.90,English,,0,0,0,,As another argument that passes in
Dialogue: 0,0:54:34.78,0:54:37.36,English,,0,0,0,,The location the address of the time string
Dialogue: 0,0:54:37.40,0:54:44.70,English,,0,0,0,,So we could require the caller to allocate space for the time string and passing the address to the ctime function
Dialogue: 0,0:54:45.88,0:54:51.16,English,,0,0,0,,Okay but this has...this would require us to change all the instances
Dialogue: 0,0:54:52.34,0:54:53.54,English,,0,0,0,,Where we call ctime
Dialogue: 0,0:54:55.18,0:55:01.12,English,,0,0,0,,But we'd also have to change the implementation of ctime in the lib.c in the library
Dialogue: 0,0:55:03.02,0:55:08.80,English,,0,0,0,,Right and so we can't...we don't have access to lib.c source on our system
Dialogue: 0,0:55:08.82,0:55:13.23,English,,0,0,0,,Right so that's just not a feasible thing plus it would break every other program
Dialogue: 0,0:55:13.70,0:55:16.18,English,,0,0,0,,That called ctime right so we just can't do
Dialogue: 0,0:55:18.26,0:55:22.98,English,,0,0,0,,That the another option a better option is to create a new function of our own
Dialogue: 0,0:55:24.18,0:55:28.32,English,,0,0,0,,Okay called ctime_ts for thread safe
Dialogue: 0,0:55:28.44,0:55:33.26,English,,0,0,0,,So we'll create our own sort of wrapper function for it for the ctime
Dialogue: 0,0:55:35.08,0:55:43.48,English,,0,0,0,,And we'll use a technique called lock and copy to provide thread safe access to ctime
Dialogue: 0,0:55:44.64,0:55:49.52,English,,0,0,0,,So the way it works is it will write this new function ctime_ts
Dialogue: 0,0:55:50.42,0:55:55.36,English,,0,0,0,,Which just like ctime takes this a pointer to this time struct
Dialogue: 0,0:55:55.98,0:55:57.66,English,,0,0,0,,But then it adds a second argument
Dialogue: 0,0:55:59.16,0:56:04.92,English,,0,0,0,,Which is a pointer to the threat of threads private copy of the time string
Dialogue: 0,0:56:06.66,0:56:15.32,English,,0,0,0,,Okay so the caller allocates the space and passes the pointer to this to that to that string
Dialogue: 0,0:56:17.52,0:56:22.58,English,,0,0,0,,And then within ctime we have a local variable called the shared pointer
Dialogue: 0,0:56:23.32,0:56:29.76,English,,0,0,0,,Okay so this is going to point to that sharred global data structure that ctime is accessing
Dialogue: 0,0:56:31.72,0:56:36.72,English,,0,0,0,,And so first we do the lock that's the lock part of lock and copy by acquiring a mutex
Dialogue: 0,0:56:38.78,0:56:40.46,English,,0,0,0,,And then we call ctime
Dialogue: 0,0:56:42.42,0:56:44.80,English,,0,0,0,,So only one thread at a time we'll have this mutex
Dialogue: 0,0:56:44.94,0:56:48.16,English,,0,0,0,,So whatever thread...so once we return from p
Dialogue: 0,0:56:48.54,0:56:52.80,English,,0,0,0,,We know that we're the only thread in this critical section
Dialogue: 0,0:56:53.78,0:56:57.46,English,,0,0,0,,So we call ctime the normal lib.c ctime function
Dialogue: 0,0:56:58.28,0:57:02.10,English,,0,0,0,,Which returns a pointer to this to the same location
Dialogue: 0,0:57:03.46,0:57:06.98,English,,0,0,0,,And then we do the copy part we copy that string
Dialogue: 0,0:57:08.92,0:57:13.78,English,,0,0,0,,To the private string that was passed in just into a function
Dialogue: 0,0:57:15.40,0:57:18.04,English,,0,0,0,,Once we've done the copy then we can release the mutex
Dialogue: 0,0:57:18.56,0:57:20.22,English,,0,0,0,,And then we return a pointer
Dialogue: 0,0:57:21.68,0:57:27.86,English,,0,0,0,,We return privatep back to the caller right ok so
Dialogue: 0,0:57:30.16,0:57:34.20,English,,0,0,0,,And we don't this is just more of a convenience to the caller
Dialogue: 0,0:57:34.40,0:57:38.66,English,,0,0,0,,Because programs that are using ctime are expecting to get that pointer back
Dialogue: 0,0:57:39.46,0:57:41.48,English,,0,0,0,,Ok so by using lock and copy
Dialogue: 0,0:57:42.14,0:57:46.34,English,,0,0,0,,We have to make changes,we have to write this new function but it's fairly simple
Dialogue: 0,0:57:47.60,0:57:52.76,English,,0,0,0,,And then we have to make changes every place in our program where we call ctime
Dialogue: 0,0:57:52.76,0:57:56.28,English,,0,0,0,,We have to update those to calls to ctime_ts
Dialogue: 0,0:57:56.92,0:58:02.72,English,,0,0,0,,And create this local string array
Dialogue: 0,0:58:03.46,0:58:04.26,English,,0,0,0,,Ok yes
Dialogue: 0,0:58:04.66,0:58:18.02,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:21.04,0:58:24.56,English,,0,0,0,,Well typically these functions are returning pointers to some data structure
Dialogue: 0,0:58:25.00,0:58:30.22,English,,0,0,0,,And so they're sort of updating the data structure and then returning a pointer to it so
Dialogue: 0,0:58:32.10,0:58:33.82,English,,0,0,0,,It wouldn't makes,I don't know how
Dialogue: 0,0:58:34.58,0:58:37.64,English,,0,0,0,,I guess it could return a struct and it would always return
Dialogue: 0,0:58:38.60,0:58:39.28,English,,0,0,0,,Now now
Dialogue: 0,0:58:43.52,0:58:48.16,English,,0,0,0,,I can't think of any...I can't think of any reason why they would turn anything but a pointer
Dialogue: 0,0:58:48.62,0:58:52.72,English,,0,0,0,,Because they're typically updating some data structure
Dialogue: 0,0:58:53.30,0:58:54.76,English,,0,0,0,,And then returning a pointer to it
Dialogue: 0,0:59:02.18,0:59:03.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:06.18,0:59:07.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:08.98,0:59:13.04,English,,0,0,0,,Scalars those scalars would always be returned in %eax or %rax
Dialogue: 0,0:59:13.84,0:59:16.32,English,,0,0,0,,All right so actually that would be okay right it would just be
Dialogue: 0,0:59:17.06,0:59:19.16,English,,0,0,0,,It's the pointer that causes a problem because
Dialogue: 0,0:59:20.32,0:59:23.00,English,,0,0,0,,It's always returning that value in %eax
Dialogue: 0,0:59:23.00,0:59:30.56,English,,0,0,0,,But it's always returning the same value in %eax always pointing to the same data structure okay good
Dialogue: 0,0:59:34.52,0:59:35.48,English,,0,0,0,,Okay now one...
Dialogue: 0,0:59:37.58,0:59:41.98,English,,0,0,0,,One potentially significant disadvantage of lock and copy is that
Dialogue: 0,0:59:43.24,0:59:49.06,English,,0,0,0,,This copy might not always be as simple as just doing like a strcpy,if
Dialogue: 0,0:59:50.02,0:59:56.62,English,,0,0,0,,If it's a complex diff...if the function that you're calling is computing some complex data structure like a nested
Dialogue: 0,0:59:57.26,1:00:00.40,English,,0,0,0,,You know a struct which contains structs and pointers to arrays
Dialogue: 0,1:00:01.28,1:00:04.66,English,,0,0,0,,Then this copy can get quite complicated right
Dialogue: 0,1:00:05.10,1:00:07.06,English,,0,0,0,,It would require what we call a deep copy
Dialogue: 0,1:00:08.20,1:00:10.50,English,,0,0,0,,So that can be that can be very difficult to
Dialogue: 0,1:00:11.16,1:00:15.84,English,,0,0,0,,But in this case it's simple we're just copying one string to another
Dialogue: 0,1:00:17.44,1:00:25.06,English,,0,0,0,,Okay and then finally the 4 class of thread-unsafe functions are functions that call unsafe functions right
Dialogue: 0,1:00:25.08,1:00:26.20,English,,0,0,0,,So it's kind of obvious
Dialogue: 0,1:00:27.04,1:00:32.16,English,,0,0,0,,And then the obvious fix is to not call thread-unsafe functions from within your function
Dialogue: 0,1:00:32.76,1:00:34.04,English,,0,0,0,,And then you can make it thread safe
Dialogue: 0,1:00:37.10,1:00:44.34,English,,0,0,0,,Now there's a very interesting an important subclass of thread-safe functions called reentrant functions
Dialogue: 0,1:00:45.76,1:00:49.20,English,,0,0,0,,So a reentrant a function is reentrant
Dialogue: 0,1:00:50.22,1:00:53.82,English,,0,0,0,,If it contains no accesses to shared to shared variables
Dialogue: 0,1:00:54.72,1:00:59.14,English,,0,0,0,,Okay so if all the...every variable that it accesses is
Dialogue: 0,1:00:59.56,1:01:06.94,English,,0,0,0,,Contained on the is declared as a local variable and stored on the stack for that function
Dialogue: 0,1:01:07.68,1:01:09.30,English,,0,0,0,,Okay that's called a reentrant function
Dialogue: 0,1:01:10.10,1:01:13.38,English,,0,0,0,,And because there's no accesses of any kind to shared variables
Dialogue: 0,1:01:14.10,1:01:17.10,English,,0,0,0,,There's no synchronization required
Dialogue: 0,1:01:17.10,1:01:22.14,English,,0,0,0,,Because every function is operating accessing its own local copy of all the variables
Dialogue: 0,1:01:23.90,1:01:29.58,English,,0,0,0,,And if multiple threads execute two instances of a reentrant function
Dialogue: 0,1:01:30.62,1:01:33.16,English,,0,0,0,,It's okay each thread has its own separate stack
Dialogue: 0,1:01:33.80,1:01:39.56,English,,0,0,0,,So you don't need to worry about any kind of synchronization they can run independently
Dialogue: 0,1:01:40.12,1:01:45.76,English,,0,0,0,,So the reason reentrant functions are so important is because it's expensive to do synchronization
Dialogue: 0,1:01:47.10,1:01:51.46,English,,0,0,0,,And so what you can avoid it completely with these reentrant function reentrant functions
Dialogue: 0,1:01:51.48,1:01:52.48,English,,0,0,0,,So they're efficient
Dialogue: 0,1:01:57.52,1:02:01.24,English,,0,0,0,,So as that as the diagram shows every reentrant function is thread safe
Dialogue: 0,1:02:01.96,1:02:04.52,English,,0,0,0,,But not every thread safe function is reentrant
Dialogue: 0,1:02:07.48,1:02:11.92,English,,0,0,0,,So we saw that before right when we have a function that accesses a shared variable
Dialogue: 0,1:02:12.48,1:02:15.90,English,,0,0,0,,We can make it thread safe by protecting it with a mutex
Dialogue: 0,1:02:17.98,1:02:21.62,English,,0,0,0,,Okay but it's not reentrant,because it's accessing shared variables okay
Dialogue: 0,1:02:28.30,1:02:34.74,English,,0,0,0,,Now on all the functions in the standard C library which are enumerated in the back of your k and r texture thread-safe
Dialogue: 0,1:02:35.66,1:02:37.60,English,,0,0,0,,Okay but not necessarily reentrant
Dialogue: 0,1:02:39.36,1:02:44.20,English,,0,0,0,,And most most syscalls are thread safe with a few exceptions that I've listed here
Dialogue: 0,1:02:44.98,1:02:47.74,English,,0,0,0,,I don't think I don't think this is complete
Dialogue: 0,1:02:47.76,1:02:50.44,English,,0,0,0,,But these are just some examples of some notable ones
Dialogue: 0,1:02:51.74,1:02:55.22,English,,0,0,0,,And so for each of these thread unsafe functions
Dialogue: 0,1:02:57.30,1:02:59.92,English,,0,0,0,,Linux provides a reentrant version
Dialogue: 0,1:03:00.66,1:03:02.88,English,,0,0,0,,Which is denoted by _r
Dialogue: 0,1:03:03.76,1:03:08.40,English,,0,0,0,,And then that reentrant version has a different set of parameters typically
Dialogue: 0,1:03:10.08,1:03:19.90,English,,0,0,0,,The only exception that I know about is inet_ntoa which is an episode of an obsolete network protocol for converting
Dialogue: 0,1:03:20.86,1:03:25.14,English,,0,0,0,,Sort of binary network addresses to human readable ascii addresses
Dialogue: 0,1:03:25.66,1:03:30.48,English,,0,0,0,,But this is ops been obsoleted by other calls
Dialogue: 0,1:03:30.48,1:03:36.02,English,,0,0,0,,So it's I guess they just never bothered to create a reentrant version for it
Dialogue: 0,1:03:36.38,1:03:38.96,English,,0,0,0,,Because there's other options alternatives to using that
Dialogue: 0,1:03:41.28,1:03:45.10,English,,0,0,0,,Okay so another thing we have to worry about is we've seen is races
Dialogue: 0,1:03:46.16,1:03:49.42,English,,0,0,0,,Again this is the real bugaboo in threaded programs
Dialogue: 0,1:03:50.58,1:03:53.82,English,,0,0,0,,And it typically involves some kind of unexpected sharing
Dialogue: 0,1:03:54.62,1:03:57.24,English,,0,0,0,,So in this case I'm going to revisit this
Dialogue: 0,1:03:58.12,1:04:02.16,English,,0,0,0,,This incorrect threaded program
Dialogue: 0,1:04:03.14,1:04:07.38,English,,0,0,0,,That where we introduce introduced a race by passing when we create the thread
Dialogue: 0,1:04:08.74,1:04:13.02,English,,0,0,0,,We pass the argument to the thread which is like the local thread id
Dialogue: 0,1:04:14.30,1:04:19.18,English,,0,0,0,,We pass an address of a variable that we have stored on the stack
Dialogue: 0,1:04:19.92,1:04:23.66,English,,0,0,0,,And int i that the loop iterator
Dialogue: 0,1:04:26.00,1:04:26.68,English,,0,0,0,,And so
Dialogue: 0,1:04:29.82,1:04:33.92,English,,0,0,0,,We've seen that this causes this causes a race so
Dialogue: 0,1:04:35.74,1:04:41.26,English,,0,0,0,,We incurred...we set initially i is 0, then we create a new thread which is peer thread 0
Dialogue: 0,1:04:42.14,1:04:51.08,English,,0,0,0,,And then this thread dereferences the pointer to get its local copy of the this sort of local thread id
Dialogue: 0,1:04:53.26,1:04:54.86,English,,0,0,0,,But now we've introduced the race
Dialogue: 0,1:04:56.88,1:04:58.52,English,,0,0,0,,Between the increment of i
Dialogue: 0,1:05:00.50,1:05:04.86,English,,0,0,0,,And the dereferencing of the incrementing of i and the main thread
Dialogue: 0,1:05:05.30,1:05:08.00,English,,0,0,0,,And the dereferencing of i in the peer thread
Dialogue: 0,1:05:09.12,1:05:13.42,English,,0,0,0,,So if this dereferencing happens before i is incremented then we're good
Dialogue: 0,1:05:14.68,1:05:17.26,English,,0,0,0,,But if this dereferencing happens after
Dialogue: 0,1:05:18.08,1:05:20.96,English,,0,0,0,,We increment i so in other words at when i equal 1
Dialogue: 0,1:05:22.44,1:05:26.94,English,,0,0,0,,Then we get the wrong value in the peer thread for myid
Dialogue: 0,1:05:30.46,1:05:32.96,English,,0,0,0,,So you might wonder I think there was a question before about
Dialogue: 0,1:05:33.98,1:05:39.24,English,,0,0,0,,You know this seems that the odds of this happening seems so low why why are you even worrying about it
Dialogue: 0,1:05:40.66,1:05:46.60,English,,0,0,0,,So we actually create just to sort of test this out we wrote a program to see if we could
Dialogue: 0,1:05:47.78,1:05:52.60,English,,0,0,0,,See if we could actually see this race in practice
Dialogue: 0,1:05:53.68,1:05:58.22,English,,0,0,0,,And that's one of the great things about like 213 is that you we can just try stuff out right so
Dialogue: 0,1:05:58.94,1:05:59.94,English,,0,0,0,,So we just tried it out
Dialogue: 0,1:06:01.94,1:06:07.90,English,,0,0,0,,So we wrote a simple main thread that creates a hundred different threads
Dialogue: 0,1:06:08.76,1:06:15.54,English,,0,0,0,,Each with then we passed the art as the argument we passed the address of this local variable i okay
Dialogue: 0,1:06:17.76,1:06:21.34,English,,0,0,0,,And then in each peer thread we detach the thread dereference
Dialogue: 0,1:06:22.06,1:06:25.46,English,,0,0,0,,And then we have a function that saves the value so we're we're storing
Dialogue: 0,1:06:27.14,1:06:31.86,English,,0,0,0,,We're storing that value of i for future reference
Dialogue: 0,1:06:33.90,1:06:35.36,English,,0,0,0,,Okay so now if there's no race
Dialogue: 0,1:06:36.52,1:06:40.74,English,,0,0,0,,Each of the 100 threads would get a separate distinct thread id
Dialogue: 0,1:06:40.98,1:06:43.72,English,,0,0,0,,Right so each value 0 through 99
Dialogue: 0,1:06:44.16,1:06:45.60,English,,0,0,0,,If we made a histogram of it
Dialogue: 0,1:06:46.34,1:06:50.72,English,,0,0,0,,There would be exactly one instance of each value of i
Dialogue: 0,1:06:52.42,1:06:56.54,English,,0,0,0,,Okay but if there was a race there would be for some values of i
Dialogue: 0,1:06:56.54,1:06:59.56,English,,0,0,0,,There would be multiple instances that were encountered in multiple threads
Dialogue: 0,1:07:00.76,1:07:02.64,English,,0,0,0,,Okay so you can see if we go back here
Dialogue: 0,1:07:04.02,1:07:11.62,English,,0,0,0,,If we lose if the peer thread loses the race and I gets incremented before it can dereference
Dialogue: 0,1:07:15.28,1:07:22.08,English,,0,0,0,,Now we've got peer thread 0 actually gets an id of one
Dialogue: 0,1:07:25.70,1:07:27.52,English,,0,0,0,,Okay and then peer thread one
Dialogue: 0,1:07:28.32,1:07:34.24,English,,0,0,0,,If there's no race it'll get the correct value of one so now we've got two instances of one okay
Dialogue: 0,1:07:36.86,1:07:38.36,English,,0,0,0,,So let's look so this is the case
Dialogue: 0,1:07:40.48,1:07:45.58,English,,0,0,0,,So we've plotted the results for a case where there's no race so along the x-axis sorry this is too small
Dialogue: 0,1:07:46.18,1:07:51.20,English,,0,0,0,,The x-axis gives us all the 100 values of i,0 through 99
Dialogue: 0,1:07:51.72,1:08:00.12,English,,0,0,0,,And then the y-axis is the count so this is a hit we're doing a histogram for these all the values 0 through 99
Dialogue: 0,1:08:01.22,1:08:05.46,English,,0,0,0,,So in this case every value has exactly one instance so no race
Dialogue: 0,1:08:06.26,1:08:14.64,English,,0,0,0,,There was no races in involved in all 99 are all 100 instances
Dialogue: 0,1:08:16.52,1:08:18.22,English,,0,0,0,,If we run it on a single core laptop
Dialogue: 0,1:08:18.30,1:08:22.08,English,,0,0,0,,So now each thread is sort of taking its turn on a single core
Dialogue: 0,1:08:24.06,1:08:27.40,English,,0,0,0,,It happens a few times right so there's a few times where
Dialogue: 0,1:08:28.18,1:08:31.50,English,,0,0,0,,The one thread gets preempted and the other thread
Dialogue: 0,1:08:31.98,1:08:33.24,English,,0,0,0,,Begins to run
Dialogue: 0,1:08:35.84,1:08:36.78,English,,0,0,0,,Before it can...
Dialogue: 0,1:08:36.92,1:08:41.74,English,,0,0,0,,So the peers when one thread gets preempted before I can dereference the variable
Dialogue: 0,1:08:41.74,1:08:44.10,English,,0,0,0,,So it gets the wrong the wrong value
Dialogue: 0,1:08:44.40,1:08:50.38,English,,0,0,0,,But it's not very common it just it happened 1,2,3,4,5,6,7 times
Dialogue: 0,1:08:51.46,1:08:54.76,English,,0,0,0,,But now if we run this program on a multi-core server
Dialogue: 0,1:08:55.48,1:08:58.30,English,,0,0,0,,You can see it happens a lot in fact it happens most of the time
Dialogue: 0,1:08:58.68,1:09:04.60,English,,0,0,0,,So it almost never get the correct value for for myid
Dialogue: 0,1:09:06.80,1:09:11.38,English,,0,0,0,,Okay so this is just another example of some of the create the things that can just drive you crazy
Dialogue: 0,1:09:12.04,1:09:15.78,English,,0,0,0,,If you're not careful when you program is and threads with threads
Dialogue: 0,1:09:18.36,1:09:24.82,English,,0,0,0,,Okay and as so as we saw the the way to eliminate these kind of erases  is to avoid
Dialogue: 0,1:09:25.82,1:09:30.06,English,,0,0,0,,This the sharing of state and in this case by allocating
Dialogue: 0,1:09:31.08,1:09:35.31,English,,0,0,0,,For each thread allocating a separate block in the heap
Dialogue: 0,1:09:35.68,1:09:40.44,English,,0,0,0,,That will hold the local id for that thread
Dialogue: 0,1:09:40.88,1:09:47.60,English,,0,0,0,,And then passing a pointer to that unique block of storage to the thread
Dialogue: 0,1:09:51.16,1:09:54.14,English,,0,0,0,,Okay so if that if all of that isn't enough to worry about
Dialogue: 0,1:09:55.58,1:09:57.22,English,,0,0,0,,And by now you should be losing sleep
Dialogue: 0,1:09:58.60,1:10:01.42,English,,0,0,0,,At the very thought of writing a threaded program
Dialogue: 0,1:10:02.02,1:10:04.10,English,,0,0,0,,Another thing to worry about is deadlock
Dialogue: 0,1:10:06.70,1:10:13.56,English,,0,0,0,,Okay so here a program is deadlocked if it's waiting for some condition to occur that will never occur
Dialogue: 0,1:10:18.16,1:10:21.28,English,,0,0,0,,Okay so let's say a typical scenario right p
Dialogue: 0,1:10:22.30,1:10:26.16,English,,0,0,0,,p is the potential the p operation is a potential problem because it blocks
Dialogue: 0,1:10:27.64,1:10:31.70,English,,0,0,0,,Right and it's waiting for that semaphore that it's blocking on to become nonzero
Dialogue: 0,1:10:33.84,1:10:36.94,English,,0,0,0,,Well it's not too hard to imagine scenarios where
Dialogue: 0,1:10:37.96,1:10:44.38,English,,0,0,0,,Some there's some combination of pees of pee operations that sort of block each other
Dialogue: 0,1:10:44.92,1:10:49.00,English,,0,0,0,,Okay and make it impossible for the condition they're waiting on to occur
Dialogue: 0,1:10:49.98,1:10:54.44,English,,0,0,0,,So for example let's say you've got two threads
Dialogue: 0,1:10:55.08,1:10:58.56,English,,0,0,0,,That need two threads one and two
Dialogue: 0,1:10:59.22,1:11:03.18,English,,0,0,0,,That need two different resources A and B in order to proceed
Dialogue: 0,1:11:03.18,1:11:06.88,English,,0,0,0,,So they have to acquire they have to do a pee on the mutex
Dialogue: 0,1:11:07.00,1:11:10.76,English,,0,0,0,,That on the mutex that that's associated with
Dialogue: 0,1:11:12.16,1:11:14.92,English,,0,0,0,,The mutexes that are associated with these two resources
Dialogue: 0,1:11:16.64,1:11:22.32,English,,0,0,0,,So let's say process one acquires A so it does a pee on A mutex
Dialogue: 0,1:11:23.94,1:11:28.50,English,,0,0,0,,That's one ,it's okay,so it acquires that resource
Dialogue: 0,1:11:30.04,1:11:33.38,English,,0,0,0,,And then it gets preempted by thread 2
Dialogue: 0,1:11:34.06,1:11:35.28,English,,0,0,0,,Which acquires B
Dialogue: 0,1:11:36.74,1:11:41.14,English,,0,0,0,,First instead of acquiring A thread B for some reason acquires B
Dialogue: 0,1:11:42.20,1:11:46.06,English,,0,0,0,,So now thread A holds the lock on resource A
Dialogue: 0,1:11:47.08,1:11:49.78,English,,0,0,0,,And thread 2 holds the lock on resource B
Dialogue: 0,1:11:52.08,1:11:56.06,English,,0,0,0,,And so now let's say process thread 2 gets preempted so now
Dialogue: 0,1:11:56.88,1:11:59.18,English,,0,0,0,,And thread one runs and so now it's waiting
Dialogue: 0,1:12:00.60,1:12:02.32,English,,0,0,0,,It's trying to tries to acquire
Dialogue: 0,1:12:03.18,1:12:05.36,English,,0,0,0,,The the lock on resource B
Dialogue: 0,1:12:07.08,1:12:09.08,English,,0,0,0,,But threat to our holds that lock
Dialogue: 0,1:12:10.54,1:12:15.02,English,,0,0,0,,And at the same time thread 2 tries to acquire the lock on resource A
Dialogue: 0,1:12:17.04,1:12:18.64,English,,0,0,0,,But process one is holding that right
Dialogue: 0,1:12:18.72,1:12:25.22,English,,0,0,0,,So they're each so here's the case where thread A is waiting for this semaphore
Dialogue: 0,1:12:26.02,1:12:28.52,English,,0,0,0,,Associated with B to become nonzero
Dialogue: 0,1:12:29.36,1:12:31.46,English,,0,0,0,,So it's blocked in this p operation
Dialogue: 0,1:12:32.10,1:12:39.60,English,,0,0,0,,And at the same time thread 2 is blocked in the p operation for resource A
Dialogue: 0,1:12:40.76,1:12:44.22,English,,0,0,0,,Neither of those semaphores will ever be released
Dialogue: 0,1:12:44.70,1:12:46.86,English,,0,0,0,,So thread 1 and 2 are deadlocked
Dialogue: 0,1:12:49.70,1:12:55.38,English,,0,0,0,,Okay and it happened because just there was this innocuous little bug in this case
Dialogue: 0,1:12:55.92,1:12:59.04,English,,0,0,0,,Where one the threads acquired their resources in different orders
Dialogue: 0,1:13:05.62,1:13:08.78,English,,0,0,0,,So here's an example of a program that deadlocks
Dialogue: 0,1:13:08.98,1:13:14.78,English,,0,0,0,,And if you looked at this you know the fact that it's wrong and bug doesn't jump out at you right
Dialogue: 0,1:13:14.82,1:13:17.86,English,,0,0,0,,So this kind of stuff is very subtle
Dialogue: 0,1:13:17.86,1:13:22.22,English,,0,0,0,,So here's a program we're going to create two threads
Dialogue: 0,1:13:24.52,1:13:29.12,English,,0,0,0,,We've got an array so and we have an array of mutexes
Dialogue: 0,1:13:31.64,1:13:33.28,English,,0,0,0,,An array of two mutexes
Dialogue: 0,1:13:34.58,1:13:38.62,English,,0,0,0,,So we create two threads and we pass each thread
Dialogue: 0,1:13:39.16,1:13:42.86,English,,0,0,0,,It's a local thread id so of 0 and 1
Dialogue: 0,1:13:43.70,1:13:49.56,English,,0,0,0,,And so here we're avoiding the race we're just casting this thread id to a pointer okay
Dialogue: 0,1:13:49.96,1:13:52.52,English,,0,0,0,,Which is a little strange but it's okay
Dialogue: 0,1:13:53.38,1:13:55.26,English,,0,0,0,,And then we're waiting for those threads to finish
Dialogue: 0,1:13:57.62,1:14:05.60,English,,0,0,0,,Ok each thread is going to acquire two these two semaphores
Dialogue: 0,1:14:06.18,1:14:07.60,English,,0,0,0,,These two mutexes
Dialogue: 0,1:14:08.78,1:14:10.78,English,,0,0,0,,But it's going to do it in a different order
Dialogue: 0,1:14:14.94,1:14:18.44,English,,0,0,0,,Okay so it's going to do it as a function it's going to take the id
Dialogue: 0,1:14:18.44,1:14:22.40,English,,0,0,0,,So it's going to...so thread 0 will first acquire a mutex 0
Dialogue: 0,1:14:23.82,1:14:27.68,English,,0,0,0,,And then acquire mutex 1-0
Dialogue: 0,1:14:27.68,1:14:29.70,English,,0,0,0,,So then it will acquire mutex 1
Dialogue: 0,1:14:31.50,1:14:36.20,English,,0,0,0,,And thread 1 will first acquire mutex 1
Dialogue: 0,1:14:36.98,1:14:38.56,English,,0,0,0,,And then acquire mutex 0
Dialogue: 0,1:14:41.86,1:14:46.98,English,,0,0,0,,Ok so if we were to draw that diet,and then it will attempt to then it will increment count
Dialogue: 0,1:14:47.36,1:14:48.50,English,,0,0,0,,So this is totally bogus
Dialogue: 0,1:14:48.66,1:14:51.34,English,,0,0,0,,But it's just to illustrate the problem
Dialogue: 0,1:14:52.74,1:14:58.08,English,,0,0,0,,So you can see thread 0 does a P semaphore 0 followed by a P semaphore 1
Dialogue: 0,1:14:58.86,1:15:01.30,English,,0,0,0,,And thread 1 does a P semaphore 1
Dialogue: 0,1:15:01.98,1:15:03.92,English,,0,0,0,,Followed by a P semaphore 0
Dialogue: 0,1:15:06.50,1:15:10.22,English,,0,0,0,,And so we can see this,that this is a problem very clearly
Dialogue: 0,1:15:10.42,1:15:12.52,English,,0,0,0,,If we go back to a progress graphs
Dialogue: 0,1:15:17.08,1:15:19.40,English,,0,0,0,,So if you look at thread 0
Dialogue: 0,1:15:20.36,1:15:22.42,English,,0,0,0,,It's doing a P semaphore 1
Dialogue: 0,1:15:22.90,1:15:28.22,English,,0,0,0,,And of and it followed a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:30.82,1:15:35.94,English,,0,0,0,,And thread 1 is also is doing a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:36.64,1:15:44.20,English,,0,0,0,,So if you take the intersection of these two regions
Dialogue: 0,1:15:45.00,1:15:47.92,English,,0,0,0,,You get the forbidden region for semaphore 1
Dialogue: 0,1:15:48.04,1:15:51.20,English,,0,0,0,,Okay so this is the region that enforces mutual exclusion
Dialogue: 0,1:15:51.90,1:15:56.00,English,,0,0,0,,So on this the resource associated with semaphore 1
Dialogue: 0,1:15:58.78,1:16:02.54,English,,0,0,0,,And if you do the same thing for semaphore 0 so here in thread 1
Dialogue: 0,1:16:03.20,1:16:06.26,English,,0,0,0,,We're acquiring semaphore 0 here and releasing it here
Dialogue: 0,1:16:07.72,1:16:12.82,English,,0,0,0,,And in thread 0 we're acquiring it here and releasing it here
Dialogue: 0,1:16:13.96,1:16:16.02,English,,0,0,0,,So if you take the intersection of those two
Dialogue: 0,1:16:16.66,1:16:19.84,English,,0,0,0,,You get this forbidden region for S(0)
Dialogue: 0,1:16:21.66,1:16:22.84,English,,0,0,0,,Ok now the problem
Dialogue: 0,1:16:26.86,1:16:31.22,English,,0,0,0,,is right is this region here this so-called deadlock region
Dialogue: 0,1:16:33.74,1:16:35.42,English,,0,0,0,,Because by the rules of
Dialogue: 0,1:16:36.58,1:16:37.98,English,,0,0,0,,You know time can't go backwards
Dialogue: 0,1:16:40.82,1:16:44.16,English,,0,0,0,,Heart once the trajectory enters into the this deadlock region
Dialogue: 0,1:16:45.08,1:16:45.88,English,,0,0,0,,Then it's doomed
Dialogue: 0,1:16:46.48,1:16:49.68,English,,0,0,0,,Because there's no once it enters this
Dialogue: 0,1:16:50.64,1:16:54.54,English,,0,0,0,,Once it enters this deadlock region there's nowhere for it to go eventually
Dialogue: 0,1:16:55.60,1:16:57.26,English,,0,0,0,,No matter how it progresses
Dialogue: 0,1:16:57.82,1:17:01.24,English,,0,0,0,,Every trajectory will lead to this point here where
Dialogue: 0,1:17:01.36,1:17:04.66,English,,0,0,0,,It's boxed in and can no longer proceed
Dialogue: 0,1:17:11.20,1:17:12.06,English,,0,0,0,,So
Dialogue: 0,1:17:15.34,1:17:19.08,English,,0,0,0,,So interestingly this sort of this region back here
Dialogue: 0,1:17:20.02,1:17:24.98,English,,0,0,0,,On the sort of the tail end of the of these two forbidden regions
Dialogue: 0,1:17:25.66,1:17:27.98,English,,0,0,0,,This represents states that can never be reached
Dialogue: 0,1:17:28.26,1:17:32.44,English,,0,0,0,,So these are on unreachable states which may or may not be interesting
Dialogue: 0,1:17:33.68,1:17:35.44,English,,0,0,0,,And then what makes this so nasty
Dialogue: 0,1:17:36.96,1:17:37.76,English,,0,0,0,,Is that
Dialogue: 0,1:17:39.26,1:17:42.68,English,,0,0,0,,It's non-deterministic right some programs some trajectories
Dialogue: 0,1:17:44.28,1:17:47.36,English,,0,0,0,,If they get lucky they'll skirt this deadlock region
Dialogue: 0,1:17:48.44,1:17:50.66,English,,0,0,0,,And then the program will run fine right
Dialogue: 0,1:17:52.94,1:17:55.58,English,,0,0,0,,There's okay so if it's trajectory maybe
Dialogue: 0,1:17:57.50,1:18:01.56,English,,0,0,0,,Just by some you know just by some arbitrary scheduling decision
Dialogue: 0,1:18:01.90,1:18:11.66,English,,0,0,0,,Made by the kernel the trajectory gets passed the deadlock region in this direction
Dialogue: 0,1:18:13.00,1:18:16.98,English,,0,0,0,,And then it'll eventually run without any problem
Dialogue: 0,1:18:17.84,1:18:25.46,English,,0,0,0,,So it's just it's only if the trajectory lands it within the deadlock region then there were that we're in trouble
Dialogue: 0,1:18:26.76,1:18:34.78,English,,0,0,0,,So this is the really nasty, the really nasty part is that you may run your program for a million times and every trajectory
Dialogue: 0,1:18:36.76,1:18:40.54,English,,0,0,0,,Every one of those million trajectories skirts the deadlock region
Dialogue: 0,1:18:41.40,1:18:43.76,English,,0,0,0,,Okay but on the million and first time that you run it
Dialogue: 0,1:18:44.50,1:18:47.50,English,,0,0,0,,It enters the deadlock region and then deadlocks
Dialogue: 0,1:18:50.60,1:18:53.72,English,,0,0,0,,Okay so it's very it's a very tough problem to deal with
Dialogue: 0,1:18:55.06,1:18:57.80,English,,0,0,0,,Now fortunately you it's easy to avoid
Dialogue: 0,1:18:58.94,1:19:07.32,English,,0,0,0,,If threads that are acquiring locks on resources acquire all those locks in the same order
Dialogue: 0,1:19:07.66,1:19:11.78,English,,0,0,0,,Okay so in our example if we rewrite this program
Dialogue: 0,1:19:11.86,1:19:17.42,English,,0,0,0,,So that each thread 0 and thread 1 acquire their locks in the same order
Dialogue: 0,1:19:18.36,1:19:22.08,English,,0,0,0,,Semaphore 0 first followed by semaphore 1
Dialogue: 0,1:19:25.00,1:19:28.72,English,,0,0,0,,Then if that happens and we you can see
Dialogue: 0,1:19:28.96,1:19:31.70,English,,0,0,0,,It eliminates the potential deadlock region
Dialogue: 0,1:19:35.76,1:19:39.40,English,,0,0,0,,Okay so now any trajectory that we take 
Dialogue: 0,1:19:44.78,1:19:49.42,English,,0,0,0,,Will be fine because we've eliminated that that that deadlock region
Dialogue: 0,1:19:50.12,1:19:53.44,English,,0,0,0,,And the order that we release the locks doesn't matter
Dialogue: 0,1:19:53.44,1:19:57.50,English,,0,0,0,,Because that sort of affects the
Dialogue: 0,1:20:00.38,1:20:06.10,English,,0,0,0,,It affects this or unreachable region you know the size and shape of this unreachable region
Dialogue: 0,1:20:08.02,1:20:13.68,English,,0,0,0,,But it there's never the order that we release the locks can never introduce a deadlock region
Dialogue: 0,1:20:17.66,1:20:19.20,English,,0,0,0,,Okay so that's it for today
Dialogue: 0,1:20:22.40,1:20:29.44,English,,0,0,0,,Hope you all have a very nice Thanksgiving holiday and we'll see you on Tuesday
