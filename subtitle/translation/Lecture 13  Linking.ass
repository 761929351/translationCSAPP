[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video File: ../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 810
Active Line: 819
Video Position: 146324

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.34,English,,0,0,0,,Welcome good to see you
Dialogue: 0,0:00:00.03,0:00:01.34,Chinese,,0,0,0,,欢迎，很高兴见到大家
Dialogue: 0,0:00:04.60,0:00:09.52,English,,0,0,0,,Today we're going to begin a transitioning from
Dialogue: 0,0:00:04.60,0:00:09.52,Chinese,,0,0,0,,今天我们要转变一下研究内容
Dialogue: 0,0:00:10.28,0:00:17.04,English,,0,0,0,,How a programs interact with hardware to how they interact with software in particular system software
Dialogue: 0,0:00:10.28,0:00:17.04,Chinese,,0,0,0,,从程序如何与硬件交互，以及它们如何与特定系统软件中的软件交互开始
Dialogue: 0,0:00:17.70,0:00:23.38,English,,0,0,0,,And we're going to start that investigation by studying and learning about a process called linking
Dialogue: 0,0:00:17.70,0:00:23.38,Chinese,,0,0,0,,我们将通过研究和弄懂一个叫做链接的过程开始
Dialogue: 0,0:00:25.12,0:00:30.98,English,,0,0,0,,Which is how the system builds your programs ok
Dialogue: 0,0:00:25.12,0:00:30.98,English,,0,0,0,,这能帮助你好好弄清楚系统是如何构建你的程序
Dialogue: 0,0:00:33.26,0:00:35.92,English,,0,0,0,,So we're going to study the process of linking
Dialogue: 0,0:00:33.26,0:00:35.92,English,,0,0,0,,所以我们要学习链接的过程
Dialogue: 0,0:00:35.92,0:00:40.86,English,,0,0,0,,And then I'm going to show you a really cool technique called library interpositioning
Dialogue: 0,0:00:35.92,0:00:40.86,English,,0,0,0,,然后我将向你展示一项非常酷的技术，称为库打桩技术
Dialogue: 0,0:00:42.16,0:00:51.08,English,,0,0,0,,Which allows you to use linking to actually intercept on function calls in libraries like the standard C library
Dialogue: 0,0:00:42.16,0:00:51.08,English,,0,0,0,,这允许你使用链接实际拦截像标准 C 库这样的库中的函数调用
Dialogue: 0,0:00:51.66,0:00:56.38,English,,0,0,0,,So it's a very powerful and interesting technique and it's all enabled by by linking
Dialogue: 0,0:00:51.66,0:00:56.38,English,,0,0,0,,所以它是一种非常强大而且有趣的技术，它通过链接实现
Dialogue: 0,0:00:58.28,0:01:01.36,English,,0,0,0,,So let's start with a simple program
Dialogue: 0,0:00:58.28,0:01:01.36,English,,0,0,0,,让我们从一个非常简单的程序开始吧
Dialogue: 0,0:01:02.54,0:01:07.84,English,,0,0,0,,This program consists of two modules a main.c and sum.c
Dialogue: 0,0:01:02.54,0:01:07.84,English,,0,0,0,,这个程序里包含两个模块 main.c 和 sum.c
Dialogue: 0,0:01:09.06,0:01:14.90,English,,0,0,0,,sum.c takes as an array as an argument and a length n
Dialogue: 0,0:01:09.06,0:01:14.90,English,,0,0,0,,sum.c 将一个数组和一个长度 n 作为参数
Dialogue: 0,0:01:15.54,0:01:21.60,English,,0,0,0,,And then it sums up the elements of that array and returns the sum  back to the caller
Dialogue: 0,0:01:15.54,0:01:21.60,English,,0,0,0,,然后它计算了该数组中元素的总和并将总和返回给调用者
Dialogue: 0,0:01:23.48,0:01:26.21,English,,0,0,0,,main.c calls the sum function
Dialogue: 0,0:01:23.48,0:01:26.21,English,,0,0,0,,main.c 调用了 sum 函数
Dialogue: 0,0:01:26.76,0:01:29.54,English,,0,0,0,,Using and passes it a two element array of ints
Dialogue: 0,0:01:26.76,0:01:29.54,English,,0,0,0,,使用并传递一个两元素的 int 类型数组
Dialogue: 0,0:01:31.20,0:01:35.78,English,,0,0,0,,And then returns the value received from some
Dialogue: 0,0:01:31.20,0:01:35.78,English,,0,0,0,,然后返回了从其中收到的值
Dialogue: 0,0:01:37.74,0:01:43.54,English,,0,0,0,,Yeah we that that's kind of an odd thing to do to return your exit status like that
Dialogue: 0,0:01:37.74,0:01:43.54,English,,0,0,0,,是的，我们认为像这样返回退出状态是件奇怪的事情
Dialogue: 0,0:01:43.54,0:01:47.76,English,,0,0,0,,But we just did it so that the compiler wouldn't optimize away all of a code
Dialogue: 0,0:01:43.54,0:01:47.76,English,,0,0,0,,但我们这样做，以便编译器不会优化掉所有代码
Dialogue: 0,0:01:49.22,0:01:52.94,English,,0,0,0,,I know let's look at what happens if when we want to compile those those two modules
Dialogue: 0,0:01:49.22,0:01:52.94,English,,0,0,0,,让我们来看看如果我们想要编译那两个模块会发生什么
Dialogue: 0,0:01:55.44,0:01:58.74,English,,0,0,0,,For each of main.c and sum.c
Dialogue: 0,0:01:55.44,0:01:58.74,English,,0,0,0,,对于每个 main.c 和 sum.c
Dialogue: 0,0:01:59.52,0:02:08.66,English,,0,0,0,,The GCC calls a series of translators on that,on those modules,on those .c files
Dialogue: 0,0:01:59.52,0:02:08.66,English,,0,0,0,,GCC 会在这些模块上调用 .c 文件上的一系列翻译器
Dialogue: 0,0:02:09.38,0:02:11.68,English,,0,0,0,,First calls the C preprocessor cpp
Dialogue: 0,0:02:09.38,0:02:11.68,English,,0,0,0,,首先调用 C 预处理器 cpp(将 main.c 翻译成 ASCII 中间文件 main.i)
Dialogue: 0,0:02:14.30,0:02:18.82,English,,0,0,0,,Then it calls the compiler,the actual compiler which is cc1
Dialogue: 0,0:02:14.30,0:02:18.82,English,,0,0,0,,然后它调用编译器，实际上使用的编译器是叫 cc1(将 main.i 翻译成 ASCII 汇编语言文件 main.s)
Dialogue: 0,0:02:20.90,0:02:26.96,English,,0,0,0,,The compiler generates assembly which is then translated by the assembler as
Dialogue: 0,0:02:20.90,0:02:26.96,English,,0,0,0,,编译器生成汇编程序，然后汇编器将其翻译
Dialogue: 0,0:02:27.72,0:02:32.60,English,,0,0,0,,And resulting in a .o file called main.o
Dialogue: 0,0:02:27.72,0:02:32.60,English,,0,0,0,,结果生成了一个 .o 文件,称为 main.o
Dialogue: 0,0:02:33.26,0:02:36.24,English,,0,0,0,,Similar things happens for sum.c
Dialogue: 0,0:02:33.26,0:02:36.24,English,,0,0,0,,sum.c 也发生了类似的事情
Dialogue: 0,0:02:37.34,0:02:43.88,English,,0,0,0,,So after these three translators work on the code
Dialogue: 0,0:02:37.34,0:02:43.88,English,,0,0,0,,在这三个翻译器处理完代码之后
Dialogue: 0,0:02:44.36,0:02:47.14,English,,0,0,0,,We have two object files two .o files
Dialogue: 0,0:02:44.36,0:02:47.14,English,,0,0,0,,生成了两个 .o 格式目标文件
Dialogue: 0,0:02:48.86,0:02:51.54,English,,0,0,0,,The linker takes those those .o files
Dialogue: 0,0:02:48.86,0:02:51.54,English,,0,0,0,,链接器取到这些 .o 格式目标文件
Dialogue: 0,0:02:52.18,0:03:04.66,English,,0,0,0,,And put some,links them together sort of smashes them together to form a single executable called that we can then run
Dialogue: 0,0:02:52.18,0:03:04.66,English,,0,0,0,,然后放一些（必要的系统目标文件），将它们链接在一起，将它们拼凑在一起，创建一个单个的可执行文件然后运行
Dialogue: 0,0:03:07.02,0:03:09.24,English,,0,0,0,,Then we can then load and run on the system
Dialogue: 0,0:03:07.02,0:03:09.24,English,,0,0,0,,然后我们就可以加载并运行到系统上
Dialogue: 0,0:03:11.36,0:03:15.42,English,,0,0,0,,So the main.c and sum.c they are called source files
Dialogue: 0,0:03:11.36,0:03:15.42,English,,0,0,0,,所以 main.c 和 sum.c 被称为源文件
Dialogue: 0,0:03:15.94,0:03:19.90,English,,0,0,0,,These .o files are object files that
Dialogue: 0,0:03:15.94,0:03:19.90,English,,0,0,0,,这些 .o 文件
Dialogue: 0,0:03:20.60,0:03:22.28,English,,0,0,0,,We are separately compiled
Dialogue: 0,0:03:20.60,0:03:22.28,English,,0,0,0,,虽然是我们分开编译的目标文件
Dialogue: 0,0:03:23.18,0:03:25.64,English,,0,0,0,,But we call them relocatable object files
Dialogue: 0,0:03:23.18,0:03:25.64,English,,0,0,0,,但我们还是要叫他们可重定位目标文件
Dialogue: 0,0:03:25.74,0:03:33.32,English,,0,0,0,,Because they can be combined together to form the fully linked executable object file
Dialogue: 0,0:03:25.74,0:03:33.32,English,,0,0,0,,因为它们可以组合在一起形成完全链接的可执行目标文件
Dialogue: 0,0:03:36.06,0:03:42.56,English,,0,0,0,,So why do we do it like this, you know why do we allow this so-called separate compilation
Dialogue: 0,0:03:36.06,0:03:42.56,English,,0,0,0,,那为什么我们这样做呢，你知道为什么我们允许这种所谓的分开编译
Dialogue: 0,0:03:42.62,0:03:48.50,English,,0,0,0,,You know why don't we just have like one big you know one big file that with all of code in it
Dialogue: 0,0:03:42.62,0:03:48.50,English,,0,0,0,,你知道为什么我们不喜欢一个包含所有代码的大文件
Dialogue: 0,0:03:49.02,0:03:55.57,English,,0,0,0,,Well there's a couple reasons the first is is modularity so by allowing you to break your code into smaller pieces
Dialogue: 0,0:03:49.02,0:03:55.57,English,,0,0,0,,有一些原因，首先是模块化，所以允许你将代码分解成更小的部分
Dialogue: 0,0:03:55.96,0:03:58.96,English,,0,0,0,,You can put related functions into separate source files
Dialogue: 0,0:03:55.96,0:03:58.96,English,,0,0,0,,你可以将相关功能放入单独的源文件中
Dialogue: 0,0:03:59.30,0:04:01.58,English,,0,0,0,,You can define libraries of functions
Dialogue: 0,0:03:59.30,0:04:01.58,English,,0,0,0,,你可以定义函数库
Dialogue: 0,0:04:02.74,0:04:11.60,English,,0,0,0,,So it's just good technique and it allows you to kind of break your code up into nice modular pieces
Dialogue: 0,0:04:02.74,0:04:11.60,English,,0,0,0,,所以这只是一种很好的技术，它可以让你将代码分解成很好的模块化部分
Dialogue: 0,0:04:13.54,0:04:15.10,English,,0,0,0,,The other reason is efficiency
Dialogue: 0,0:04:13.54,0:04:15.10,English,,0,0,0,,另一个理由是效率
Dialogue: 0,0:04:18.68,0:04:21.92,English,,0,0,0,,So if we've broken up our program into multiple chunks
Dialogue: 0,0:04:18.68,0:04:21.92,English,,0,0,0,,所以如果我们把我们的程序分为多个块
Dialogue: 0,0:04:22.66,0:04:28.54,English,,0,0,0,,If we change and if we only need to change one of the chunks
Dialogue: 0,0:04:22.66,0:04:28.54,English,,0,0,0,,如果我们改变，比如如果我们只需要更改其中一个块
Dialogue: 0,0:04:29.26,0:04:33.06,English,,0,0,0,,We don't have to recompile the all the other modules
Dialogue: 0,0:04:29.26,0:04:33.06,English,,0,0,0,,我们就没必要重新编译所有其他模块
Dialogue: 0,0:04:33.28,0:04:38.50,English,,0,0,0,,Right we can just recompile the one module that we changed and then link them all together again
Dialogue: 0,0:04:33.28,0:04:38.50,English,,0,0,0,,对，我们可以重新编译我们更改的一个模块，然后再将它们全部链接在一起
Dialogue: 0,0:04:38.58,0:04:44.26,English,,0,0,0,,Right so it's efficient in time it's also efficient in space
Dialogue: 0,0:04:38.58,0:04:44.26,English,,0,0,0,,所以这在时间和空间上都是有效的
Dialogue: 0,0:04:44.26,0:04:51.64,English,,0,0,0,,Because you can take all of the functions in the standard C library you could put them all together
Dialogue: 0,0:04:44.26,0:04:51.64,English,,0,0,0,,因为你可以使用标准 C 库中的所有功能，所以你可以将它们放在一起
Dialogue: 0,0:04:52.14,0:04:57.86,English,,0,0,0,,But then the only functions that you actually get compiled and linked into your program are the ones that you actually call
Dialogue: 0,0:04:52.14,0:04:57.86,English,,0,0,0,,但是，实际编译并链接到程序中的唯一函数是你实际调用的函数
Dialogue: 0,0:04:58.68,0:05:01.62,English,,0,0,0,,Ok so you can save space
Dialogue: 0,0:04:58.68,0:05:01.62,English,,0,0,0,,好的，这样你就可以节省空间
Dialogue: 0,0:05:01.62,0:05:08.14,English,,0,0,0,,You don't you know normally you use only a small subset of the standard C functions
Dialogue: 0,0:05:01.62,0:05:08.14,English,,0,0,0,,你通常不知道你其实只使用标准 C 函数的一小部分
Dialogue: 0,0:05:08.80,0:05:13.16,English,,0,0,0,,So there's no point in linking all of those functions into your code if you don't need them
Dialogue: 0,0:05:08.80,0:05:13.16,English,,0,0,0,,因此，如果你不需要将所有这些功能链接到代码中，那就没有意义了
Dialogue: 0,0:05:15.08,0:05:16.66,English,,0,0,0,,Alright so what do linkers do
Dialogue: 0,0:05:15.08,0:05:16.66,English,,0,0,0,,好吧，那么链接器做了什么呢
Dialogue: 0,0:05:18.02,0:05:21.78,English,,0,0,0,,Well there's two main tasks that a linker performs
Dialogue: 0,0:05:18.02,0:05:21.78,English,,0,0,0,,链接器执行的主要任务有两个
Dialogue: 0,0:05:23.28,0:05:25.82,English,,0,0,0,,The first is called simple resolution
Dialogue: 0,0:05:23.28,0:05:25.82,English,,0,0,0,,第一个被称为简单解析（符号解析）
Dialogue: 0,0:05:27.16,0:05:30.16,English,,0,0,0,,So programs define and reference symbols
Dialogue: 0,0:05:27.16,0:05:30.16,English,,0,0,0,,为了程序定义和应用符号
Dialogue: 0,0:05:30.44,0:05:37.10,English,,0,0,0,,Okay that what the linker refers to as symbols and these are global variables and functions
Dialogue: 0,0:05:30.44,0:05:37.10,English,,0,0,0,,好的，链接器称为符号，这些是全局变量和函数
Dialogue: 0,0:05:37.62,0:05:44.40,English,,0,0,0,,Okay in the names and those objects they're referred to as a symbol
Dialogue: 0,0:05:37.62,0:05:44.40,English,,0,0,0,,在名称和那些对象中，它们被称为符号
Dialogue: 0,0:05:44.46,0:05:52.28,English,,0,0,0,,So here we're declaring,we're defining a symbol called swap
Dialogue: 0,0:05:44.46,0:05:52.28,English,,0,0,0,,第一行代码，我们在这里声明，我们正在定义一个名为swap的符号
Dialogue: 0,0:05:53.66,0:05:59.42,English,,0,0,0,,Here we're referring when we call swap, we're referring to that symbol
Dialogue: 0,0:05:53.66,0:05:59.42,English,,0,0,0,,中间这行我们称之为 swap ，我们指的是那个符号
Dialogue: 0,0:05:59.44,0:06:01.30,English,,0,0,0,,Okay that's a reference to the symbol
Dialogue: 0,0:05:59.44,0:06:01.30,English,,0,0,0,,是的，这是对符号的一种引用
Dialogue: 0,0:06:03.30,0:06:07.20,English,,0,0,0,,And here we're defining a pointer to an int called xp
Dialogue: 0,0:06:03.30,0:06:07.20,English,,0,0,0,,最后一行，我们定义了一个指向名为 xp 的 int 类型指针
Dialogue: 0,0:06:08.30,0:06:13.02,English,,0,0,0,,So we're defining xp and we're initializing it to the address of x
Dialogue: 0,0:06:08.30,0:06:13.02,English,,0,0,0,,所以我们定义了 xp ，将它初始化为取 x 的地址
Dialogue: 0,0:06:13.02,0:06:15.52,English,,0,0,0,,So we're referring,that's a reference to x
Dialogue: 0,0:06:13.02,0:06:15.52,English,,0,0,0,,这指的是，这是对 x 的引用
Dialogue: 0,0:06:18.00,0:06:24.24,English,,0,0,0,,Okay so the symbol definitions are stored in the object file by the assembler
Dialogue: 0,0:06:18.00,0:06:24.24,English,,0,0,0,,汇编器将符号定义存储在目标文件中
Dialogue: 0,0:06:25.32,0:06:28.52,English,,0,0,0,,In a symbol table which is an array of structs
Dialogue: 0,0:06:25.32,0:06:28.52,English,,0,0,0,,在这个符号表里面，全是一系列结构数组
Dialogue: 0,0:06:29.12,0:06:32.19,English,,0,0,0,,Where each structs contains information about the symbol
Dialogue: 0,0:06:29.12,0:06:32.19,English,,0,0,0,,每个结构数组里面包含有关该符号的信息
Dialogue: 0,0:06:32.58,0:06:37.54,English,,0,0,0,,Like the name of the symbol its size and where it's located
Dialogue: 0,0:06:32.58,0:06:37.54,English,,0,0,0,,比如符号的名称，它的大小和位置等等信息
Dialogue: 0,0:06:40.54,0:06:46.78,English,,0,0,0,,Now what we mean by symbol resolution is that during the linker linking process
Dialogue: 0,0:06:40.54,0:06:46.78,English,,0,0,0,,所以现在我们说符号解析的意思是在链接器链接过程中
Dialogue: 0,0:06:47.58,0:06:54.94,English,,0,0,0,,The linker associates each symbol reference with exactly one symbol definition
Dialogue: 0,0:06:47.58,0:06:54.94,English,,0,0,0,,链接器将每个符号引用与一个符号定义相关联
Dialogue: 0,0:06:57.68,0:06:59.42,English,,0,0,0,,Okay so it's possible in multiple
Dialogue: 0,0:06:57.68,0:06:59.42,English,,0,0,0,,好的，所以这可能有多个
Dialogue: 0,0:07:00.64,0:07:04.16,English,,0,0,0,,You know why is this an issue well it's possible like in multiple modules
Dialogue: 0,0:07:00.64,0:07:04.16,English,,0,0,0,,这中间可能会有些问题，比如在多个模块中
Dialogue: 0,0:07:04.16,0:07:06.84,English,,0,0,0,,You may declare a global variable with the same name
Dialogue: 0,0:07:04.16,0:07:06.84,English,,0,0,0,,你可能会声明一个有相同名称的全局变量
Dialogue: 0,0:07:07.80,0:07:13.76,English,,0,0,0,,The linker has to decide which one of those definitions to use for all subsequent references
Dialogue: 0,0:07:07.80,0:07:13.76,English,,0,0,0,,链接器必须决定将其中的某个定义用于所有后续引用
Dialogue: 0,0:07:16.70,0:07:21.74,English,,0,0,0,,Now once the linker is associated a unique object
Dialogue: 0,0:07:16.70,0:07:21.74,English,,0,0,0,,一旦链接器和一个独一无二的目标建立联系
Dialogue: 0,0:07:21.74,0:07:25.44,English,,0,0,0,,With each a unique symbol definition with each reference
Dialogue: 0,0:07:21.74,0:07:25.44,English,,0,0,0,,每个引用都会有一个唯一的符号定义
Dialogue: 0,0:07:26.84,0:07:29.22,English,,0,0,0,,Then it does the second step which is relocation
Dialogue: 0,0:07:26.84,0:07:29.22,English,,0,0,0,,然后它执行第二步，即重定位
Dialogue: 0,0:07:29.78,0:07:33.32,English,,0,0,0,,And during relocation it merges all of the modules together
Dialogue: 0,0:07:29.78,0:07:33.32,English,,0,0,0,,在重定位期间，它会将所有模块合并在一起
Dialogue: 0,0:07:33.70,0:07:42.98,English,,0,0,0,,Into a single executable object module that can be directly loaded and executed on the system
Dialogue: 0,0:07:33.70,0:07:42.98,English,,0,0,0,,进入单个可执行目标模块后，就可以直接在系统上加载和执行
Dialogue: 0,0:07:43.98,0:07:47.34,English,,0,0,0,,So when it does this merging
Dialogue: 0,0:07:43.98,0:07:47.34,English,,0,0,0,,所以当它合并时
Dialogue: 0,0:07:50.16,0:07:57.04,English,,0,0,0,,It has to figure out where each symbol,each function and each variable is going to be stored
Dialogue: 0,0:07:50.16,0:07:57.04,English,,0,0,0,,它必须弄清楚每个符号，每个函数和每个变量是要准备存储在哪
Dialogue: 0,0:07:57.92,0:07:59.16,English,,0,0,0,,And this is called relocation
Dialogue: 0,0:07:57.92,0:07:59.16,English,,0,0,0,,这称为重定位
Dialogue: 0,0:07:59.16,0:08:06.78,English,,0,0,0,,Because initially functions are just stored at some offset in their object module
Dialogue: 0,0:07:59.16,0:08:06.78,English,,0,0,0,,因为最初的函数只是存储在其目标模块中的某个偏移处
Dialogue: 0,0:08:07.36,0:08:13.26,English,,0,0,0,,Right because that the linker doesn't know where those functions are actually going to be eventually a loaded into memory
Dialogue: 0,0:08:07.36,0:08:13.26,English,,0,0,0,,正确，因为链接器不知道这些函数最终会被真正加载到内存中的哪个地方
Dialogue: 0,0:08:14.04,0:08:26.08,English,,0,0,0,,So before relocation the address of a function in the object module is just its offset in the module and similarly for data
Dialogue: 0,0:08:14.04,0:08:26.08,English,,0,0,0,,所以在重定向前目标模块中的函数地址只是它在模块中的偏移量，对于数据也是如此
Dialogue: 0,0:08:26.62,0:08:31.38,English,,0,0,0,,During the relocation step the linker decides on
Dialogue: 0,0:08:26.62,0:08:31.38,English,,0,0,0,,在重定位步骤期间，链接器会决定
Dialogue: 0,0:08:31.56,0:08:38.76,English,,0,0,0,,Where each symbol is going to be ultimately located in memory one at x,when the program executes
Dialogue: 0,0:08:31.56,0:08:38.76,English,,0,0,0,,当程序执行时，每个符号最终将位于 x 中的存储区中的哪里
Dialogue: 0,0:08:39.54,0:08:45.48,English,,0,0,0,,And it binds that those absolute memory locations to the symbol
Dialogue: 0,0:08:39.54,0:08:45.48,English,,0,0,0,,并且它将那些绝对存储器位置绑定到符号
Dialogue: 0,0:08:45.98,0:08:49.74,English,,0,0,0,,And then it goes and looks at all the references to those symbols
Dialogue: 0,0:08:45.98,0:08:49.74,English,,0,0,0,,然后它会继续向下执行并查看所有对这些符号的引用
Dialogue: 0,0:08:50.46,0:08:54.74,English,,0,0,0,,And it updates those references so that they now they point to the correct address
Dialogue: 0,0:08:50.46,0:08:54.74,English,,0,0,0,,而且它它会更新那些引用，以便它们现在能指向正确的地址
Dialogue: 0,0:08:55.54,0:08:57.72,English,,0,0,0,,Okay so figure out where stuff is going to go
Dialogue: 0,0:08:55.54,0:08:57.72,English,,0,0,0,,好的，所以弄清楚原料要去哪里
Dialogue: 0,0:08:58.88,0:09:03.78,English,,0,0,0,,For each definition figure out where it's going to go and for each reference then update that reference
Dialogue: 0,0:08:58.88,0:09:03.78,English,,0,0,0,,对于每个定义，找出它要去的位置以及每个引用，然后更新该引用
Dialogue: 0,0:09:03.78,0:09:06.14,English,,0,0,0,,So it now points to the right spot
Dialogue: 0,0:09:03.78,0:09:06.14,English,,0,0,0,,所以它现在指向正确的位置
Dialogue: 0,0:09:09.90,0:09:14.54,English,,0,0,0,,So let's look at what these...how these steps work in more detail
Dialogue: 0,0:09:09.90,0:09:14.54,English,,0,0,0,,那么让我们来看看这些......这些步骤如何更详细地运作
Dialogue: 0,0:09:14.92,0:09:18.22,English,,0,0,0,,Before that we need to define a few things
Dialogue: 0,0:09:14.92,0:09:18.22,English,,0,0,0,,在那之前我们需要定义一些东西
Dialogue: 0,0:09:19.80,0:09:23.34,English,,0,0,0,,So there's three kinds of object modules that I've alluded to
Dialogue: 0,0:09:19.80,0:09:23.34,English,,0,0,0,,所以我提到了三种目标模块
Dialogue: 0,0:09:24.18,0:09:29.72,English,,0,0,0,,There's the .o file which is a relocatable object module this is the output of the assembler
Dialogue: 0,0:09:24.18,0:09:29.72,English,,0,0,0,,.o 文件是可重定位目标模块，这是汇编器的输出
Dialogue: 0,0:09:30.50,0:09:33.40,English,,0,0,0,,And it's not a binary file
Dialogue: 0,0:09:30.50,0:09:33.40,English,,0,0,0,,它不是一个二进制文件
Dialogue: 0,0:09:34.00,0:09:39.34,English,,0,0,0,,But it's not in any form that can be directly loaded into memory
Dialogue: 0,0:09:34.00,0:09:39.34,English,,0,0,0,,但它不能以任何形式直接加载到内存中
Dialogue: 0,0:09:39.34,0:09:43.60,English,,0,0,0,, It needs to be manipulated by the linker before it can be actually used
Dialogue: 0,0:09:39.34,0:09:43.60,English,,0,0,0,, 在实际使用之前，需要由链接器对其进行操作
Dialogue: 0,0:09:44.64,0:09:48.48,English,,0,0,0,,There's the executable object file which is generated by the linker
Dialogue: 0,0:09:44.64,0:09:48.48,English,,0,0,0,,由链接器生成的可执行目标文件
Dialogue: 0,0:09:50.18,0:09:51.70,English,,0,0,0,,These is called a.out files
Dialogue: 0,0:09:50.18,0:09:51.70,English,,0,0,0,,这被称为 a.out 文件
Dialogue: 0,0:09:51.72,0:09:57.06,English,,0,0,0,,Sometimes historically the very first Linux systems the executable
Dialogue: 0,0:09:51.72,0:09:57.06,English,,0,0,0,,在历史上第一个Linux操作系统就是可执行的
Dialogue: 0,0:09:57.06,0:10:04.36,English,,0,0,0,,This sort of the default name that they the developers of Unix used,the default name for their executables was a.out
Dialogue: 0,0:09:57.06,0:10:04.36,English,,0,0,0,,这是Unix开发人员使用的默认名称，其可执行文件的默认名称是a.out
Dialogue: 0,0:10:05.72,0:10:10.34,English,,0,0,0,,So that's just sort of a historical reason that it's called a.out
Dialogue: 0,0:10:05.72,0:10:10.34,English,,0,0,0,,所以这只是一个历史原因所以它被称为a.out
Dialogue: 0,0:10:10.96,0:10:16.60,English,,0,0,0,,And then there's another type of object file called a shared object file or .so file
Dialogue: 0,0:10:10.96,0:10:16.60,English,,0,0,0,,然后是另一种称为共享目标文件或.so文件的目标文件
Dialogue: 0,0:10:17.12,0:10:24.46,English,,0,0,0,,Which is a modern technique for creating shared libraries
Dialogue: 0,0:10:17.12,0:10:24.46,English,,0,0,0,,这是一种用于创建共享库的现代技术
Dialogue: 0,0:10:24.62,0:10:27.64,English,,0,0,0,,And we'll look at those,we'll look at those later today
Dialogue: 0,0:10:24.62,0:10:27.64,English,,0,0,0,,那个我们之后再了解，将在今天晚些时候再学习了解
Dialogue: 0,0:10:29.14,0:10:34.50,English,,0,0,0,,Now object modules come in a standard format called ELF format
Dialogue: 0,0:10:29.14,0:10:34.50,English,,0,0,0,,现在，目标模块采用称为ELF格式的标准格式
Dialogue: 0,0:10:35.92,0:10:41.12,English,,0,0,0,,And it's a unified format for .o files for executables and for .so files
Dialogue: 0,0:10:35.92,0:10:41.12,English,,0,0,0,,它是可执行文件，.so文件，.o文件的统一格式
Dialogue: 0,0:10:41.12,0:10:45.34,English,,0,0,0,,They all use the same format,the same general format
Dialogue: 0,0:10:41.12,0:10:45.34,English,,0,0,0,,他们都使用一样的格式，一样的通用的格式
Dialogue: 0,0:10:48.26,0:10:52.68,English,,0,0,0,,So this while these ELF binaries are
Dialogue: 0,0:10:48.26,0:10:52.68,English,,0,0,0,,这就是这些 ELF 二进制文件
Dialogue: 0,0:10:53.48,0:10:55.58,English,,0,0,0,,Their binaries they're very structured
Dialogue: 0,0:10:53.48,0:10:55.58,English,,0,0,0,,他们的二进制文件非常有条理
Dialogue: 0,0:10:56.02,0:10:58.14,English,,0,0,0,,Ok and they're broken up into sections
Dialogue: 0,0:10:56.02,0:10:58.14,English,,0,0,0,,他们被分成几个部分
Dialogue: 0,0:10:58.94,0:11:08.02,English,,0,0,0,,The at the beginning is a header,that defines things like the size of the word the byte ordering
Dialogue: 0,0:10:58.94,0:11:08.02,English,,0,0,0,,开头是一个头，它定义了（生成该文件系统的）字节顺序和字的大小
Dialogue: 0,0:11:08.46,0:11:12.46,English,,0,0,0,,Whether it's a .o,a .out or a .so
Dialogue: 0,0:11:08.46,0:11:12.46,English,,0,0,0,,无论是 .o,.out 还是 .so 
Dialogue: 0,0:11:12.90,0:11:19.12,English,,0,0,0,,So it just provides some sort of general information about this binary
Dialogue: 0,0:11:12.90,0:11:19.12,English,,0,0,0,,它只是提供了关于这个二进制文件的一般信息
Dialogue: 0,0:11:19.76,0:11:23.88,English,,0,0,0,,And then there's what's a so called segment header table which is
Dialogue: 0,0:11:19.76,0:11:23.88,English,,0,0,0,,然后就是所谓的节头部表
Dialogue: 0,0:11:24.74,0:11:28.10,English,,0,0,0,,It's only defined for the executable object files
Dialogue: 0,0:11:24.74,0:11:28.10,English,,0,0,0,,它只在可执行目标文件中定义
Dialogue: 0,0:11:28.50,0:11:34.30,English,,0,0,0,,And indicates where all the different segments of the code are going to go in memory
Dialogue: 0,0:11:28.50,0:11:34.30,English,,0,0,0,,并指出代码的所有不同段在内存中的位置
Dialogue: 0,0:11:34.30,0:11:38.87,English,,0,0,0,,So where does your stack go, where do your shared libraries go
Dialogue: 0,0:11:34.30,0:11:38.87,English,,0,0,0,,那么你的栈在哪里，你的共享库去了哪里
Dialogue: 0,0:11:38.87,0:11:42.96,English,,0,0,0,,Where does your that you're initialized and uninitialized data
Dialogue: 0,0:11:38.87,0:11:42.96,English,,0,0,0,,你初始化数据和未初始化数据的位置在哪里
Dialogue: 0,0:11:43.74,0:11:45.00,English,,0,0,0,,Where does your code go
Dialogue: 0,0:11:43.74,0:11:45.00,English,,0,0,0,,你的代码去了哪里
Dialogue: 0,0:11:45.00,0:11:51.62,English,,0,0,0,,Right so all these various sections are defined in the segment header table
Dialogue: 0,0:11:45.00,0:11:51.62,English,,0,0,0,,正确，因此所有这些不同的部分都在段头表中定义
Dialogue: 0,0:11:52.60,0:11:59.60,English,,0,0,0,,And then there's the code itself which is called the .text section for sort of arcane historical reasons
Dialogue: 0,0:11:52.60,0:11:59.60,English,,0,0,0,,然后是代码本身，出于某种神秘的历史原因它被称为.text部分
Dialogue: 0,0:11:59.78,0:12:02.16,English,,0,0,0,,So .text is always code
Dialogue: 0,0:11:59.78,0:12:02.16,English,,0,0,0,, .text 一般是代码
Dialogue: 0,0:12:03.96,0:12:08.26,English,,0,0,0,,And then that's followed by read only data
Dialogue: 0,0:12:03.96,0:12:08.26,English,,0,0,0,,然后是只读数据
Dialogue: 0,0:12:08.42,0:12:11.14,English,,0,0,0,,Such as the jump tables in switch statements
Dialogue: 0,0:12:08.42,0:12:11.14,English,,0,0,0,,比如switch语句中的跳转表
Dialogue: 0,0:12:12.52,0:12:20.02,English,,0,0,0,,So text and read only the .text and .rodata have the property that they're both read-only you don't write to them
Dialogue: 0,0:12:12.52,0:12:20.02,English,,0,0,0,,因此，文本.text和只读.rodata具有以下属性：它们都是只读的，你不会写入它们
Dialogue: 0,0:12:21.90,0:12:24.78,English,,0,0,0,,Then that's followed by the .data section
Dialogue: 0,0:12:21.90,0:12:24.78,English,,0,0,0,,然后是.data部分
Dialogue: 0,0:12:24.96,0:12:29.98,English,,0,0,0,,Which is contains space for all of your initialized global variables
Dialogue: 0,0:12:24.96,0:12:29.98,English,,0,0,0,,它包含了所有初始化全局变量的空间
Dialogue: 0,0:12:31.06,0:12:33.44,English,,0,0,0,,And then there's a section called .bss
Dialogue: 0,0:12:31.06,0:12:33.44,English,,0,0,0,,接下来是一个名为.bss的部分
Dialogue: 0,0:12:33.56,0:12:41.36,English,,0,0,0,,Which defines the uninitialized global variables
Dialogue: 0,0:12:33.56,0:12:41.36,English,,0,0,0,,它定义了未初始化的全局变量
Dialogue: 0,0:12:42.78,0:12:46.82,English,,0,0,0,,Now this doesn't actually take up any space because they're uninitialized droids
Dialogue: 0,0:12:42.78,0:12:46.82,English,,0,0,0,,这个节实际上并没有占用任何实际的空间，因为它们仅仅是未初始化的占位符
Dialogue: 0,0:12:48.10,0:12:50.76,English,,0,0,0,,Ok but there are entries in the symbol table for them
Dialogue: 0,0:12:48.10,0:12:50.76,English,,0,0,0,,好的，但符号表中会有条目
Dialogue: 0,0:12:51.34,0:12:57.30,English,,0,0,0,,And in it at when this program gets loaded these variables are going to need
Dialogue: 0,0:12:51.34,0:12:57.30,English,,0,0,0,,在这个程序加载时会需要这些变量
Dialogue: 0,0:12:58.54,0:13:00.86,English,,0,0,0,,They're actually going to have to have space allocated for them
Dialogue: 0,0:12:58.54,0:13:00.86,English,,0,0,0,,在这个时候就必须为他们分配空间
Dialogue: 0,0:13:01.70,0:13:08.26,English,,0,0,0,,.bss is another one of those sort of arcane names,that cope goes all the way back to the 60s
Dialogue: 0,0:13:01.70,0:13:08.26,English,,0,0,0,,.bss 是另一种神秘的名字，应对可以追溯到60年代
Dialogue: 0,0:13:08.78,0:13:11.94,English,,0,0,0,,For there was IBM instruction called the block started by symbol
Dialogue: 0,0:13:08.78,0:13:11.94,English,,0,0,0,,那时候IBM指令将其称为块符号
Dialogue: 0,0:13:12.42,0:13:16.22,English,,0,0,0,,I think a better way to remember what it means is better save space
Dialogue: 0,0:13:12.42,0:13:16.22,English,,0,0,0,,我认为理解它的意义最好的方式是 better save space (BSS)的缩写
Dialogue: 0,0:13:16.66,0:13:21.66,English,,0,0,0,,Ok so you can,if you have a separate section for the uninitialized variable since uninitialized
Dialogue: 0,0:13:16.66,0:13:21.66,English,,0,0,0,,好的，如果在未初始化过程开始时有一个单独的节用于未初始化的变量，你可以这样理解
Dialogue: 0,0:13:22.16,0:13:29.46,English,,0,0,0,,You don't have to...they don't have to consume any room in the .o file
Dialogue: 0,0:13:22.16,0:13:29.46,English,,0,0,0,,他们不必占用.o文件中的任何空间
Dialogue: 0,0:13:32.78,0:13:35.54,English,,0,0,0,,Ok there's also a section for the symbol table
Dialogue: 0,0:13:32.78,0:13:35.54,English,,0,0,0,,好的接下来还有一个部分是针对符号表的
Dialogue: 0,0:13:37.42,0:13:44.56,English,,0,0,0,,This contained like I said it's an array of structs for procedures global variables
Dialogue: 0,0:13:37.42,0:13:44.56,English,,0,0,0,,就像我之前说的那样它包含程序全局变量的结构数组
Dialogue: 0,0:13:47.72,0:13:50.80,English,,0,0,0,,And anything defined with the static attribute
Dialogue: 0,0:13:47.72,0:13:50.80,English,,0,0,0,,以及我们使用static属性定义的任何内容
Dialogue: 0,0:13:53.02,0:13:57.68,English,,0,0,0,,And each one of these symbols gets an entry in the symbol table
Dialogue: 0,0:13:53.02,0:13:57.68,English,,0,0,0,,并且这些符号中的每一个都在符号表中获得了一个条目
Dialogue: 0,0:13:59.18,0:14:04.56,English,,0,0,0,,And then there's two sections called them that contain relocation info so this is the notes
Dialogue: 0,0:13:59.18,0:14:04.56,English,,0,0,0,,然后有两个部分称为包含重定位信息的部分，称为记录
Dialogue: 0,0:14:06.62,0:14:12.04,English,,0,0,0,,When that linker went and identified all the references to symbols it put a little note to see
Dialogue: 0,0:14:06.62,0:14:12.04,English,,0,0,0,,当链接器去识别所有对符号的引用时，它就会记下一些记录
Dialogue: 0,0:14:12.04,0:14:16.00,English,,0,0,0,,I'm going to have to remember to fix this the reference to this symbol up
Dialogue: 0,0:14:12.04,0:14:16.00,English,,0,0,0,,我不得不记住去安排对这个符号的引用
Dialogue: 0,0:14:16.44,0:14:21.16,English,,0,0,0,,When I actually create the executable
Dialogue: 0,0:14:16.44,0:14:21.16,English,,0,0,0,,在我实际创建可执行文件时
Dialogue: 0,0:14:21.84,0:14:25.26,English,,0,0,0,,So a relocation entry is just like that the linker
Dialogue: 0,0:14:21.84,0:14:25.26,English,,0,0,0,,所以重定向条目就像链接器一样
Dialogue: 0,0:14:25.80,0:14:31.74,English,,0,0,0,,That it's a note that the assembler makes to the linker to say hey you're going to have to fix up this this reference
Dialogue: 0,0:14:25.80,0:14:31.74,English,,0,0,0,,这是一个记录，汇编程序让链接器说“嘿”，你将不得不安排这个引用
Dialogue: 0,0:14:31.74,0:14:38.16,English,,0,0,0,,Because I don't know I don't know where this symbol is actually going to be stored in memory when it's loaded
Dialogue: 0,0:14:31.74,0:14:38.16,English,,0,0,0,,因为我不知道这个符号在加载时实际存储在内存中的位置
Dialogue: 0,0:14:41.56,0:14:43.72,English,,0,0,0,,Okay and then there's a debug section that contains
Dialogue: 0,0:14:41.56,0:14:43.72,English,,0,0,0,,好的，接下来是调试部分
Dialogue: 0,0:14:45.32,0:14:54.22,English,,0,0,0,,Information that relates line numbers to in the source code to line numbers in the machine code
Dialogue: 0,0:14:45.32,0:14:54.22,English,,0,0,0,,它包含了将源代码中的行号与机器代码中的行号相关联的信息
Dialogue: 0,0:14:55.10,0:14:59.40,English,,0,0,0,,Okay and so this is called .debug and this is what you get when you compile with -g
Dialogue: 0,0:14:55.10,0:14:59.40,English,,0,0,0,,好的，所以这叫做 .debug，这是你用-g编译时得到的
Dialogue: 0,0:14:59.98,0:15:06.04,English,,0,0,0,,And then there's a header table that tells you where all these different sections start
Dialogue: 0,0:14:59.98,0:15:06.04,English,,0,0,0,,然后有一个节头表，告诉你所有这些不同部分的起始位置
Dialogue: 0,0:15:08.20,0:15:11.34,English,,0,0,0,,Now to a linker there's three different kinds of symbols
Dialogue: 0,0:15:08.20,0:15:11.34,English,,0,0,0,,现在我们说链接器有三种不同的符号
Dialogue: 0,0:15:12.58,0:15:17.00,English,,0,0,0,,Global symbols are defined in some module m
Dialogue: 0,0:15:12.58,0:15:17.00,English,,0,0,0,,全局符号在一些模块 m 中定义
Dialogue: 0,0:15:17.50,0:15:20.82,English,,0,0,0,,And they can be used by other modules
Dialogue: 0,0:15:17.50,0:15:20.82,English,,0,0,0,,它们可以被其他模块使用
Dialogue: 0,0:15:21.08,0:15:27.14,English,,0,0,0,,Right so I mean did you notice when we...if we have a program that consists of multiple modules
Dialogue: 0,0:15:21.08,0:15:27.14,English,,0,0,0,,是的，所以我的意思是你注意到我们......如果我们有一个由多个模块组成的程序
Dialogue: 0,0:15:27.56,0:15:30.66,English,,0,0,0,,And we compile each one of those modules into a .o file
Dialogue: 0,0:15:27.56,0:15:30.66,English,,0,0,0,,然后我们将每个模块编译成一个 .o 文件
Dialogue: 0,0:15:32.18,0:15:37.42,English,,0,0,0,,Will be calling functions that aren't defined,that are defined by other modules right
Dialogue: 0,0:15:32.18,0:15:37.42,English,,0,0,0,,将调用由其他模块正确定义的未定义的函数
Dialogue: 0,0:15:38.94,0:15:44.64,English,,0,0,0,,Okay so those,but there's no error though that the compiler doesn't throw an error
Dialogue: 0,0:15:38.94,0:15:44.64,English,,0,0,0,,好吧那些，但是虽然编译器没有抛出错误
Dialogue: 0,0:15:44.64,0:15:48.44,English,,0,0,0,,Because it's assuming that those are defined in other modules and
Dialogue: 0,0:15:44.64,0:15:48.44,English,,0,0,0,,因为它假设那些是在其他模块中定义的
Dialogue: 0,0:15:49.10,0:15:53.32,English,,0,0,0,,It assumes the linker will be able to find them in and determine the address
Dialogue: 0,0:15:49.10,0:15:53.32,English,,0,0,0,,它假定链接器能够找到它们并确定地址
Dialogue: 0,0:15:54.40,0:16:04.06,English,,0,0,0,,So anything that's defined with that, any global,either global variable or function name
Dialogue: 0,0:15:54.40,0:16:04.06,English,,0,0,0,,所以用任何全局变量或函数名定义的任何东西
Dialogue: 0,0:16:04.46,0:16:08.82,English,,0,0,0,,That's defined without the static attribute is a global symbol
Dialogue: 0,0:16:04.46,0:16:08.82,English,,0,0,0,,没有静态属性的定义是全局符号
Dialogue: 0,0:16:10.92,0:16:14.92,English,,0,0,0,,Okay now and then external symbols are kind of the flip side of that
Dialogue: 0,0:16:15.08,0:16:19.12,English,,0,0,0,,External symbols are symbols that are referenced by some module
Dialogue: 0,0:16:19.44,0:16:21.54,English,,0,0,0,,But defined in some other module
Dialogue: 0,0:16:21.78,0:16:26.64,English,,0,0,0,,Okay so in a little running example
Dialogue: 0,0:16:27.08,0:16:32.66,English,,0,0,0,,When main.c code called the function some it was referencing an external symbol
Dialogue: 0,0:16:34.20,0:16:42.58,English,,0,0,0,,Okay and then there's local symbols and these are symbols that are defined and referenced within a module
Dialogue: 0,0:16:43.48,0:16:48.12,English,,0,0,0,,Okay and those you create that,this is not this is different from local variables
Dialogue: 0,0:16:48.12,0:16:56.52,English,,0,0,0,,Okay the linker you know local C variables are managed by the compiler on the stack
Dialogue: 0,0:16:57.08,0:17:01.38,English,,0,0,0,,Linker has no idea about local C variables
Dialogue: 0,0:17:01.90,0:17:04.32,English,,0,0,0,,Okay in this context when we talk about a local symbol
Dialogue: 0,0:17:04.92,0:17:12.66,English,,0,0,0,,We're talking about is either, is a global variable or function declared with the static attribute
Dialogue: 0,0:17:14.94,0:17:17.26,English,,0,0,0,,Whose that can only be referenced from within that module
Dialogue: 0,0:17:17.26,0:17:24.02,English,,0,0,0,,So we say that the scope of the a function or global variable defined with the static
Dialogue: 0,0:17:24.52,0:17:27.86,English,,0,0,0,,Attribute is limited to the module that it was defined in
Dialogue: 0,0:17:30.06,0:17:33.78,English,,0,0,0,,Okay so this is in C, this is how we do abstraction
Dialogue: 0,0:17:34.90,0:17:38.24,English,,0,0,0,,And this is how we can create sort of private functions that
Dialogue: 0,0:17:39.36,0:17:44.38,English,,0,0,0,,And private functions that can't be called from outside that module
Dialogue: 0,0:17:45.82,0:17:53.16,English,,0,0,0,,Okay so for instance if we want to make a library in C of functions, we want to make a collection of functions that
Dialogue: 0,0:17:53.61,0:17:57.94,English,,0,0,0,,Other programs can then call it link into their program and call
Dialogue: 0,0:17:58.86,0:18:07.52,English,,0,0,0,,The functions that we want to make visible to other programs are defined without the static attribute
Dialogue: 0,0:18:08.38,0:18:12.10,English,,0,0,0,,And the functions that we want to have private and just be internal
Dialogue: 0,0:18:12.76,0:18:15.36,English,,0,0,0,,We declare what the static attribute okay
Dialogue: 0,0:18:16.00,0:18:20.50,English,,0,0,0,,And that way we get abstraction and we get hiding information hiding
Dialogue: 0,0:18:20.98,0:18:26.86,English,,0,0,0,,And we're only exposing data and functions that we want to expose
Dialogue: 0,0:18:29.60,0:18:33.36,English,,0,0,0,,All right so let's look in detail how the symbol resolution step works
Dialogue: 0,0:18:34.02,0:18:38.36,English,,0,0,0,,We call a example program
Dialogue: 0,0:18:41.26,0:18:44.40,English,,0,0,0,,So here we're referencing a global called array
Dialogue: 0,0:18:45.94,0:18:50.26,English,,0,0,0,,That's defined within main.c
Dialogue: 0,0:18:54.20,0:18:56.60,English,,0,0,0,,Here we're defining main
Dialogue: 0,0:18:57.78,0:18:59.36,English,,0,0,0,,A global called main
Dialogue: 0,0:19:04.28,0:19:06.46,English,,0,0,0,,Here we're referencing a global called sum
Dialogue: 0,0:19:06.78,0:19:08.90,English,,0,0,0,,That's defined in sum.c
Dialogue: 0,0:19:11.10,0:19:17.34,English,,0,0,0,,And val is a local C variable on the stack and linker knows nothing about that okay
Dialogue: 0,0:19:20.00,0:19:23.58,English,,0,0,0,,Now loads i, s which are also local variables
Dialogue: 0,0:19:25.76,0:19:36.88,English,,0,0,0,,Now let's make sure that we understand the difference between local static C variables versus local non static C variables so
Dialogue: 0,0:19:39.74,0:19:44.12,English,,0,0,0,,Here we're defining a local static variable called int
Dialogue: 0,0:19:45.16,0:19:46.84,English,,0,0,0,,Within this function f
Dialogue: 0,0:19:48.46,0:19:53.40,English,,0,0,0,,Now because it's local, its scope is limited to this function
Dialogue: 0,0:19:53.40,0:19:58.88,English,,0,0,0,,So this variable x can only be referenced within function f
Dialogue: 0,0:20:01.06,0:20:07.10,English,,0,0,0,,And similarly for this definition of x in function g
Dialogue: 0,0:20:07.98,0:20:11.08,English,,0,0,0,,Can only be referenced by function g
Dialogue: 0,0:20:11.58,0:20:17.08,English,,0,0,0,,Now what's ,but because it's declared with the static attribute it's not stored on the stack
Dialogue: 0,0:20:17.78,0:20:22.18,English,,0,0,0,,It's actually stored in .data just like a global would be
Dialogue: 0,0:20:22.36,0:20:29.20,English,,0,0,0,,So it's like a global in the sense that it's actually stored in .data rather than the stack
Dialogue: 0,0:20:29.86,0:20:35.48,English,,0,0,0,,But it's like a local C variable in the sense that its scope is limited just to the function that it's defined in
Dialogue: 0,0:20:36.48,0:20:43.48,English,,0,0,0,,Okay so what the compiler will do it'll allocate space for each definition of x
Dialogue: 0,0:20:43.50,0:20:47.28,English,,0,0,0,,So this and it'll give it some name to disambiguate it
Dialogue: 0,0:20:47.28,0:20:49.56,English,,0,0,0,,So maybe it will call this one x.1
Dialogue: 0,0:20:49.98,0:20:51.82,English,,0,0,0,,And maybe this one x.2
Dialogue: 0,0:20:52.80,0:20:57.54,English,,0,0,0,,So these symbols are allocated in .data because
Dialogue: 0,0:20:57.94,0:21:04.18,English,,0,0,0,,Because they're initialized and they get symbol table entries just like any other symbol
Dialogue: 0,0:21:08.00,0:21:11.16,English,,0,0,0,,Okay so I said that during symbol resolution
Dialogue: 0,0:21:11.56,0:21:20.32,English,,0,0,0,,The linker associates each reference,each symbol reference to exactly one unique symbol definition
Dialogue: 0,0:21:21.58,0:21:25.72,English,,0,0,0,,Now how does it do that if there's multiple symbol definitions across all the modules
Dialogue: 0,0:21:27.64,0:21:35.32,English,,0,0,0,,So to understand this will define symbols as being either strong or weak
Dialogue: 0,0:21:35.78,0:21:43.86,English,,0,0,0,,So strong symbols are either procedures or function names or initialize global variables
Dialogue: 0,0:21:44.66,0:21:47.22,English,,0,0,0,,Weak symbols or uninitialized global variables
Dialogue: 0,0:21:49.18,0:21:54.62,English,,0,0,0,,Okay so int foo here is a strong symbol
Dialogue: 0,0:21:54.62,0:21:59.70,English,,0,0,0,,Because it's initialized,we're initializing it. p1 is strong by definition
Dialogue: 0,0:22:00.74,0:22:08.44,English,,0,0,0,,foo is weak in p2.c, this definition of foo is weak
Dialogue: 0,0:22:09.06,0:22:12.78,English,,0,0,0,,Because it's uninitialized and the definition of p2 is strong
Dialogue: 0,0:22:13.64,0:22:17.74,English,,0,0,0,,Okay so that the rules, the linker uses are the following
Dialogue: 0,0:22:19.34,0:22:22.34,English,,0,0,0,,Multiple strong symbols not allowed so that's an error
Dialogue: 0,0:22:24.14,0:22:30.34,English,,0,0,0,,Okay so that means that if across multiple modules we declare a function with the same name
Dialogue: 0,0:22:30.54,0:22:32.72,English,,0,0,0,,The linker will throw an error that's not allowed
Dialogue: 0,0:22:34.44,0:22:42.72,English,,0,0,0,,Given a strong symbol and multiple weak symbols if the linker will always choose the the strong symbol
Dialogue: 0,0:22:44.00,0:22:47.28,English,,0,0,0,,Now remember if we initialize a global variable
Dialogue: 0,0:22:50.94,0:22:56.18,English,,0,0,0,,And we if we declare an initialized global variable across multiple modules that's an error
Dialogue: 0,0:22:56.18,0:22:58.70,English,,0,0,0,,Because those are strong symbols okay by rule one
Dialogue: 0,0:22:59.02,0:23:03.90,English,,0,0,0,,But if we have one strong symbol and multiple weak symbols all with the same name
Dialogue: 0,0:23:04.52,0:23:06.92,English,,0,0,0,,Then the compiler will choose the strong symbol
Dialogue: 0,0:23:08.48,0:23:12.88,English,,0,0,0,,Okay and it will associate all references to that symbol will go to that strong symbol
Dialogue: 0,0:23:14.38,0:23:17.70,English,,0,0,0,,And if there's multiple weak symbols then it just picks an arbitrary one
Dialogue: 0,0:23:18.02,0:23:25.07,English,,0,0,0,,And this is we'll see can be problematic now you can override with this GCC flag called no common
Dialogue: 0,0:23:25.74,0:23:29.94,English,,0,0,0,,And if you declare your function with this no common argument
Dialogue: 0,0:23:31.86,0:23:35.40,English,,0,0,0,,Then multiple weak symbols will throw an error in a linker
Dialogue: 0,0:23:36.46,0:23:39.02,English,,0,0,0,,All right so why do we care about all this stuff well it turns out
Dialogue: 0,0:23:39.80,0:23:44.10,English,,0,0,0,,If you're not aware of this stuff you can run into some really serious problems
Dialogue: 0,0:23:44.12,0:23:47.40,English,,0,0,0,,That are just perplexing and confounding right so
Dialogue: 0,0:23:47.90,0:23:50.68,English,,0,0,0,,Linker errors are like the worst kind
Dialogue: 0,0:23:51.10,0:23:55.78,English,,0,0,0,,They're the hardest kind of debug because people aren't usually aware of what's going on inside their linkers
Dialogue: 0,0:23:57.64,0:24:02.26,English,,0,0,0,,And usually it's only like the very best programmers that really understand
Dialogue: 0,0:24:03.36,0:24:07.78,English,,0,0,0,,You know how these linkers work and what kind of errors they can throw and how to debug them
Dialogue: 0,0:24:08.36,0:24:13.80,English,,0,0,0,,So let me show you some examples of these kind of errors
Dialogue: 0,0:24:15.58,0:24:17.36,English,,0,0,0,,All right so we have a program
Dialogue: 0,0:24:18.24,0:24:22.96,English,,0,0,0,,We have two modules so each of these rectangles corresponds to a module
Dialogue: 0,0:24:23.84,0:24:26.58,English,,0,0,0,,And we're defining p1 in each module so
Dialogue: 0,0:24:28.54,0:24:31.28,English,,0,0,0,,That's too strong symbols that's an error
Dialogue: 0,0:24:34.38,0:24:40.34,English,,0,0,0,,Okay now here we've defining p1 and p2 so we're okay
Dialogue: 0,0:24:40.34,0:24:47.08,English,,0,0,0,,But now we've got two week symbols both are integers variables called x
Dialogue: 0,0:24:48.92,0:24:58.12,English,,0,0,0,,So and if these modules are referencing x the linker will just pick it will just pick one of these to serve as the definition
Dialogue: 0,0:24:59.72,0:25:02.40,English,,0,0,0,,But is this really what you want
Dialogue: 0,0:25:03.60,0:25:09.38,English,,0,0,0,,Now in this case it doesn't really hurt anything because x is declared in both modules as an int
Dialogue: 0,0:25:10.12,0:25:15.06,English,,0,0,0,,All right so it'll just be some integer sized variable
Dialogue: 0,0:25:15.72,0:25:19.22,English,,0,0,0,,That and it'll be somewhere
Dialogue: 0,0:25:20.04,0:25:24.14,English,,0,0,0,,And but it doesn't really matter which one the linker chooses
Dialogue: 0,0:25:25.52,0:25:31.14,English,,0,0,0,,But we start to get into trouble if we declare these weak symbols with different types
Dialogue: 0,0:25:34.02,0:25:40.26,English,,0,0,0,,So here we've declared an int x in one module and a double x in another module
Dialogue: 0,0:25:42.32,0:25:50.28,English,,0,0,0,,So if we write to x, if the linker just arbitrarily chooses this,this symbol definition to use
Dialogue: 0,0:25:51.54,0:25:57.48,English,,0,0,0,,Now this is a symbol that of length 8 of size 8
Dialogue: 0,0:26:00.36,0:26:05.72,English,,0,0,0,,If we anywhere in this program,if the linker chooses that then, anywhere in the program
Dialogue: 0,0:26:06.30,0:26:14.70,English,,0,0,0,,Those references to x will be to this double word,this double word
Dialogue: 0,0:26:16.38,0:26:21.08,English,,0,0,0,,Even in this module if we reference x it'll be an 8-byte right
Dialogue: 0,0:26:21.10,0:26:25.06,English,,0,0,0,,So it will overwrite y with the
Dialogue: 0,0:26:29.20,0:26:30.22,English,,0,0,0,,Hi order excuse me
Dialogue: 0,0:26:31.54,0:26:38.80,English,,0,0,0,,[student speaking]
Dialogue: 0,0:26:38.84,0:26:44.68,English,,0,0,0,, Oh no it's completely,it's just pick one arbitrarily
Dialogue: 0,0:26:44.96,0:26:47.40,English,,0,0,0,,And you don't know
Dialogue: 0,0:26:47.92,0:26:48.52,English,,0,0,0,,I mean it
Dialogue: 0,0:26:53.44,0:27:01.92,English,,0,0,0,,Now this is here's a problem we've defined a strong symbol x because we've initializes
Dialogue: 0,0:27:01.92,0:27:13.58,English,,0,0,0,,So the linker will always,will associate all references to x to this integer sized this integer sized symbol
Dialogue: 0,0:27:16.74,0:27:17.80,English,,0,0,0,,So if we write
Dialogue: 0,0:27:30.52,0:27:34.14,English,,0,0,0,,Oh yeah right,so rights to x here
Dialogue: 0,0:27:36.14,0:27:40.68,English,,0,0,0,,This will be a double in this module but it will overwrite y in this module
Dialogue: 0,0:27:40.94,0:27:48.36,English,,0,0,0,,So that's really nasty
Dialogue: 0,0:27:48.76,0:27:51.60,English,,0,0,0,,And here we were defining a strong symbol x
Dialogue: 0,0:27:52.40,0:28:00.90,English,,0,0,0,,So references to x in the second module will always get it will refer to this initialized variable which might not
Dialogue: 0,0:28:01.68,0:28:04.42,English,,0,0,0,,So it might not be what you want right
Dialogue: 0,0:28:06.12,0:28:10.14,English,,0,0,0,,You may be assuming that it's uninitialized in your code
Dialogue: 0,0:28:12.22,0:28:16.46,English,,0,0,0,,Okay and then you get the, the ultimate nightmare scenario is suppose
Dialogue: 0,0:28:17.06,0:28:21.62,English,,0,0,0,,You know because we're following a standard ABI we can compile our code with multiple compilers
Dialogue: 0,0:28:22.20,0:28:24.80,English,,0,0,0,,And this actually happens in some oh yes questions
Dialogue: 0,0:28:25.06,0:28:34.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:34.76,0:28:36.54,English,,0,0,0,,Oh yeah actually you're right
Dialogue: 0,0:28:37.40,0:28:41.58,English,,0,0,0,,It will still take preference and and you'll be writing a for by quantity
Dialogue: 0,0:28:41.58,0:28:45.02,English,,0,0,0,,Which is what you want so that slides not quite right
Dialogue: 0,0:28:45.50,0:28:55.50,English,,0,0,0,,So oh yeah what is the point of doing the static versus non static
Dialogue: 0,0:28:55.50,0:29:02.26,English,,0,0,0,,If it's always being referenced just locally in constantly what is the point of declaring  it's time
Dialogue: 0,0:29:02.60,0:29:05.56,English,,0,0,0,,-is it it stores it in like -no no no it's
Dialogue: 0,0:29:06.86,0:29:11.42,English,,0,0,0,,If you reference up if you reference a variable
Dialogue: 0,0:29:12.84,0:29:15.46,English,,0,0,0,,You mean so a variable is defined in your module
Dialogue: 0,0:29:16.04,0:29:22.70,English,,0,0,0,,And then you...with the static...right
Dialogue: 0,0:29:24.06,0:29:26.54,English,,0,0,0,,Oh they're both,they're both local
Dialogue: 0,0:29:26.98,0:29:31.30,English,,0,0,0,,So you do this if you want to value two to retain
Dialogue: 0,0:29:31.96,0:29:36.86,English,,0,0,0,,From if you want if you want that variable to retain value from invocation to invocation
Dialogue: 0,0:29:38.32,0:29:42.62,English,,0,0,0,,So suppose you it's usually a bad idea as we'll see when we study threads
Dialogue: 0,0:29:42.62,0:29:44.90,English,,0,0,0,,Because it makes your code non thread safe
Dialogue: 0,0:29:45.62,0:29:49.40,English,,0,0,0,,But like early like random number generators
Dialogue: 0,0:29:50.18,0:29:53.28,English,,0,0,0,,Would it would compute a pseudo-random number
Dialogue: 0,0:29:53.78,0:29:55.84,English,,0,0,0,,And then it would store it in a static variable
Dialogue: 0,0:29:56.28,0:30:01.30,English,,0,0,0,,And then use that as the the starting value for the next time you call that function
Dialogue: 0,0:30:01.74,0:30:06.70,English,,0,0,0,,So whenever you want values to persist across function invocation to reduce static
Dialogue: 0,0:30:07.26,0:30:25.04,English,,0,0,0,,Yes something really crash
Dialogue: 0,0:30:25.04,0:30:26.20,English,,0,0,0,,Well wait a minute let me...
Dialogue: 0,0:30:27.50,0:30:34.04,English,,0,0,0,,Let me get this straight writes to x and p2 will actually correspond to the memory
Dialogue: 0,0:30:34.30,0:30:40.78,English,,0,0,0,,Look that it will actually go to the memory location I'm sorry I need to amend that
Dialogue: 0,0:30:41.74,0:30:47.60,English,,0,0,0,,So writes to x in p2 will be 8 bytes
Dialogue: 0,0:30:47.64,0:30:51.32,English,,0,0,0,,Because the compiler you know the compiler knows that it's a double
Dialogue: 0,0:30:52.70,0:30:59.84,English,,0,0,0,,But it'll go to a memory location that's only 4 bytes
Dialogue: 0,0:31:00.54,0:31:03.32,English,,0,0,0,,Because x because the linker chose the strong symbol
Dialogue: 0,0:31:04.46,0:31:08.34,English,,0,0,0,,Okay so the rights to x and p2 will actually overwrite y
Dialogue: 0,0:31:12.98,0:31:14.06,English,,0,0,0,,I'm sorry yes question
Dialogue: 0,0:31:14.06,0:31:23.12,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:23.18,0:31:25.08,English,,0,0,0,,That's just usually the way it happens
Dialogue: 0,0:31:25.70,0:31:33.42,English,,0,0,0,,You know...[student speaking]
Dialogue: 0,0:31:33.46,0:31:38.46,English,,0,0,0,,No no no global variables go in data they don't go on the stack
Dialogue: 0,0:31:39.36,0:31:41.80,English,,0,0,0,,But usually if you define local variables in a function
Dialogue: 0,0:31:42.26,0:31:46.38,English,,0,0,0,,It will put them,it will allocate them one after the other on the stack
Dialogue: 0,0:31:49.68,0:31:55.66,English,,0,0,0,,Okay all right so all this discussion about
Dialogue: 0,0:31:57.52,0:32:01.38,English,,0,0,0,,These weird strong weak symbol rules that the linker have
Dialogue: 0,0:32:01.38,0:32:04.92,English,,0,0,0,,It's another reason to avoid global variables if you can
Dialogue: 0,0:32:07.32,0:32:12.40,English,,0,0,0,,Now if you need to declare a global see if you can declare it static
Dialogue: 0,0:32:12.40,0:32:16.08,English,,0,0,0,,Because that'll limited scope to the the module that it's declared in
Dialogue: 0,0:32:16.34,0:32:18.10,English,,0,0,0,,So that's a good idea if you can do it
Dialogue: 0,0:32:18.88,0:32:21.24,English,,0,0,0,,And if you define a global variable initialize it
Dialogue: 0,0:32:22.90,0:32:31.26,English,,0,0,0,,So that you'll find,you'll discover if you have multiple initialize global symbols with the same name in your code
Dialogue: 0,0:32:32.46,0:32:35.90,English,,0,0,0,,And then if you want to it's always good practice
Dialogue: 0,0:32:35.90,0:32:41.70,English,,0,0,0,,If you're referencing an external variable to tell the compiler about it by using the x turn attribute
Dialogue: 0,0:32:44.94,0:32:46.29,English,,0,0,0,,All right
Dialogue: 0,0:32:46.74,0:32:53.48,English,,0,0,0,,So now at this point the linker has associated every symbol reference  with some simple definition
Dialogue: 0,0:32:54.70,0:32:59.56,English,,0,0,0,,Now it has to take all those object relocatable object files and smush them together
Dialogue: 0,0:32:59.80,0:33:03.84,English,,0,0,0,,And create like one big executable
Dialogue: 0,0:33:04.92,0:33:08.54,English,,0,0,0,,So suppose with our example a little running example
Dialogue: 0,0:33:09.72,0:33:18.32,English,,0,0,0,,Each main.o and sum.o contain a code and initialize data
Dialogue: 0,0:33:19.08,0:33:22.96,English,,0,0,0,,sum.o doesn't have any initialize data it just has code
Dialogue: 0,0:33:23.62,0:33:28.34,English,,0,0,0,,And then there's their system code that actually runs before and after your program so
Dialogue: 0,0:33:29.88,0:33:35.46,English,,0,0,0,,When your program run it actually starts executing a startup code from  from lib.c
Dialogue: 0,0:33:36.12,0:33:44.46,English,,0,0,0,,That that sort of initializes things and then the last thing that it does is it calls main and passes it rc and rv
Dialogue: 0,0:33:46.18,0:33:48.38,English,,0,0,0,,Okay and then when you're, when your program exits
Dialogue: 0,0:33:49.78,0:33:55.00,English,,0,0,0,,Well that's a cyst call,but if your program if your main function routine does a return
Dialogue: 0,0:33:55.46,0:33:59.54,English,,0,0,0,,Then it returns back to that startup code which then doesn't exit okay
Dialogue: 0,0:34:00.52,0:34:07.62,English,,0,0,0,,So this is just...so this this consists of of text and data as well
Dialogue: 0,0:34:09.10,0:34:13.16,English,,0,0,0,,And so when the linker relocates these object files
Dialogue: 0,0:34:15.28,0:34:20.84,English,,0,0,0,,It takes all of the code the text sections from each of the modules
Dialogue: 0,0:34:21.80,0:34:29.96,English,,0,0,0,,And puts them together contiguously init in the .text section for the executable object file
Dialogue: 0,0:34:30.30,0:34:34.42,English,,0,0,0,,Ok so it just puts them together in some order that it determines
Dialogue: 0,0:34:34.76,0:34:40.40,English,,0,0,0,,And it creates a combined .text section in the executable
Dialogue: 0,0:34:40.82,0:34:46.18,English,,0,0,0,,That contains all of the system code and the all of the all of the code defined in the modules
Dialogue: 0,0:34:46.84,0:34:51.24,English,,0,0,0,,And then it does the same thing with the data takes all the .data
Dialogue: 0,0:34:51.96,0:34:55.92,English,,0,0,0,,Sections from the various object files and puts them together
Dialogue: 0,0:34:56.42,0:35:00.62,English,,0,0,0,,In one combined .data section in the executable
Dialogue: 0,0:35:02.52,0:35:07.32,English,,0,0,0,,And it also emerges the symbol tables and in the debug information as well
Dialogue: 0,0:35:09.14,0:35:15.12,English,,0,0,0,,Now when it just the act the act of sort of
Dialogue: 0,0:35:15.64,0:35:19.98,English,,0,0,0,,Relocating these object files requires the linker
Dialogue: 0,0:35:20.56,0:35:23.54,English,,0,0,0,,To figure out where it's going to actually store these
Dialogue: 0,0:35:24.42,0:35:31.24,English,,0,0,0,,These different these different symbols when the system gets, when this program gets loaded
Dialogue: 0,0:35:31.26,0:35:36.00,English,,0,0,0,,So it has to pick an address for main that
Dialogue: 0,0:35:37.30,0:35:41.14,English,,0,0,0,,That function will start at some absolute address
Dialogue: 0,0:35:41.22,0:35:46.42,English,,0,0,0,,It's going to have... it's going to do the same for swap,so for all the all the data arrays right
Dialogue: 0,0:35:51.16,0:36:00.16,English,,0,0,0,,And but the problem is that when this code is compiled,the compiler doesn't know what addresses the linker is going to pick
Dialogue: 0,0:36:02.40,0:36:09.10,English,,0,0,0,,So the compiler creates these reminders to the linker called relocation entries
Dialogue: 0,0:36:09.10,0:36:13.84,English,,0,0,0,,Which are then stored in the relocation sections of the the object file
Dialogue: 0,0:36:14.94,0:36:20.22,English,,0,0,0,,And these relocation entries are instructions to the linker that's something
Dialogue: 0,0:36:21.62,0:36:24.88,English,,0,0,0,,That there's a reference to a symbol that's going to have to be patched up
Dialogue: 0,0:36:25.48,0:36:30.98,English,,0,0,0,,When the the code is actually relocated and merged into the executable
Dialogue: 0,0:36:32.42,0:36:36.24,English,,0,0,0,,So let's look at a couple of these a couple of examples so in
Dialogue: 0,0:36:37.04,0:36:44.38,English,,0,0,0,,Our in our main.c module there was a reference to this global symbol called array
Dialogue: 0,0:36:46.58,0:36:52.06,English,,0,0,0,,Okay and then there was also a reference to this global symbol sum which is the function
Dialogue: 0,0:36:53.54,0:36:57.32,English,,0,0,0,,So the compiler creates two relocation entries
Dialogue: 0,0:36:57.90,0:37:00.84,English,,0,0,0,,The first one for the reference to the array a
Dialogue: 0,0:37:01.58,0:37:06.30,English,,0,0,0,,So here we're moving remember %edi is the first argument
Dialogue: 0,0:37:07.00,0:37:12.18,English,,0,0,0,,So remember a sum function takes the address of the of array
Dialogue: 0,0:37:12.68,0:37:15.50,English,,0,0,0,,Of the input array as its argument
Dialogue: 0,0:37:16.92,0:37:27.00,English,,0,0,0,,So this move we're moving the address of the array into %edi for the first argument
Dialogue: 0,0:37:27.92,0:37:30.36,English,,0,0,0,,But the compiler doesn't know what that address is going to be
Dialogue: 0,0:37:31.24,0:37:34.56,English,,0,0,0,,Right so it just it just it just
Dialogue: 0,0:37:35.84,0:37:42.58,English,,0,0,0,,It just moves in an immediate value of 0 into %edi temporarily right so you can see this is all zeros
Dialogue: 0,0:37:43.96,0:37:50.02,English,,0,0,0,,The bf is the move instruction and then there's all zeros for now
Dialogue: 0,0:37:51.82,0:37:57.92,English,,0,0,0,,And then it places this relocation entry in the relocation section of main.o
Dialogue: 0,0:37:58.64,0:38:03.44,English,,0,0,0,,And it says to the linker at offset a
Dialogue: 0,0:38:04.96,0:38:09.58,English,,0,0,0,,So these let me remind you these are main.o
Dialogue: 0,0:38:10.52,0:38:13.90,English,,0,0,0,,Module only contains one function
Dialogue: 0,0:38:14.92,0:38:22.96,English,,0,0,0,,So that function starts that offsets zero in the code section of the module in the .text section of the module
Dialogue: 0,0:38:23.90,0:38:28.84,English,,0,0,0,,If there were other functions in this module they would follow immediately after
Dialogue: 0,0:38:29.48,0:38:36.98,English,,0,0,0,,Ok and it so you can see what the compiler it's just generating offsets of these instructions
Dialogue: 0,0:38:37.62,0:38:39.92,English,,0,0,0,,From the beginning of the .text section
Dialogue: 0,0:38:41.02,0:38:46.50,English,,0,0,0,,And it includes this relocation entry which says to the linker hey
Dialogue: 0,0:38:46.98,0:38:54.38,English,,0,0,0,,When you're relocating main.o add offset a in this .text section
Dialogue: 0,0:38:55.48,0:39:03.36,English,,0,0,0,,You've got a reference,a reference to an array in the form of a 32-bit address
Dialogue: 0,0:39:04.52,0:39:11.40,English,,0,0,0,,Ok so that,so eventually the linker is going to have to patch up these
Dialogue: 0,0:39:12.28,0:39:15.04,English,,0,0,0,,So this is address , this is address a
Dialogue: 0,0:39:15.04,0:39:18.30,English,,0,0,0,,It's going to have to patch up the four bytes starting at address a
Dialogue: 0,0:39:19.82,0:39:24.76,English,,0,0,0,,With the absolute address of the symbol array
Dialogue: 0,0:39:28.58,0:39:38.70,English,,0,0,0,,And then similarly the reference to,the reference to,this the reference to this function some
Dialogue: 0,0:39:39.72,0:39:44.28,English,,0,0,0,,The compiler has no idea where some actually will end up
Dialogue: 0,0:39:44.28,0:39:49.24,English,,0,0,0,,It doesn't even know what module it's in or even if it's, even if it is defined in a module
Dialogue: 0,0:39:49.94,0:39:55.48,English,,0,0,0,,So in this case it just it does a call with all zeros
Dialogue: 0,0:39:58.14,0:40:01.72,English,,0,0,0,,And then it adds this relocation entry that says to the linker
Dialogue: 0,0:40:03.10,0:40:16.16,English,,0,0,0,,At offset f you've got a four byte pc-relative reference to a function,to assemble called sum
Dialogue: 0,0:40:17.78,0:40:23.66,English,,0,0,0,,And then it this is sort of a arcane detail that but and it includes
Dialogue: 0,0:40:24.24,0:40:27.96,English,,0,0,0,,There's an option to include a bias in the in the offset
Dialogue: 0,0:40:28.66,0:40:36.26,English,,0,0,0,,And since we're using since calls are always resolved using pc-relative addressing
Dialogue: 0,0:40:36.78,0:40:43.18,English,,0,0,0,,The value that's going to be placed here at these four bytes that offset f
Dialogue: 0,0:40:43.70,0:40:48.40,English,,0,0,0,,Is going to be an offset from the current %rip value or program or counter value
Dialogue: 0,0:40:49.44,0:40:53.66,English,,0,0,0,,And since the program counter always points to the nest get next instruction
Dialogue: 0,0:40:55.66,0:40:59.18,English,,0,0,0,,It includes this which is four bytes away it includes this
Dialogue: 0,0:40:59.54,0:41:01.40,English,,0,0,0,,This offset of minus four
Dialogue: 0,0:41:02.96,0:41:11.22,English,,0,0,0,,So I talked about it in detail in the book if you really want to know how this works
Dialogue: 0,0:41:11.32,0:41:17.98,English,,0,0,0,,But just the point here is that there's enough information for the linker to actually fill in the right address
Dialogue: 0,0:41:18.98,0:41:21.34,English,,0,0,0,,So now if we look at the relocated text section
Dialogue: 0,0:41:21.34,0:41:27.64,English,,0,0,0,,So if we compile this code into an executable and then we use object on to disassemble it
Dialogue: 0,0:41:28.52,0:41:34.36,English,,0,0,0,,Then what you see is this reference here
Dialogue: 0,0:41:34.36,0:41:38.58,English,,0,0,0,,Where we move the address of the address of a into %edi
Dialogue: 0,0:41:39.96,0:41:50.20,English,,0,0,0,,Those four bytes which were original zero have now been updated with the actual address of array in memory at runtime
Dialogue: 0,0:41:50.70,0:41:57.60,English,,0,0,0,,Okay so the linkers decided that the array is going to go at address 0x601018
Dialogue: 0,0:41:58.46,0:42:06.54,English,,0,0,0,,And then it's actually patched that the four bytes in the cup in the in the move instruction with that absolute address
Dialogue: 0,0:42:08.90,0:42:12.28,English,,0,0,0,,And the call to sum is...it's also been updated
Dialogue: 0,0:42:13.18,0:42:15.02,English,,0,0,0,,But this one's interesting right that
Dialogue: 0,0:42:15.46,0:42:22.04,English,,0,0,0,,So the address it's been updated with the pc relative address of five
Dialogue: 0,0:42:23.42,0:42:25.42,English,,0,0,0,,Okay so when this program runs
Dialogue: 0,0:42:27.34,0:42:28.98,English,,0,0,0,,This call instruction
Dialogue: 0,0:42:30.54,0:42:39.68,English,,0,0,0,,What it will do when it when it determines when it computes the absolute address of the function sum
Dialogue: 0,0:42:40.84,0:42:49.10,English,,0,0,0,,It will take...
Dialogue: 0,0:42:49.26,0:43:00.36,English,,0,0,0,,It will take the current value of the program counter which is the next instruction so 0x4004e3
Dialogue: 0,0:43:01.44,0:43:07.42,English,,0,0,0,,And it will add to it whatever value is in this immediate field
Dialogue: 0,0:43:08.16,0:43:13.84,English,,0,0,0,,Okay which is a two's comp... interpret it as a two's complement integer so it can go
Dialogue: 0,0:43:14.76,0:43:18.22,English,,0,0,0,,It can be relative you can go - or +
Dialogue: 0,0:43:18.88,0:43:28.44,English,,0,0,0,,In this case it's saying that the function that you want to call is at 0x4004e3 + 5
Dialogue: 0,0:43:29.54,0:43:34.66,English,,0,0,0,,Which is 0x4004e8 which is the address of some
Dialogue: 0,0:43:35.80,0:43:40.38,English,,0,0,0,,Okay and so the linker does that the compiler has all the smarts
Dialogue: 0,0:43:40.38,0:43:43.46,English,,0,0,0,,The compiler computed the relocation entry
Dialogue: 0,0:43:43.70,0:43:49.02,English,,0,0,0,,The linker is just blindly going through each of those relocation entries and just doing what it's told
Dialogue: 0,0:43:50.44,0:43:58.74,English,,0,0,0,,Okay but the net result is that now all of these these references have been patched up with valid absolute addresses
Dialogue: 0,0:44:04.90,0:44:08.34,English,,0,0,0,,Now once the linkers created an object file
Dialogue: 0,0:44:10.20,0:44:13.92,English,,0,0,0,,That object file can be loaded the code and data
Dialogue: 0,0:44:13.92,0:44:18.80,English,,0,0,0,,And that object file can be loaded directly into memory with no further modification
Dialogue: 0,0:44:20.32,0:44:29.72,English,,0,0,0,,Ok so the if you look at all of the read-only sections in the executable
Dialogue: 0,0:44:30.62,0:44:33.60,English,,0,0,0,,So there's this init section which
Dialogue: 0,0:44:35.40,0:44:41.18,English,,0,0,0,,We're not to worry about that, all the code is in the .text and things like jump tables are in .rodata
Dialogue: 0,0:44:43.58,0:44:48.18,English,,0,0,0,,All of this data can be loaded directly into memory as is
Dialogue: 0,0:44:49.64,0:44:53.90,English,,0,0,0,,Okay so these bytes can just be copied directly into memory
Dialogue: 0,0:44:54.82,0:44:58.78,English,,0,0,0,,And that forms the so called a read-only code segment
Dialogue: 0,0:45:02.44,0:45:10.60,English,,0,0,0,,The data in the .data and .bss  sections can also be copied directly into memory
Dialogue: 0,0:45:13.40,0:45:19.86,English,,0,0,0,,And in the case of the variables and .data they'll be initialized to a value that's stored in the symbol table
Dialogue: 0,0:45:22.96,0:45:27.34,English,,0,0,0,,So we're drawing a memory here
Dialogue: 0,0:45:27.34,0:45:36.34,English,,0,0,0,,This is the (memory) address space that every Linux program sees
Dialogue: 0,0:45:37.56,0:45:46.02,English,,0,0,0,,And we're drawing addresses starting from 0 and going up increasing as we grow up
Dialogue: 0,0:45:47.62,0:45:58.04,English,,0,0,0,,And every program is loaded at this the same address  0x400000
Dialogue: 0,0:45:59.76,0:46:06.36,English,,0,0,0,,And so the the code comes directly from the object file the data comes directly from the object file
Dialogue: 0,0:46:07.04,0:46:09.68,English,,0,0,0,,And then that's followed by a runtime heap
Dialogue: 0,0:46:10.18,0:46:12.50,English,,0,0,0,,Which is created and managed by malloc
Dialogue: 0,0:46:13.14,0:46:16.38,English,,0,0,0,,So when you need dynamically need to allocate memory
Dialogue: 0,0:46:16.42,0:46:22.22,English,,0,0,0,,Like using malloc that memory comes out of this heap
Dialogue: 0,0:46:22.30,0:46:26.94,English,,0,0,0,,Which starts immediately following the data segment and grows upwards
Dialogue: 0,0:46:29.42,0:46:39.20,English,,0,0,0,,The stack is at the very top of the visible memory that's available to application programs
Dialogue: 0,0:46:40.02,0:46:46.94,English,,0,0,0,,The memory above that is restricted to the kernel
Dialogue: 0,0:46:47.62,0:46:51.92,English,,0,0,0,,Okay so if you try to access those memory locations you'll get a seg fault
Dialogue: 0,0:46:54.00,0:46:58.72,English,,0,0,0,,And then the stack as we know grows down so this is managed and created a run time
Dialogue: 0,0:46:59.50,0:47:03.88,English,,0,0,0,,And then there's this region somewhere in this huge gap between the stack and the heap
Dialogue: 0,0:47:05.54,0:47:14.74,English,,0,0,0,,There's a region for shared libraries so the .so files all get loaded into this memory mapped region for shared libraries
Dialogue: 0,0:47:17.90,0:47:21.84,English,,0,0,0,,Now that the top of the heap is indicated by this global variable
Dialogue: 0,0:47:23.12,0:47:26.52,English,,0,0,0,,Maintained by the kernel called break brk
Dialogue: 0,0:47:27.38,0:47:33.60,English,,0,0,0,,And the the top of the stack as we know is maintained by the general purpose register %rsp
Dialogue: 0,0:47:34.58,0:47:38.00,English,,0,0,0,,Now there's a little bit of a...this is a little bit of a simplification
Dialogue: 0,0:47:38.00,0:47:42.64,English,,0,0,0,,If you actually look at the addresses returned by malloc
Dialogue: 0,0:47:43.44,0:47:46.34,English,,0,0,0,,There's actually,a there's actually two heaps
Dialogue: 0,0:47:46.34,0:47:50.88,English,,0,0,0,,There's a heap up here and in the high memory that grows down
Dialogue: 0,0:47:51.16,0:47:54.20,English,,0,0,0,,That's used for large objects,very large
Dialogue: 0,0:47:54.66,0:47:56.24,English,,0,0,0,,You know if you mount like a whole bunch of space
Dialogue: 0,0:47:56.80,0:48:01.72,English,,0,0,0,,And then the heap that grows up is  is reserved for smaller smaller objects
Dialogue: 0,0:48:03.26,0:48:04.60,English,,0,0,0,,So I'm not really sure why they do this
Dialogue: 0,0:48:04.62,0:48:11.02,English,,0,0,0,,I think it allows them to have separate allocation algorithms for large objects and small objects
Dialogue: 0,0:48:19.32,0:48:25.04,English,,0,0,0,,Okay so one of the real advantages of linking is that allows us to create libraries of things
Dialogue: 0,0:48:26.26,0:48:29.12,English,,0,0,0,,So it's always something we want to do as programmers we always...
Dialogue: 0,0:48:30.92,0:48:36.72,English,,0,0,0,,We always want to create abstractions and then present those abstractions to users
Dialogue: 0,0:48:37.42,0:48:40.48,English,,0,0,0,,Right and we do that by creating libraries defining an api
Dialogue: 0,0:48:40.48,0:48:40.98,English,,0,0,0,,Yes
Dialogue: 0,0:48:41.70,0:48:50.76,English,,0,0,0,,[student speaking]
Dialogue: 0,0:48:53.20,0:48:56.54,English,,0,0,0,,I think it just is...no no it
Dialogue: 0,0:48:59.02,0:49:04.92,English,,0,0,0,,Actually that's a good question I... the things I've done it just grows until it runs out of memory right there
Dialogue: 0,0:49:06.22,0:49:10.06,English,,0,0,0,,So I don't think actually that's a really good question I mean I've...
Dialogue: 0,0:49:10.79,0:49:14.66,English,,0,0,0,,I've done those experiments and it eventually reaches some limit
Dialogue: 0,0:49:21.38,0:49:24.96,English,,0,0,0,,Yeah I don't know it's a very large number
Dialogue: 0,0:49:29.34,0:49:36.18,English,,0,0,0,,But I so you know as programmers we always want to abstract define apis
Dialogue: 0,0:49:36.50,0:49:42.30,English,,0,0,0,,Implement package up those api's and make them available to to other programmers
Dialogue: 0,0:49:44.78,0:49:50.24,English,,0,0,0,,So how can we actually do that how can we make commonly used functions available to other programmers
Dialogue: 0,0:49:50.56,0:49:53.64,English,,0,0,0,,Well one thing given what we've learned so far
Dialogue: 0,0:49:54.22,0:50:00.30,English,,0,0,0,, You could just take all the functions and put them all in a single big C file right
Dialogue: 0,0:50:01.08,0:50:07.74,English,,0,0,0,,And then programmers would just link that C file into their programs if they want to use them right
Dialogue: 0,0:50:08.48,0:50:13.20,English,,0,0,0,,Another option would be to take that might get kind of unwieldy if it's a big library right
Dialogue: 0,0:50:13.42,0:50:16.30,English,,0,0,0,,Lipsi has hundreds and hundreds of functions
Dialogue: 0,0:50:17.44,0:50:21.50,English,,0,0,0,,So another option would might be to just take each function put it in a separate file
Dialogue: 0,0:50:22.20,0:50:25.56,English,,0,0,0,,And then compile them all together and compile and link them all together
Dialogue: 0,0:50:27.22,0:50:33.48,English,,0,0,0,,So this is more space and time efficient than then the first option
Dialogue: 0,0:50:34.72,0:50:37.50,English,,0,0,0,,But it seems like it would be burdensome on the programmer because
Dialogue: 0,0:50:38.18,0:50:42.70,English,,0,0,0,,The program would have to know where all the all these functions were and put them in make files
Dialogue: 0,0:50:42.70,0:50:50.56,English,,0,0,0,,It'd just be a lot of you know this you could end up with a ridiculously large command line to GCC
Dialogue: 0,0:50:52.80,0:50:57.96,English,,0,0,0,,So that one solution to this problem is that
Dialogue: 0,0:50:58.24,0:51:03.82,English,,0,0,0,,The first solution that the developers of Unix came up with us
Dialogue: 0,0:51:04.10,0:51:05.54,English,,0,0,0,,Something called a static library
Dialogue: 0,0:51:06.44,0:51:11.58,English,,0,0,0,,So the the idea where the static library is that you create this archive  called a .a file
Dialogue: 0,0:51:12.50,0:51:19.18,English,,0,0,0,,Which is it's just a collection of .o file where each .o file contains a function
Dialogue: 0,0:51:19.46,0:51:25.65,English,,0,0,0,,Ok so you take all the functions in your library you use option two to create a bunch of .o files
Dialogue: 0,0:51:26.30,0:51:31.26,English,,0,0,0,,And then you use a program called an archive or AR  to take those .o files
Dialogue: 0,0:51:31.82,0:51:37.30,English,,0,0,0,,Put them together in a all together in a big file called an archive
Dialogue: 0,0:51:37.94,0:51:44.14,English,,0,0,0,,With a table of contents at the beginning that tells you the offset of each one of the .o files
Dialogue: 0,0:51:44.54,0:51:49.92,English,,0,0,0,,Ok so an archive is just this concatenated collection of .o files
Dialogue: 0,0:51:53.12,0:51:57.64,English,,0,0,0,,And then and then you link you pass that archive to the linker
Dialogue: 0,0:51:58.06,0:52:03.62,English,,0,0,0,,And it only takes the .o files that are actually referenced  and links them into the code
Dialogue: 0,0:52:03.74,0:52:07.42,English,,0,0,0,,Right so it's a more efficient way you can have a huge archive
Dialogue: 0,0:52:07.78,0:52:10.26,English,,0,0,0,,But like lib.c but if you only call printf
Dialogue: 0,0:52:11.32,0:52:13.88,English,,0,0,0,,The only .o file you get is printf.o
Dialogue: 0,0:52:15.50,0:52:17.90,English,,0,0,0,,Okay so the way this works is
Dialogue: 0,0:52:18.80,0:52:19.96,English,,0,0,0,,As before we take
Dialogue: 0,0:52:24.76,0:52:28.00,English,,0,0,0,,We take all the functions we want to put in our library
Dialogue: 0,0:52:29.40,0:52:32.48,English,,0,0,0,,We run them through our translators to get .o files
Dialogue: 0,0:52:33.30,0:52:37.14,English,,0,0,0,,We pass those to the archiver to get a the archive
Dialogue: 0,0:52:37.14,0:52:40.74,English,,0,0,0,,So in this case libc.a
Dialogue: 0,0:52:42.02,0:52:46.16,English,,0,0,0,,And which has this code for printf that we might want to use
Dialogue: 0,0:52:47.32,0:52:52.42,English,,0,0,0,,Right and so we can recreate that archive anytime we want
Dialogue: 0,0:52:52.42,0:52:55.62,English,,0,0,0,,So if one of these functions changes like say printf changes
Dialogue: 0,0:52:56.10,0:53:03.51,English,,0,0,0,,You just re archive the dot recompile printf and then re archive all of the .o files
Dialogue: 0,0:53:04.40,0:53:07.30,English,,0,0,0,,So in libc it's about 1500 object files
Dialogue: 0,0:53:07.36,0:53:14.42,English,,0,0,0,,And it's archived things like printf,scanf,simple integer math and there's also a math library
Dialogue: 0,0:53:15.84,0:53:20.92,English,,0,0,0,,Which has you know several hundred common functions for things like
Dialogue: 0,0:53:21.66,0:53:26.50,English,,0,0,0,,Floating point math sin,cos,tan gent etc
Dialogue: 0,0:53:27.98,0:53:34.40,English,,0,0,0,,These libraries the convention is that a library always is prefixed with lib with lib and then
Dialogue: 0,0:53:35.06,0:53:38.72,English,,0,0,0,,And then sort of new some indication of what it what it does
Dialogue: 0,0:53:42.64,0:53:45.46,English,,0,0,0,,So now let's see how linking with these static libraries would work
Dialogue: 0,0:53:45.52,0:53:47.84,English,,0,0,0,,So I've created a little example here
Dialogue: 0,0:53:50.36,0:53:53.38,English,,0,0,0,,I've created a library called libvector.a
Dialogue: 0,0:53:54.40,0:53:57.38,English,,0,0,0,,And it consists of functions that manipulate vectors
Dialogue: 0,0:53:57.82,0:54:00.68,English,,0,0,0,,And this is a real simple library it just adds
Dialogue: 0,0:54:00.90,0:54:07.56,English,,0,0,0,,There's a function to add two vectors x and y together and return the result in z
Dialogue: 0,0:54:10.10,0:54:16.00,English,,0,0,0,,And then another similar function that will do pairwise multiplication of two vectors so
Dialogue: 0,0:54:16.44,0:54:20.46,English,,0,0,0,,x[i]*y[i] equals z[i]
Dialogue: 0,0:54:22.06,0:54:28.94,English,,0,0,0,,Now I compile these two programs and pack I want to package them into an archive called libvector.a
Dialogue: 0,0:54:29.70,0:54:34.46,English,,0,0,0,,And then in my main program I'm going to call one of those functions addvec
Dialogue: 0,0:54:35.12,0:54:38.08,English,,0,0,0,,To add these two vectors x and y together
Dialogue: 0,0:54:43.28,0:54:46.26,English,,0,0,0,,So now what happens when we compile this this program
Dialogue: 0,0:54:47.82,0:54:56.36,English,,0,0,0,,We've already we've constructed the archive libc.a  from addvec.o and multvec.o
Dialogue: 0,0:54:57.80,0:55:05.90,English,,0,0,0,,And we pass that archive to the linker along with a main 2.0 relocatable object file
Dialogue: 0,0:55:07.68,0:55:10.42,English,,0,0,0,,And we also pass it libc.a
Dialogue: 0,0:55:10.80,0:55:14.10,English,,0,0,0,,Which has the definition of which contains printf.o
Dialogue: 0,0:55:14.96,0:55:17.10,English,,0,0,0,,And anything else that printf.o my call
Dialogue: 0,0:55:19.08,0:55:26.99,English,,0,0,0,,So these three the linker detects the reference to addvec the function addvec
Dialogue: 0,0:55:26.99,0:55:34.40,English,,0,0,0,,And so it just pulls addvec.o out and ignores the rest,similarly for printf.o
Dialogue: 0,0:55:35.12,0:55:36.66,English,,0,0,0,,And then it compiles all those
Dialogue: 0,0:55:36.96,0:55:43.32,English,,0,0,0,,Main main.o addvec.o and printf.o all together into this fully linked executable
Dialogue: 0,0:55:43.78,0:55:47.10,English,,0,0,0,,Called prog2c for compiled time
Dialogue: 0,0:55:48.84,0:55:54.79,English,,0,0,0,,So we're doing this,we're doing this link,we're doing this this linking at compile time
Dialogue: 0,0:55:55.28,0:55:57.28,English,,0,0,0,,When we call a GCC
Dialogue: 0,0:55:59.06,0:56:05.12,English,,0,0,0,,Now what the linker does when it's using static libraries
Dialogue: 0,0:56:07.88,0:56:12.28,English,,0,0,0,,It scans all the .o files and .a files in order on the command line
Dialogue: 0,0:56:12.32,0:56:21.02,English,,0,0,0,,So you're just typing GCC and then a list of .o files and .a files in some order
Dialogue: 0,0:56:23.08,0:56:29.14,English,,0,0,0,,So during the scan it keeps a list of the current unresolved references right
Dialogue: 0,0:56:30.18,0:56:35.10,English,,0,0,0,,If let's say let's say it looks at main.o first and there's a reference to printf
Dialogue: 0,0:56:36.58,0:56:41.10,English,,0,0,0,,That's an unresolved reference because print is not defined in main.o
Dialogue: 0,0:56:41.10,0:56:43.40,English,,0,0,0,,So that goes in a list of undefined references
Dialogue: 0,0:56:44.72,0:56:51.68,English,,0,0,0,,And at some point or another as each new .o file or .a file is encountered
Dialogue: 0,0:56:52.22,0:57:01.36,English,,0,0,0,,The linker tries to without but list of references with the symbols that are defined in that .o file or .a file
Dialogue: 0,0:57:03.14,0:57:06.90,English,,0,0,0,,And then if there's any entries in the list at the end of the scan then there's error
Dialogue: 0,0:57:07.42,0:57:13.48,English,,0,0,0,,Okay so that the key here is that the linker will try to resolve these references from left to right on the command line
Dialogue: 0,0:57:14.16,0:57:18.76,English,,0,0,0,,And so this is another sort of important thing for you to know as programmers
Dialogue: 0,0:57:18.76,0:57:25.22,English,,0,0,0,,Because the order that you put your files on the command line actually makes a difference
Dialogue: 0,0:57:25.58,0:57:31.36,English,,0,0,0,,Okay so you can get sort of weird baffling linker errors if you use the wrong order
Dialogue: 0,0:57:32.20,0:57:34.08,English,,0,0,0,,So for instance suppose we've got
Dialogue: 0,0:57:36.78,0:57:40.12,English,,0,0,0,,A function an object module called libtest
Dialogue: 0,0:57:41.04,0:57:48.24,English,,0,0,0,,That calls a function that's defined in lmine.a
Dialogue: 0,0:57:49.24,0:58:02.88,English,,0,0,0,,Okay so these -L, -L period that says to look for,to look for a library files in the current directory
Dialogue: 0,0:58:02.88,0:58:07.80,English,,0,0,0,,That's what the dot look there first and then look in the normal places that you look
Dialogue: 0,0:58:09.04,0:58:14.72,English,,0,0,0,,And the the -l that's a it's like an abbreviation
Dialogue: 0,0:58:15.20,0:58:20.14,English,,0,0,0,,We could replace this with just the fully spelled out lmind.a
Dialogue: 0,0:58:20.98,0:58:23.84,English,,0,0,0,,Okay but you'll see this this  -l used a lot
Dialogue: 0,0:58:24.68,0:58:30.94,English,,0,0,0,,So libtest calls a function that's declared in lmind.a
Dialogue: 0,0:58:32.00,0:58:37.28,English,,0,0,0,,So the linker looks at it looks at the unresolved symbols in libtest.o
Dialogue: 0,0:58:38.08,0:58:41.28,English,,0,0,0,,And it detects that there's this unresolved function let's say it's called foo
Dialogue: 0,0:58:42.34,0:58:44.90,English,,0,0,0,,I know it's it's called libfun
Dialogue: 0,0:58:46.20,0:58:54.38,English,,0,0,0,,So and it puts it on the list and then it goes on to the next command line entry and that's lmine.a
Dialogue: 0,0:58:54.78,0:58:58.92,English,,0,0,0,,And in there it finds it finds this symbol of libfun
Dialogue: 0,0:58:59.64,0:59:08.10,English,,0,0,0,,And it resolves the reference to that libfun to the actual address the relocated address
Dialogue: 0,0:59:09.14,0:59:15.04,English,,0,0,0,,Now if we switch the order and we put lmine.a first followed by libtest.o
Dialogue: 0,0:59:15.84,0:59:18.60,English,,0,0,0,,Well there's no unresolved references in this library
Dialogue: 0,0:59:18.60,0:59:21.46,English,,0,0,0,,Right it's just the collection of function definitions
Dialogue: 0,0:59:23.26,0:59:27.96,English,,0,0,0,,So it there's no unresolved references so the linker looks at that that's all good
Dialogue: 0,0:59:28.26,0:59:33.10,English,,0,0,0,,And then it looks at libtest.o and now there's an unresolved reference to two libfun
Dialogue: 0,0:59:33.72,0:59:36.32,English,,0,0,0,,But we're out of we're at the end of the command line
Dialogue: 0,0:59:37.18,0:59:38.46,English,,0,0,0,,So that's a linker error
Dialogue: 0,0:59:39.64,0:59:44.40,English,,0,0,0,,So you get this you get this really cryptic error message
Dialogue: 0,0:59:45.56,0:59:50.24,English,,0,0,0,,And if you didn't know about this ordering rule you wouldn't have any idea how to debug
Dialogue: 0,0:59:53.32,0:59:56.88,English,,0,0,0,,It okay so the static libraries are kind of the old fashioned solution that
Dialogue: 0,0:59:56.88,1:00:02.04,English,,0,0,0,,The modern solution is to use dynamic libraries or shared libraries
Dialogue: 0,1:00:04.14,1:00:08.42,English,,0,0,0,,So the reason the reason there's this sort of newer form of libraries
Dialogue: 0,1:00:08.46,1:00:11.74,English,,0,0,0,,That static libraries have some disadvantages
Dialogue: 0,1:00:12.48,1:00:17.18,English,,0,0,0,,So every if you compile with static libraries
Dialogue: 0,1:00:17.20,1:00:20.14,English,,0,0,0,,Then every every function that uses printf
Dialogue: 0,1:00:20.14,1:00:24.34,English,,0,0,0,,Which or every program that uses printf has to have a copy of printf
Dialogue: 0,1:00:25.98,1:00:29.12,English,,0,0,0,,Okay but almost every every program uses printf right
Dialogue: 0,1:00:29.14,1:00:35.14,English,,0,0,0,,So there's a shared libraries allow provide a mechanism where there can just be one
Dialogue: 0,1:00:35.78,1:00:43.32,English,,0,0,0,,Wherever there's just one instance of a shared library member like printf
Dialogue: 0,1:00:44.22,1:00:47.96,English,,0,0,0,,And every program running on the system will share that one copy
Dialogue: 0,1:00:54.76,1:00:59.96,English,,0,0,0,,So that's sort of the big disadvantage is this potential duplication
Dialogue: 0,1:01:01.80,1:01:08.42,English,,0,0,0,,So shared libraries are different in the sense that they contain
Dialogue: 0,1:01:11.34,1:01:15.38,English,,0,0,0,,Code and data that are linked and loaded into the program not when it's
Dialogue: 0,1:01:15.86,1:01:21.46,English,,0,0,0,,Not when it's compiled and linked and into a executable object file
Dialogue: 0,1:01:21.80,1:01:25.98,English,,0,0,0,,But actually when the program is loaded into the system
Dialogue: 0,1:01:25.98,1:01:31.50,English,,0,0,0,,So linking of references to shared library objects is deferred
Dialogue: 0,1:01:32.20,1:01:35.54,English,,0,0,0,,Until the program is actually loaded into memory
Dialogue: 0,1:01:35.78,1:01:39.28,English,,0,0,0,,Until the executable object file is actually loaded into memory
Dialogue: 0,1:01:40.28,1:01:42.86,English,,0,0,0,,And this can either and it can even happen
Dialogue: 0,1:01:43.36,1:01:49.82,English,,0,0,0,,It can happen when the program is actually loaded into memory but it can also happen at runtime anytime at runtime
Dialogue: 0,1:01:50.50,1:01:52.76,English,,0,0,0,,So you can be...you can be running a program
Dialogue: 0,1:01:53.20,1:01:59.86,English,,0,0,0,,And that program can arbitrarily decide to load a function that's declared in a shared library
Dialogue: 0,1:02:00.32,1:02:01.78,English,,0,0,0,,Okay and I'll show you that it's really cool
Dialogue: 0,1:02:04.12,1:02:06.68,English,,0,0,0,,Now these things are often called they're called shared libraries
Dialogue: 0,1:02:06.68,1:02:10.54,English,,0,0,0,,They're called dynamic link libraries like in windows they're called dlls
Dialogue: 0,1:02:11.42,1:02:14.46,English,,0,0,0,,.iso files they're all referenced the same thing
Dialogue: 0,1:02:21.30,1:02:23.52,English,,0,0,0,,Okay so that this like I said you can...
Dialogue: 0,1:02:24.38,1:02:30.20,English,,0,0,0,,The dynamic linking can occur when the program's loaded or after it's loaded and actually running
Dialogue: 0,1:02:32.28,1:02:37.66,English,,0,0,0,,And there's this sort of big deal that shared library routines can be shared by multiple processes
Dialogue: 0,1:02:37.88,1:02:40.46,English,,0,0,0,,And we'll look at this this will make sense when we look at virtual memories
Dialogue: 0,1:02:40.46,1:02:42.36,English,,0,0,0,,So don't worry about that now
Dialogue: 0,1:02:43.28,1:02:45.26,English,,0,0,0,,But but here's how the process works
Dialogue: 0,1:02:49.68,1:02:54.02,English,,0,0,0,,So we've,first we have to create instead of creating an archive
Dialogue: 0,1:02:54.78,1:02:59.88,English,,0,0,0,,We create a shared library,so our libvector routines
Dialogue: 0,1:03:02.22,1:03:08.88,English,,0,0,0,,Instead of creating an archive a file we create a shared a .so file
Dialogue: 0,1:03:09.46,1:03:13.08,English,,0,0,0,,Using the shared argument to GCC
Dialogue: 0,1:03:13.98,1:03:17.52,English,,0,0,0,,So we take our two input functions a addvec and multvec
Dialogue: 0,1:03:18.28,1:03:25.72,English,,0,0,0,,And share it says to create and we're telling GCC to create a shared library  and place it in libvector.so
Dialogue: 0,1:03:27.04,1:03:36.92,English,,0,0,0,,Okay and so and there's also that the C developers have created a punctured library called libc.so
Dialogue: 0,1:03:36.92,1:03:41.40,English,,0,0,0,,That contains printf and on it and other standard library functions
Dialogue: 0,1:03:43.46,1:03:47.88,English,,0,0,0,,So we take our program main2,this is the same program that calls addvec
Dialogue: 0,1:03:48.76,1:03:51.88,English,,0,0,0,,And we compile it into main2.o
Dialogue: 0,1:03:52.30,1:03:57.24,English,,0,0,0,,And we pass main2.0 and  these .so files to the linker
Dialogue: 0,1:03:59.72,1:04:07.96,English,,0,0,0,,Now the linker doesn't at this point it doesn't actually copy let's say we're using addvec or printf
Dialogue: 0,1:04:08.36,1:04:14.14,English,,0,0,0,,It doesn't actually copy those functions or do anything with them in the executable
Dialogue: 0,1:04:14.14,1:04:18.44,English,,0,0,0,,It just makes a note in the symbol table that those functions will need to be the
Dialogue: 0,1:04:20.28,1:04:24.70,English,,0,0,0,,References to those functions will need to be resolved when the program is loaded
Dialogue: 0,1:04:25.22,1:04:31.02,English,,0,0,0,,Okay so it,it puts in a relocation entry that says fix this up when you load the program
Dialogue: 0,1:04:32.16,1:04:35.44,English,,0,0,0,,So it's partially linked but it's not fully linked
Dialogue: 0,1:04:35.44,1:04:41.94,English,,0,0,0,,You can't take that,you can't take a program,you can't take a executable file
Dialogue: 0,1:04:42.24,1:04:45.56,English,,0,0,0,,That was dynamically linked and loaded directly
Dialogue: 0,1:04:47.42,1:04:54.02,English,,0,0,0,,What you do is the loader which is the execve system call
Dialogue: 0,1:04:54.50,1:05:02.12,English,,0,0,0,,And we'll learn more about that, but just this is just a sys call that loads loads executables into memory and runs them
Dialogue: 0,1:05:03.84,1:05:06.38,English,,0,0,0,,The loader takes the executable
Dialogue: 0,1:05:07.06,1:05:12.42,English,,0,0,0,,And then it takes the shared .so files
Dialogue: 0,1:05:13.04,1:05:19.72,English,,0,0,0,,That this program needs k it also made when the linker also made a note of which .so files it needs
Dialogue: 0,1:05:22.26,1:05:27.50,English,,0,0,0,,So the loader calls the dynamic linker which takes those .so files
Dialogue: 0,1:05:27.86,1:05:33.18,English,,0,0,0,,And then actually resolves all the references to any on any unresolved reference
Dialogue: 0,1:05:33.70,1:05:43.86,English,,0,0,0,,Okay so the the address of addvec,the addvec and printf functions isn't determined until the program is loaded
Dialogue: 0,1:05:44.80,1:05:49.32,English,,0,0,0,,And by that and it isn't determined by the dynamic linker until the program is loaded
Dialogue: 0,1:05:50.46,1:05:55.02,English,,0,0,0,,So that the dynamic linker does it goes through a similar process that the static linker did
Dialogue: 0,1:05:55.32,1:05:59.82,English,,0,0,0,,Sort of fixing up references to add back at references to printf
Dialogue: 0,1:06:00.46,1:06:08.42,English,,0,0,0,,And then at that point the binary is in a form that can be executed directly
Dialogue: 0,1:06:08.56,1:06:26.98,English,,0,0,0,,So question-yes-what if you look the part where did like where is that like if you include violence and use anger and greed zero actually
Dialogue: 0,1:06:26.98,1:06:29.64,English,,0,0,0,,Okay the question is what happens if you include a file
Dialogue: 0,1:06:30.50,1:06:34.28,English,,0,0,0,,So includes are handled by the C preprocessor
Dialogue: 0,1:06:34.94,1:06:40.78,English,,0,0,0,,So they're gone, they're long gone, by the time the by the time the linker gets around to it
Dialogue: 0,1:06:41.28,1:06:45.82,English,,0,0,0,,Okay so the C preprocessor just takes #define,#include
Dialogue: 0,1:06:46.70,1:06:51.44,English,,0,0,0,,And and interprets those and outputs another C program
Dialogue: 0,1:06:51.98,1:06:59.18,English,,0,0,0,,So if you include a file the C preprocessor just takes that file and just expands it
Dialogue: 0,1:06:59.90,1:07:05.36,English,,0,0,0,,And the output C program contains an expanded version of all the files that you include it
Dialogue: 0,1:07:11.38,1:07:16.82,English,,0,0,0,,Okay now what's really cool is that you can also do this dynamic linking at runtime
Dialogue: 0,1:07:17.34,1:07:20.84,English,,0,0,0,,So what I showed you before we're doing it at load time
Dialogue: 0,1:07:21.78,1:07:34.68,English,,0,0,0,,But you can also arbitrarily decide to load link and call a function from a shared from a from any function defined in a .so file
Dialogue: 0,1:07:35.94,1:07:41.36,English,,0,0,0,,And the way you do it is there's a there's an interface called the dlopen
Dialogue: 0,1:07:41.84,1:07:44.90,English,,0,0,0,,That's in lib.c that allows you to do this
Dialogue: 0,1:07:45.76,1:07:52.58,English,,0,0,0,,So let's say we want to this is our main program and just like before we want to call addvec
Dialogue: 0,1:07:53.28,1:07:57.24,English,,0,0,0,,Okay but addvec now is defined in a .so file
Dialogue: 0,1:07:57.92,1:08:00.98,English,,0,0,0,,The exact same .so file that we generated before
Dialogue: 0,1:08:02.32,1:08:08.72,English,,0,0,0,,When we compile,so we'll call this dll.c,when we compile this program ddl.c
Dialogue: 0,1:08:10.52,1:08:18.92,English,,0,0,0,,We have no idea that it's going to call a function from lib.so
Dialogue: 0,1:08:19.38,1:08:23.84,English,,0,0,0,,We just compile it as though a standalone C program
Dialogue: 0,1:08:24.72,1:08:29.32,English,,0,0,0,,Within this program though we declare a pointer a function pointer called addvec
Dialogue: 0,1:08:30.10,1:08:32.64,English,,0,0,0,,And we give the prototype for this function
Dialogue: 0,1:08:32.70,1:08:39.14,English,,0,0,0,,It's pointers city so it's a two input arrays the output array on the size
Dialogue: 0,1:08:41.28,1:08:46.00,English,,0,0,0,,And then first we dynamically load the shared library that contains the function we want
Dialogue: 0,1:08:47.24,1:08:55.32,English,,0,0,0,,So we call dlopen and we say load up this .so file into memory
Dialogue: 0,1:08:55.42,1:08:57.50,English,,0,0,0,,So that I can call a function
Dialogue: 0,1:08:57.96,1:09:06.28,English,,0,0,0,,But don't resolve,you know don't worry about the resolving the references to it functions until I actually tell you too
Dialogue: 0,1:09:07.24,1:09:09.00,English,,0,0,0,,That's the lazy part
Dialogue: 0,1:09:10.50,1:09:13.74,English,,0,0,0,,And so what what this deal open returns a handle
Dialogue: 0,1:09:14.40,1:09:18.06,English,,0,0,0,,That then you use in subsequent calls okay
Dialogue: 0,1:09:19.08,1:09:24.98,English,,0,0,0,,So if we don't if the handle is null there was some kind of error like maybe this data .so file does exist
Dialogue: 0,1:09:27.76,1:09:34.32,English,,0,0,0,,So once we've opened that .so file then we use dlsym with the handle so this
Dialogue: 0,1:09:34.94,1:09:41.62,English,,0,0,0,,And then we give it as we pass as a string the name of the function that we want to invoke
Dialogue: 0,1:09:43.26,1:09:47.90,English,,0,0,0,,And what we get back from dlsym as a pointer to that function
Dialogue: 0,1:09:48.90,1:09:53.96,English,,0,0,0,,And then we can use that function just like any other function so we can use that function pointer
Dialogue: 0,1:09:54.24,1:09:57.44,English,,0,0,0,,And we call it just as though it were a statically defined function
Dialogue: 0,1:09:58.86,1:10:01.88,English,,0,0,0,,So you can see this is real very powerful technique
Dialogue: 0,1:10:08.50,1:10:14.86,English,,0,0,0,,Okay so looks let's finish the last little bits of the class
Dialogue: 0,1:10:14.86,1:10:21.02,English,,0,0,0,,I want to show you it to try to convince you that linking is is actually interesting which is kind of a hard sell sometime
Dialogue: 0,1:10:21.04,1:10:33.80,English,,0,0,0,,Yes question...yes...no it's that's how you know
Dialogue: 0,1:10:34.18,1:10:37.72,English,,0,0,0,,No you just it's declared as a function pointer
Dialogue: 0,1:10:37.72,1:10:43.46,English,,0,0,0,,And you then you just use the name of the function you don't have to dereference it
Dialogue: 0,1:10:45.42,1:10:52.90,English,,0,0,0,,Or you just you call it you call the function by just using that function pointer name okay
Dialogue: 0,1:10:53.42,1:10:54.38,English,,0,0,0,,Just like I did
Dialogue: 0,1:10:59.98,1:11:03.22,English,,0,0,0,,If you dereference it I just get back a pointer value
Dialogue: 0,1:11:04.08,1:11:07.80,English,,0,0,0,,You get back the address of that function
Dialogue: 0,1:11:09.70,1:11:15.64,English,,0,0,0,,All right so it's kind of a hard sell to that to convince you that linking is interesting
Dialogue: 0,1:11:15.64,1:11:16.80,English,,0,0,0,,But I'm going to try
Dialogue: 0,1:11:17.30,1:11:22.52,English,,0,0,0,,Ok so there's this powerful technique called inner library inter positioning
Dialogue: 0,1:11:23.24,1:11:27.88,English,,0,0,0,,And the goal is to intercept function calls from libraries
Dialogue: 0,1:11:28.64,1:11:32.60,English,,0,0,0,,And do something intercept them for some reason
Dialogue: 0,1:11:33.30,1:11:37.24,English,,0,0,0,,Right so what we typically want to do is intercept a function call
Dialogue: 0,1:11:38.12,1:11:42.04,English,,0,0,0,,Maybe record some to some statistics or do some error checking
Dialogue: 0,1:11:42.56,1:11:45.94,English,,0,0,0,,And then call the real function as intended
Dialogue: 0,1:11:46.04,1:11:50.16,English,,0,0,0,,Right so the idea is we're going to create wrappers
Dialogue: 0,1:11:52.00,1:12:00.18,English,,0,0,0,,And when the program when a program calls a function what we're going to do is we're going to execute its wrapper instead
Dialogue: 0,1:12:01.88,1:12:04.30,English,,0,0,0,,Okay and we're going to do it without changing any of the source
Dialogue: 0,1:12:09.68,1:12:13.34,English,,0,0,0,,Now there's a lot of reasons there's a lot of applications for this
Dialogue: 0,1:12:13.94,1:12:21.10,English,,0,0,0,,That the neatest one that I know is that these facebook engineers
Dialogue: 0,1:12:21.56,1:12:25.30,English,,0,0,0,,So we're trying to deal with this year-long bug in the facebook iPhone app
Dialogue: 0,1:12:26.10,1:12:28.20,English,,0,0,0,,And nobody could figure out what was going on
Dialogue: 0,1:12:29.28,1:12:31.86,English,,0,0,0,,And they figured it out using library inter positioning
Dialogue: 0,1:12:32.28,1:12:37.40,English,,0,0,0,,They figured out that there was something in the network stack writing to the wrong location
Dialogue: 0,1:12:37.40,1:12:43.26,English,,0,0,0,,They figured it out by intercepting all the calls from their facebook app  that did rights
Dialogue: 0,1:12:43.90,1:12:47.04,English,,0,0,0,,So things like write to the ep right
Dialogue: 0,1:12:47.96,1:12:51.02,English,,0,0,0,,So they just they intercepted all those calls and then they were able to
Dialogue: 0,1:12:51.02,1:12:54.06,English,,0,0,0,,To when they looked at the arguments and how those functions were being called
Dialogue: 0,1:12:54.26,1:12:55.94,English,,0,0,0,,They determine the air
Dialogue: 0,1:13:00.04,1:13:02.54,English,,0,0,0,,You can also use it for monitoring and profiling like
Dialogue: 0,1:13:02.54,1:13:07.80,English,,0,0,0,,So if you want to know like how many times different functions get called you can you can interpose
Dialogue: 0,1:13:08.34,1:13:12.64,English,,0,0,0,,We use it for generating address traces
Dialogue: 0,1:13:12.70,1:13:17.46,English,,0,0,0,,So you're malloc when you do your malloc lab later in the semester
Dialogue: 0,1:13:17.80,1:13:22.76,English,,0,0,0,,You're going to be evaluating your malloc using a traces
Dialogue: 0,1:13:22.76,1:13:27.36,English,,0,0,0,,That we generated from real programs using this inter positioning technique
Dialogue: 0,1:13:27.62,1:13:34.08,English,,0,0,0,,Right so we enter post on all the malloc and free calls in like netscape
Dialogue: 0,1:13:35.62,1:13:39.18,English,,0,0,0,,And then we just recorded what addresses and sizes
Dialogue: 0,1:13:39.64,1:13:44.88,English,,0,0,0,,Malloc was returning and what what blocks free was freeing up
Dialogue: 0,1:13:45.30,1:13:51.84,English,,0,0,0,,And we just created a trace of those, and then, so let me show you how you would do this
Dialogue: 0,1:13:54.00,1:13:56.24,English,,0,0,0,,So the idea let's say we have this main program
Dialogue: 0,1:13:56.26,1:13:59.54,English,,0,0,0,,And the idea is to trace all the malloc and free calls
Dialogue: 0,1:13:59.54,1:14:02.38,English,,0,0,0,,So there's one malloc call and there's one free call
Dialogue: 0,1:14:03.16,1:14:07.18,English,,0,0,0,,And we want to know what these addresses are and we want to know what these sizes are
Dialogue: 0,1:14:08.48,1:14:12.50,English,,0,0,0,,So we can do this at either compile time, link time or run time
Dialogue: 0,1:14:13.80,1:14:15.20,English,,0,0,0,,To do it at compile time
Dialogue: 0,1:14:16.02,1:14:19.90,English,,0,0,0,,We first write wrapper functions called mymalloc and myfree
Dialogue: 0,1:14:20.44,1:14:23.52,English,,0,0,0,,Where mymalloc call most the real malloc function
Dialogue: 0,1:14:24.08,1:14:30.82,English,,0,0,0,,And then it prints out the the size that it was called and the address that malloc returned
Dialogue: 0,1:14:31.40,1:14:35.60,English,,0,0,0,,Okay so this when we run our program it will print out these all these addresses
Dialogue: 0,1:14:35.60,1:14:37.36,English,,0,0,0,,And it does the same thing for free
Dialogue: 0,1:14:38.18,1:14:41.46,English,,0,0,0,,And then here's the trick in malloc.h
Dialogue: 0,1:14:42.26,1:14:49.20,English,,0,0,0,,We define malloc to be mymalloc ,okay and free to be myfree
Dialogue: 0,1:14:49.52,1:14:53.34,English,,0,0,0,,And then we give the prototype for it so the compiler doesn't get confused
Dialogue: 0,1:14:54.14,1:14:58.10,English,,0,0,0,,And then we can compile mymalloc.c into a .o file
Dialogue: 0,1:14:59.22,1:15:03.54,English,,0,0,0,,And then we call week then we complete we call our program
Dialogue: 0,1:15:03.54,1:15:10.74,English,,0,0,0,,Which is our main program int.c for inner positioning
Dialogue: 0,1:15:11.72,1:15:13.70,English,,0,0,0,,And we call that and here's the trick
Dialogue: 0,1:15:14.58,1:15:18.14,English,,0,0,0,,We call it with the -I argument
Dialogue: 0,1:15:18.74,1:15:22.22,English,,0,0,0,,And we say look for any include files in the current directory
Dialogue: 0,1:15:22.56,1:15:29.94,English,,0,0,0,,Okay so this was similar to that -L argument
Dialogue: 0,1:15:30.90,1:15:35.12,English,,0,0,0,,But because we tell GCC to look in the current directory first
Dialogue: 0,1:15:35.80,1:15:38.20,English,,0,0,0,,So this is sort of where the inner positioning happens
Dialogue: 0,1:15:38.68,1:15:44.60,English,,0,0,0,,This because when it does that it's going to it's going to find a
Dialogue: 0,1:15:45.82,1:15:48.28,English,,0,0,0,,It's going to find a library called malloc.h
Dialogue: 0,1:15:49.44,1:15:51.54,English,,0,0,0,,I mean .h file called malloc.h
Dialogue: 0,1:15:52.02,1:15:57.26,English,,0,0,0,,And so all the calls to malloc will be translated by the C preprocessor to mymalloc
Dialogue: 0,1:15:58.76,1:16:04.90,English,,0,0,0,,So when we run this it prints out the the trip malloc and free trace
Dialogue: 0,1:16:07.86,1:16:09.60,English,,0,0,0,,Now we can also do this at link time
Dialogue: 0,1:16:09.60,1:16:14.38,English,,0,0,0,,So we can tell C,in order to do this we had to get access to the
Dialogue: 0,1:16:15.14,1:16:19.24,English,,0,0,0,,We had to compile the program,we didn't have to change it but we had to compile it
Dialogue: 0,1:16:19.94,1:16:27.08,English,,0,0,0,,We can use link time at our positioning if to avoid that compilation
Dialogue: 0,1:16:28.40,1:16:34.10,English,,0,0,0,,So the way this works we define our wrapper functions with this special name underscore underscore wrap malloc
Dialogue: 0,1:16:35.20,1:16:38.96,English,,0,0,0,,And this calls the real malloc function and then prints out the information
Dialogue: 0,1:16:41.14,1:16:51.16,English,,0,0,0,,And then at link time then we do the inter positioning by calling the linker with this special -Wl  argument
Dialogue: 0,1:16:52.14,1:16:57.72,English,,0,0,0,,And so what this does the -Wl flag to GCC says hey
Dialogue: 0,1:16:58.34,1:17:05.00,English,,0,0,0,,Take what follows the argument that follows replace all the commas with spaces
Dialogue: 0,1:17:05.00,1:17:07.50,English,,0,0,0,,And then invoke the linker with this argument
Dialogue: 0,1:17:07.72,1:17:11.40,English,,0,0,0,,Okay so what we're doing is passing a linker arguments to the linker
Dialogue: 0,1:17:12.28,1:17:15.54,English,,0,0,0,,And this --wrap argument to the linker
Dialogue: 0,1:17:16.44,1:17:23.76,English,,0,0,0,,It tells the linker to resolve all references to malloc as underscore underscore wrap malloc
Dialogue: 0,1:17:24.80,1:17:30.86,English,,0,0,0,,And all references to underscore real malloc - should be resolved as malloc
Dialogue: 0,1:17:32.68,1:17:37.74,English,,0,0,0,,Okay so anywhere in the program what we call malloc it'll be resolved to underscore underscore wrap malloc
Dialogue: 0,1:17:38.24,1:17:41.92,English,,0,0,0,,And it will invoke our wrapper and then the wrapper calls real malloc
Dialogue: 0,1:17:42.54,1:17:50.70,English,,0,0,0,,Which by because of this flag resolves to the the actual malloc routine
Dialogue: 0,1:17:53.16,1:17:55.98,English,,0,0,0,,Now here you can also in the really the really amazing thing
Dialogue: 0,1:17:56.02,1:18:01.06,English,,0,0,0,,You can also do this inter positioning it load timer and run time when the program is loaded
Dialogue: 0,1:18:01.08,1:18:05.52,English,,0,0,0,,So you don't even need access to the .o files all you need is access to the executable
Dialogue: 0,1:18:06.66,1:18:09.50,English,,0,0,0,,Right and for every program we have access to the executable
Dialogue: 0,1:18:10.17,1:18:12.40,English,,0,0,0,,So think about that we can take any program
Dialogue: 0,1:18:13.08,1:18:17.24,English,,0,0,0,,And we can interpose on its library calls at runtime
Dialogue: 0,1:18:18.58,1:18:26.15,English,,0,0,0,,So the way we do this is we write the wrapper function now uses the dlsym call that we saw before
Dialogue: 0,1:18:27.62,1:18:32.10,English,,0,0,0,,And we call it with this special function the special argument called next
Dialogue: 0,1:18:33.70,1:18:39.08,English,,0,0,0,,And we silver and what this is saying is get the address of the real malloc
Dialogue: 0,1:18:40.26,1:18:47.90,English,,0,0,0,,Okay so and we're going to trick the linker into looking first to implementation of malloc
Dialogue: 0,1:18:48.60,1:18:55.00,English,,0,0,0,,But here we want the real one,so we're telling it to get to look in the next place,its next place that it would normally look
Dialogue: 0,1:18:55.78,1:18:59.52,English,,0,0,0,,And fetch the the address of malloc
Dialogue: 0,1:18:59.52,1:19:04.02,English,,0,0,0,,So the result is a pointer a function pointer called mallocp
Dialogue: 0,1:19:04.64,1:19:09.58,English,,0,0,0,,And then we can just call that function to get to call the libc malloc
Dialogue: 0,1:19:09.92,1:19:12.28,English,,0,0,0,,And then print out the the data
Dialogue: 0,1:19:12.94,1:19:19.50,English,,0,0,0,,Okay we do the same thing for free, we use dlsym in exactly the same way for free
Dialogue: 0,1:19:20.68,1:19:25.22,English,,0,0,0,,And then the inter positioning now happens when the program is loaded
Dialogue: 0,1:19:26.56,1:19:31.92,English,,0,0,0,,So notice we built this our main program now in tar for run time inter positioning
Dialogue: 0,1:19:32.82,1:19:40.28,English,,0,0,0,,We built it I'm sorry we created our .so file mymalloc.so using the shared argument
Dialogue: 0,1:19:41.56,1:19:48.24,English,,0,0,0,,And then we compiled int.c into this executable called intr
Dialogue: 0,1:19:48.24,1:19:51.66,English,,0,0,0,,But notice there's no mention of mymalloc.so anywhere
Dialogue: 0,1:19:54.42,1:19:57.76,English,,0,0,0,,And now the inner positioning happens when we actually run the program
Dialogue: 0,1:19:58.68,1:20:13.06,English,,0,0,0,,And we do it,we affect the the inner positioning by setting an environment variable called ld-preload to mymalloc.so
Dialogue: 0,1:20:13.42,1:20:17.82,English,,0,0,0,,And so what this is a environment variable that tells the dynamic linker
Dialogue: 0,1:20:18.60,1:20:26.20,English,,0,0,0,,To look first in the value, it looked first in the the value of ld preload is a list of locations
Dialogue: 0,1:20:26.62,1:20:29.64,English,,0,0,0,,Look first in those locations when to resolve references
Dialogue: 0,1:20:29.98,1:20:33.90,English,,0,0,0,,And only later look in the normal system places
Dialogue: 0,1:20:34.86,1:20:38.95,English,,0,0,0,,So we're saying to look in mymalloc.so unresolved references first
Dialogue: 0,1:20:39.46,1:20:44.44,English,,0,0,0,,And then we're invoking,so this is in bash this is how you initialize an environment variable
Dialogue: 0,1:20:44.68,1:20:50.54,English,,0,0,0,,So we're initializing it to mymalloc.so and then we're loading and running the program
Dialogue: 0,1:20:51.86,1:21:00.08,English,,0,0,0,,And so the ld so all the references to malloc get turned into the references to the wrapper function
Dialogue: 0,1:21:01.34,1:21:05.34,English,,0,0,0,,The malloc function that we defined in our program okay
Dialogue: 0,1:21:07.74,1:21:12.46,English,,0,0,0,,Ok so that's it so that that inter positioning is a really cool technique
Dialogue: 0,1:21:12.60,1:21:15.86,English,,0,0,0,,And it's only possible because of linkers so
Dialogue: 0,1:21:17.46,1:21:23.86,English,,0,0,0,,alright so good we'll see you on on Thursday and good luck with your cache labs
