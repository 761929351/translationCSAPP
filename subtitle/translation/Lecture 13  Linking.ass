[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: csapp/Lecture 13  Linking.mp4
Video File: csapp/Lecture 13  Linking.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.203125
Scroll Position: 1627
Active Line: 1640
Video Position: 146324

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Noto Sans CJK SC Black,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,1.5,1.2,2,10,10,10,1
Style: Chinese,Noto Sans CJK SC Black,40,&H00FFFF00,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.2,1.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.34,English,,0,0,0,,Welcome good to see you
Dialogue: 0,0:00:00.03,0:00:01.34,Chinese,,0,0,0,,欢迎，很高兴见到大家
Dialogue: 0,0:00:04.60,0:00:09.52,English,,0,0,0,,Today we're going to begin a transitioning from
Dialogue: 0,0:00:04.60,0:00:09.52,Chinese,,0,0,0,,今天我们要转变一下研究内容
Dialogue: 0,0:00:10.28,0:00:17.04,English,,0,0,0,,How a programs interact with hardware to how they interact with software in particular system software
Dialogue: 0,0:00:10.28,0:00:17.04,Chinese,,0,0,0,,从程序如何与硬件交互，以及它们如何与特定系统软件中的软件交互开始
Dialogue: 0,0:00:17.70,0:00:23.38,English,,0,0,0,,And we're going to start that investigation by studying and learning about a process called linking
Dialogue: 0,0:00:17.70,0:00:23.38,Chinese,,0,0,0,,我们将通过研究和弄懂一个叫做链接的过程开始
Dialogue: 0,0:00:25.12,0:00:30.98,English,,0,0,0,,Which is how the system builds your programs ok
Dialogue: 0,0:00:25.12,0:00:30.98,Chinese,,0,0,0,,这能帮助你好好弄清楚系统是如何构建你的程序
Dialogue: 0,0:00:33.26,0:00:35.92,English,,0,0,0,,So we're going to study the process of linking
Dialogue: 0,0:00:33.26,0:00:35.92,Chinese,,0,0,0,,所以我们要学习链接的过程
Dialogue: 0,0:00:35.92,0:00:40.86,English,,0,0,0,,And then I'm going to show you a really cool technique called library interpositioning
Dialogue: 0,0:00:35.92,0:00:40.86,Chinese,,0,0,0,,然后我将向你展示一项非常酷的技术，称为「库打桩」技术
Dialogue: 0,0:00:42.16,0:00:51.08,English,,0,0,0,,Which allows you to use linking to actually intercept on function calls in libraries like the standard C library
Dialogue: 0,0:00:42.16,0:00:51.08,Chinese,,0,0,0,,这允许你使用链接实际拦截像 C 标准库这样的库中的函数调用
Dialogue: 0,0:00:51.66,0:00:56.38,English,,0,0,0,,So it's a very powerful and interesting technique and it's all enabled by by linking
Dialogue: 0,0:00:51.66,0:00:56.38,Chinese,,0,0,0,,所以它是一种非常强大而且有趣的技术，它通过链接实现
Dialogue: 0,0:00:58.28,0:01:01.36,English,,0,0,0,,So let's start with a simple program
Dialogue: 0,0:00:58.28,0:01:01.36,Chinese,,0,0,0,,让我们从一个非常简单的程序开始吧
Dialogue: 0,0:01:02.54,0:01:07.84,English,,0,0,0,,This program consists of two modules a main.c and sum.c
Dialogue: 0,0:01:02.54,0:01:07.84,Chinese,,0,0,0,,这个程序里包含两个模块 main.c 和 sum.c
Dialogue: 0,0:01:09.06,0:01:14.90,English,,0,0,0,,sum.c takes as an array as an argument and a length n
Dialogue: 0,0:01:09.06,0:01:14.90,Chinese,,0,0,0,,sum.c 将一个数组和一个长度 n 作为参数
Dialogue: 0,0:01:15.54,0:01:21.60,English,,0,0,0,,And then it sums up the elements of that array and returns the sum  back to the caller
Dialogue: 0,0:01:15.54,0:01:21.60,Chinese,,0,0,0,,然后它计算了该数组中元素的总和并将总和返回给调用者
Dialogue: 0,0:01:23.48,0:01:26.21,English,,0,0,0,,main.c calls the sum function
Dialogue: 0,0:01:23.48,0:01:26.21,Chinese,,0,0,0,,main.c 调用了 sum 函数
Dialogue: 0,0:01:26.76,0:01:29.54,English,,0,0,0,,Using and passes it a two element array of ints
Dialogue: 0,0:01:26.76,0:01:29.54,Chinese,,0,0,0,,使用并传递一个两元素的 int 类型数组
Dialogue: 0,0:01:31.20,0:01:35.78,English,,0,0,0,,And then returns the value received from some
Dialogue: 0,0:01:31.20,0:01:35.78,Chinese,,0,0,0,,然后返回了从其中收到的值
Dialogue: 0,0:01:37.74,0:01:43.54,English,,0,0,0,,Yeah we that that's kind of an odd thing to do to return your exit status like that
Dialogue: 0,0:01:37.74,0:01:43.54,Chinese,,0,0,0,,是的，我们认为像这样返回退出状态是件奇怪的事情
Dialogue: 0,0:01:43.54,0:01:47.76,English,,0,0,0,,But we just did it so that the compiler wouldn't optimize away all of a code
Dialogue: 0,0:01:43.54,0:01:47.76,Chinese,,0,0,0,,但我们这样做，以便编译器不会优化掉所有代码
Dialogue: 0,0:01:49.22,0:01:52.94,English,,0,0,0,,I know let's look at what happens if when we want to compile those those two modules
Dialogue: 0,0:01:49.22,0:01:52.94,Chinese,,0,0,0,,让我们来看看如果我们想要编译那两个模块会发生什么
Dialogue: 0,0:01:55.44,0:01:58.74,English,,0,0,0,,For each of main.c and sum.c
Dialogue: 0,0:01:55.44,0:01:58.74,Chinese,,0,0,0,,对于每个 main.c 和 sum.c
Dialogue: 0,0:01:59.52,0:02:08.66,English,,0,0,0,,The GCC calls a series of translators on that,on those modules,on those .c files
Dialogue: 0,0:01:59.52,0:02:08.66,Chinese,,0,0,0,,GCC 会在这些模块上调用 .c 文件上的一系列翻译器
Dialogue: 0,0:02:09.38,0:02:11.68,English,,0,0,0,,First calls the C preprocessor cpp
Dialogue: 0,0:02:09.38,0:02:11.68,Chinese,,0,0,0,,首先调用 C 预处理器 cpp(将 main.c 翻译成 ASCII 中间文件 main.i)
Dialogue: 0,0:02:14.30,0:02:18.82,English,,0,0,0,,Then it calls the compiler,the actual compiler which is cc1
Dialogue: 0,0:02:14.30,0:02:18.82,Chinese,,0,0,0,,然后它调用编译器，实际上使用的编译器是叫 cc1(将 main.i 翻译成 ASCII 汇编语言文件 main.s)
Dialogue: 0,0:02:20.90,0:02:26.96,English,,0,0,0,,The compiler generates assembly which is then translated by the assembler as
Dialogue: 0,0:02:20.90,0:02:26.96,Chinese,,0,0,0,,编译器生成汇编程序，然后汇编器将其翻译
Dialogue: 0,0:02:27.72,0:02:32.60,English,,0,0,0,,And resulting in a .o file called main.o
Dialogue: 0,0:02:27.72,0:02:32.60,Chinese,,0,0,0,,结果生成了一个 .o 文件，称为 main.o
Dialogue: 0,0:02:33.26,0:02:36.24,English,,0,0,0,,Similar things happens for sum.c
Dialogue: 0,0:02:33.26,0:02:36.24,Chinese,,0,0,0,,sum.c 也发生了类似的事情
Dialogue: 0,0:02:37.34,0:02:43.88,English,,0,0,0,,So after these three translators work on the code
Dialogue: 0,0:02:37.34,0:02:43.88,Chinese,,0,0,0,,在这三个翻译器处理完代码之后
Dialogue: 0,0:02:44.36,0:02:47.14,English,,0,0,0,,We have two object files two .o files
Dialogue: 0,0:02:44.36,0:02:47.14,Chinese,,0,0,0,,生成了两个 .o 格式目标文件
Dialogue: 0,0:02:48.86,0:02:51.54,English,,0,0,0,,The linker takes those those .o files
Dialogue: 0,0:02:48.86,0:02:51.54,Chinese,,0,0,0,,链接器取到这些 .o 格式目标文件
Dialogue: 0,0:02:52.18,0:03:04.66,English,,0,0,0,,And put some,links them together sort of smashes them together to form a single executable called that we can then run
Dialogue: 0,0:02:52.18,0:03:04.66,Chinese,,0,0,0,,将它们拼凑在一起，创建一个单个的可执行文件然后运行
Dialogue: 0,0:02:52.18,0:03:04.66,Chinese,,0,0,0,,然后放一些（必要的系统目标文件），将它们链接在一起，
Dialogue: 0,0:03:07.02,0:03:09.24,English,,0,0,0,,Then we can then load and run on the system
Dialogue: 0,0:03:07.02,0:03:09.24,Chinese,,0,0,0,,然后我们就可以加载并运行到系统上
Dialogue: 0,0:03:11.36,0:03:15.42,English,,0,0,0,,So the main.c and sum.c they are called source files
Dialogue: 0,0:03:11.36,0:03:15.42,Chinese,,0,0,0,,所以 main.c 和 sum.c 被称为源文件
Dialogue: 0,0:03:15.94,0:03:19.90,English,,0,0,0,,These .o files are object files that
Dialogue: 0,0:03:15.94,0:03:19.90,Chinese,,0,0,0,,这些 .o 文件
Dialogue: 0,0:03:20.60,0:03:22.28,English,,0,0,0,,We are separately compiled
Dialogue: 0,0:03:20.60,0:03:22.28,Chinese,,0,0,0,,虽然是我们分开编译的目标文件
Dialogue: 0,0:03:23.18,0:03:25.64,English,,0,0,0,,But we call them relocatable object files
Dialogue: 0,0:03:23.18,0:03:25.64,Chinese,,0,0,0,,但我们还是要叫他们可重定位目标文件
Dialogue: 0,0:03:25.74,0:03:33.32,English,,0,0,0,,Because they can be combined together to form the fully linked executable object file
Dialogue: 0,0:03:25.74,0:03:33.32,Chinese,,0,0,0,,因为它们可以组合在一起形成完全链接的可执行目标文件
Dialogue: 0,0:03:36.06,0:03:42.56,English,,0,0,0,,So why do we do it like this, you know why do we allow this so-called separate compilation
Dialogue: 0,0:03:36.06,0:03:42.56,Chinese,,0,0,0,,那为什么我们这样做呢，你知道为什么我们允许这种所谓的分离编译
Dialogue: 0,0:03:42.62,0:03:48.50,English,,0,0,0,,You know why don't we just have like one big you know one big file that with all of code in it
Dialogue: 0,0:03:42.62,0:03:48.50,Chinese,,0,0,0,,你知道为什么我们不喜欢一个包含所有代码的大文件
Dialogue: 0,0:03:49.02,0:03:55.57,English,,0,0,0,,Well there's a couple reasons the first is is modularity so by allowing you to break your code into smaller pieces
Dialogue: 0,0:03:49.02,0:03:55.57,Chinese,,0,0,0,,有一些原因，首先是模块化，允许你将代码分解成更小的部分
Dialogue: 0,0:03:55.96,0:03:58.96,English,,0,0,0,,You can put related functions into separate source files
Dialogue: 0,0:03:55.96,0:03:58.96,Chinese,,0,0,0,,你可以将相关功能放入单独的源文件中
Dialogue: 0,0:03:59.30,0:04:01.58,English,,0,0,0,,You can define libraries of functions
Dialogue: 0,0:03:59.30,0:04:01.58,Chinese,,0,0,0,,你可以定义函数库
Dialogue: 0,0:04:02.74,0:04:11.60,English,,0,0,0,,So it's just good technique and it allows you to kind of break your code up into nice modular pieces
Dialogue: 0,0:04:02.74,0:04:11.60,Chinese,,0,0,0,,所以这只是一种很好的技术，它可以让你将代码分解成很好的模块化的部分
Dialogue: 0,0:04:13.54,0:04:15.10,English,,0,0,0,,The other reason is efficiency
Dialogue: 0,0:04:13.54,0:04:15.10,Chinese,,0,0,0,,另一个理由是效率
Dialogue: 0,0:04:18.68,0:04:21.92,English,,0,0,0,,So if we've broken up our program into multiple chunks
Dialogue: 0,0:04:18.68,0:04:21.92,Chinese,,0,0,0,,所以如果我们把我们的程序分为多个块
Dialogue: 0,0:04:22.66,0:04:28.54,English,,0,0,0,,If we change and if we only need to change one of the chunks
Dialogue: 0,0:04:22.66,0:04:28.54,Chinese,,0,0,0,,当我们改变，比如我们只需要更改其中一个块
Dialogue: 0,0:04:29.26,0:04:33.06,English,,0,0,0,,We don't have to recompile the all the other modules
Dialogue: 0,0:04:29.26,0:04:33.06,Chinese,,0,0,0,,我们就没必要重新编译所有其他模块
Dialogue: 0,0:04:33.28,0:04:38.50,English,,0,0,0,,Right we can just recompile the one module that we changed and then link them all together again
Dialogue: 0,0:04:33.28,0:04:38.50,Chinese,,0,0,0,,对，我们可以重新编译我们更改的一个模块，然后再将它们全部链接在一起
Dialogue: 0,0:04:38.58,0:04:44.26,English,,0,0,0,,Right so it's efficient in time it's also efficient in space
Dialogue: 0,0:04:38.58,0:04:44.26,Chinese,,0,0,0,,所以这在时间和空间上都是有效的
Dialogue: 0,0:04:44.26,0:04:51.64,English,,0,0,0,,Because you can take all of the functions in the standard C library you could put them all together
Dialogue: 0,0:04:44.26,0:04:51.64,Chinese,,0,0,0,,因为你可以使用 C 标准库中的所有功能，所以你可以将它们放在一起
Dialogue: 0,0:04:52.14,0:04:57.86,English,,0,0,0,,But then the only functions that you actually get compiled and linked into your program are the ones that you actually call
Dialogue: 0,0:04:52.14,0:04:57.86,Chinese,,0,0,0,,但是，实际编译并链接到程序中的唯一函数是你实际调用的函数
Dialogue: 0,0:04:58.68,0:05:01.62,English,,0,0,0,,Ok so you can save space
Dialogue: 0,0:04:58.68,0:05:01.62,Chinese,,0,0,0,,好的，这样你就可以节省空间
Dialogue: 0,0:05:01.62,0:05:08.14,English,,0,0,0,,You don't you know normally you use only a small subset of the standard C functions
Dialogue: 0,0:05:01.62,0:05:08.14,Chinese,,0,0,0,,你通常不知道你其实只使用 C 标准函数的一小部分
Dialogue: 0,0:05:08.80,0:05:13.16,English,,0,0,0,,So there's no point in linking all of those functions into your code if you don't need them
Dialogue: 0,0:05:08.80,0:05:13.16,Chinese,,0,0,0,,因此，如果你不需要将所有这些功能链接到代码中，那就没有意义了
Dialogue: 0,0:05:15.08,0:05:16.66,English,,0,0,0,,Alright so what do linkers do
Dialogue: 0,0:05:15.08,0:05:16.66,Chinese,,0,0,0,,好吧，那么链接器做了什么呢
Dialogue: 0,0:05:18.02,0:05:21.78,English,,0,0,0,,Well there's two main tasks that a linker performs
Dialogue: 0,0:05:18.02,0:05:21.78,Chinese,,0,0,0,,链接器执行的主要任务有两个
Dialogue: 0,0:05:23.28,0:05:25.82,English,,0,0,0,,The first is called simple resolution
Dialogue: 0,0:05:23.28,0:05:25.82,Chinese,,0,0,0,,第一个被称为简单解析（符号解析）
Dialogue: 0,0:05:27.16,0:05:30.16,English,,0,0,0,,So programs define and reference symbols
Dialogue: 0,0:05:27.16,0:05:30.16,Chinese,,0,0,0,,程序会定义和引用符号
Dialogue: 0,0:05:30.44,0:05:37.10,English,,0,0,0,,Okay that what the linker refers to as symbols and these are global variables and functions
Dialogue: 0,0:05:30.44,0:05:37.10,Chinese,,0,0,0,,好的，链接器称为符号，这些是全局变量和函数
Dialogue: 0,0:05:37.62,0:05:44.40,English,,0,0,0,,Okay in the names and those objects they're referred to as a symbol
Dialogue: 0,0:05:37.62,0:05:44.40,Chinese,,0,0,0,,在名称和那些对象中，它们被称为符号
Dialogue: 0,0:05:44.46,0:05:52.28,English,,0,0,0,,So here we're declaring,we're defining a symbol called swap
Dialogue: 0,0:05:44.46,0:05:52.28,Chinese,,0,0,0,,第一行代码，我们在这里声明，我们正在定义一个名为 swap 的符号
Dialogue: 0,0:05:53.66,0:05:59.42,English,,0,0,0,,Here we're referring when we call swap, we're referring to that symbol
Dialogue: 0,0:05:53.66,0:05:59.42,Chinese,,0,0,0,,中间这行我们称之为 swap，我们指的是那个符号
Dialogue: 0,0:05:59.44,0:06:01.30,English,,0,0,0,,Okay that's a reference to the symbol
Dialogue: 0,0:05:59.44,0:06:01.30,Chinese,,0,0,0,,是的，这是对符号的一种引用
Dialogue: 0,0:06:03.30,0:06:07.20,English,,0,0,0,,And here we're defining a pointer to an int called xp
Dialogue: 0,0:06:03.30,0:06:07.20,Chinese,,0,0,0,,最后一行，我们定义了一个指向名为 xp 的 int 类型指针
Dialogue: 0,0:06:08.30,0:06:13.02,English,,0,0,0,,So we're defining xp and we're initializing it to the address of x
Dialogue: 0,0:06:08.30,0:06:13.02,Chinese,,0,0,0,,所以我们定义了 xp ，将它初始化为取 x 的地址
Dialogue: 0,0:06:13.02,0:06:15.52,English,,0,0,0,,So we're referring,that's a reference to x
Dialogue: 0,0:06:13.02,0:06:15.52,Chinese,,0,0,0,,这指的是，这是对 x 的引用
Dialogue: 0,0:06:18.00,0:06:24.24,English,,0,0,0,,Okay so the symbol definitions are stored in the object file by the assembler
Dialogue: 0,0:06:18.00,0:06:24.24,Chinese,,0,0,0,,汇编器将符号定义存储在目标文件中
Dialogue: 0,0:06:25.32,0:06:28.52,English,,0,0,0,,In a symbol table which is an array of structs
Dialogue: 0,0:06:25.32,0:06:28.52,Chinese,,0,0,0,,在这个符号表里面，全是一系列结构数组
Dialogue: 0,0:06:29.12,0:06:32.19,English,,0,0,0,,Where each structs contains information about the symbol
Dialogue: 0,0:06:29.12,0:06:32.19,Chinese,,0,0,0,,每个结构数组里面包含有关该符号的信息
Dialogue: 0,0:06:32.58,0:06:37.54,English,,0,0,0,,Like the name of the symbol its size and where it's located
Dialogue: 0,0:06:32.58,0:06:37.54,Chinese,,0,0,0,,比如符号的名称，它的大小和位置等等信息
Dialogue: 0,0:06:40.54,0:06:46.78,English,,0,0,0,,Now what we mean by symbol resolution is that during the linker linking process
Dialogue: 0,0:06:40.54,0:06:46.78,Chinese,,0,0,0,,所以现在我们说符号解析的意思是在链接器链接过程中
Dialogue: 0,0:06:47.58,0:06:54.94,English,,0,0,0,,The linker associates each symbol reference with exactly one symbol definition
Dialogue: 0,0:06:47.58,0:06:54.94,Chinese,,0,0,0,,链接器将每个符号引用与一个符号定义相关联
Dialogue: 0,0:06:57.68,0:06:59.42,English,,0,0,0,,Okay so it's possible in multiple
Dialogue: 0,0:06:57.68,0:06:59.42,Chinese,,0,0,0,,好的，所以这可能有多个
Dialogue: 0,0:07:00.64,0:07:04.16,English,,0,0,0,,You know why is this an issue well it's possible like in multiple modules
Dialogue: 0,0:07:00.64,0:07:04.16,Chinese,,0,0,0,,这中间可能会有些问题，比如在多个模块中
Dialogue: 0,0:07:04.16,0:07:06.84,English,,0,0,0,,You may declare a global variable with the same name
Dialogue: 0,0:07:04.16,0:07:06.84,Chinese,,0,0,0,,你可能会声明一个有相同名称的全局变量
Dialogue: 0,0:07:07.80,0:07:13.76,English,,0,0,0,,The linker has to decide which one of those definitions to use for all subsequent references
Dialogue: 0,0:07:07.80,0:07:13.76,Chinese,,0,0,0,,链接器必须决定将其中的某个定义用于所有后续引用
Dialogue: 0,0:07:16.70,0:07:21.74,English,,0,0,0,,Now once the linker is associated a unique object
Dialogue: 0,0:07:16.70,0:07:21.74,Chinese,,0,0,0,,一旦链接器和一个独一无二的目标建立联系
Dialogue: 0,0:07:21.74,0:07:25.44,English,,0,0,0,,With each a unique symbol definition with each reference
Dialogue: 0,0:07:21.74,0:07:25.44,Chinese,,0,0,0,,每个引用都会有一个唯一的符号定义
Dialogue: 0,0:07:26.84,0:07:29.22,English,,0,0,0,,Then it does the second step which is relocation
Dialogue: 0,0:07:26.84,0:07:29.22,Chinese,,0,0,0,,然后它执行第二步，即重定位
Dialogue: 0,0:07:29.78,0:07:33.32,English,,0,0,0,,And during relocation it merges all of the modules together
Dialogue: 0,0:07:29.78,0:07:33.32,Chinese,,0,0,0,,在重定位期间，它会将所有模块合并在一起
Dialogue: 0,0:07:33.70,0:07:42.98,English,,0,0,0,,Into a single executable object module that can be directly loaded and executed on the system
Dialogue: 0,0:07:33.70,0:07:42.98,Chinese,,0,0,0,,进入单个可执行目标模块后，就可以直接在系统上加载和执行
Dialogue: 0,0:07:43.98,0:07:47.34,English,,0,0,0,,So when it does this merging
Dialogue: 0,0:07:43.98,0:07:47.34,Chinese,,0,0,0,,所以当它合并时
Dialogue: 0,0:07:50.16,0:07:57.04,English,,0,0,0,,It has to figure out where each symbol,each function and each variable is going to be stored
Dialogue: 0,0:07:50.16,0:07:57.04,Chinese,,0,0,0,,它必须弄清楚每个符号，每个函数和每个变量是要准备存储在哪
Dialogue: 0,0:07:57.92,0:07:59.16,English,,0,0,0,,And this is called relocation
Dialogue: 0,0:07:57.92,0:07:59.16,Chinese,,0,0,0,,这称为重定位
Dialogue: 0,0:07:59.16,0:08:06.78,English,,0,0,0,,Because initially functions are just stored at some offset in their object module
Dialogue: 0,0:07:59.16,0:08:06.78,Chinese,,0,0,0,,因为最初的函数只是存储在其目标模块中的某个偏移处
Dialogue: 0,0:08:07.36,0:08:13.26,English,,0,0,0,,Right because that the linker doesn't know where those functions are actually going to be eventually a loaded into memory
Dialogue: 0,0:08:07.36,0:08:13.26,Chinese,,0,0,0,,正确，因为链接器不知道这些函数最终会被真正加载到内存中的哪个地方
Dialogue: 0,0:08:14.04,0:08:26.08,English,,0,0,0,,So before relocation the address of a function in the object module is just its offset in the module and similarly for data
Dialogue: 0,0:08:14.04,0:08:26.08,Chinese,,0,0,0,,所以在重定向前目标模块中的函数地址只是它在模块中的偏移量，对于数据也是如此
Dialogue: 0,0:08:26.62,0:08:31.38,English,,0,0,0,,During the relocation step the linker decides on
Dialogue: 0,0:08:26.62,0:08:31.38,Chinese,,0,0,0,,在重定位步骤期间，链接器会决定
Dialogue: 0,0:08:31.56,0:08:38.76,English,,0,0,0,,Where each symbol is going to be ultimately located in memory one at x,when the program executes
Dialogue: 0,0:08:31.56,0:08:38.76,Chinese,,0,0,0,,当程序执行时，每个符号最终将位于 x 中的存储区中的哪里
Dialogue: 0,0:08:39.54,0:08:45.48,English,,0,0,0,,And it binds that those absolute memory locations to the symbol
Dialogue: 0,0:08:39.54,0:08:45.48,Chinese,,0,0,0,,并且它将那些绝对存储器位置绑定到符号
Dialogue: 0,0:08:45.98,0:08:49.74,English,,0,0,0,,And then it goes and looks at all the references to those symbols
Dialogue: 0,0:08:45.98,0:08:49.74,Chinese,,0,0,0,,然后它会继续向下执行并查看所有对这些符号的引用
Dialogue: 0,0:08:50.46,0:08:54.74,English,,0,0,0,,And it updates those references so that they now they point to the correct address
Dialogue: 0,0:08:50.46,0:08:54.74,Chinese,,0,0,0,,而且它们会更新那些引用，以便它们现在能指向正确的地址
Dialogue: 0,0:08:55.54,0:08:57.72,English,,0,0,0,,Okay so figure out where stuff is going to go
Dialogue: 0,0:08:55.54,0:08:57.72,Chinese,,0,0,0,,好的，所以弄清楚原料要去哪里
Dialogue: 0,0:08:58.88,0:09:03.78,English,,0,0,0,,For each definition figure out where it's going to go and for each reference then update that reference
Dialogue: 0,0:08:58.88,0:09:03.78,Chinese,,0,0,0,,对于每个定义，找出它要去的位置以及每个引用，然后更新该引用
Dialogue: 0,0:09:03.78,0:09:06.14,English,,0,0,0,,So it now points to the right spot
Dialogue: 0,0:09:03.78,0:09:06.14,Chinese,,0,0,0,,所以它现在指向正确的位置
Dialogue: 0,0:09:09.90,0:09:14.54,English,,0,0,0,,So let's look at what these...how these steps work in more detail
Dialogue: 0,0:09:09.90,0:09:14.54,Chinese,,0,0,0,,那么让我们来看看这些......这些步骤如何更详细地运作
Dialogue: 0,0:09:14.92,0:09:18.22,English,,0,0,0,,Before that we need to define a few things
Dialogue: 0,0:09:14.92,0:09:18.22,Chinese,,0,0,0,,在那之前我们需要定义一些东西
Dialogue: 0,0:09:19.80,0:09:23.34,English,,0,0,0,,So there's three kinds of object modules that I've alluded to
Dialogue: 0,0:09:19.80,0:09:23.34,Chinese,,0,0,0,,所以我提到了三种目标模块
Dialogue: 0,0:09:24.18,0:09:29.72,English,,0,0,0,,There's the .o file which is a relocatable object module this is the output of the assembler
Dialogue: 0,0:09:24.18,0:09:29.72,Chinese,,0,0,0,,.o 文件是可重定位目标模块，这是汇编器的输出
Dialogue: 0,0:09:30.50,0:09:33.40,English,,0,0,0,,And it's not a binary file
Dialogue: 0,0:09:30.50,0:09:33.40,Chinese,,0,0,0,,它不是一个二进制文件
Dialogue: 0,0:09:34.00,0:09:39.34,English,,0,0,0,,But it's not in any form that can be directly loaded into memory
Dialogue: 0,0:09:34.00,0:09:39.34,Chinese,,0,0,0,,但它不能以任何形式直接加载到内存中
Dialogue: 0,0:09:39.34,0:09:43.60,English,,0,0,0,, It needs to be manipulated by the linker before it can be actually used
Dialogue: 0,0:09:39.34,0:09:43.60,Chinese,,0,0,0,, 在实际使用之前，需要由链接器对其进行操作
Dialogue: 0,0:09:44.64,0:09:48.48,English,,0,0,0,,There's the executable object file which is generated by the linker
Dialogue: 0,0:09:44.64,0:09:48.48,Chinese,,0,0,0,,由链接器生成的可执行目标文件
Dialogue: 0,0:09:50.18,0:09:51.70,English,,0,0,0,,These is called a.out files
Dialogue: 0,0:09:50.18,0:09:51.70,Chinese,,0,0,0,,这被称为 a.out 文件
Dialogue: 0,0:09:51.72,0:09:57.06,English,,0,0,0,,Sometimes historically the very first Linux systems the executable
Dialogue: 0,0:09:51.72,0:09:57.06,Chinese,,0,0,0,,在历史上第一个 Linux 操作系统就是可执行的
Dialogue: 0,0:09:57.06,0:10:04.36,English,,0,0,0,,This sort of the default name that they the developers of Unix used,the default name for their executables was a.out
Dialogue: 0,0:09:57.06,0:10:04.36,Chinese,,0,0,0,,这是 Unix 开发人员使用的默认名称，其可执行文件的默认名称是 a.out
Dialogue: 0,0:10:05.72,0:10:10.34,English,,0,0,0,,So that's just sort of a historical reason that it's called a.out
Dialogue: 0,0:10:05.72,0:10:10.34,Chinese,,0,0,0,,所以这只是一个历史原因所以它被称为 a.out
Dialogue: 0,0:10:10.96,0:10:16.60,English,,0,0,0,,And then there's another type of object file called a shared object file or .so file
Dialogue: 0,0:10:10.96,0:10:16.60,Chinese,,0,0,0,,然后是另一种称为共享目标文件或 .so 文件的目标文件
Dialogue: 0,0:10:17.12,0:10:24.46,English,,0,0,0,,Which is a modern technique for creating shared libraries
Dialogue: 0,0:10:17.12,0:10:24.46,Chinese,,0,0,0,,这是一种用于创建共享库的现代技术
Dialogue: 0,0:10:24.62,0:10:27.64,English,,0,0,0,,And we'll look at those,we'll look at those later today
Dialogue: 0,0:10:24.62,0:10:27.64,Chinese,,0,0,0,,那个我们之后再了解，将在今天晚些时候再学习了解
Dialogue: 0,0:10:29.14,0:10:34.50,English,,0,0,0,,Now object modules come in a standard format called ELF format
Dialogue: 0,0:10:29.14,0:10:34.50,Chinese,,0,0,0,,现在，目标模块采用称为 ELF 格式的标准格式
Dialogue: 0,0:10:35.92,0:10:41.12,English,,0,0,0,,And it's a unified format for .o files for executables and for .so files
Dialogue: 0,0:10:35.92,0:10:41.12,Chinese,,0,0,0,,它是可执行文件，.so 文件，.o 文件的统一格式
Dialogue: 0,0:10:41.12,0:10:45.34,English,,0,0,0,,They all use the same format,the same general format
Dialogue: 0,0:10:41.12,0:10:45.34,Chinese,,0,0,0,,他们都使用一样的格式，一样的通用的格式
Dialogue: 0,0:10:48.26,0:10:52.68,English,,0,0,0,,So this while these ELF binaries are
Dialogue: 0,0:10:48.26,0:10:52.68,Chinese,,0,0,0,,这就是这些 ELF 二进制文件
Dialogue: 0,0:10:53.48,0:10:55.58,English,,0,0,0,,Their binaries they're very structured
Dialogue: 0,0:10:53.48,0:10:55.58,Chinese,,0,0,0,,他们的二进制文件非常有条理
Dialogue: 0,0:10:56.02,0:10:58.14,English,,0,0,0,,Ok and they're broken up into sections
Dialogue: 0,0:10:56.02,0:10:58.14,Chinese,,0,0,0,,他们被分成几个部分
Dialogue: 0,0:10:58.94,0:11:08.02,English,,0,0,0,,The at the beginning is a header,that defines things like the size of the word the byte ordering
Dialogue: 0,0:10:58.94,0:11:08.02,Chinese,,0,0,0,,开头是一个头，它定义了（生成该文件系统的）字节顺序和字的大小
Dialogue: 0,0:11:08.46,0:11:12.46,English,,0,0,0,,Whether it's a .o,a .out or a .so
Dialogue: 0,0:11:08.46,0:11:12.46,Chinese,,0,0,0,,无论是 .o, .out 还是 .so
Dialogue: 0,0:11:12.90,0:11:19.12,English,,0,0,0,,So it just provides some sort of general information about this binary
Dialogue: 0,0:11:12.90,0:11:19.12,Chinese,,0,0,0,,它只是提供了关于这个二进制文件的一般信息
Dialogue: 0,0:11:19.76,0:11:23.88,English,,0,0,0,,And then there's what's a so called segment header table which is
Dialogue: 0,0:11:19.76,0:11:23.88,Chinese,,0,0,0,,然后就是所谓的节头部表
Dialogue: 0,0:11:24.74,0:11:28.10,English,,0,0,0,,It's only defined for the executable object files
Dialogue: 0,0:11:24.74,0:11:28.10,Chinese,,0,0,0,,它只在可执行目标文件中定义
Dialogue: 0,0:11:28.50,0:11:34.30,English,,0,0,0,,And indicates where all the different segments of the code are going to go in memory
Dialogue: 0,0:11:28.50,0:11:34.30,Chinese,,0,0,0,,并指出代码的所有不同段在内存中的位置
Dialogue: 0,0:11:34.30,0:11:38.87,English,,0,0,0,,So where does your stack go, where do your shared libraries go
Dialogue: 0,0:11:34.30,0:11:38.87,Chinese,,0,0,0,,那么你的栈在哪里，你的共享库去了哪里
Dialogue: 0,0:11:38.87,0:11:42.96,English,,0,0,0,,Where does your that you're initialized and uninitialized data
Dialogue: 0,0:11:38.87,0:11:42.96,Chinese,,0,0,0,,你初始化数据和未初始化数据的位置在哪里
Dialogue: 0,0:11:43.74,0:11:45.00,English,,0,0,0,,Where does your code go
Dialogue: 0,0:11:43.74,0:11:45.00,Chinese,,0,0,0,,你的代码去了哪里
Dialogue: 0,0:11:45.00,0:11:51.62,English,,0,0,0,,Right so all these various sections are defined in the segment header table
Dialogue: 0,0:11:45.00,0:11:51.62,Chinese,,0,0,0,,正确，因此所有这些不同的部分都在段头表中定义
Dialogue: 0,0:11:52.60,0:11:59.60,English,,0,0,0,,And then there's the code itself which is called the .text section for sort of arcane historical reasons
Dialogue: 0,0:11:52.60,0:11:59.60,Chinese,,0,0,0,,然后是代码本身，出于某种神秘的历史原因它被称为 .text 部分
Dialogue: 0,0:11:59.78,0:12:02.16,English,,0,0,0,,So .text is always code
Dialogue: 0,0:11:59.78,0:12:02.16,Chinese,,0,0,0,, .text 一般是代码
Dialogue: 0,0:12:03.96,0:12:08.26,English,,0,0,0,,And then that's followed by read only data
Dialogue: 0,0:12:03.96,0:12:08.26,Chinese,,0,0,0,,然后是只读数据
Dialogue: 0,0:12:08.42,0:12:11.14,English,,0,0,0,,Such as the jump tables in switch statements
Dialogue: 0,0:12:08.42,0:12:11.14,Chinese,,0,0,0,,比如 switch 语句中的跳转表
Dialogue: 0,0:12:12.52,0:12:20.02,English,,0,0,0,,So text and read only the .text and .rodata have the property that they're both read-only you don't write to them
Dialogue: 0,0:12:12.52,0:12:20.02,Chinese,,0,0,0,,因此，文本 .text 和只读 .rodata 具有以下属性：它们都是只读的，你不会写入它们
Dialogue: 0,0:12:21.90,0:12:24.78,English,,0,0,0,,Then that's followed by the .data section
Dialogue: 0,0:12:21.90,0:12:24.78,Chinese,,0,0,0,,然后是 .data 部分
Dialogue: 0,0:12:24.96,0:12:29.98,English,,0,0,0,,Which is contains space for all of your initialized global variables
Dialogue: 0,0:12:24.96,0:12:29.98,Chinese,,0,0,0,,它包含了所有初始化全局变量的空间
Dialogue: 0,0:12:31.06,0:12:33.44,English,,0,0,0,,And then there's a section called .bss
Dialogue: 0,0:12:31.06,0:12:33.44,Chinese,,0,0,0,,接下来是一个名为 .bss 的部分
Dialogue: 0,0:12:33.56,0:12:41.36,English,,0,0,0,,Which defines the uninitialized global variables
Dialogue: 0,0:12:33.56,0:12:41.36,Chinese,,0,0,0,,它定义了未初始化的全局变量
Dialogue: 0,0:12:42.78,0:12:46.82,English,,0,0,0,,Now this doesn't actually take up any space because they're uninitialized droids
Dialogue: 0,0:12:42.78,0:12:46.82,Chinese,,0,0,0,,这个节实际上并没有占用任何实际的空间，因为它们仅仅是未初始化的占位符
Dialogue: 0,0:12:48.10,0:12:50.76,English,,0,0,0,,Ok but there are entries in the symbol table for them
Dialogue: 0,0:12:48.10,0:12:50.76,Chinese,,0,0,0,,好的，但符号表中会有条目
Dialogue: 0,0:12:51.34,0:12:57.30,English,,0,0,0,,And in it at when this program gets loaded these variables are going to need
Dialogue: 0,0:12:51.34,0:12:57.30,Chinese,,0,0,0,,在这个程序加载时会需要这些变量
Dialogue: 0,0:12:58.54,0:13:00.86,English,,0,0,0,,They're actually going to have to have space allocated for them
Dialogue: 0,0:12:58.54,0:13:00.86,Chinese,,0,0,0,,在这个时候就必须为他们分配空间
Dialogue: 0,0:13:01.70,0:13:08.26,English,,0,0,0,,.bss is another one of those sort of arcane names,that cope goes all the way back to the 60s
Dialogue: 0,0:13:01.70,0:13:08.26,Chinese,,0,0,0,,.bss 是另一种神秘的名字，应对可以追溯到 60 年代
Dialogue: 0,0:13:08.78,0:13:11.94,English,,0,0,0,,For there was IBM instruction called the block started by symbol
Dialogue: 0,0:13:08.78,0:13:11.94,Chinese,,0,0,0,,那时候 IBM 指令将其称为块符号
Dialogue: 0,0:13:12.42,0:13:16.22,English,,0,0,0,,I think a better way to remember what it means is better save space
Dialogue: 0,0:13:12.42,0:13:16.22,Chinese,,0,0,0,,我认为理解它的意义最好的方式是 better save space (BSS) 的缩写
Dialogue: 0,0:13:16.66,0:13:21.66,English,,0,0,0,,Ok so you can,if you have a separate section for the uninitialized variable since uninitialized
Dialogue: 0,0:13:16.66,0:13:21.66,Chinese,,0,0,0,,好的，如果在未初始化过程开始时有一个单独的节用于未初始化的变量，你可以这样理解
Dialogue: 0,0:13:22.16,0:13:29.46,English,,0,0,0,,You don't have to...they don't have to consume any room in the .o file
Dialogue: 0,0:13:22.16,0:13:29.46,Chinese,,0,0,0,,他们不必占用 .o 文件中的任何空间
Dialogue: 0,0:13:32.78,0:13:35.54,English,,0,0,0,,Ok there's also a section for the symbol table
Dialogue: 0,0:13:32.78,0:13:35.54,Chinese,,0,0,0,,好的接下来还有一个部分是针对符号表的
Dialogue: 0,0:13:37.42,0:13:44.56,English,,0,0,0,,This contained like I said it's an array of structs for procedures global variables
Dialogue: 0,0:13:37.42,0:13:44.56,Chinese,,0,0,0,,就像我之前说的那样它包含程序全局变量的结构数组
Dialogue: 0,0:13:47.72,0:13:50.80,English,,0,0,0,,And anything defined with the static attribute
Dialogue: 0,0:13:47.72,0:13:50.80,Chinese,,0,0,0,,以及我们使用 static 属性定义的任何内容
Dialogue: 0,0:13:53.02,0:13:57.68,English,,0,0,0,,And each one of these symbols gets an entry in the symbol table
Dialogue: 0,0:13:53.02,0:13:57.68,Chinese,,0,0,0,,并且这些符号中的每一个都在符号表中获得了一个条目
Dialogue: 0,0:13:59.18,0:14:04.56,English,,0,0,0,,And then there's two sections called them that contain relocation info so this is the notes
Dialogue: 0,0:13:59.18,0:14:04.56,Chinese,,0,0,0,,然后有两个部分称为包含重定位信息的部分，称为记录
Dialogue: 0,0:14:06.62,0:14:12.04,English,,0,0,0,,When that linker went and identified all the references to symbols it put a little note to see
Dialogue: 0,0:14:06.62,0:14:12.04,Chinese,,0,0,0,,当链接器去识别所有对符号的引用时，它就会记下一些记录
Dialogue: 0,0:14:12.04,0:14:16.00,English,,0,0,0,,I'm going to have to remember to fix this the reference to this symbol up
Dialogue: 0,0:14:12.04,0:14:16.00,Chinese,,0,0,0,,我不得不记住去安排对这个符号的引用
Dialogue: 0,0:14:16.44,0:14:21.16,English,,0,0,0,,When I actually create the executable
Dialogue: 0,0:14:16.44,0:14:21.16,Chinese,,0,0,0,,在我实际创建可执行文件时
Dialogue: 0,0:14:21.84,0:14:25.26,English,,0,0,0,,So a relocation entry is just like that the linker
Dialogue: 0,0:14:21.84,0:14:25.26,Chinese,,0,0,0,,所以重定向条目就像链接器一样
Dialogue: 0,0:14:25.80,0:14:31.74,English,,0,0,0,,That it's a note that the assembler makes to the linker to say hey you're going to have to fix up this this reference
Dialogue: 0,0:14:25.80,0:14:31.74,Chinese,,0,0,0,,这是一个记录，汇编程序让链接器说「嘿」，你将不得不安排这个引用
Dialogue: 0,0:14:31.74,0:14:38.16,English,,0,0,0,,Because I don't know I don't know where this symbol is actually going to be stored in memory when it's loaded
Dialogue: 0,0:14:31.74,0:14:38.16,Chinese,,0,0,0,,因为我不知道这个符号在加载时实际存储在内存中的位置
Dialogue: 0,0:14:41.56,0:14:43.72,English,,0,0,0,,Okay and then there's a debug section that contains
Dialogue: 0,0:14:41.56,0:14:43.72,Chinese,,0,0,0,,好的，接下来是调试部分
Dialogue: 0,0:14:45.32,0:14:54.22,English,,0,0,0,,Information that relates line numbers to in the source code to line numbers in the machine code
Dialogue: 0,0:14:45.32,0:14:54.22,Chinese,,0,0,0,,它包含了将源代码中的行号与机器代码中的行号相关联的信息
Dialogue: 0,0:14:55.10,0:14:59.40,English,,0,0,0,,Okay and so this is called .debug and this is what you get when you compile with -g
Dialogue: 0,0:14:55.10,0:14:59.40,Chinese,,0,0,0,,好的，所以这叫做 .debug，这是你用-g编译时得到的
Dialogue: 0,0:14:59.98,0:15:06.04,English,,0,0,0,,And then there's a header table that tells you where all these different sections start
Dialogue: 0,0:14:59.98,0:15:06.04,Chinese,,0,0,0,,然后有一个节头表，告诉你所有这些不同部分的起始位置
Dialogue: 0,0:15:08.20,0:15:11.34,English,,0,0,0,,Now to a linker there's three different kinds of symbols
Dialogue: 0,0:15:08.20,0:15:11.34,Chinese,,0,0,0,,现在我们说链接器有三种不同的符号
Dialogue: 0,0:15:12.58,0:15:17.00,English,,0,0,0,,Global symbols are defined in some module m
Dialogue: 0,0:15:12.58,0:15:17.00,Chinese,,0,0,0,,全局符号在一些模块 m 中定义
Dialogue: 0,0:15:17.50,0:15:20.82,English,,0,0,0,,And they can be used by other modules
Dialogue: 0,0:15:17.50,0:15:20.82,Chinese,,0,0,0,,它们可以被其他模块使用
Dialogue: 0,0:15:21.08,0:15:27.14,English,,0,0,0,,Right so I mean did you notice when we...if we have a program that consists of multiple modules
Dialogue: 0,0:15:21.08,0:15:27.14,Chinese,,0,0,0,,是的，所以我的意思是你注意到我们......如果我们有一个由多个模块组成的程序
Dialogue: 0,0:15:27.56,0:15:30.66,English,,0,0,0,,And we compile each one of those modules into a .o file
Dialogue: 0,0:15:27.56,0:15:30.66,Chinese,,0,0,0,,然后我们将每个模块编译成一个 .o 文件
Dialogue: 0,0:15:32.18,0:15:37.42,English,,0,0,0,,Will be calling functions that aren't defined,that are defined by other modules right
Dialogue: 0,0:15:32.18,0:15:37.42,Chinese,,0,0,0,,将调用由其他模块正确定义的未定义的函数
Dialogue: 0,0:15:38.94,0:15:44.64,English,,0,0,0,,Okay so those,but there's no error though that the compiler doesn't throw an error
Dialogue: 0,0:15:38.94,0:15:44.64,Chinese,,0,0,0,,好吧那些，但是虽然编译器没有抛出错误
Dialogue: 0,0:15:44.64,0:15:48.44,English,,0,0,0,,Because it's assuming that those are defined in other modules and
Dialogue: 0,0:15:44.64,0:15:48.44,Chinese,,0,0,0,,因为它假设那些是在其他模块中定义的
Dialogue: 0,0:15:49.10,0:15:53.32,English,,0,0,0,,It assumes the linker will be able to find them in and determine the address
Dialogue: 0,0:15:49.10,0:15:53.32,Chinese,,0,0,0,,它假定链接器能够找到它们并确定地址
Dialogue: 0,0:15:54.40,0:16:04.06,English,,0,0,0,,So anything that's defined with that, any global,either global variable or function name
Dialogue: 0,0:15:54.40,0:16:04.06,Chinese,,0,0,0,,所以用任何全局变量或函数名定义的任何东西
Dialogue: 0,0:16:04.46,0:16:08.82,English,,0,0,0,,That's defined without the static attribute is a global symbol
Dialogue: 0,0:16:04.46,0:16:08.82,Chinese,,0,0,0,,只要没有静态属性的定义那就是一个全局符号
Dialogue: 0,0:16:10.92,0:16:14.92,English,,0,0,0,,Okay now and then external symbols are kind of the flip side of that
Dialogue: 0,0:16:10.92,0:16:14.92,Chinese,,0,0,0,,好的，然后外部符号就是其中的一种
Dialogue: 0,0:16:15.08,0:16:19.12,English,,0,0,0,,External symbols are symbols that are referenced by some module
Dialogue: 0,0:16:15.08,0:16:19.12,Chinese,,0,0,0,,外部符号是某些模块引用的符号
Dialogue: 0,0:16:19.44,0:16:21.54,English,,0,0,0,,But defined in some other module
Dialogue: 0,0:16:19.44,0:16:21.54,Chinese,,0,0,0,,但在其他一些模块中定义
Dialogue: 0,0:16:21.78,0:16:26.64,English,,0,0,0,,Okay so in a little running example
Dialogue: 0,0:16:21.78,0:16:26.64,Chinese,,0,0,0,,好吧，在这个小运行示例中
Dialogue: 0,0:16:27.08,0:16:32.66,English,,0,0,0,,When main.c code called the function some it was referencing an external symbol
Dialogue: 0,0:16:27.08,0:16:32.66,Chinese,,0,0,0,,当 main.c 代码调用函数时，它就会引用了一个外部符号
Dialogue: 0,0:16:34.20,0:16:42.58,English,,0,0,0,,Okay and then there's local symbols and these are symbols that are defined and referenced within a module
Dialogue: 0,0:16:34.20,0:16:42.58,Chinese,,0,0,0,,好的，接下来我们介绍局部符号，这是在模块中定义和引用的符号
Dialogue: 0,0:16:43.48,0:16:48.12,English,,0,0,0,,Okay and those you create that,this is not this is different from local variables
Dialogue: 0,0:16:43.48,0:16:48.12,Chinese,,0,0,0,,好的，那些是你创建的（程序里面的变量），它不同于局部变量
Dialogue: 0,0:16:48.12,0:16:56.52,English,,0,0,0,,Okay the linker you know local C variables are managed by the compiler on the stack
Dialogue: 0,0:16:48.12,0:16:56.52,Chinese,,0,0,0,,好的，你知道的，局部 C 程序变量的链接器是由堆栈上的编译器管理的
Dialogue: 0,0:16:57.08,0:17:01.38,English,,0,0,0,,Linker has no idea about local C variables
Dialogue: 0,0:16:57.08,0:17:01.38,Chinese,,0,0,0,,链接器它是不知道局部 C 程序的变量的
Dialogue: 0,0:17:01.90,0:17:04.32,English,,0,0,0,,Okay in this context when we talk about a local symbol
Dialogue: 0,0:17:01.90,0:17:04.32,Chinese,,0,0,0,,好的，在这种情况下当我们谈到一个局部符号
Dialogue: 0,0:17:04.92,0:17:12.66,English,,0,0,0,,We're talking about is either, is a global variable or function declared with the static attribute
Dialogue: 0,0:17:04.92,0:17:12.66,Chinese,,0,0,0,,实际上我们讨论的是，一个全局变量或用 static 属性声明的函数
Dialogue: 0,0:17:14.94,0:17:17.26,English,,0,0,0,,Whose that can only be referenced from within that module
Dialogue: 0,0:17:14.94,0:17:17.26,Chinese,,0,0,0,,那玩意只能从该模块中引用它
Dialogue: 0,0:17:17.26,0:17:24.02,English,,0,0,0,,So we say that the scope of the a function or global variable defined with the static
Dialogue: 0,0:17:17.26,0:17:24.02,Chinese,,0,0,0,,所以我们说用 static 属性定义的函数或全局变量
Dialogue: 0,0:17:24.52,0:17:27.86,English,,0,0,0,,Attribute is limited to the module that it was defined in
Dialogue: 0,0:17:24.52,0:17:27.86,Chinese,,0,0,0,,其范围仅限于其定义的模块
Dialogue: 0,0:17:30.06,0:17:33.78,English,,0,0,0,,Okay so this is in C, this is how we do abstraction
Dialogue: 0,0:17:30.06,0:17:33.78,Chinese,,0,0,0,,好的，这就是在 C 语言里 ，这就是我们怎么进行抽象
Dialogue: 0,0:17:34.90,0:17:38.24,English,,0,0,0,,And this is how we can create sort of private functions that
Dialogue: 0,0:17:34.90,0:17:38.24,Chinese,,0,0,0,,以及这就是我们如何创建私有函数
Dialogue: 0,0:17:39.36,0:17:44.38,English,,0,0,0,,And private functions that can't be called from outside that module
Dialogue: 0,0:17:39.36,0:17:44.38,Chinese,,0,0,0,,并且是无法从该模块外部调用的私有函数
Dialogue: 0,0:17:45.82,0:17:53.16,English,,0,0,0,,Okay so for instance if we want to make a library in C of functions, we want to make a collection of functions that
Dialogue: 0,0:17:45.82,0:17:53.16,Chinese,,0,0,0,,好的，例如，如果我们想在函数 C 中创建一个库，我们想要创建一个函数集合
Dialogue: 0,0:17:53.61,0:17:57.94,English,,0,0,0,,Other programs can then call it link into their program and call
Dialogue: 0,0:17:53.61,0:17:57.94,Chinese,,0,0,0,,其他程序可以将其称为链接到他们程序和调用
Dialogue: 0,0:17:58.86,0:18:07.52,English,,0,0,0,,The functions that we want to make visible to other programs are defined without the static attribute
Dialogue: 0,0:17:58.86,0:18:07.52,Chinese,,0,0,0,,我们希望对其他程序可见的函数是在没有加上 static 属性定义的
Dialogue: 0,0:18:08.38,0:18:12.10,English,,0,0,0,,And the functions that we want to have private and just be internal
Dialogue: 0,0:18:08.38,0:18:12.10,Chinese,,0,0,0,,我们希望只是对于内部而言的
Dialogue: 0,0:18:12.76,0:18:15.36,English,,0,0,0,,We declare what the static attribute okay
Dialogue: 0,0:18:12.76,0:18:15.36,Chinese,,0,0,0,,我们声明 static 属性
Dialogue: 0,0:18:16.00,0:18:20.50,English,,0,0,0,,And that way we get abstraction and we get hiding information hiding
Dialogue: 0,0:18:16.00,0:18:20.50,Chinese,,0,0,0,,这样我们就可以抽象，并将我们希望隐藏的信息隐藏
Dialogue: 0,0:18:20.98,0:18:26.86,English,,0,0,0,,And we're only exposing data and functions that we want to expose
Dialogue: 0,0:18:20.98,0:18:26.86,Chinese,,0,0,0,,我们只展示我们想要公开的数据和功能
Dialogue: 0,0:18:29.60,0:18:33.36,English,,0,0,0,,All right so let's look in detail how the symbol resolution step works
Dialogue: 0,0:18:29.60,0:18:33.36,Chinese,,0,0,0,,好的，接下来让我们详细了解符号解析步骤的工作原理
Dialogue: 0,0:18:34.02,0:18:38.36,English,,0,0,0,,We call a example program
Dialogue: 0,0:18:34.02,0:18:38.36,Chinese,,0,0,0,,我们来拜访一下这个例子程序
Dialogue: 0,0:18:41.26,0:18:44.40,English,,0,0,0,,So here we're referencing a global called array
Dialogue: 0,0:18:41.26,0:18:44.40,Chinese,,0,0,0,,这里我们引用了一个全局调用数组
Dialogue: 0,0:18:45.94,0:18:50.26,English,,0,0,0,,That's defined within main.c
Dialogue: 0,0:18:45.94,0:18:50.26,Chinese,,0,0,0,,这个在 main.c 中定义
Dialogue: 0,0:18:54.20,0:18:56.60,English,,0,0,0,,Here we're defining main
Dialogue: 0,0:18:54.20,0:18:56.60,Chinese,,0,0,0,,在这里，我们定义了 main 函数
Dialogue: 0,0:18:57.78,0:18:59.36,English,,0,0,0,,A global called main
Dialogue: 0,0:18:57.78,0:18:59.36,Chinese,,0,0,0,,一个全局调用 main 函数
Dialogue: 0,0:19:04.28,0:19:06.46,English,,0,0,0,,Here we're referencing a global called sum
Dialogue: 0,0:19:04.28,0:19:06.46,Chinese,,0,0,0,,在这里，我们引用一个全局调用 sum 函数
Dialogue: 0,0:19:06.78,0:19:08.90,English,,0,0,0,,That's defined in sum.c
Dialogue: 0,0:19:06.78,0:19:08.90,Chinese,,0,0,0,,它定义在 sum.c 中间
Dialogue: 0,0:19:11.10,0:19:17.34,English,,0,0,0,,And val is a local C variable on the stack and linker knows nothing about that okay
Dialogue: 0,0:19:11.10,0:19:17.34,Chinese,,0,0,0,,val 是堆栈上的局部 C 变量，链接器实际上对其没有任何了解
Dialogue: 0,0:19:20.00,0:19:23.58,English,,0,0,0,,Now loads i, s which are also local variables
Dialogue: 0,0:19:20.00,0:19:23.58,Chinese,,0,0,0,,现在加载 i，s, 当然这两者也是局部变量
Dialogue: 0,0:19:25.76,0:19:36.88,English,,0,0,0,,Now let's make sure that we understand the difference between local static C variables versus local non static C variables so
Dialogue: 0,0:19:25.76,0:19:36.88,Chinese,,0,0,0,,现在让我们确保我们理解了局部 static C 变量与本地非 static C 变量之间的区别
Dialogue: 0,0:19:39.74,0:19:44.12,English,,0,0,0,,Here we're defining a local static variable called int
Dialogue: 0,0:19:39.74,0:19:44.12,Chinese,,0,0,0,,这里我们定义一个类型为 int 的局部静态变量
Dialogue: 0,0:19:45.16,0:19:46.84,English,,0,0,0,,Within this function f
Dialogue: 0,0:19:45.16,0:19:46.84,Chinese,,0,0,0,,在这个函数 f 中
Dialogue: 0,0:19:48.46,0:19:53.40,English,,0,0,0,,Now because it's local, its scope is limited to this function
Dialogue: 0,0:19:48.46,0:19:53.40,Chinese,,0,0,0,,现在因为它是的局部，它的范围仅限于此功能
Dialogue: 0,0:19:53.40,0:19:58.88,English,,0,0,0,,So this variable x can only be referenced within function f
Dialogue: 0,0:19:53.40,0:19:58.88,Chinese,,0,0,0,,所以这个变量 x 只能在函数 f 中引用
Dialogue: 0,0:20:01.06,0:20:07.10,English,,0,0,0,,And similarly for this definition of x in function g
Dialogue: 0,0:20:01.06,0:20:07.10,Chinese,,0,0,0,,类似于函数 g 中 x 的这个定义
Dialogue: 0,0:20:07.98,0:20:11.08,English,,0,0,0,,Can only be referenced by function g
Dialogue: 0,0:20:07.98,0:20:11.08,Chinese,,0,0,0,,只能被函数 g 引用
Dialogue: 0,0:20:11.58,0:20:17.08,English,,0,0,0,,Now what's ,but because it's declared with the static attribute it's not stored on the stack
Dialogue: 0,0:20:11.58,0:20:17.08,Chinese,,0,0,0,,它是什么样的，但因为它是用静态属性声明的，所以它不存储在堆栈中
Dialogue: 0,0:20:17.78,0:20:22.18,English,,0,0,0,,It's actually stored in .data just like a global would be
Dialogue: 0,0:20:17.78,0:20:22.18,Chinese,,0,0,0,,它实际上存储在 .data 文件中，就像全局变量一样
Dialogue: 0,0:20:22.36,0:20:29.20,English,,0,0,0,,So it's like a global in the sense that it's actually stored in .data rather than the stack
Dialogue: 0,0:20:22.36,0:20:29.20,Chinese,,0,0,0,,所以它就像一个实际上存储在 .data 而不是堆栈中的全局变量
Dialogue: 0,0:20:29.86,0:20:35.48,English,,0,0,0,,But it's like a local C variable in the sense that its scope is limited just to the function that it's defined in
Dialogue: 0,0:20:29.86,0:20:35.48,Chinese,,0,0,0,,但它就像一个局部 C 程序变量，因为它的范围仅限于它所定义的函数
Dialogue: 0,0:20:36.48,0:20:43.48,English,,0,0,0,,Okay so what the compiler will do it'll allocate space for each definition of x
Dialogue: 0,0:20:36.48,0:20:43.48,Chinese,,0,0,0,,好的，那么编译器会做什么呢，它将为每个 x 的定义分配空间
Dialogue: 0,0:20:43.50,0:20:47.28,English,,0,0,0,,So this and it'll give it some name to disambiguate it
Dialogue: 0,0:20:43.50,0:20:47.28,Chinese,,0,0,0,,所以这样的话，它会给它赋予一些名称来消除它的歧义
Dialogue: 0,0:20:47.28,0:20:49.56,English,,0,0,0,,So maybe it will call this one x.1
Dialogue: 0,0:20:47.28,0:20:49.56,Chinese,,0,0,0,,所以也许它会称之为 x.1
Dialogue: 0,0:20:49.98,0:20:51.82,English,,0,0,0,,And maybe this one x.2
Dialogue: 0,0:20:49.98,0:20:51.82,Chinese,,0,0,0,,也有可能叫 x.2
Dialogue: 0,0:20:52.80,0:20:57.54,English,,0,0,0,,So these symbols are allocated in .data because
Dialogue: 0,0:20:52.80,0:20:57.54,Chinese,,0,0,0,,这些符号分配在在 .data 中，因为
Dialogue: 0,0:20:57.94,0:21:04.18,English,,0,0,0,,Because they're initialized and they get symbol table entries just like any other symbol
Dialogue: 0,0:20:57.94,0:21:04.18,Chinese,,0,0,0,,因为它们已初始化并且像任何其他符号一样会获得符号表条目
Dialogue: 0,0:21:08.00,0:21:11.16,English,,0,0,0,,Okay so I said that during symbol resolution
Dialogue: 0,0:21:08.00,0:21:11.16,Chinese,,0,0,0,,好的，所以我在讲解符号解析期间说过
Dialogue: 0,0:21:11.56,0:21:20.32,English,,0,0,0,,The linker associates each reference,each symbol reference to exactly one unique symbol definition
Dialogue: 0,0:21:11.56,0:21:20.32,Chinese,,0,0,0,,链接器和每个引用连接起来，每个符号引用与一个唯一的符号定义相关联
Dialogue: 0,0:21:21.58,0:21:25.72,English,,0,0,0,,Now how does it do that if there's multiple symbol definitions across all the modules
Dialogue: 0,0:21:21.58,0:21:25.72,Chinese,,0,0,0,,现在有一种情况，如果所有模块中有多个符号定义，它是如何做的呢
Dialogue: 0,0:21:27.64,0:21:35.32,English,,0,0,0,,So to understand this will define symbols as being either strong or weak
Dialogue: 0,0:21:27.64,0:21:35.32,Chinese,,0,0,0,,因此，要理解这种情况需要将把符号定义为强或弱
Dialogue: 0,0:21:35.78,0:21:43.86,English,,0,0,0,,So strong symbols are either procedures or function names or initialize global variables
Dialogue: 0,0:21:35.78,0:21:43.86,Chinese,,0,0,0,,过程，函数名称或已初始化的全局变量是强符号
Dialogue: 0,0:21:44.66,0:21:47.22,English,,0,0,0,,Weak symbols are uninitialized global variables
Dialogue: 0,0:21:44.66,0:21:47.22,Chinese,,0,0,0,,弱符号是未初始化的全局变量
Dialogue: 0,0:21:49.18,0:21:54.62,English,,0,0,0,,Okay so int foo here is a strong symbol
Dialogue: 0,0:21:49.18,0:21:54.62,Chinese,,0,0,0,,好吧，所以这里的 int foo 是一个强有力的象征
Dialogue: 0,0:21:54.62,0:21:59.70,English,,0,0,0,,Because it's initialized,we're initializing it. p1 is strong by definition
Dialogue: 0,0:21:54.62,0:21:59.70,Chinese,,0,0,0,,因为它已初始化，我们正在初始化它。根据定义，p1 是强符号
Dialogue: 0,0:22:00.74,0:22:08.44,English,,0,0,0,,foo is weak in p2.c, this definition of foo is weak
Dialogue: 0,0:22:00.74,0:22:08.44,Chinese,,0,0,0,,p2.c 中的 foo 就是弱符号，这个定义的 foo 就是弱符号
Dialogue: 0,0:22:09.06,0:22:12.78,English,,0,0,0,,Because it's uninitialized and the definition of p2 is strong
Dialogue: 0,0:22:09.06,0:22:12.78,Chinese,,0,0,0,,因为它没有初始化，下面这个 p2 的定义的话就是强符号
Dialogue: 0,0:22:13.64,0:22:17.74,English,,0,0,0,,Okay so that the rules, the linker uses are the following
Dialogue: 0,0:22:13.64,0:22:17.74,Chinese,,0,0,0,,好的，链接器使用的规则如下
Dialogue: 0,0:22:19.34,0:22:22.34,English,,0,0,0,,Multiple strong symbols not allowed so that's an error
Dialogue: 0,0:22:19.34,0:22:22.34,Chinese,,0,0,0,,不允许有多个强符号，以免出现错误
Dialogue: 0,0:22:24.14,0:22:30.34,English,,0,0,0,,Okay so that means that if across multiple modules we declare a function with the same name
Dialogue: 0,0:22:24.14,0:22:30.34,Chinese,,0,0,0,,好的，这意味着如果我们在多个模块中，声明一个具有相同名称的函数
Dialogue: 0,0:22:30.54,0:22:32.72,English,,0,0,0,,The linker will throw an error that's not allowed
Dialogue: 0,0:22:30.54,0:22:32.72,Chinese,,0,0,0,,链接器将抛出一个不允许的错误
Dialogue: 0,0:22:34.44,0:22:42.72,English,,0,0,0,,Given a strong symbol and multiple weak symbols if the linker will always choose the the strong symbol
Dialogue: 0,0:22:34.44,0:22:42.72,Chinese,,0,0,0,,如果链接器总是选择强符号，则给出强符号和多个弱符号
Dialogue: 0,0:22:44.00,0:22:47.28,English,,0,0,0,,Now remember if we initialize a global variable
Dialogue: 0,0:22:44.00,0:22:47.28,Chinese,,0,0,0,,现在记住我们是否初始化了一个同名的全局变量
Dialogue: 0,0:22:50.94,0:22:56.18,English,,0,0,0,,And we if we declare an initialized global variable across multiple modules that's an error
Dialogue: 0,0:22:50.94,0:22:56.18,Chinese,,0,0,0,,如果我们在多个模块中声明一个同名的初始化的全局变量，那么我们就是一个错误
Dialogue: 0,0:22:56.18,0:22:58.70,English,,0,0,0,,Because those are strong symbols okay by rule one
Dialogue: 0,0:22:56.18,0:22:58.70,Chinese,,0,0,0,,因为那些是强符号的第一条规则
Dialogue: 0,0:22:59.02,0:23:03.90,English,,0,0,0,,But if we have one strong symbol and multiple weak symbols all with the same name
Dialogue: 0,0:22:59.02,0:23:03.90,Chinese,,0,0,0,,但是如果我们有一个强符号和多个弱符号具有相同的名称
Dialogue: 0,0:23:04.52,0:23:06.92,English,,0,0,0,,Then the compiler will choose the strong symbol
Dialogue: 0,0:23:04.52,0:23:06.92,Chinese,,0,0,0,,然后编译器将选择强符号
Dialogue: 0,0:23:08.48,0:23:12.88,English,,0,0,0,,Okay and it will associate all references to that symbol will go to that strong symbol
Dialogue: 0,0:23:08.48,0:23:12.88,Chinese,,0,0,0,,好的，它将所有对该符号的引用关联到该强符号
Dialogue: 0,0:23:14.38,0:23:17.70,English,,0,0,0,,And if there's multiple weak symbols then it just picks an arbitrary one
Dialogue: 0,0:23:14.38,0:23:17.70,Chinese,,0,0,0,,如果有多个弱符号同名，那么它会从这些弱符号中任意选择一个
Dialogue: 0,0:23:18.02,0:23:25.07,English,,0,0,0,,And this is we'll see can be problematic now you can override with this GCC flag called no common
Dialogue: 0,0:23:18.02,0:23:25.07,Chinese,,0,0,0,,这是我们将看到的，可能会有问题，现在你可以用这个名为 no common 的 GCC 标志覆盖
Dialogue: 0,0:23:25.74,0:23:29.94,English,,0,0,0,,And if you declare your function with this no common argument
Dialogue: 0,0:23:25.74,0:23:29.94,Chinese,,0,0,0,,如果你用这个 no common 的参数声明函数
Dialogue: 0,0:23:31.86,0:23:35.40,English,,0,0,0,,Then multiple weak symbols will throw an error in a linker
Dialogue: 0,0:23:31.86,0:23:35.40,Chinese,,0,0,0,,然后多个弱符号将在链接器中抛出错误
Dialogue: 0,0:23:36.46,0:23:39.02,English,,0,0,0,,All right so why do we care about all this stuff well it turns out
Dialogue: 0,0:23:36.46,0:23:39.02,Chinese,,0,0,0,,好吧，为什么我们关心所有这些东西呢
Dialogue: 0,0:23:39.80,0:23:44.10,English,,0,0,0,,If you're not aware of this stuff you can run into some really serious problems
Dialogue: 0,0:23:39.80,0:23:44.10,Chinese,,0,0,0,,如果你不了解这些东西，你可能会遇到一些非常严重的问题
Dialogue: 0,0:23:44.12,0:23:47.40,English,,0,0,0,,That are just perplexing and confounding right so
Dialogue: 0,0:23:44.12,0:23:47.40,Chinese,,0,0,0,,这些东西容易令人困惑和混淆
Dialogue: 0,0:23:47.90,0:23:50.68,English,,0,0,0,,Linker errors are like the worst kind
Dialogue: 0,0:23:47.90,0:23:50.68,Chinese,,0,0,0,,链接器错误就是最糟糕的那种
Dialogue: 0,0:23:51.10,0:23:55.78,English,,0,0,0,,They're the hardest kind of debug because people aren't usually aware of what's going on inside their linkers
Dialogue: 0,0:23:51.10,0:23:55.78,Chinese,,0,0,0,,它们是最难调试的，因为人们通常不知道链接器的内部发生了什么
Dialogue: 0,0:23:57.64,0:24:02.26,English,,0,0,0,,And usually it's only like the very best programmers that really understand
Dialogue: 0,0:23:57.64,0:24:02.26,Chinese,,0,0,0,,而且通常只有最好的程序员真的理解里面发生了什么
Dialogue: 0,0:24:03.36,0:24:07.78,English,,0,0,0,,You know how these linkers work and what kind of errors they can throw and how to debug them
Dialogue: 0,0:24:03.36,0:24:07.78,Chinese,,0,0,0,,你知道这些链接器是如何工作的，它们可以抛出什么样的错误以及如何调试它们
Dialogue: 0,0:24:08.36,0:24:13.80,English,,0,0,0,,So let me show you some examples of these kind of errors
Dialogue: 0,0:24:08.36,0:24:13.80,Chinese,,0,0,0,,那么让我向你展示一些这类错误的例子
Dialogue: 0,0:24:15.58,0:24:17.36,English,,0,0,0,,All right so we have a program
Dialogue: 0,0:24:15.58,0:24:17.36,Chinese,,0,0,0,,好的，我们有一个程序
Dialogue: 0,0:24:18.24,0:24:22.96,English,,0,0,0,,We have two modules so each of these rectangles corresponds to a module
Dialogue: 0,0:24:18.24,0:24:22.96,Chinese,,0,0,0,,我们有两个模块，这里每个矩形窗口对应一个模块
Dialogue: 0,0:24:23.84,0:24:26.58,English,,0,0,0,,And we're defining p1 in each module so
Dialogue: 0,0:24:23.84,0:24:26.58,Chinese,,0,0,0,,我们在每个模块中定义 p1
Dialogue: 0,0:24:28.54,0:24:31.28,English,,0,0,0,,That's two strong symbols that's an error
Dialogue: 0,0:24:28.54,0:24:31.28,Chinese,,0,0,0,,这里有两个强符号，因此出现了错误
Dialogue: 0,0:24:34.38,0:24:40.34,English,,0,0,0,,Okay now here we've defining p1 and p2 so we're okay
Dialogue: 0,0:24:34.38,0:24:40.34,Chinese,,0,0,0,,好的，现在我们已经定义了 p1 和 p2，这没有问题
Dialogue: 0,0:24:40.34,0:24:47.08,English,,0,0,0,,But now we've got two weak symbols both are integers variables called x
Dialogue: 0,0:24:40.34,0:24:47.08,Chinese,,0,0,0,,但现在我们有两个弱符号，都是整数变量，称为 x
Dialogue: 0,0:24:48.92,0:24:58.12,English,,0,0,0,,So and if these modules are referencing x the linker will just pick it will just pick one of these to serve as the definition
Dialogue: 0,0:24:48.92,0:24:58.12,Chinese,,0,0,0,,因此，如果这些模块引用 x，链接器将只选择其中一个作为定义
Dialogue: 0,0:24:59.72,0:25:02.40,English,,0,0,0,,But is this really what you want
Dialogue: 0,0:24:59.72,0:25:02.40,Chinese,,0,0,0,,但这真的是你想要的结果吗
Dialogue: 0,0:25:03.60,0:25:09.38,English,,0,0,0,,Now in this case it doesn't really hurt anything because x is declared in both modules as an int
Dialogue: 0,0:25:03.60,0:25:09.38,Chinese,,0,0,0,,现在在这种情况下它并没有什么影响，因为 x 在两个模块中都被声明为 int
Dialogue: 0,0:25:10.12,0:25:15.06,English,,0,0,0,,All right so it'll just be some integer sized variable
Dialogue: 0,0:25:10.12,0:25:15.06,Chinese,,0,0,0,,所以它只是一个整数大小的变量
Dialogue: 0,0:25:15.72,0:25:19.22,English,,0,0,0,,That and it'll be somewhere
Dialogue: 0,0:25:15.72,0:25:19.22,Chinese,,0,0,0,,它将在某个地方放着
Dialogue: 0,0:25:20.04,0:25:24.14,English,,0,0,0,,And but it doesn't really matter which one the linker chooses
Dialogue: 0,0:25:20.04,0:25:24.14,Chinese,,0,0,0,,但是链接器选择哪一个并不重要
Dialogue: 0,0:25:25.52,0:25:31.14,English,,0,0,0,,But we start to get into trouble if we declare these weak symbols with different types
Dialogue: 0,0:25:25.52,0:25:31.14,Chinese,,0,0,0,,但是如果我们用不同的类型声明这些弱符号，我们就遇到麻烦了
Dialogue: 0,0:25:34.02,0:25:40.26,English,,0,0,0,,So here we've declared an int x in one module and a double x in another module
Dialogue: 0,0:25:34.02,0:25:40.26,Chinese,,0,0,0,,在这里，我们在一个模块中声明了一个 int x，在另一个模块中声明了一个 double x
Dialogue: 0,0:25:42.32,0:25:50.28,English,,0,0,0,,So if we write to x, if the linker just arbitrarily chooses this,this symbol definition to use
Dialogue: 0,0:25:42.32,0:25:50.28,Chinese,,0,0,0,,当我们写入 x 时，如果链接器随意选择了这个，那么就使用此符号定义
Dialogue: 0,0:25:51.54,0:25:57.48,English,,0,0,0,,Now this is a symbol that of length 8 of size 8
Dialogue: 0,0:25:51.54,0:25:57.48,Chinese,,0,0,0,,这是长度为 8 的符号
Dialogue: 0,0:26:00.36,0:26:05.72,English,,0,0,0,,If we anywhere in this program,if the linker chooses that then, anywhere in the program
Dialogue: 0,0:26:00.36,0:26:05.72,Chinese,,0,0,0,,如果我们在这个程序中的任何地方，如果链接器选择程序中的任意地方
Dialogue: 0,0:26:06.30,0:26:14.70,English,,0,0,0,,Those references to x will be to this double word,this double word
Dialogue: 0,0:26:06.30,0:26:14.70,Chinese,,0,0,0,,那些对 x 的引用将是这个双字，这个双字
Dialogue: 0,0:26:16.38,0:26:21.08,English,,0,0,0,,Even in this module if we reference x it'll be an 8-byte right
Dialogue: 0,0:26:16.38,0:26:21.08,Chinese,,0,0,0,,即使在这个模块中，如果我们引用 x，它也将是一个 8 字节的
Dialogue: 0,0:26:21.10,0:26:25.06,English,,0,0,0,,So it will overwrite y with the
Dialogue: 0,0:26:21.10,0:26:25.06,Chinese,,0,0,0,,所以它会覆盖 y
Dialogue: 0,0:26:29.20,0:26:30.22,English,,0,0,0,,Hi order excuse me
Dialogue: 0,0:26:29.20,0:26:30.22,Chinese,,0,0,0,,你有什么问题吗
Dialogue: 0,0:26:31.54,0:26:38.80,English,,0,0,0,,[student speaking]
Dialogue: 0,0:26:31.54,0:26:38.80,Chinese,,0,0,0,,[学生在发言...]
Dialogue: 0,0:26:38.84,0:26:44.68,English,,0,0,0,, Oh no it's completely,it's just pick one arbitrarily
Dialogue: 0,0:26:38.84,0:26:44.68,Chinese,,0,0,0,,噢它不完全是这样，它只是任意选择一个
Dialogue: 0,0:26:44.96,0:26:47.40,English,,0,0,0,,And you don't know
Dialogue: 0,0:26:44.96,0:26:47.40,Chinese,,0,0,0,,而且你不知道
Dialogue: 0,0:26:47.92,0:26:48.52,English,,0,0,0,,I mean it
Dialogue: 0,0:26:47.92,0:26:48.52,Chinese,,0,0,0,,我的意思是
Dialogue: 0,0:26:53.44,0:27:01.92,English,,0,0,0,,Now this is here's a problem we've defined a strong symbol x because we've initializes
Dialogue: 0,0:26:53.44,0:27:01.92,Chinese,,0,0,0,,现在这是一个问题，我们已经定义了一个强符号x，因为我们已经初始化了
Dialogue: 0,0:27:01.92,0:27:13.58,English,,0,0,0,,So the linker will always,will associate all references to x to this integer sized this integer sized symbol
Dialogue: 0,0:27:01.92,0:27:13.58,Chinese,,0,0,0,,因此链接器将始终将对x的所有引用与此整数大小符号相关联
Dialogue: 0,0:27:16.74,0:27:17.80,English,,0,0,0,,So if we write
Dialogue: 0,0:27:16.74,0:27:17.80,Chinese,,0,0,0,,所以，如果我们写
Dialogue: 0,0:27:30.52,0:27:34.14,English,,0,0,0,,Oh yeah right,so rights to x here
Dialogue: 0,0:27:30.52,0:27:34.14,Chinese,,0,0,0,,哦是的，对于 x
Dialogue: 0,0:27:36.14,0:27:40.68,English,,0,0,0,,This will be a double in this module but it will overwrite y in this module
Dialogue: 0,0:27:36.14,0:27:40.68,Chinese,,0,0,0,,这将是此模块中的两倍，但它将覆盖此模块中的 y
Dialogue: 0,0:27:40.94,0:27:48.36,English,,0,0,0,,So that's really nasty
Dialogue: 0,0:27:40.94,0:27:48.36,Chinese,,0,0,0,,所以那真的很讨厌
Dialogue: 0,0:27:48.76,0:27:51.60,English,,0,0,0,,And here we were defining a strong symbol x
Dialogue: 0,0:27:48.76,0:27:51.60,Chinese,,0,0,0,,在这我们正在定义一个强符号 x
Dialogue: 0,0:27:52.40,0:28:00.90,English,,0,0,0,,So references to x in the second module will always get it will refer to this initialized variable which might not
Dialogue: 0,0:27:52.40,0:28:00.90,Chinese,,0,0,0,,因此，在第二个模块中对x的引用的结果将得到它将引用这个初始化的变量
Dialogue: 0,0:28:01.68,0:28:04.42,English,,0,0,0,,So it might not be what you want right
Dialogue: 0,0:28:01.68,0:28:04.42,Chinese,,0,0,0,,所以它可能不是你想要的
Dialogue: 0,0:28:06.12,0:28:10.14,English,,0,0,0,,You may be assuming that it's uninitialized in your code
Dialogue: 0,0:28:06.12,0:28:10.14,Chinese,,0,0,0,,你可能认为它在你的代码中未初始化
Dialogue: 0,0:28:12.22,0:28:16.46,English,,0,0,0,,Okay and then you get the, the ultimate nightmare scenario is suppose
Dialogue: 0,0:28:12.22,0:28:16.46,Chinese,,0,0,0,,好吧，然后你得到了，最终的噩梦场景就是，假设...嗯
Dialogue: 0,0:28:17.06,0:28:21.62,English,,0,0,0,,You know because we're following a standard ABI we can compile our code with multiple compilers
Dialogue: 0,0:28:17.06,0:28:21.62,Chinese,,0,0,0,,你知道，因为我们遵循标准的 ABI，我们可以用多个编译器编译我们的代码
Dialogue: 0,0:28:22.20,0:28:24.80,English,,0,0,0,,And this actually happens in some , oh yes questions
Dialogue: 0,0:28:22.20,0:28:24.80,Chinese,,0,0,0,,这实际上发生在一些，嗯好的请你提问
Dialogue: 0,0:28:25.06,0:28:34.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:25.06,0:28:34.74,Chinese,,0,0,0,,[学生在发言]
Dialogue: 0,0:28:34.76,0:28:36.54,English,,0,0,0,,Oh yeah actually you're right
Dialogue: 0,0:28:34.76,0:28:36.54,Chinese,,0,0,0,,嗯是的你说的是对的
Dialogue: 0,0:28:37.40,0:28:41.58,English,,0,0,0,,It will still take preference and and you'll be writing a for by quantity
Dialogue: 0,0:28:37.40,0:28:41.58,Chinese,,0,0,0,,它仍然会优先考虑并且你将按数量编写
Dialogue: 0,0:28:41.58,0:28:45.02,English,,0,0,0,,Which is what you want so that slides not quite right
Dialogue: 0,0:28:41.58,0:28:45.02,Chinese,,0,0,0,,这是你想的，所以那个幻灯片上的不太正确
Dialogue: 0,0:28:45.50,0:28:55.50,English,,0,0,0,,So oh yeah what is the point of doing the static versus non static
Dialogue: 0,0:28:45.50,0:28:55.50,Chinese,,0,0,0,,（学生）所以哦，是的，处理静态与非静态的重点是什么
Dialogue: 0,0:28:55.50,0:29:02.26,English,,0,0,0,,If it's always being referenced just locally in constantly what is the point of declaring  it's time
Dialogue: 0,0:28:55.50,0:29:02.26,Chinese,,0,0,0,,（学生）如果它总是不断的在被本地引用，那么什么是宣布它时间的点
Dialogue: 0,0:29:02.60,0:29:05.56,English,,0,0,0,,-is it it stores it in like -no no no it's
Dialogue: 0,0:29:02.60,0:29:05.56,Chinese,,0,0,0,,（学生）是不是该把他存储起来  （教授）不不不，不是的
Dialogue: 0,0:29:06.86,0:29:11.42,English,,0,0,0,,If you reference up if you reference a variable
Dialogue: 0,0:29:06.86,0:29:11.42,Chinese,,0,0,0,,如果引用变量，就会引用
Dialogue: 0,0:29:12.84,0:29:15.46,English,,0,0,0,,You mean so a variable is defined in your module
Dialogue: 0,0:29:12.84,0:29:15.46,Chinese,,0,0,0,,你的意思是在模块中定义一个变量
Dialogue: 0,0:29:16.04,0:29:22.70,English,,0,0,0,,And then you...with the static...right
Dialogue: 0,0:29:16.04,0:29:22.70,Chinese,,0,0,0,,然后你....用 static....对吗
Dialogue: 0,0:29:24.06,0:29:26.54,English,,0,0,0,,Oh they're both,they're both local
Dialogue: 0,0:29:24.06,0:29:26.54,Chinese,,0,0,0,,噢，他们都是，他们都是局部的
Dialogue: 0,0:29:26.98,0:29:31.30,English,,0,0,0,,So you do this if you want to value two to retain
Dialogue: 0,0:29:26.98,0:29:31.30,Chinese,,0,0,0,,因此，如果你想要保留两个值，请执行此操作
Dialogue: 0,0:29:31.96,0:29:36.86,English,,0,0,0,,From if you want if you want that variable to retain value from invocation to invocation
Dialogue: 0,0:29:31.96,0:29:36.86,Chinese,,0,0,0,,如果你想要该变量保留从调用到调用的值
Dialogue: 0,0:29:38.32,0:29:42.62,English,,0,0,0,,So suppose you it's usually a bad idea as we'll see when we study threads
Dialogue: 0,0:29:38.32,0:29:42.62,Chinese,,0,0,0,,所以假设你，这通常是一个坏主意，因为我们会在研究线程时看到
Dialogue: 0,0:29:42.62,0:29:44.90,English,,0,0,0,,Because it makes your code non thread safe
Dialogue: 0,0:29:42.62,0:29:44.90,Chinese,,0,0,0,,因为这将使你的代码线程不安全
Dialogue: 0,0:29:45.62,0:29:49.40,English,,0,0,0,,But like early like random number generators
Dialogue: 0,0:29:45.62,0:29:49.40,Chinese,,0,0,0,,但就像早期的随机数生成器一样
Dialogue: 0,0:29:50.18,0:29:53.28,English,,0,0,0,,Would it would compute a pseudo-random number
Dialogue: 0,0:29:50.18,0:29:53.28,Chinese,,0,0,0,,它会计算一个伪随机数
Dialogue: 0,0:29:53.78,0:29:55.84,English,,0,0,0,,And then it would store it in a static variable
Dialogue: 0,0:29:53.78,0:29:55.84,Chinese,,0,0,0,,然后它会存储在一个静态变量里面
Dialogue: 0,0:29:56.28,0:30:01.30,English,,0,0,0,,And then use that as the the starting value for the next time you call that function
Dialogue: 0,0:29:56.28,0:30:01.30,Chinese,,0,0,0,,然后将其用作下次调用该函数时的起始值
Dialogue: 0,0:30:01.74,0:30:06.70,English,,0,0,0,,So whenever you want values to persist across function invocation to reduce static
Dialogue: 0,0:30:01.74,0:30:06.70,Chinese,,0,0,0,,因此，无论何时你都希望值能被允许进行跨越函数调用以减少静态
Dialogue: 0,0:30:07.26,0:30:25.04,English,,0,0,0,,Yes something really crash
Dialogue: 0,0:30:07.26,0:30:25.04,Chinese,,0,0,0,,（学生）某些事情真的崩溃了
Dialogue: 0,0:30:25.04,0:30:26.20,English,,0,0,0,,Well wait a minute let me...
Dialogue: 0,0:30:25.04,0:30:26.20,Chinese,,0,0,0,,等一下让我...
Dialogue: 0,0:30:27.50,0:30:34.04,English,,0,0,0,,Let me get this straight writes to x and p2 will actually correspond to the memory
Dialogue: 0,0:30:27.50,0:30:34.04,Chinese,,0,0,0,,让我直接写入 x 和 p2， 这实际上将和内存链接起来
Dialogue: 0,0:30:34.30,0:30:40.78,English,,0,0,0,,Look that it will actually go to the memory location I'm sorry I need to amend that
Dialogue: 0,0:30:34.30,0:30:40.78,Chinese,,0,0,0,,看它实际上会进入内存位置，我很抱歉我需要修改它
Dialogue: 0,0:30:41.74,0:30:47.60,English,,0,0,0,,So writes to x in p2 will be 8 bytes
Dialogue: 0,0:30:41.74,0:30:47.60,Chinese,,0,0,0,,因此，在 p2 中写入 x 将是 8 个字节
Dialogue: 0,0:30:47.64,0:30:51.32,English,,0,0,0,,Because the compiler you know the compiler knows that it's a double
Dialogue: 0,0:30:47.64,0:30:51.32,Chinese,,0,0,0,,因为编译器，你知道编译器会知道它是双精度的
Dialogue: 0,0:30:52.70,0:30:59.84,English,,0,0,0,,But it'll go to a memory location that's only 4 bytes
Dialogue: 0,0:30:52.70,0:30:59.84,Chinese,,0,0,0,,但它会进入一个只有 4 个字节的内存位置
Dialogue: 0,0:31:00.54,0:31:03.32,English,,0,0,0,,Because x because the linker chose the strong symbol
Dialogue: 0,0:31:00.54,0:31:03.32,Chinese,,0,0,0,,因为 x...因为链接器选择了强符号
Dialogue: 0,0:31:04.46,0:31:08.34,English,,0,0,0,,Okay so the rights to x and p2 will actually overwrite y
Dialogue: 0,0:31:04.46,0:31:08.34,Chinese,,0,0,0,,好的，正确的是 x 和 p2 实际上会覆盖 y
Dialogue: 0,0:31:12.98,0:31:14.06,English,,0,0,0,,I'm sorry yes question
Dialogue: 0,0:31:12.98,0:31:14.06,Chinese,,0,0,0,,对不起...好的，有人有问题
Dialogue: 0,0:31:14.06,0:31:23.12,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:14.06,0:31:23.12,Chinese,,0,0,0,,[学生发言]
Dialogue: 0,0:31:23.18,0:31:25.08,English,,0,0,0,,That's just usually the way it happens
Dialogue: 0,0:31:23.18,0:31:25.08,Chinese,,0,0,0,,它通常就是这样发生的
Dialogue: 0,0:31:25.70,0:31:33.42,English,,0,0,0,,You know...[student speaking]
Dialogue: 0,0:31:25.70,0:31:33.42,Chinese,,0,0,0,,你知道...... [学生说话]
Dialogue: 0,0:31:33.46,0:31:38.46,English,,0,0,0,,No no no global variables go in data they don't go on the stack
Dialogue: 0,0:31:33.46,0:31:38.46,Chinese,,0,0,0,,不不不全局变量进入了数据，他们并没有进栈
Dialogue: 0,0:31:39.36,0:31:41.80,English,,0,0,0,,But usually if you define local variables in a function
Dialogue: 0,0:31:39.36,0:31:41.80,Chinese,,0,0,0,,但通常来说，如果你在函数中定义局部变量
Dialogue: 0,0:31:42.26,0:31:46.38,English,,0,0,0,,It will put them,it will allocate them one after the other on the stack
Dialogue: 0,0:31:42.26,0:31:46.38,Chinese,,0,0,0,,它会放置它们，它会将他们一个接一个地分配到栈上
Dialogue: 0,0:31:49.68,0:31:55.66,English,,0,0,0,,Okay all right so all this discussion about
Dialogue: 0,0:31:49.68,0:31:55.66,Chinese,,0,0,0,,好的，所有这些讨论
Dialogue: 0,0:31:57.52,0:32:01.38,English,,0,0,0,,These weird strong weak symbol rules that the linker have
Dialogue: 0,0:31:57.52,0:32:01.38,Chinese,,0,0,0,,有关链接器具有的这些奇怪的强弱符号规则
Dialogue: 0,0:32:01.38,0:32:04.92,English,,0,0,0,,It's another reason to avoid global variables if you can
Dialogue: 0,0:32:01.38,0:32:04.92,Chinese,,0,0,0,,这是避免全局变量的另一个原因
Dialogue: 0,0:32:07.32,0:32:12.40,English,,0,0,0,,Now if you need to declare a global see if you can declare it static
Dialogue: 0,0:32:07.32,0:32:12.40,Chinese,,0,0,0,,现在，如果你需要声明全局变量，请看看是否可以将其声明为 static
Dialogue: 0,0:32:12.40,0:32:16.08,English,,0,0,0,,Because that'll limited scope to the the module that it's declared in
Dialogue: 0,0:32:12.40,0:32:16.08,Chinese,,0,0,0,,因为那样会限制了它声明的模块的范围
Dialogue: 0,0:32:16.34,0:32:18.10,English,,0,0,0,,So that's a good idea if you can do it
Dialogue: 0,0:32:16.34,0:32:18.10,Chinese,,0,0,0,,如果你那样做的话，是个好主意
Dialogue: 0,0:32:18.88,0:32:21.24,English,,0,0,0,,And if you define a global variable initialize it
Dialogue: 0,0:32:18.88,0:32:21.24,Chinese,,0,0,0,,如果你定义了一个全局变量，就把它初始化了
Dialogue: 0,0:32:22.90,0:32:31.26,English,,0,0,0,,So that you'll find,you'll discover if you have multiple initialize global symbols with the same name in your code
Dialogue: 0,0:32:22.90,0:32:31.26,Chinese,,0,0,0,,所以你会发现，你会发现你的代码中是否有多个具有相同名称的初始化全局符号
Dialogue: 0,0:32:32.46,0:32:35.90,English,,0,0,0,,And then if you want to it's always good practice
Dialogue: 0,0:32:32.46,0:32:35.90,Chinese,,0,0,0,,如果你想要，它总是好的做法
Dialogue: 0,0:32:35.90,0:32:41.70,English,,0,0,0,,If you're referencing an external variable to tell the compiler about it by using the extern attribute
Dialogue: 0,0:32:35.90,0:32:41.70,Chinese,,0,0,0,,如果你正在引用外部变量，则通过使用 extern 属性告诉编译器
Dialogue: 0,0:32:44.94,0:32:46.29,English,,0,0,0,,All right
Dialogue: 0,0:32:44.94,0:32:46.29,Chinese,,0,0,0,,好的
Dialogue: 0,0:32:46.74,0:32:53.48,English,,0,0,0,,So now at this point the linker has associated every symbol reference  with some simple definition
Dialogue: 0,0:32:46.74,0:32:53.48,Chinese,,0,0,0,,所以现在，链接器已经将每个符号引用与一些简单的定义相关联
Dialogue: 0,0:32:54.70,0:32:59.56,English,,0,0,0,,Now it has to take all those object relocatable object files and smush them together
Dialogue: 0,0:32:54.70,0:32:59.56,Chinese,,0,0,0,,现在它必须获取所有这些对象可重定位目标文件并将它们组合在一起
Dialogue: 0,0:32:59.80,0:33:03.84,English,,0,0,0,,And create like one big executable
Dialogue: 0,0:32:59.80,0:33:03.84,Chinese,,0,0,0,,并创建一个大的可执行文件
Dialogue: 0,0:33:04.92,0:33:08.54,English,,0,0,0,,So suppose with our example a little running example
Dialogue: 0,0:33:04.92,0:33:08.54,Chinese,,0,0,0,,因此，假设我们拿一个小运行示例来举例
Dialogue: 0,0:33:09.72,0:33:18.32,English,,0,0,0,,Each main.o and sum.o contain a code and initialize data
Dialogue: 0,0:33:09.72,0:33:18.32,Chinese,,0,0,0,,每个 main.o 和 sum.o 都包含了代码并初始化数据
Dialogue: 0,0:33:19.08,0:33:22.96,English,,0,0,0,,sum.o doesn't have any initialize data it just has code
Dialogue: 0,0:33:19.08,0:33:22.96,Chinese,,0,0,0,,sum.o 没有初始化数据，只有代码
Dialogue: 0,0:33:23.62,0:33:28.34,English,,0,0,0,,And then there's their system code that actually runs before and after your program so
Dialogue: 0,0:33:23.62,0:33:28.34,Chinese,,0,0,0,,然后是上面的系统代码，它实际上在你的程序之前和之后运行
Dialogue: 0,0:33:29.88,0:33:35.46,English,,0,0,0,,When your program run it actually starts executing a startup code from  from lib.c
Dialogue: 0,0:33:29.88,0:33:35.46,Chinese,,0,0,0,,程序运行时，它从 lib.c 开始执行启动代码
Dialogue: 0,0:33:36.12,0:33:44.46,English,,0,0,0,,That that sort of initializes things and then the last thing that it does is it calls main and passes it rc and rv
Dialogue: 0,0:33:36.12,0:33:44.46,Chinese,,0,0,0,,它主要做这一类初始化的事情，然后它做的最后一件事是它调用 main 并传递 rc 和 rv
Dialogue: 0,0:33:46.18,0:33:48.38,English,,0,0,0,,Okay and then when you're, when your program exits
Dialogue: 0,0:33:46.18,0:33:48.38,Chinese,,0,0,0,,好的，然后当你的程序退出时
Dialogue: 0,0:33:49.78,0:33:55.00,English,,0,0,0,,Well that's a cyst call,but if your program if your main function routine does a return
Dialogue: 0,0:33:49.78,0:33:55.00,Chinese,,0,0,0,,会有一个调用，但如果你的程序...如果你的主函数例程返回
Dialogue: 0,0:33:55.46,0:33:59.54,English,,0,0,0,,Then it returns back to that startup code which then doesn't exit okay
Dialogue: 0,0:33:55.46,0:33:59.54,Chinese,,0,0,0,,然后它返回到那个启动代码，然后没退出
Dialogue: 0,0:34:00.52,0:34:07.62,English,,0,0,0,,So this is just...so this this consists of of text and data as well
Dialogue: 0,0:34:00.52,0:34:07.62,Chinese,,0,0,0,,这包括文本和数据
Dialogue: 0,0:34:09.10,0:34:13.16,English,,0,0,0,,And so when the linker relocates these object files
Dialogue: 0,0:34:09.10,0:34:13.16,Chinese,,0,0,0,,所以当链接器重定位这些目标文件时
Dialogue: 0,0:34:15.28,0:34:20.84,English,,0,0,0,,It takes all of the code the text sections from each of the modules
Dialogue: 0,0:34:15.28,0:34:20.84,Chinese,,0,0,0,,它将所有代码都放在每个模块的文本部分中
Dialogue: 0,0:34:21.80,0:34:29.96,English,,0,0,0,,And puts them together contiguously init in the .text section for the executable object file
Dialogue: 0,0:34:21.80,0:34:29.96,Chinese,,0,0,0,,并将它们连续地放在可执行对象文件的 .text 部分中
Dialogue: 0,0:34:30.30,0:34:34.42,English,,0,0,0,,Ok so it just puts them together in some order that it determines
Dialogue: 0,0:34:30.30,0:34:34.42,Chinese,,0,0,0,,它只是按照它确定的顺序将它们组合在一起
Dialogue: 0,0:34:34.76,0:34:40.40,English,,0,0,0,,And it creates a combined .text section in the executable
Dialogue: 0,0:34:34.76,0:34:40.40,Chinese,,0,0,0,,它在可执行文件中创建了一个组合的 .text 部分
Dialogue: 0,0:34:40.82,0:34:46.18,English,,0,0,0,,That contains all of the system code and the all of the all of the code defined in the modules
Dialogue: 0,0:34:40.82,0:34:46.18,Chinese,,0,0,0,,它包含所有系统代码和模块中定义的所有代码
Dialogue: 0,0:34:46.84,0:34:51.24,English,,0,0,0,,And then it does the same thing with the data takes all the .data
Dialogue: 0,0:34:46.84,0:34:51.24,Chinese,,0,0,0,,然后它会对数据采用所有 .data 做同样的事情
Dialogue: 0,0:34:51.96,0:34:55.92,English,,0,0,0,,Sections from the various object files and puts them together
Dialogue: 0,0:34:51.96,0:34:55.92,Chinese,,0,0,0,,来自各种目标文件的部分并将它们放在一起
Dialogue: 0,0:34:56.42,0:35:00.62,English,,0,0,0,,In one combined .data section in the executable
Dialogue: 0,0:34:56.42,0:35:00.62,Chinese,,0,0,0,,在可执行文件中的一个组合的 .data 部分
Dialogue: 0,0:35:02.52,0:35:07.32,English,,0,0,0,,And it also emerges the symbol tables and in the debug information as well
Dialogue: 0,0:35:02.52,0:35:07.32,Chinese,,0,0,0,,它还会出现符号表和调试信息
Dialogue: 0,0:35:09.14,0:35:15.12,English,,0,0,0,,Now when it just the act the act of sort of
Dialogue: 0,0:35:09.14,0:35:15.12,Chinese,,0,0,0,,现在当它起作用
Dialogue: 0,0:35:15.64,0:35:19.98,English,,0,0,0,,Relocating these object files requires the linker
Dialogue: 0,0:35:15.64,0:35:19.98,Chinese,,0,0,0,,重定向这些目标文件需要链接器
Dialogue: 0,0:35:20.56,0:35:23.54,English,,0,0,0,,To figure out where it's going to actually store these
Dialogue: 0,0:35:20.56,0:35:23.54,Chinese,,0,0,0,,来弄清楚它们实际存储在哪里
Dialogue: 0,0:35:24.42,0:35:31.24,English,,0,0,0,,These different these different symbols when the system gets, when this program gets loaded
Dialogue: 0,0:35:24.42,0:35:31.24,Chinese,,0,0,0,,当程序加载时，这些不同的符号...
Dialogue: 0,0:35:31.26,0:35:36.00,English,,0,0,0,,So it has to pick an address for main that
Dialogue: 0,0:35:31.26,0:35:36.00,Chinese,,0,0,0,,所以它必须为 main 选择一个地址
Dialogue: 0,0:35:37.30,0:35:41.14,English,,0,0,0,,That function will start at some absolute address
Dialogue: 0,0:35:37.30,0:35:41.14,Chinese,,0,0,0,,以至于函数将从某个绝对地址开始
Dialogue: 0,0:35:41.22,0:35:46.42,English,,0,0,0,,It's going to have... it's going to do the same for swap,so for all the all the data arrays right
Dialogue: 0,0:35:41.22,0:35:46.42,Chinese,,0,0,0,,它会对 swap() 做同样的事情，以保证所有数组都是正确的
Dialogue: 0,0:35:51.16,0:36:00.16,English,,0,0,0,,And but the problem is that when this code is compiled,the compiler doesn't know what addresses the linker is going to pick
Dialogue: 0,0:35:51.16,0:36:00.16,Chinese,,0,0,0,,但问题是，当编译此代码时，编译器不知道链接器将选择哪些地址
Dialogue: 0,0:36:02.40,0:36:09.10,English,,0,0,0,,So the compiler creates these reminders to the linker called relocation entries
Dialogue: 0,0:36:02.40,0:36:09.10,Chinese,,0,0,0,,因此，编译器会向称为重定位条目的链接器创建这些提醒
Dialogue: 0,0:36:09.10,0:36:13.84,English,,0,0,0,,Which are then stored in the relocation sections of the the object file
Dialogue: 0,0:36:09.10,0:36:13.84,Chinese,,0,0,0,,然后将其存储在目标文件的重定位部分中
Dialogue: 0,0:36:14.94,0:36:20.22,English,,0,0,0,,And these relocation entries are instructions to the linker that's something
Dialogue: 0,0:36:14.94,0:36:20.22,Chinese,,0,0,0,,这些重定位条目是链接器的指令
Dialogue: 0,0:36:21.62,0:36:24.88,English,,0,0,0,,That there's a reference to a symbol that's going to have to be patched up
Dialogue: 0,0:36:21.62,0:36:24.88,Chinese,,0,0,0,,有一个符号的引用必须要修改
Dialogue: 0,0:36:25.48,0:36:30.98,English,,0,0,0,,When the the code is actually relocated and merged into the executable
Dialogue: 0,0:36:25.48,0:36:30.98,Chinese,,0,0,0,,在代码实际重定位并合并到可执行文件中时
Dialogue: 0,0:36:32.42,0:36:36.24,English,,0,0,0,,So let's look at a couple of these a couple of examples so in
Dialogue: 0,0:36:32.42,0:36:36.24,Chinese,,0,0,0,,让我们看看其中的几个例子
Dialogue: 0,0:36:37.04,0:36:44.38,English,,0,0,0,,Our in our main.c module there was a reference to this global symbol called array
Dialogue: 0,0:36:37.04,0:36:44.38,Chinese,,0,0,0,,我们在 main.c 模块中引用了一个名为 array 的全局符号
Dialogue: 0,0:36:46.58,0:36:52.06,English,,0,0,0,,Okay and then there was also a reference to this global symbol sum which is the function
Dialogue: 0,0:36:46.58,0:36:52.06,Chinese,,0,0,0,,好的，然后还有一个引用，全局符号 sum， 这是一个函数
Dialogue: 0,0:36:53.54,0:36:57.32,English,,0,0,0,,So the compiler creates two relocation entries
Dialogue: 0,0:36:53.54,0:36:57.32,Chinese,,0,0,0,,因此编译器会创建两个重定位条目
Dialogue: 0,0:36:57.90,0:37:00.84,English,,0,0,0,,The first one for the reference to the array a
Dialogue: 0,0:36:57.90,0:37:00.84,Chinese,,0,0,0,,第一个用于引用数组 a
Dialogue: 0,0:37:01.58,0:37:06.30,English,,0,0,0,,So here we're moving member %edi is the first argument
Dialogue: 0,0:37:01.58,0:37:06.30,Chinese,,0,0,0,,所以这里我们正在传送的成员 ％edi 是第一个参数
Dialogue: 0,0:37:07.00,0:37:12.18,English,,0,0,0,,So remember a sum function takes the address of the of array
Dialogue: 0,0:37:07.00,0:37:12.18,Chinese,,0,0,0,,所以请记住 sum 函数获取数组的地址
Dialogue: 0,0:37:12.68,0:37:15.50,English,,0,0,0,,Of the input array as its argument
Dialogue: 0,0:37:12.68,0:37:15.50,Chinese,,0,0,0,,输入数组作为其参数
Dialogue: 0,0:37:16.92,0:37:27.00,English,,0,0,0,,So this move we're moving the address of the array into %edi for the first argument
Dialogue: 0,0:37:16.92,0:37:27.00,Chinese,,0,0,0,,因此，我们将第一个参数的数组地址传送到 ％edi 中
Dialogue: 0,0:37:27.92,0:37:30.36,English,,0,0,0,,But the compiler doesn't know what that address is going to be
Dialogue: 0,0:37:27.92,0:37:30.36,Chinese,,0,0,0,,但编译器不知道该地址会是什么
Dialogue: 0,0:37:31.24,0:37:34.56,English,,0,0,0,,Right so it just it just it just
Dialogue: 0,0:37:31.24,0:37:34.56,Chinese,,0,0,0,,是的，它只是...
Dialogue: 0,0:37:35.84,0:37:42.58,English,,0,0,0,,It just moves in an immediate value of 0 into %edi temporarily right so you can see this is all zeros
Dialogue: 0,0:37:35.84,0:37:42.58,Chinese,,0,0,0,,它只是暂时把立即数值 $0x0 传送到 ％edi ，所以你可以看到这是全零
Dialogue: 0,0:37:43.96,0:37:50.02,English,,0,0,0,,The bf is the mov instruction and then there's all zeros for now
Dialogue: 0,0:37:43.96,0:37:50.02,Chinese,,0,0,0,,bf 是 mov 指令，然后后面全都是 0
Dialogue: 0,0:37:51.82,0:37:57.92,English,,0,0,0,,And then it places this relocation entry in the relocation section of main.o
Dialogue: 0,0:37:51.82,0:37:57.92,Chinese,,0,0,0,,然后它将此重定位条目放在 main.o 的重定位部分中
Dialogue: 0,0:37:58.64,0:38:03.44,English,,0,0,0,,And it says to the linker at offset a
Dialogue: 0,0:37:58.64,0:38:03.44,Chinese,,0,0,0,,它在偏移量 a 处告知链接器
Dialogue: 0,0:38:04.96,0:38:09.58,English,,0,0,0,,So these let me remind you these are main.o
Dialogue: 0,0:38:04.96,0:38:09.58,Chinese,,0,0,0,,所以这些提醒你们这些是 main.o 模块
Dialogue: 0,0:38:10.52,0:38:13.90,English,,0,0,0,,Module only contains one function
Dialogue: 0,0:38:10.52,0:38:13.90,Chinese,,0,0,0,,这个模块只包含一个函数
Dialogue: 0,0:38:14.92,0:38:22.96,English,,0,0,0,,So that function starts that offsets zero in the code section of the module in the .text section of the module
Dialogue: 0,0:38:14.92,0:38:22.96,Chinese,,0,0,0,,因此，该函数在模块的 .text 部分的模块的代码部分偏移为零的地方开始
Dialogue: 0,0:38:23.90,0:38:28.84,English,,0,0,0,,If there were other functions in this module they would follow immediately after
Dialogue: 0,0:38:23.90,0:38:28.84,Chinese,,0,0,0,,如果此模块中还有其他功能，则会立即跟进
Dialogue: 0,0:38:29.48,0:38:36.98,English,,0,0,0,,Ok and it so you can see what the compiler it's just generating offsets of these instructions
Dialogue: 0,0:38:29.48,0:38:36.98,Chinese,,0,0,0,,好的，所以你可以看到编译器只是生成这些指令的偏移量
Dialogue: 0,0:38:37.62,0:38:39.92,English,,0,0,0,,From the beginning of the .text section
Dialogue: 0,0:38:37.62,0:38:39.92,Chinese,,0,0,0,,从 .text 部分开始
Dialogue: 0,0:38:41.02,0:38:46.50,English,,0,0,0,,And it includes this relocation entry which says to the linker hey
Dialogue: 0,0:38:41.02,0:38:46.50,Chinese,,0,0,0,,它包括这个重定位条目，它跟链接器打招呼
Dialogue: 0,0:38:46.98,0:38:54.38,English,,0,0,0,,When you're relocating main.o add offset a in this .text section
Dialogue: 0,0:38:46.98,0:38:54.38,Chinese,,0,0,0,,当你重新定位 main.o 时，在此 .text 部分中添加偏移量 a
Dialogue: 0,0:38:55.48,0:39:03.36,English,,0,0,0,,You've got a reference,a reference to an array in the form of a 32-bit address
Dialogue: 0,0:38:55.48,0:39:03.36,Chinese,,0,0,0,,你有一个 32 位地址形式的数组引用
Dialogue: 0,0:39:04.52,0:39:11.40,English,,0,0,0,,Ok so that,so eventually the linker is going to have to patch up these
Dialogue: 0,0:39:04.52,0:39:11.40,Chinese,,0,0,0,,好的，那么，最终链接器将不得不修改它们
Dialogue: 0,0:39:12.28,0:39:15.04,English,,0,0,0,,So this is address , this is address a
Dialogue: 0,0:39:12.28,0:39:15.04,Chinese,,0,0,0,,所以这是地址 a
Dialogue: 0,0:39:15.04,0:39:18.30,English,,0,0,0,,It's going to have to patch up the four bytes starting at address a
Dialogue: 0,0:39:15.04,0:39:18.30,Chinese,,0,0,0,,它必须修改从地址 a 开始的四个字节
Dialogue: 0,0:39:19.82,0:39:24.76,English,,0,0,0,,With the absolute address of the symbol array
Dialogue: 0,0:39:19.82,0:39:24.76,Chinese,,0,0,0,,地址 a 使用符号数组的绝对地址
Dialogue: 0,0:39:28.58,0:39:38.70,English,,0,0,0,,And then similarly the reference to,the reference to,this the reference to this function sum
Dialogue: 0,0:39:28.58,0:39:38.70,Chinese,,0,0,0,,然后类似地引用这个函数的 sum
Dialogue: 0,0:39:39.72,0:39:44.28,English,,0,0,0,,The compiler has no idea where sum actually will end up
Dialogue: 0,0:39:39.72,0:39:44.28,Chinese,,0,0,0,,编译器不知道 sum 实际上会在哪里结束
Dialogue: 0,0:39:44.28,0:39:49.24,English,,0,0,0,,It doesn't even know what module it's in or even if it's, even if it is defined in a module
Dialogue: 0,0:39:44.28,0:39:49.24,Chinese,,0,0,0,,即使 sum 是在模块中定义的，编译器甚至不知道它所在的模块，甚至它是什么模块
Dialogue: 0,0:39:49.94,0:39:55.48,English,,0,0,0,,So in this case it just it does a call with all zeros
Dialogue: 0,0:39:49.94,0:39:55.48,Chinese,,0,0,0,,所以在这种情况下它只能用全零来调用
Dialogue: 0,0:39:58.14,0:40:01.72,English,,0,0,0,,And then it adds this relocation entry that says to the linker
Dialogue: 0,0:39:58.14,0:40:01.72,Chinese,,0,0,0,,然后它添加了对链接器通告的重定位条目
Dialogue: 0,0:40:03.10,0:40:16.16,English,,0,0,0,,At offset f you've got a four byte pc-relative reference to a function,to assemble called sum
Dialogue: 0,0:40:03.10,0:40:16.16,Chinese,,0,0,0,,在偏移量 f 处，你有一个四字节的 pc 相对引用，用于汇总调用 sum
Dialogue: 0,0:40:17.78,0:40:23.66,English,,0,0,0,,And then it this is sort of a arcane detail that but and it includes
Dialogue: 0,0:40:17.78,0:40:23.66,Chinese,,0,0,0,,然后，这有一个神奇的细节
Dialogue: 0,0:40:24.24,0:40:27.96,English,,0,0,0,,There's an option to include a bias in the in the offset
Dialogue: 0,0:40:24.24,0:40:27.96,Chinese,,0,0,0,,可以选择在偏移中包含偏差
Dialogue: 0,0:40:28.66,0:40:36.26,English,,0,0,0,,And since we're using since calls are always resolved using pc-relative addressing
Dialogue: 0,0:40:28.66,0:40:36.26,Chinese,,0,0,0,,因为我们正在使用，因为调用总是使用 pc 相对寻址来解决
Dialogue: 0,0:40:36.78,0:40:43.18,English,,0,0,0,,The value that's going to be placed here at these four bytes that offset f
Dialogue: 0,0:40:36.78,0:40:43.18,Chinese,,0,0,0,,将在偏移 f 的四个字节处放置的值
Dialogue: 0,0:40:43.70,0:40:48.40,English,,0,0,0,,Is going to be an offset from the current %rip value or program or counter value
Dialogue: 0,0:40:43.70,0:40:48.40,Chinese,,0,0,0,,将是当前 ％rip 值或程序或计数器值的偏移量
Dialogue: 0,0:40:49.44,0:40:53.66,English,,0,0,0,,And since the program counter always points to the nest get next instruction
Dialogue: 0,0:40:49.44,0:40:53.66,Chinese,,0,0,0,,并且由于程序计数器总是指向嵌套获取下一条指令
Dialogue: 0,0:40:55.66,0:40:59.18,English,,0,0,0,,It includes this which is four bytes away it includes this
Dialogue: 0,0:40:55.66,0:40:59.18,Chinese,,0,0,0,,它包括四个字节，它包括这个
Dialogue: 0,0:40:59.54,0:41:01.40,English,,0,0,0,,This offset of minus four
Dialogue: 0,0:40:59.54,0:41:01.40,Chinese,,0,0,0,,这个偏移量减去四
Dialogue: 0,0:41:02.96,0:41:11.22,English,,0,0,0,,So I talked about it in detail in the book if you really want to know how this works
Dialogue: 0,0:41:02.96,0:41:11.22,Chinese,,0,0,0,,所以如果你真的想知道它是如何工作的，我会在书中详细讨论它
Dialogue: 0,0:41:11.32,0:41:17.98,English,,0,0,0,,But just the point here is that there's enough information for the linker to actually fill in the right address
Dialogue: 0,0:41:11.32,0:41:17.98,Chinese,,0,0,0,,但这里的重点是链接器有足够的信息来实际填充正确的地址
Dialogue: 0,0:41:18.98,0:41:21.34,English,,0,0,0,,So now if we look at the relocated .text section
Dialogue: 0,0:41:18.98,0:41:21.34,Chinese,,0,0,0,,现在，如果我们查看重定位的 .text 部分
Dialogue: 0,0:41:21.34,0:41:27.64,English,,0,0,0,,if we compile this code into an executable and then we use objdump to disassemble it
Dialogue: 0,0:41:21.34,0:41:27.64,Chinese,,0,0,0,,如果我们将此代码编译为可执行文件，然后我们使用 objdump 来反编译它
Dialogue: 0,0:41:28.52,0:41:34.36,English,,0,0,0,,Then what you see is this reference here
Dialogue: 0,0:41:28.52,0:41:34.36,Chinese,,0,0,0,,那么你看到的就是这里的引用
Dialogue: 0,0:41:34.36,0:41:38.58,English,,0,0,0,,Where we move the address of the address of a into %edi
Dialogue: 0,0:41:34.36,0:41:38.58,Chinese,,0,0,0,,我们将该地址传送到 ％edi
Dialogue: 0,0:41:39.96,0:41:50.20,English,,0,0,0,,Those four bytes which were original zero have now been updated with the actual address of array in memory at runtime
Dialogue: 0,0:41:39.96,0:41:50.20,Chinese,,0,0,0,,这四个一开始为零的字节现在已经在运行时用内存中数组的实际地址更新
Dialogue: 0,0:41:50.70,0:41:57.60,English,,0,0,0,,Okay so the linkers decided that the array is going to go at address 0x601018
Dialogue: 0,0:41:50.70,0:41:57.60,Chinese,,0,0,0,,好的，所以链接器决定数组将会在地址 0x601018 处
Dialogue: 0,0:41:58.46,0:42:06.54,English,,0,0,0,,And then it's actually patched that the four bytes in the cup in the in the move instruction with that absolute address
Dialogue: 0,0:41:58.46,0:42:06.54,Chinese,,0,0,0,,然后它实际上修改了 mov 指令中该绝对地址中的四个字节
Dialogue: 0,0:42:08.90,0:42:12.28,English,,0,0,0,,And the call to sum is...it's also been updated
Dialogue: 0,0:42:08.90,0:42:12.28,Chinese,,0,0,0,,对 sum 的调用是......它也被更新了
Dialogue: 0,0:42:13.18,0:42:15.02,English,,0,0,0,,But this one's interesting right that
Dialogue: 0,0:42:13.18,0:42:15.02,Chinese,,0,0,0,,这很有趣
Dialogue: 0,0:42:15.46,0:42:22.04,English,,0,0,0,,So the address it's been updated with the pc relative address of five
Dialogue: 0,0:42:15.46,0:42:22.04,Chinese,,0,0,0,,所以用 pc 的相对地址为 5 来更新它的地址
Dialogue: 0,0:42:23.42,0:42:25.42,English,,0,0,0,,Okay so when this program runs
Dialogue: 0,0:42:23.42,0:42:25.42,Chinese,,0,0,0,,好的，所以当这个程序运行时
Dialogue: 0,0:42:27.34,0:42:28.98,English,,0,0,0,,This call instruction
Dialogue: 0,0:42:27.34,0:42:28.98,Chinese,,0,0,0,,调用指令
Dialogue: 0,0:42:30.54,0:42:39.68,English,,0,0,0,,What it will do when it when it determines when it computes the absolute address of the function sum
Dialogue: 0,0:42:30.54,0:42:39.68,Chinese,,0,0,0,,当它确定何时计算函数 sum 的绝对地址时它会做什么？
Dialogue: 0,0:42:40.84,0:42:49.10,English,,0,0,0,,It will take...
Dialogue: 0,0:42:40.84,0:42:49.10,Chinese,,0,0,0,,他将
Dialogue: 0,0:42:49.26,0:43:00.36,English,,0,0,0,,It will take the current value of the program counter which is the next instruction so 0x4004e3
Dialogue: 0,0:42:49.26,0:43:00.36,Chinese,,0,0,0,,它将采用程序计数器的当前值，即下一条指令 0x4004e3
Dialogue: 0,0:43:01.44,0:43:07.42,English,,0,0,0,,And it will add to it whatever value is in this immediate field
Dialogue: 0,0:43:01.44,0:43:07.42,Chinese,,0,0,0,,它将增加它在这个区域的任何值
Dialogue: 0,0:43:08.16,0:43:13.84,English,,0,0,0,,Okay which is a two's comp... interpret it as a two's complement integer so it can go
Dialogue: 0,0:43:08.16,0:43:13.84,Chinese,,0,0,0,,好的，这是一个二..把它解释为一个二进制补码整数，所以它可以
Dialogue: 0,0:43:14.76,0:43:18.22,English,,0,0,0,,It can be relative you can go - or +
Dialogue: 0,0:43:14.76,0:43:18.22,Chinese,,0,0,0,,它可以是相对的，你可以去 - 或 +
Dialogue: 0,0:43:18.88,0:43:28.44,English,,0,0,0,,In this case it's saying that the function that you want to call is at 0x4004e3 + 5
Dialogue: 0,0:43:18.88,0:43:28.44,Chinese,,0,0,0,,在这种情况下，它表示你要调用的函数是在 0x4004e3 + 5
Dialogue: 0,0:43:29.54,0:43:34.66,English,,0,0,0,,Which is 0x4004e8 which is the address of sum
Dialogue: 0,0:43:29.54,0:43:34.66,Chinese,,0,0,0,,就是 0x4004e8，这是 sum 的地址
Dialogue: 0,0:43:35.80,0:43:40.38,English,,0,0,0,,Okay and so the linker does that the compiler has all the smarts
Dialogue: 0,0:43:35.80,0:43:40.38,Chinese,,0,0,0,,好了，所以链接器做的是，编译器有这些智慧
Dialogue: 0,0:43:40.38,0:43:43.46,English,,0,0,0,,The compiler computed the relocation entry
Dialogue: 0,0:43:40.38,0:43:43.46,Chinese,,0,0,0,,编译器计算了重定位条目
Dialogue: 0,0:43:43.70,0:43:49.02,English,,0,0,0,,The linker is just blindly going through each of those relocation entries and just doing what it's told
Dialogue: 0,0:43:43.70,0:43:49.02,Chinese,,0,0,0,,链接器只是盲目地浏览每个重定位条目，只是按照它所说的去做
Dialogue: 0,0:43:50.44,0:43:58.74,English,,0,0,0,,Okay but the next result is that now all of these these references have been patched up with valid absolute addresses
Dialogue: 0,0:43:50.44,0:43:58.74,Chinese,,0,0,0,,好的，但接下来的结果是，现在所有这些引用都已使用有效的绝对地址进行了修补
Dialogue: 0,0:44:04.90,0:44:08.34,English,,0,0,0,,Now once the linkers created an object file
Dialogue: 0,0:44:04.90,0:44:08.34,Chinese,,0,0,0,,现在，一旦链接器创建了一个目标文件
Dialogue: 0,0:44:10.20,0:44:13.92,English,,0,0,0,,That object file can be loaded the code and data
Dialogue: 0,0:44:10.20,0:44:13.92,Chinese,,0,0,0,,该对象文件可以加载代码和数据
Dialogue: 0,0:44:13.92,0:44:18.80,English,,0,0,0,,And that object file can be loaded directly into memory with no further modification
Dialogue: 0,0:44:13.92,0:44:18.80,Chinese,,0,0,0,,并且该对象文件可以直接加载到内存中而无需进一步修改
Dialogue: 0,0:44:20.32,0:44:29.72,English,,0,0,0,,Ok so the if you look at all of the read-only sections in the executable
Dialogue: 0,0:44:20.32,0:44:29.72,Chinese,,0,0,0,,好的，如果你查看可执行文件中的所有只读部分
Dialogue: 0,0:44:30.62,0:44:33.60,English,,0,0,0,,So there's this .init section which
Dialogue: 0,0:44:30.62,0:44:33.60,Chinese,,0,0,0,,所以有这个 .init 部分
Dialogue: 0,0:44:35.40,0:44:41.18,English,,0,0,0,,We're not to worry about that, all the code is in the .text and things like jump tables are in .rodata
Dialogue: 0,0:44:35.40,0:44:41.18,Chinese,,0,0,0,,我们不用担心，所有代码都在 .text 中，跳转表之类的东西都在 .rodata 中
Dialogue: 0,0:44:43.58,0:44:48.18,English,,0,0,0,,All of this data can be loaded directly into memory as is
Dialogue: 0,0:44:43.58,0:44:48.18,Chinese,,0,0,0,,所有这些数据都可以直接加载到内存中
Dialogue: 0,0:44:49.64,0:44:53.90,English,,0,0,0,,Okay so these bytes can just be copied directly into memory
Dialogue: 0,0:44:49.64,0:44:53.90,Chinese,,0,0,0,,好的，所以这些字节可以直接复制到内存中
Dialogue: 0,0:44:54.82,0:44:58.78,English,,0,0,0,,And that forms the so called a read-only code segment
Dialogue: 0,0:44:54.82,0:44:58.78,Chinese,,0,0,0,,这形成了所谓的只读代码段
Dialogue: 0,0:45:02.44,0:45:10.60,English,,0,0,0,,The data in the .data and .bss  sections can also be copied directly into memory
Dialogue: 0,0:45:02.44,0:45:10.60,Chinese,,0,0,0,,.data 和 .bss 部分中的数据也可以直接复制到内存中
Dialogue: 0,0:45:13.40,0:45:19.86,English,,0,0,0,,And in the case of the variables and .data they'll be initialized to a value that's stored in the symbol table
Dialogue: 0,0:45:13.40,0:45:19.86,Chinese,,0,0,0,,在变量和 .data 的区域下，它们将被初始化为存储在符号表中的值
Dialogue: 0,0:45:22.96,0:45:27.34,English,,0,0,0,,So we're drawing a memory here
Dialogue: 0,0:45:22.96,0:45:27.34,Chinese,,0,0,0,,所以我们在这里画一个存储模型
Dialogue: 0,0:45:27.34,0:45:36.34,English,,0,0,0,,This is the (memory) address space that every Linux program sees
Dialogue: 0,0:45:27.34,0:45:36.34,Chinese,,0,0,0,,这是每个 Linux 程序看到的（内存）地址空间
Dialogue: 0,0:45:37.56,0:45:46.02,English,,0,0,0,,And we're drawing addresses starting from 0 and going up increasing as we grow up
Dialogue: 0,0:45:37.56,0:45:46.02,Chinese,,0,0,0,,我们从 0 开始画地址，随着往上而增加
Dialogue: 0,0:45:47.62,0:45:58.04,English,,0,0,0,,And every program is loaded at this the same address  0x400000
Dialogue: 0,0:45:47.62,0:45:58.04,Chinese,,0,0,0,,并且每个程序都加载到相同的地址 0x400000
Dialogue: 0,0:45:59.76,0:46:06.36,English,,0,0,0,,And so the the code comes directly from the object file the data comes directly from the object file
Dialogue: 0,0:45:59.76,0:46:06.36,Chinese,,0,0,0,,因此代码直接来自目标文件，数据直接来自目标文件
Dialogue: 0,0:46:07.04,0:46:09.68,English,,0,0,0,,And then that's followed by a runtime heap
Dialogue: 0,0:46:07.04,0:46:09.68,Chinese,,0,0,0,,然后是运行堆
Dialogue: 0,0:46:10.18,0:46:12.50,English,,0,0,0,,Which is created and managed by malloc
Dialogue: 0,0:46:10.18,0:46:12.50,Chinese,,0,0,0,,这是由 malloc 创建和管理的
Dialogue: 0,0:46:13.14,0:46:16.38,English,,0,0,0,,So when you need dynamically need to allocate memory
Dialogue: 0,0:46:13.14,0:46:16.38,Chinese,,0,0,0,,所以当你需要动态分配内存时
Dialogue: 0,0:46:16.42,0:46:22.22,English,,0,0,0,,Like using malloc that memory comes out of this heap
Dialogue: 0,0:46:16.42,0:46:22.22,Chinese,,0,0,0,,比如使用 malloc ，内存来自这个堆
Dialogue: 0,0:46:22.30,0:46:26.94,English,,0,0,0,,Which starts immediately following the data segment and grows upwards
Dialogue: 0,0:46:22.30,0:46:26.94,Chinese,,0,0,0,,它紧随数据段之后开始并向上发展
Dialogue: 0,0:46:29.42,0:46:39.20,English,,0,0,0,,The stack is at the very top of the visible memory that's available to application programs
Dialogue: 0,0:46:29.42,0:46:39.20,Chinese,,0,0,0,,栈位于可见内存的最顶层，可供应用程序使用
Dialogue: 0,0:46:40.02,0:46:46.94,English,,0,0,0,,The memory above that is restricted to the kernel
Dialogue: 0,0:46:40.02,0:46:46.94,Chinese,,0,0,0,,上面的内存仅限于内核
Dialogue: 0,0:46:47.62,0:46:51.92,English,,0,0,0,,Okay so if you try to access those memory locations you'll get a seg fault
Dialogue: 0,0:46:47.62,0:46:51.92,Chinese,,0,0,0,,好的，如果你尝试访问这些内存位置，你将收到段错误
Dialogue: 0,0:46:54.00,0:46:58.72,English,,0,0,0,,And then the stack as we know grows down so this is managed and created a runtime
Dialogue: 0,0:46:54.00,0:46:58.72,Chinese,,0,0,0,,然后我们知道的，堆栈会逐渐减少，这样就可以管理并创建一个运行时间
Dialogue: 0,0:46:59.50,0:47:03.88,English,,0,0,0,,And then there's this region somewhere in this huge gap between the stack and the heap
Dialogue: 0,0:46:59.50,0:47:03.88,Chinese,,0,0,0,,然后在栈和堆之间的这个巨大差距将会在某个地方存在这个区域
Dialogue: 0,0:47:05.54,0:47:14.74,English,,0,0,0,,There's a region for shared libraries so the .so files all get loaded into this memory-mapped region for shared libraries
Dialogue: 0,0:47:05.54,0:47:14.74,Chinese,,0,0,0,,共享库有一个区域，因此 .so 文件都被加载到共享库的内存映射区域
Dialogue: 0,0:47:17.90,0:47:21.84,English,,0,0,0,,Now that the top of the heap is indicated by this global variable
Dialogue: 0,0:47:17.90,0:47:21.84,Chinese,,0,0,0,,现在堆的顶部由此全局变量指示
Dialogue: 0,0:47:23.12,0:47:26.52,English,,0,0,0,,Maintained by the kernel called break brk
Dialogue: 0,0:47:23.12,0:47:26.52,Chinese,,0,0,0,,由内核维护，名为 break， brk
Dialogue: 0,0:47:27.38,0:47:33.60,English,,0,0,0,,And the the top of the stack as we know is maintained by the general purpose register %rsp
Dialogue: 0,0:47:27.38,0:47:33.60,Chinese,,0,0,0,,我们所知道的堆栈顶部由通用寄存器 ％rsp 维护
Dialogue: 0,0:47:34.58,0:47:38.00,English,,0,0,0,,Now there's a little bit of a...this is a little bit of a simplification
Dialogue: 0,0:47:34.58,0:47:38.00,Chinese,,0,0,0,,现在有一点......这有点简化
Dialogue: 0,0:47:38.00,0:47:42.64,English,,0,0,0,,If you actually look at the addresses returned by malloc
Dialogue: 0,0:47:38.00,0:47:42.64,Chinese,,0,0,0,,如果你实际查看 malloc 返回的地址
Dialogue: 0,0:47:43.44,0:47:46.34,English,,0,0,0,,There's actually,a there's actually two heaps
Dialogue: 0,0:47:43.44,0:47:46.34,Chinese,,0,0,0,,实际上，实际上有两个堆
Dialogue: 0,0:47:46.34,0:47:50.88,English,,0,0,0,,There's a heap up here and in the high memory that grows down
Dialogue: 0,0:47:46.34,0:47:50.88,Chinese,,0,0,0,,这上面有一个堆，并且在高速记忆中会逐渐减少
Dialogue: 0,0:47:51.16,0:47:54.20,English,,0,0,0,,That's used for large objects,very large
Dialogue: 0,0:47:51.16,0:47:54.20,Chinese,,0,0,0,,那用于大型目标，非常大
Dialogue: 0,0:47:54.66,0:47:56.24,English,,0,0,0,,if you mount like a whole bunch of space
Dialogue: 0,0:47:54.66,0:47:56.24,Chinese,,0,0,0,,它会增长比如一大堆空间
Dialogue: 0,0:47:56.80,0:48:01.72,English,,0,0,0,,And then the heap that grows up is  is reserved for smaller smaller objects
Dialogue: 0,0:47:56.80,0:48:01.72,Chinese,,0,0,0,,增长的堆被保留用于较小的目标
Dialogue: 0,0:48:03.26,0:48:04.60,English,,0,0,0,,So I'm not really sure why they do this
Dialogue: 0,0:48:03.26,0:48:04.60,Chinese,,0,0,0,,所以我不确定他们为什么这样做
Dialogue: 0,0:48:04.62,0:48:11.02,English,,0,0,0,,I think it allows them to have separate allocation algorithms for large objects and small objects
Dialogue: 0,0:48:04.62,0:48:11.02,Chinese,,0,0,0,,我认为它允许他们为大的目标和小的目标分别使用分配算法
Dialogue: 0,0:48:19.32,0:48:25.04,English,,0,0,0,,Okay so one of the real advantages of linking is that allows us to create libraries of things
Dialogue: 0,0:48:19.32,0:48:25.04,Chinese,,0,0,0,,好吧接下来，链接的一个真正优势是允许我们创建库
Dialogue: 0,0:48:26.26,0:48:29.12,English,,0,0,0,,So it's always something we want to do as programmers we always...
Dialogue: 0,0:48:26.26,0:48:29.12,Chinese,,0,0,0,,因此，作为程序员，我们总是希望做的某些事情......
Dialogue: 0,0:48:30.92,0:48:36.72,English,,0,0,0,,We always want to create abstractions and then present those abstractions to users
Dialogue: 0,0:48:30.92,0:48:36.72,Chinese,,0,0,0,,我们总是希望创建抽象，然后将这些抽象呈现给用户
Dialogue: 0,0:48:37.42,0:48:40.48,English,,0,0,0,,Right and we do that by creating libraries defining an api
Dialogue: 0,0:48:37.42,0:48:40.48,Chinese,,0,0,0,,是的，我们通过创建定义 api 的库来实现
Dialogue: 0,0:48:40.48,0:48:40.98,English,,0,0,0,,Yes
Dialogue: 0,0:48:40.48,0:48:40.98,Chinese,,0,0,0,,是
Dialogue: 0,0:48:41.70,0:48:50.76,English,,0,0,0,,[student speaking]
Dialogue: 0,0:48:41.70,0:48:50.76,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:48:53.20,0:48:56.54,English,,0,0,0,,I think it just is...no no it
Dialogue: 0,0:48:53.20,0:48:56.54,Chinese,,0,0,0,,我认为这只是......不，不
Dialogue: 0,0:48:59.02,0:49:04.92,English,,0,0,0,,Actually that's a good question I... the things I've done it just grows until it runs out of memory right there
Dialogue: 0,0:48:59.02,0:49:04.92,Chinese,,0,0,0,,实际上，这是一个很好的问题，我...我做过的实验里面它会不断增长，直到它在那里耗尽内存
Dialogue: 0,0:49:06.22,0:49:10.06,English,,0,0,0,,So I don't think actually that's a really good question I mean I've...
Dialogue: 0,0:49:06.22,0:49:10.06,Chinese,,0,0,0,,所以我认为这不认为....那是个一个非常好的问题我的意思是我...
Dialogue: 0,0:49:10.79,0:49:14.66,English,,0,0,0,,I've done those experiments and it eventually reaches some limit
Dialogue: 0,0:49:10.79,0:49:14.66,Chinese,,0,0,0,,我做过那些实验，最终达到了一定的限度
Dialogue: 0,0:49:21.38,0:49:24.96,English,,0,0,0,,Yeah I don't know it's a very large number
Dialogue: 0,0:49:21.38,0:49:24.96,Chinese,,0,0,0,,是的我不知道，这是一个非常大的数字
Dialogue: 0,0:49:29.34,0:49:36.18,English,,0,0,0,,But I so you know as programmers we always want to abstract define apis
Dialogue: 0,0:49:29.34,0:49:36.18,Chinese,,0,0,0,,但我知道作为程序员我们总是想抽象定义 api
Dialogue: 0,0:49:36.50,0:49:42.30,English,,0,0,0,,Implement package up those api's and make them available to to other programmers
Dialogue: 0,0:49:36.50,0:49:42.30,Chinese,,0,0,0,,实现打包这些 api 并将其提供给其他程序员
Dialogue: 0,0:49:44.78,0:49:50.24,English,,0,0,0,,So how can we actually do that how can we make commonly used functions available to other programmers
Dialogue: 0,0:49:44.78,0:49:50.24,Chinese,,0,0,0,,那么我们如何才能真正实现这一目标呢？我们如何将常用函数提供给其他程序员
Dialogue: 0,0:49:50.56,0:49:53.64,English,,0,0,0,,Well one thing given what we've learned so far
Dialogue: 0,0:49:50.56,0:49:53.64,Chinese,,0,0,0,,鉴于我们迄今为止学到的东西，还有一件事
Dialogue: 0,0:49:54.22,0:50:00.30,English,,0,0,0,, You could just take all the functions and put them all in a single big C file right
Dialogue: 0,0:49:54.22,0:50:00.30,Chinese,,0,0,0,,你可以把所有的功能都放在一个大的 C 文件中
Dialogue: 0,0:50:01.08,0:50:07.74,English,,0,0,0,,And then programmers would just link that C file into their programs if they want to use them right
Dialogue: 0,0:50:01.08,0:50:07.74,Chinese,,0,0,0,,如果他们想要正确使用它们然后程序员只要将 C 文件链接到他们的程序中
Dialogue: 0,0:50:08.48,0:50:13.20,English,,0,0,0,,Another option would be to take that might get kind of unwieldy if it's a big library right
Dialogue: 0,0:50:08.48,0:50:13.20,Chinese,,0,0,0,,另一种选择是如果它是一个很大的库，可能会变得有点笨重
Dialogue: 0,0:50:13.42,0:50:16.30,English,,0,0,0,,libc has hundreds and hundreds of functions
Dialogue: 0,0:50:13.42,0:50:16.30,Chinese,,0,0,0,,libc 有数百种功能
Dialogue: 0,0:50:17.44,0:50:21.50,English,,0,0,0,,So another option would might be to just take each function put it in a separate file
Dialogue: 0,0:50:17.44,0:50:21.50,Chinese,,0,0,0,,所以另一种选择可能是将每个函数放在一个单独的文件中
Dialogue: 0,0:50:22.20,0:50:25.56,English,,0,0,0,,And then compile them all together and compile and link them all together
Dialogue: 0,0:50:22.20,0:50:25.56,Chinese,,0,0,0,,然后将它们一起编译并编译并将它们链接在一起
Dialogue: 0,0:50:27.22,0:50:33.48,English,,0,0,0,,So this is more space and time efficient than then the first option
Dialogue: 0,0:50:27.22,0:50:33.48,Chinese,,0,0,0,,因此，这比第一个选项更节省空间和时间
Dialogue: 0,0:50:34.72,0:50:37.50,English,,0,0,0,,But it seems like it would be burdensome on the programmer because
Dialogue: 0,0:50:34.72,0:50:37.50,Chinese,,0,0,0,,但似乎这对程序员来说会很麻烦，因为
Dialogue: 0,0:50:38.18,0:50:42.70,English,,0,0,0,,The program would have to know where all the all these functions were and put them in make files
Dialogue: 0,0:50:38.18,0:50:42.70,Chinese,,0,0,0,,该程序必须知道所有这些函数的位置，并将它们放在 make 文件中
Dialogue: 0,0:50:42.70,0:50:50.56,English,,0,0,0,,It'd just be a lot of you know this you could end up with a ridiculously large command line to GCC
Dialogue: 0,0:50:42.70,0:50:50.56,Chinese,,0,0,0,,很多人都知道你最终可能会向 GCC 提供一个非常大的命令行
Dialogue: 0,0:50:52.80,0:50:57.96,English,,0,0,0,,So that one solution to this problem is that
Dialogue: 0,0:50:52.80,0:50:57.96,Chinese,,0,0,0,,所以这个问题的一个解决方案是
Dialogue: 0,0:50:58.24,0:51:03.82,English,,0,0,0,,The first solution that the developers of Unix came up with us
Dialogue: 0,0:50:58.24,0:51:03.82,Chinese,,0,0,0,,Unix 开发人员提出的第一个解决方案
Dialogue: 0,0:51:04.10,0:51:05.54,English,,0,0,0,,Somebody called a static library
Dialogue: 0,0:51:04.10,0:51:05.54,Chinese,,0,0,0,,有些人称它为静态库
Dialogue: 0,0:51:06.44,0:51:11.58,English,,0,0,0,,So the the idea where the static library is that you create this archive  called a .a file
Dialogue: 0,0:51:06.44,0:51:11.58,Chinese,,0,0,0,,因此，你创建了此被称为 .a 文件归档的静态库的想法
Dialogue: 0,0:51:12.50,0:51:19.18,English,,0,0,0,,Which is it's just a collection of .o file where each .o file contains a function
Dialogue: 0,0:51:12.50,0:51:19.18,Chinese,,0,0,0,,这只是 .o 文件的集合，其中每个 .o 文件都包含一个函数
Dialogue: 0,0:51:19.46,0:51:25.65,English,,0,0,0,,Ok so you take all the functions in your library you use option two to create a bunch of .o files
Dialogue: 0,0:51:19.46,0:51:25.65,Chinese,,0,0,0,,好的，所以你使用库中的所有函数，你使用选项二来创建一堆 .o 文件
Dialogue: 0,0:51:26.30,0:51:31.26,English,,0,0,0,,And then you use a program called an archive or AR  to take those .o files
Dialogue: 0,0:51:26.30,0:51:31.26,Chinese,,0,0,0,,然后你使用一个名为 archive 或 AR 的程序来获取那些 .o 文件
Dialogue: 0,0:51:31.82,0:51:37.30,English,,0,0,0,,Put them together in a all together in a big file called an archive
Dialogue: 0,0:51:31.82,0:51:37.30,Chinese,,0,0,0,,将它们放在一起，放在一个称为存档的大文件中
Dialogue: 0,0:51:37.94,0:51:44.14,English,,0,0,0,,With a table of contents at the beginning that tells you the offset of each one of the .o files
Dialogue: 0,0:51:37.94,0:51:44.14,Chinese,,0,0,0,,开始使用一个内容目录，告诉你每个 .o 文件的偏移量
Dialogue: 0,0:51:44.54,0:51:49.92,English,,0,0,0,,Ok so an archive is just this concatenated collection of .o files
Dialogue: 0,0:51:44.54,0:51:49.92,Chinese,,0,0,0,,好的，所以存档就是这个链接的 .o 文件集合
Dialogue: 0,0:51:53.12,0:51:57.64,English,,0,0,0,,And then and then you link you pass that archive to the linker
Dialogue: 0,0:51:53.12,0:51:57.64,Chinese,,0,0,0,,然后，你将链接传递给链接器
Dialogue: 0,0:51:58.06,0:52:03.62,English,,0,0,0,,And it only takes the .o files that are actually referenced  and links them into the code
Dialogue: 0,0:51:58.06,0:52:03.62,Chinese,,0,0,0,,它只需要实际引用的 .o 文件并将它们链接到代码中
Dialogue: 0,0:52:03.74,0:52:07.42,English,,0,0,0,,Right so it's a more efficient way you can have a huge archive
Dialogue: 0,0:52:03.74,0:52:07.42,Chinese,,0,0,0,,这是一个更有效的方式，你可以有一个巨大的档案
Dialogue: 0,0:52:07.78,0:52:10.26,English,,0,0,0,,But like libc but if you only call printf
Dialogue: 0,0:52:07.78,0:52:10.26,Chinese,,0,0,0,,但是比如 libc，但是如果你只调用 printf
Dialogue: 0,0:52:11.32,0:52:13.88,English,,0,0,0,,The only .o file you get is printf.o
Dialogue: 0,0:52:11.32,0:52:13.88,Chinese,,0,0,0,,你得到的唯一 .o 文件是 printf.o
Dialogue: 0,0:52:15.50,0:52:17.90,English,,0,0,0,,Okay so the way this works is
Dialogue: 0,0:52:15.50,0:52:17.90,Chinese,,0,0,0,,好的，这样做的方式是
Dialogue: 0,0:52:18.80,0:52:19.96,English,,0,0,0,,As before we take
Dialogue: 0,0:52:18.80,0:52:19.96,Chinese,,0,0,0,,和以前采取的方式一样
Dialogue: 0,0:52:24.76,0:52:28.00,English,,0,0,0,,We take all the functions we want to put in our library
Dialogue: 0,0:52:24.76,0:52:28.00,Chinese,,0,0,0,,我们将我们想要的所有函数放在库中
Dialogue: 0,0:52:29.40,0:52:32.48,English,,0,0,0,,We run them through our translators to get .o files
Dialogue: 0,0:52:29.40,0:52:32.48,Chinese,,0,0,0,,我们通过翻译器运行它们来获取 .o 文件
Dialogue: 0,0:52:33.30,0:52:37.14,English,,0,0,0,,We pass those to the archiver to get a the archive
Dialogue: 0,0:52:33.30,0:52:37.14,Chinese,,0,0,0,,我们将这些文件传递给归档器以获取归档文件
Dialogue: 0,0:52:37.14,0:52:40.74,English,,0,0,0,,So in this case libc.a
Dialogue: 0,0:52:37.14,0:52:40.74,Chinese,,0,0,0,,所以在种情况下 libc.a
Dialogue: 0,0:52:42.02,0:52:46.16,English,,0,0,0,,And which has this code for printf that we might want to use
Dialogue: 0,0:52:42.02,0:52:46.16,Chinese,,0,0,0,,可能有 printf 代码，我们想使用
Dialogue: 0,0:52:47.32,0:52:52.42,English,,0,0,0,,Right and so we can recreate that archive anytime we want
Dialogue: 0,0:52:47.32,0:52:52.42,Chinese,,0,0,0,,是的，所以我们可以随时重新创建该档案
Dialogue: 0,0:52:52.42,0:52:55.62,English,,0,0,0,,So if one of these functions changes like say printf changes
Dialogue: 0,0:52:52.42,0:52:55.62,Chinese,,0,0,0,,因此，如果其中一个函数发生变化，比如说 printf 更改
Dialogue: 0,0:52:56.10,0:53:03.51,English,,0,0,0,,You just rearchive the dot recompile printf and then re archive all of the .o files
Dialogue: 0,0:52:56.10,0:53:03.51,Chinese,,0,0,0,,你只需重新存档....重新编译 printf，然后重新存档所有 .o 文件
Dialogue: 0,0:53:04.40,0:53:07.30,English,,0,0,0,,So in libc it's about 1500 object files
Dialogue: 0,0:53:04.40,0:53:07.30,Chinese,,0,0,0,,在 libc 中它大约有 1500 个目标文件
Dialogue: 0,0:53:07.36,0:53:14.42,English,,0,0,0,,And it's archived things like printf,scanf,simple integer math and there's also a math library
Dialogue: 0,0:53:07.36,0:53:14.42,Chinese,,0,0,0,,它存档的东西，比如 printf，scanf，简单的整数数学，还有一个数学库
Dialogue: 0,0:53:15.84,0:53:20.92,English,,0,0,0,,Which has you know several hundred common functions for things like
Dialogue: 0,0:53:15.84,0:53:20.92,Chinese,,0,0,0,,你知道几百种常见功能
Dialogue: 0,0:53:21.66,0:53:26.50,English,,0,0,0,,Floating point math sin,cos,tan gent etc
Dialogue: 0,0:53:21.66,0:53:26.50,Chinese,,0,0,0,,比如浮点数学 sin，cos，tan 等
Dialogue: 0,0:53:27.98,0:53:34.40,English,,0,0,0,,These libraries the convention is that a library always is prefixed with lib with lib and then
Dialogue: 0,0:53:27.98,0:53:34.40,Chinese,,0,0,0,,这些库的惯例是，库总是以 lib 为前缀，然后
Dialogue: 0,0:53:35.06,0:53:38.72,English,,0,0,0,,And then sort of new some indication of what it what it does
Dialogue: 0,0:53:35.06,0:53:38.72,Chinese,,0,0,0,,然后对它的作用进行了一些额外暗示
Dialogue: 0,0:53:42.64,0:53:45.46,English,,0,0,0,,So now let's see how linking with these static libraries would work
Dialogue: 0,0:53:42.64,0:53:45.46,Chinese,,0,0,0,,现在让我们看看如何与这些静态库链接起作用
Dialogue: 0,0:53:45.52,0:53:47.84,English,,0,0,0,,So I've created a little example here
Dialogue: 0,0:53:45.52,0:53:47.84,Chinese,,0,0,0,,所以我在这里创建了一个小例子
Dialogue: 0,0:53:50.36,0:53:53.38,English,,0,0,0,,I've created a library called libvector.a
Dialogue: 0,0:53:50.36,0:53:53.38,Chinese,,0,0,0,,我创建了一个名为 libvector.a 的库
Dialogue: 0,0:53:54.40,0:53:57.38,English,,0,0,0,,And it consists of functions that manipulate vectors
Dialogue: 0,0:53:54.40,0:53:57.38,Chinese,,0,0,0,,它由操纵向量的函数组成
Dialogue: 0,0:53:57.82,0:54:00.68,English,,0,0,0,,And this is a real simple library it just adds
Dialogue: 0,0:53:57.82,0:54:00.68,Chinese,,0,0,0,,这是一个真正简单只是加的库
Dialogue: 0,0:54:00.90,0:54:07.56,English,,0,0,0,,There's a function to add two vectors x and y together and return the result in z
Dialogue: 0,0:54:00.90,0:54:07.56,Chinese,,0,0,0,,这里有一个函数可以将两个向量 x 和 y 相加并在 z 中返回结果
Dialogue: 0,0:54:10.10,0:54:16.00,English,,0,0,0,,And then another similar function that will do pairwise multiplication of two vectors so
Dialogue: 0,0:54:10.10,0:54:16.00,Chinese,,0,0,0,,然后是另一个类似的函数，它将对两个向量进行成对乘法
Dialogue: 0,0:54:16.44,0:54:20.46,English,,0,0,0,,x[i]*y[i] equals z[i]
Dialogue: 0,0:54:16.44,0:54:20.46,Chinese,,0,0,0,,x [i] * y [i] 等于 z [i]
Dialogue: 0,0:54:22.06,0:54:28.94,English,,0,0,0,,Now I compile these two programs and pack I want to package them into an archive called libvector.a
Dialogue: 0,0:54:22.06,0:54:28.94,Chinese,,0,0,0,,现在我编译这两个程序并打包，我想将它们打包成一个名为 libvector.a 的存档
Dialogue: 0,0:54:29.70,0:54:34.46,English,,0,0,0,,And then in my main program I'm going to call one of those functions addvec
Dialogue: 0,0:54:29.70,0:54:34.46,Chinese,,0,0,0,,然后在我的主程序中，我将调用其中一个函数 addvec
Dialogue: 0,0:54:35.12,0:54:38.08,English,,0,0,0,,To add these two vectors x and y together
Dialogue: 0,0:54:35.12,0:54:38.08,Chinese,,0,0,0,,将这两个向量 x 和 y 加在一起
Dialogue: 0,0:54:43.28,0:54:46.26,English,,0,0,0,,So now what happens when we compile this this program
Dialogue: 0,0:54:43.28,0:54:46.26,Chinese,,0,0,0,,那么现在当我们编译这个程序时会发生什么
Dialogue: 0,0:54:47.82,0:54:56.36,English,,0,0,0,,We've already we've constructed the archive libc.a  from addvec.o and multvec.o
Dialogue: 0,0:54:47.82,0:54:56.36,Chinese,,0,0,0,,我们已经从 addvec.o 和 multvec.o 构建了存档 libc.a
Dialogue: 0,0:54:57.80,0:55:05.90,English,,0,0,0,,And we pass that archive to the linker along with a main2.o relocatable object file
Dialogue: 0,0:54:57.80,0:55:05.90,Chinese,,0,0,0,,我们将该存档与 main.o 可重定位目标文件一起传递给链接器
Dialogue: 0,0:55:07.68,0:55:10.42,English,,0,0,0,,And we also pass it libc.a
Dialogue: 0,0:55:07.68,0:55:10.42,Chinese,,0,0,0,,我们也将它传递给 libc.a
Dialogue: 0,0:55:10.80,0:55:14.10,English,,0,0,0,,Which has the definition of which contains printf.o
Dialogue: 0,0:55:10.80,0:55:14.10,Chinese,,0,0,0,,其定义包含 printf.o
Dialogue: 0,0:55:14.96,0:55:17.10,English,,0,0,0,,And anything else that printf.o my call
Dialogue: 0,0:55:14.96,0:55:17.10,Chinese,,0,0,0,,剩下的就是调用 printf.o
Dialogue: 0,0:55:19.08,0:55:26.99,English,,0,0,0,,So these three the linker detects the reference to addvec the function addvec
Dialogue: 0,0:55:19.08,0:55:26.99,Chinese,,0,0,0,,所以这三个链接器检测到 addvec 函数 addvec 的引用
Dialogue: 0,0:55:26.99,0:55:34.40,English,,0,0,0,,And so it just pulls addvec.o out and ignores the rest,similarly for printf.o
Dialogue: 0,0:55:26.99,0:55:34.40,Chinese,,0,0,0,,所以它只是将 addvec.o 拉出来并忽略其余部分，类似于 printf.o
Dialogue: 0,0:55:35.12,0:55:36.66,English,,0,0,0,,And then it compiles all those
Dialogue: 0,0:55:35.12,0:55:36.66,Chinese,,0,0,0,,然后它编译所有这些
Dialogue: 0,0:55:36.96,0:55:43.32,English,,0,0,0,,Main main.o addvec.o and printf.o all together into this fully linked executable
Dialogue: 0,0:55:36.96,0:55:43.32,Chinese,,0,0,0,,主要的 main.o addvec.o 和 printf.o 一起进入这个完全链接的可执行文件
Dialogue: 0,0:55:43.78,0:55:47.10,English,,0,0,0,,Called prog2c for compile-time
Dialogue: 0,0:55:43.78,0:55:47.10,Chinese,,0,0,0,,称为 prog2c 编译时间
Dialogue: 0,0:55:48.84,0:55:54.79,English,,0,0,0,,So we're doing this,we're doing this link,we're doing this this linking at compile time
Dialogue: 0,0:55:48.84,0:55:54.79,Chinese,,0,0,0,,所以我们这样做，我们正在做这个链接，我们在编译时这样做这个链接
Dialogue: 0,0:55:55.28,0:55:57.28,English,,0,0,0,,When we call a GCC
Dialogue: 0,0:55:55.28,0:55:57.28,Chinese,,0,0,0,,当我们调用 GCC 时
Dialogue: 0,0:55:59.06,0:56:05.12,English,,0,0,0,,Now what the linker does when it's using static libraries
Dialogue: 0,0:55:59.06,0:56:05.12,Chinese,,0,0,0,,现在链接器在使用静态库时会做什么
Dialogue: 0,0:56:07.88,0:56:12.28,English,,0,0,0,,It scans all the .o files and .a files in order on the command line
Dialogue: 0,0:56:07.88,0:56:12.28,Chinese,,0,0,0,,它在命令行上按顺序扫描所有 .o 文件和 .a 文件
Dialogue: 0,0:56:12.32,0:56:21.02,English,,0,0,0,,So you're just typing GCC and then a list of .o files and .a files in some order
Dialogue: 0,0:56:12.32,0:56:21.02,Chinese,,0,0,0,,因此，你只需键入 GCC，然后按某种顺序键入 .o 文件和 .a 文件列表
Dialogue: 0,0:56:23.08,0:56:29.14,English,,0,0,0,,So during the scan it keeps a list of the current unresolved references right
Dialogue: 0,0:56:23.08,0:56:29.14,Chinese,,0,0,0,,因此，在扫描期间，它会保留当前未解析的引用列表
Dialogue: 0,0:56:30.18,0:56:35.10,English,,0,0,0,,If let's say let's say it looks at main.o first and there's a reference to printf
Dialogue: 0,0:56:30.18,0:56:35.10,Chinese,,0,0,0,,如果我们说它首先会看看 main.o 有一个对 printf 的引用
Dialogue: 0,0:56:36.58,0:56:41.10,English,,0,0,0,,That's an unresolved reference because printf is not defined in main.o
Dialogue: 0,0:56:36.58,0:56:41.10,Chinese,,0,0,0,,这是一个未解析的引用，因为 printf 未在 main.o 中定义
Dialogue: 0,0:56:41.10,0:56:43.40,English,,0,0,0,,So that goes in a list of undefined references
Dialogue: 0,0:56:41.10,0:56:43.40,Chinese,,0,0,0,,所以这是一个未定义的引用列表
Dialogue: 0,0:56:44.72,0:56:51.68,English,,0,0,0,,And at some point or another as each new .o file or .a file is encountered
Dialogue: 0,0:56:44.72,0:56:51.68,Chinese,,0,0,0,,在某些时候，每个新的 .o 文件或 .a 文件会冲突
Dialogue: 0,0:56:52.22,0:57:01.36,English,,0,0,0,,The linker tries to without but list of references with the symbols that are defined in that .o file or .a file
Dialogue: 0,0:56:52.22,0:57:01.36,Chinese,,0,0,0,,链接器尝试使用该 .o 文件或 .a 文件中定义的符号但不包含引用列表
Dialogue: 0,0:57:03.14,0:57:06.90,English,,0,0,0,,And then if there's any entries in the list at the end of the scan then there's error
Dialogue: 0,0:57:03.14,0:57:06.90,Chinese,,0,0,0,,然后，如果在扫描结束时列表中有任何条目，那么就会出错
Dialogue: 0,0:57:07.42,0:57:13.48,English,,0,0,0,,Okay so that the key here is that the linker will try to resolve these references from left to right on the command line
Dialogue: 0,0:57:07.42,0:57:13.48,Chinese,,0,0,0,,好的，这里的关键是链接器将尝试在命令行上从左到右解析这些引用
Dialogue: 0,0:57:14.16,0:57:18.76,English,,0,0,0,,And so this is another sort of important thing for you to know as programmers
Dialogue: 0,0:57:14.16,0:57:18.76,Chinese,,0,0,0,,因此，作为程序员，这是另一种重要的事情
Dialogue: 0,0:57:18.76,0:57:25.22,English,,0,0,0,,Because the order that you put your files on the command line actually makes a difference
Dialogue: 0,0:57:18.76,0:57:25.22,Chinese,,0,0,0,,因为你将文件放在命令行上的顺序实际上有所不同
Dialogue: 0,0:57:25.58,0:57:31.36,English,,0,0,0,,Okay so you can get sort of weird baffling linker errors if you use the wrong order
Dialogue: 0,0:57:25.58,0:57:31.36,Chinese,,0,0,0,,好的，如果你使用错误的顺序，你可能会遇到一些奇怪的令人困惑的链接器错误
Dialogue: 0,0:57:32.20,0:57:34.08,English,,0,0,0,,So for instance suppose we've got
Dialogue: 0,0:57:32.20,0:57:34.08,Chinese,,0,0,0,,所以比如假设我们有
Dialogue: 0,0:57:36.78,0:57:40.12,English,,0,0,0,,A function an object module called libtest
Dialogue: 0,0:57:36.78,0:57:40.12,Chinese,,0,0,0,,一个函数，一个名为 libtest 的对象模块
Dialogue: 0,0:57:41.04,0:57:48.24,English,,0,0,0,,That calls a function that's defined in lmine.a
Dialogue: 0,0:57:41.04,0:57:48.24,Chinese,,0,0,0,,它调用了一个在 lmine.a 中定义的函数
Dialogue: 0,0:57:49.24,0:58:02.88,English,,0,0,0,,Okay so these -L., -L. period that says to look for,to look for a library files in the current directory
Dialogue: 0,0:57:49.24,0:58:02.88,Chinese,,0,0,0,,好的，所以这些 -L，-L 要求查找，以查找当前目录中的库文件
Dialogue: 0,0:58:02.88,0:58:07.80,English,,0,0,0,,That's what the dot look there first and then look in the normal places that you look
Dialogue: 0,0:58:02.88,0:58:07.80,Chinese,,0,0,0,,这就是查找的点，然后查找你看起来正常的地方
Dialogue: 0,0:58:09.04,0:58:14.72,English,,0,0,0,,And the the -l that's a it's like an abbreviation
Dialogue: 0,0:58:09.04,0:58:14.72,Chinese,,0,0,0,,而 -l 就像是一个缩写
Dialogue: 0,0:58:15.20,0:58:20.14,English,,0,0,0,,We could replace this with just the fully spelled out lmind.a
Dialogue: 0,0:58:15.20,0:58:20.14,Chinese,,0,0,0,,我们可以用完全拼写的 lmind.a 替换它
Dialogue: 0,0:58:20.98,0:58:23.84,English,,0,0,0,,Okay but you'll see this this  -l used a lot
Dialogue: 0,0:58:20.98,0:58:23.84,Chinese,,0,0,0,,好的，但是你会看到这个 -l 我经常使用它
Dialogue: 0,0:58:24.68,0:58:30.94,English,,0,0,0,,So libtest calls a function that's declared in lmind.a
Dialogue: 0,0:58:24.68,0:58:30.94,Chinese,,0,0,0,,libtest 调用了在 lmind.a 中声明的函数
Dialogue: 0,0:58:32.00,0:58:37.28,English,,0,0,0,,So the linker looks at it looks at the unresolved symbols in libtest.o
Dialogue: 0,0:58:32.00,0:58:37.28,Chinese,,0,0,0,,因此，链接器会查看 libtest.o 中未解析的符号
Dialogue: 0,0:58:38.08,0:58:41.28,English,,0,0,0,,And it detects that there's this unresolved function let's say it's called foo
Dialogue: 0,0:58:38.08,0:58:41.28,Chinese,,0,0,0,,并且它检测到这个未解析的函数，我们称它为 foo
Dialogue: 0,0:58:42.34,0:58:44.90,English,,0,0,0,,I know its， it's called libfun
Dialogue: 0,0:58:42.34,0:58:44.90,Chinese,,0,0,0,,我知道它，叫做 libfun
Dialogue: 0,0:58:46.20,0:58:54.38,English,,0,0,0,,So and it puts it on the list and then it goes on to the next command line entry and that's lmine.a
Dialogue: 0,0:58:46.20,0:58:54.38,Chinese,,0,0,0,,所以它把它放在列表上然后继续下一个命令行条目，也就是 lmine.a
Dialogue: 0,0:58:54.78,0:58:58.92,English,,0,0,0,,And in there it finds it finds this symbol of libfun
Dialogue: 0,0:58:54.78,0:58:58.92,Chinese,,0,0,0,,在那里，它发现它找到了 libfun 的这个符号
Dialogue: 0,0:58:59.64,0:59:08.10,English,,0,0,0,,And it resolves the reference to that libfun to the actual address the relocated address
Dialogue: 0,0:58:59.64,0:59:08.10,Chinese,,0,0,0,,并且它将对 libfun 的引用解析为重定位地址的实际地址
Dialogue: 0,0:59:09.14,0:59:15.04,English,,0,0,0,,Now if we switch the order and we put lmine.a first followed by libtest.o
Dialogue: 0,0:59:09.14,0:59:15.04,Chinese,,0,0,0,,现在，如果我们切换顺序，我们首先将 lmine.a 放在 libtest.o 之前
Dialogue: 0,0:59:15.84,0:59:18.60,English,,0,0,0,,Well there's no unresolved references in this library
Dialogue: 0,0:59:15.84,0:59:18.60,Chinese,,0,0,0,,那么这个库中就没有未解析的引用
Dialogue: 0,0:59:18.60,0:59:21.46,English,,0,0,0,,Right it's just the collection of function definitions
Dialogue: 0,0:59:18.60,0:59:21.46,Chinese,,0,0,0,,对，它只是函数定义的集合
Dialogue: 0,0:59:23.26,0:59:27.96,English,,0,0,0,,So it there's no unresolved references so the linker looks at that that's all good
Dialogue: 0,0:59:23.26,0:59:27.96,Chinese,,0,0,0,,因此它没有未解析的引用，因此链接器会发现这一切都很好
Dialogue: 0,0:59:28.26,0:59:33.10,English,,0,0,0,,And then it looks at libtest.o and now there's an unresolved reference to to libfun
Dialogue: 0,0:59:28.26,0:59:33.10,Chinese,,0,0,0,,然后它查看 libtest.o，现在 libfun 有未解析的引用
Dialogue: 0,0:59:33.72,0:59:36.32,English,,0,0,0,,But we're out of we're at the end of the command line
Dialogue: 0,0:59:33.72,0:59:36.32,Chinese,,0,0,0,,但是我们已经到了命令行的末尾
Dialogue: 0,0:59:37.18,0:59:38.46,English,,0,0,0,,So that's a linker error
Dialogue: 0,0:59:37.18,0:59:38.46,Chinese,,0,0,0,,所以就有了一个链接器错误
Dialogue: 0,0:59:39.64,0:59:44.40,English,,0,0,0,,So you get this you get this really cryptic error message
Dialogue: 0,0:59:39.64,0:59:44.40,Chinese,,0,0,0,,所以你获取了这个神秘的错误信息
Dialogue: 0,0:59:45.56,0:59:50.24,English,,0,0,0,,And if you didn't know about this ordering rule you wouldn't have any idea how to debug
Dialogue: 0,0:59:45.56,0:59:50.24,Chinese,,0,0,0,,如果你不了解此顺序规则，你将不知道如何调试
Dialogue: 0,0:59:53.32,0:59:56.88,English,,0,0,0,,It okay so the static libraries are kind of the old fashioned solution that
Dialogue: 0,0:59:53.32,0:59:56.88,Chinese,,0,0,0,,没关系，静态库是一种老式的解决方案
Dialogue: 0,0:59:56.88,1:00:02.04,English,,0,0,0,,The modern solution is to use dynamic libraries or shared libraries
Dialogue: 0,0:59:56.88,1:00:02.04,Chinese,,0,0,0,,现代解决方案是使用动态库或共享库
Dialogue: 0,1:00:04.14,1:00:08.42,English,,0,0,0,,So the reason the reason there's this sort of newer form of libraries
Dialogue: 0,1:00:04.14,1:00:08.42,Chinese,,0,0,0,,这种新型库的存在是有原因的
Dialogue: 0,1:00:08.46,1:00:11.74,English,,0,0,0,,That static libraries have some disadvantages
Dialogue: 0,1:00:08.46,1:00:11.74,Chinese,,0,0,0,,静态库有一些缺点
Dialogue: 0,1:00:12.48,1:00:17.18,English,,0,0,0,,So every if you compile with static libraries
Dialogue: 0,1:00:12.48,1:00:17.18,Chinese,,0,0,0,,所以如果你用静态库编译的话
Dialogue: 0,1:00:17.20,1:00:20.14,English,,0,0,0,,Then every every function that uses printf
Dialogue: 0,1:00:17.20,1:00:20.14,Chinese,,0,0,0,,然后每个使用 printf 的函数
Dialogue: 0,1:00:20.14,1:00:24.34,English,,0,0,0,,Which or every program that uses printf has to have a copy of printf
Dialogue: 0,1:00:20.14,1:00:24.34,Chinese,,0,0,0,,使用 printf 的那个或每个程序都必须有 printf 的副本
Dialogue: 0,1:00:25.98,1:00:29.12,English,,0,0,0,,Okay but almost every every program uses printf right
Dialogue: 0,1:00:25.98,1:00:29.12,Chinese,,0,0,0,,好的，但几乎每个程序都使用 printf
Dialogue: 0,1:00:29.14,1:00:35.14,English,,0,0,0,,So there's a shared libraries allow provide a mechanism where there can just be one
Dialogue: 0,1:00:29.14,1:00:35.14,Chinese,,0,0,0,,共享库允许提供一个机制，这种机制使得其只能有一个
Dialogue: 0,1:00:35.78,1:00:43.32,English,,0,0,0,,Wherever there's just one instance of a shared library member like printf
Dialogue: 0,1:00:35.78,1:00:43.32,Chinese,,0,0,0,,只能有一个像 printf 这样的共享库成员的实例
Dialogue: 0,1:00:44.22,1:00:47.96,English,,0,0,0,,And every program running on the system will share that one copy
Dialogue: 0,1:00:44.22,1:00:47.96,Chinese,,0,0,0,,并且系统上运行的每个程序都将共享该副本
Dialogue: 0,1:00:54.76,1:00:59.96,English,,0,0,0,,So that's sort of the big disadvantage is this potential duplication
Dialogue: 0,1:00:54.76,1:00:59.96,Chinese,,0,0,0,,那种潜在的重复是一个很大的缺点
Dialogue: 0,1:01:01.80,1:01:08.42,English,,0,0,0,,So shared libraries are different in the sense that they contain
Dialogue: 0,1:01:01.80,1:01:08.42,Chinese,,0,0,0,,共享库的意义是不同的
Dialogue: 0,1:01:11.34,1:01:15.38,English,,0,0,0,,Code and data that are linked and loaded into the program now when it's
Dialogue: 0,1:01:11.34,1:01:15.38,Chinese,,0,0,0,,他们包含链接并加载进程序的代码和数据
Dialogue: 0,1:01:15.86,1:01:21.46,English,,0,0,0,,Now when it's compiled and linked and into a executable object file
Dialogue: 0,1:01:15.86,1:01:21.46,Chinese,,0,0,0,,现在是编译和链接到可执行目标文件时
Dialogue: 0,1:01:21.80,1:01:25.98,English,,0,0,0,,But actually when the program is loaded into the system
Dialogue: 0,1:01:21.80,1:01:25.98,Chinese,,0,0,0,,但实际上当程序加载到系统中时
Dialogue: 0,1:01:25.98,1:01:31.50,English,,0,0,0,,So linking of references to shared library objects is deferred
Dialogue: 0,1:01:25.98,1:01:31.50,Chinese,,0,0,0,,对共享库对象的引用的链接延迟了
Dialogue: 0,1:01:32.20,1:01:35.54,English,,0,0,0,,Until the program is actually loaded into memory
Dialogue: 0,1:01:32.20,1:01:35.54,Chinese,,0,0,0,,直到程序实际加载到内存中
Dialogue: 0,1:01:35.78,1:01:39.28,English,,0,0,0,,Until the executable object file is actually loaded into memory
Dialogue: 0,1:01:35.78,1:01:39.28,Chinese,,0,0,0,,直到可执行目标文件实际加载到内存中
Dialogue: 0,1:01:40.28,1:01:42.86,English,,0,0,0,,And this can either and it can even happen
Dialogue: 0,1:01:40.28,1:01:42.86,Chinese,,0,0,0,,这也可以，甚至可能发生
Dialogue: 0,1:01:43.36,1:01:49.82,English,,0,0,0,,It can happen when the program is actually loaded into memory but it can also happen at runtime anytime at runtime
Dialogue: 0,1:01:43.36,1:01:49.82,Chinese,,0,0,0,,它可能在程序实际加载到内存时发生，但也可以在运行时随时在运行时发生
Dialogue: 0,1:01:50.50,1:01:52.76,English,,0,0,0,,So you can be...you can be running a program
Dialogue: 0,1:01:50.50,1:01:52.76,Chinese,,0,0,0,,所以你可以...你可以运行一个程序
Dialogue: 0,1:01:53.20,1:01:59.86,English,,0,0,0,,And that program can arbitrarily decide to load a function that's declared in a shared library
Dialogue: 0,1:01:53.20,1:01:59.86,Chinese,,0,0,0,,并且该程序可以任意决定加载在共享库中声明的函数
Dialogue: 0,1:02:00.32,1:02:01.78,English,,0,0,0,,Okay and I'll show you that it's really cool
Dialogue: 0,1:02:00.32,1:02:01.78,Chinese,,0,0,0,,好的，我会告诉你它真的很酷
Dialogue: 0,1:02:04.12,1:02:06.68,English,,0,0,0,,Now these things are often called they're called shared libraries
Dialogue: 0,1:02:04.12,1:02:06.68,Chinese,,0,0,0,,现在这些东西经常被称为共享库
Dialogue: 0,1:02:06.68,1:02:10.54,English,,0,0,0,,They're called dynamic link libraries like in windows they're called dlls
Dialogue: 0,1:02:06.68,1:02:10.54,Chinese,,0,0,0,,它们被称为动态链接库，比如在 windows 中，它们被称为 dll
Dialogue: 0,1:02:11.42,1:02:14.46,English,,0,0,0,,.so files they're all referenced the same thing
Dialogue: 0,1:02:11.42,1:02:14.46,Chinese,,0,0,0,,.so 文件，他们都引用了相同的东西
Dialogue: 0,1:02:21.30,1:02:23.52,English,,0,0,0,,Okay so that this like I said you can...
Dialogue: 0,1:02:21.30,1:02:23.52,Chinese,,0,0,0,,好吧这就像我说的那样......
Dialogue: 0,1:02:24.38,1:02:30.20,English,,0,0,0,,The dynamic linking can occur when the program's loaded or after it's loaded and actually running
Dialogue: 0,1:02:24.38,1:02:30.20,Chinese,,0,0,0,,动态链接可以在程序加载时或在加载后实际运行时发生
Dialogue: 0,1:02:32.28,1:02:37.66,English,,0,0,0,,And there's this sort of big deal that shared library routines can be shared by multiple processes
Dialogue: 0,1:02:32.28,1:02:37.66,Chinese,,0,0,0,,并且存在这样一个了不起的事，共享库例程可以由多个进程共享
Dialogue: 0,1:02:37.88,1:02:40.46,English,,0,0,0,,And we'll look at this this will make sense when we look at virtual memories
Dialogue: 0,1:02:37.88,1:02:40.46,Chinese,,0,0,0,,当我们学习到虚拟内存时，我们就会发现这是有意义的
Dialogue: 0,1:02:40.46,1:02:42.36,English,,0,0,0,,So don't worry about that now
Dialogue: 0,1:02:40.46,1:02:42.36,Chinese,,0,0,0,,所以现在不要担心
Dialogue: 0,1:02:43.28,1:02:45.26,English,,0,0,0,,But but here's how the process works
Dialogue: 0,1:02:43.28,1:02:45.26,Chinese,,0,0,0,,这就是流程如何工作的图
Dialogue: 0,1:02:49.68,1:02:54.02,English,,0,0,0,,So we've,first we have to create instead of creating an archive
Dialogue: 0,1:02:49.68,1:02:54.02,Chinese,,0,0,0,,所以我们首先要创建而不是创建存档
Dialogue: 0,1:02:54.78,1:02:59.88,English,,0,0,0,,We create a shared library,so our libvector routines
Dialogue: 0,1:02:54.78,1:02:59.88,Chinese,,0,0,0,,我们创建一个共享库，我们的 libvector 程序
Dialogue: 0,1:03:02.22,1:03:08.88,English,,0,0,0,,Instead of creating an archive a file we create a shared a .so file
Dialogue: 0,1:03:02.22,1:03:08.88,Chinese,,0,0,0,,我们创建一个共享的 .so 文件，而不是创建存档文件
Dialogue: 0,1:03:09.46,1:03:13.08,English,,0,0,0,,Using the shared argument to GCC
Dialogue: 0,1:03:09.46,1:03:13.08,Chinese,,0,0,0,,使用 GCC 的共享参数
Dialogue: 0,1:03:13.98,1:03:17.52,English,,0,0,0,,So we take our two input functions a addvec and multvec
Dialogue: 0,1:03:13.98,1:03:17.52,Chinese,,0,0,0,,因此我们将两个输入函数作为 addvec 和 multvec
Dialogue: 0,1:03:18.28,1:03:25.72,English,,0,0,0,,And share it says to create and we're telling GCC to create a shared library  and place it in libvector.so
Dialogue: 0,1:03:18.28,1:03:25.72,Chinese,,0,0,0,,并告诉它说要创建，我们告诉 GCC 创建一个共享库并将其放在 libvector.so 中
Dialogue: 0,1:03:27.04,1:03:36.92,English,,0,0,0,,Okay and so and there's also that the C developers have created a shared library called libc.so
Dialogue: 0,1:03:27.04,1:03:36.92,Chinese,,0,0,0,,好的，还有 C 开发人员创建了一个名为 libc.so 的共享库
Dialogue: 0,1:03:36.92,1:03:41.40,English,,0,0,0,,That contains printf and on it and other standard library functions
Dialogue: 0,1:03:36.92,1:03:41.40,Chinese,,0,0,0,,它包含 printf 和其他标准库函数
Dialogue: 0,1:03:43.46,1:03:47.88,English,,0,0,0,,So we take our program main2,this is the same program that calls addvec
Dialogue: 0,1:03:43.46,1:03:47.88,Chinese,,0,0,0,,所以我们采用我们的程序 main2 ，这是调用 addvec 的相同程序
Dialogue: 0,1:03:48.76,1:03:51.88,English,,0,0,0,,And we compile it into main2.o
Dialogue: 0,1:03:48.76,1:03:51.88,Chinese,,0,0,0,,我们将它编译成 main2.o
Dialogue: 0,1:03:52.30,1:03:57.24,English,,0,0,0,,And we pass main2.o and  these .so files to the linker
Dialogue: 0,1:03:52.30,1:03:57.24,Chinese,,0,0,0,,我们将 main2.o 和这些 .so 文件传递给链接器
Dialogue: 0,1:03:59.72,1:04:07.96,English,,0,0,0,,Now the linker doesn't at this point it doesn't actually copy that say we're using addvec or printf
Dialogue: 0,1:03:59.72,1:04:07.96,Chinese,,0,0,0,,现在链接器在实际上并没有真的复制我们将要使用的 addvec 或 printf
Dialogue: 0,1:04:08.36,1:04:14.14,English,,0,0,0,,It doesn't actually copy those functions or do anything with them in the executable
Dialogue: 0,1:04:08.36,1:04:14.14,Chinese,,0,0,0,,它实际上并不复制这些函数或在可执行文件中对它们执行任何操作
Dialogue: 0,1:04:14.14,1:04:18.44,English,,0,0,0,,It just makes a note in the symbol table that those functions will need to be the
Dialogue: 0,1:04:14.14,1:04:18.44,Chinese,,0,0,0,,它只是在符号表中记下一笔
Dialogue: 0,1:04:20.28,1:04:24.70,English,,0,0,0,,References to those functions will need to be resolved when the program is loaded
Dialogue: 0,1:04:20.28,1:04:24.70,Chinese,,0,0,0,,加载程序时需要解析对这些函数的引用
Dialogue: 0,1:04:25.22,1:04:31.02,English,,0,0,0,,Okay so it,it puts in a relocation entry that says fix this up when you load the program
Dialogue: 0,1:04:25.22,1:04:31.02,Chinese,,0,0,0,,好吧，它放入一个重定位条目，说明在加载程序时解决这个问题
Dialogue: 0,1:04:32.16,1:04:35.44,English,,0,0,0,,So it's partially linked but it's not fully linked
Dialogue: 0,1:04:32.16,1:04:35.44,Chinese,,0,0,0,,所以它是部分链接的，但它并没有完全链接起来
Dialogue: 0,1:04:35.44,1:04:41.94,English,,0,0,0,,You can't take that,you can't take a program,you can't take a executable file
Dialogue: 0,1:04:35.44,1:04:41.94,Chinese,,0,0,0,,你不能获取那个，你不能获取一个程序，你不能获取一个可执行文件
Dialogue: 0,1:04:42.24,1:04:45.56,English,,0,0,0,,That was dynamically linked and loaded directly
Dialogue: 0,1:04:42.24,1:04:45.56,Chinese,,0,0,0,,这就是动态链接和直接加载
Dialogue: 0,1:04:47.42,1:04:54.02,English,,0,0,0,,What you do is the loader which is the execve system call
Dialogue: 0,1:04:47.42,1:04:54.02,Chinese,,0,0,0,,你所做的是作为 execve 系统调用的加载器
Dialogue: 0,1:04:54.50,1:05:02.12,English,,0,0,0,,And we'll learn more about that, but just this is just a sys call that loads loads executables into memory and runs them
Dialogue: 0,1:04:54.50,1:05:02.12,Chinese,,0,0,0,,我们将更多地了解它，但这只是一个 sys 调用，它将可执行文件加载到内存中并运行它们
Dialogue: 0,1:05:03.84,1:05:06.38,English,,0,0,0,,The loader takes the executable
Dialogue: 0,1:05:03.84,1:05:06.38,Chinese,,0,0,0,,加载器获取可执行文件
Dialogue: 0,1:05:07.06,1:05:12.42,English,,0,0,0,,And then it takes the shared .so files
Dialogue: 0,1:05:07.06,1:05:12.42,Chinese,,0,0,0,,然后它需要共享的 .so 文件
Dialogue: 0,1:05:13.04,1:05:19.72,English,,0,0,0,,That this program needs k it also made when the linker also made a note of which .so files it needs
Dialogue: 0,1:05:13.04,1:05:19.72,Chinese,,0,0,0,,当链接器还记录了它需要哪个 .so 文件时，这个程序还需要 k
Dialogue: 0,1:05:22.26,1:05:27.50,English,,0,0,0,,So the loader calls the dynamic linker which takes those .so files
Dialogue: 0,1:05:22.26,1:05:27.50,Chinese,,0,0,0,,所以加载器调用动态链接器，它接受那些 .so 文件
Dialogue: 0,1:05:27.86,1:05:33.18,English,,0,0,0,,And then actually resolves all the references to any on any unresolved reference
Dialogue: 0,1:05:27.86,1:05:33.18,Chinese,,0,0,0,,然后实际解析任何未解析的引用上的所有引用
Dialogue: 0,1:05:33.70,1:05:43.86,English,,0,0,0,,Okay so the the address of addvec,the addvec and printf functions isn't determined until the program is loaded
Dialogue: 0,1:05:33.70,1:05:43.86,Chinese,,0,0,0,,好的，所以 addvec 的地址，addvec 和 printf 函数在程序加载之前是不确定的
Dialogue: 0,1:05:44.80,1:05:49.32,English,,0,0,0,,And by that and it isn't determined by the dynamic linker until the program is loaded
Dialogue: 0,1:05:44.80,1:05:49.32,Chinese,,0,0,0,,由此，在加载程序之前，动态链接器不会确定它
Dialogue: 0,1:05:50.46,1:05:55.02,English,,0,0,0,,So that the dynamic linker does it goes through a similar process that the static linker did
Dialogue: 0,1:05:50.46,1:05:55.02,Chinese,,0,0,0,,因此，动态链接器会执行与静态链接器类似的过程
Dialogue: 0,1:05:55.32,1:05:59.82,English,,0,0,0,,Sort of fixing up references to add back at references to printf
Dialogue: 0,1:05:55.32,1:05:59.82,Chinese,,0,0,0,,修复引用以加回对 printf 的引用
Dialogue: 0,1:06:00.46,1:06:08.42,English,,0,0,0,,And then at that point the binary is in a form that can be executed directly
Dialogue: 0,1:06:00.46,1:06:08.42,Chinese,,0,0,0,,然后在那时，二进制文件的形式可以直接执行
Dialogue: 0,1:06:08.56,1:06:26.98,English,,0,0,0,,So question-yes-what if you look the part where did like where is that like if you include violence and use anger and greed zero actually
Dialogue: 0,1:06:08.56,1:06:26.98,Chinese,,0,0,0,,你有问题？ - 是 -------
Dialogue: 0,1:06:26.98,1:06:29.64,English,,0,0,0,,Okay the question is what happens if you include a file
Dialogue: 0,1:06:26.98,1:06:29.64,Chinese,,0,0,0,,好的问题是如果使用 include 了一个文件会发生什么
Dialogue: 0,1:06:30.50,1:06:34.28,English,,0,0,0,,So includes are handled by the C preprocessor
Dialogue: 0,1:06:30.50,1:06:34.28,Chinese,,0,0,0,,includes 是由 C 预处理器处理
Dialogue: 0,1:06:34.94,1:06:40.78,English,,0,0,0,,So they're gone, they're long gone, by the time the by the time the linker gets around to it
Dialogue: 0,1:06:34.94,1:06:40.78,Chinese,,0,0,0,,因此，当链接器到达它时，它们已经处理过了
Dialogue: 0,1:06:41.28,1:06:45.82,English,,0,0,0,,Okay so the C preprocessor just takes #define,#include
Dialogue: 0,1:06:41.28,1:06:45.82,Chinese,,0,0,0,,好的，所以 C 预处理器只需要 #define，#include
Dialogue: 0,1:06:46.70,1:06:51.44,English,,0,0,0,,And and interprets those and outputs another C program
Dialogue: 0,1:06:46.70,1:06:51.44,Chinese,,0,0,0,,并解释这些并输出另一个 C 程序
Dialogue: 0,1:06:51.98,1:06:59.18,English,,0,0,0,,So if you include a file the C preprocessor just takes that file and just expands it
Dialogue: 0,1:06:51.98,1:06:59.18,Chinese,,0,0,0,,因此，如果你 include 一个文件， C 预处理器只需要获取该文件并将其扩展
Dialogue: 0,1:06:59.90,1:07:05.36,English,,0,0,0,,And the output C program contains an expanded version of all the files that you include it
Dialogue: 0,1:06:59.90,1:07:05.36,Chinese,,0,0,0,,输出 C 程序包含你 include 它的所有文件的扩展版本
Dialogue: 0,1:07:11.38,1:07:16.82,English,,0,0,0,,Okay now that's really cool is that you can also do this dynamic linking at runtime
Dialogue: 0,1:07:11.38,1:07:16.82,Chinese,,0,0,0,,好的，现在真正酷的是你也可以在运行时进行动态链接
Dialogue: 0,1:07:17.34,1:07:20.84,English,,0,0,0,,So what I showed you before we're doing it at load time
Dialogue: 0,1:07:17.34,1:07:20.84,Chinese,,0,0,0,,所以我要向你展示加载时候发生了什么
Dialogue: 0,1:07:21.78,1:07:34.68,English,,0,0,0,,But you can also arbitrarily decide to load link and call a function from a shared from a from any function defined in a .so file
Dialogue: 0,1:07:21.78,1:07:34.68,Chinese,,0,0,0,,但你也可以随意决定加载链接并从 .so 文件中定义的任何共享函数中调用函数
Dialogue: 0,1:07:35.94,1:07:41.36,English,,0,0,0,,And the way you do it is there's a there's an interface called the dlopen
Dialogue: 0,1:07:35.94,1:07:41.36,Chinese,,0,0,0,,你这样做的方法是有一个名为 dlopen 的接口
Dialogue: 0,1:07:41.84,1:07:44.90,English,,0,0,0,,That's in lib.c that allows you to do this
Dialogue: 0,1:07:41.84,1:07:44.90,Chinese,,0,0,0,,这是在 lib.c 中允许你这样做
Dialogue: 0,1:07:45.76,1:07:52.58,English,,0,0,0,,So let's say we want to this is our main program and just like before we want to call addvec
Dialogue: 0,1:07:45.76,1:07:52.58,Chinese,,0,0,0,,所以，我们希望这是我们的主程序，就像我们之前想要调用 addvec 的那样
Dialogue: 0,1:07:53.28,1:07:57.24,English,,0,0,0,,Okay but addvec now is defined in a .so file
Dialogue: 0,1:07:53.28,1:07:57.24,Chinese,,0,0,0,,好的，但现在 addvec 是在 .so 文件中定义的
Dialogue: 0,1:07:57.92,1:08:00.98,English,,0,0,0,,The exact same .so file that we generated before
Dialogue: 0,1:07:57.92,1:08:00.98,Chinese,,0,0,0,,我们之前生成的完全相同的 .so 文件
Dialogue: 0,1:08:02.32,1:08:08.72,English,,0,0,0,,When we compile,so we'll call this dll.c,when we compile this program ddl.c
Dialogue: 0,1:08:02.32,1:08:08.72,Chinese,,0,0,0,,当我们编译时，所以当我们编译这个程序 dll.c 时，我们将调用这个 dll.c
Dialogue: 0,1:08:10.52,1:08:18.92,English,,0,0,0,,We have no idea that it's going to call a function from lib.so
Dialogue: 0,1:08:10.52,1:08:18.92,Chinese,,0,0,0,,我们不知道它会从 lib.so 调用一个函数
Dialogue: 0,1:08:19.38,1:08:23.84,English,,0,0,0,,We just compile it as though a standalone C program
Dialogue: 0,1:08:19.38,1:08:23.84,Chinese,,0,0,0,,我们只是编译它就像是编译一个独立的 C 程序
Dialogue: 0,1:08:24.72,1:08:29.32,English,,0,0,0,,Within this program though we declare a pointer a function pointer called addvec
Dialogue: 0,1:08:24.72,1:08:29.32,Chinese,,0,0,0,,虽然我们在这个程序中声明了一个名为 addvec 的函数指针
Dialogue: 0,1:08:30.10,1:08:32.64,English,,0,0,0,,And we give the prototype for this function
Dialogue: 0,1:08:30.10,1:08:32.64,Chinese,,0,0,0,,我们给出了这个函数的原型
Dialogue: 0,1:08:32.70,1:08:39.14,English,,0,0,0,,It's pointers .. so it's a two input arrays, the output array on the size
Dialogue: 0,1:08:32.70,1:08:39.14,Chinese,,0,0,0,,它是指针，它有两个输入数组，还有的关于规模的输出数组
Dialogue: 0,1:08:41.28,1:08:46.00,English,,0,0,0,,And then first we dynamically load the shared library that contains the function we want
Dialogue: 0,1:08:41.28,1:08:46.00,Chinese,,0,0,0,,然后我们首先动态加载包含我们想要的函数的共享库
Dialogue: 0,1:08:47.24,1:08:55.32,English,,0,0,0,,So we call dlopen and we say load up this .so file into memory
Dialogue: 0,1:08:47.24,1:08:55.32,Chinese,,0,0,0,,然后我们调用 dlopen，然后我们说把这个 .so 文件加载到内存中
Dialogue: 0,1:08:55.42,1:08:57.50,English,,0,0,0,,So that I can call a function
Dialogue: 0,1:08:55.42,1:08:57.50,Chinese,,0,0,0,,这样我就可以调用一个函数了
Dialogue: 0,1:08:57.96,1:09:06.28,English,,0,0,0,,But don't resolve,you know don't worry about the resolving the references to it functions until I actually tell you to
Dialogue: 0,1:08:57.96,1:09:06.28,Chinese,,0,0,0,,但是不要解析.....不要担心解析函数引用，直到告诉你要去才去
Dialogue: 0,1:09:07.24,1:09:09.00,English,,0,0,0,,That's the lazy part
Dialogue: 0,1:09:07.24,1:09:09.00,Chinese,,0,0,0,,那是 LAZY 的部分
Dialogue: 0,1:09:10.50,1:09:13.74,English,,0,0,0,,And so what what this deal open returns a handle
Dialogue: 0,1:09:10.50,1:09:13.74,Chinese,,0,0,0,,那么这个处理返回了一个 handle
Dialogue: 0,1:09:14.40,1:09:18.06,English,,0,0,0,,That then you use in subsequent calls okay
Dialogue: 0,1:09:14.40,1:09:18.06,Chinese,,0,0,0,,然后用在随后的调用中
Dialogue: 0,1:09:19.08,1:09:24.98,English,,0,0,0,,So if we don't if the handle is null there was some kind of error like maybe this data .so file doesn't exist
Dialogue: 0,1:09:19.08,1:09:24.98,Chinese,,0,0,0,,如果 handle 为空，就会出现某种错误，例如这个 .so 文件并不存在
Dialogue: 0,1:09:27.76,1:09:34.32,English,,0,0,0,,So once we've opened that .so file then we use dlsym with the handle so this
Dialogue: 0,1:09:27.76,1:09:34.32,Chinese,,0,0,0,,所以一旦我们打开那个 .so 文件，我们就会使用带有 handle 参数的 dlsym 函数
Dialogue: 0,1:09:34.94,1:09:41.62,English,,0,0,0,,And then we give it as we pass as a string the name of the function that we want to invoke
Dialogue: 0,1:09:34.94,1:09:41.62,Chinese,,0,0,0,,然后我们给它，因为我们传递一个字符串作为我们想要调用的函数的名称
Dialogue: 0,1:09:43.26,1:09:47.90,English,,0,0,0,,And what we get back from dlsym as a pointer to that function
Dialogue: 0,1:09:43.26,1:09:47.90,Chinese,,0,0,0,,我们得到从 dlsym 返回参数作为指向该函数的指针
Dialogue: 0,1:09:48.90,1:09:53.96,English,,0,0,0,,And then we can use that function just like any other function so we can use that function pointer
Dialogue: 0,1:09:48.90,1:09:53.96,Chinese,,0,0,0,,然后我们可以像任何其他函数一样使用该函数，因此我们可以使用该函数指针
Dialogue: 0,1:09:54.24,1:09:57.44,English,,0,0,0,,And we call it just as though it were a statically defined function
Dialogue: 0,1:09:54.24,1:09:57.44,Chinese,,0,0,0,,我们称之为静态定义函数
Dialogue: 0,1:09:58.86,1:10:01.88,English,,0,0,0,,So you can see this is real very powerful technique
Dialogue: 0,1:09:58.86,1:10:01.88,Chinese,,0,0,0,,所以你可以看到这是一个非常强大的技术
Dialogue: 0,1:10:08.50,1:10:14.86,English,,0,0,0,,Okay so looks let's finish the last little bits of the class
Dialogue: 0,1:10:08.50,1:10:14.86,Chinese,,0,0,0,,好吧看起来让我们完成课程的最后一点
Dialogue: 0,1:10:14.86,1:10:21.02,English,,0,0,0,,I want to show you it to try to convince you that linking is is actually interesting which is kind of a hard sell sometime
Dialogue: 0,1:10:14.86,1:10:21.02,Chinese,,0,0,0,,我想告诉你它试图说服你，链接实际上是有趣的，好像是在硬形推销一样
Dialogue: 0,1:10:21.04,1:10:33.80,English,,0,0,0,,Yes question...yes...no it's that's how you know
Dialogue: 0,1:10:21.04,1:10:33.80,Chinese,,0,0,0,,好的问题......是的......不
Dialogue: 0,1:10:34.18,1:10:37.72,English,,0,0,0,,No you just it's declared as a function pointer
Dialogue: 0,1:10:34.18,1:10:37.72,Chinese,,0,0,0,,不，你只是声明它是一个函数指针
Dialogue: 0,1:10:37.72,1:10:43.46,English,,0,0,0,,And you then you just use the name of the function you don't have to dereference it
Dialogue: 0,1:10:37.72,1:10:43.46,Chinese,,0,0,0,,然后你就可以使用你没有的函数名称来取消引用它
Dialogue: 0,1:10:45.42,1:10:52.90,English,,0,0,0,,Or you just you call it you call the function by just using that function pointer name okay
Dialogue: 0,1:10:45.42,1:10:52.90,Chinese,,0,0,0,,或者你只是在调用它，你只需使用该函数指针名称即可调用该函数
Dialogue: 0,1:10:53.42,1:10:54.38,English,,0,0,0,,Just like I did
Dialogue: 0,1:10:53.42,1:10:54.38,Chinese,,0,0,0,,就像我一样
Dialogue: 0,1:10:59.98,1:11:03.22,English,,0,0,0,,If you dereference it I just get back a pointer value
Dialogue: 0,1:10:59.98,1:11:03.22,Chinese,,0,0,0,,如果你取消引用它我只是得到一个指针值
Dialogue: 0,1:11:04.08,1:11:07.80,English,,0,0,0,,You get back the address of that function
Dialogue: 0,1:11:04.08,1:11:07.80,Chinese,,0,0,0,,你得到那个函数返回的地址
Dialogue: 0,1:11:09.70,1:11:15.64,English,,0,0,0,,All right so it's kind of a hard sell to that to convince you that linking is interesting
Dialogue: 0,1:11:09.70,1:11:15.64,Chinese,,0,0,0,,好吧，硬性推销给你们说链接很有意思感觉很难
Dialogue: 0,1:11:15.64,1:11:16.80,English,,0,0,0,,But I'm going to try
Dialogue: 0,1:11:15.64,1:11:16.80,Chinese,,0,0,0,,但是我要试试
Dialogue: 0,1:11:17.30,1:11:22.52,English,,0,0,0,,Ok so there's this powerful technique called inner library inter positioning
Dialogue: 0,1:11:17.30,1:11:22.52,Chinese,,0,0,0,,好的，有一种强大的技术称为库打桩
Dialogue: 0,1:11:23.24,1:11:27.88,English,,0,0,0,,And the goal is to intercept function calls from libraries
Dialogue: 0,1:11:23.24,1:11:27.88,Chinese,,0,0,0,,目标是截获来自库的函数调用
Dialogue: 0,1:11:28.64,1:11:32.60,English,,0,0,0,,And do something intercept them for some reason
Dialogue: 0,1:11:28.64,1:11:32.60,Chinese,,0,0,0,,以及出于某种原因截获它们后做一些事情
Dialogue: 0,1:11:33.30,1:11:37.24,English,,0,0,0,,Right so what we typically want to do is intercept a function call
Dialogue: 0,1:11:33.30,1:11:37.24,Chinese,,0,0,0,,我们通常想要做的就是截获一个函数调用
Dialogue: 0,1:11:38.12,1:11:42.04,English,,0,0,0,,Maybe record some to some statistics or do some error checking
Dialogue: 0,1:11:38.12,1:11:42.04,Chinese,,0,0,0,,也许记录一些统计数据或做一些错误检查
Dialogue: 0,1:11:42.56,1:11:45.94,English,,0,0,0,,And then call the real function as intended
Dialogue: 0,1:11:42.56,1:11:45.94,Chinese,,0,0,0,,然后按预期调用实际函数
Dialogue: 0,1:11:46.04,1:11:50.16,English,,0,0,0,,Right so the idea is we're going to create wrappers
Dialogue: 0,1:11:46.04,1:11:50.16,Chinese,,0,0,0,,对，所以我们的想法是创建包装函数
Dialogue: 0,1:11:52.00,1:12:00.18,English,,0,0,0,,And when the program when a program calls a function what we're going to do is we're going to execute its wrapper instead
Dialogue: 0,1:11:52.00,1:12:00.18,Chinese,,0,0,0,,当一个程序调用一个函数的程序时，我们要做的就是执行它的包装函数
Dialogue: 0,1:12:01.88,1:12:04.30,English,,0,0,0,,Okay and we're going to do it without changing any of the source
Dialogue: 0,1:12:01.88,1:12:04.30,Chinese,,0,0,0,,好的，我们将在不改变任何源的情况下这样做
Dialogue: 0,1:12:09.68,1:12:13.34,English,,0,0,0,,Now there's a lot of reasons there's a lot of applications for this
Dialogue: 0,1:12:09.68,1:12:13.34,Chinese,,0,0,0,,现在有很多原因这样做，有很多应用程序
Dialogue: 0,1:12:13.94,1:12:21.10,English,,0,0,0,,That the neatest one that I know is that these facebook engineers
Dialogue: 0,1:12:13.94,1:12:21.10,Chinese,,0,0,0,,我知道的最棒的是 facebook 工程师做过的
Dialogue: 0,1:12:21.56,1:12:25.30,English,,0,0,0,,So we're trying to deal with this year-long bug in the facebook iPhone app
Dialogue: 0,1:12:21.56,1:12:25.30,Chinese,,0,0,0,,他们正试图在 Facebook 的 iPhone 应用程序中解决一个长达一年的错误
Dialogue: 0,1:12:26.10,1:12:28.20,English,,0,0,0,,And nobody could figure out what was going on
Dialogue: 0,1:12:26.10,1:12:28.20,Chinese,,0,0,0,,没有人能弄明白发生了什么
Dialogue: 0,1:12:29.28,1:12:31.86,English,,0,0,0,,And they figured it out using library inter positioning
Dialogue: 0,1:12:29.28,1:12:31.86,Chinese,,0,0,0,,他们使用库间定位来解决这个问题
Dialogue: 0,1:12:32.28,1:12:37.40,English,,0,0,0,,They figured out that there was something in the network stack writing to the wrong location
Dialogue: 0,1:12:32.28,1:12:37.40,Chinese,,0,0,0,,他们发现网络栈中有东西写错了位置
Dialogue: 0,1:12:37.40,1:12:43.26,English,,0,0,0,,They figured it out by intercepting all the calls from their facebook app  that did rights
Dialogue: 0,1:12:37.40,1:12:43.26,Chinese,,0,0,0,,他们通过拦截来自他们的 Facebook 应用程序的所有权限来解决这个问题
Dialogue: 0,1:12:43.90,1:12:47.04,English,,0,0,0,,So things like write to the ep right
Dialogue: 0,1:12:43.90,1:12:47.04,Chinese,,0,0,0,,然后做一些处理比如写入权限
Dialogue: 0,1:12:47.96,1:12:51.02,English,,0,0,0,,So they just they intercepted all those calls and then they were able to
Dialogue: 0,1:12:47.96,1:12:51.02,Chinese,,0,0,0,,他们只是拦截了所有这些电话，然后他们就可以
Dialogue: 0,1:12:51.02,1:12:54.06,English,,0,0,0,,To when they looked at the arguments and how those functions were being called
Dialogue: 0,1:12:51.02,1:12:54.06,Chinese,,0,0,0,,当他们查看参数以及如何调用这些函数时
Dialogue: 0,1:12:54.26,1:12:55.94,English,,0,0,0,,They determine the air
Dialogue: 0,1:12:54.26,1:12:55.94,Chinese,,0,0,0,,他们决定
Dialogue: 0,1:13:00.04,1:13:02.54,English,,0,0,0,,You can also use it for monitoring and profiling like
Dialogue: 0,1:13:00.04,1:13:02.54,Chinese,,0,0,0,,你也可以使用它进行监视和分析
Dialogue: 0,1:13:02.54,1:13:07.80,English,,0,0,0,,So if you want to know like how many times different functions get called you can you can interpose
Dialogue: 0,1:13:02.54,1:13:07.80,Chinese,,0,0,0,,因此，如果你想知道调用不同函数的次数，你可以设置
Dialogue: 0,1:13:08.34,1:13:12.64,English,,0,0,0,,We use it for generating address traces
Dialogue: 0,1:13:08.34,1:13:12.64,Chinese,,0,0,0,,我们用它来生成地址追踪
Dialogue: 0,1:13:12.70,1:13:17.46,English,,0,0,0,,So you're malloc when you do your malloc lab later in the semester
Dialogue: 0,1:13:12.70,1:13:17.46,Chinese,,0,0,0,,所以当你在学期后期做 malloc 实验时
Dialogue: 0,1:13:17.80,1:13:22.76,English,,0,0,0,,You're going to be evaluating your malloc using a traces
Dialogue: 0,1:13:17.80,1:13:22.76,Chinese,,0,0,0,,你将使用追踪程序评估你的 malloc
Dialogue: 0,1:13:22.76,1:13:27.36,English,,0,0,0,,That we generated from real programs using this inter positioning technique
Dialogue: 0,1:13:22.76,1:13:27.36,Chinese,,0,0,0,,这种追踪程序是从使用了库打桩技术的真实程序中生成的
Dialogue: 0,1:13:27.62,1:13:34.08,English,,0,0,0,,Right so we interpose on all the malloc and free calls in like netscape
Dialogue: 0,1:13:27.62,1:13:34.08,Chinese,,0,0,0,,我们插入所有 malloc 和free 调用，比如 netscape
Dialogue: 0,1:13:35.62,1:13:39.18,English,,0,0,0,,And then we just recorded what addresses and sizes
Dialogue: 0,1:13:35.62,1:13:39.18,Chinese,,0,0,0,,然后我们只记录了地址和大小
Dialogue: 0,1:13:39.64,1:13:44.88,English,,0,0,0,,Malloc was returning and what what blocks free was freeing up
Dialogue: 0,1:13:39.64,1:13:44.88,Chinese,,0,0,0,,Malloc 返回后，free 块释放了
Dialogue: 0,1:13:45.30,1:13:51.84,English,,0,0,0,,And we just created a trace of those, and then, so let me show you how you would do this
Dialogue: 0,1:13:45.30,1:13:51.84,Chinese,,0,0,0,,我们刚刚创建了那些追踪程序，然后，让我告诉你如何做到这一点
Dialogue: 0,1:13:54.00,1:13:56.24,English,,0,0,0,,So the idea let's say we have this main program
Dialogue: 0,1:13:54.00,1:13:56.24,Chinese,,0,0,0,,所以有个主意，这里有一个主程序
Dialogue: 0,1:13:56.26,1:13:59.54,English,,0,0,0,,And the idea is to trace all the malloc and free calls
Dialogue: 0,1:13:56.26,1:13:59.54,Chinese,,0,0,0,,我们的想法是跟踪所有 malloc 和 free 调用
Dialogue: 0,1:13:59.54,1:14:02.38,English,,0,0,0,,So there's one malloc call and there's one free call
Dialogue: 0,1:13:59.54,1:14:02.38,Chinese,,0,0,0,,所以这里有一个 malloc 调用，以及下面调用了 free
Dialogue: 0,1:14:03.16,1:14:07.18,English,,0,0,0,,And we want to know what these addresses are and we want to know what these sizes are
Dialogue: 0,1:14:03.16,1:14:07.18,Chinese,,0,0,0,,我们想知道这些地址是什么，我们想知道这些大小是什么
Dialogue: 0,1:14:08.48,1:14:12.50,English,,0,0,0,,So we can do this at either compile time, link time or run time
Dialogue: 0,1:14:08.48,1:14:12.50,Chinese,,0,0,0,,所以我们可以在编译时，链接时或运行时执行库打桩操作
Dialogue: 0,1:14:13.80,1:14:15.20,English,,0,0,0,,To do it at compile time
Dialogue: 0,1:14:13.80,1:14:15.20,Chinese,,0,0,0,,在编译时执行此操作
Dialogue: 0,1:14:16.02,1:14:19.90,English,,0,0,0,,We first write wrapper functions called mymalloc and myfree
Dialogue: 0,1:14:16.02,1:14:19.90,Chinese,,0,0,0,,我们首先编写名为 mymalloc 和 myfree 的包装函数
Dialogue: 0,1:14:20.44,1:14:23.52,English,,0,0,0,,Where mymalloc calls the __real_malloc function
Dialogue: 0,1:14:20.44,1:14:23.52,Chinese,,0,0,0,,mymalloc 能在相应的位置调用 __real_malloc 函数
Dialogue: 0,1:14:24.08,1:14:30.82,English,,0,0,0,,And then it prints out the the size that it was called and the address that malloc returned
Dialogue: 0,1:14:24.08,1:14:30.82,Chinese,,0,0,0,,然后它打印出它它调用的大小和 malloc 返回的地址
Dialogue: 0,1:14:31.40,1:14:35.60,English,,0,0,0,,Okay so this when we run our program it will print out these all these addresses
Dialogue: 0,1:14:31.40,1:14:35.60,Chinese,,0,0,0,,好的，所以当我们运行程序时，它会打印出这些所有这些地址
Dialogue: 0,1:14:35.60,1:14:37.36,English,,0,0,0,,And it does the same thing for free
Dialogue: 0,1:14:35.60,1:14:37.36,Chinese,,0,0,0,,并且它免费做同样的事情
Dialogue: 0,1:14:38.18,1:14:41.46,English,,0,0,0,,And then here's the trick in malloc.h
Dialogue: 0,1:14:38.18,1:14:41.46,Chinese,,0,0,0,,然后是 malloc.h 中的技巧
Dialogue: 0,1:14:42.26,1:14:49.20,English,,0,0,0,,We define malloc to be mymalloc ,okay and free to be myfree
Dialogue: 0,1:14:42.26,1:14:49.20,Chinese,,0,0,0,,我们将 malloc 定义为 mymalloc，好的，并且把 free 定义为 myfree
Dialogue: 0,1:14:49.52,1:14:53.34,English,,0,0,0,,And then we give the prototype for it so the compiler doesn't get confused
Dialogue: 0,1:14:49.52,1:14:53.34,Chinese,,0,0,0,,然后我们给它原型，这样编译器就不会混淆了
Dialogue: 0,1:14:54.14,1:14:58.10,English,,0,0,0,,And then we can compile mymalloc.c into a .o file
Dialogue: 0,1:14:54.14,1:14:58.10,Chinese,,0,0,0,,然后我们可以将 mymalloc.c 编译成 .o 文件
Dialogue: 0,1:14:59.22,1:15:03.54,English,,0,0,0,,And then we call... then we complete we call our program
Dialogue: 0,1:14:59.22,1:15:03.54,Chinese,,0,0,0,,然后我们调用....然后我们完成我们调用程序
Dialogue: 0,1:15:03.54,1:15:10.74,English,,0,0,0,,Which is our main program int.c for inner positioning
Dialogue: 0,1:15:03.54,1:15:10.74,Chinese,,0,0,0,,这是我们用于库打桩的主要程序 int.c
Dialogue: 0,1:15:11.72,1:15:13.70,English,,0,0,0,,And we call that and here's the trick
Dialogue: 0,1:15:11.72,1:15:13.70,Chinese,,0,0,0,,我们调用它，这里有个诀窍
Dialogue: 0,1:15:14.58,1:15:18.14,English,,0,0,0,,We call it with the -I argument
Dialogue: 0,1:15:14.58,1:15:18.14,Chinese,,0,0,0,,我们用 -I 参数调用它
Dialogue: 0,1:15:18.74,1:15:22.22,English,,0,0,0,,And we say look for any include files in the current directory
Dialogue: 0,1:15:18.74,1:15:22.22,Chinese,,0,0,0,,它的意思是在当前目录中查找任何 include 文件
Dialogue: 0,1:15:22.56,1:15:29.94,English,,0,0,0,,Okay so this was similar to that -L argument
Dialogue: 0,1:15:22.56,1:15:29.94,Chinese,,0,0,0,,好的，这与 -L 参数类似
Dialogue: 0,1:15:30.90,1:15:35.12,English,,0,0,0,,But because we tell GCC to look in the current directory first
Dialogue: 0,1:15:30.90,1:15:35.12,Chinese,,0,0,0,,但是因为我们告诉 GCC 要先查看当前目录
Dialogue: 0,1:15:35.80,1:15:38.20,English,,0,0,0,,So this is sort of where the inner positioning happens
Dialogue: 0,1:15:35.80,1:15:38.20,Chinese,,0,0,0,,这可以说就是库打桩发生的地方
Dialogue: 0,1:15:38.68,1:15:44.60,English,,0,0,0,,This because when it does that it's going to it's going to find a
Dialogue: 0,1:15:38.68,1:15:44.60,Chinese,,0,0,0,,这是因为当它这样做时，它会找到一个
Dialogue: 0,1:15:45.82,1:15:48.28,English,,0,0,0,,It's going to find a library called malloc.h
Dialogue: 0,1:15:45.82,1:15:48.28,Chinese,,0,0,0,,它将找到一个名为 malloc.h 的库
Dialogue: 0,1:15:49.44,1:15:51.54,English,,0,0,0,,I mean .h file called malloc.h
Dialogue: 0,1:15:49.44,1:15:51.54,Chinese,,0,0,0,,我的意思是 .h 文件叫做 malloc.h
Dialogue: 0,1:15:52.02,1:15:57.26,English,,0,0,0,,And so all the calls to malloc will be translated by the C preprocessor to mymalloc
Dialogue: 0,1:15:52.02,1:15:57.26,Chinese,,0,0,0,,所以对 malloc 的所有调用都将由 C 预处理器转换为 mymalloc
Dialogue: 0,1:15:58.76,1:16:04.90,English,,0,0,0,,So when we run this it prints out the the tri... malloc and free trace
Dialogue: 0,1:15:58.76,1:16:04.90,Chinese,,0,0,0,,因此，当我们运行它时，它打印出 malloc 和 free 的跟踪信息
Dialogue: 0,1:16:07.86,1:16:09.60,English,,0,0,0,,Now we can also do this at link time
Dialogue: 0,1:16:07.86,1:16:09.60,Chinese,,0,0,0,,现在我们也可以在链接时执行此操作
Dialogue: 0,1:16:09.60,1:16:14.38,English,,0,0,0,,So we can tell C,in order to do this we had to get access to the
Dialogue: 0,1:16:09.60,1:16:14.38,Chinese,,0,0,0,,所以我们可以告诉 C，为了做到这一点，我们必须访问
Dialogue: 0,1:16:15.14,1:16:19.24,English,,0,0,0,,We had to compile the program,we didn't have to change it but we had to compile it
Dialogue: 0,1:16:15.14,1:16:19.24,Chinese,,0,0,0,,我们必须编译程序，我们不必更改它，但我们必须编译它
Dialogue: 0,1:16:19.94,1:16:27.08,English,,0,0,0,,We can use link time at our positioning if to avoid that compilation
Dialogue: 0,1:16:19.94,1:16:27.08,Chinese,,0,0,0,,如果要避免编译，我们可以在定位时使用链接时间
Dialogue: 0,1:16:28.40,1:16:34.10,English,,0,0,0,,So the way this works we define our wrapper functions with this special name __wrap_malloc
Dialogue: 0,1:16:28.40,1:16:34.10,Chinese,,0,0,0,,因此，我们使用这个特殊名称 __wrap_malloc 来定义我们的包装函数
Dialogue: 0,1:16:35.20,1:16:38.96,English,,0,0,0,,And this calls the __real_malloc function and then prints out the information
Dialogue: 0,1:16:35.20,1:16:38.96,Chinese,,0,0,0,,这会调用 __real_malloc 函数，然后打印出信息
Dialogue: 0,1:16:41.14,1:16:51.16,English,,0,0,0,,And then at link time then we do the inter positioning by calling the linker with this special -Wl  argument
Dialogue: 0,1:16:41.14,1:16:51.16,Chinese,,0,0,0,,然后在链接时，我们通过使用这个特殊的 -Wl 参数调用链接器来进行打桩
Dialogue: 0,1:16:52.14,1:16:57.72,English,,0,0,0,,And so what this does the -Wl flag to GCC says hey
Dialogue: 0,1:16:52.14,1:16:57.72,Chinese,,0,0,0,,那么 GCC 的 -Wl 标志是什么呢
Dialogue: 0,1:16:58.34,1:17:05.00,English,,0,0,0,,Take what follows the argument that follows replace all the commas with spaces
Dialogue: 0,1:16:58.34,1:17:05.00,Chinese,,0,0,0,,接下来的参数后面用逗号替换所有空格
Dialogue: 0,1:17:05.00,1:17:07.50,English,,0,0,0,,And then invoke the linker with this argument
Dialogue: 0,1:17:05.00,1:17:07.50,Chinese,,0,0,0,,然后使用此参数调用链接器
Dialogue: 0,1:17:07.72,1:17:11.40,English,,0,0,0,,Okay so what we're doing is passing a linker arguments to the linker
Dialogue: 0,1:17:07.72,1:17:11.40,Chinese,,0,0,0,,好的，我们正在做的是将链接器参数传递给链接器
Dialogue: 0,1:17:12.28,1:17:15.54,English,,0,0,0,,And this --wrap argument to the linker
Dialogue: 0,1:17:12.28,1:17:15.54,Chinese,,0,0,0,,这是链接器的 --wrap 参数
Dialogue: 0,1:17:16.44,1:17:23.76,English,,0,0,0,,It tells the linker to resolve all references to malloc as __wrap_malloc
Dialogue: 0,1:17:16.44,1:17:23.76,Chinese,,0,0,0,,它告诉链接器将对 malloc 的所有引用解析为 __wrap_malloc
Dialogue: 0,1:17:24.80,1:17:30.86,English,,0,0,0,,And all references to __real_malloc - should be resolved as malloc
Dialogue: 0,1:17:24.80,1:17:30.86,Chinese,,0,0,0,,并且对 __real_malloc 的所有引用  - 应该被解析为 malloc
Dialogue: 0,1:17:32.68,1:17:37.74,English,,0,0,0,,Okay so anywhere in the program what we call malloc it'll be resolved to underscore __wrap_malloc
Dialogue: 0,1:17:32.68,1:17:37.74,Chinese,,0,0,0,,好的，在我们程序中的任何地方调用 malloc ，它都将被解析为 __wrap_malloc
Dialogue: 0,1:17:38.24,1:17:41.92,English,,0,0,0,,And it will invoke our wrapper and then the wrapper calls __real_malloc
Dialogue: 0,1:17:38.24,1:17:41.92,Chinese,,0,0,0,,它将调用我们的包装器，然后包装器调用 __real_malloc
Dialogue: 0,1:17:42.54,1:17:50.70,English,,0,0,0,,Which by because of this flag resolves to the the actual malloc routine
Dialogue: 0,1:17:42.54,1:17:50.70,Chinese,,0,0,0,,因为这个标志解析了实际的 malloc 例程
Dialogue: 0,1:17:53.16,1:17:55.98,English,,0,0,0,,Now here you can also in the really the really amazing thing
Dialogue: 0,1:17:53.16,1:17:55.98,Chinese,,0,0,0,,真正令人惊讶的是接下来的
Dialogue: 0,1:17:56.02,1:18:01.06,English,,0,0,0,,You can also do this inter positioning it load timer and run time when the program is loaded
Dialogue: 0,1:17:56.02,1:18:01.06,Chinese,,0,0,0,,你也可以在加载程序时进行打桩到加载计时器和运行时间
Dialogue: 0,1:18:01.08,1:18:05.52,English,,0,0,0,,So you don't even need access to the .o files all you need is access to the executable
Dialogue: 0,1:18:01.08,1:18:05.52,Chinese,,0,0,0,,因此，你甚至不需要访问 .o 文件，只需访问可执行文件即可
Dialogue: 0,1:18:06.66,1:18:09.50,English,,0,0,0,,Right and for every program we have access to the executable
Dialogue: 0,1:18:06.66,1:18:09.50,Chinese,,0,0,0,,我们有权访问可执行文件的每个程序
Dialogue: 0,1:18:10.17,1:18:12.40,English,,0,0,0,,So think about that we can take any program
Dialogue: 0,1:18:10.17,1:18:12.40,Chinese,,0,0,0,,所以想想我们可以使用任何程序
Dialogue: 0,1:18:13.08,1:18:17.24,English,,0,0,0,,And we can interpose on its library calls at runtime
Dialogue: 0,1:18:13.08,1:18:17.24,Chinese,,0,0,0,,我们可以在运行时插入其库调用
Dialogue: 0,1:18:18.58,1:18:26.15,English,,0,0,0,,So the way we do this is we write the wrapper function now uses the dlsym call that we saw before
Dialogue: 0,1:18:18.58,1:18:26.15,Chinese,,0,0,0,,所以我们这样做的原因是我们编写包装函数使用了我们之前看到的 dlsym 调用
Dialogue: 0,1:18:27.62,1:18:32.10,English,,0,0,0,,And we call it with this special function the special argument called next
Dialogue: 0,1:18:27.62,1:18:32.10,Chinese,,0,0,0,,我们用这个特殊的函数调用它，这个特殊的参数叫做 next
Dialogue: 0,1:18:33.70,1:18:39.08,English,,0,0,0,,And we silver and what this is saying is get the address of the real malloc
Dialogue: 0,1:18:33.70,1:18:39.08,Chinese,,0,0,0,,我们说的是 real malloc 的地址
Dialogue: 0,1:18:40.26,1:18:47.90,English,,0,0,0,,Okay so and we're going to trick the linker into looking first to implementation of malloc
Dialogue: 0,1:18:40.26,1:18:47.90,Chinese,,0,0,0,,好的，我们将欺骗链接器首先查看 malloc 的实现
Dialogue: 0,1:18:48.60,1:18:55.00,English,,0,0,0,,But here we want the real one,so we're telling it to get to look in the next place,its next place that it would normally look
Dialogue: 0,1:18:48.60,1:18:55.00,Chinese,,0,0,0,,但是在这里我们想要真正的那个，所以我们告诉它要去下一个地方，它通常看起来的下一个地方
Dialogue: 0,1:18:55.78,1:18:59.52,English,,0,0,0,,And fetch the the address of malloc
Dialogue: 0,1:18:55.78,1:18:59.52,Chinese,,0,0,0,,并获取 malloc 的地址
Dialogue: 0,1:18:59.52,1:19:04.02,English,,0,0,0,,So the result is a pointer a function pointer called mallocp
Dialogue: 0,1:18:59.52,1:19:04.02,Chinese,,0,0,0,,所以结果是一个指针叫做 mallocp 的函数指针
Dialogue: 0,1:19:04.64,1:19:09.58,English,,0,0,0,,And then we can just call that function to get to call the libc malloc
Dialogue: 0,1:19:04.64,1:19:09.58,Chinese,,0,0,0,,然后我们可以调用该函数来调用 libc malloc
Dialogue: 0,1:19:09.92,1:19:12.28,English,,0,0,0,,And then print out the the data
Dialogue: 0,1:19:09.92,1:19:12.28,Chinese,,0,0,0,,然后打印出数据
Dialogue: 0,1:19:12.94,1:19:19.50,English,,0,0,0,,Okay we do the same thing for free, we use dlsym in exactly the same way for free
Dialogue: 0,1:19:12.94,1:19:19.50,Chinese,,0,0,0,,好的，我们对 free 做同样的事情，我们以完全相同的方式对 free 使用 dlsym
Dialogue: 0,1:19:20.68,1:19:25.22,English,,0,0,0,,And then the inter positioning now happens when the program is loaded
Dialogue: 0,1:19:20.68,1:19:25.22,Chinese,,0,0,0,,然后，当程序加载时，就会发生打桩
Dialogue: 0,1:19:26.56,1:19:31.92,English,,0,0,0,,So notice we built this our main program now intr for run time inter positioning
Dialogue: 0,1:19:26.56,1:19:31.92,Chinese,,0,0,0,,所以请注意，我们构建了我们的主程序 intr ，用于运行时打桩
Dialogue: 0,1:19:32.82,1:19:40.28,English,,0,0,0,,We built it I'm sorry we created our .so file mymalloc.so using the shared argument
Dialogue: 0,1:19:32.82,1:19:40.28,Chinese,,0,0,0,,我们建立了，很抱歉我们使用共享参数创建了我们的 .so 文件 mymalloc.so
Dialogue: 0,1:19:41.56,1:19:48.24,English,,0,0,0,,And then we compiled int.c into this executable called intr
Dialogue: 0,1:19:41.56,1:19:48.24,Chinese,,0,0,0,,然后我们将 int.c 编译成这个名为 intr 的可执行文件
Dialogue: 0,1:19:48.24,1:19:51.66,English,,0,0,0,,But notice there's no mention of mymalloc.so anywhere
Dialogue: 0,1:19:48.24,1:19:51.66,Chinese,,0,0,0,,但请注意，在任何地方都没有提到 mymalloc
Dialogue: 0,1:19:54.42,1:19:57.76,English,,0,0,0,,And now the inner positioning happens when we actually run the program
Dialogue: 0,1:19:54.42,1:19:57.76,Chinese,,0,0,0,,现在，当我们实际运行程序时，打桩就会发生
Dialogue: 0,1:19:58.68,1:20:13.06,English,,0,0,0,,And we do it,we affect the the inner positioning by setting an environment variable called ld-preload to mymalloc.so
Dialogue: 0,1:19:58.68,1:20:13.06,Chinese,,0,0,0,,我们这样做，我们通过将一个名为 ld-preload 的环境变量设置为 mymalloc.so 来影响打桩
Dialogue: 0,1:20:13.42,1:20:17.82,English,,0,0,0,,And so what this is a environment variable that tells the dynamic linker
Dialogue: 0,1:20:13.42,1:20:17.82,Chinese,,0,0,0,,这是一个告诉动态链接器的环境变量
Dialogue: 0,1:20:18.60,1:20:26.20,English,,0,0,0,,To look first in the value, it looked first in the the value of ld-preload is a list of locations
Dialogue: 0,1:20:18.60,1:20:26.20,Chinese,,0,0,0,,首先会搜索值， ld-preload 的值是一个位置列表
Dialogue: 0,1:20:26.62,1:20:29.64,English,,0,0,0,,Look first in those locations when to resolve references
Dialogue: 0,1:20:26.62,1:20:29.64,Chinese,,0,0,0,,首先查看这些位置何时解析引用
Dialogue: 0,1:20:29.98,1:20:33.90,English,,0,0,0,,And only later look in the normal system places
Dialogue: 0,1:20:29.98,1:20:33.90,Chinese,,0,0,0,,只有在以后查看正常系统的地方
Dialogue: 0,1:20:34.86,1:20:38.95,English,,0,0,0,,So we're saying to look in mymalloc.so unresolved references first
Dialogue: 0,1:20:34.86,1:20:38.95,Chinese,,0,0,0,,所以我们首先要查看 mymalloc.so 里未解析的引用
Dialogue: 0,1:20:39.46,1:20:44.44,English,,0,0,0,,And then we're invoking,so this is in bash this is how you initialize an environment variable
Dialogue: 0,1:20:39.46,1:20:44.44,Chinese,,0,0,0,,然后我们正在调用，所以这是在 bash 中这是初始化环境变量的方式
Dialogue: 0,1:20:44.68,1:20:50.54,English,,0,0,0,,So we're initializing it to mymalloc.so and then we're loading and running the program
Dialogue: 0,1:20:44.68,1:20:50.54,Chinese,,0,0,0,,所以我们将它初始化为 mymalloc.so 然后我们将加载并运行该程序
Dialogue: 0,1:20:51.86,1:21:00.08,English,,0,0,0,,And so the ld so all the references to malloc get turned into the references to the wrapper function
Dialogue: 0,1:20:51.86,1:21:00.08,Chinese,,0,0,0,,所以对 malloc 的所有引用都变成了对包装函数的引用
Dialogue: 0,1:21:01.34,1:21:05.34,English,,0,0,0,,The malloc function that we defined in our program okay
Dialogue: 0,1:21:01.34,1:21:05.34,Chinese,,0,0,0,,我们在程序中定义的 malloc 函数没问题
Dialogue: 0,1:21:07.74,1:21:12.46,English,,0,0,0,,Ok so that's it so that that inter positioning is a really cool technique
Dialogue: 0,1:21:07.74,1:21:12.46,Chinese,,0,0,0,,好的就是这样，这样的定位是一种非常酷的技术
Dialogue: 0,1:21:12.60,1:21:15.86,English,,0,0,0,,And it's only possible because of linkers so
Dialogue: 0,1:21:12.60,1:21:15.86,Chinese,,0,0,0,,而且只有因为链接器才有可能
Dialogue: 0,1:21:17.46,1:21:23.86,English,,0,0,0,,alright so good we'll see you on on Thursday and good luck with your cache labs
Dialogue: 0,1:21:17.46,1:21:23.86,Chinese,,0,0,0,,好的，我们星期四见，祝你的 cache lab 好运
