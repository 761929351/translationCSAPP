[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 11  The Memory Hierarchy.mp4
Video File: ../../../../Desktop/csapp/Lecture 11  The Memory Hierarchy.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.070312
Scroll Position: 189
Active Line: 193
Video Position: 32944

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.08,English,,0,0,0,,All right good afternoon everybody
Dialogue: 0,0:00:03.26,0:00:04.76,English,,0,0,0,,Welcome!good to see you
Dialogue: 0,0:00:05.88,0:00:07.98,English,,0,0,0,,Hope you all have started your attack labs
Dialogue: 0,0:00:09.30,0:00:14.06,English,,0,0,0,,Everybody started? be a good time to start I think
Dialogue: 0,0:00:15.52,0:00:20.06,English,,0,0,0,,Anyway I hope you're enjoying it, that's a that's a new one this semester that's
Dialogue: 0,0:00:20.60,0:00:24.24,English,,0,0,0,,I think really interesting and modern and current
Dialogue: 0,0:00:26.36,0:00:28.34,English,,0,0,0,,Okay today we're going to...
Dialogue: 0,0:00:29.64,0:00:32.18,English,,0,0,0,,Today we're going to talk about something called the memory hierarchy
Dialogue: 0,0:00:32.84,0:00:36.92,English,,0,0,0,,Now so far in the class we've thought of memory
Dialogue: 0,0:00:37.00,0:00:39.48,English,,0,0,0,,When we're looking at our assembly language programs
Dialogue: 0,0:00:39.48,0:00:42.10,English,,0,0,0,,We've thought of memory as an array of bytes
Dialogue: 0,0:00:42.40,0:00:48.28,English,,0,0,0,,It's the big array of bytes that we can access with that an index called an address
Dialogue: 0,0:00:50.88,0:00:56.36,English,,0,0,0,,But in actuality the memory system is a very complex hierarchy of devices
Dialogue: 0,0:00:57.04,0:01:00.68,English,,0,0,0,,That provides this abstraction of this this large linear array
Dialogue: 0,0:01:00.98,0:01:04.70,English,,0,0,0,,And so today we're going to look at how memory hierarchies are built
Dialogue: 0,0:01:05.40,0:01:08.86,English,,0,0,0,,And why they're built the way they are
Dialogue: 0,0:01:09.20,0:01:17.98,English,,0,0,0,,And what we'll see is that this sort of beautiful confluence of the properties of storage devices
Dialogue: 0,0:01:18.64,0:01:24.38,English,,0,0,0,,And the properties of programs come together to create this...
Dialogue: 0,0:01:24.72,0:01:27.26,English,,0,0,0,,This beautiful design called a memory hierarchy
Dialogue: 0,0:01:28.48,0:01:33.98,English,,0,0,0,,So we're going to quickly kind of do a high-level tour of storage technologies and trends
Dialogue: 0,0:01:34.48,0:01:36.22,English,,0,0,0,,We're not going to go into a whole lot of detail
Dialogue: 0,0:01:37.44,0:01:44.04,English,,0,0,0,,The point in looking at these at these the properties of these technologies is that
Dialogue: 0,0:01:44.38,0:01:47.88,English,,0,0,0,,There are some fundamental properties that determine their performance and their speed
Dialogue: 0,0:01:48.25,0:01:51.48,English,,0,0,0,,And determine limits on their performance and speed
Dialogue: 0,0:01:51.92,0:01:58.74,English,,0,0,0,,And so I want you to have a,you know, just some high-level idea of what those what those properties are
Dialogue: 0,0:01:59.72,0:02:03.62,English,,0,0,0,,And then we'll look at a property of programs called locality of reference
Dialogue: 0,0:02:04.22,0:02:09.68,English,,0,0,0,,And we'll see how that locality and the properties of storage devices
Dialogue: 0,0:02:09.68,0:02:15.06,English,,0,0,0,,Come together to suggest this design of memory systems as a hierarchy
Dialogue: 0,0:02:17.00,0:02:18.46,English,,0,0,0,,Okay so we'll look at memories first
Dialogue: 0,0:02:18.46,0:02:23.06,English,,0,0,0,,Now the the workhorse memory is called a random access memory or RAM
Dialogue: 0,0:02:23.54,0:02:26.34,English,,0,0,0,,I'm sure it's traditionally packaged up as a chip
Dialogue: 0,0:02:26.62,0:02:30.66,English,,0,0,0,,And then you put multiple chips together to form your main memory
Dialogue: 0,0:02:31.14,0:02:35.96,English,,0,0,0,,And there's a basic storage unit called a cell which where each cell stores one bit
Dialogue: 0,0:02:36.94,0:02:41.54,English,,0,0,0,,Okay now there's a RAM comes in two varieties
Dialogue: 0,0:02:41.54,0:02:46.86,English,,0,0,0,,There's a DRAM and DRAM and they're distinguished by the way that those cells are implemented
Dialogue: 0,0:02:48.40,0:02:48.78,English,,0,0,0,,So in
Dialogue: 0,0:02:50.14,0:03:04.08,English,,0,0,0,,and SRAM requires it's more complex than DRAM it requires like 4,6 transistors per bit whereas DRAM only requires a one transistor
Dialogue: 0,0:03:04.78,0:03:11.20,English,,0,0,0,,Okay so you'll see that SRAM are going to be more expensive lots more expensive
Dialogue: 0,0:03:11.48,0:03:15.08,English,,0,0,0,,Because they're more complex each cell is more complex
Dialogue: 0,0:03:15.34,0:03:21.28,English,,0,0,0,,But they're also much faster like ten order magnitude faster than DRAMs
Dialogue: 0,0:03:21.90,0:03:24.84,English,,0,0,0,,And they have there's some other properties too like
Dialogue: 0,0:03:25.52,0:03:28.88,English,,0,0,0,,SRAM constantly,a DRAM constantly needs to be refreshed
Dialogue: 0,0:03:28.88,0:03:34.26,English,,0,0,0,,If you don't hit it with a voltage
Dialogue: 0,0:03:34.26,0:03:39.12,English,,0,0,0,,It loses the charge whereas DRAM while it needs to be plugged in
Dialogue: 0,0:03:39.74,0:03:42.90,English,,0,0,0,,And and have an electric charge it doesn't need to be refreshed
Dialogue: 0,0:03:43.44,0:03:47.22,English,,0,0,0,,SRAM is a lot more reliable than DRAM so it
Dialogue: 0,0:03:47.70,0:03:49.92,English,,0,0,0,,There's less need for error detection and correction
Dialogue: 0,0:03:50.66,0:03:59.98,English,,0,0,0,,And there and so because of this difference right the SRAMs are costlier smaller and faster than DRAMs
Dialogue: 0,0:04:01.48,0:04:08.78,English,,0,0,0,,We find SRAMs being used in these small fast memories on chip called cache memories
Dialogue: 0,0:04:09.30,0:04:12.70,English,,0,0,0,,And we're going to learn all about those on Thursday
Dialogue: 0,0:04:14.04,0:04:24.06,English,,0,0,0,,And then DRAM is the workhorse used in main memories and the frame buffers associated with graphics cards
Dialogue: 0,0:04:25.24,0:04:33.52,English,,0,0,0,,Now DRAM and SRAM are volatile in the sense that if they're powered off they lose all the information right so this is why
Dialogue: 0,0:04:33.68,0:04:37.72,English,,0,0,0,,When you turn your computer off you have to you lose everything in your memory
Dialogue: 0,0:04:37.72,0:04:43.34,English,,0,0,0,,And you have to when you turn it back on you have to sort of reload everything from your disk
Dialogue: 0,0:04:44.08,0:04:50.30,English,,0,0,0,,There's a different another kind of memory called a nonvolatile memory which retains its information when it's powered off
Dialogue: 0,0:04:50.90,0:04:57.02,English,,0,0,0,,And there's a whole bunch of these things that so called up read-only memory
Dialogue: 0,0:04:57.02,0:05:02.08,English,,0,0,0,,So the generic name for these nonvolatile memories is read only memories ROM
Dialogue: 0,0:05:02.08,0:05:10.98,English,,0,0,0,,And there's a whole bunch of different kinds sort of going back in time the original read only memories were ROMs
Dialogue: 0,0:05:10.98,0:05:14.10,English,,0,0,0,,And they can only be programmed once when the chip was produced
Dialogue: 0,0:05:14.60,0:05:17.82,English,,0,0,0,,And then over time gradually over period of like 20 or 30 years
Dialogue: 0,0:05:18.26,0:05:23.04,English,,0,0,0,,There were improvements in the way that ROMs could be programmed and in how they were erased
Dialogue: 0,0:05:23.30,0:05:24.88,English,,0,0,0,,So they could be reprogrammed
Dialogue: 0,0:05:25.78,0:05:31.04,English,,0,0,0,,The what we have today the the modern form of read only memories is called flash memory
Dialogue: 0,0:05:32.78,0:05:41.34,English,,0,0,0,,Which provides the capability of erasing you can erase just chunks of the the flash memory called blocks
Dialogue: 0,0:05:43.12,0:05:49.16,English,,0,0,0,,And then the downside is that these things wear out after about a hundred thousand erasers
Dialogue: 0,0:05:49.50,0:05:57.44,English,,0,0,0,,Okay so you can erase and reprogram a hundred thousand times and then it's your bricked
Dialogue: 0,0:05:58.76,0:06:04.36,English,,0,0,0,,Now that these nonvolatile memories are show up in with
Dialogue: 0,0:06:04.36,0:06:06.76,English,,0,0,0,,So called firmware which is software
Dialogue: 0,0:06:07.48,0:06:09.78,English,,0,0,0,,That's that's programmed into a ROM
Dialogue: 0,0:06:10.34,0:06:14.22,English,,0,0,0,,And you see those in the BIOS of computers so when you power on your computer
Dialogue: 0,0:06:15.18,0:06:19.14,English,,0,0,0,,The very first instructions that execute are stored in a ROM right
Dialogue: 0,0:06:19.14,0:06:22.80,English,,0,0,0,,If you're wondered like where do those things come from so they're stored in ROM
Dialogue: 0,0:06:23.18,0:06:26.76,English,,0,0,0,,And then there's a boot process where gradually more and more information is
Dialogue: 0,0:06:27.50,0:06:30.36,English,,0,0,0,,And instructions are loaded into memory
Dialogue: 0,0:06:32.28,0:06:37.52,English,,0,0,0,,You know IO.IO devices have little computers in them call controllers
Dialogue: 0,0:06:38.19,0:06:41.98,English,,0,0,0,,These controllers consist of instructions and data that are that are stored in ROMs
Dialogue: 0,0:06:43.24,0:06:48.62,English,,0,0,0,,And you see them all over the place in these solid state disks
Dialogue: 0,0:06:49.66,0:06:55.56,English,,0,0,0,,That to the system look like a rotating disk
Dialogue: 0,0:06:55.98,0:06:58.10,English,,0,0,0,,But they're built of flash memories
Dialogue: 0,0:06:59.80,0:07:03.98,English,,0,0,0,,Okay and these are you see these in thumb drives smartphones tablets and laptops
Dialogue: 0,0:07:03.98,0:07:06.70,English,,0,0,0,,And they're even starting to show up in servers now
Dialogue: 0,0:07:14.62,0:07:22.02,English,,0,0,0,,So the memories are connected to the CPU using sort of wires that are collectively called buses
Dialogue: 0,0:07:22.54,0:07:31.06,English,,0,0,0,,Okay so data flows across the wires back and forth from the,we have the CPU chip
Dialogue: 0,0:07:32.68,0:07:38.52,English,,0,0,0,,And it consists of register file these are the general-purpose registers %rax, %rdi and so on
Dialogue: 0,0:07:39.36,0:07:44.82,English,,0,0,0,,And there's an arithmetic logic unit that reads and writes data from the register files
Dialogue: 0,0:07:45.32,0:07:51.44,English,,0,0,0,,And then manipulates that data in some way by doing some kind of arithmetic operation or some logical operation
Dialogue: 0,0:07:52.38,0:07:57.02,English,,0,0,0,,And if instructions need to access memory
Dialogue: 0,0:07:57.20,0:08:04.34,English,,0,0,0,,So if there's you're doing a move,a move instruction that reads or writes to memory
Dialogue: 0,0:08:06.04,0:08:11.44,English,,0,0,0,,Then that's handled by a bus interface which is connected to a what we'll call a system bus
Dialogue: 0,0:08:13.32,0:08:16.74,English,,0,0,0,,And then that's connected to an I/O bridge and this
Dialogue: 0,0:08:17.28,0:08:24.00,English,,0,0,0,,This is another collection of chips,Intel calls this what I'm calling the I/O bridge,they call the chipset 
Dialogue: 0,0:08:24.66,0:08:28.92,English,,0,0,0,,Okay but it's it's a collection of chips separate from the process the CPU chip
Dialogue: 0,0:08:29.80,0:08:34.84,English,,0,0,0,,And then the I/O bridge is connected to another bus called the memory bus which connects the main memory
Dialogue: 0,0:08:36.42,0:08:41.68,English,,0,0,0,,Okay now this is kind of an abstraction I don't want you to take this too literally
Dialogue: 0,0:08:41.68,0:08:45.44,English,,0,0,0,,But it gives you the idea of how information flows in the system
Dialogue: 0,0:08:46.10,0:08:53.22,English,,0,0,0,,Okay modern modern systems use proprietary bus designs and they're very arcane and increasingly complex
Dialogue: 0,0:08:53.72,0:09:00.46,English,,0,0,0,,So we're just going to use a fairly simple abstraction for these bus architectures
Dialogue: 0,0:09:02.22,0:09:07.06,English,,0,0,0,,Now when is,now suppose you do a load operation like movq
Dialogue: 0,0:09:07.26,0:09:11.88,English,,0,0,0,,The eight bytes at address a into %rax
Dialogue: 0,0:09:12.26,0:09:17.16,English,,0,0,0,,Okay so we call that a load because we're loading from the point of view of the CPU
Dialogue: 0,0:09:17.46,0:09:19.90,English,,0,0,0,,We're loading data into the CPU
Dialogue: 0,0:09:20.62,0:09:24.40,English,,0,0,0,,But we're loading and we're loading data from memory into the CPU
Dialogue: 0,0:09:25.74,0:09:30.04,English,,0,0,0,,So when the CPU executes movq instruction like this
Dialogue: 0,0:09:30.76,0:09:33.98,English,,0,0,0,,It first places the address of A on the memory bus
Dialogue: 0,0:09:38.22,0:09:44.82,English,,0,0,0,,And then the main memory census that address and it reads the contents the eight bytes at address A
Dialogue: 0,0:09:45.72,0:09:50.76,English,,0,0,0,,So it retrieves the word 8 byte word from address a and places it back on the bus
Dialogue: 0,0:09:52.70,0:09:58.10,English,,0,0,0,,The those bits travel through the I/O bridge to the bus interface
Dialogue: 0,0:09:59.84,0:10:07.20,English,,0,0,0,,And then the CPU reads the the word x from the data word x from the bus and in composition to register %rax
Dialogue: 0,0:10:07.46,0:10:11.72,English,,0,0,0,,Okay so it's now writing is is similar again
Dialogue: 0,0:10:12.28,0:10:20.08,English,,0,0,0,,So here we're doing a move instruction movq from %rax into address A main memory
Dialogue: 0,0:10:21.16,0:10:25.66,English,,0,0,0,,Okay so the the CPU starts as before by placing the address a on the bus
Dialogue: 0,0:10:27.46,0:10:31.65,English,,0,0,0,,Main memory reads that address and then it waits for the data to arrive on the bus
Dialogue: 0,0:10:31.65,0:10:35.50,English,,0,0,0,,So the CPU then places the contents of %rax on the bus
Dialogue: 0,0:10:36.42,0:10:39.54,English,,0,0,0,,Those contents travel across to main memory
Dialogue: 0,0:10:39.96,0:10:45.08,English,,0,0,0,,Which then reads the reads that word from the bus and stores it at address A
Dialogue: 0,0:10:45.58,0:10:51.06,English,,0,0,0,,Ok so that the point of all this is that operations that occur
Dialogue: 0,0:10:52.48,0:10:54.24,English,,0,0,0,,You know reads and writes of registers
Dialogue: 0,0:10:55.66,0:11:01.90,English,,0,0,0,,Because the register file is very close to the ALU, these happen in on the order of a few cycles
Dialogue: 0,0:11:02.70,0:11:06.38,English,,0,0,0,,Ok register,the register very close to the ALU
Dialogue: 0,0:11:06.74,0:11:10.28,English,,0,0,0,,So those operations are very happened very quickly
Dialogue: 0,0:11:11.32,0:11:19.40,English,,0,0,0,,Whereas memories actually this is a set of chips that are very far away relatively speaking from the CPU
Dialogue: 0,0:11:20.90,0:11:24.68,English,,0,0,0,,And there's a lot going on in when if you have to read or write memory there's
Dialogue: 0,0:11:25.10,0:11:32.22,English,,0,0,0,,It you have to do multiple operations on the bus,data has to travel propagate across that bus all this stuff takes time
Dialogue: 0,0:11:32.82,0:11:36.28,English,,0,0,0,,So memory operations reads and writes are typically
Dialogue: 0,0:11:36.64,0:11:45.78,English,,0,0,0,,You know maybe 50 nanoseconds 100 nanoseconds whereas operations that occur between registers are sub nanosecond
Dialogue: 0,0:11:47.84,0:11:52.78,English,,0,0,0,,On the order of so you're talking about a one to two orders of magnitude difference
Dialogue: 0,0:11:53.86,0:11:56.94,English,,0,0,0,,If you have to go off chip to to retrieve something from memory
Dialogue: 0,0:11:56.94,0:12:03.24,English,,0,0,0,,Ok so that's the first sort of big takeaway item about memory systems
Dialogue: 0,0:12:04.46,0:12:08.16,English,,0,0,0,,Now in other popular storage technology is rotating disks
Dialogue: 0,0:12:09.14,0:12:14.08,English,,0,0,0,,And I don't know if you've ever torn one apart they're kind of interesting there's a series of platters
Dialogue: 0,0:12:15.08,0:12:18.18,English,,0,0,0,,Each platter is coated with a magnetic material
Dialogue: 0,0:12:19.14,0:12:25.30,English,,0,0,0,,And then and then bits ones and zeros are encoded in that magnetic material
Dialogue: 0,0:12:26.04,0:12:31.79,English,,0,0,0,,And then there's this arm that can it's it's hinged right here
Dialogue: 0,0:12:32.38,0:12:38.50,English,,0,0,0,,And then it can it floats over the platter so it floats on a thin layer of air over the platter
Dialogue: 0,0:12:38.50,0:12:45.26,English,,0,0,0,,And there's a read/write head at the very end that can sense the changes in the magnetic field that encode the bits
Dialogue: 0,0:12:45.74,0:12:52.62,English,,0,0,0,,Okay so these platters are spinning around like counterclockwise like this, this arm can go back and forth 
Dialogue: 0,0:12:53.32,0:12:56.82,English,,0,0,0,,So there's a lot of mechanical gear so this is all mechanical
Dialogue: 0,0:12:57.46,0:13:00.34,English,,0,0,0,,So the mechanical nature of a rotating disc
Dialogue: 0,0:13:00.82,0:13:05.42,English,,0,0,0,,Means it's going to be slower right then DRAMs and SRAMs 
Dialogue: 0,0:13:06.30,0:13:10.66,English,,0,0,0,,And there's also electronics like it's like a little computer in firmware
Dialogue: 0,0:13:11.08,0:13:18.80,English,,0,0,0,,That that actually controls the operation of this drive that controls how this arm goes back and forth
Dialogue: 0,0:13:20.06,0:13:24.82,English,,0,0,0,,And and and controls how the data is read off of the the read/write head
Dialogue: 0,0:13:25.76,0:13:32.02,English,,0,0,0,,So just in a little more detail we can think of these disks consists of platters
Dialogue: 0,0:13:32.02,0:13:34.82,English,,0,0,0,,Each platter has two surfaces the top and a bottom
Dialogue: 0,0:13:35.98,0:13:41.70,English,,0,0,0,,And then each surface consists of these trees are concentric rings  called tracks
Dialogue: 0,0:13:43.28,0:13:49.94,English,,0,0,0,,And then each track consists of us it consists of sectors which contain the data
Dialogue: 0,0:13:50.70,0:13:58.98,English,,0,0,0,,So typically 512,512 bits, oh I'm sorry bytes 
Dialogue: 0,0:14:01.06,0:14:04.26,English,,0,0,0,,And then except these tracks are separated by gaps
Dialogue: 0,0:14:04.96,0:14:09.00,English,,0,0,0,,That goat that these gaps like right here that don't contain data
Dialogue: 0,0:14:12.72,0:14:17.40,English,,0,0,0,,Now platters are aligned on top of each other on the spindle
Dialogue: 0,0:14:18.08,0:14:21.64,English,,0,0,0,,And so tracks that are aligned on the different surfaces
Dialogue: 0,0:14:22.20,0:14:26.38,English,,0,0,0,,Such as this track here on those the collection of those
Dialogue: 0,0:14:26.88,0:14:31.30,English,,0,0,0,,Tracks form what we call a cylinder okay because it has a cylindrical shape
Dialogue: 0,0:14:33.08,0:14:37.86,English,,0,0,0,,Now the capacity of disks is that the number of bits that can be stored 
Dialogue: 0,0:14:39.94,0:14:46.23,English,,0,0,0,,And vendors kind of they all dis vendors use they quote the capacity in gigabytes
Dialogue: 0,0:14:46.23,0:14:57.00,English,,0,0,0,,But where a gigabyte is 10^9 bytes right instead of 2^20,okay like like you would expect
Dialogue: 0,0:14:57.92,0:15:00.84,English,,0,0,0,,So what...I'm not sure why they do this
Dialogue: 0,0:15:01.32,0:15:08.28,English,,0,0,0,,But it allows by by quoting their capacity and gigabytes in 10^9 bytes
Dialogue: 0,0:15:08.93,0:15:11.24,English,,0,0,0,,It's a bigger number right
Dialogue: 0,0:15:11.60,0:15:15.40,English,,0,0,0,,So it looks better it looks like there's more information
Dialogue: 0,0:15:15.40,0:15:20.36,English,,0,0,0,,It's a little I don't really know why they do it but I think that's why it is
Dialogue: 0,0:15:21.08,0:15:27.13,English,,0,0,0,,And it's one of those little bit annoying things that we just have to just  know about and get used to
Dialogue: 0,0:15:27.98,0:15:34.80,English,,0,0,0,,Now the capacity is determined by 2 independent technology factors
Dialogue: 0,0:15:35.38,0:15:43.46,English,,0,0,0,,One is the recording density so that's how many bits can you pack into a single sector
Dialogue: 0,0:15:44.64,0:15:50.74,English,,0,0,0,,Or porous or at least a portion of a track
Dialogue: 0,0:15:51.56,0:15:56.78,English,,0,0,0,,And then the track density which is sort of how close can you put those tracks together
Dialogue: 0,0:15:57.64,0:16:02.90,English,,0,0,0,,And then the product of those two is what's called the areal density and that determines the overall capacity of the disc
Dialogue: 0,0:16:03.02,0:16:10.18,English,,0,0,0,,So the higher the areal capacity the more bits you can squeeze on to that onto that surface
Dialogue: 0,0:16:10.90,0:16:17.26,English,,0,0,0,,Now in the old days when aerial densities were fairly low
Dialogue: 0,0:16:18.16,0:16:22.22,English,,0,0,0,,Each each track on the surface would have the same number of sectors
Dialogue: 0,0:16:23.64,0:16:25.96,English,,0,0,0,,Okay so there was a constant number of sectors per track
Dialogue: 0,0:16:26.88,0:16:31.60,English,,0,0,0,,So now what happens as you as your tracks go from the
Dialogue: 0,0:16:32.16,0:16:36.54,English,,0,0,0,,You know near the whole by the spindle as they go as they move outward
Dialogue: 0,0:16:37.56,0:16:43.88,English,,0,0,0,,Right if you have the same number of sectors with the same bit density
Dialogue: 0,0:16:45.08,0:16:49.64,English,,0,0,0,,That the gaps between sectors are going to get bigger and bigger as you go out
Dialogue: 0,0:16:49.84,0:16:52.86,English,,0,0,0,,And you're going to be wasting more and more of your space
Dialogue: 0,0:16:53.32,0:16:57.50,English,,0,0,0,,So at when aerial densities were fairly low this was okay
Dialogue: 0,0:16:57.98,0:17:01.44,English,,0,0,0,,But after a while it just became not okay to waste that much room
Dialogue: 0,0:17:01.92,0:17:05.76,English,,0,0,0,,So what modern systems do is they partition the tracks into these
Dialogue: 0,0:17:06.16,0:17:08.06,English,,0,0,0,,So called rook recording zones
Dialogue: 0,0:17:08.54,0:17:12.82,English,,0,0,0,,Where each recording zone such as this right here
Dialogue: 0,0:17:13.18,0:17:17.64,English,,0,0,0,,Each recording zone has a consonant number of sectors
Dialogue: 0,0:17:18.24,0:17:22.04,English,,0,0,0,,So each track in a recording zone has the same number of sectors
Dialogue: 0,0:17:22.86,0:17:27.92,English,,0,0,0,,And of course as you move outward if you move outward in the recording zone
Dialogue: 0,0:17:28.68,0:17:30.60,English,,0,0,0,,You're going to have bigger and bigger gaps
Dialogue: 0,0:17:30.72,0:17:33.72,English,,0,0,0,,But then you start a new recording zone
Dialogue: 0,0:17:34.12,0:17:39.52,English,,0,0,0,,That will have more sectors per track and then within that
Dialogue: 0,0:17:40.32,0:17:46.08,English,,0,0,0,,So you can see in this outer in this outer zone you have more you have more sectors
Dialogue: 0,0:17:46.56,0:17:48.18,English,,0,0,0,,Than you do on this inner zone
Dialogue: 0,0:17:49.18,0:17:56.66,English,,0,0,0,,Okay so that's a way to kind of deal with that sort of that growth in the gaps to keep it from getting too large
Dialogue: 0,0:17:57.42,0:18:03.90,English,,0,0,0,,And so because we don't really have the number of sectors per track isn't constant
Dialogue: 0,0:18:03.90,0:18:07.22,English,,0,0,0,,We'll use an Average the average sectors per track across 
Dialogue: 0,0:18:07.78,0:18:11.58,English,,0,0,0,,All recording zones when we do serve our capacity estimates
Dialogue: 0,0:18:13.38,0:18:18.32,English,,0,0,0,,Okay so you can imagine the formula for computing the disk capacity is fairly straightforward
Dialogue: 0,0:18:18.70,0:18:21.28,English,,0,0,0,,It's the number of bytes per sector
Dialogue: 0,0:18:22.50,0:18:24.90,English,,0,0,0,,Times the average number of sectors per track
Dialogue: 0,0:18:26.10,0:18:30.08,English,,0,0,0,,Times the average number of tracks per surface times the number of surfaces per platter
Dialogue: 0,0:18:30.66,0:18:32.80,English,,0,0,0,,Times the number of platters per disk okay
Dialogue: 0,0:18:35.78,0:18:37.58,English,,0,0,0,,Now let's look at how just work
Dialogue: 0,0:18:39.04,0:18:42.78,English,,0,0,0,,So these these surfaces are spinning at a fixed rotational rate
Dialogue: 0,0:18:42.78,0:18:49.92,English,,0,0,0,,Now a typical rate may be 7200 rpm s is a fairly common rotational rate
Dialogue: 0,0:18:51.06,0:18:59.25,English,,0,0,0,,So the disc is spinning around you can see this pretty proud of that
Dialogue: 0,0:19:00.08,0:19:04.04,English,,0,0,0,,So it's spinning around counter clockwise and then the arm
Dialogue: 0,0:19:05.52,0:19:10.60,English,,0,0,0,,Moves radially here we go
Dialogue: 0,0:19:10.68,0:19:14.22,English,,0,0,0,,The arm moves radially and it can go over any of the tracks
Dialogue: 0,0:19:16.72,0:19:17.84,English,,0,0,0,,Okay all right that's enough
Dialogue: 0,0:19:20.58,0:19:24.20,English,,0,0,0,,Okay now when you have multiple platters
Dialogue: 0,0:19:24.90,0:19:32.14,English,,0,0,0,,Each one of these each one of these there's actually multiple arms and there's a read/write head on each surface
Dialogue: 0,0:19:32.14,0:19:38.70,English,,0,0,0,,So if the platters has to - if - if each side of the platter
Dialogue: 0,0:19:39.24,0:19:42.84,English,,0,0,0,,Is coated with this magnetic material then
Dialogue: 0,0:19:42.84,0:19:45.86,English,,0,0,0,,You'll have you have a read/write head on each side
Dialogue: 0,0:19:46.32,0:19:48.70,English,,0,0,0,,And then these are all connected they kind of move together
Dialogue: 0,0:19:49.12,0:19:53.84,English,,0,0,0,,Now originally these these read/write heads would be they were rigid
Dialogue: 0,0:19:54.76,0:19:57.34,English,,0,0,0,,Right because the densities tracked densities weren't that high
Dialogue: 0,0:19:58.04,0:20:03.18,English,,0,0,0,,So they could they could just sort of licks and even though the tracks didn't align perfectly
Dialogue: 0,0:20:03.48,0:20:07.80,English,,0,0,0,,They could just sort of they could they could still cover
Dialogue: 0,0:20:07.90,0:20:14.40,English,,0,0,0,,The read/write heads could still cover the tracks with these fixed  with these fixed arms
Dialogue: 0,0:20:14.40,0:20:17.84,English,,0,0,0,,But nowadays that the densities are so high
Dialogue: 0,0:20:18.06,0:20:22.54,English,,0,0,0,,That they actually the controller can actually move the read/write heads a little bit
Dialogue: 0,0:20:22.66,0:20:27.24,English,,0,0,0,,So that it matches up with that all of the tracks on all of the surfaces
Dialogue: 0,0:20:30.52,0:20:34.24,English,,0,0,0,,Okay so let's look at how this works how we read data
Dialogue: 0,0:20:36.18,0:20:37.34,English,,0,0,0,,So we have our
Dialogue: 0,0:20:38.98,0:20:42.96,English,,0,0,0,,This is our this is our arm and the tip of the arrow is the read/write head
Dialogue: 0,0:20:43.38,0:20:48.44,English,,0,0,0,,And it's positioned and the platter is rotating counterclockwise
Dialogue: 0,0:20:49.30,0:20:52.48,English,,0,0,0,,And it's positioned just ready to read the blue sector
Dialogue: 0,0:20:53.50,0:20:57.18,English,,0,0,0,,So it as the blue sector spins underneath the read/write head
Dialogue: 0,0:20:57.60,0:21:03.52,English,,0,0,0,,It senses those bits and sends them up to the controller which passes them back up to the  the CPU
Dialogue: 0,0:21:04.26,0:21:07.42,English,,0,0,0,,And now the CPU is requested that the disk
Dialogue: 0,0:21:07.80,0:21:10.58,English,,0,0,0,,It's requested the red data from the red sector
Dialogue: 0,0:21:11.82,0:21:15.14,English,,0,0,0,,So we have to take the controller takes that read/write head
Dialogue: 0,0:21:15.84,0:21:18.74,English,,0,0,0,,Moves it back to reds track
Dialogue: 0,0:21:19.86,0:21:22.40,English,,0,0,0,,And then waits for it to spin around and
Dialogue: 0,0:21:24.82,0:21:26.70,English,,0,0,0,,And to the to the read/write head
Dialogue: 0,0:21:29.26,0:21:33.26,English,,0,0,0,,And then it reads that that red that red sector
Dialogue: 0,0:21:34.70,0:21:38.82,English,,0,0,0,,Okay so when we first so there's really three components going on here that determine
Dialogue: 0,0:21:38.82,0:21:41.12,English,,0,0,0,,How long it takes to read one of these sectors
Dialogue: 0,0:21:43.06,0:21:46.80,English,,0,0,0,,The when we move the head that's called a seek
Dialogue: 0,0:21:47.62,0:21:51.98,English,,0,0,0,,When we waited for the red track to sort of rotate around
Dialogue: 0,0:21:51.98,0:21:55.36,English,,0,0,0,,That's called the rotational latency so however long it takes
Dialogue: 0,0:21:56.18,0:22:01.12,English,,0,0,0,,On average it will be half of the half of the time
Dialogue: 0,0:22:01.88,0:22:05.28,English,,0,0,0,,It takes for the entire to circle all the way around
Dialogue: 0,0:22:06.08,0:22:08.44,English,,0,0,0,,And then there's the data transfer which is
Dialogue: 0,0:22:08.96,0:22:10.46,English,,0,0,0,,Sort of how long it takes for that
Dialogue: 0,0:22:11.10,0:22:13.38,English,,0,0,0,,For that track to pass under the read/write head
Dialogue: 0,0:22:15.90,0:22:18.46,English,,0,0,0,,Now the reason the reason it's important to know this is that
Dialogue: 0,0:22:19.20,0:22:23.48,English,,0,0,0,,These three components you add them together and that's the that's what your average
Dialogue: 0,0:22:23.62,0:22:25.70,English,,0,0,0,,X time it takes to access data
Dialogue: 0,0:22:27.04,0:22:30.22,English,,0,0,0,,That time is dominated by the seek time
Dialogue: 0,0:22:30.54,0:22:34.42,English,,0,0,0,,So seek times are measured in milliseconds right so we're moving this head there's
Dialogue: 0,0:22:35.14,0:22:40.34,English,,0,0,0,,This there's a servo that has to fire up and there's actual mechanical motion
Dialogue: 0,0:22:40.36,0:22:42.82,English,,0,0,0,,And that that takes time
Dialogue: 0,0:22:43.34,0:22:50.64,English,,0,0,0,,And it's on the order of three to nine milliseconds and this has been true for decades
Dialogue: 0,0:22:50.86,0:22:53.84,English,,0,0,0,,Right so this this value is not changing right
Dialogue: 0,0:22:53.84,0:22:56.66,English,,0,0,0,,There's just sort of fundamental mechanical limits
Dialogue: 0,0:22:57.36,0:23:03.64,English,,0,0,0,,That make it very difficult to to decrease this this value
Dialogue: 0,0:23:04.40,0:23:05.82,English,,0,0,0,,Now the rotational latency
Dialogue: 0,0:23:08.82,0:23:16.38,English,,0,0,0,,The time that it takes to spin around will we'll call that the t average rotation
Dialogue: 0,0:23:16.38,0:23:20.16,English,,0,0,0,,And then the time it takes to read the the bits will call t average transfer
Dialogue: 0,0:23:20.16,0:23:27.42,English,,0,0,0,,Okay so we have t average seek which is this seek time rotational latency and transfer time
Dialogue: 0,0:23:30.10,0:23:34.50,English,,0,0,0,,And now if we just take some typical numbers   and plug those in
Dialogue: 0,0:23:35.60,0:23:39.32,English,,0,0,0,,You see that our seek time is on the order of milliseconds
Dialogue: 0,0:23:39.96,0:23:42.78,English,,0,0,0,,The rotational rate is also on the order of milliseconds right
Dialogue: 0,0:23:42.78,0:23:47.26,English,,0,0,0,,So there's there's also mechanical limits and how fast you can you can spin these around
Dialogue: 0,0:23:48.12,0:23:53.84,English,,0,0,0,,The access time and the transfer time  is very small
Dialogue: 0,0:23:53.92,0:24:00.62,English,,0,0,0,,So it's orders of magnitude smaller because you just have to read a few that the bits that are in one sector
Dialogue: 0,0:24:02.30,0:24:10.14,English,,0,0,0,,Okay so if you look you can see that the total access time is dominated by seek  and rotational latency
Dialogue: 0,0:24:10.78,0:24:15.56,English,,0,0,0,,So you know a good rule of thumb just for sort of estimating how long it takes to read from a disk
Dialogue: 0,0:24:15.56,0:24:19.40,English,,0,0,0,,It is just take twice the seek the seek time and you'll be pretty close
Dialogue: 0,0:24:20.20,0:24:24.60,English,,0,0,0,,And basically the transfer time is you get that for free
Dialogue: 0,0:24:26.66,0:24:29.26,English,,0,0,0,,Now here's the here's the important thing to know about disks
Dialogue: 0,0:24:30.70,0:24:36.20,English,,0,0,0,,We SRAM access times about four nanoseconds to get a double word
Dialogue: 0,0:24:36.62,0:24:40.24,English,,0,0,0,,Dram is about 60 nanoseconds
Dialogue: 0,0:24:40.24,0:24:45.42,English,,0,0,0,,So DRAM is about an order of magnitude slower than SRAM
Dialogue: 0,0:24:47.18,0:24:50.70,English,,0,0,0,,But disk is 40,000 times slower than SRAM
Dialogue: 0,0:24:51.32,0:24:54.06,English,,0,0,0,,So that's 4,000 orders of magnitude difference
Dialogue: 0,0:24:54.94,0:25:01.42,English,,0,0,0,,That's huge and it's it's 250 times orders of magnitude slower than DRAMs
Dialogue: 0,0:25:02.82,0:25:07.30,English,,0,0,0,,So the there's a big gap between DRAM and SRAM
Dialogue: 0,0:25:07.30,0:25:15.16,English,,0,0,0,,And there's an even bigger gap between disk and other memory types
Dialogue: 0,0:25:17.12,0:25:20.08,English,,0,0,0,,Now modern disks present a much simpler view
Dialogue: 0,0:25:20.48,0:25:29.08,English,,0,0,0,,Than so we then this track cylinder sector geometry
Dialogue: 0,0:25:29.72,0:25:32.67,English,,0,0,0,,So modern modern disk controllers actually present
Dialogue: 0,0:25:33.22,0:25:36.80,English,,0,0,0,,To the CPU they present the disk as a sequence of logical blocks
Dialogue: 0,0:25:37.82,0:25:40.70,English,,0,0,0,,Where each block is is a multiple of a sector size
Dialogue: 0,0:25:40.70,0:25:45.18,English,,0,0,0,,So this in simplest case a block is just a logical block is one sector
Dialogue: 0,0:25:45.64,0:25:47.64,English,,0,0,0,,And then blocks are numbered starting at zero
Dialogue: 0,0:25:47.64,0:25:50.76,English,,0,0,0,,And they just go all the way up to some to some large number
Dialogue: 0,0:25:53.58,0:25:58.72,English,,0,0,0,,And then the the disk controller keeps the mapping maintains the mapping between logical blocks
Dialogue: 0,0:25:58.88,0:26:00.64,English,,0,0,0,,And the actual physical sectors
Dialogue: 0,0:26:03.44,0:26:10.06,English,,0,0,0,,So as in the old saying is you know most interesting ideas in computer science are involve some form of indirection
Dialogue: 0,0:26:10.28,0:26:12.02,English,,0,0,0,,So this is a level of indirection
Dialogue: 0,0:26:12.50,0:26:16.28,English,,0,0,0,,That provides you know this mapping between logical blocks and physical blocks
Dialogue: 0,0:26:17.04,0:26:21.48,English,,0,0,0,,So it allows disk controllers to take some cylinders and reserve them as spare cylinders
Dialogue: 0,0:26:22.10,0:26:24.04,English,,0,0,0,,That aren't mapped in illogical blocks
Dialogue: 0,0:26:24.90,0:26:29.54,English,,0,0,0,,And then if there's if one of the sectors goes bad in a cylinder
Dialogue: 0,0:26:29.96,0:26:38.22,English,,0,0,0,,That the disk controller can just copy the data over to a spare cylinder and then just keep going right
Dialogue: 0,0:26:38.22,0:26:46.18,English,,0,0,0,,So this is why your 4matic capacity is less than sort of the if you know if you counted the number of actual cylinders on the disk
Dialogue: 0,0:26:46.50,0:26:49.52,English,,0,0,0,,Your 4matic capacity is less than the maximum capacity
Dialogue: 0,0:26:49.72,0:26:53.62,English,,0,0,0,,Because some of those cylinders are being reserved for failures
Dialogue: 0,0:26:57.80,0:27:04.18,English,,0,0,0,,Now devices like disks are connected to the to the CPU and the memory
Dialogue: 0,0:27:05.54,0:27:09.82,English,,0,0,0,,Via the I/O bridge over another kind of bus called an I/O bus
Dialogue: 0,0:27:11.46,0:27:19.50,English,,0,0,0,,This what I'm showing you now is actually not representative of modern systems
Dialogue: 0,0:27:19.50,0:27:23.82,English,,0,0,0,,It's representative of what was called the pci bus about five years ago
Dialogue: 0,0:27:24.26,0:27:31.36,English,,0,0,0,,Modern buses now are the pci bus is a broadcast bus meaning it's just a single set of wires
Dialogue: 0,0:27:32.12,0:27:36.78,English,,0,0,0,,So if any device us changes the values on those wires
Dialogue: 0,0:27:37.08,0:27:39.84,English,,0,0,0,,Every device on that bus can see those values
Dialogue: 0,0:27:41.48,0:27:46.26,English,,0,0,0,,Okay that's called a broadcast bus and it's a simplest kind of way to hook things together
Dialogue: 0,0:27:47.84,0:27:51.76,English,,0,0,0,,Modern systems use a bus structure called pci express
Dialogue: 0,0:27:52.32,0:27:56.18,English,,0,0,0,,Which although it has the word pci and it's completely different it's point-to-point
Dialogue: 0,0:27:56.30,0:28:00.08,English,,0,0,0,,So devices are connected by a set of point-to-point connections
Dialogue: 0,0:28:00.32,0:28:04.30,English,,0,0,0,,Arbitrated by a-- by some kind of a switch
Dialogue: 0,0:28:04.80,0:28:09.84,English,,0,0,0,,And we won't go into it it's the same idea it it's a much more efficient design
Dialogue: 0,0:28:10.30,0:28:16.86,English,,0,0,0,,It's much faster and but it provides the same capability mainly it just attaches up
Dialogue: 0,0:28:17.42,0:28:21.32,English,,0,0,0,,It allows you to attach all of your devices to your to your CPU
Dialogue: 0,0:28:22.26,0:28:25.72,English,,0,0,0,,So just think of this bus as this sort of a single set of wires
Dialogue: 0,0:28:26.44,0:28:28.00,English,,0,0,0,,Where each wire carries a bit
Dialogue: 0,0:28:28.74,0:28:33.30,English,,0,0,0,,And every device attached to it can see all the values of all the wires
Dialogue: 0,0:28:34.32,0:28:41.10,English,,0,0,0,,And so it there's some devices that are just built it directly into the motherboard and they attach to the bus like
Dialogue: 0,0:28:41.52,0:28:46.72,English,,0,0,0,,You know disks have just plugged directly into sockets on a motherboard
Dialogue: 0,0:28:46.94,0:28:50.64,English,,0,0,0,,And you know your graphics adapter and the USB controller
Dialogue: 0,0:28:50.92,0:28:53.06,English,,0,0,0,,And then the system presents an interface
Dialogue: 0,0:28:53.06,0:28:58.76,English,,0,0,0,,So you can plug mouse things like mice and keyboards into the USB controller
Dialogue: 0,0:28:59.24,0:29:03.58,English,,0,0,0,,And then there's expansion slots that allow you that are
Dialogue: 0,0:29:04.24,0:29:07.90,English,,0,0,0,,Connect to the wires in the in the bus that allow you to add other devices right
Dialogue: 0,0:29:08.64,0:29:11.38,English,,0,0,0,,Maybe network you know if you want to put a network adapter there
Dialogue: 0,0:29:14.14,0:29:16.60,English,,0,0,0,,Now what happens when we want to read a disk sector
Dialogue: 0,0:29:17.34,0:29:21.14,English,,0,0,0,,Well the CPU initiates this read by writing a triple
Dialogue: 0,0:29:21.38,0:29:25.22,English,,0,0,0,,So it writes three different values it writes a command like say read
Dialogue: 0,0:29:26.04,0:29:27.94,English,,0,0,0,,It writes a logical block number
Dialogue: 0,0:29:28.24,0:29:30.32,English,,0,0,0,,So I want to read a logical block number
Dialogue: 0,0:29:30.78,0:29:35.12,English,,0,0,0,,And I want to place the contents of that logical block at a certain address in memory
Dialogue: 0,0:29:36.46,0:29:41.90,English,,0,0,0,,Okay so it's a command logical block number in a memory address
Dialogue: 0,0:29:43.00,0:29:49.70,English,,0,0,0,,The disk controller reads the whatever sector corresponds to that logical block
Dialogue: 0,0:29:49.92,0:29:54.78,English,,0,0,0,,So we'll assume that logical blocks are consists of one sector
Dialogue: 0,0:29:56.36,0:30:00.52,English,,0,0,0,,And then it does this interesting thing it copies it takes control of the bus
Dialogue: 0,0:30:01.16,0:30:03.90,English,,0,0,0,,And it copies the data this is the disk controller now
Dialogue: 0,0:30:04.64,0:30:12.58,English,,0,0,0,,Copies the data across the I/O bus through the I/O bridge and directly to main memory without ever notifying the CPU
Dialogue: 0,0:30:12.58,0:30:20.28,English,,0,0,0,,So the CPU is completely oblivious to the fact that this transfer is going on
Dialogue: 0,0:30:22.68,0:30:25.68,English,,0,0,0,,And then once it's once its transfer the data to main memory
Dialogue: 0,0:30:26.26,0:30:30.46,English,,0,0,0,,Then it notifies the CPU using this mechanism called an interrupt
Dialogue: 0,0:30:31.36,0:30:35.82,English,,0,0,0,,So it actually asserts a pin on the the actual CPU chip itself
Dialogue: 0,0:30:36.40,0:30:39.92,English,,0,0,0,,So it it changes the value of that pin from 0 to 1
Dialogue: 0,0:30:40.62,0:30:48.84,English,,0,0,0,,And that trigger is an interrupt and which notifies the CPU that sector has been copy
Dialogue: 0,0:30:50.02,0:30:56.04,English,,0,0,0,,Ok so then the CPU if there's some program somewhere waiting for that data to be read into memory
Dialogue: 0,0:30:56.04,0:31:01.44,English,,0,0,0,,So now now the CPU can can execute that program and deal with that memory
Dialogue: 0,0:31:02.00,0:31:04.90,English,,0,0,0,,So what this what this mechanism allows
Dialogue: 0,0:31:05.80,0:31:11.63,English,,0,0,0,,And the reason they do this is because disks are just so god-awful slow
Dialogue: 0,0:31:12.54,0:31:19.40,English,,0,0,0,,The within 10 milliseconds a system could be executing millions and millions of instructions
Dialogue: 0,0:31:19.40,0:31:22.74,English,,0,0,0,,The CPU could be executing millions and millions of instructions
Dialogue: 0,0:31:22.74,0:31:26.88,English,,0,0,0,,It will be a terrible waste if the CPU waited for that data to come off the disk
Dialogue: 0,0:31:27.88,0:31:33.18,English,,0,0,0,,So what it does is it it issues this request to the disk controller
Dialogue: 0,0:31:33.88,0:31:37.74,English,,0,0,0,,And then while that well that really slow laborious process is going on
Dialogue: 0,0:31:38.16,0:31:42.14,English,,0,0,0,,The CPU can be executing other instructions and doing other useful work
Dialogue: 0,0:31:43.94,0:31:49.18,English,,0,0,0,,So this is really essential to just sort of getting reasonable performance
Dialogue: 0,0:31:49.18,0:31:53.58,English,,0,0,0,,And from keeping this really slow disk system from slowing the system down
Dialogue: 0,0:31:54.64,0:32:02.22,English,,0,0,0,,Now there's another interesting hype kind of disk called a solid-state disk
Dialogue: 0,0:32:02.22,0:32:09.68,English,,0,0,0,,Which is kind of halfway between rotating and rotating discs  and DRAM memories
Dialogue: 0,0:32:10.38,0:32:14.07,English,,0,0,0,,In a solid-state disk to the to the CPU
Dialogue: 0,0:32:14.07,0:32:17.96,English,,0,0,0,,It looks exactly like a rotating disk it has the same socket plug
Dialogue: 0,0:32:18.20,0:32:22.40,English,,0,0,0,,It has the same physical interface that has the same packaging
Dialogue: 0,0:32:22.82,0:32:24.83,English,,0,0,0,,It looks like a rotating disc
Dialogue: 0,0:32:25.18,0:32:31.66,English,,0,0,0,,But instead of having all these mechanical parts it's actually built entirely out of flash memory
Dialogue: 0,0:32:31.96,0:32:36.82,English,,0,0,0,,And firmware that acts as the the controller
Dialogue: 0,0:32:37.42,0:32:44.60,English,,0,0,0,,So inside of a solid-state disk there's a firmware a set of firmware called the flash translation layer
Dialogue: 0,0:32:44.72,0:32:51.86,English,,0,0,0,,Which serves the purpose as the same purpose as the disk controller does in a rotating disk d
Dialogue: 0,0:32:54.70,0:32:57.06,English,,0,0,0,,And then the memory itself the read
Dialogue: 0,0:32:58.60,0:33:03.74,English,,0,0,0,,Data can be read read and written from the flash memory in units of pages
Dialogue: 0,0:33:04.34,0:33:08.94,English,,0,0,0,,Which depending on the technology can be 512 kbytes to 4 k bytes
Dialogue: 0,0:33:11.12,0:33:14.92,English,,0,0,0,,And then a sequence of pages forms a block
Dialogue: 0,0:33:15.92,0:33:21.50,English,,0,0,0,,Now these these these blocks are different from the logical blocks that the CPU does
Dialogue: 0,0:33:21.50,0:33:24.24,English,,0,0,0,,So it's kind of an unfortunate overlap of terms
Dialogue: 0,0:33:26.78,0:33:35.48,English,,0,0,0,,But the the trick is or the I guess the limitation is that data is written in units of pages
Dialogue: 0,0:33:36.74,0:33:41.06,English,,0,0,0,,But a page can only be written after the entire block has been erased
Dialogue: 0,0:33:43.86,0:33:46.98,English,,0,0,0,,Okay so that's that seems kind of weird but that's that's the way it works
Dialogue: 0,0:33:47.68,0:33:49.85,English,,0,0,0,,So what that means is if you want to write
Dialogue: 0,0:33:51.30,0:33:57.54,English,,0,0,0,,If you want to write to a page you have to find a block somewhere that's been erased
Dialogue: 0,0:33:59.00,0:34:05.40,English,,0,0,0,,You have to copy all of the other pages in your target block over to that new block and then you can do the right
Dialogue: 0,0:34:07.10,0:34:14.04,English,,0,0,0,,Okay so you can see that rights now become fairly complex operation reads you can read anything
Dialogue: 0,0:34:15.30,0:34:21.50,English,,0,0,0,,And then like all flash a so it's kind of an efficient right because you're writing one page
Dialogue: 0,0:34:22.70,0:34:28.58,English,,0,0,0,,But to do that you have to sort of copy all the other pages in it block and you have to erase the whole
Dialogue: 0,0:34:29.18,0:34:33.86,English,,0,0,0,,And then when you finish then you erase this block so it can be used for for other writes yes
Dialogue: 0,0:34:34.92,0:34:38.88,English,,0,0,0,,So eventually after a hundred thousand repeated writes these we're out
Dialogue: 0,0:34:40.24,0:34:43.40,English,,0,0,0,,Now the flash translation layer xin modern systems
Dialogue: 0,0:34:43.96,0:34:50.32,English,,0,0,0,,Do all kinds of fancy proprietary algorithms to sort of extend the life they use caching
Dialogue: 0,0:34:50.78,0:34:54.58,English,,0,0,0,,And and various tricks to extend the life of these SSD
Dialogue: 0,0:34:54.58,0:34:58.76,English,,0,0,0,,So in practice it's not really a problem which I'll show you in a second
Dialogue: 0,0:35:00.42,0:35:04.28,English,,0,0,0,,So the performance characteristics of SSDs
Dialogue: 0,0:35:04.74,0:35:08.66,English,,0,0,0,,Now you can think of a typical hard drive you might be able to get
Dialogue: 0,0:35:09.98,0:35:12.94,English,,0,0,0,,You know I mean what if when I measure them when I measure my drives
Dialogue: 0,0:35:12.94,0:35:16.34,English,,0,0,0,,I maybe forty fifty megabytes per second that would be a typical rate
Dialogue: 0,0:35:17.34,0:35:21.16,English,,0,0,0,,Okay these SSDs are 10 times faster than that
Dialogue: 0,0:35:22.06,0:35:25.18,English,,0,0,0,,So for sequential reads you can get about 500 50 megabytes
Dialogue: 0,0:35:26.04,0:35:28.78,English,,0,0,0,,Sequential writes are a little bit slower
Dialogue: 0,0:35:31.08,0:35:36.18,English,,0,0,0,,Random access whether you're reading or writing is a little bit slower than sequential access
Dialogue: 0,0:35:37.02,0:35:39.80,English,,0,0,0,,And as we'll see this is that this is fairly common
Dialogue: 0,0:35:39.82,0:35:45.90,English,,0,0,0,,It's it's in memory systems it's almost always better to do things sequentially  than to jump around
Dialogue: 0,0:35:48.06,0:35:53.62,English,,0,0,0,,And erasing random writes are slower because erase erasing takes about a millisecond right
Dialogue: 0,0:35:53.62,0:35:59.20,English,,0,0,0,,So now we're back up to that that millisecond range which is which is slow
Dialogue: 0,0:35:59.82,0:36:06.80,English,,0,0,0,,And as I mentioned yet if you modify one one one page after all the other pages in that block have to be copy
Dialogue: 0,0:36:07.94,0:36:18.24,English,,0,0,0,,Now earlier SSDs had a huge gap between random writes and sequential reads
Dialogue: 0,0:36:19.10,0:36:23.28,English,,0,0,0,,But they because of sort of improvements in the flash translation layer
Dialogue: 0,0:36:23.66,0:36:29.12,English,,0,0,0,,These aren't really that that difference right reading and writing it's it's writing is slower
Dialogue: 0,0:36:29.52,0:36:34.36,English,,0,0,0,,But they're doing all kinds of interesting amazing things to get these numbers fairly close
Dialogue: 0,0:36:35.76,0:36:42.42,English,,0,0,0,,Ok so art when we have a model of SSDs we really don't need to distinguish anymore that between reads and writes
Dialogue: 0,0:36:45.14,0:36:48.10,English,,0,0,0,,You okay so SSDs because they have no moving parts
Dialogue: 0,0:36:48.16,0:36:51.76,English,,0,0,0,,They're faster they take less power they're more rugged
Dialogue: 0,0:36:52.22,0:36:54.78,English,,0,0,0,,You know which is why they're good for thumb drives
Dialogue: 0,0:36:55.52,0:36:57.70,English,,0,0,0,,And you know ipods and things like that
Dialogue: 0,0:36:58.24,0:37:01.06,English,,0,0,0,,But they have this potential to wear out
Dialogue: 0,0:37:01.26,0:37:05.34,English,,0,0,0,,Which could be a problem but in practice it's not for example
Dialogue: 0,0:37:05.34,0:37:10.00,English,,0,0,0,,Intel guarantees that you can do 128 petabytes of writes
Dialogue: 0,0:37:10.64,0:37:13.46,English,,0,0,0,,Before your SSD is no longer good
Dialogue: 0,0:37:14.24,0:37:19.92,English,,0,0,0,,So that's a lot of data to write I mean think about how many years it would take to write that much data
Dialogue: 0,0:37:21.46,0:37:25.48,English,,0,0,0,,And as of 2015 as of now
Dialogue: 0,0:37:25.76,0:37:28.67,English,,0,0,0,,They're a lot more expensive per byte than rotating disks
Dialogue: 0,0:37:29.18,0:37:32.88,English,,0,0,0,,So rotating disks are much bigger but they're slower
Dialogue: 0,0:37:33.52,0:37:35.72,English,,0,0,0,,SSDs are smaller and faster
Dialogue: 0,0:37:39.28,0:37:40.98,English,,0,0,0,,Now if you take
Dialogue: 0,0:37:42.10,0:37:48.22,English,,0,0,0,,If you look at the performance characteristics of these different storage devices relative to CPU
Dialogue: 0,0:37:48.62,0:37:52.10,English,,0,0,0,,Over time you get this really interesting graph
Dialogue: 0,0:37:53.58,0:38:03.14,English,,0,0,0,,Now this graph shows on the y-axis access time in nanoseconds  or in a log scale
Dialogue: 0,0:38:03.14,0:38:14.44,English,,0,0,0,,Okay so each one of these each change in units from 1,000 to 10,000 represents a order of magnitude difference in access time
Dialogue: 0,0:38:15.52,0:38:22.98,English,,0,0,0,,On the x-axis I've plotted time going from 1985 to 2015
Dialogue: 0,0:38:24.20,0:38:29.36,English,,0,0,0,,And then I've plotted the sort of the the access time or the cycle time of
Dialogue: 0,0:38:30.10,0:38:35.16,English,,0,0,0,,The access time of the these devices disk SSD DRAM and SRAM
Dialogue: 0,0:38:36.00,0:38:38.12,English,,0,0,0,,And the cycle time of processors
Dialogue: 0,0:38:38.16,0:38:44.31,English,,0,0,0,,So let's look at on the bottom we have the the cycle time of processors over time
Dialogue: 0,0:38:45.22,0:38:52.04,English,,0,0,0,,And what you see is it's going down at is this sort of exponential rate  from 1985 to 2003
Dialogue: 0,0:38:52.82,0:39:00.27,English,,0,0,0,,There's the doubling basically every 18 months or two years in clock frequency and a resulting
Dialogue: 0,0:39:00.80,0:39:06.88,English,,0,0,0,,Halving of the cycle time over this 18-month two to two year period
Dialogue: 0,0:39:08.16,0:39:14.12,English,,0,0,0,,So this so what what manufacturers did until 2003
Dialogue: 0,0:39:15.02,0:39:18.92,English,,0,0,0,,To make their processors faster was a but they would just double the clock frequency
Dialogue: 0,0:39:19.60,0:39:23.28,English,,0,0,0,,They decrease the feature size of the chips that they were making
Dialogue: 0,0:39:24.00,0:39:26.94,English,,0,0,0,,And that would allow them to put things closer together
Dialogue: 0,0:39:26.94,0:39:35.82,English,,0,0,0,,And then have that and then increase the clock frequency by a proportional amount
Dialogue: 0,0:39:36.92,0:39:42.48,English,,0,0,0,,Now this all ended 2003 was an interesting year in computer history
Dialogue: 0,0:39:43.16,0:39:48.92,English,,0,0,0,,Because of this there's a sort of unfortunate property that the power that you consume
Dialogue: 0,0:39:49.22,0:39:50.98,English,,0,0,0,,Is proportional to your frequency
Dialogue: 0,0:39:50.98,0:39:55.62,English,,0,0,0,,Okay so the more power I mean the higher the frequency the more power you consume
Dialogue: 0,0:39:56.52,0:40:04.30,English,,0,0,0,,By 2003 the processor that Intel was getting ready to ship was going to burn about 800 watts of power
Dialogue: 0,0:40:05.08,0:40:10.42,English,,0,0,0,,Think about 800 watt light bulbs inside your laptop and
Dialogue: 0,0:40:11.92,0:40:16.38,English,,0,0,0,,I actually saw an early prototype of one of these devices
Dialogue: 0,0:40:16.68,0:40:25.40,English,,0,0,0,,And the the heatsink to absorb the power from the chip was about this big it was about four square inches
Dialogue: 0,0:40:25.40,0:40:28.26,English,,0,0,0,,It's a giant thing just sitting on the motherboard
Dialogue: 0,0:40:29.78,0:40:36.70,English,,0,0,0,,So that's what we what we say is that processor design hit the power wall in 2003
Dialogue: 0,0:40:36.70,0:40:40.62,English,,0,0,0,,They could no longer just continue to increase clock frequencies
Dialogue: 0,0:40:41.40,0:40:45.90,English,,0,0,0,,To to get faster to make faster computers
Dialogue: 0,0:40:46.50,0:40:49.26,English,,0,0,0,,And what so what they had to do after 2003
Dialogue: 0,0:40:49.68,0:40:55.42,English,,0,0,0,,Instead of increasing the clock frequency and try and set up doubling the clock frequency
Dialogue: 0,0:40:56.22,0:40:59.58,English,,0,0,0,,They put more processor cores onto the chips
Dialogue: 0,0:41:00.22,0:41:05.08,English,,0,0,0,,So now they subdivided a CPU chip into individual processor cores
Dialogue: 0,0:41:05.08,0:41:07.52,English,,0,0,0,,Each one could execute its own instructions
Dialogue: 0,0:41:09.64,0:41:13.24,English,,0,0,0,,And then so and by running in parallel
Dialogue: 0,0:41:13.54,0:41:18.70,English,,0,0,0,,You could do more effective work so the effective cycle time could continue to go down
Dialogue: 0,0:41:18.70,0:41:22.54,English,,0,0,0,,So what I've what I plotted here on the bottom is the effective cycle time
Dialogue: 0,0:41:22.54,0:41:26.40,English,,0,0,0,,So basically the the cycle time divided by the number of cores
Dialogue: 0,0:41:27.46,0:41:30.80,English,,0,0,0,,So here in 2005 that the first systems use two cores
Dialogue: 0,0:41:31.36,0:41:34.60,English,,0,0,0,,So now you can run two independent threads or two independent programs
Dialogue: 0,0:41:35.30,0:41:40.10,English,,0,0,0,,And currently it's about four cores server class systems you can get eight cores
Dialogue: 0,0:41:40.58,0:41:43.94,English,,0,0,0,,And there's even some 12 core chips
Dialogue: 0,0:41:44.74,0:41:50.60,English,,0,0,0,,So in the future what's going to happen is that the the clock frequencies are going to stay fairly constant
Dialogue: 0,0:41:50.60,0:41:54.56,English,,0,0,0,,So you can see the site you can see the the cycle times are
Dialogue: 0,0:41:55.24,0:42:00.48,English,,0,0,0,,They actually increased a little bit here and then they're slowly going down but it's generally flat
Dialogue: 0,0:42:02.20,0:42:04.78,English,,0,0,0,,And so the only way to really get more performance
Dialogue: 0,0:42:04.94,0:42:07.48,English,,0,0,0,,Go forward is to increase the number of independent course
Dialogue: 0,0:42:08.28,0:42:13.54,English,,0,0,0,,And that's just that's just the way it's got to be
Dialogue: 0,0:42:14.88,0:42:20.32,English,,0,0,0,,Now here in the the black circle the second line I've plotted the access time for SRAM over time
Dialogue: 0,0:42:22.24,0:42:25.54,English,,0,0,0,,And you can see that SRAM is tracking CPU pretty good
Dialogue: 0,0:42:25.94,0:42:29.68,English,,0,0,0,,And it and there's it's it's an order of magnitude slower but
Dialogue: 0,0:42:30.12,0:42:34.22,English,,0,0,0,,It's tracking the CPU performance pretty well
Dialogue: 0,0:42:34.72,0:42:40.92,English,,0,0,0,,Dram you can see there's a huge gap between the CPU and the DRAM several orders of magnitude
Dialogue: 0,0:42:41.50,0:42:44.08,English,,0,0,0,,And in the last few years DRAMs have gotten a little better
Dialogue: 0,0:42:44.08,0:42:49.64,English,,0,0,0,,But they've proven surprisingly difficult to to make faster
Dialogue: 0,0:42:53.24,0:42:56.48,English,,0,0,0,,SSDs are kind of in between disks and DRAM
Dialogue: 0,0:42:56.48,0:43:02.44,English,,0,0,0,,And then disks up here you can see at a million nanoseconds that's the that's a millisecond
Dialogue: 0,0:43:02.44,0:43:11.93,English,,0,0,0,,So you can see disks are sort of in this in this sort of millisecond range with access times
Dialogue: 0,0:43:12.30,0:43:16.46,English,,0,0,0,,And those those that they've gone down a little bit but not really too much
Dialogue: 0,0:43:17.30,0:43:24.90,English,,0,0,0,,So the point I want to make is that there's this huge gap between DRAM  SSD disk in and CPUs
Dialogue: 0,0:43:25.38,0:43:31.34,English,,0,0,0,,And in some cases it's even getting worse as time goes by so that's a problem right how
Dialogue: 0,0:43:33.08,0:43:37.24,English,,0,0,0,,Our programs all need data our data is stored in memory and disk
Dialogue: 0,0:43:38.50,0:43:41.20,English,,0,0,0,,So if if our if our computers are getting faster
Dialogue: 0,0:43:41.94,0:43:47.95,English,,0,0,0,,And our storage devices are are staying relatively the same or relatively slower
Dialogue: 0,0:43:48.42,0:43:53.16,English,,0,0,0,,Then we've got a problem right increases in in our in computer performance won't
Dialogue: 0,0:43:53.32,0:43:56.06,English,,0,0,0,,It'll be hard to make our programs run faster
Dialogue: 0,0:43:56.20,0:43:59.76,English,,0,0,0,,Because we'll be limited by the time it takes to to access the data
Dialogue: 0,0:44:01.18,0:44:04.62,English,,0,0,0,,Ok so that's that that's sort of the fundamental problem that we have to deal with
Dialogue: 0,0:44:05.80,0:44:12.86,English,,0,0,0,,And it turns out that the key to bridging this this gap between the CPU and and memory
Dialogue: 0,0:44:13.52,0:44:18.86,English,,0,0,0,,Is this is this very basic fundamental property of programs called locality
Dialogue: 0,0:44:19.62,0:44:25.02,English,,0,0,0,,Okay and so this is an essential sort of fundamental enduring property of programs
Dialogue: 0,0:44:31.60,0:44:36.28,English,,0,0,0,,So we say that so programs have this property called locality
Dialogue: 0,0:44:37.22,0:44:38.96,English,,0,0,0,,And what this means is that
Dialogue: 0,0:44:41.00,0:44:44.66,English,,0,0,0,,I'm sorry I'll just I have to read it because it's it's really accurate definition
Dialogue: 0,0:44:44.66,0:44:53.38,English,,0,0,0,,So programs tend to use data and instructions whose addresses are near or equal to those that they have used recently
Dialogue: 0,0:44:54.86,0:45:00.14,English,,0,0,0,,Okay so if a program access is a data item the chances are very high
Dialogue: 0,0:45:01.06,0:45:06.78,English,,0,0,0,,That it's going to access that data item or a nearby data item sometime in the near future
Dialogue: 0,0:45:09.24,0:45:14.72,English,,0,0,0,,Okay that likelihood that the program is going to access that data item or a nearby a data item
Dialogue: 0,0:45:14.78,0:45:18.68,English,,0,0,0,,In the near future is that is this property called locality
Dialogue: 0,0:45:19.74,0:45:24.90,English,,0,0,0,,So well does we just typically distinguish two two different kinds of locality
Dialogue: 0,0:45:25.42,0:45:33.00,English,,0,0,0,,Temporal locality is the property that recently referenced items are likely to be referenced again in the near future
Dialogue: 0,0:45:33.50,0:45:35.53,English,,0,0,0,,Kaycee 50 so if you read a variable
Dialogue: 0,0:45:36.16,0:45:38.50,English,,0,0,0,,Chances are you're going to read that variable again
Dialogue: 0,0:45:39.24,0:45:42.74,English,,0,0,0,,For example suppose you're summing into a variable inside of a loop
Dialogue: 0,0:45:42.96,0:45:46.46,English,,0,0,0,,Each loop iteration you're going to access that that variable okay
Dialogue: 0,0:45:47.28,0:45:55.06,English,,0,0,0,,Spatial locality is that the tendency for items with nearby addresses up that
Dialogue: 0,0:45:55.34,0:46:01.70,English,,0,0,0,,That items if we access if we access one item chances are high we're going to access a nearby item
Dialogue: 0,0:46:05.86,0:46:13.46,English,,0,0,0,,Okay so let's look at this little snippet of code and see if we can identify all the different kinds of locality in this code
Dialogue: 0,0:46:14.72,0:46:18.04,English,,0,0,0,,So we have two different kinds of of references there's data references
Dialogue: 0,0:46:18.64,0:46:22.08,English,,0,0,0,,And then there's instructions right so we're reading instructions out of memory
Dialogue: 0,0:46:22.36,0:46:24.22,English,,0,0,0,,And those instructions are referencing data okay
Dialogue: 0,0:46:26.96,0:46:32.70,English,,0,0,0,,So first of all notice that we're we're referencing the elements of an array in succession
Dialogue: 0,0:46:33.70,0:46:36.42,English,,0,0,0,,So we're increasing I by one each time and then we're
Dialogue: 0,0:46:36.76,0:46:41.20,English,,0,0,0,,So we're incrementing I through the loop and we're reading a[i]
Dialogue: 0,0:46:42.32,0:46:45.98,English,,0,0,0,,Okay so this is called a stride one reference pattern the
Dialogue: 0,0:46:46.66,0:46:50.82,English,,0,0,0,,The stride is how much we're incrementing this this index
Dialogue: 0,0:46:50.82,0:46:54.64,English,,0,0,0,,So we're since we're incrementing it by one we call that a stride one pattern
Dialogue: 0,0:46:55.46,0:47:05.38,English,,0,0,0,,So what kind of what kind of locality is the these repeated references to a[i] spatial or temporal
Dialogue: 0,0:47:07.54,0:47:10.08,English,,0,0,0,,That spatial right because we're accessing nearby items
Dialogue: 0,0:47:12.10,0:47:16.02,English,,0,0,0,,Okay what about the referencing this this variable some inside the loop
Dialogue: 0,0:47:17.00,0:47:17.96,English,,0,0,0,,That's temporal
Dialogue: 0,0:47:19.48,0:47:20.84,English,,0,0,0,,Now what about instructions
Dialogue: 0,0:47:21.48,0:47:28.02,English,,0,0,0,,So we're referencing where each loop iteration where reference we're executing a sequence of instructions
Dialogue: 0,0:47:28.86,0:47:30.52,English,,0,0,0,,So what kind of locality is that
Dialogue: 0,0:47:34.06,0:47:37.86,English,,0,0,0,,Within each loop iteration? no that's spatial right
Dialogue: 0,0:47:37.86,0:47:42.93,English,,0,0,0,,Because we're just executing a sequence of instructions within each loop iteration
Dialogue: 0,0:47:43.52,0:47:45.74,English,,0,0,0,,But then we cycle through the loop repeatedly
Dialogue: 0,0:47:46.48,0:47:52.58,English,,0,0,0,,So we'll chances so each loop iteration we're going to access each of those instructions
Dialogue: 0,0:47:53.32,0:47:55.78,English,,0,0,0,,That we access the previous loop iteration right
Dialogue: 0,0:47:55.94,0:47:59.58,English,,0,0,0,,So we go up we just keep at we're just going to keep executing the sum
Dialogue: 0,0:48:00.02,0:48:03.48,English,,0,0,0,,Assembly language instructions that implement this loop body
Dialogue: 0,0:48:04.16,0:48:06.48,English,,0,0,0,,Now in this simple example it's probably this one instruction
Dialogue: 0,0:48:06.48,0:48:10.32,English,,0,0,0,,But in general your loop can have multiple instructions
Dialogue: 0,0:48:13.72,0:48:20.40,English,,0,0,0,,Now when I claim to you I'm one of the one of the main sort of points of this just this whole course
Dialogue: 0,0:48:21.54,0:48:24.26,English,,0,0,0,,Is that as a professional programmer
Dialogue: 0,0:48:25.24,0:48:31.84,English,,0,0,0,,It's an essential skill that that you be able to look at code and so get a qualitative sense of its locality
Dialogue: 0,0:48:32.74,0:48:36.64,English,,0,0,0,,Because as we'll see good locality turns into good performance
Dialogue: 0,0:48:37.50,0:48:39.40,English,,0,0,0,,The way that systems are built these days
Dialogue: 0,0:48:40.10,0:48:46.82,English,,0,0,0,,So as a programmer it's very important for you to be able to kind of look at code and get some qualitative sense
Dialogue: 0,0:48:47.30,0:48:51.56,English,,0,0,0,,Like yeah that's pretty good locality that's terrible locality right that that's
Dialogue: 0,0:48:52.34,0:48:55.48,English,,0,0,0,,And what you want to do is avoid the terrible locality in your code
Dialogue: 0,0:48:56.28,0:48:58.34,English,,0,0,0,,So let's look at a simple example here
Dialogue: 0,0:48:59.10,0:49:00.52,English,,0,0,0,,To see what I mean by this
Dialogue: 0,0:49:01.62,0:49:06.66,English,,0,0,0,,So what I'm doing is I'm taking an array a two-dimensional array a
Dialogue: 0,0:49:07.16,0:49:09.30,English,,0,0,0,,With m m rows and n columns
Dialogue: 0,0:49:10.98,0:49:17.04,English,,0,0,0,,And within it a doubly nested loop iterating on I and j
Dialogue: 0,0:49:17.30,0:49:19.07,English,,0,0,0,,I'm summing the elements of that array
Dialogue: 0,0:49:19.90,0:49:24.38,English,,0,0,0,,Okay seems this a very simple operation what could go wrong right
Dialogue: 0,0:49:26.66,0:49:36.20,English,,0,0,0,,So it turns out if you write this code to have bad locality  it will run order magnitude slower
Dialogue: 0,0:49:38.12,0:49:43.56,English,,0,0,0,,Okay so if just look at this if you look at this do you think this has good locality or bad locality
Dialogue: 0,0:49:44.14,0:49:49.36,English,,0,0,0,,Let's look at the with respect to the accesses of a
Dialogue: 0,0:49:53.42,0:49:54.20,English,,0,0,0,,Good or bad ?
Dialogue: 0,0:50:00.76,0:50:04.78,English,,0,0,0,,Well so how is how is a laid out in memory right
Dialogue: 0,0:50:05.96,0:50:11.38,English,,0,0,0,,It's row wise all right so see uses used lays out a raised row wise
Dialogue: 0,0:50:11.38,0:50:16.06,English,,0,0,0,,So the first all the elements of the first row followed by all the elements
Dialogue: 0,0:50:16.06,0:50:19.14,English,,0,0,0,,Of the second row followed by all the elements of the third row
Dialogue: 0,0:50:21.08,0:50:23.28,English,,0,0,0,,Okay so how are we accessing this array
Dialogue: 0,0:50:23.28,0:50:30.42,English,,0,0,0,,Look at we're accessing a[i][j] and we're varying j the fastest
Dialogue: 0,0:50:30.44,0:50:33.42,English,,0,0,0,,So we hold I constant and then we vary j
Dialogue: 0,0:50:33.94,0:50:38.32,English,,0,0,0,,And then we access all so we hold the I constant to access row i
Dialogue: 0,0:50:39.10,0:50:43.44,English,,0,0,0,,And then we vary j to access all the columns in that row
Dialogue: 0,0:50:44.76,0:50:51.06,English,,0,0,0,,Okay so each each hitter and then we increase and then we go back and increase i
Dialogue: 0,0:50:52.60,0:50:54.46,English,,0,0,0,,So now we're accessing the next row
Dialogue: 0,0:50:56.92,0:51:04.34,English,,0,0,0,,Okay so if we were to look at the addresses of a[i][j] the sequence of addresses  that are being read
Dialogue: 0,0:51:05.34,0:51:12.78,English,,0,0,0,,Those would correspond to a stride one access and so we'd be accessing all the elements of a sequentially in order
Dialogue: 0,0:51:13.86,0:51:18.48,English,,0,0,0,,Okay so that's really good spatial locality right that's the best you can do
Dialogue: 0,0:51:19.68,0:51:25.77,English,,0,0,0,,Now what about what about and then we have temporal locality on some so that's good
Dialogue: 0,0:51:26.66,0:51:30.54,English,,0,0,0,,Right so everything about this is pretty good so this is the good case
Dialogue: 0,0:51:32.36,0:51:36.06,English,,0,0,0,,Now what about this what I've done I've taken the same program
Dialogue: 0,0:51:37.16,0:51:45.22,English,,0,0,0,,And I've just inverted the loops so it's a loop on j first and then on i
Dialogue: 0,0:51:45.82,0:51:47.90,English,,0,0,0,,And then I just have the same inner loop body
Dialogue: 0,0:51:52.26,0:51:57.54,English,,0,0,0,,Now what does that do to this what does that do to the spatial locality of our accesses okay
Dialogue: 0,0:51:57.96,0:52:00.00,English,,0,0,0,,Yes
Dialogue: 0,0:52:00.00,0:52:06.04,English,,0,0,0,,Terrible because it's going you should be offended what do you see this isn't lawful
Dialogue: 0,0:52:07.60,0:52:10.24,English,,0,0,0,,But it's terrible right because look it
Dialogue: 0,0:52:11.06,0:52:14.03,English,,0,0,0,,So we're now we're holding j
Dialogue: 0,0:52:14.84,0:52:21.44,English,,0,0,0,,We're holding j constant and then we're iterating through the jt element of each row so that's skipping
Dialogue: 0,0:52:23.16,0:52:29.90,English,,0,0,0,,We have n we have n elements in each row so we're doing a stride n access through memory
Dialogue: 0,0:52:30.68,0:52:31.96,English,,0,0,0,,So we're going like this
Dialogue: 0,0:52:33.38,0:52:38.48,English,,0,0,0,,And then we're incrementing then we're looking then we're incrementing the column by one and then we're doing this again
Dialogue: 0,0:52:39.46,0:52:43.60,English,,0,0,0,,So it's terrible spatial locality this is the worst spatial locality we could get
Dialogue: 0,0:52:48.30,0:52:50.22,English,,0,0,0,,Now let's look at a three dimensional array
Dialogue: 0,0:52:52.24,0:52:54.76,English,,0,0,0,,And let me ask you that let me post the following question
Dialogue: 0,0:52:55.54,0:52:59.46,English,,0,0,0,,Can you based on this sort of qualitative idea that
Dialogue: 0,0:53:00.14,0:53:04.24,English,,0,0,0,,This idea that you want you want to try to get a stride one reference pattern
Dialogue: 0,0:53:05.34,0:53:11.40,English,,0,0,0,,Okay so how would you permute these given this given this inner body
Dialogue: 0,0:53:12.48,0:53:19.38,English,,0,0,0,,A[k][i][j] how would you promote that permute these these loop indices to give stride one reference pattern
Dialogue: 0,0:53:23.46,0:53:26.08,English,,0,0,0,,Okay that's right kij is right
Dialogue: 0,0:53:26.60,0:53:30.28,English,,0,0,0,,So what in general we want to do is we want to go going from right to left
Dialogue: 0,0:53:31.22,0:53:34.94,English,,0,0,0,,We want we want those indices to be changing the fastest
Dialogue: 0,0:53:35.12,0:53:40.38,English,,0,0,0,,So we want j we want k and I to be held constant and then we want to change j
Dialogue: 0,0:53:41.10,0:53:46.24,English,,0,0,0,,Then we want to increment I and then for that value that those values of k and i
Dialogue: 0,0:53:46.24,0:53:51.07,English,,0,0,0,,We want to want to sequence through all the the values of j again
Dialogue: 0,0:53:51.86,0:53:52.52,English,,0,0,0,,Okay
Dialogue: 0,0:53:56.41,0:54:01.92,English,,0,0,0,,Okay so we've looked at properties of technology of storage technologies
Dialogue: 0,0:54:03.18,0:54:08.84,English,,0,0,0,,And well we and there's this sort of basic sort of fundamental principle that cheaper storage
Dialogue: 0,0:54:09.36,0:54:13.88,English,,0,0,0,,You bigger storage higher capacity storage is cheaper
Dialogue: 0,0:54:15.82,0:54:19.22,English,,0,0,0,,More expensive storage is smaller
Dialogue: 0,0:54:19.72,0:54:22.16,English,,0,0,0,,Because we just don't have that we don't we can't spend enough money
Dialogue: 0,0:54:25.46,0:54:31.66,English,,0,0,0,,There's this gap there's this gap between our storage devices and the CPU
Dialogue: 0,0:54:32.86,0:54:36.08,English,,0,0,0,,That is in at least in the case of disks are getting bigger
Dialogue: 0,0:54:38.02,0:54:40.62,English,,0,0,0,,And we have programs that exhibit locality
Dialogue: 0,0:54:41.98,0:54:48.34,English,,0,0,0,,Okay so these three things these properties of storage technologies
Dialogue: 0,0:54:48.64,0:54:50.50,English,,0,0,0,,And properties of our programs
Dialogue: 0,0:54:50.94,0:54:58.18,English,,0,0,0,,Complement each other in this beautiful way to suggest and inform the design of our storage systems
Dialogue: 0,0:54:58.82,0:55:01.84,English,,0,0,0,,And this design is something called a memory hierarchy
Dialogue: 0,0:55:03.96,0:55:05.98,English,,0,0,0,,Okay here's the idea of a memory hierarchy
Dialogue: 0,0:55:07.92,0:55:12.74,English,,0,0,0,,You layer instead of a flat memory system you now
Dialogue: 0,0:55:13.04,0:55:16.16,English,,0,0,0,,You create your memory system as a hierarchy of devices
Dialogue: 0,0:55:17.84,0:55:20.82,English,,0,0,0,,And at the top of the at the top of this hierarchy
Dialogue: 0,0:55:21.54,0:55:25.94,English,,0,0,0,,You have your smaller faster and more expensive storage devices
Dialogue: 0,0:55:25.94,0:55:28.62,English,,0,0,0,,So at the very top you have registers
Dialogue: 0,0:55:29.56,0:55:35.50,English,,0,0,0,,Which are which can be accessed and within one cycle right one instruction
Dialogue: 0,0:55:36.76,0:55:40.46,English,,0,0,0,,While that instructions executing can access read and write into a register
Dialogue: 0,0:55:41.16,0:55:43.74,English,,0,0,0,,Okay so registers are at the top of the hierarchy
Dialogue: 0,0:55:44.46,0:55:47.36,English,,0,0,0,,But because those are in custom silicon they're very expensive right
Dialogue: 0,0:55:47.36,0:55:51.50,English,,0,0,0,,The fabrication plants to make processors cost billions of dollars
Dialogue: 0,0:55:52.16,0:55:53.98,English,,0,0,0,,Okay so this is the most expensive and
Dialogue: 0,0:55:54.60,0:55:59.56,English,,0,0,0,,Because of that it's also the smallest we've only got 16 registers at the top of the hierarchy
Dialogue: 0,0:56:00.60,0:56:07.00,English,,0,0,0,,Now below that we put one or more SRAM memories remember SRAM is faster
Dialogue: 0,0:56:08.46,0:56:10.02,English,,0,0,0,,It's the fastest kind of memory
Dialogue: 0,0:56:10.02,0:56:16.16,English,,0,0,0,,So we put one or more so-called caches cache memories built out of SRAM
Dialogue: 0,0:56:16.78,0:56:18.80,English,,0,0,0,,In the processor chip itself
Dialogue: 0,0:56:23.44,0:56:30.82,English,,0,0,0,,And then and these caches because they're made out of SRAM they're on the order of megabytes in size
Dialogue: 0,0:56:31.18,0:56:34.38,English,,0,0,0,,Okay they're much bigger than registers but they're they're megabytes
Dialogue: 0,0:56:35.94,0:56:39.86,English,,0,0,0,,Okay which if we look and then beneath that is our
Dialogue: 0,0:56:40.10,0:56:47.08,English,,0,0,0,,Main memory which is built out of DRAMs and those can be gigabytes  tens of gigabytes on modern systems
Dialogue: 0,0:56:47.92,0:56:49.84,English,,0,0,0,,And then below that is our local disks
Dialogue: 0,0:56:50.68,0:56:57.08,English,,0,0,0,,And we can even have lower layers like web servers that are storing you know for storing stuff on google
Dialogue: 0,0:56:57.76,0:57:01.38,English,,0,0,0,,That you can think of that as just part of our our hierarchy
Dialogue: 0,0:57:02.60,0:57:06.90,English,,0,0,0,,Now here's the here's the key idea and a higher in a in a memory hierarchy
Dialogue: 0,0:57:07.92,0:57:14.89,English,,0,0,0,,Each level in this hierarchy holds data that's retrieved from the next lower level
Dialogue: 0,0:57:15.56,0:57:21.24,English,,0,0,0,,Okay so caches hold registers hold data that's that's stored in the l1 cache
Dialogue: 0,0:57:22.12,0:57:30.00,English,,0,0,0,,The l1 cache holds data that's retrieved from the l2 cache the l3 cache holds data  that's restored
Dialogue: 0,0:57:30.70,0:57:37.48,English,,0,0,0,,That's that's retrieved from main memory main memory holds data that's retrieved from secondary disk and so on
Dialogue: 0,0:57:39.46,0:57:44.10,English,,0,0,0,,Now as we'll see the that the reason memory systems are designed like this
Dialogue: 0,0:57:45.22,0:57:48.22,English,,0,0,0,,Is that they when you have this kind of system
Dialogue: 0,0:57:50.68,0:57:59.28,English,,0,0,0,,This you can access in general you can access your data at the speed of the fastest item in the day
Dialogue: 0,0:57:59.74,0:58:01.20,English,,0,0,0,,And at the top of the hierarchy
Dialogue: 0,0:58:01.66,0:58:02.76,English,,0,0,0,,So that's the fastest
Dialogue: 0,0:58:03.66,0:58:08.80,English,,0,0,0,,But with the cost of the storage at the lower part of the hierarchy
Dialogue: 0,0:58:10.94,0:58:14.92,English,,0,0,0,,Okay so this this works all because of an idea called caching
Dialogue: 0,0:58:16.92,0:58:23.28,English,,0,0,0,,So a cache and compete to took to a computer scientist is a
Dialogue: 0,0:58:23.70,0:58:32.00,English,,0,0,0,,It's a smaller faster storage device that acts as a staging area for the data and a larger slower device
Dialogue: 0,0:58:32.04,0:58:38.00,English,,0,0,0,,So just like like here you can think of your main memory is a cache for data
Dialogue: 0,0:58:38.00,0:58:41.58,English,,0,0,0,,That's stored on disk right you read memory from disk and then you store it in main memory
Dialogue: 0,0:58:42.38,0:58:44.84,English,,0,0,0,,Okay you can think of the main memory as a staging area
Dialogue: 0,0:58:46.50,0:58:52.20,English,,0,0,0,,So once you get the data from the disk you don't access it again on the disk you access it in memory which is much faster
Dialogue: 0,0:58:52.68,0:58:55.42,English,,0,0,0,,Ok so this idea propagates all the way up the hierarchy
Dialogue: 0,0:58:59.32,0:59:02.62,English,,0,0,0,,Okay so we you can think of a cache on
Dialogue: 0,0:59:03.92,0:59:11.28,English,,0,0,0,,One way to think of a cache is imagine your backpack when you're getting ready to come to school in the morning
Dialogue: 0,0:59:11.94,0:59:15.02,English,,0,0,0,,So you're in your apartment which is kind of far away from school
Dialogue: 0,0:59:16.40,0:59:20.24,English,,0,0,0,,So before you come into school you take items from from your house
Dialogue: 0,0:59:20.72,0:59:23.02,English,,0,0,0,,And you put them in your backpack right
Dialogue: 0,0:59:24.08,0:59:28.92,English,,0,0,0,,Then you come to school if you need those items you get there in your backpack
Dialogue: 0,0:59:29.56,0:59:30.92,English,,0,0,0,,You know if you didn't do that
Dialogue: 0,0:59:31.20,0:59:35.88,English,,0,0,0,,Every time you needed something you'd have to walk back home and get it  and then walk back to school
Dialogue: 0,0:59:36.44,0:59:41.24,English,,0,0,0,,All right so it's so the idea of caching is very you know it's a very familiar kind of simple notion
Dialogue: 0,0:59:41.58,0:59:47.28,English,,0,0,0,,But it turns out to be quite powerful and it shows up in all parts of computer systems
Dialogue: 0,0:59:50.56,0:59:54.44,English,,0,0,0,,Okay so so what we say is that for each level k in the hierarchy
Dialogue: 0,0:59:55.08,0:59:58.94,English,,0,0,0,,The the faster smaller device at level k serves as a cache
Dialogue: 0,0:59:59.50,1:00:02.67,English,,0,0,0,,For the larger slower device at level k+1
Dialogue: 0,1:00:03.26,1:00:07.46,English,,0,0,0,,And remember our our levels go from so l0 is the highest
Dialogue: 0,1:00:07.46,1:00:10.60,English,,0,0,0,,So this the smallest lowest level is actually the highest
Dialogue: 0,1:00:11.56,1:00:15.36,English,,0,0,0,,The further step in the cat in the hierarchy and as we increase the levels
Dialogue: 0,1:00:15.84,1:00:17.60,English,,0,0,0,,We're going down the hierarchy
Dialogue: 0,1:00:20.44,1:00:25.22,English,,0,0,0,,Now why do they work so this is this is a really fundamental idea
Dialogue: 0,1:00:25.88,1:00:27.42,English,,0,0,0,,They work because of locality
Dialogue: 0,1:00:28.84,1:00:34.72,English,,0,0,0,,So because of locality programs tend to access data that's stored at level k
Dialogue: 0,1:00:36.28,1:00:39.32,English,,0,0,0,,More often than they access data at level k+1 o
Dialogue: 0,1:00:41.06,1:00:43.86,English,,0,0,0,,Okay so if we access an item at level +1
Dialogue: 0,1:00:44.82,1:00:50.35,English,,0,0,0,,We can move it up to level k chances are because of locality we're going to access it again
Dialogue: 0,1:00:51.26,1:01:01.30,English,,0,0,0,,Okay so now we're accessing the data at level k multiple times at the rate at the speed of love
Dialogue: 0,1:01:01.44,1:01:03.74,English,,0,0,0,,Okay not at the speed of level k plus one okay so that's
Dialogue: 0,1:01:04.60,1:01:08.48,English,,0,0,0,,That's the fun the fundal fundamental idea
Dialogue: 0,1:01:08.60,1:01:12.46,English,,0,0,0,,And because we're not accessing data at level +1 as often
Dialogue: 0,1:01:12.76,1:01:18.14,English,,0,0,0,,We can afford to use slower storage devices which are cheaper
Dialogue: 0,1:01:20.80,1:01:24.22,English,,0,0,0,,In this and thus we can make them bigger and cheaper per gig
Dialogue: 0,1:01:26.30,1:01:29.98,English,,0,0,0,,So what this does is the hierarchy creates a a large pool of storage
Dialogue: 0,1:01:30.06,1:01:33.06,English,,0,0,0,,That's roughly about the size of the lowest level
Dialogue: 0,1:01:34.42,1:01:37.10,English,,0,0,0,,That can be accessed at the speed at the highest level
Dialogue: 0,1:01:41.88,1:01:45.60,English,,0,0,0,,All right let's let's look at how caching works in a general way
Dialogue: 0,1:01:46.34,1:01:51.20,English,,0,0,0,,And then we'll see on thursday how these hardware cache memories work
Dialogue: 0,1:01:51.56,1:01:57.80,English,,0,0,0,,Okay but like I said caching is a very general idea that can be applied at all levels in the hierarchy
Dialogue: 0,1:01:59.04,1:02:05.68,English,,0,0,0,,So here we have a cache - so the in all kinds of most caches there's some kind of transfer unit
Dialogue: 0,1:02:06.86,1:02:08.72,English,,0,0,0,,To go from one level to the next
Dialogue: 0,1:02:08.72,1:02:13.94,English,,0,0,0,,So here we have at this at this upper level
Dialogue: 0,1:02:14.76,1:02:18.86,English,,0,0,0,,We have a what we'll call the cache that can hold four blocks
Dialogue: 0,1:02:19.56,1:02:23.76,English,,0,0,0,,So our our memory and then at the lower level we have memory
Dialogue: 0,1:02:24.76,1:02:28.90,English,,0,0,0,,And this memory is partitioned into blocks of some fixed size that's this
Dialogue: 0,1:02:29.84,1:02:36.36,English,,0,0,0,,That's the way cache is at nearly near the upper part of the hierarchy work
Dialogue: 0,1:02:37.02,1:02:43.58,English,,0,0,0,,Now at the lower levels like if you're accessing data say from a web server
Dialogue: 0,1:02:43.92,1:02:47.40,English,,0,0,0,,Then the the data is partitioned into files typically
Dialogue: 0,1:02:47.40,1:02:53.14,English,,0,0,0,,Okay but it upper levels the data is partitioned into blocks so just suppose this is main memory
Dialogue: 0,1:02:54.08,1:02:58.68,English,,0,0,0,,And then above that we have a that consists of a bunch of these blocks
Dialogue: 0,1:02:58.68,1:03:05.84,English,,0,0,0,,So we just take the memory and partition into blocks where each block is the same number of bytes
Dialogue: 0,1:03:07.84,1:03:12.74,English,,0,0,0,,And then data will be transferred between memory and the cache in block size transfer units
Dialogue: 0,1:03:13.34,1:03:18.68,English,,0,0,0,,Okay so if you need data from the memory if the cache needs data from the memory it'll grab a whole block
Dialogue: 0,1:03:19.96,1:03:26.12,English,,0,0,0,,And then at any point in time the cache holds a subset of the the blocks in main memory
Dialogue: 0,1:03:27.56,1:03:33.16,English,,0,0,0,,Okay so this this cache is much faster but it's also much slower
Dialogue: 0,1:03:35.78,1:03:38.58,English,,0,0,0,,And because of that and it's much smaller
Dialogue: 0,1:03:39.50,1:03:44.78,English,,0,0,0,,I'm sorry it's much faster but it's it's much more expensive because it's faster it's more expensive
Dialogue: 0,1:03:45.20,1:03:47.32,English,,0,0,0,,And because it's more expensive it's smaller
Dialogue: 0,1:03:51.98,1:04:01.30,English,,0,0,0,,Now suppose the cash once de-reference say that the CPU asks for data that's contained in block four
Dialogue: 0,1:04:04.80,1:04:08.90,English,,0,0,0,,So it looks it looks to see if the data is in the cache it's not
Dialogue: 0,1:04:08.90,1:04:12.06,English,,0,0,0,,So the cache asks the memory to give it block four
Dialogue: 0,1:04:13.20,1:04:17.16,English,,0,0,0,,So that block is copied from memory into the cache
Dialogue: 0,1:04:17.80,1:04:22.58,English,,0,0,0,,Overwriting the one of the existing in this case block eight it will overwrite blockade
Dialogue: 0,1:04:22.58,1:04:26.36,English,,0,0,0,,So now now block four is is in our cache
Dialogue: 0,1:04:28.56,1:04:35.36,English,,0,0,0,,Now suppose now now suppose the CPU s for a some data that's in block ten
Dialogue: 0,1:04:35.94,1:04:39.90,English,,0,0,0,,That gets copied up and and we overwrite that that block
Dialogue: 0,1:04:41.00,1:04:46.70,English,,0,0,0,,Now the whole idea of storing it in the cache is that we're hoping that the seek the program that's executing on the CPU
Dialogue: 0,1:04:47.14,1:04:49.80,English,,0,0,0,,Will reuse one of those blocks we just spent all the time
Dialogue: 0,1:04:50.26,1:04:55.78,English,,0,0,0,,We went to all this trouble to copy it from memory to to this cache  and we know that's slow
Dialogue: 0,1:04:58.38,1:05:06.78,English,,0,0,0,,So now suppose that the CPU needs some data in block  b in this case fourteen
Dialogue: 0,1:05:08.92,1:05:16.60,English,,0,0,0,,Okay so it needs it needs a we're a memory word that's stored that was originally stored in memory it in block fourteen
Dialogue: 0,1:05:18.38,1:05:23.44,English,,0,0,0,,Well now this cache can just return that's what we call a hit right so the
Dialogue: 0,1:05:23.56,1:05:28.04,English,,0,0,0,,Block that we access is in the cache so that's good hits are good
Dialogue: 0,1:05:28.50,1:05:33.08,English,,0,0,0,,Because now we can return that block directly to CPU
Dialogue: 0,1:05:33.76,1:05:39.92,English,,0,0,0,,And this this memory is much faster than if we had to go all the way to main memory to the DRAM
Dialogue: 0,1:05:40.16,1:05:43.16,English,,0,0,0,,Okay so the SRAM much faster than the DRAM
Dialogue: 0,1:05:43.74,1:05:47.90,English,,0,0,0,,So the CPU gets that block fourteen much faster than it would have
Dialogue: 0,1:05:48.26,1:05:49.86,English,,0,0,0,,If it had just gone all the way to memory
Dialogue: 0,1:05:51.56,1:05:56.58,English,,0,0,0,,Okay the sort of other the the opposite of a hit is a miss
Dialogue: 0,1:05:57.84,1:06:00.40,English,,0,0,0,,So suppose the CPU s for block twelve
Dialogue: 0,1:06:01.62,1:06:04.32,English,,0,0,0,,The cache looks for that block can't find it
Dialogue: 0,1:06:04.98,1:06:10.84,English,,0,0,0,,That's a miss so the the cash has to ask that the main memory the DRAM for block 12
Dialogue: 0,1:06:11.52,1:06:14.56,English,,0,0,0,,Where it gets copied into the cache and then it can return that
Dialogue: 0,1:06:16.58,1:06:22.56,English,,0,0,0,,So that takes longer right so the CPU has to wait for that block to be ex to be fetched from memory
Dialogue: 0,1:06:23.08,1:06:26.18,English,,0,0,0,,And so misses are slow so hits are good because they're fast
Dialogue: 0,1:06:26.84,1:06:28.90,English,,0,0,0,,Misses are bad because they're they're slow
Dialogue: 0,1:06:31.44,1:06:36.40,English,,0,0,0,,Now we typically distinguish between several different kinds of caches
Dialogue: 0,1:06:37.32,1:06:40.94,English,,0,0,0,,So the first kind of miss is a cold miss or a compulsory miss
Dialogue: 0,1:06:41.78,1:06:44.76,English,,0,0,0,,Which is caused because there's just nothing in the cache
Dialogue: 0,1:06:44.98,1:06:48.48,English,,0,0,0,,Initially caches they're empty they have no blocks and as we fetch
Dialogue: 0,1:06:49.44,1:06:53.84,English,,0,0,0,,As we fetch blocks from the lower level from the next the next level and put them in the cache
Dialogue: 0,1:06:54.68,1:06:57.00,English,,0,0,0,,The cache will slowly fill up with blocks
Dialogue: 0,1:06:57.64,1:07:00.06,English,,0,0,0,,And we'll get and that will increase the likelihood of hits
Dialogue: 0,1:07:00.62,1:07:03.58,English,,0,0,0,,But when the cache is empty we're going to miss every time right
Dialogue: 0,1:07:03.58,1:07:07.04,English,,0,0,0,,So there's just no way to avoid cold misses right you got
Dialogue: 0,1:07:07.46,1:07:11.28,English,,0,0,0,,Oh so this is called warming up your cache so as you load data items into the cache
Dialogue: 0,1:07:11.88,1:07:17.66,English,,0,0,0,,Initially it's cold and as you add more items you're warming it up meaning that you're increasing the likelihood of a hit
Dialogue: 0,1:07:19.18,1:07:29.56,English,,0,0,0,,Now there's a there's another sort of symmetric kind of miss which is called a capacity miss
Dialogue: 0,1:07:30.22,1:07:35.48,English,,0,0,0,,And these misses are due to the fact that the cache is just a certain size right you just can't
Dialogue: 0,1:07:35.96,1:07:38.28,English,,0,0,0,,In the example we looked at we only had four blocks
Dialogue: 0,1:07:39.96,1:07:48.04,English,,0,0,0,,So if we're if we're trying if our if our if our temporal locality involves eight blocks
Dialogue: 0,1:07:48.94,1:07:54.10,English,,0,0,0,,You know say if the loop that we're accessing is  is accessing elements in array
Dialogue: 0,1:07:55.42,1:08:00.96,English,,0,0,0,,That that consists of eight blocks there's just not enough room to store eight blocks and that four block cache
Dialogue: 0,1:08:01.44,1:08:07.52,English,,0,0,0,,So we're going to get misses right we would need a bigger cache to be able to satisfy and store those eight blocks
Dialogue: 0,1:08:08.02,1:08:13.40,English,,0,0,0,,And if we had a big enough cache then we get good hit rate right if we could store all the blocks
Dialogue: 0,1:08:14.42,1:08:23.02,English,,0,0,0,,In our cache then we then then the cache could take advantage of the spatial and temporal locality within that program
Dialogue: 0,1:08:24.00,1:08:28.96,English,,0,0,0,,So in general what we call this set of blocks at any point in time when a program is running
Dialogue: 0,1:08:29.50,1:08:34.73,English,,0,0,0,,We call the set of blocks that are sort of being accessed over and over again the working set
Dialogue: 0,1:08:35.48,1:08:42.14,English,,0,0,0,,And so your working set and the working set will change you know as you go from loop to loop  from function to function
Dialogue: 0,1:08:42.74,1:08:45.41,English,,0,0,0,,But at a point in time in your program when
Dialogue: 0,1:08:46.28,1:08:51.30,English,,0,0,0,,It you have this idea of a working set which is sort of the blocks that you need to have stored in your cache
Dialogue: 0,1:08:54.00,1:08:59.28,English,,0,0,0,,Ok and well so when you're working set size exceeds your cache size then you get capacity misses
Dialogue: 0,1:09:00.36,1:09:04.12,English,,0,0,0,,There's this other kind of weird miss called the conflict miss
Dialogue: 0,1:09:04.88,1:09:08.24,English,,0,0,0,,Which has to do with the way that caches are often implemented
Dialogue: 0,1:09:09.52,1:09:15.88,English,,0,0,0,,So the idea is that most caches especially hardware caches because they're they have to be simple
Dialogue: 0,1:09:17.42,1:09:23.50,English,,0,0,0,,They have they limit where a block can be placed to some
Dialogue: 0,1:09:24.26,1:09:27.22,English,,0,0,0,,Small set of positions in the cache
Dialogue: 0,1:09:28.50,1:09:32.04,English,,0,0,0,,So like one of the the simplest models is to just take
Dialogue: 0,1:09:33.00,1:09:39.94,English,,0,0,0,,Block I can only be placed in block I mod the cache size
Dialogue: 0,1:09:40.12,1:09:43.75,English,,0,0,0,,So in our that that little cache we saw that had four blocks
Dialogue: 0,1:09:44.56,1:09:50.26,English,,0,0,0,,We would take we would take block I from memory and we would stick it at block I mod 4
Dialogue: 0,1:09:50.26,1:09:54.02,English,,0,0,0,,So block 0 would go at block 0 in our cache
Dialogue: 0,1:09:55.00,1:10:03.42,English,,0,0,0,,As would block 4 and as would block 8 block 9 would go into block 1 in the cache
Dialogue: 0,1:10:03.92,1:10:13.84,English,,0,0,0,,And that's when that happens suppose suppose we use that model so we're going to take
Dialogue: 0,1:10:14.82,1:10:18.50,English,,0,0,0,,Block I and we're going to put it we can only place it in the cache
Dialogue: 0,1:10:19.28,1:10:21.60,English,,0,0,0,,At block I mod 4
Dialogue: 0,1:10:22.94,1:10:30.40,English,,0,0,0,,Now suppose our suppose our reference pattern involves from memory block zero block four and block eight
Dialogue: 0,1:10:31.68,1:10:36.22,English,,0,0,0,,It's only three blocks so we have we have enough room in the cache to store
Dialogue: 0,1:10:37.32,1:10:43.46,English,,0,0,0,,Those three blocks but because of the way we've decided to place blocks each block will be will evict
Dialogue: 0,1:10:44.36,1:10:48.82,English,,0,0,0,,When we access block four it'll go into block zero in the cache
Dialogue: 0,1:10:50.16,1:10:52.16,English,,0,0,0,,When we access blocked four in the cache
Dialogue: 0,1:10:52.84,1:10:56.92,English,,0,0,0,,It'll overwrite that block and it'll go into block zero in the cache
Dialogue: 0,1:10:57.42,1:11:04.08,English,,0,0,0,,And so because of this it's really the access pattern conspiring with the  algorithm
Dialogue: 0,1:11:04.08,1:11:05.58,English,,0,0,0,,That we're using for placing blocks
Dialogue: 0,1:11:06.92,1:11:09.42,English,,0,0,0,,Okay so because of this we have plenty of room in the cache
Dialogue: 0,1:11:09.86,1:11:15.74,English,,0,0,0,,But because of this sort of the access pattern conspiring with the placement algorithm
Dialogue: 0,1:11:16.08,1:11:17.48,English,,0,0,0,,We get misses every time
Dialogue: 0,1:11:19.54,1:11:25.14,English,,0,0,0,,We'll see how we'll see how conflict marisa's work in detail when we study your caches tomorrow
Dialogue: 0,1:11:28.24,1:11:31.59,English,,0,0,0,,So
Dialogue: 0,1:11:32.10,1:11:36.62,English,,0,0,0,,So this is these these caches exist everywhere in the memory hierarchy and
Dialogue: 0,1:11:38.42,1:11:41.96,English,,0,0,0,,So all of them are caches of one form or another right
Dialogue: 0,1:11:42.66,1:11:45.64,English,,0,0,0,,So you can think of the registers as a type of cache
Dialogue: 0,1:11:46.28,1:11:48.52,English,,0,0,0,,What are they cache for eight byte words
Dialogue: 0,1:11:49.64,1:11:53.14,English,,0,0,0,,Okay where's it cached it's cached right on the CPU itself
Dialogue: 0,1:11:54.56,1:11:58.92,English,,0,0,0,,What's the latency it's instant and happens within an instruction
Dialogue: 0,1:12:00.20,1:12:03.46,English,,0,0,0,,And then who manages the cache somebody has to manage the cache when
Dialogue: 0,1:12:03.86,1:12:07.50,English,,0,0,0,,When when there's a request to load an item from the lower level in the hierarchy
Dialogue: 0,1:12:08.08,1:12:12.60,English,,0,0,0,,Something has to decide what to do with that where to put it in the cache that's called managing the cache
Dialogue: 0,1:12:13.40,1:12:16.52,English,,0,0,0,,Well in this case the compiler manages the cache
Dialogue: 0,1:12:17.08,1:12:21.42,English,,0,0,0,,When you when you compile your C code the compiler figures out which register
Dialogue: 0,1:12:21.96,1:12:24.44,English,,0,0,0,,Data items from memory are going to go into okay
Dialogue: 0,1:12:25.08,1:12:32.84,English,,0,0,0,,So tlb this is something this is a cache that's used in virtual memory
Dialogue: 0,1:12:33.78,1:12:37.40,English,,0,0,0,,Then there's these hardware caches called l1 and l2 caches
Dialogue: 0,1:12:38.32,1:12:43.04,English,,0,0,0,,So they store 64 byte blocks on modern Intel systems
Dialogue: 0,1:12:43.86,1:12:50.18,English,,0,0,0,,And they're cached on the CPU chip itself in in s ramps that are built right into the CPU chip
Dialogue: 0,1:12:51.44,1:12:58.23,English,,0,0,0,,And depending on whether l1 caches to on core i7s have a latency of 4 cycles
Dialogue: 0,1:12:58.68,1:13:01.14,English,,0,0,0,,And l2 has a latency of 10 cycles
Dialogue: 0,1:13:02.28,1:13:04.64,English,,0,0,0,,And both of these are managed by hardware
Dialogue: 0,1:13:05.44,1:13:11.60,English,,0,0,0,,So when you when the CPU fetches an item from the l1 cache hardware figure finds it
Dialogue: 0,1:13:12.40,1:13:17.74,English,,0,0,0,,And if there's a miss and a block is loaded from l2 hardware in the l1 cache figures out where to put it
Dialogue: 0,1:13:17.88,1:13:22.48,English,,0,0,0,,Ok so all this is done without any intervention by hardware
Dialogue: 0,1:13:24.80,1:13:28.82,English,,0,0,0,,Disks contain buffer operating systems maintain buffer caches
Dialogue: 0,1:13:29.54,1:13:32.10,English,,0,0,0,,So in this case what's cached is portions of files
Dialogue: 0,1:13:33.50,1:13:36.34,English,,0,0,0,,Ok and they're cached in main memory
Dialogue: 0,1:13:37.16,1:13:42.42,English,,0,0,0,,And latency to 2 main memories about a hundred cycles or so
Dialogue: 0,1:13:43.60,1:13:45.76,English,,0,0,0,,And these are managed by the operating system
Dialogue: 0,1:13:46.32,1:13:51.34,English,,0,0,0,,So the operating system reserves a portion of memory to store files that you've loaded so
Dialogue: 0,1:13:52.30,1:13:56.46,English,,0,0,0,,So the operating system exploits locality if you if you read a file
Dialogue: 0,1:13:57.64,1:14:03.54,English,,0,0,0,,And then start reading referencing bytes from that file it will actually be served from the
Dialogue: 0,1:14:03.92,1:14:06.42,English,,0,0,0,,File cache and it won't go out to disk
Dialogue: 0,1:14:08.40,1:14:16.66,English,,0,0,0,,Network networks maintain caches like things like nfs and afs maintain local caches on disk
Dialogue: 0,1:14:17.92,1:14:23.64,English,,0,0,0,,Your browser has a cache so when it fetches files from from servers
Dialogue: 0,1:14:23.94,1:14:27.88,English,,0,0,0,,It stores those files locally on disk so if you reference those web pages again
Dialogue: 0,1:14:28.10,1:14:31.84,English,,0,0,0,,They're served from from your local disk rather than going all the way across the network
Dialogue: 0,1:14:33.16,1:14:39.60,English,,0,0,0,,Ok so the point is that these caches exist everywhere in the memory hierarchy
Dialogue: 0,1:14:39.86,1:14:43.84,English,,0,0,0,,And they're all based on the same principles they're just implemented in different ways
Dialogue: 0,1:14:46.78,1:14:50.42,English,,0,0,0,,Ok so just to summarize what we've what we've done today
Dialogue: 0,1:14:51.82,1:14:57.12,English,,0,0,0,,We've seen that there's there's a gap between the CPU and our storage devices that continues to increase
Dialogue: 0,1:14:58.38,1:15:02.90,English,,0,0,0,,We've seen that well-written programs have this property called locality
Dialogue: 0,1:15:03.86,1:15:08.98,English,,0,0,0,,And we've seen that caching by taking by using caching
Dialogue: 0,1:15:08.98,1:15:12.80,English,,0,0,0,,We can build a memory hierarchy that takes advantage of locality and programs
Dialogue: 0,1:15:13.66,1:15:19.70,English,,0,0,0,,And allows us to build storage systems that where we can access data at the rate of the fastest device
Dialogue: 0,1:15:20.36,1:15:25.14,English,,0,0,0,,But at the cost and capacity of the devices at the the lowest level
Dialogue: 0,1:15:26.28,1:15:35.48,English,,0,0,0,,Ok so thursday we're going to look at a very specific part of the hierarchy called cache memories
