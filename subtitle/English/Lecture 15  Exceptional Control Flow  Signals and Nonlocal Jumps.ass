[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 845
Active Line: 858
Video Position: 142535

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.94,English,,0,0,0,,Good afternoon everybody welcome
Dialogue: 0,0:00:02.86,0:00:03.68,English,,0,0,0,,Good to see you
Dialogue: 0,0:00:05.02,0:00:08.52,English,,0,0,0,,Today we're going to continue our study of exceptional control flow
Dialogue: 0,0:00:09.56,0:00:16.24,English,,0,0,0,,By looking at some higher level mechanisms known as Linux signals and C nonlocal jumps
Dialogue: 0,0:00:16.90,0:00:21.42,English,,0,0,0,,Now we're going to spend most of our time looking at signals
Dialogue: 0,0:00:21.62,0:00:26.60,English,,0,0,0,,Because they have a lot of subtleties the semantics can be kind of confusing
Dialogue: 0,0:00:26.60,0:00:28.62,English,,0,0,0,,So we're going to we're going to spend most of our time there
Dialogue: 0,0:00:29.36,0:00:33.70,English,,0,0,0,,And I'll mention the idea of nonlocal jumps but
Dialogue: 0,0:00:36.08,0:00:38.70,English,,0,0,0,,For details on those you'll want to look in your textbook
Dialogue: 0,0:00:38.84,0:00:43.40,English,,0,0,0,,And in the slides at the supplemental slides at the end of this the slide deck
Dialogue: 0,0:00:45.64,0:00:48.06,English,,0,0,0,,Now to motivate the notion of signals
Dialogue: 0,0:00:49.00,0:00:54.40,English,,0,0,0,,I want to talk a little bit about shell programs
Dialogue: 0,0:00:56.08,0:01:01.54,English,,0,0,0,,Now as we mentioned last time there's only one way to create processes on a Linux system
Dialogue: 0,0:01:01.56,0:01:03.24,English,,0,0,0,,And that's using the fork call
Dialogue: 0,0:01:04.14,0:01:09.84,English,,0,0,0,,In fact the all of the processes on the system actually form a hierarchy
Dialogue: 0,0:01:09.88,0:01:15.68,English,,0,0,0,,So that the very first process created when you boot the system up is the init process
Dialogue: 0,0:01:16.08,0:01:17.92,English,,0,0,0,,Which has a process id of 1
Dialogue: 0,0:01:18.48,0:01:23.81,English,,0,0,0,,And then all other processes on the system are descendants of that of that init process
Dialogue: 0,0:01:24.68,0:01:29.04,English,,0,0,0,,Now the init process when it starts up it creates daemons
Dialogue: 0,0:01:29.76,0:01:33.38,English,,0,0,0,,Which are long-running programs that provide services typically
Dialogue: 0,0:01:33.42,0:01:41.44,English,,0,0,0,,So for example web server it other kinds of services that you always want running on the system
Dialogue: 0,0:01:42.26,0:01:45.90,English,,0,0,0,,And then eventually it creates login so called login shells
Dialogue: 0,0:01:46.50,0:01:49.34,English,,0,0,0,,Which provide the command-line interface to users
Dialogue: 0,0:01:50.10,0:01:52.48,English,,0,0,0,,So when you login a Linux system
Dialogue: 0,0:01:53.10,0:01:55.84,English,,0,0,0,,What you eventually get to is a login shell
Dialogue: 0,0:01:56.12,0:01:58.98,English,,0,0,0,,That's expecting you to type commands
Dialogue: 0,0:02:01.72,0:02:07.36,English,,0,0,0,,Now the login shells execute programs on your behalf
Dialogue: 0,0:02:08.52,0:02:11.92,English,,0,0,0,,So when we type something into the shell
Dialogue: 0,0:02:13.00,0:02:21.62,English,,0,0,0,,Say we type the ls command we're asking the shell to run the executable program called ls
Dialogue: 0,0:02:22.80,0:02:25.68,English,,0,0,0,,And so what the shell will do,is it will create a child
Dialogue: 0,0:02:26.38,0:02:30.16,English,,0,0,0,,And then it will execute ls within that child process
Dialogue: 0,0:02:31.12,0:02:37.28,English,,0,0,0,,And it's possible that that process may create other child processes
Dialogue: 0,0:02:40.36,0:02:44.34,English,,0,0,0,,So a shell is an application program no different from any other program
Dialogue: 0,0:02:45.02,0:02:47.78,English,,0,0,0,,That executes programs on the behalf of users
Dialogue: 0,0:02:49.62,0:02:52.56,English,,0,0,0,,Okay the default shell for Linux is called bash
Dialogue: 0,0:02:52.72,0:03:01.66,English,,0,0,0,,But there's other shells that that were created on earlier with earlier versions of UNIX
Dialogue: 0,0:03:02.26,0:03:07.38,English,,0,0,0,,Sh was the original shell called the Bourne shell because it was created by Stephen Bourne
Dialogue: 0,0:03:07.82,0:03:10.26,English,,0,0,0,,And when Berkeley came out with their distribution of UNIX
Dialogue: 0,0:03:10.72,0:03:13.18,English,,0,0,0,,They created a shell called the csh
Dialogue: 0,0:03:14.68,0:03:21.90,English,,0,0,0,,Now the execution is in a shell is a sequence of read and evaluate steps
Dialogue: 0,0:03:22.80,0:03:24.96,English,,0,0,0,,So first a shell prints out a prompt
Dialogue: 0,0:03:25.84,0:03:30.96,English,,0,0,0,,And then it waits for it waits for you to type something in on the command line and hit return
Dialogue: 0,0:03:32.24,0:03:38.14,English,,0,0,0,,Okay and typically what you're typing in is a command which is just the
Dialogue: 0,0:03:38.74,0:03:44.10,English,,0,0,0,,So the first thing you type is a command and then you follow that with optional arguments separated by spaces
Dialogue: 0,0:03:44.90,0:03:50.90,English,,0,0,0,,Okay so once you hit once you type in a command and those optional arguments and hit return
Dialogue: 0,0:03:51.72,0:04:00.36,English,,0,0,0,,The shell checks for the end of file character which is a ctrl-d to terminal
Dialogue: 0,0:04:00.60,0:04:04.56,English,,0,0,0,,And if so it exits otherwise it evaluates that command line
Dialogue: 0,0:04:05.46,0:04:06.96,English,,0,0,0,,And the evaluation consists
Dialogue: 0,0:04:10.48,0:04:14.14,English,,0,0,0,,And then when it returns from the evaluation it just does the same thing over in it
Dialogue: 0,0:04:14.66,0:04:21.40,English,,0,0,0,,Now the evaluation consists of the following kinds of steps first
Dialogue: 0,0:04:22.50,0:04:24.18,English,,0,0,0,,It parses the command line
Dialogue: 0,0:04:25.92,0:04:32.76,English,,0,0,0,,And in the process so it takes the command-line which in this example is in buff
Dialogue: 0,0:04:33.10,0:04:37.46,English,,0,0,0,,And it produces argv array okay where argv[0] is a command
Dialogue: 0,0:04:37.92,0:04:41.16,English,,0,0,0,,And then argv[1] and argv[2] and so on are the optional arguments
Dialogue: 0,0:04:42.82,0:04:48.24,English,,0,0,0,,And the convention in a shell is that if the command line is terminated
Dialogue: 0,0:04:49.56,0:04:55.14,English,,0,0,0,,By an ampersand then you're asking the shell to run that job,to run that command in the background
Dialogue: 0,0:04:56.02,0:04:58.18,English,,0,0,0,,Meaning the shell won't wait for that job to finish
Dialogue: 0,0:04:58.78,0:05:00.68,English,,0,0,0,,Before it goes through its next read stub
Dialogue: 0,0:05:01.44,0:05:05.72,English,,0,0,0,,If the line that you type doesn't have an ampersand
Dialogue: 0,0:05:05.72,0:05:10.38,English,,0,0,0,,Then you're asking the shell to run that job in the foreground which means the shell will wait
Dialogue: 0,0:05:13.56,0:05:19.38,English,,0,0,0,,So first we parse this command line into an argv array
Dialogue: 0,0:05:19.42,0:05:25.46,English,,0,0,0,,And we return whether or not it was terminated by an ampersand, so bg for background
Dialogue: 0,0:05:26.42,0:05:31.90,English,,0,0,0,,If argv[0] is null then that means we just hit a we just hit return right so as an empty line
Dialogue: 0,0:05:32.58,0:05:35.04,English,,0,0,0,,So we'll just return and just ignore those
Dialogue: 0,0:05:36.54,0:05:41.66,English,,0,0,0,,Now a shell also implements what are called built-in commands
Dialogue: 0,0:05:41.90,0:05:47.36,English,,0,0,0,,So various things like jobs bg, fg
Dialogue: 0,0:05:47.82,0:05:51.96,English,,0,0,0,,Are examples of built-in commands which are just implemented in the shell itself
Dialogue: 0,0:05:53.14,0:05:55.32,English,,0,0,0,,So if you type...if the first thing you type
Dialogue: 0,0:05:56.20,0:05:58.48,English,,0,0,0,,If the command you enter is a built in
Dialogue: 0,0:05:59.24,0:06:06.02,English,,0,0,0,,Then the shell will check that,it will check argv[0] for a to see if it's a built-in command
Dialogue: 0,0:06:06.64,0:06:11.70,English,,0,0,0,,And if it is it'll just execute it whatever it is you asked it to do
Dialogue: 0,0:06:13.76,0:06:20.14,English,,0,0,0,,Okay otherwise if it's not a built-in then that means that you're asking the shell to run some program
Dialogue: 0,0:06:22.42,0:06:24.92,English,,0,0,0,,Okay so in that case the shell will fork a child
Dialogue: 0,0:06:26.34,0:06:31.60,English,,0,0,0,,And then the child will execute that program by calling execve
Dialogue: 0,0:06:32.98,0:06:35.50,English,,0,0,0,,Passing as the first argument the name of the command
Dialogue: 0,0:06:36.18,0:06:41.24,English,,0,0,0,,And as the second and third argv and and the environment respectively
Dialogue: 0,0:06:42.10,0:06:46.86,English,,0,0,0,,Now execve if you recall from last time never returns unless there's an error
Dialogue: 0,0:06:47.37,0:06:51.48,English,,0,0,0,,So it checks so we check it the return value for execve
Dialogue: 0,0:06:52.70,0:06:56.98,English,,0,0,0,,And if it returns less than zero fact the only time it will return
Dialogue: 0,0:06:57.54,0:07:01.90,English,,0,0,0,,If it does return it will always return -1
Dialogue: 0,0:07:02.32,0:07:04.56,English,,0,0,0,,But we're just being careful here
Dialogue: 0,0:07:05.24,0:07:12.32,English,,0,0,0,,So we check that for an error and in print and error message if we find an error and then exit
Dialogue: 0,0:07:15.26,0:07:22.06,English,,0,0,0,,So once the parent gets control again
Dialogue: 0,0:07:22.76,0:07:25.20,English,,0,0,0,,Then it waits for that foreground job to terminate
Dialogue: 0,0:07:26.22,0:07:28.52,English,,0,0,0,,Okay so if it's not a background job
Dialogue: 0,0:07:29.30,0:07:32.18,English,,0,0,0,,Then it waits for it to terminate by calling waitpid
Dialogue: 0,0:07:33.34,0:07:38.70,English,,0,0,0,,And waiting for that child that foreground job to terminate and then and reaping it
Dialogue: 0,0:07:39.44,0:07:43.96,English,,0,0,0,,Otherwise if it's a background job it just prints say a message and goes on
Dialogue: 0,0:07:44.82,0:07:46.44,English,,0,0,0,,So this is really interesting right that
Dialogue: 0,0:07:46.74,0:07:50.98,English,,0,0,0,,There's really the only difference between a foreground job and a background job is just that the shell
Dialogue: 0,0:07:51.76,0:07:53.62,English,,0,0,0,,Does a waitpid on that job or not
Dialogue: 0,0:07:54.02,0:07:57.46,English,,0,0,0,,Right so there otherwise there's really no difference
Dialogue: 0,0:07:58.78,0:08:03.68,English,,0,0,0,,Now what's the problem? there's a problem with our example show
Dialogue: 0,0:08:05.88,0:08:09.88,English,,0,0,0,,And that the problem is that we're doing the right thing for the foreground job
Dialogue: 0,0:08:10.40,0:08:13.72,English,,0,0,0,,We always have to reap these children so they they so that
Dialogue: 0,0:08:15.10,0:08:17.54,English,,0,0,0,,They're their state can be released
Dialogue: 0,0:08:19.82,0:08:23.62,English,,0,0,0,,But we're not doing anything to reap any background jobs
Dialogue: 0,0:08:23.80,0:08:26.78,English,,0,0,0,,Right when if the background job so if not bg
Dialogue: 0,0:08:27.26,0:08:29.38,English,,0,0,0,,We're just printing a message and then we're returning
Dialogue: 0,0:08:30.30,0:08:32.80,English,,0,0,0,,And then we're continuing with this read evaluate step
Dialogue: 0,0:08:33.58,0:08:38.82,English,,0,0,0,,And never going back and and taking care of that background job
Dialogue: 0,0:08:40.40,0:08:44.24,English,,0,0,0,,So this is a problem because that the background job will eventually become
Dialogue: 0,0:08:45.82,0:08:51.46,English,,0,0,0,,If we have enough of those jobs we create a memory leak that could crash the system right so this is an error
Dialogue: 0,0:08:52.36,0:08:53.72,English,,0,0,0,,So what are we going to do about this
Dialogue: 0,0:08:54.38,0:08:59.10,English,,0,0,0,,Well it turns out that exceptional control flow will help us solve this problem
Dialogue: 0,0:09:00.08,0:09:04.72,English,,0,0,0,,And what happens is that the kernel will notify
Dialogue: 0,0:09:05.18,0:09:08.54,English,,0,0,0,,The shell when a any of its children terminate
Dialogue: 0,0:09:09.78,0:09:14.82,English,,0,0,0,,Okay and then the shell can then react to that and issue a waitpid
Dialogue: 0,0:09:15.46,0:09:21.18,English,,0,0,0,,Okay and this notification mechanism that the kernel uses is something called a signal
Dialogue: 0,0:09:25.92,0:09:28.22,English,,0,0,0,,So a signal is a small message
Dialogue: 0,0:09:29.98,0:09:36.82,English,,0,0,0,,That the kernel delivers to a process to notify it that there's been some event in the system
Dialogue: 0,0:09:37.66,0:09:44.18,English,,0,0,0,,Now so this is very similar to the exceptions that we studied the last time
Dialogue: 0,0:09:44.34,0:09:47.52,English,,0,0,0,,Right except it's all implemented in software
Dialogue: 0,0:09:49.12,0:09:53.02,English,,0,0,0,,Now kernel signals are always sent from the kernel
Dialogue: 0,0:09:53.02,0:09:56.38,English,,0,0,0,,But sometimes they're sent at the request of another process
Dialogue: 0,0:09:56.82,0:10:00.42,English,,0,0,0,,Right sometimes the kernel will notice that there's some event
Dialogue: 0,0:10:01.22,0:10:07.06,English,,0,0,0,,Other times another process will ask the kernel to send a message to some other process
Dialogue: 0,0:10:08.52,0:10:11.52,English,,0,0,0,,Now that we say that it's a small message
Dialogue: 0,0:10:12.22,0:10:15.42,English,,0,0,0,,Because the only information that's contained in a signal
Dialogue: 0,0:10:16.00,0:10:18.66,English,,0,0,0,,It's a unique integer id
Dialogue: 0,0:10:19.66,0:10:23.50,English,,0,0,0,,And the fact that it was delivered okay so
Dialogue: 0,0:10:24.34,0:10:27.94,English,,0,0,0,,That's so there's nothing else in a signal except that it arrived
Dialogue: 0,0:10:28.18,0:10:31.88,English,,0,0,0,,And that it has some unique id
Dialogue: 0,0:10:33.04,0:10:37.26,English,,0,0,0,,Now examples of these are the sigint
Dialogue: 0,0:10:37.48,0:10:41.60,English,,0,0,0,,So signals have this ... this unique id and then they also have a name
Dialogue: 0,0:10:44.80,0:10:51.32,English,,0,0,0,,So the sigint is what the when you type ctrl-C at on the command line
Dialogue: 0,0:10:51.64,0:10:56.90,English,,0,0,0,,The kernel sends a signal to every any processes in the foreground
Dialogue: 0,0:10:57.26,0:11:00.52,English,,0,0,0,,And the default action of receiving a sigint is to terminate right
Dialogue: 0,0:11:00.52,0:11:04.06,English,,0,0,0,,So this is how if you're running a foreground job you hit ctrl-c
Dialogue: 0,0:11:04.52,0:11:07.08,English,,0,0,0,,You get the prompt back because it kills that job
Dialogue: 0,0:11:08.36,0:11:13.84,English,,0,0,0,,Sigkill number 9 can be used to kill terminate any program
Dialogue: 0,0:11:15.78,0:11:22.74,English,,0,0,0,,So these two have sigint and sigkill have the same effect on the programs me that they kill the program
Dialogue: 0,0:11:23.02,0:11:30.36,English,,0,0,0,,The the unique aspect of sigkill is that there's no way to ignore it or override it
Dialogue: 0,0:11:30.89,0:11:32.18,English,,0,0,0,,Okay so this is like the failsafe
Dialogue: 0,0:11:33.36,0:11:38.48,English,,0,0,0,,As we'll see there are there are ways to catch and ignore other signals like sigint
Dialogue: 0,0:11:40.22,0:11:43.32,English,,0,0,0,,Sigsegv is the our favorite segment
Dialogue: 0,0:11:43.54,0:11:51.24,English,,0,0,0,,Segmentation violation so if you access a region of memory that's protected or not legal
Dialogue: 0,0:11:52.48,0:11:57.74,English,,0,0,0,,Then your program will ,the kernel will send your that process a sigsegv
Dialogue: 0,0:11:58.46,0:12:06.40,English,,0,0,0,,Okay signal and the default  the default effective that is to terminate the program
Dialogue: 0,0:12:07.08,0:12:11.72,English,,0,0,0,,Sigalrm is a way within your program you can arrange for a signal to be sent to yourself
Dialogue: 0,0:12:12.32,0:12:18.94,English,,0,0,0,,So you can say inside your program send me a sigalrm signal in three seconds
Dialogue: 0,0:12:21.58,0:12:27.00,English,,0,0,0,,So this is a way to do things like you can set up timers,you can set up timeouts like if you want to
Dialogue: 0,0:12:27.60,0:12:32.88,English,,0,0,0,,If you want to set a timeout value and you're doing some some some work and
Dialogue: 0,0:12:33.28,0:12:39.76,English,,0,0,0,,You want to guard against that that work taking exceptionally long time, you can use sigalrm to set a timeout
Dialogue: 0,0:12:40.64,0:12:46.72,English,,0,0,0,,And then a very important one is as we'll see that would be very important for our shell is the sigchild signal
Dialogue: 0,0:12:47.30,0:12:54.48,English,,0,0,0,,Which the kernel sends to a parent every time one of its children terminates or stops
Dialogue: 0,0:12:55.48,0:12:57.90,English,,0,0,0,,Okay so this as we'll see now
Dialogue: 0,0:12:58.44,0:13:02.58,English,,0,0,0,,We'll see this is how we're going...this is how a shell that is going to actually reap
Dialogue: 0,0:13:02.66,0:13:08.40,English,,0,0,0,,It's all of its children right is by taking advantage of the sigchild signal
Dialogue: 0,0:13:09.78,0:13:11.92,English,,0,0,0,,But before I can show you that
Dialogue: 0,0:13:12.46,0:13:18.58,English,,0,0,0,,We need to go through a number of concepts around signals
Dialogue: 0,0:13:20.00,0:13:24.32,English,,0,0,0,,Okay like I said the semantics of signals
Dialogue: 0,0:13:24.74,0:13:27.54,English,,0,0,0,,It's probably one of the thorniest aspects of Linux
Dialogue: 0,0:13:28.94,0:13:40.98,English,,0,0,0,,It was developed very early in the the lifespan of Linux when and it maybe wasn't as clean as it could be right so
Dialogue: 0,0:13:41.44,0:13:47.24,English,,0,0,0,,In order to get a handle on signals we're going to be very careful about defining terms and very careful about the way
Dialogue: 0,0:13:47.62,0:13:48.88,English,,0,0,0,,We talk about them
Dialogue: 0,0:13:50.26,0:13:57.46,English,,0,0,0,,So we say that the kernel sends or delivers a signal to some destination process
Dialogue: 0,0:13:58.52,0:14:04.98,English,,0,0,0,,And it does this by setting some state in the context of the destination process
Dialogue: 0,0:14:05.76,0:14:14.00,English,,0,0,0,,Now nothing happens except that some bits get changed in the destination process context
Dialogue: 0,0:14:14.32,0:14:19.02,English,,0,0,0,,Okay there's no impact of, immediate impact of sending a signal
Dialogue: 0,0:14:22.94,0:14:24.80,English,,0,0,0,,Now a kernel sends a signal
Dialogue: 0,0:14:25.92,0:14:29.68,English,,0,0,0,,Either because it detected some event in the system like
Dialogue: 0,0:14:30.38,0:14:33.02,English,,0,0,0,,That like a child process is terminated for example
Dialogue: 0,0:14:34.66,0:14:41.42,English,,0,0,0,,Or another process has asked the kernel (to send) to deliver a process on a signal on its behalf
Dialogue: 0,0:14:43.38,0:14:47.04,English,,0,0,0,,And there's a number of ways to do that one of them is with the kill system call
Dialogue: 0,0:14:48.88,0:14:51.48,English,,0,0,0,,It's kind of an unfortunate tournament
Dialogue: 0,0:14:52.18,0:14:55.50,English,,0,0,0,,I mean the so kill is a general way to send signals
Dialogue: 0,0:14:56.10,0:15:01.50,English,,0,0,0,,And the impact is sometimes not to kill the program right
Dialogue: 0,0:15:01.52,0:15:04.36,English,,0,0,0,,But for some reason they chose to call it kill
Dialogue: 0,0:15:07.72,0:15:11.70,English,,0,0,0,,Now the destination process receives a signal
Dialogue: 0,0:15:13.08,0:15:20.54,English,,0,0,0,,When it's forced by the kernel to act in some way to react in some way to the delivery of a signal
Dialogue: 0,0:15:22.34,0:15:29.02,English,,0,0,0,,Okay so these are two very different things sending a signal set state in the context of the destination process
Dialogue: 0,0:15:29.84,0:15:36.82,English,,0,0,0,,Receiving a signal is what happens when the destination process is finally
Dialogue: 0,0:15:37.16,0:15:40.90,English,,0,0,0,,Forced by the kernel to act in some way to react in some way
Dialogue: 0,0:15:41.82,0:15:45.70,English,,0,0,0,,Now some possible ways to react are to just ignore the signal
Dialogue: 0,0:15:49.14,0:15:50.46,English,,0,0,0,,Okay to terminate the process
Dialogue: 0,0:15:52.98,0:15:58.50,English,,0,0,0,,Or to catch the signal by executing a user level function called a signal handler
Dialogue: 0,0:15:59.10,0:16:04.18,English,,0,0,0,,So in this case when we catch signals it's very similar to the...
Dialogue: 0,0:16:04.94,0:16:06.38,English,,0,0,0,,And executes a signal handle
Dialogue: 0,0:16:06.38,0:16:13.74,English,,0,0,0,,It's very similar to executing an exception handler in response to some kind of event in the system
Dialogue: 0,0:16:14.20,0:16:17.52,English,,0,0,0,,Now the difference is that exception handlers are in the kernel
Dialogue: 0,0:16:18.18,0:16:21.28,English,,0,0,0,,Signal handlers are actually just in your C code okay there
Dialogue: 0,0:16:22.74,0:16:25.31,English,,0,0,0,,And they execute in your process
Dialogue: 0,0:16:26.86,0:16:34.66,English,,0,0,0,,So the way to think about if we catch a signal by executing a signal handler
Dialogue: 0,0:16:35.20,0:16:37.72,English,,0,0,0,,We have our process executing instructions
Dialogue: 0,0:16:39.00,0:16:41.72,English,,0,0,0,,And then the signal is received by that process
Dialogue: 0,0:16:43.02,0:16:47.10,English,,0,0,0,,So the kernel passes control to a signal handler
Dialogue: 0,0:16:47.10,0:16:55.14,English,,0,0,0,,Which is also just in the code that's executing in the current process, it's just a function in our C code
Dialogue: 0,0:16:56.18,0:17:01.52,English,,0,0,0,,The signal handler runs and when it returns,it eventually returns back to the next instruction
Dialogue: 0,0:17:02.22,0:17:04.00,English,,0,0,0,,And then we continue
Dialogue: 0,0:17:04.24,0:17:08.70,English,,0,0,0,,Okay so it's just like kind of like an interrupt right we just temporarily pause
Dialogue: 0,0:17:09.36,0:17:16.22,English,,0,0,0,,What we're doing in our code to execute this handler before just continuing on
Dialogue: 0,0:17:18.98,0:17:21.16,English,,0,0,0,,Okay now we say that a signal is pending
Dialogue: 0,0:17:21.80,0:17:25.98,English,,0,0,0,,If it's been sent by the kernel but not you have received
Dialogue: 0,0:17:27.98,0:17:34.92,English,,0,0,0,,Okay so if at any given point in time there can only be one pending signal of any particular type
Dialogue: 0,0:17:36.84,0:17:40.70,English,,0,0,0,,Okay so this has very important consequences for using signals
Dialogue: 0,0:17:40.70,0:17:47.32,English,,0,0,0,,Because you can't cue signals up right at any point in time there's there can only be one pending sigchild
Dialogue: 0,0:17:47.66,0:17:51.02,English,,0,0,0,,Signal for example or sigint signal
Dialogue: 0,0:17:51.84,0:17:55.38,English,,0,0,0,,And if a subsequent sigchild signals say is sent
Dialogue: 0,0:17:55.94,0:18:00.51,English,,0,0,0,,It just over writes well you can think of it,it has no impact
Dialogue: 0,0:18:00.78,0:18:04.04,English,,0,0,0,,It's just discarded right if there's already a pending signal
Dialogue: 0,0:18:04.04,0:18:06.66,English,,0,0,0,,So they don't queue up in any meaningful way
Dialogue: 0,0:18:09.58,0:18:12.50,English,,0,0,0,,Now our process can block the receipt of certain signals
Dialogue: 0,0:18:13.62,0:18:16.42,English,,0,0,0,,Okay now it can't stop signals from being delivered
Dialogue: 0,0:18:17.04,0:18:23.76,English,,0,0,0,,But it can stop the process from having to react to the route to that signal when it's received
Dialogue: 0,0:18:27.84,0:18:34.10,English,,0,0,0,,Okay so block signals can be delivered but they won't be received until the signals unblocked
Dialogue: 0,0:18:38.88,0:18:41.30,English,,0,0,0,,And pending signals are received at most once
Dialogue: 0,0:18:46.34,0:18:49.36,English,,0,0,0,,Now the kernel keeps track of these pending and blocked
Dialogue: 0,0:18:49.90,0:18:54.42,English,,0,0,0,,Signals in bit vectors that will call pending and blocked
Dialogue: 0,0:18:55.24,0:18:58.62,English,,0,0,0,,And pending represents the set of pending signals
Dialogue: 0,0:18:58.74,0:19:04.24,English,,0,0,0,,Right where each bit in the pending bit vector corresponds to some particular signal
Dialogue: 0,0:19:04.84,0:19:07.06,English,,0,0,0,,Okay so this is why they can't be queued right because
Dialogue: 0,0:19:08.18,0:19:12.38,English,,0,0,0,,There's only one bit for any signal key,there's only one bit in the bit vector
Dialogue: 0,0:19:12.84,0:19:18.00,English,,0,0,0,,And if we...and when we deliver a signal we're just setting will set that bit the kernel will set that bit
Dialogue: 0,0:19:18.30,0:19:24.26,English,,0,0,0,,We deliver another signal of the same type, it'll just set that bit again which has no effect
Dialogue: 0,0:19:26.80,0:19:32.68,English,,0,0,0,,Now the kernel sets that the bit in pending when the signals delivered and it clears it
Dialogue: 0,0:19:32.80,0:19:34.18,English,,0,0,0,,When the signals received
Dialogue: 0,0:19:35.68,0:19:43.22,English,,0,0,0,,And the kernel also provides mechanism for users to block signals with blocked bit vector
Dialogue: 0,0:19:43.22,0:19:49.34,English,,0,0,0,,So the block bit vector is the same size as the pending bit vector turns out it's just a 32 bit int
Dialogue: 0,0:19:51.86,0:19:54.32,English,,0,0,0,,Okay and it can be set and cleared the bits
Dialogue: 0,0:19:54.46,0:19:58.10,English,,0,0,0,,And that can be set and cleared using the sigprocmask system call
Dialogue: 0,0:19:59.10,0:20:05.18,English,,0,0,0,,Okay now that the blocked in the Linux literature the blocked bit vector is also called the signal mask
Dialogue: 0,0:20:10.28,0:20:14.40,English,,0,0,0,,Okay now we want to look in a little more detail about sending and receiving signals
Dialogue: 0,0:20:14.40,0:20:16.76,English,,0,0,0,,So let's start first with sending signals
Dialogue: 0,0:20:18.56,0:20:21.34,English,,0,0,0,,First we need to understand the idea of a process group
Dialogue: 0,0:20:22.48,0:20:25.84,English,,0,0,0,,So every process belongs to exactly one process group
Dialogue: 0,0:20:28.38,0:20:31.48,English,,0,0,0,,And those so here I'm showing a shell that's in process
Dialogue: 0,0:20:31.88,0:20:35.38,English,,0,0,0,,It has a process id of 10 and a process group id of 10
Dialogue: 0,0:20:36.82,0:20:38.92,English,,0,0,0,,The shell created a foreground job
Dialogue: 0,0:20:41.12,0:20:44.80,English,,0,0,0,,Which has a process id of 20 and a process group id of 20
Dialogue: 0,0:20:45.34,0:20:51.88,English,,0,0,0,,And then all of the children that this foreground job created have the same process group id of 20
Dialogue: 0,0:20:53.94,0:20:59.20,English,,0,0,0,,So these process groups can be set by a system call set called the set process group id(setpgid())
Dialogue: 0,0:21:01.30,0:21:06.96,English,,0,0,0,,And you can fetch that process group using the get process group system call
Dialogue: 0,0:21:07.62,0:21:14.04,English,,0,0,0,,So you can see in this example what this shell is done is it created a foreground child
Dialogue: 0,0:21:14.04,0:21:22.42,English,,0,0,0,,So it created this child and it changed the process group id to be equal to the process id of the child
Dialogue: 0,0:21:24.06,0:21:27.04,English,,0,0,0,,And then when this child created other child children
Dialogue: 0,0:21:27.68,0:21:30.52,English,,0,0,0,,They just inherited the same process group id
Dialogue: 0,0:21:34.74,0:21:37.34,English,,0,0,0,,Okay now this notion of a process group is useful
Dialogue: 0,0:21:37.78,0:21:43.26,English,,0,0,0,,Because it allows you to send signals to groups of processes at the same time
Dialogue: 0,0:21:43.74,0:21:46.08,English,,0,0,0,,And you can do that with a program called kill
Dialogue: 0,0:21:46.64,0:21:49.46,English,,0,0,0,,Which is typically in /bin directory
Dialogue: 0,0:21:50.56,0:21:55.60,English,,0,0,0,,And that the kill program you can use the kill program to send an arbitrary signal to
Dialogue: 0,0:21:55.78,0:22:00.56,English,,0,0,0,,Either an individual process or all the processes in one process group
Dialogue: 0,0:22:02.88,0:22:10.46,English,,0,0,0,,So let's look at an example this program,this forks program creates two children
Dialogue: 0,0:22:13.70,0:22:17.96,English,,0,0,0,,And with each of which has a process group of 24817
Dialogue: 0,0:22:18.86,0:22:21.86,English,,0,0,0,,And of course they have different process they have different process ids
Dialogue: 0,0:22:23.36,0:22:29.58,English,,0,0,0,,And so if we do a ps we see these two processes running
Dialogue: 0,0:22:30.90,0:22:34.50,English,,0,0,0,,And these just go into loop so they'll just run continuously
Dialogue: 0,0:22:36.10,0:22:37.50,English,,0,0,0,,Okay now we can
Dialogue: 0,0:22:40.30,0:22:43.48,English,,0,0,0,,We can use kill to kill an individual process
Dialogue: 0,0:22:44.00,0:22:51.08,English,,0,0,0,,For example so if we call it the first argument indicates what signal you want to send
Dialogue: 0,0:22:51.08,0:22:55.30,English,,0,0,0,,So in this case it's signal 9 which is the sigkill signal
Dialogue: 0,0:22:55.88,0:23:02.98,English,,0,0,0,,So kill -9 is a very typical,usually if you want to kill processes you just kill -9
Dialogue: 0,0:23:03.94,0:23:13.10,English,,0,0,0,,And actually one of my favorite auto lab nicknames for 213 was the nickname was kill - 9 15-213
Dialogue: 0,0:23:16.10,0:23:23.20,English,,0,0,0,,So but then the second argument is the if it's is the process id
Dialogue: 0,0:23:23.22,0:23:29.54,English,,0,0,0,,So this is asking the kernel to kill process id 24818
Dialogue: 0,0:23:30.12,0:23:32.44,English,,0,0,0,,By sending it a sigkill signal
Dialogue: 0,0:23:33.64,0:23:38.58,English,,0,0,0,,Now if the process id is is preceded by a dash
Dialogue: 0,0:23:40.86,0:23:45.12,English,,0,0,0,,Then it sends a signal to every process in process group
Dialogue: 0,0:23:45.64,0:23:48.30,English,,0,0,0,,Then it treats this argument as a process group
Dialogue: 0,0:23:48.78,0:23:52.46,English,,0,0,0,,And it sends a signal to every process in that process group
Dialogue: 0,0:23:52.96,0:23:58.82,English,,0,0,0,,So in this case it will send a signal to both of these children processes
Dialogue: 0,0:24:00.48,0:24:05.40,English,,0,0,0,,And then afterwards we if we do a ps we see that those processes are gone
Dialogue: 0,0:24:05.62,0:24:07.90,English,,0,0,0,,Okay that it really did work that way
Dialogue: 0,0:24:09.78,0:24:15.24,English,,0,0,0,,Now another way to send signals is by typing either ctrl-c or ctrl-z
Dialogue: 0,0:24:15.62,0:24:18.26,English,,0,0,0,,At the to the command line
Dialogue: 0,0:24:19.44,0:24:25.50,English,,0,0,0,,Ctrl-c causes the kernel to send a signal to every job in the foreground process group
Dialogue: 0,0:24:25.84,0:24:35.58,English,,0,0,0,,And ctrl-z causes it to send a sigtstp signal to every job in the foreground process group
Dialogue: 0,0:24:36.38,0:24:39.28,English,,0,0,0,,The default action for sigint is to terminate the process
Dialogue: 0,0:24:39.28,0:24:43.88,English,,0,0,0,,The default action for the sigtstp is to suspend the process stop it
Dialogue: 0,0:24:44.34,0:24:48.24,English,,0,0,0,,Until it receives a sig cont a signal
Dialogue: 0,0:24:54.90,0:24:58.58,English,,0,0,0,,So you can see an example of this here we have a program that
Dialogue: 0,0:25:00.90,0:25:07.27,English,,0,0,0,,Creates a parent and a child running in the foreground so the parents running in the foreground
Dialogue: 0,0:25:08.10,0:25:11.04,English,,0,0,0,,Now when we type ctrl-z to the command line
Dialogue: 0,0:25:12.70,0:25:16.36,English,,0,0,0,,The shell notifies us that it's suspended that process
Dialogue: 0,0:25:16.80,0:25:23.90,English,,0,0,0,,And if we do a ps we can see the parent and the child indeed are suspended
Dialogue: 0,0:25:23.94,0:25:28.72,English,,0,0,0,,So the ps indicates that it's suspended or stopped using T
Dialogue: 0,0:25:33.04,0:25:37.04,English,,0,0,0,,Now next we type in the built in the shell built in which is fg
Dialogue: 0,0:25:37.16,0:25:42.36,English,,0,0,0,,And fg restores those suspended jobs to the foreground
Dialogue: 0,0:25:44.70,0:25:50.06,English,,0,0,0,,So after typing fg now we're running this our program again in the foreground
Dialogue: 0,0:25:51.58,0:25:54.28,English,,0,0,0,,And then we can kill it by typing ctrl-c
Dialogue: 0,0:25:54.78,0:25:58.84,English,,0,0,0,,Which elicits a sigint whose default action is to terminate
Dialogue: 0,0:25:59.18,0:26:03.30,English,,0,0,0,,And then when we do a ps we see that indeed that's that they're gone
Dialogue: 0,0:26:06.96,0:26:11.40,English,,0,0,0,,Now the third way that we can send signals is by using the kill system call
Dialogue: 0,0:26:15.44,0:26:17.60,English,,0,0,0,,So here's an example of how that works
Dialogue: 0,0:26:18.04,0:26:21.82,English,,0,0,0,,So in this example we're creating N children
Dialogue: 0,0:26:23.00,0:26:25.14,English,,0,0,0,,Now each of which goes into an infinite loop
Dialogue: 0,0:26:25.84,0:26:29.90,English,,0,0,0,,And we're recording this the process id of each child that we create
Dialogue: 0,0:26:31.92,0:26:34.90,English,,0,0,0,,And then in it we go in...another loop we go through
Dialogue: 0,0:26:34.90,0:26:40.02,English,,0,0,0,,And we kill each of those child processes with by using the kill function
Dialogue: 0,0:26:40.74,0:26:45.56,English,,0,0,0,,Passing it the process id and the signal that we want sent to that process
Dialogue: 0,0:26:47.72,0:26:52.24,English,,0,0,0,,Okay and then we do our due diligence and reap each one of those
Dialogue: 0,0:26:52.64,0:26:54.64,English,,0,0,0,,Children that we've terminated
Dialogue: 0,0:26:55.56,0:27:02.28,English,,0,0,0,,Now this isn't strictly necessary because we're going to exit as soon as this fork12 function
Dialogue: 0,0:27:02.80,0:27:06.58,English,,0,0,0,,Returns we're going to exit the code so but we're just being
Dialogue: 0,0:27:07.38,0:27:11.90,English,,0,0,0,,You know careful here and maybe a little pedantic but
Dialogue: 0,0:27:16.02,0:27:20.26,English,,0,0,0,,Okay now let's look at how we process receive signals
Dialogue: 0,0:27:22.58,0:27:29.72,English,,0,0,0,,Now suppose process A is running along executing its user code and then
Dialogue: 0,0:27:30.48,0:27:34.94,English,,0,0,0,,There's a control passes into the kernel because of some exception
Dialogue: 0,0:27:36.12,0:27:40.36,English,,0,0,0,,Now that exception can be either a timer going off
Dialogue: 0,0:27:40.90,0:27:45.12,English,,0,0,0,,They've been interrupts or it can be a trap user calls a system call
Dialogue: 0,0:27:45.76,0:27:50.50,English,,0,0,0,,Okay but it's always caused that the trap into the
Dialogue: 0,0:27:51.20,0:27:54.26,English,,0,0,0,,Or the transferring control into the kernel is always caused by some exception
Dialogue: 0,0:27:56.18,0:27:59.48,English,,0,0,0,,So at this point the kernel calls its scheduler function
Dialogue: 0,0:28:00.12,0:28:07.34,English,,0,0,0,,And it decides do a context switch from process A to process B
Dialogue: 0,0:28:09.46,0:28:15.50,English,,0,0,0,,And it gets processed B all set up and right before it returns from that exception
Dialogue: 0,0:28:16.26,0:28:24.24,English,,0,0,0,,And right before it's ready to pass control back to process the user code and process B
Dialogue: 0,0:28:25.30,0:28:29.34,English,,0,0,0,,It checks for any signals that any pending signals
Dialogue: 0,0:28:32.58,0:28:38.50,English,,0,0,0,,Okay and it does this by computing a bit vector pnb so pending nonblocked
Dialogue: 0,0:28:39.42,0:28:42.58,English,,0,0,0,,Which is the logical and of the pending bit vector
Dialogue: 0,0:28:44.00,0:28:46.48,English,,0,0,0,,And the inverse of the blocked bit vector
Dialogue: 0,0:28:47.74,0:28:52.10,English,,0,0,0,,Okay so pnb is a list of all the pending signals that aren't blocked
Dialogue: 0,0:28:53.34,0:28:56.08,English,,0,0,0,,Okay so these are all the pending signals that should be received
Dialogue: 0,0:28:59.12,0:29:02.84,English,,0,0,0,,Now if pnb is all zeros then there's no pending signals
Dialogue: 0,0:29:03.04,0:29:05.86,English,,0,0,0,,So it just returns it passes control back
Dialogue: 0,0:29:07.18,0:29:10.98,English,,0,0,0,,It passes control back to process B which can continue executing
Dialogue: 0,0:29:11.64,0:29:14.18,English,,0,0,0,,However if pnb is nonzero then
Dialogue: 0,0:29:15.10,0:29:19.70,English,,0,0,0,,It chooses the smallest nonzero bit in pnb
Dialogue: 0,0:29:19.70,0:29:24.56,English,,0,0,0,,And it forces process p to receive that signal the corresponding signal
Dialogue: 0,0:29:27.74,0:29:32.20,English,,0,0,0,,The receipt of the signal triggers some action in the process
Dialogue: 0,0:29:36.24,0:29:44.34,English,,0,0,0,,And then we repeat that for all the nonzero signals k that are nonzero bits that are set in pnb
Dialogue: 0,0:29:44.78,0:29:47.60,English,,0,0,0,,And finally when we've gone all through all the nonzero bits
Dialogue: 0,0:29:48.14,0:29:56.70,English,,0,0,0,,Then we pass control to the next instruction in process p
Dialogue: 0,0:30:00.72,0:30:03.96,English,,0,0,0,,So the receipt of a signal always triggers some action
Dialogue: 0,0:30:04.46,0:30:06.93,English,,0,0,0,,Which is either the process terminates
Dialogue: 0,0:30:07.86,0:30:11.40,English,,0,0,0,,The process stops until it's restarted by a sick can't signal
Dialogue: 0,0:30:12.42,0:30:14.52,English,,0,0,0,,The process ignores the signal
Dialogue: 0,0:30:15.36,0:30:18.42,English,,0,0,0,,Ok so that's there's always some predefined default action
Dialogue: 0,0:30:21.72,0:30:29.72,English,,0,0,0,,But we can modify that default action by using a function system call called signal
Dialogue: 0,0:30:31.66,0:30:37.28,English,,0,0,0,,Ok so we can...now signals a little that's another sort of misleading kind of term just like kill right because when we
Dialogue: 0,0:30:37.74,0:30:40.50,English,,0,0,0,,When we send a signal to a process we don't always want to kill it
Dialogue: 0,0:30:41.74,0:30:44.02,English,,0,0,0,,And signal doesn't actually signal anything
Dialogue: 0,0:30:44.40,0:30:49.22,English,,0,0,0,,It just modifies the default action associated with some something
Dialogue: 0,0:30:50.74,0:30:55.02,English,,0,0,0,,Okay so if the signal function takes out a signal number(signum)
Dialogue: 0,0:30:56.90,0:31:01.98,English,,0,0,0,,And then specifies a change in the default action for that signal
Dialogue: 0,0:31:04.16,0:31:07.46,English,,0,0,0,,And those default actions can be either to ignore the signal(sig_ign)
Dialogue: 0,0:31:08.30,0:31:14.96,English,,0,0,0,,Ok ignore signals of type signal,revert to the default behavior for that signal
Dialogue: 0,0:31:17.48,0:31:21.96,English,,0,0,0,,Or we can give it...or it can be the address of a user level signal handler
Dialogue: 0,0:31:22.64,0:31:26.38,English,,0,0,0,,Which is a function that we've declared in our C program
Dialogue: 0,0:31:26.76,0:31:32.92,English,,0,0,0,,Ok there's nothing special about the function it has a certain prototype that has it takes a single argument
Dialogue: 0,0:31:33.60,0:31:40.06,English,,0,0,0,,Which is the signal number so when that function gets called in response to receiving a signal
Dialogue: 0,0:31:41.24,0:31:44.02,English,,0,0,0,,That argument will be set to the signal number
Dialogue: 0,0:31:47.80,0:31:54.54,English,,0,0,0,,So calling signal with a specifying a signal handler is called installing a handler
Dialogue: 0,0:31:55.42,0:31:59.68,English,,0,0,0,,And then executing the handlers referred to as catching or executing
Dialogue: 0,0:31:59.68,0:32:01.52,English,,0,0,0,,They were handling the signal
Dialogue: 0,0:32:03.78,0:32:06.64,English,,0,0,0,,And and this handler then is just like an exception handler
Dialogue: 0,0:32:06.66,0:32:12.56,English,,0,0,0,,When it returns it will be when it's executed it will interrupt the
Dialogue: 0,0:32:13.16,0:32:16.66,English,,0,0,0,,Whatever is currently executing in the process when it returns
Dialogue: 0,0:32:16.92,0:32:19.94,English,,0,0,0,,It will return back to that point and continue executing
Dialogue: 0,0:32:22.74,0:32:26.74,English,,0,0,0,,Okay so here's a simple example of installing a handler
Dialogue: 0,0:32:28.62,0:32:32.48,English,,0,0,0,,So here in main where we're going to install a sigint handler
Dialogue: 0,0:32:34.92,0:32:38.80,English,,0,0,0,,Which is called sigint_handler which is defined up here
Dialogue: 0,0:32:39.80,0:32:43.12,English,,0,0,0,,And the prototype for this function is returns nothing
Dialogue: 0,0:32:43.80,0:32:48.12,English,,0,0,0,,And it takes a single integer argument which is the signal number and returns nothing
Dialogue: 0,0:32:50.76,0:32:52.42,English,,0,0,0,,Okay and after we install that handler
Dialogue: 0,0:32:53.12,0:32:59.24,English,,0,0,0,,Then we're going to execute the pause this call which just waits for a signal handler to execute
Dialogue: 0,0:32:59.48,0:33:03.20,English,,0,0,0,,Ok so pause terminates the current or suspends the current process
Dialogue: 0,0:33:04.28,0:33:08.38,English,,0,0,0,,Until a signal is received and a handler executes in that process
Dialogue: 0,0:33:08.92,0:33:10.68,English,,0,0,0,,And then pause then pause returns
Dialogue: 0,0:33:13.36,0:33:16.36,English,,0,0,0,,So we're going to wait until the sigint happens
Dialogue: 0,0:33:16.40,0:33:19.54,English,,0,0,0,,So sigint entry call is when we type ctrl-c
Dialogue: 0,0:33:21.98,0:33:27.04,English,,0,0,0,,So when you're doing your bombs did you panic at some point and try to hit ctrl-c to get out of it
Dialogue: 0,0:33:28.50,0:33:30.86,English,,0,0,0,,Okay so that snarky message you got that was
Dialogue: 0,0:33:32.04,0:33:37.20,English,,0,0,0,,We did that by installing a sigint handler in your bomb
Dialogue: 0,0:33:38.78,0:33:43.14,English,,0,0,0,,Okay so when you type ctrl-c that elicits a sigint
Dialogue: 0,0:33:43.60,0:33:51.60,English,,0,0,0,,When that sigint is received,we printed this message and then eventually let you exit
Dialogue: 0,0:33:56.90,0:34:01.38,English,,0,0,0,,Now signals are another examples of concurrency
Dialogue: 0,0:34:02.16,0:34:06.92,English,,0,0,0,,Now we've seen concurrency earlier in the form of processes
Dialogue: 0,0:34:07.84,0:34:12.90,English,,0,0,0,,Right concurrent flows overlapping in time
Dialogue: 0,0:34:14.14,0:34:19.32,English,,0,0,0,,Okay logical flows overlapping in time by definition are concurrent
Dialogue: 0,0:34:20.58,0:34:26.62,English,,0,0,0,,Now with processes the because they have separate address spaces
Dialogue: 0,0:34:26.84,0:34:29.46,English,,0,0,0,,Those concurrent flows never interfere with each other
Dialogue: 0,0:34:29.58,0:34:33.62,English,,0,0,0,,Right so in some sense processes are very easy to deal with
Dialogue: 0,0:34:34.10,0:34:40.18,English,,0,0,0,,And we don't really have to worry one process doesn't have to worry about being interfered with by another process
Dialogue: 0,0:34:42.02,0:34:47.46,English,,0,0,0,,In fact you have to go to great lengths to share like to share things between processes
Dialogue: 0,0:34:47.46,0:34:53.78,English,,0,0,0,,You have to use specific system calls in order to say share memory between two processes
Dialogue: 0,0:34:55.22,0:34:59.90,English,,0,0,0,,Now signals are another form of concurrency this is the second time in this class that
Dialogue: 0,0:35:01.42,0:35:03.08,English,,0,0,0,,That you've experienced concurrency
Dialogue: 0,0:35:03.98,0:35:08.22,English,,0,0,0,,And so a signal is just a concurrent flow,it's just a logical flow a sit
Dialogue: 0,0:35:08.86,0:35:13.82,English,,0,0,0,,So a handler is just another logical flow that runs concurrently with your program
Dialogue: 0,0:35:14.92,0:35:19.28,English,,0,0,0,,Right so we're...let's say we're executing a while loop in process A
Dialogue: 0,0:35:20.76,0:35:22.90,English,,0,0,0,,Okay that while loop is executing
Dialogue: 0,0:35:23.46,0:35:25.56,English,,0,0,0,,And in process a receives the signal
Dialogue: 0,0:35:26.54,0:35:29.22,English,,0,0,0,,Which causes a transfer of control to this handler
Dialogue: 0,0:35:31.84,0:35:35.30,English,,0,0,0,,This handler executes so this is a concurrent flow
Dialogue: 0,0:35:36.12,0:35:42.24,English,,0,0,0,,That overlaps in time with the while loop in process A eventually this handler returns
Dialogue: 0,0:35:43.24,0:35:48.42,English,,0,0,0,,And we return for the back tip to back to process A
Dialogue: 0,0:35:50.34,0:35:58.26,English,,0,0,0,,Now one of the reasons signals are so tricky is because of this overlapping concurrent flow
Dialogue: 0,0:35:59.86,0:36:06.06,English,,0,0,0,,This concurrency because the signal handler runs in the same process  as the main program
Dialogue: 0,0:36:06.68,0:36:10.12,English,,0,0,0,,So it shares all the global variables of that program
Dialogue: 0,0:36:11.76,0:36:15.26,English,,0,0,0,,Okay so you're that signal handler is a function
Dialogue: 0,0:36:15.26,0:36:21.54,English,,0,0,0,,That you've declared and it has access to all the state,all the global state in the program
Dialogue: 0,0:36:23.40,0:36:27.86,English,,0,0,0,,Okay and the existence of the shared global state can create real problems
Dialogue: 0,0:36:37.50,0:36:40.48,English,,0,0,0,,And we'll get into more details about some of those problems
Dialogue: 0,0:36:42.08,0:36:49.90,English,,0,0,0,,So another way to look at these signal handlers disking as concurrent flows is using this context switch diagram
Dialogue: 0,0:36:50.62,0:36:53.32,English,,0,0,0,,So suppose we're executing in process A
Dialogue: 0,0:36:54.50,0:37:00.85,English,,0,0,0,,And now at some point a signal delivered to process A
Dialogue: 0,0:37:01.70,0:37:06.78,English,,0,0,0,,Now nothing happens right just the pending bit gets set in process A at this point
Dialogue: 0,0:37:08.64,0:37:12.52,English,,0,0,0,,Now at some point there's a transfer of control into the kernel
Dialogue: 0,0:37:13.44,0:37:17.20,English,,0,0,0,,And the kernel decides to do a context switch from A to B
Dialogue: 0,0:37:18.08,0:37:22.34,English,,0,0,0,,And now B gets to run for a while there's another transfer of control to the kernel
Dialogue: 0,0:37:24.30,0:37:27.02,English,,0,0,0,,And the kernel decides to schedule process A
Dialogue: 0,0:37:28.62,0:37:32.90,English,,0,0,0,,And now right before it returns control to process A
Dialogue: 0,0:37:33.26,0:37:37.36,English,,0,0,0,,It notices that the pending bit for this signal is set
Dialogue: 0,0:37:37.76,0:37:40.38,English,,0,0,0,,So it causes process A to receive that signal
Dialogue: 0,0:37:41.00,0:37:42.88,English,,0,0,0,,So that executes the handler code
Dialogue: 0,0:37:43.68,0:37:48.12,English,,0,0,0,,When the handler returns, it returns for brief briefly to the kernel
Dialogue: 0,0:37:48.18,0:37:53.76,English,,0,0,0,,Which then transfers control back to the the next instruction that the process was going to execute
Dialogue: 0,0:37:56.48,0:38:00.56,English,,0,0,0,,Now handlers are also tricky because they can be interrupted by other handlers
Dialogue: 0,0:38:01.34,0:38:06.56,English,,0,0,0,,So suppose we have our main program that catches a signal s
Dialogue: 0,0:38:08.00,0:38:10.70,English,,0,0,0,,Which causes a transfer of control to handler S
Dialogue: 0,0:38:11.44,0:38:13.76,English,,0,0,0,,And then we'll handler S did you have a question okay
Dialogue: 0,0:38:15.24,0:38:19.00,English,,0,0,0,,Well handler S is executing
Dialogue: 0,0:38:22.96,0:38:28.28,English,,0,0,0,,The program catches a signal t
Dialogue: 0,0:38:30.62,0:38:35.78,English,,0,0,0,,Which causes a transfer of control to the handler first for t
Dialogue: 0,0:38:36.38,0:38:39.30,English,,0,0,0,,And when at handler returns,it returns to the point to the
Dialogue: 0,0:38:40.36,0:38:45.80,English,,0,0,0,,To the to the instruction and handle or else that was where it was interrupted
Dialogue: 0,0:38:46.36,0:38:50.50,English,,0,0,0,,And then handle or us continues its execution and eventually
Dialogue: 0,0:38:50.50,0:38:54.34,English,,0,0,0,,Return back to the the point in the main program where it was interrupted
Dialogue: 0,0:38:58.70,0:39:02.61,English,,0,0,0,,Now signals that the kernel always blocks
Dialogue: 0,0:39:03.32,0:39:06.44,English,,0,0,0,,Pending signals of the type currently being handled right so
Dialogue: 0,0:39:07.56,0:39:12.46,English,,0,0,0,,A handler for a signal of type t can't be interrupted
Dialogue: 0,0:39:13.20,0:39:16.16,English,,0,0,0,,By the receipt of another signal of that same type
Dialogue: 0,0:39:16.96,0:39:20.98,English,,0,0,0,,Okay can be as I showed in the previous slide it can be interrupted by a signal of another type
Dialogue: 0,0:39:21.46,0:39:23.42,English,,0,0,0,,But not by a signal of the same type
Dialogue: 0,0:39:23.88,0:39:28.12,English,,0,0,0,,So that's sort of an implicit form of blocking
Dialogue: 0,0:39:29.22,0:39:36.70,English,,0,0,0,,But there's the kernel also provides a system call that allows you to explicitly block and unblock signals
Dialogue: 0,0:39:37.30,0:39:40.01,English,,0,0,0,,In the form of the sigprocmask function
Dialogue: 0,0:39:41.96,0:39:48.66,English,,0,0,0,,And then there's associated so this allows you to block and unblock a set of signals
Dialogue: 0,0:39:49.42,0:39:54.04,English,,0,0,0,,And then there some support functions that allow you to create those sets
Dialogue: 0,0:39:55.40,0:39:58.34,English,,0,0,0,,So just think of these as bit vectors
Dialogue: 0,0:39:58.38,0:40:05.34,English,,0,0,0,,And these functions will set in set and reset the bits and those those bit vectors
Dialogue: 0,0:40:07.16,0:40:12.72,English,,0,0,0,,So let's see how we can use sigprocmasks to temporarily block and unblock a signal
Dialogue: 0,0:40:13.32,0:40:16.00,English,,0,0,0,,So this is going to turn out to be very important for you
Dialogue: 0,0:40:16.00,0:40:21.24,English,,0,0,0,,When you working on your shells that which is your next lab assignment okay
Dialogue: 0,0:40:25.98,0:40:31.34,English,,0,0,0,,So what we do...we'll use sigemptyset to create an empty mask so this is a mask with all zeros
Dialogue: 0,0:40:31.96,0:40:33.80,English,,0,0,0,,Okay with no elements in the set
Dialogue: 0,0:40:34.80,0:40:39.46,English,,0,0,0,,And then we're going to add a single element to this set which is sigint
Dialogue: 0,0:40:42.46,0:40:47.88,English,,0,0,0,,And now we temp...we have some code that we don't want to be interrupted by the seed of sigint
Dialogue: 0,0:40:49.36,0:40:53.08,English,,0,0,0,,Okay so we want to temporarily block the receipt of sig n signals
Dialogue: 0,0:40:54.08,0:40:58.70,English,,0,0,0,,And we do it by calling sigprocmask with the command
Dialogue: 0,0:40:59.20,0:41:02.56,English,,0,0,0,,Say I want to block I want to block the signals
Dialogue: 0,0:41:03.84,0:41:08.78,English,,0,0,0,,That are spent that are in the set specified by mask
Dialogue: 0,0:41:12.36,0:41:16.22,English,,0,0,0,,And I'll assign the so this will become my new mask
Dialogue: 0,0:41:16.64,0:41:19.72,English,,0,0,0,,So this becomes the new blocked bit vector
Dialogue: 0,0:41:20.68,0:41:24.52,English,,0,0,0,,Okay or the not the this the new signal mask
Dialogue: 0,0:41:24.62,0:41:31.28,English,,0,0,0,,And it makes a copy of the old one and stores it at the address specified in the third argument
Dialogue: 0,0:41:32.82,0:41:35.50,English,,0,0,0,,So at this point after we returned from sigprocmask
Dialogue: 0,0:41:36.04,0:41:38.50,English,,0,0,0,,Sigint signals are blocked and they won't be received
Dialogue: 0,0:41:40.94,0:41:47.02,English,,0,0,0,,And then we...so we can execute this code knowing that we won't be interrupted by receipt of a sigint
Dialogue: 0,0:41:49.56,0:41:57.20,English,,0,0,0,,And then we can restore the previous block set by using the sig_setmask in stopper ation
Dialogue: 0,0:41:57.78,0:42:03.44,English,,0,0,0,,And passing in the previous mask that we saved up here when we initially blocks again
Dialogue: 0,0:42:09.96,0:42:15.12,English,,0,0,0,,Okay so signals and signal handling is a really tricky business
Dialogue: 0,0:42:15.54,0:42:17.48,English,,0,0,0,,And there's sort of three things that make them
Dialogue: 0,0:42:18.82,0:42:21.44,English,,0,0,0,,So tricky and kind of nasty really
Dialogue: 0,0:42:21.88,0:42:26.80,English,,0,0,0,,One is that you have to be very careful to write handlers that are safe
Dialogue: 0,0:42:27.54,0:42:33.96,English,,0,0,0,,Okay so there's you can write signal handlers that are unsafe in the sense that they'll create a deadlock in your program
Dialogue: 0,0:42:36.68,0:42:41.68,English,,0,0,0,,Okay or you can write signal handlers that will corrupt a global data structure
Dialogue: 0,0:42:42.58,0:42:46.24,English,,0,0,0,,That's being modified by the main program
Dialogue: 0,0:42:46.24,0:42:54.06,English,,0,0,0,,So I mean imagine your main programming is updating some data structure like a linked list
Dialogue: 0,0:42:54.84,0:42:59.72,English,,0,0,0,,And right in the middle of updating that data structure when it's no longer consistent
Dialogue: 0,0:43:01.44,0:43:04.02,English,,0,0,0,,The program gets interrupted by the receipt of a signal
Dialogue: 0,0:43:05.22,0:43:11.54,English,,0,0,0,,And if that signal handler is updating that same data structure reading that structure or modifying it
Dialogue: 0,0:43:12.62,0:43:17.18,English,,0,0,0,,Then it's going to encounter it in an inconsistent state and and you're in trouble
Dialogue: 0,0:43:19.92,0:43:27.28,English,,0,0,0,,Okay so this the fact that it's easy to write signal handlers
Dialogue: 0,0:43:27.30,0:43:32.04,English,,0,0,0,,That are unsafe is is is one aspect of that makes them tough to deal with
Dialogue: 0,0:43:32.66,0:43:37.16,English,,0,0,0,,Another aspect is they have this funny semantics that signals aren't cued
Dialogue: 0,0:43:38.04,0:43:40.60,English,,0,0,0,,And so if you're not really careful about this
Dialogue: 0,0:43:41.12,0:43:45.68,English,,0,0,0,,It's very easy to use the receipt of signals to count events
Dialogue: 0,0:43:46.76,0:43:49.94,English,,0,0,0,,And you can't do that if signals were cued you could use
Dialogue: 0,0:43:50.12,0:43:54.34,English,,0,0,0,,You could use the receipt of a signal to count events in the system but you can't do it because
Dialogue: 0,0:43:54.80,0:43:56.08,English,,0,0,0,,Their signals aren't cued
Dialogue: 0,0:43:57.28,0:44:00.82,English,,0,0,0,,And then a third aspect of signals which makes them tough is that
Dialogue: 0,0:44:01.66,0:44:05.18,English,,0,0,0,,They're not even portable across different versions of Linux
Dialogue: 0,0:44:07.52,0:44:12.94,English,,0,0,0,,Okay so if you use solaris or some form of bsd it's not necessarily
Dialogue: 0,0:44:13.24,0:44:16.70,English,,0,0,0,,The single handling semantics aren't necessarily the same as they are in Linux
Dialogue: 0,0:44:17.82,0:44:21.36,English,,0,0,0,,Okay so we'll look at all three of these in a little more detail
Dialogue: 0,0:44:21.36,0:44:24.34,English,,0,0,0,,And first we'll start with writing safe handlers
Dialogue: 0,0:44:26.94,0:44:32.40,English,,0,0,0,,So let me give you some guidelines for how to write safe handlers
Dialogue: 0,0:44:33.24,0:44:38.16,English,,0,0,0,,And this is just a collection of...
Dialogue: 0,0:44:39.16,0:44:43.78,English,,0,0,0,,Collection of sort of collected wisdom from various sources
Dialogue: 0,0:44:44.16,0:44:48.58,English,,0,0,0,,But it covers a lot of aspects of signal handlers
Dialogue: 0,0:44:49.34,0:44:53.66,English,,0,0,0,,So the first guideline is to keep your handlers as simple as possible for example
Dialogue: 0,0:44:54.04,0:44:58.94,English,,0,0,0,,The simplest possible handle I can think of just sets a global variable and then it returns
Dialogue: 0,0:45:00.52,0:45:10.62,English,,0,0,0,,Okay and in fact cert the CMU cert provides guidelines for sort of compliant programs
Dialogue: 0,0:45:11.38,0:45:17.88,English,,0,0,0,,And this is the only signal handler that they allow this is the only compliant signal handler
Dialogue: 0,0:45:18.10,0:45:20.64,English,,0,0,0,,One that just sets a global variable and then returns
Dialogue: 0,0:45:26.26,0:45:33.24,English,,0,0,0,,Okay guideline number one call only functions in your handlers that are that have this property of async-signals-safety
Dialogue: 0,0:45:35.82,0:45:41.16,English,,0,0,0,,We'll look at this in a second but I want to point out that printf, sprintf,malloc,exit
Dialogue: 0,0:45:42.18,0:45:45.64,English,,0,0,0,,Functions that are very common and commonly used are not safe
Dialogue: 0,0:45:48.88,0:45:54.80,English,,0,0,0,,Okay guideline number two is to always save and restore errno on entry and exit
Dialogue: 0,0:45:55.14,0:45:56.62,English,,0,0,0,,So you know errno is a global
Dialogue: 0,0:45:57.40,0:46:01.44,English,,0,0,0,,Global variable that's set when there's whenever there's an error in a system-level function
Dialogue: 0,0:46:02.56,0:46:06.42,English,,0,0,0,,So you need to save and restore it on entry and exit
Dialogue: 0,0:46:06.70,0:46:10.86,English,,0,0,0,,So that it doesn't get overwritten if you're interrupted by another handler
Dialogue: 0,0:46:15.92,0:46:18.32,English,,0,0,0,,Okay if you're accessing any shared data structures
Dialogue: 0,0:46:19.00,0:46:25.24,English,,0,0,0,,Inside a signal handler that are also accessed by your main routine
Dialogue: 0,0:46:25.34,0:46:29.16,English,,0,0,0,,Then you need to temporarily block signals while you access that data structure
Dialogue: 0,0:46:29.80,0:46:31.98,English,,0,0,0,,Both in the main routine and your signal handler
Dialogue: 0,0:46:32.86,0:46:35.43,English,,0,0,0,,Right and the reason for this is what I described earlier
Dialogue: 0,0:46:36.04,0:46:39.88,English,,0,0,0,,If your main routine is updating that global data structure and then it gets interrupted
Dialogue: 0,0:46:40.40,0:46:44.46,English,,0,0,0,,And the signal handler is reading that data structure it's going to find it in an inconsistent state
Dialogue: 0,0:46:44.88,0:46:46.40,English,,0,0,0,,And bad things will happen
Dialogue: 0,0:46:50.88,0:46:55.76,English,,0,0,0,,Okay you want to be sure to declare your any global variables that are shared between signal handlers
Dialogue: 0,0:46:55.96,0:46:57.94,English,,0,0,0,,And the main routine as volatile
Dialogue: 0,0:46:58.56,0:47:04.38,English,,0,0,0,,Okay the volatile attribute will prevent the compiler from putting that value in a register
Dialogue: 0,0:47:07.62,0:47:09.96,English,,0,0,0,,So if you declare a global variable as volatile
Dialogue: 0,0:47:10.58,0:47:14.58,English,,0,0,0,,It will always be reads and writes will always go to and from memory
Dialogue: 0,0:47:15.94,0:47:22.76,English,,0,0,0,,Okay so this is very important right you might if you don't declare these global variables at volatile
Dialogue: 0,0:47:22.86,0:47:28.22,English,,0,0,0,,And the compiler chooses to put one of those in a register
Dialogue: 0,0:47:29.64,0:47:33.04,English,,0,0,0,,Then you may miss that variable being updated
Dialogue: 0,0:47:33.06,0:47:37.68,English,,0,0,0,,So suppose your signal handlers is setting a global variable
Dialogue: 0,0:47:39.26,0:47:44.74,English,,0,0,0,,And now suppose your main routine is spinning waiting for that global variable to get set
Dialogue: 0,0:47:46.56,0:47:51.82,English,,0,0,0,,Well if it's in a register the write to that variable will just update the register
Dialogue: 0,0:47:51.92,0:47:58.70,English,,0,0,0,,Right and so your main routine is in danger of just of spinning forever not seeing the change right
Dialogue: 0,0:48:00.54,0:48:04.62,English,,0,0,0,,Okay so always use volatility so that they're not stored in registers
Dialogue: 0,0:48:06.22,0:48:10.60,English,,0,0,0,,And then if you have fun if you have a special kind of global called a flag
Dialogue: 0,0:48:11.18,0:48:19.22,English,,0,0,0,,Which by definition is a variable it's only read or written not incremented or updated it's just read or written
Dialogue: 0,0:48:20.64,0:48:27.18,English,,0,0,0,,If you have a variable with that property then you can declare it with this sig_atomic_t tribute
Dialogue: 0,0:48:28.72,0:48:34.46,English,,0,0,0,,And if you do that then the system guarantees that reads and writes to that variable will be atomic
Dialogue: 0,0:48:34.68,0:48:39.22,English,,0,0,0,,So you don't have to in other words you don't have to protect accesses to the shared
Dialogue: 0,0:48:39.82,0:48:43.58,English,,0,0,0,,To accesses or references to those global variables
Dialogue: 0,0:48:44.52,0:48:53.56,English,,0,0,0,,Okay and so by atomic which means that the read or write of that flag will always happen in one uninterruptible step
Dialogue: 0,0:48:54.86,0:48:58.12,English,,0,0,0,,Okay one uninterruptible load or store particular
Dialogue: 0,0:49:00.16,0:49:03.94,English,,0,0,0,,Now in practice on most systems this sig_atomic_t is an int
Dialogue: 0,0:49:05.80,0:49:12.00,English,,0,0,0,,So you can read or write an int with one one instruction okay so it's atomic
Dialogue: 0,0:49:12.62,0:49:16.06,English,,0,0,0,,But if you want to be portable you declare it with sig_atomic_t
Dialogue: 0,0:49:16.30,0:49:21.94,English,,0,0,0,,And then it'll work on none it will work on all systems
Dialogue: 0,0:49:24.78,0:49:27.44,English,,0,0,0,,Okay we mentioned this property of a sync signal safety
Dialogue: 0,0:49:28.66,0:49:32.66,English,,0,0,0,,Now a function is safe to be used inside of a signal handler
Dialogue: 0,0:49:33.56,0:49:38.54,English,,0,0,0,,If it's either reentrant or if it can't be interrupted by signals
Dialogue: 0,0:49:39.30,0:49:44.62,English,,0,0,0,,And will...a reentrant function as we'll see when we study threads is a function where all of its
Dialogue: 0,0:49:45.16,0:49:48.20,English,,0,0,0,,All of the data that it accesses is on its own stack
Dialogue: 0,0:49:50.64,0:49:56.06,English,,0,0,0,,Okay so no global variables no pointers to global variables everything's stored on the stack locally
Dialogue: 0,0:49:58.00,0:50:00.42,English,,0,0,0,,Okay so that means you can be it's called reentrant
Dialogue: 0,0:50:00.42,0:50:03.36,English,,0,0,0,,Because you can write have multiple instances of that function
Dialogue: 0,0:50:03.36,0:50:08.52,English,,0,0,0,,And they all have their own separate copies of all of the variables that they're using
Dialogue: 0,0:50:10.02,0:50:16.58,English,,0,0,0,,Now the posix standard guarantees 117 different functions to be a sync-signal-safe
Dialogue: 0,0:50:19.80,0:50:24.42,English,,0,0,0,,These include _exit,write,wait,waitpid,sleep,kill
Dialogue: 0,0:50:25.52,0:50:30.81,English,,0,0,0,,But unfortunately there's some very popular functions that aren't on this list printf,sprintf
Dialogue: 0,0:50:31.28,0:50:32.70,English,,0,0,0,,Things that you really want to use
Dialogue: 0,0:50:33.14,0:50:37.84,English,,0,0,0,,And in fact write is the only output function that's async-signal-safe
Dialogue: 0,0:50:41.06,0:50:43.14,English,,0,0,0,,So this is kind of a problem because
Dialogue: 0,0:50:44.34,0:50:50.52,English,,0,0,0,,Especially when you know you something you'd often like your signal handlers to output information
Dialogue: 0,0:50:51.52,0:50:56.38,English,,0,0,0,,But you can't if you want to really be pedantic and careful you can't use printf in fact
Dialogue: 0,0:50:57.48,0:50:59.28,English,,0,0,0,,It's possible to write a program
Dialogue: 0,0:51:00.46,0:51:04.16,English,,0,0,0,,And I'll try to...it's possible to write a program
Dialogue: 0,0:51:05.12,0:51:09.24,English,,0,0,0,,That does a tight loop of printouts in the main routine
Dialogue: 0,0:51:10.96,0:51:18.32,English,,0,0,0,,And then a steady stream of interrupts which execute a handler which also does a printf
Dialogue: 0,0:51:22.94,0:51:28.70,English,,0,0,0,,The printf call has to acquire what's called a lock on the terminal
Dialogue: 0,0:51:29.24,0:51:32.88,English,,0,0,0,,Okay each printf inside that library function
Dialogue: 0,0:51:33.70,0:51:40.06,English,,0,0,0,,It acquires a lock which means only one instance of printf can write to the terminal at a point in time
Dialogue: 0,0:51:40.90,0:51:44.94,English,,0,0,0,,If another function tries to acquire that lock it has to wait
Dialogue: 0,0:51:46.28,0:51:50.12,English,,0,0,0,,Until whatever function owns the lock releases it
Dialogue: 0,0:51:50.84,0:51:58.30,English,,0,0,0,,Okay so a lock prevents a lock is a way for to get mutually exclusive access to two shared resources
Dialogue: 0,0:51:59.68,0:52:04.90,English,,0,0,0,,So if we have a tight loop in our main routine with executing printf
Dialogue: 0,0:52:05.66,0:52:10.22,English,,0,0,0,,Imagine what happens if one of those printfs acquires a lock on the terminal
Dialogue: 0,0:52:10.68,0:52:16.18,English,,0,0,0,,And then gets interrupted not by the receipt of a signal
Dialogue: 0,0:52:16.88,0:52:20.58,English,,0,0,0,,Now within the signal handler it calls another printf
Dialogue: 0,0:52:22.08,0:52:26.88,English,,0,0,0,,And that printf tries to acquire that lock and it blocks forever
Dialogue: 0,0:52:27.10,0:52:32.28,English,,0,0,0,,Because nothing's going to release that lock because the main routine was interrupted by the handler
Dialogue: 0,0:52:35.28,0:52:40.48,English,,0,0,0,,So you have what's called a classical condition called deadlock
Dialogue: 0,0:52:41.06,0:52:44.32,English,,0,0,0,,Which is we have a process waiting for an event that will never occur
Dialogue: 0,0:52:44.36,0:52:50.48,English,,0,0,0,,In this case the the printf and the signal handler is waiting for a lock to be released that will never be released
Dialogue: 0,0:52:51.70,0:52:56.66,English,,0,0,0,,So it's interesting you can try this it's
Dialogue: 0,0:52:57.42,0:53:01.40,English,,0,0,0,,It's not too hard to to create this deadlock situation
Dialogue: 0,0:53:02.90,0:53:05.74,English,,0,0,0,,So to deal with this I really didn't want to tell you guys
Dialogue: 0,0:53:05.74,0:53:09.92,English,,0,0,0,,That you couldn't have any output in your programs and writes a very difficult thing to deal with
Dialogue: 0,0:53:11.10,0:53:16.84,English,,0,0,0,,So I created a small little library called the safe I/O library
Dialogue: 0,0:53:18.50,0:53:25.46,English,,0,0,0,,Consists of three routines and they're available to you in the csapp.c file
Dialogue: 0,0:53:25.46,0:53:28.02,English,,0,0,0,,Which is distributed on the website
Dialogue: 0,0:53:28.94,0:53:31.42,English,,0,0,0,,And it consists of three reentrant routines
Dialogue: 0,0:53:33.64,0:53:37.50,English,,0,0,0,,sio_puts prints string
Dialogue: 0,0:53:38.84,0:53:41.48,English,,0,0,0,,(sio_)putl prints a long
Dialogue: 0,0:53:42.82,0:53:48.04,English,,0,0,0,,And sio_error prints a message and then exits
Dialogue: 0,0:53:50.82,0:53:55.92,English,,0,0,0,,Okay so you can safely use take my word for it you can safely use this in your signal handlers
Dialogue: 0,0:53:56.54,0:54:01.94,English,,0,0,0,,So if we were going to rewrite our sigint_handler from the binary bomb
Dialogue: 0,0:54:02.60,0:54:08.38,English,,0,0,0,,We could rewrite it like this and now we have every function is async-signal-safe
Dialogue: 0,0:54:11.60,0:54:16.58,English,,0,0,0,,All right now signals are also tucked because of this funky non cueing semantics
Dialogue: 0,0:54:19.56,0:54:21.70,English,,0,0,0,,And so it's really easy to make mistakes
Dialogue: 0,0:54:23.92,0:54:26.14,English,,0,0,0,,When you have an implicit assumption that
Dialogue: 0,0:54:27.94,0:54:33.18,English,,0,0,0,,The that the receipt of a signal it can be used to count the occurrence of an event
Dialogue: 0,0:54:34.82,0:54:38.32,English,,0,0,0,,So let's look at this, let's look at this example program
Dialogue: 0,0:54:40.88,0:54:42.92,English,,0,0,0,,We install a sigchild handler
Dialogue: 0,0:54:43.92,0:54:49.40,English,,0,0,0,,Okay and this is actually this sort of close the loop member we talked about our example shell
Dialogue: 0,0:54:49.96,0:54:53.38,English,,0,0,0,,We're wondering how are we going to reap those background children
Dialogue: 0,0:54:53.76,0:54:57.42,English,,0,0,0,,Well we do it by installing a sigchild handle like we're doing in this example
Dialogue: 0,0:54:58.26,0:55:03.62,English,,0,0,0,,So this here we have a program that installs this sig child handler
Dialogue: 0,0:55:04.28,0:55:08.86,English,,0,0,0,,And then it creates N different child processes
Dialogue: 0,0:55:09.64,0:55:12.86,English,,0,0,0,,Where each child sleeps for a little bit and exits
Dialogue: 0,0:55:17.02,0:55:22.16,English,,0,0,0,,And then it spins until the ccount variable becomes zero
Dialogue: 0,0:55:23.86,0:55:29.16,English,,0,0,0,,That the parent, I'm sorry, the parent spins until the ccount variable becomes zero
Dialogue: 0,0:55:30.76,0:55:40.32,English,,0,0,0,,Now in our child handler we have a global that's initialized to zero ccount
Dialogue: 0,0:55:43.94,0:55:48.40,English,,0,0,0,,And then we wait,we're going to wait so this child,when the child handler gets called that means
Dialogue: 0,0:55:48.84,0:55:51.14,English,,0,0,0,,It's called because we received a sigchild signal
Dialogue: 0,0:55:53.30,0:55:58.52,English,,0,0,0,,Okay so in our handler we're going to reap that child by calling weight
Dialogue: 0,0:56:00.04,0:56:03.60,English,,0,0,0,,And we're going to dec...will decrement ccount
Dialogue: 0,0:56:04.00,0:56:10.56,English,,0,0,0,,Okay so once all of the children if then have been reaped ccount will be zero
Dialogue: 0,0:56:10.56,0:56:13.88,English,,0,0,0,,And then the parent can exit this while loop
Dialogue: 0,0:56:15.54,0:56:18.48,English,,0,0,0,,Okay now in this particular example N was 5
Dialogue: 0,0:56:20.20,0:56:26.72,English,,0,0,0,,But will you run this code,we only the handle or only gets called twice
Dialogue: 0,0:56:29.46,0:56:35.38,English,,0,0,0,,Okay so the the message handler reap child only gets executed twice right
Dialogue: 0,0:56:35.38,0:56:37.76,English,,0,0,0,,Which means the handler was only called twice
Dialogue: 0,0:56:38.04,0:56:42.62,English,,0,0,0,,We created five children,we terminated five children
Dialogue: 0,0:56:43.58,0:56:45.16,English,,0,0,0,,But we only reaped two
Dialogue: 0,0:56:47.26,0:56:51.94,English,,0,0,0,,Okay so that the problem is that when we the problem is that we assumed
Dialogue: 0,0:56:52.76,0:56:54.84,English,,0,0,0,,That the receipt...
Dialogue: 0,0:56:56.94,0:57:03.36,English,,0,0,0,,The execution of the child handled our correspondent to the single receipt of a single sigchild signal
Dialogue: 0,0:57:04.78,0:57:09.38,English,,0,0,0,,Okay when in reality there signals are true
Dialogue: 0,0:57:10.40,0:57:15.90,English,,0,0,0,,We had in reality multiple sigchild signals were delivered to that child
Dialogue: 0,0:57:15.90,0:57:19.10,English,,0,0,0,,Which kept overriding that at bit in the pending bit vector
Dialogue: 0,0:57:20.26,0:57:26.68,English,,0,0,0,,And the delivery of those signals didn't cause any reaction in the process
Dialogue: 0,0:57:26.68,0:57:30.00,English,,0,0,0,,Until that process was just about ready to be rescheduled
Dialogue: 0,0:57:30.44,0:57:33.02,English,,0,0,0,,And only then was where was a signal received
Dialogue: 0,0:57:33.92,0:57:37.84,English,,0,0,0,,But even though like say three signals were delivered only one was received
Dialogue: 0,0:57:41.04,0:57:43.80,English,,0,0,0,,Okay so you can't use events in this case we're using event
Dialogue: 0,0:57:44.58,0:57:50.40,English,,0,0,0,,We're using signals to count events which in this case is the termination of a child
Dialogue: 0,0:57:51.30,0:57:55.52,English,,0,0,0,,Okay so the receipt of a signal in this case
Dialogue: 0,0:57:55.62,0:58:00.04,English,,0,0,0,,It only indicates that at least one child terminated
Dialogue: 0,0:58:00.40,0:58:04.06,English,,0,0,0,,Right not one child terminated
Dialogue: 0,0:58:05.36,0:58:10.60,English,,0,0,0,,All we can infer from the receipt of that signal is that at least one child has terminated
Dialogue: 0,0:58:11.70,0:58:17.88,English,,0,0,0,,Okay so to fix that when we receive a sigchild
Dialogue: 0,0:58:18.68,0:58:23.80,English,,0,0,0,,We have to put we have to put the wait,that's reaping on our children
Dialogue: 0,0:58:24.36,0:58:26.62,English,,0,0,0,,We have to put that in a loop
Dialogue: 0,0:58:27.30,0:58:29.48,English,,0,0,0,,So we have to assume that the receipt of a sigchild
Dialogue: 0,0:58:29.80,0:58:34.16,English,,0,0,0,,If we get a sigchild there could be multiple terminated children
Dialogue: 0,0:58:34.82,0:58:37.92,English,,0,0,0,,That we have to that we have to reap
Dialogue: 0,0:58:38.68,0:58:42.78,English,,0,0,0,,And so we put that in this loop and we execute this loop
Dialogue: 0,0:58:43.08,0:58:48.78,English,,0,0,0,,Until there's no more terminated children in which case wait will...
Dialogue: 0,0:58:49.24,0:58:53.22,English,,0,0,0,,Will exit with an error code of -1 and a error know of a child
Dialogue: 0,0:58:53.80,0:58:58.00,English,,0,0,0,,So this isn't really an error it's just means there's no more terminated children
Dialogue: 0,0:58:58.00,0:59:03.30,English,,0,0,0,,So we check as long as if our errno not echild then we have an error
Dialogue: 0,0:59:03.82,0:59:06.72,English,,0,0,0,,Otherwise we terminated normally as we expect it
Dialogue: 0,0:59:07.54,0:59:09.12,English,,0,0,0,,Now if we run this code
Dialogue: 0,0:59:10.46,0:59:15.94,English,,0,0,0,,Now we we see that we reap all five children as as we should
Dialogue: 0,0:59:18.70,0:59:23.30,English,,0,0,0,,Okay so let's the litany of problems with signals first
Dialogue: 0,0:59:24.14,0:59:27.18,English,,0,0,0,,It's easy to write handlers that aren't safe
Dialogue: 0,0:59:27.72,0:59:31.02,English,,0,0,0,,Second it's easy to get the semantics wrong third
Dialogue: 0,0:59:32.30,0:59:35.88,English,,0,0,0,,They're often not even portable across different versions of UNIX
Dialogue: 0,0:59:36.82,0:59:39.86,English,,0,0,0,,So there's some older systems I don't know if any
Dialogue: 0,0:59:40.68,0:59:47.74,English,,0,0,0,,There's some earlier versions of UNIX that after you catch a signal it restores the default action
Dialogue: 0,0:59:47.82,0:59:50.70,English,,0,0,0,,So you have to reinstall the handler every time
Dialogue: 0,0:59:51.64,0:59:57.64,English,,0,0,0,,Well every time a handler gets called you have to reinstall that handler by calling signal inside the handler itself
Dialogue: 0,0:59:58.62,1:00:00.88,English,,0,0,0,,We don't have to do that for Linux systems
Dialogue: 0,1:00:03.22,1:00:08.52,English,,0,0,0,,On some systems when you have so-called slow syscalls
Dialogue: 0,1:00:09.66,1:00:10.70,English,,0,0,0,,For example read
Dialogue: 0,1:00:11.96,1:00:13.54,English,,0,0,0,,You know if you do a read system call
Dialogue: 0,1:00:15.38,1:00:18.68,English,,0,0,0,,The kernel doesn't wait around for that data to arrive
Dialogue: 0,1:00:20.48,1:00:25.46,English,,0,0,0,,It you know it sends a request to the disk controller and that schedules another process
Dialogue: 0,1:00:26.70,1:00:31.22,English,,0,0,0,,Right so in a way that the read call is sort of and then only when the data arrives
Dialogue: 0,1:00:31.54,1:00:34.64,English,,0,0,0,,And the interrupt comes in announcing that the data arrives
Dialogue: 0,1:00:35.14,1:00:38.92,English,,0,0,0,,Does that read call finish and then restore and return
Dialogue: 0,1:00:39.58,1:00:43.86,English,,0,0,0,,So you can think of read is actually kind of broken up into two parts right
Dialogue: 0,1:00:45.90,1:00:54.14,English,,0,0,0,,Then and so that functions like read these kind of functions are called slow syscalls
Dialogue: 0,1:00:55.36,1:00:59.68,English,,0,0,0,,And on some systems if the process receives a signal
Dialogue: 0,1:01:00.16,1:01:02.54,English,,0,0,0,,Before a slow system calls has finished
Dialogue: 0,1:01:04.24,1:01:09.22,English,,0,0,0,,The kernel will just abort that system call and return from that system call with an error
Dialogue: 0,1:01:09.92,1:01:14.54,English,,0,0,0,,Okay so from users point of view you're doing a read call
Dialogue: 0,1:01:15.22,1:01:19.64,English,,0,0,0,,And it returns with this eintr signal this eintr error
Dialogue: 0,1:01:20.72,1:01:24.82,English,,0,0,0,,You did nothing wrong you just happen to have the bad luck of being interrupted by some signal
Dialogue: 0,1:01:25.14,1:01:27.26,English,,0,0,0,,And so in your user code you have to check for that
Dialogue: 0,1:01:27.32,1:01:33.34,English,,0,0,0,,And if a slow system call like read is interrupted by signal you have to redo it
Dialogue: 0,1:01:33.82,1:01:39.04,English,,0,0,0,,So you have to put which is really a pain right because you have to put these read calls in a loop
Dialogue: 0,1:01:39.04,1:01:41.72,English,,0,0,0,,And keep looping until it succeeds
Dialogue: 0,1:01:42.90,1:01:46.90,English,,0,0,0,,And finally some systems don't block signals of the type being handled right
Dialogue: 0,1:01:48.92,1:01:52.32,English,,0,0,0,,So that the solution for this is a replacement for signal
Dialogue: 0,1:01:52.32,1:01:54.32,English,,0,0,0,,So the problem is with the signal syscall
Dialogue: 0,1:01:54.94,1:01:58.52,English,,0,0,0,,And the solution is a newer syscall called sigaction
Dialogue: 0,1:01:59.00,1:02:02.32,English,,0,0,0,,Which provides a mechanism a replacement for signal
Dialogue: 0,1:02:02.80,1:02:06.70,English,,0,0,0,,That provides a mechanism for portable and predictable signal handling
Dialogue: 0,1:02:07.54,1:02:14.18,English,,0,0,0,,And so what I've done is created a wrapper called uppercase signal
Dialogue: 0,1:02:15.76,1:02:19.56,English,,0,0,0,,That takes the same arguments as that the signal call
Dialogue: 0,1:02:20.88,1:02:26.04,English,,0,0,0,,But inside it calls the sigaction function to get portable signal handling
Dialogue: 0,1:02:27.44,1:02:32.22,English,,0,0,0,,And so it's not really important to go into detail about this
Dialogue: 0,1:02:34.22,1:02:42.78,English,,0,0,0,,The point is in your code you always want to call Signal using the  wrapper that provided in csapp.c
Dialogue: 0,1:02:43.28,1:02:47.26,English,,0,0,0,,And then if you do that then you'll always block signals of the typing
Dialogue: 0,1:02:47.70,1:02:50.84,English,,0,0,0,,Handle the system will automatically restart
Dialogue: 0,1:02:52.02,1:02:55.28,English,,0,0,0,,Slow syscalls that have been interrupted by by signals
Dialogue: 0,1:02:58.60,1:03:00.84,English,,0,0,0,,Okay so fortunately there's an easy fix for this
Dialogue: 0,1:03:04.48,1:03:06.74,English,,0,0,0,,Now let's finish up with them
Dialogue: 0,1:03:08.78,1:03:11.60,English,,0,0,0,,There's some interesting I mentioned that signals are difficult
Dialogue: 0,1:03:11.60,1:03:14.56,English,,0,0,0,,Because of these the fact that they're concurrent flows
Dialogue: 0,1:03:15.10,1:03:20.36,English,,0,0,0,,So I want to look at some sort of subtle issues that you can run into because of this concurrency
Dialogue: 0,1:03:21.98,1:03:26.56,English,,0,0,0,,And I want to talk about how to identify those errors and how to fix them
Dialogue: 0,1:03:31.20,1:03:35.60,English,,0,0,0,,So here's a program that this is like a simple shell program
Dialogue: 0,1:03:36.40,1:03:41.58,English,,0,0,0,,That maintains a jobs list right so every time it creates a new child
Dialogue: 0,1:03:42.30,1:03:48.04,English,,0,0,0,,It adds it to the jobs list and every time that child terminates it removes it from the jobs list
Dialogue: 0,1:03:51.06,1:04:01.76,English,,0,0,0,,Okay so our simple show just in a loop it just creates a child and then executes the program within that child
Dialogue: 0,1:04:02.46,1:04:09.72,English,,0,0,0,,And then in the parent it correctly blocks all of the signals temporarily while it adds the job to the job queue
Dialogue: 0,1:04:12.60,1:04:16.26,English,,0,0,0,,And then it unblocks and then it unblocks those signals
Dialogue: 0,1:04:17.78,1:04:22.76,English,,0,0,0,,Okay so this is correct and that it's protecting access to this the shared job queue
Dialogue: 0,1:04:25.76,1:04:31.88,English,,0,0,0,,Because job queue is also manipulated by the sigchild handler
Dialogue: 0,1:04:32.06,1:04:37.68,English,,0,0,0,,So when a child terminates and the parent receives the sigchild
Dialogue: 0,1:04:38.26,1:04:40.54,English,,0,0,0,,This handler runs
Dialogue: 0,1:04:41.98,1:04:47.02,English,,0,0,0,,And this handler goes through and it reaps all of the children potentially terminated children
Dialogue: 0,1:04:47.82,1:04:52.42,English,,0,0,0,,And then for each one it deletes that job from the job queue
Dialogue: 0,1:04:52.92,1:04:57.66,English,,0,0,0,,All right so here's a classic case we have two concurrent flows our main routine
Dialogue: 0,1:04:58.44,1:05:00.74,English,,0,0,0,,And our signal handler
Dialogue: 0,1:05:01.82,1:05:06.50,English,,0,0,0,,They're each accessing a shared data structure in this case the job queue
Dialogue: 0,1:05:08.78,1:05:16.62,English,,0,0,0,,Okay and they're there correctly blocking signals while they update this this job queue
Dialogue: 0,1:05:19.12,1:05:23.26,English,,0,0,0,,But this program has a really subtle and nasty bug in it
Dialogue: 0,1:05:25.42,1:05:26.58,English,,0,0,0,,Can you see what it is
Dialogue: 0,1:05:30.60,1:05:32.26,English,,0,0,0,,What's the sequence of events that would
Dialogue: 0,1:05:33.58,1:05:36.50,English,,0,0,0,,Cause this program to fail
Dialogue: 0,1:05:40.82,1:05:41.34,English,,0,0,0,,Yes
Dialogue: 0,1:05:47.22,1:05:52.58,English,,0,0,0,,Exactly that's exactly it,so is it possible that the the child process
Dialogue: 0,1:05:53.34,1:05:58.02,English,,0,0,0,,Could terminate before the parent has a chance to add that job to the queue and the answer is yes
Dialogue: 0,1:05:58.66,1:06:04.78,English,,0,0,0,,Right we you cannot make any assumptions about the execution ordering of the child in the process
Dialogue: 0,1:06:05.14,1:06:06.40,English,,0,0,0,,Or about how long they run right
Dialogue: 0,1:06:06.78,1:06:09.42,English,,0,0,0,,So it's very possible
Dialogue: 0,1:06:10.10,1:06:16.20,English,,0,0,0,,That the child can connect after the four control returns to the child instead of the parent
Dialogue: 0,1:06:16.76,1:06:22.90,English,,0,0,0,,And then the child terminates before the parent ever has a chance to add that job to the job queue
Dialogue: 0,1:06:23.38,1:06:30.10,English,,0,0,0,,So now what's happened is that the child is deleting
Dialogue: 0,1:06:30.92,1:06:35.43,English,,0,0,0,,A deleting a job that hasn't been added to the job queue right
Dialogue: 0,1:06:35.62,1:06:40.30,English,,0,0,0,,Now when the parent finally gets around to running it adds that job to the job queue
Dialogue: 0,1:06:40.58,1:06:42.06,English,,0,0,0,,And that job will never be deleted
Dialogue: 0,1:06:43.96,1:06:50.42,English,,0,0,0,,Right so this is the kind of subtle nasty horrible kind of bug that you run into
Dialogue: 0,1:06:50.78,1:06:52.46,English,,0,0,0,,When you're dealing with concurrency
Dialogue: 0,1:06:53.00,1:06:56.06,English,,0,0,0,,Trying to keep track of all of these interleaving of events
Dialogue: 0,1:06:56.82,1:06:58.78,English,,0,0,0,,Can just make your head explode all right
Dialogue: 0,1:06:59.62,1:07:04.90,English,,0,0,0,,Now and it happens and sig... it happens with any kind of concurrency
Dialogue: 0,1:07:05.30,1:07:09.82,English,,0,0,0,,Where you have concurrent flows accessing shared resources and signal handlers are no different
Dialogue: 0,1:07:10.68,1:07:15.88,English,,0,0,0,,Now we'll look at principled ways where we can deal with this kind of sharing when we study threads later on
Dialogue: 0,1:07:17.34,1:07:22.16,English,,0,0,0,,But I just want to point this out to him scare you a little bit
Dialogue: 0,1:07:23.34,1:07:24.96,English,,0,0,0,,All right so here's how we would fix that
Dialogue: 0,1:07:27.28,1:07:37.74,English,,0,0,0,,What we have to do is somehow avoid the possibility of the child handle or executing
Dialogue: 0,1:07:38.38,1:07:43.28,English,,0,0,0,,Before the parent can add the corresponding job to the job queue
Dialogue: 0,1:07:44.18,1:07:48.54,English,,0,0,0,,Now we can't control whether the child executes first or the parent execute first
Dialogue: 0,1:07:49.62,1:07:51.74,English,,0,0,0,,And we can't control how long the child runs
Dialogue: 0,1:07:52.50,1:07:58.10,English,,0,0,0,,But we can control when the the sigchild handler runs because we can block signals
Dialogue: 0,1:07:58.81,1:08:00.84,English,,0,0,0,,Okay so what we'll do
Dialogue: 0,1:08:02.44,1:08:04.34,English,,0,0,0,,We'll modify our program
Dialogue: 0,1:08:07.36,1:08:12.88,English,,0,0,0,,We'll use sigprocmask to block sigchild signals before we create the child
Dialogue: 0,1:08:14.50,1:08:19.44,English,,0,0,0,,Okay so at this point after this invocation of sigproc,sigchild, signals are blocked
Dialogue: 0,1:08:21.64,1:08:23.32,English,,0,0,0,,Okay then we create the child
Dialogue: 0,1:08:24.68,1:08:27.54,English,,0,0,0,,And before we do execev
Dialogue: 0,1:08:27.90,1:08:34.30,English,,0,0,0,,Since we don't know that child may may need to reap its children right we don't know if it
Dialogue: 0,1:08:34.82,1:08:42.82,English,,0,0,0,,By default children inherit the the blocked a bit vector of their parents okay so when this child runs
Dialogue: 0,1:08:44.60,1:08:51.74,English,,0,0,0,,After it returns from fork at this point right after the fork sigchild is blocked in the child as well right
Dialogue: 0,1:08:52.34,1:08:55.28,English,,0,0,0,,So if we didn't do anything if and the child created children
Dialogue: 0,1:08:56.74,1:09:01.58,English,,0,0,0,,And tried to reap you know reap them with a sigchild handle that sigchild handler wouldn't run right
Dialogue: 0,1:09:01.60,1:09:02.44,English,,0,0,0,,So that would be a problem
Dialogue: 0,1:09:03.42,1:09:08.30,English,,0,0,0,,So in the child before we execute that the program itself we unblock sigchild
Dialogue: 0,1:09:09.16,1:09:11.60,English,,0,0,0,,And this was an example that I was alluding to last time
Dialogue: 0,1:09:12.40,1:09:19.44,English,,0,0,0,,How it's useful sometimes to separate creating processes with executing programs right then
Dialogue: 0,1:09:20.72,1:09:27.52,English,,0,0,0,,So this allows us to get our signal mask set up the way we want it before we run our program in the child
Dialogue: 0,1:09:29.34,1:09:33.82,English,,0,0,0,,So now even if the child terminates early
Dialogue: 0,1:09:36.26,1:09:43.94,English,,0,0,0,,The sigchild handler won't run until after we've added the job to the to the job queue
Dialogue: 0,1:09:44.42,1:09:49.74,English,,0,0,0,,Because we don't unblock sigchild until after the until after we call a job
Dialogue: 0,1:09:57.82,1:09:58.98,English,,0,0,0,,Okay now there's another
Dialogue: 0,1:09:59.26,1:10:04.40,English,,0,0,0,,So this sort of scenario be very relevant to you when you do your shell lab
Dialogue: 0,1:10:05.10,1:10:08.52,English,,0,0,0,,Okay so you want to be careful not to make that mistake
Dialogue: 0,1:10:12.28,1:10:15.84,English,,0,0,0,,Another thing that you're going to need to do in your shell lab
Dialogue: 0,1:10:16.92,1:10:20.22,English,,0,0,0,,Now you remember in our simple our simple shell example we did the wait
Dialogue: 0,1:10:20.74,1:10:24.65,English,,0,0,0,,Inside the main routine so we waited for foreground jobs using wait
Dialogue: 0,1:10:25.48,1:10:31.28,English,,0,0,0,,But now in a real shell we're going to have our sigchild handler do all the all the wait call all the waits
Dialogue: 0,1:10:32.28,1:10:37.58,English,,0,0,0,,And so we can't put the weight has to go in the sigchild handler can't go in the main routine
Dialogue: 0,1:10:40.48,1:10:45.66,English,,0,0,0,,Okay so high if we can't put a weight in the main routine
Dialogue: 0,1:10:46.88,1:10:50.88,English,,0,0,0,,How are we going to detect that our foreground job is finished
Dialogue: 0,1:10:56.50,1:11:01.42,English,,0,0,0,,Okay so somehow so what we could do?we could define in the sigchild handler
Dialogue: 0,1:11:03.00,1:11:05.16,English,,0,0,0,,When we read the foreground job
Dialogue: 0,1:11:06.84,1:11:10.42,English,,0,0,0,,Right we've created a foreground job when we read that foreground job
Dialogue: 0,1:11:11.18,1:11:14.92,English,,0,0,0,,We could set this global flag
Dialogue: 0,1:11:16.02,1:11:18.48,English,,0,0,0,,We could declare the process this process id
Dialogue: 0,1:11:19.14,1:11:21.98,English,,0,0,0,,A variable pid as a global flag
Dialogue: 0,1:11:22.64,1:11:27.86,English,,0,0,0,,And then just assign the process id of the foreground job
Dialogue: 0,1:11:29.50,1:11:34.06,English,,0,0,0,,Okay so this is an example of a handler it just all it does it sets a flag and then exits
Dialogue: 0,1:11:38.92,1:11:45.56,English,,0,0,0,,And then in our main routine,okay we want to block sigchild just by just like before
Dialogue: 0,1:11:45.94,1:11:51.24,English,,0,0,0,,Okay to avoid that race condition between the parent and the child
Dialogue: 0,1:11:53.48,1:11:55.42,English,,0,0,0,,And then we create the child
Dialogue: 0,1:11:57.40,1:12:01.54,English,,0,0,0,,And then in the and then the parent we set pid to zero
Dialogue: 0,1:12:03.92,1:12:05.70,English,,0,0,0,,Okay then we unblock sigchild
Dialogue: 0,1:12:07.30,1:12:11.76,English,,0,0,0,,And then we wait for the sigchild handler to run and set pid to nonzero
Dialogue: 0,1:12:15.56,1:12:18.34,English,,0,0,0,,Okay everybody see that I mean this so this is correct right
Dialogue: 0,1:12:19.70,1:12:21.30,English,,0,0,0,,But it's extremely wasteful right
Dialogue: 0,1:12:21.64,1:12:29.96,English,,0,0,0,,We're spinning...we're using valuable processor cycles in this tight spin loop
Dialogue: 0,1:12:30.14,1:12:33.74,English,,0,0,0,,Just executing over and over and over and over and over and over, for who knows how long
Dialogue: 0,1:12:35.14,1:12:38.72,English,,0,0,0,,Okay so that's not a good solution alright
Dialogue: 0,1:12:38.80,1:12:41.86,English,,0,0,0,,So let's look at a couple other things we might consider
Dialogue: 0,1:12:42.64,1:12:46.30,English,,0,0,0,,And that have been considered by generations of 213 students
Dialogue: 0,1:12:49.70,1:12:54.92,English,,0,0,0,,So one thing you might think well I'll just instead of just putting a semicolon here
Dialogue: 0,1:12:55.50,1:12:56.62,English,,0,0,0,,I'll pause
Dialogue: 0,1:12:58.56,1:13:02.06,English,,0,0,0,,And then I'll wait for the sigchild handler to run
Dialogue: 0,1:13:03.44,1:13:05.34,English,,0,0,0,,And then I'll go back up and I'll check
Dialogue: 0,1:13:06.26,1:13:07.44,English,,0,0,0,,I'll check pid again
Dialogue: 0,1:13:08.80,1:13:11.64,English,,0,0,0,,Now you have to put this in a loop it still has to be in a loop
Dialogue: 0,1:13:12.56,1:13:16.72,English,,0,0,0,,Because we have other signal handlers in our program we have a sigint handler
Dialogue: 0,1:13:17.72,1:13:22.50,English,,0,0,0,,So it might be if we do the pause here and this again comes in and say get sigint handler runs
Dialogue: 0,1:13:24.02,1:13:27.14,English,,0,0,0,,That would cause us to exit the pause function and go back up
Dialogue: 0,1:13:27.36,1:13:29.80,English,,0,0,0,,So we have to keep checking pid because we're not sure
Dialogue: 0,1:13:30.66,1:13:37.66,English,,0,0,0,,We have to keep checking for the specific signal handler sigchild handler to run instead of other handlers that might run
Dialogue: 0,1:13:39.32,1:13:41.28,English,,0,0,0,,But this is actually wrong
Dialogue: 0,1:13:44.36,1:13:47.74,English,,0,0,0,,Because it has a race can you see what the race is
Dialogue: 0,1:13:54.54,1:13:58.62,English,,0,0,0,,What's wrong with this there's a good chance that this thing will block forever
Dialogue: 0,1:14:03.50,1:14:15.92,English,,0,0,0,,Yes
Dialogue: 0,1:14:16.06,1:14:20.46,English,,0,0,0,,Yeah that's so the problem with this is like
Dialogue: 0,1:14:20.90,1:14:26.12,English,,0,0,0,,So if the signal is received after pid is checked
Dialogue: 0,1:14:27.00,1:14:28.66,English,,0,0,0,,But before the pause executes
Dialogue: 0,1:14:29.54,1:14:31.82,English,,0,0,0,,Okay which is possible right
Dialogue: 0,1:14:33.14,1:14:35.76,English,,0,0,0,,It's unlikely but it's possible
Dialogue: 0,1:14:37.54,1:14:41.52,English,,0,0,0,,If that signal is arrives here
Dialogue: 0,1:14:42.62,1:14:45.36,English,,0,0,0,,Then the handler will set pid to nonzero and
Dialogue: 0,1:14:46.08,1:14:47.82,English,,0,0,0,,Then we'll execute the pause
Dialogue: 0,1:14:49.00,1:14:53.32,English,,0,0,0,,And the pause will be blocked forever waiting for a signal that will never arrive right
Dialogue: 0,1:14:53.84,1:14:56.14,English,,0,0,0,,Because the sigchild signal already already came
Dialogue: 0,1:14:57.56,1:14:58.80,English,,0,0,0,,Very subtle right
Dialogue: 0,1:15:00.28,1:15:03.42,English,,0,0,0,,So this code looks okay it looks benign but it's wrong
Dialogue: 0,1:15:04.46,1:15:08.48,English,,0,0,0,,And your program would just hang forever
Dialogue: 0,1:15:09.60,1:15:11.26,English,,0,0,0,,So we say well okay that's no good
Dialogue: 0,1:15:11.80,1:15:16.36,English,,0,0,0,,We could replace the pause with asleep so we could say let's check pid
Dialogue: 0,1:15:17.26,1:15:22.52,English,,0,0,0,,And then sleep for some predetermined amount of time in this case one second
Dialogue: 0,1:15:24.68,1:15:26.98,English,,0,0,0,,And then go back up and check pid again
Dialogue: 0,1:15:28.42,1:15:34.00,English,,0,0,0,,So this while this is correct it's way too slow right we're asking the system to wait for a second which is an eternity
Dialogue: 0,1:15:35.10,1:15:40.02,English,,0,0,0,,And there's forms of sleep nanosecond where you can wait instead of units of seconds
Dialogue: 0,1:15:40.02,1:15:41.76,English,,0,0,0,,You can wait in units of nanoseconds
Dialogue: 0,1:15:42.26,1:15:44.32,English,,0,0,0,,But that what value do you use right
Dialogue: 0,1:15:45.16,1:15:51.48,English,,0,0,0,,If it's it that so that's if you choose a value that's too large then you have this problem the slowness problem
Dialogue: 0,1:15:51.82,1:15:54.90,English,,0,0,0,,If you choose a sleep time that's too small
Dialogue: 0,1:15:55.30,1:15:57.64,English,,0,0,0,,Then you have the other problem that it's inefficient
Dialogue: 0,1:15:59.20,1:16:01.14,English,,0,0,0,,So the solution is to use sigsuspend
Dialogue: 0,1:16:03.04,1:16:05.70,English,,0,0,0,,Which is the last thing we're going to look at today
Dialogue: 0,1:16:06.84,1:16:11.58,English,,0,0,0,,So sigsuspend is a function that takes a signal mask
Dialogue: 0,1:16:12.94,1:16:17.64,English,,0,0,0,,And it's equivalent to an uninterruptible version of these three statements
Dialogue: 0,1:16:18.88,1:16:23.40,English,,0,0,0,,So we block the signals that are specified in the signal mask
Dialogue: 0,1:16:25.18,1:16:27.46,English,,0,0,0,,And then it's atomic in the sense that
Dialogue: 0,1:16:30.28,1:16:36.22,English,,0,0,0,,After that this these two statements can't be interrupted they're always executed together
Dialogue: 0,1:16:37.28,1:16:39.34,English,,0,0,0,,Okay so we blocked these signals
Dialogue: 0,1:16:40.34,1:16:41.84,English,,0,0,0,,And then we execute the pause
Dialogue: 0,1:16:44.08,1:16:45.30,English,,0,0,0,,Okay so there's no chance
Dialogue: 0,1:16:46.18,1:16:51.60,English,,0,0,0,,Of a signal interrupting this program in between the sigprocmask and the pause
Dialogue: 0,1:16:54.58,1:16:58.74,English,,0,0,0,,Okay and then when a signal does come in and
Dialogue: 0,1:17:00.28,1:17:05.80,English,,0,0,0,,The execution of the handle or causes pause to exit then we set the mask back to what it was before
Dialogue: 0,1:17:08.34,1:17:10.82,English,,0,0,0,,Okay so the proper way then to wait for a signal
Dialogue: 0,1:17:11.74,1:17:13.88,English,,0,0,0,,Is to use sigsuspend in the following way
Dialogue: 0,1:17:14.82,1:17:16.52,English,,0,0,0,,So here's our here's our program again
Dialogue: 0,1:17:17.82,1:17:20.80,English,,0,0,0,,We before we create the child we block sigchild
Dialogue: 0,1:17:21.54,1:17:22.78,English,,0,0,0,,Then we create the child
Dialogue: 0,1:17:23.96,1:17:26.42,English,,0,0,0,,And now we're going to wait for the sigchild to be received
Dialogue: 0,1:17:27.72,1:17:29.48,English,,0,0,0,,Now sigchild is still blocked
Dialogue: 0,1:17:30.26,1:17:34.90,English,,0,0,0,,Okay so there's no danger of the sigchild handler running
Dialogue: 0,1:17:35.42,1:17:38.26,English,,0,0,0,,Okay so we set that global variable to zero
Dialogue: 0,1:17:39.74,1:17:44.52,English,,0,0,0,,And then while it's while it's nonzero we repeatedly call sigsuspend
Dialogue: 0,1:17:46.22,1:17:48.48,English,,0,0,0,,And sigsuspend is using the previous mask
Dialogue: 0,1:17:49.02,1:17:51.76,English,,0,0,0,,That was set up here so sigsuspend is using the mask
Dialogue: 0,1:17:52.50,1:17:54.53,English,,0,0,0,,Where sigchild is unblocked
Dialogue: 0,1:17:55.42,1:18:01.48,English,,0,0,0,,Okay when we entered this first sigprocmask,sigchild was unblocked
Dialogue: 0,1:18:03.32,1:18:08.70,English,,0,0,0,,So this allows inside the sigsuspend sigchild is unblocked
Dialogue: 0,1:18:09.80,1:18:15.42,English,,0,0,0,,Okay so it allows for the handler now to be received or to be executed
Dialogue: 0,1:18:17.16,1:18:21.20,English,,0,0,0,,Okay so in and it does it safely because of the...
Dialogue: 0,1:18:21.72,1:18:24.84,English,,0,0,0,, The atomic nature of those those first two instructions
Dialogue: 0,1:18:27.44,1:18:33.16,English,,0,0,0,,So once the so it's possible that implicit pause inside of sigchild
Dialogue: 0,1:18:33.16,1:18:37.02,English,,0,0,0,,Could be interrupted by say another signal like sigint
Dialogue: 0,1:18:38.28,1:18:42.60,English,,0,0,0,,Okay in which case we'd loop back up we notice that pid was still zero
Dialogue: 0,1:18:42.96,1:18:47.18,English,,0,0,0,,And we go back into sigsuspend with sigchild unblocked
Dialogue: 0,1:18:47.56,1:18:50.16,English,,0,0,0,,Okay so that makes sense to everybody
Dialogue: 0,1:18:50.16,1:18:55.42,English,,0,0,0,,And now so this is exactly the behavior we want where we're not wasting resources but we've eliminated the race
Dialogue: 0,1:18:59.28,1:19:04.44,English,,0,0,0,,Okay so that's it for today if you're interested nonlocal jumps are this weird thing in C
Dialogue: 0,1:19:04.94,1:19:08.92,English,,0,0,0,,That allows a function to return to some other function that didn't call it
Dialogue: 0,1:19:11.14,1:19:17.37,English,,0,0,0,,Okay but it's described in your textbook and also in some additional slides here if you if you're interested
