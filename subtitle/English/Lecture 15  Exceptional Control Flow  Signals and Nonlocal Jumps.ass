[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video File: ../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 865
Active Line: 876
Video Position: 142535

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.94,csapp,,0,0,0,,good afternoon everybody welcome 
Dialogue: 0,0:00:02.86,0:00:03.68,csapp,,0,0,0,,good to see you 
Dialogue: 0,0:00:05.02,0:00:08.52,csapp,,0,0,0,,today we're going to continue our study of exceptional control flow  
Dialogue: 0,0:00:09.56,0:00:16.24,csapp,,0,0,0,,by looking at some higher level mechanisms known as Linux signals and see non-local jumps
Dialogue: 0,0:00:16.90,0:00:21.42,csapp,,0,0,0,, now we're going to spend most of our most of our time looking at signals
Dialogue: 0,0:00:21.62,0:00:26.14,csapp,,0,0,0,,because they have a lot of subtleties the semantics can be kind of confusing
Dialogue: 0,0:00:26.14,0:00:28.62,csapp,,0,0,0,,so we're going to we're going to spend most of our time there 
Dialogue: 0,0:00:29.36,0:00:33.70,csapp,,0,0,0,,and I'll mention the idea of non-local jumps but 
Dialogue: 0,0:00:36.08,0:00:38.70,csapp,,0,0,0,,for details on those you'll want to look in your textbook
Dialogue: 0,0:00:38.84,0:00:43.40,csapp,,0,0,0,, and in the slides at the Supplemental slides at the end of this the slide deck
Dialogue: 0,0:00:45.64,0:00:48.06,csapp,,0,0,0,, now to motivate the notion of signals 
Dialogue: 0,0:00:49.00,0:00:54.40,csapp,,0,0,0,,I want to want to talk a little bit about shell programs
Dialogue: 0,0:00:56.08,0:01:01.54,csapp,,0,0,0,, now as we mentioned last time there's only one way to create processes on a Linux system
Dialogue: 0,0:01:01.56,0:01:03.24,csapp,,0,0,0,, and that's using the fork call 
Dialogue: 0,0:01:04.14,0:01:09.84,csapp,,0,0,0,,in fact the all of the processes on the system actually form a hierarchy 
Dialogue: 0,0:01:09.88,0:01:15.68,csapp,,0,0,0,,so that the very first process created when you boot the system up is the init process
Dialogue: 0,0:01:16.08,0:01:17.92,csapp,,0,0,0,,which has a process ID of 1 
Dialogue: 0,0:01:18.48,0:01:23.81,csapp,,0,0,0,,and then all other processes on the system are descendants of that of that init process
Dialogue: 0,0:01:24.68,0:01:29.04,csapp,,0,0,0,,now the init process when it starts up it creates daemons 
Dialogue: 0,0:01:29.76,0:01:34.54,csapp,,0,0,0,,which are long-running programs that provide services typically so for example of a
Dialogue: 0,0:01:35.84,0:01:41.44,csapp,,0,0,0,,web server it other kinds of services that you always want running on the system
Dialogue: 0,0:01:42.26,0:01:45.90,csapp,,0,0,0,, and then eventually it creates login so called login shells 
Dialogue: 0,0:01:46.50,0:01:49.34,csapp,,0,0,0,,which provide the command-line interface to two users 
Dialogue: 0,0:01:50.10,0:01:52.48,csapp,,0,0,0,,so when you log into a Linux system
Dialogue: 0,0:01:53.10,0:01:55.84,csapp,,0,0,0,, what you eventually get to is that is a login shell 
Dialogue: 0,0:01:56.12,0:01:58.98,csapp,,0,0,0,,that's expecting you to type commands
Dialogue: 0,0:02:01.72,0:02:07.36,csapp,,0,0,0,, now the login login shells execute programs on your your behalf
Dialogue: 0,0:02:08.52,0:02:11.92,csapp,,0,0,0,, so when we type something into the shell
Dialogue: 0,0:02:13.00,0:02:21.62,csapp,,0,0,0,,say we type the LS command we're asking we're asking the shell to run the executable program called LS 
Dialogue: 0,0:02:22.80,0:02:25.68,csapp,,0,0,0,,and so what the shell will do is it will create a child
Dialogue: 0,0:02:26.38,0:02:30.16,csapp,,0,0,0,, and then it will execute LS within that child process 
Dialogue: 0,0:02:31.12,0:02:37.28,csapp,,0,0,0,,and it's possible that that process may create other other child processes 
Dialogue: 0,0:02:40.36,0:02:44.34,csapp,,0,0,0,,so a shell is an application program no different from any other program
Dialogue: 0,0:02:45.02,0:02:47.78,csapp,,0,0,0,, that executes programs on the behalf of users 
Dialogue: 0,0:02:49.62,0:02:52.56,csapp,,0,0,0,,okay the default shell for Linux is called bash 
Dialogue: 0,0:02:52.72,0:03:01.66,csapp,,0,0,0,,but there's there's other shells that that were created on earlier  with earlier versions of UNIX 
Dialogue: 0,0:03:02.26,0:03:07.38,csapp,,0,0,0,,SH was the original shell called the Bourne shell because it was created by Stephen Bourne
Dialogue: 0,0:03:07.82,0:03:10.26,csapp,,0,0,0,,and when berkeley came out with their distribution of Unix
Dialogue: 0,0:03:10.72,0:03:13.18,csapp,,0,0,0,, they created a shell called the CSH 
Dialogue: 0,0:03:14.68,0:03:21.90,csapp,,0,0,0,,now the the execution is in a shell is a sequence of read and evaluate steps
Dialogue: 0,0:03:22.80,0:03:24.96,csapp,,0,0,0,, so first a shell prints out a prompt 
Dialogue: 0,0:03:25.84,0:03:30.96,csapp,,0,0,0,,and then it waits for it waits for you to type something in on the command line and hit return
Dialogue: 0,0:03:32.24,0:03:34.40,csapp,,0,0,0,,okay and typically what you're what you're typing in 
Dialogue: 0,0:03:35.06,0:03:38.14,csapp,,0,0,0,,is a is a command which is just the 
Dialogue: 0,0:03:38.74,0:03:44.10,csapp,,0,0,0,,so the first thing you type is a command and then you follow that with optional arguments separated by spaces
Dialogue: 0,0:03:44.90,0:03:50.90,csapp,,0,0,0,, okay so once you hit once you type in a command and those optional arguments and hit return
Dialogue: 0,0:03:51.72,0:04:00.36,csapp,,0,0,0,, the shell checks for the end of file character which is a Ctrl-D to terminal 
Dialogue: 0,0:04:00.60,0:04:04.56,csapp,,0,0,0,,and if so it exits otherwise it evaluates that command line 
Dialogue: 0,0:04:05.46,0:04:06.96,csapp,,0,0,0,,and the evaluation consists
Dialogue: 0,0:04:10.48,0:04:14.14,csapp,,0,0,0,,and then when it returns from the evaluation it just does the same thing over in it
Dialogue: 0,0:04:14.66,0:04:21.40,csapp,,0,0,0,, now the evaluation consists of the following kinds of steps first
Dialogue: 0,0:04:22.50,0:04:24.18,csapp,,0,0,0,, it parses the command line
Dialogue: 0,0:04:25.92,0:04:32.76,csapp,,0,0,0,,and bite and and in the process so it takes the command-line which in this example is in buff 
Dialogue: 0,0:04:33.10,0:04:37.46,csapp,,0,0,0,,and it produces argv array okay where argv[0] is a command
Dialogue: 0,0:04:37.92,0:04:41.16,csapp,,0,0,0,,and then argv[1] and argv[2] and so on are the optional arguments 
Dialogue: 0,0:04:42.82,0:04:48.24,csapp,,0,0,0,,and the convention in a shell is that if the command line is terminated 
Dialogue: 0,0:04:49.56,0:04:52.80,csapp,,0,0,0,,by an ampersand then you're asking the shell to run that job
Dialogue: 0,0:04:53.38,0:04:55.14,csapp,,0,0,0,, to run that command in the background meaning
Dialogue: 0,0:04:56.02,0:04:58.18,csapp,,0,0,0,, the shell won't wait for that job to finish 
Dialogue: 0,0:04:58.78,0:05:00.68,csapp,,0,0,0,,before it goes through its next read stub 
Dialogue: 0,0:05:01.44,0:05:05.72,csapp,,0,0,0,,if it if the the line that you type doesn't have an ampersand
Dialogue: 0,0:05:05.72,0:05:10.38,csapp,,0,0,0,, then you're asking the shell to to run that job in the foreground which means the shell will wait
Dialogue: 0,0:05:13.56,0:05:19.38,csapp,,0,0,0,, so so first we parse this this command line into an argv array 
Dialogue: 0,0:05:19.42,0:05:25.46,csapp,,0,0,0,,and we return whether or not it was terminated by an ampersand  D so BG for background
Dialogue: 0,0:05:26.42,0:05:31.90,csapp,,0,0,0,,if argv[0] is null then that means we just hit a we just hit return right so as an empty line 
Dialogue: 0,0:05:32.58,0:05:35.04,csapp,,0,0,0,,so we'll just return and just ignore those 
Dialogue: 0,0:05:36.54,0:05:41.66,csapp,,0,0,0,,now a shell also implements what are called built-in commands
Dialogue: 0,0:05:41.90,0:05:47.36,csapp,,0,0,0,, so various things like jobs bg, fg
Dialogue: 0,0:05:47.82,0:05:51.96,csapp,,0,0,0,,are examples of built-in commands which are just implemented in the shell itself
Dialogue: 0,0:05:53.14,0:05:55.32,csapp,,0,0,0,, so if you type if the first thing you type
Dialogue: 0,0:05:56.20,0:05:58.48,csapp,,0,0,0,, if the command you enter is a built in
Dialogue: 0,0:05:59.24,0:06:06.02,csapp,,0,0,0,, then the shell will it will check that it will check argv[0] for a to see if it's a built-in command 
Dialogue: 0,0:06:06.64,0:06:11.70,csapp,,0,0,0,,and if it is it'll just execute it whatever whatever it is you asked it to do 
Dialogue: 0,0:06:13.76,0:06:20.14,csapp,,0,0,0,,okay otherwise if it's not a built-in then that means that that you're asking the shell to run some program 
Dialogue: 0,0:06:22.42,0:06:24.92,csapp,,0,0,0,,okay so in that case the shell will fork a child
Dialogue: 0,0:06:26.34,0:06:31.60,csapp,,0,0,0,,and then the child will execute that program  by calling execve
Dialogue: 0,0:06:32.98,0:06:35.50,csapp,,0,0,0,,passing as the first argument the name of the command
Dialogue: 0,0:06:36.18,0:06:41.24,csapp,,0,0,0,, and as the second and third argv and and the environment respectively
Dialogue: 0,0:06:42.10,0:06:46.86,csapp,,0,0,0,,now exactly if you recall from last time never returns  unless there's an error
Dialogue: 0,0:06:47.37,0:06:51.48,csapp,,0,0,0,, so it checks so we check it the return value for execve 
Dialogue: 0,0:06:52.70,0:06:56.98,csapp,,0,0,0,,and if it returns less than zero fact the only time it will return
Dialogue: 0,0:06:57.54,0:07:01.90,csapp,,0,0,0,, if it does return it will always return -1
Dialogue: 0,0:07:02.32,0:07:04.56,csapp,,0,0,0,, but we're just being careful here 
Dialogue: 0,0:07:05.24,0:07:12.32,csapp,,0,0,0,,so we check that for a an error and in in print and error message if we find an error and then exit 
Dialogue: 0,0:07:15.26,0:07:22.06,csapp,,0,0,0,,so once the once the once the parent gets control again 
Dialogue: 0,0:07:22.76,0:07:25.20,csapp,,0,0,0,,then it waits for that foreground job to terminate 
Dialogue: 0,0:07:26.22,0:07:28.52,csapp,,0,0,0,,okay so if it's not a background job 
Dialogue: 0,0:07:29.30,0:07:32.18,csapp,,0,0,0,,then it waits for it to terminate by calling waitpid
Dialogue: 0,0:07:33.34,0:07:38.70,csapp,,0,0,0,,and waiting for that child that foreground job to terminate and then and reaping it 
Dialogue: 0,0:07:39.44,0:07:43.96,csapp,,0,0,0,,otherwise if it's a background job it just prints say a message and goes on 
Dialogue: 0,0:07:44.82,0:07:46.44,csapp,,0,0,0,,so this is really interesting right that 
Dialogue: 0,0:07:46.74,0:07:50.98,csapp,,0,0,0,,there's really the only difference between a foreground job and a background job is just that the shell 
Dialogue: 0,0:07:51.76,0:07:53.62,csapp,,0,0,0,,does a waitpid on that job or not 
Dialogue: 0,0:07:54.02,0:07:57.46,csapp,,0,0,0,,right so there otherwise there's really there's really no difference 
Dialogue: 0,0:07:58.78,0:08:03.68,csapp,,0,0,0,,now what's the prob there's a problem with our example show 
Dialogue: 0,0:08:05.88,0:08:09.88,csapp,,0,0,0,,and that the problem is that we're we're doing the right thing for the foreground job 
Dialogue: 0,0:08:10.40,0:08:13.72,csapp,,0,0,0,,we always have to reap these children so they they so that
Dialogue: 0,0:08:15.10,0:08:17.54,csapp,,0,0,0,,they're their state can be released 
Dialogue: 0,0:08:19.82,0:08:23.62,csapp,,0,0,0,,but we're not we're not doing anything to reap any background jobs 
Dialogue: 0,0:08:23.80,0:08:26.78,csapp,,0,0,0,,right when if the background job so if not BG 
Dialogue: 0,0:08:27.26,0:08:29.38,csapp,,0,0,0,,we're just printing a message and then we're returning
Dialogue: 0,0:08:30.30,0:08:32.80,csapp,,0,0,0,, and then we're continuing with this read evaluate step 
Dialogue: 0,0:08:33.58,0:08:38.82,csapp,,0,0,0,,and never never going back and and taking care of that of that background job 
Dialogue: 0,0:08:40.40,0:08:44.24,csapp,,0,0,0,,so this is a problem because that the background job will eventually become
Dialogue: 0,0:08:45.82,0:08:51.46,csapp,,0,0,0,, if we have enough of those jobs we create a memory leak that could crash the system right so this is an error
Dialogue: 0,0:08:52.36,0:08:53.72,csapp,,0,0,0,,so what are we going to do about this
Dialogue: 0,0:08:54.38,0:08:59.10,csapp,,0,0,0,,well it turns out that exceptional control flow will help us solve this problem
Dialogue: 0,0:09:00.08,0:09:04.72,csapp,,0,0,0,, and what happens is that the kernel will notify 
Dialogue: 0,0:09:05.18,0:09:08.54,csapp,,0,0,0,,the shell when when a any of its children terminate 
Dialogue: 0,0:09:09.78,0:09:14.82,csapp,,0,0,0,,okay and then the shell can can then react to that and issue a waitpid 
Dialogue: 0,0:09:15.46,0:09:21.18,csapp,,0,0,0,,okay and this this notification mechanism that the the kernel uses is something called a signal
Dialogue: 0,0:09:25.92,0:09:28.22,csapp,,0,0,0,,so a signal is a small message 
Dialogue: 0,0:09:29.98,0:09:36.82,csapp,,0,0,0,,that the kernel delivers to a process to notify it that there's been some event in the system
Dialogue: 0,0:09:37.66,0:09:44.18,csapp,,0,0,0,, now so this is very similar to the exceptions that we studied the last time
Dialogue: 0,0:09:44.34,0:09:47.52,csapp,,0,0,0,, right except it's it's it's all implemented in software 
Dialogue: 0,0:09:49.12,0:09:53.02,csapp,,0,0,0,,now kernel signals are always sent from the kernel
Dialogue: 0,0:09:53.02,0:09:56.38,csapp,,0,0,0,,but sometimes they're sent at the request of another process 
Dialogue: 0,0:09:56.82,0:10:00.42,csapp,,0,0,0,,right sometimes the the kernel will notice that there's some event 
Dialogue: 0,0:10:01.22,0:10:07.06,csapp,,0,0,0,,other times another process will ask the kernel to send a message to some other process 
Dialogue: 0,0:10:08.52,0:10:11.52,csapp,,0,0,0,,now that we say that it's a small message
Dialogue: 0,0:10:12.22,0:10:15.42,csapp,,0,0,0,,because the only information that's contained in a signal 
Dialogue: 0,0:10:16.00,0:10:18.66,csapp,,0,0,0,,is its it's a unique integer ID 
Dialogue: 0,0:10:19.66,0:10:23.50,csapp,,0,0,0,,and the fact that it was it was it was delivered okay so
Dialogue: 0,0:10:24.34,0:10:27.94,csapp,,0,0,0,,that's so there's nothing else in a signal except except that it arrived 
Dialogue: 0,0:10:28.18,0:10:31.88,csapp,,0,0,0,,and that it has some some some unique ID 
Dialogue: 0,0:10:33.04,0:10:37.26,csapp,,0,0,0,,now examples of these are the sigint 
Dialogue: 0,0:10:37.48,0:10:41.60,csapp,,0,0,0,,so signals have this I this unique ID and then they also have a name 
Dialogue: 0,0:10:44.80,0:10:51.32,csapp,,0,0,0,,so the sigint is what the when you type control C at on the command line
Dialogue: 0,0:10:51.64,0:10:56.90,csapp,,0,0,0,, the kernel sends a signal to every any processes in the foreground 
Dialogue: 0,0:10:57.26,0:11:00.52,csapp,,0,0,0,,and the default action of receiving a SIGINT is to terminate right
Dialogue: 0,0:11:00.52,0:11:04.06,csapp,,0,0,0,,so this is how if you're running a foreground job you hit Ctrl-C
Dialogue: 0,0:11:04.52,0:11:07.08,csapp,,0,0,0,,you get the prompt back because it kills that job 
Dialogue: 0,0:11:08.36,0:11:13.84,csapp,,0,0,0,,sigkill number nine can be used to kill terminate any program 
Dialogue: 0,0:11:15.78,0:11:22.74,csapp,,0,0,0,,so these two have sig ant and sigkill have the same effect on the programs me that they kill the program
Dialogue: 0,0:11:23.02,0:11:30.36,csapp,,0,0,0,, the the unique aspect of sig kill is that there's no way to ignore it or override it 
Dialogue: 0,0:11:30.89,0:11:32.18,csapp,,0,0,0,,okay so this is like the failsafe 
Dialogue: 0,0:11:33.36,0:11:38.48,csapp,,0,0,0,,as we'll see there are there are ways to to catch and ignore other signals like sigint
Dialogue: 0,0:11:40.22,0:11:43.32,csapp,,0,0,0,,SIGSEGV is the our favorite segment
Dialogue: 0,0:11:43.54,0:11:51.24,csapp,,0,0,0,,segmentation violation so if you if you access a region of memory that's protected or or not legal
Dialogue: 0,0:11:52.48,0:11:57.74,csapp,,0,0,0,, then your program will the kernel will send your that process a sigsegv 
Dialogue: 0,0:11:58.46,0:12:06.40,csapp,,0,0,0,,okay signal and that the default  the default effective that is to terminate the program 
Dialogue: 0,0:12:07.08,0:12:11.72,csapp,,0,0,0,,sigalrm is a way within your program you can arrange for a signal to be sent to yourself
Dialogue: 0,0:12:12.32,0:12:18.94,csapp,,0,0,0,, so you can say inside your program send me a sigalrm signal  in three seconds something like that 
Dialogue: 0,0:12:21.58,0:12:27.00,csapp,,0,0,0,,so this is a way to do things like you can set up timers you can set up timeouts like if you want to 
Dialogue: 0,0:12:27.60,0:12:32.88,csapp,,0,0,0,,X if you want to set a timeout value and you're doing some some some work and 
Dialogue: 0,0:12:33.28,0:12:36.60,csapp,,0,0,0,,you want to guard against that that work taking exceptionally long time 
Dialogue: 0,0:12:36.60,0:12:39.76,csapp,,0,0,0,,you can you can you can use sigalrm to set a timeout
Dialogue: 0,0:12:40.64,0:12:46.72,csapp,,0,0,0,,and then a very important one is as we'll see that would be very important for our shell is the sigchild signal
Dialogue: 0,0:12:47.30,0:12:54.48,csapp,,0,0,0,,which the colonel sends to a parent every time one of its children terminates  or stops 
Dialogue: 0,0:12:55.48,0:12:57.90,csapp,,0,0,0,,okay so this as we'll see now 
Dialogue: 0,0:12:58.44,0:13:02.58,csapp,,0,0,0,,we'll see this is how we're going this is how our shell that is going to actually reap
Dialogue: 0,0:13:02.66,0:13:08.40,csapp,,0,0,0,, it's it's all of its children right is by taking advantage of the sigchild signal 
Dialogue: 0,0:13:09.78,0:13:11.92,csapp,,0,0,0,,but before I can show you that 
Dialogue: 0,0:13:12.46,0:13:18.58,csapp,,0,0,0,,we need to go through a number of concepts around signals 
Dialogue: 0,0:13:20.00,0:13:24.32,csapp,,0,0,0,,okay like I said the the semantics of signals 
Dialogue: 0,0:13:24.74,0:13:27.54,csapp,,0,0,0,,it's probably one of the thorniest aspects of Linux 
Dialogue: 0,0:13:28.94,0:13:34.24,csapp,,0,0,0,,it was it was developed very early in the the lifespan of Linux when 
Dialogue: 0,0:13:35.32,0:13:40.98,csapp,,0,0,0,,and it maybe wasn't as clean as it could be right so
Dialogue: 0,0:13:41.44,0:13:45.36,csapp,,0,0,0,,in order to get a handle on signals we're going to be very careful about defining terms 
Dialogue: 0,0:13:45.54,0:13:47.24,csapp,,0,0,0,,and very careful about the way 
Dialogue: 0,0:13:47.62,0:13:48.88,csapp,,0,0,0,,we talk about them
Dialogue: 0,0:13:50.26,0:13:57.46,csapp,,0,0,0,, so we say that the kernel sends or delivers a signal to some destination process 
Dialogue: 0,0:13:58.52,0:14:04.98,csapp,,0,0,0,,and it does this by setting some state in the context of the destination process
Dialogue: 0,0:14:05.76,0:14:14.00,csapp,,0,0,0,,now nothing happens except that some bits get changed in the destination process context 
Dialogue: 0,0:14:14.32,0:14:19.02,csapp,,0,0,0,,okay there's no there's no impact of immediate impact of sending a signal
Dialogue: 0,0:14:22.94,0:14:24.80,csapp,,0,0,0,, now a kernel sends a signal
Dialogue: 0,0:14:25.92,0:14:29.68,csapp,,0,0,0,,either because it detected some event in the in the system like 
Dialogue: 0,0:14:30.38,0:14:33.02,csapp,,0,0,0,,that like a child process is terminated for example 
Dialogue: 0,0:14:34.66,0:14:37.84,csapp,,0,0,0,,or another process has asked the kernel to send
Dialogue: 0,0:14:38.52,0:14:41.42,csapp,,0,0,0,, to deliver a process on a signal on its behalf 
Dialogue: 0,0:14:43.38,0:14:47.04,csapp,,0,0,0,,and there's a number of ways to do that one of them is with the kill system call 
Dialogue: 0,0:14:48.88,0:14:51.48,csapp,,0,0,0,,it's kind of an unfortunate tournament 
Dialogue: 0,0:14:52.18,0:14:55.50,csapp,,0,0,0,,I mean the so kill is a general way to send signals
Dialogue: 0,0:14:56.10,0:15:01.50,csapp,,0,0,0,, and the the impact is not as is sometimes not to kill the program right 
Dialogue: 0,0:15:01.52,0:15:04.36,csapp,,0,0,0,,but for some reason they chose to to call it kill
Dialogue: 0,0:15:07.72,0:15:11.70,csapp,,0,0,0,,now the destination process receives a signal
Dialogue: 0,0:15:13.08,0:15:20.54,csapp,,0,0,0,, when it's forced by the kernel to act in some way to react in some way to the delivery of a signal 
Dialogue: 0,0:15:22.34,0:15:29.02,csapp,,0,0,0,,okay so these are two very different things sending a signal set state in the context of the destination process 
Dialogue: 0,0:15:29.84,0:15:36.82,csapp,,0,0,0,,receiving a signal is what happens when the destination process is is finally 
Dialogue: 0,0:15:37.16,0:15:40.90,csapp,,0,0,0,,forced by the kernel to act in some way to react in some way
Dialogue: 0,0:15:41.82,0:15:45.70,csapp,,0,0,0,,now some possible ways to react are to just ignore the signal 
Dialogue: 0,0:15:49.14,0:15:50.46,csapp,,0,0,0,,okay to terminate the process 
Dialogue: 0,0:15:52.98,0:15:58.50,csapp,,0,0,0,,or to catch the signal by executing a user level function  called a signal handler 
Dialogue: 0,0:15:59.10,0:16:04.18,csapp,,0,0,0,,so in this case when we when we catch signals it's very similar to the the 
Dialogue: 0,0:16:04.94,0:16:06.38,csapp,,0,0,0,,and executes a signal handle 
Dialogue: 0,0:16:06.38,0:16:13.74,csapp,,0,0,0,,it's very similar to executing a an exception handler in response to some kind of event in the system 
Dialogue: 0,0:16:14.20,0:16:17.52,csapp,,0,0,0,,now the difference is that exception handlers are in the kernel 
Dialogue: 0,0:16:18.18,0:16:21.28,csapp,,0,0,0,,signal handlers are actually just in your C code okay there
Dialogue: 0,0:16:22.74,0:16:25.31,csapp,,0,0,0,,and they execute in your in your process
Dialogue: 0,0:16:26.86,0:16:34.66,csapp,,0,0,0,,so the so the way to think about if if we catch a signal by executing a signal handler
Dialogue: 0,0:16:35.20,0:16:37.72,csapp,,0,0,0,, we have our process executing instructions
Dialogue: 0,0:16:39.00,0:16:41.72,csapp,,0,0,0,, and then the signal is received by that process 
Dialogue: 0,0:16:43.02,0:16:47.10,csapp,,0,0,0,,so the kernel passes control to a signal handler 
Dialogue: 0,0:16:47.10,0:16:55.14,csapp,,0,0,0,,which is also just in the code that's executing in the current process it's just a function  in our in our C code 
Dialogue: 0,0:16:56.18,0:17:01.52,csapp,,0,0,0,,the signal handler runs and when it returns it eventually returns back to the next instruction
Dialogue: 0,0:17:02.22,0:17:04.00,csapp,,0,0,0,, and then then we continue
Dialogue: 0,0:17:04.24,0:17:08.70,csapp,,0,0,0,,okay so it's it's it's just like kind of like an interrupt right we just temporarily pause 
Dialogue: 0,0:17:09.36,0:17:16.22,csapp,,0,0,0,,what we're doing in the in our code to execute this this handler before just continuing on
Dialogue: 0,0:17:18.98,0:17:21.16,csapp,,0,0,0,,okay now we say that a signal is pending
Dialogue: 0,0:17:21.80,0:17:25.98,csapp,,0,0,0,,if it's been sent by the colonel but not you have received 
Dialogue: 0,0:17:27.98,0:17:34.92,csapp,,0,0,0,,okay so if at any given point in time there can only be one pending signal of any particular type
Dialogue: 0,0:17:36.84,0:17:40.70,csapp,,0,0,0,, okay so this has very important consequences for using signals 
Dialogue: 0,0:17:40.70,0:17:47.32,csapp,,0,0,0,,because you can't cue signals up right at any point in time there's there can only be one pending sigchild 
Dialogue: 0,0:17:47.66,0:17:51.02,csapp,,0,0,0,,signal for example or sig sigint signal 
Dialogue: 0,0:17:51.84,0:17:55.38,csapp,,0,0,0,,and if a subsequent sigchild signals say is sent
Dialogue: 0,0:17:55.94,0:18:00.51,csapp,,0,0,0,, it just over writes well you can think of it as it has no impact
Dialogue: 0,0:18:00.78,0:18:04.04,csapp,,0,0,0,,it's just discarded right if there's already a pending signal
Dialogue: 0,0:18:04.04,0:18:06.66,csapp,,0,0,0,, so they don't they don't queue up in any meaningful way
Dialogue: 0,0:18:09.58,0:18:12.50,csapp,,0,0,0,, now our process can block the receipt of certain signals 
Dialogue: 0,0:18:13.62,0:18:16.42,csapp,,0,0,0,,okay now it can't stop signals from being delivered
Dialogue: 0,0:18:17.04,0:18:23.76,csapp,,0,0,0,,but it can stop it can stop the process from having to react to the route to that signal when it's received 
Dialogue: 0,0:18:27.84,0:18:33.02,csapp,,0,0,0,,okay so block signals can be delivered but they won't be received until the signals
Dialogue: 0,0:18:33.58,0:18:34.10,csapp,,0,0,0,,unblocked
Dialogue: 0,0:18:38.88,0:18:41.30,csapp,,0,0,0,,and pending signals are received at most once
Dialogue: 0,0:18:46.34,0:18:49.36,csapp,,0,0,0,, now the colonel keeps track of these pending and blocked 
Dialogue: 0,0:18:49.90,0:18:54.42,csapp,,0,0,0,,signals in bit vectors that will call pending and blocked
Dialogue: 0,0:18:55.24,0:18:58.62,csapp,,0,0,0,, and pending represents the set of pending signals 
Dialogue: 0,0:18:58.74,0:19:04.24,csapp,,0,0,0,,right where each bit in the pending bit vector corresponds to some particular signal 
Dialogue: 0,0:19:04.84,0:19:07.06,csapp,,0,0,0,,okay so this is why they can't be queued right because
Dialogue: 0,0:19:08.18,0:19:12.38,csapp,,0,0,0,,there's only one bit for any signal Kay there's only one bit in the bit vector
Dialogue: 0,0:19:12.84,0:19:18.00,csapp,,0,0,0,,and if we and when we deliver a signal we're just setting will set that bit the colonel will set that bit 
Dialogue: 0,0:19:18.30,0:19:24.26,csapp,,0,0,0,,we deliver another signal of the same type it'll just set that bit again which has no has no effect
Dialogue: 0,0:19:26.80,0:19:32.68,csapp,,0,0,0,,now the colonel sets that the bit in pending when the signals delivered and it clears it 
Dialogue: 0,0:19:32.80,0:19:34.18,csapp,,0,0,0,,when the signals received
Dialogue: 0,0:19:35.68,0:19:43.22,csapp,,0,0,0,,and the colonel also provides mechanism for users to block signals  blocked bit vector 
Dialogue: 0,0:19:43.22,0:19:49.34,csapp,,0,0,0,,so the block bit vector is the same size as the pending bit vector turns out it's just a 32 bit int
Dialogue: 0,0:19:51.86,0:19:54.32,csapp,,0,0,0,, okay and it can be set and cleared the bits 
Dialogue: 0,0:19:54.46,0:19:58.10,csapp,,0,0,0,,and that can be set and cleared using the sig proc mask system call 
Dialogue: 0,0:19:59.10,0:20:05.18,csapp,,0,0,0,,okay now that the blocked in the linux literature the blocked bit vector is also called the signal mask
Dialogue: 0,0:20:10.28,0:20:14.40,csapp,,0,0,0,,okay now we want to look in a little more detail about sending and receiving signals
Dialogue: 0,0:20:14.40,0:20:16.76,csapp,,0,0,0,, so let's start first with sending signals 
Dialogue: 0,0:20:18.56,0:20:21.34,csapp,,0,0,0,,first we need to understand the idea of a process group
Dialogue: 0,0:20:22.48,0:20:25.84,csapp,,0,0,0,,so every process belongs to exactly one process group 
Dialogue: 0,0:20:28.38,0:20:31.48,csapp,,0,0,0,,and those so here I'm showing a shell that's in process
Dialogue: 0,0:20:31.88,0:20:35.38,csapp,,0,0,0,, it has a process ID of 10 and a process group ID of 10 
Dialogue: 0,0:20:36.82,0:20:38.92,csapp,,0,0,0,,the shell created a foreground job
Dialogue: 0,0:20:41.12,0:20:44.80,csapp,,0,0,0,, which has a process ID of 20 and a process group ID of 20 
Dialogue: 0,0:20:45.34,0:20:47.91,csapp,,0,0,0,,and then all of the children that this foreground job
Dialogue: 0,0:20:48.22,0:20:51.88,csapp,,0,0,0,,created have the same process group ID of 20 
Dialogue: 0,0:20:53.94,0:20:59.20,csapp,,0,0,0,,so these these process groups can be set by a system call set called the set process group ID 
Dialogue: 0,0:21:01.30,0:21:06.96,csapp,,0,0,0,,and you can and you can fetch that process group using the get process group system call 
Dialogue: 0,0:21:07.62,0:21:14.04,csapp,,0,0,0,,so you can see in this example what what this shell is done is it created a foreground child
Dialogue: 0,0:21:14.04,0:21:19.12,csapp,,0,0,0,,so it created this child and it it changed the process group ID
Dialogue: 0,0:21:19.46,0:21:22.42,csapp,,0,0,0,, to be equal to the process ID of the child 
Dialogue: 0,0:21:24.06,0:21:27.04,csapp,,0,0,0,,and then when this child created other child children
Dialogue: 0,0:21:27.68,0:21:30.52,csapp,,0,0,0,, they just inherited the same process group ID 
Dialogue: 0,0:21:34.74,0:21:37.34,csapp,,0,0,0,,okay now this this notion of a process group is useful
Dialogue: 0,0:21:37.78,0:21:43.26,csapp,,0,0,0,, because it allows you to send signals to groups of processes at the same time 
Dialogue: 0,0:21:43.74,0:21:46.08,csapp,,0,0,0,,and you can do that with a program called kill
Dialogue: 0,0:21:46.64,0:21:49.46,csapp,,0,0,0,, which is typically in /bin directory
Dialogue: 0,0:21:50.56,0:21:55.60,csapp,,0,0,0,,and that the kill program you can use the kill program to send an arbitrary signal to 
Dialogue: 0,0:21:55.78,0:22:00.56,csapp,,0,0,0,,either an individual process or all the processes in one process group
Dialogue: 0,0:22:02.88,0:22:06.46,csapp,,0,0,0,, so let's look at an example this program
Dialogue: 0,0:22:07.08,0:22:10.46,csapp,,0,0,0,, this Forks program creates two children
Dialogue: 0,0:22:13.70,0:22:17.96,csapp,,0,0,0,, and with each of which has a process group of 24817 
Dialogue: 0,0:22:18.86,0:22:21.86,csapp,,0,0,0,,and of course they have different process they have different process IDs
Dialogue: 0,0:22:23.36,0:22:26.40,csapp,,0,0,0,, and so if we if we do a PS we see these two 
Dialogue: 0,0:22:27.12,0:22:29.58,csapp,,0,0,0,,we see these two processes running 
Dialogue: 0,0:22:30.90,0:22:34.50,csapp,,0,0,0,,and these just go into loop so they'll just they'll just run continuously 
Dialogue: 0,0:22:36.10,0:22:37.50,csapp,,0,0,0,,okay now we can 
Dialogue: 0,0:22:40.30,0:22:43.48,csapp,,0,0,0,,we can use kill to to kill an individual process
Dialogue: 0,0:22:44.00,0:22:47.56,csapp,,0,0,0,, for example so if we call it the first argument 
Dialogue: 0,0:22:49.16,0:22:51.08,csapp,,0,0,0,,indicates what signal you want to send 
Dialogue: 0,0:22:51.08,0:22:55.30,csapp,,0,0,0,,so in this case it's its signal 9 which is the sigkill signal 
Dialogue: 0,0:22:55.88,0:22:59.82,csapp,,0,0,0,,so kill -9 is is a very typical
Dialogue: 0,0:23:00.10,0:23:02.98,csapp,,0,0,0,,usually if you want to kill processes you just kill -9 
Dialogue: 0,0:23:03.94,0:23:13.10,csapp,,0,0,0,,and actually one of my favorite Auto lab nuke names for 213 was the nickname was kill - 9 15-213 
Dialogue: 0,0:23:16.10,0:23:23.20,csapp,,0,0,0,,so but then then the second argument is the if it's is the the process ID 
Dialogue: 0,0:23:23.22,0:23:29.54,csapp,,0,0,0,,so this is asking this is asking the kernel to kill process ID 24818
Dialogue: 0,0:23:30.12,0:23:32.44,csapp,,0,0,0,,by sending it a cig kill signal 
Dialogue: 0,0:23:33.64,0:23:38.58,csapp,,0,0,0,,now if the if the process ID is is preceded by a dash
Dialogue: 0,0:23:40.86,0:23:45.12,csapp,,0,0,0,, then it sends a signal to every process in process group - 
Dialogue: 0,0:23:45.64,0:23:48.30,csapp,,0,0,0,,then it treats this argument as a process group
Dialogue: 0,0:23:48.78,0:23:52.46,csapp,,0,0,0,, and it sends a signal to every process in that process group 
Dialogue: 0,0:23:52.96,0:23:58.82,csapp,,0,0,0,,so in this case it will send a signal to both of these both of these children processes
Dialogue: 0,0:24:00.48,0:24:05.40,csapp,,0,0,0,,and then afterwards we if we do a PS we see that those processes are gone 
Dialogue: 0,0:24:05.62,0:24:07.90,csapp,,0,0,0,,okay that it really did work that way 
Dialogue: 0,0:24:09.78,0:24:15.24,csapp,,0,0,0,,now another way to send signals is by typing either control C or control Z 
Dialogue: 0,0:24:15.62,0:24:18.26,csapp,,0,0,0,,at the to the command line 
Dialogue: 0,0:24:19.44,0:24:25.50,csapp,,0,0,0,,control C causes the kernel to send a signal to every job in the the foreground process group 
Dialogue: 0,0:24:25.84,0:24:35.58,csapp,,0,0,0,,and control Z causes it to send a signal to every job in the in the foreground process group
Dialogue: 0,0:24:36.38,0:24:39.28,csapp,,0,0,0,, the default action for SIGINT is to terminate the process 
Dialogue: 0,0:24:39.28,0:24:43.88,csapp,,0,0,0,,the default action for the sig tea stop is to suspend the process stop it 
Dialogue: 0,0:24:44.34,0:24:48.24,csapp,,0,0,0,,until it receives a sig cont a signal
Dialogue: 0,0:24:54.90,0:24:58.58,csapp,,0,0,0,,so you can see an example of this here we have a program that 
Dialogue: 0,0:25:00.90,0:25:07.27,csapp,,0,0,0,,creates a parent and a child running in the foreground so the parents running in the foreground
Dialogue: 0,0:25:08.10,0:25:11.04,csapp,,0,0,0,,now when we type control Z to the command line
Dialogue: 0,0:25:12.70,0:25:16.36,csapp,,0,0,0,, the shell notifies us that it's suspended that process 
Dialogue: 0,0:25:16.80,0:25:23.90,csapp,,0,0,0,,and if we do a PS we can see the parent and the child indeed are suspended 
Dialogue: 0,0:25:23.94,0:25:28.72,csapp,,0,0,0,,so the PS indicates that it's suspended or stopped using T
Dialogue: 0,0:25:33.04,0:25:37.04,csapp,,0,0,0,,now next we type in the built in the shell built in which is fg
Dialogue: 0,0:25:37.16,0:25:42.36,csapp,,0,0,0,,and fg restores those those suspended jobs to the foreground 
Dialogue: 0,0:25:44.70,0:25:50.06,csapp,,0,0,0,,so after typing fg now we're running this our program again in the foreground 
Dialogue: 0,0:25:51.58,0:25:54.28,csapp,,0,0,0,,and then we can kill it by typing ctrl-C 
Dialogue: 0,0:25:54.78,0:25:58.84,csapp,,0,0,0,,which which elicits a SIGINT whose default action is to terminate
Dialogue: 0,0:25:59.18,0:26:03.30,csapp,,0,0,0,, and then when we do a PS we see that indeed  that's that they're gone
Dialogue: 0,0:26:06.96,0:26:11.40,csapp,,0,0,0,,now the third way that we can send signals is by using the kill system call
Dialogue: 0,0:26:15.44,0:26:17.60,csapp,,0,0,0,,so here's an example of how that works
Dialogue: 0,0:26:18.04,0:26:21.82,csapp,,0,0,0,,so in this in this example we're creating end children 
Dialogue: 0,0:26:23.00,0:26:25.14,csapp,,0,0,0,,now each of which goes into an infinite loop 
Dialogue: 0,0:26:25.84,0:26:29.90,csapp,,0,0,0,,and we're recording this the process ID of each child that we create 
Dialogue: 0,0:26:31.92,0:26:34.90,csapp,,0,0,0,,and then in it we go in another loop we go through 
Dialogue: 0,0:26:34.90,0:26:40.02,csapp,,0,0,0,,and we we kill each of those child processes with by using the kill function 
Dialogue: 0,0:26:40.74,0:26:45.56,csapp,,0,0,0,,passing it the process ID and the signal that we want sent to that process 
Dialogue: 0,0:26:47.72,0:26:52.24,csapp,,0,0,0,,okay and then we do our due diligence and reap each one of those 
Dialogue: 0,0:26:52.64,0:26:54.64,csapp,,0,0,0,,children that we've terminated
Dialogue: 0,0:26:55.56,0:27:02.28,csapp,,0,0,0,,now this isn't strictly necessary because we're going to exit as soon as this 412 function 
Dialogue: 0,0:27:02.80,0:27:06.58,csapp,,0,0,0,,returns we're going to exit the code so but we're just being
Dialogue: 0,0:27:07.38,0:27:11.90,csapp,,0,0,0,,you know careful here and maybe a little pedantic but
Dialogue: 0,0:27:16.02,0:27:20.26,csapp,,0,0,0,,okay now now let's look at how we process receive signals
Dialogue: 0,0:27:22.58,0:27:29.72,csapp,,0,0,0,,now suppose process a is running along executing its user code and then 
Dialogue: 0,0:27:30.48,0:27:34.94,csapp,,0,0,0,,there's a control passes into the kernel because of some exception
Dialogue: 0,0:27:36.12,0:27:40.36,csapp,,0,0,0,,now that exception can be either a timer going off 
Dialogue: 0,0:27:40.90,0:27:45.12,csapp,,0,0,0,,they've been interrupts or it can be a trap user calls a system call
Dialogue: 0,0:27:45.76,0:27:50.50,csapp,,0,0,0,,okay but it's always caused that the trap into the 
Dialogue: 0,0:27:51.20,0:27:54.26,csapp,,0,0,0,,or the transferring control into the kernel is always caused by some exception 
Dialogue: 0,0:27:56.18,0:27:59.48,csapp,,0,0,0,,so at this point the kernel calls its scheduler function 
Dialogue: 0,0:28:00.12,0:28:07.34,csapp,,0,0,0,,and it decides to to do a context switch from process a to process B 
Dialogue: 0,0:28:09.46,0:28:15.50,csapp,,0,0,0,,and it gets processed be all set up and right before it returns from that exception 
Dialogue: 0,0:28:16.26,0:28:24.24,csapp,,0,0,0,,and right before it's ready to pass control back to back to process  the user code and process B 
Dialogue: 0,0:28:25.30,0:28:29.34,csapp,,0,0,0,,it checks for any signals that any pending signals 
Dialogue: 0,0:28:32.58,0:28:38.50,csapp,,0,0,0,,okay and it does this by computing a bit vector PNB so pending non blocked 
Dialogue: 0,0:28:39.42,0:28:42.58,csapp,,0,0,0,,which is the logical and of the pending bit vector 
Dialogue: 0,0:28:44.00,0:28:46.48,csapp,,0,0,0,,and the inverse of the blocked bit vector 
Dialogue: 0,0:28:47.74,0:28:52.10,csapp,,0,0,0,,okay so PNB is a list of all the pending signals that aren't blocked 
Dialogue: 0,0:28:53.34,0:28:56.08,csapp,,0,0,0,,okay so these are all the pending signals that should be received 
Dialogue: 0,0:28:59.12,0:29:02.84,csapp,,0,0,0,,if now if pnb is all zeros then there's no pending signals 
Dialogue: 0,0:29:03.04,0:29:05.86,csapp,,0,0,0,,so it just returns it passes control back
Dialogue: 0,0:29:07.18,0:29:10.98,csapp,,0,0,0,,it passes control back to process b which can continue executing 
Dialogue: 0,0:29:11.64,0:29:14.18,csapp,,0,0,0,,however if if PNB is nonzero then
Dialogue: 0,0:29:15.10,0:29:19.70,csapp,,0,0,0,, it chooses the smallest nonzero bit in PNB 
Dialogue: 0,0:29:19.70,0:29:24.56,csapp,,0,0,0,,and it forces process P to receive that signal the corresponding signal
Dialogue: 0,0:29:27.74,0:29:32.20,csapp,,0,0,0,,the receipt of the signal triggers some action in in the process 
Dialogue: 0,0:29:36.24,0:29:44.34,csapp,,0,0,0,,and then we repeat that for all the nonzero signals K that  are nonzero bits that are set in PNB 
Dialogue: 0,0:29:44.78,0:29:47.60,csapp,,0,0,0,,and finally when we've gone all through all the non zero bits 
Dialogue: 0,0:29:48.14,0:29:56.70,csapp,,0,0,0,,then we pass control to the next instruction in in the in in process P 
Dialogue: 0,0:30:00.72,0:30:03.96,csapp,,0,0,0,,so the receipt of a signal always triggers some action
Dialogue: 0,0:30:04.46,0:30:06.93,csapp,,0,0,0,,which is either the process terminates
Dialogue: 0,0:30:07.86,0:30:11.40,csapp,,0,0,0,,the process stops until it's restarted by a sick can't signal
Dialogue: 0,0:30:12.42,0:30:14.52,csapp,,0,0,0,, the process ignores the signal
Dialogue: 0,0:30:15.36,0:30:18.42,csapp,,0,0,0,, ok so that's there's always some predefined default action
Dialogue: 0,0:30:21.72,0:30:29.72,csapp,,0,0,0,,but we can modify that that default action by using a function system call called signal 
Dialogue: 0,0:30:31.66,0:30:37.28,csapp,,0,0,0,,ok so we can now signals a little that's another sort of misleading kind of term just like kill right because when we
Dialogue: 0,0:30:37.74,0:30:40.50,csapp,,0,0,0,, when we send a signal to a process we don't always want to kill it 
Dialogue: 0,0:30:41.74,0:30:44.02,csapp,,0,0,0,,and signal doesn't actually signal anything
Dialogue: 0,0:30:44.40,0:30:49.22,csapp,,0,0,0,, it just it just modifies the default action associated with some something
Dialogue: 0,0:30:50.74,0:30:55.02,csapp,,0,0,0,, okay so if the signal function takes out a signal number 
Dialogue: 0,0:30:56.90,0:31:01.98,csapp,,0,0,0,,and and then specifies a change in the default action for that signal 
Dialogue: 0,0:31:04.16,0:31:07.46,csapp,,0,0,0,,and those default actions can be either to ignore the signal
Dialogue: 0,0:31:08.30,0:31:10.42,csapp,,0,0,0,, ok ignore signals of type signal
Dialogue: 0,0:31:12.60,0:31:14.96,csapp,,0,0,0,,revert to the default behavior for that signal
Dialogue: 0,0:31:17.48,0:31:21.96,csapp,,0,0,0,, or we can we can give it or it can be the address of a user level signal handler 
Dialogue: 0,0:31:22.64,0:31:26.38,csapp,,0,0,0,,which is a function that we've declared in our C program 
Dialogue: 0,0:31:26.76,0:31:32.92,csapp,,0,0,0,,ok it's there's nothing special about the function it has a certain prototype that has it takes a single argument 
Dialogue: 0,0:31:33.60,0:31:40.06,csapp,,0,0,0,,which is the signal number so when that function gets called in in response to receiving a signal 
Dialogue: 0,0:31:41.24,0:31:44.02,csapp,,0,0,0,,that argument will be set to the signal number 
Dialogue: 0,0:31:47.80,0:31:54.54,csapp,,0,0,0,,so calling signal with a and specifying a signal handler is called installing a handler 
Dialogue: 0,0:31:55.42,0:31:59.68,csapp,,0,0,0,,and then executing the handlers referred to as catching or executing 
Dialogue: 0,0:31:59.68,0:32:01.52,csapp,,0,0,0,,they were handling the signal 
Dialogue: 0,0:32:03.78,0:32:06.64,csapp,,0,0,0,,and and this this handler then is just like an exception handler
Dialogue: 0,0:32:06.66,0:32:12.56,csapp,,0,0,0,,when it when it returns it will be when it's executed it will interrupt the
Dialogue: 0,0:32:13.16,0:32:16.66,csapp,,0,0,0,,whatever is currently executing in the process when it returns
Dialogue: 0,0:32:16.92,0:32:19.94,csapp,,0,0,0,, it will return back to that point and continue executing
Dialogue: 0,0:32:22.74,0:32:26.74,csapp,,0,0,0,, okay so here's a simple example of of installing a handler 
Dialogue: 0,0:32:28.62,0:32:32.48,csapp,,0,0,0,,so here in main where we're going to install a sigint handler 
Dialogue: 0,0:32:34.92,0:32:38.80,csapp,,0,0,0,,which is called sigint underscore handler which is defined up here 
Dialogue: 0,0:32:39.80,0:32:43.12,csapp,,0,0,0,,and the prototype for this function is returns nothing 
Dialogue: 0,0:32:43.80,0:32:48.12,csapp,,0,0,0,,and it takes a single integer argument which is the signal number and returns nothing
Dialogue: 0,0:32:50.76,0:32:52.42,csapp,,0,0,0,,okay and after we install that handler
Dialogue: 0,0:32:53.12,0:32:59.24,csapp,,0,0,0,,then we're going to execute the pause this call which just waits for a signal handler to execute
Dialogue: 0,0:32:59.48,0:33:03.20,csapp,,0,0,0,, ok so pause terminates the current or suspends the current process 
Dialogue: 0,0:33:04.28,0:33:08.38,csapp,,0,0,0,,until a signal is received and a handler executes in that process
Dialogue: 0,0:33:08.92,0:33:10.68,csapp,,0,0,0,, and then pause then pause returns
Dialogue: 0,0:33:13.36,0:33:16.36,csapp,,0,0,0,, so we're going to wait until the SIGINT happens
Dialogue: 0,0:33:16.40,0:33:19.54,csapp,,0,0,0,, so sigint entry call is when we type ctrl-c
Dialogue: 0,0:33:21.98,0:33:27.04,csapp,,0,0,0,,so when you're doing your bombs did did you panic at some point and try to hit ctrl-c to get out of it
Dialogue: 0,0:33:28.50,0:33:30.86,csapp,,0,0,0,,okay so that snarky message you got that was
Dialogue: 0,0:33:32.04,0:33:37.20,csapp,,0,0,0,, we did that by installing a signal hello SIGINT handler in in in your bomb
Dialogue: 0,0:33:38.78,0:33:43.14,csapp,,0,0,0,,okay so when when you type ctrl-c that elicits a a SIGINT 
Dialogue: 0,0:33:43.60,0:33:51.60,csapp,,0,0,0,,when that SIGINT is received we printed this message and then eventually  let you exit
Dialogue: 0,0:33:56.90,0:34:01.38,csapp,,0,0,0,,now signaler signals are another examples of concurrency 
Dialogue: 0,0:34:02.16,0:34:06.92,csapp,,0,0,0,,now we've seen concurrency earlier in the form of processes
Dialogue: 0,0:34:07.84,0:34:12.90,csapp,,0,0,0,, right concurrent flows overlapping in time 
Dialogue: 0,0:34:14.14,0:34:19.32,csapp,,0,0,0,,okay logical flows overlapping in time  by definition are concurrent
Dialogue: 0,0:34:20.58,0:34:26.62,csapp,,0,0,0,, now with with processes the because they have separate address spaces
Dialogue: 0,0:34:26.84,0:34:29.46,csapp,,0,0,0,, those concurrent flows never interfere with each other
Dialogue: 0,0:34:29.58,0:34:33.62,csapp,,0,0,0,, right so in some sense processes are very easy to deal with 
Dialogue: 0,0:34:34.10,0:34:40.18,csapp,,0,0,0,,and we don't really have to worry one process doesn't have to worry about being interfered with by another process
Dialogue: 0,0:34:42.02,0:34:47.46,csapp,,0,0,0,,in fact you have to go to great lengths to share like to share things between processes
Dialogue: 0,0:34:47.46,0:34:53.78,csapp,,0,0,0,, you have to use specific system calls in order to say share memory between two processes
Dialogue: 0,0:34:55.22,0:34:59.90,csapp,,0,0,0,, now signals are another form of concurrency this is the second time in this class that that
Dialogue: 0,0:35:01.42,0:35:03.08,csapp,,0,0,0,,you've experienced concurrency 
Dialogue: 0,0:35:03.98,0:35:08.22,csapp,,0,0,0,,and so a signal is just a concurrent flow it's just a logical flow a sit 
Dialogue: 0,0:35:08.86,0:35:13.82,csapp,,0,0,0,,so a handler is just another logical flow that runs concurrently with your program 
Dialogue: 0,0:35:14.92,0:35:19.28,csapp,,0,0,0,,right so we're let's say we're executing a while loop in process a 
Dialogue: 0,0:35:20.76,0:35:22.90,csapp,,0,0,0,,okay that while loop is is executing 
Dialogue: 0,0:35:23.46,0:35:25.56,csapp,,0,0,0,,and in process a receives the signal 
Dialogue: 0,0:35:26.54,0:35:29.22,csapp,,0,0,0,,which causes a transfer of control to this handler 
Dialogue: 0,0:35:31.84,0:35:35.30,csapp,,0,0,0,,this handler executes so this is a concurrent flow
Dialogue: 0,0:35:36.12,0:35:42.24,csapp,,0,0,0,, that overlaps in time with the while loop in process a eventually this handler returns 
Dialogue: 0,0:35:43.24,0:35:48.42,csapp,,0,0,0,,and we return for the back tip to back to process a 
Dialogue: 0,0:35:50.34,0:35:58.26,csapp,,0,0,0,,now one of the reasons signals are so tricky is because of this this overlapping concurrent flow 
Dialogue: 0,0:35:59.86,0:36:06.06,csapp,,0,0,0,,this this concurrency because the signal handler runs in the same process  as the main program 
Dialogue: 0,0:36:06.68,0:36:10.12,csapp,,0,0,0,,so it shares all the global variables of that program 
Dialogue: 0,0:36:11.76,0:36:15.26,csapp,,0,0,0,,okay so you're that signal handler is a function 
Dialogue: 0,0:36:15.26,0:36:21.54,csapp,,0,0,0,,that you've declared and it has access to all all the state all the global state in the program 
Dialogue: 0,0:36:23.40,0:36:27.86,csapp,,0,0,0,,okay and the existence of the shared global state can create real problems
Dialogue: 0,0:36:37.50,0:36:40.48,csapp,,0,0,0,,and we'll get into more details about some of those problems 
Dialogue: 0,0:36:42.08,0:36:46.76,csapp,,0,0,0,,so another way to look at these signal handlers disking as concurrent flows 
Dialogue: 0,0:36:47.32,0:36:49.90,csapp,,0,0,0,,is using this this context switch diagram 
Dialogue: 0,0:36:50.62,0:36:53.32,csapp,,0,0,0,,so suppose we're executing in process a 
Dialogue: 0,0:36:54.50,0:37:00.85,csapp,,0,0,0,,and now at some point a signal is delivered to process a
Dialogue: 0,0:37:01.70,0:37:06.78,csapp,,0,0,0,,now nothing happens right just just the pending bit gets set in process a at this point
Dialogue: 0,0:37:08.64,0:37:12.52,csapp,,0,0,0,, now at some point there's a transfer of control into the kernel 
Dialogue: 0,0:37:13.44,0:37:17.20,csapp,,0,0,0,,and the kernel decides to do a context switch from A to B 
Dialogue: 0,0:37:18.08,0:37:22.34,csapp,,0,0,0,,and now B gets to run for a while there's another transfer of control to the kernel 
Dialogue: 0,0:37:24.30,0:37:27.02,csapp,,0,0,0,,and the kernel decides to schedule process a 
Dialogue: 0,0:37:28.62,0:37:32.90,csapp,,0,0,0,,and now right before it returns control to process a 
Dialogue: 0,0:37:33.26,0:37:37.36,csapp,,0,0,0,,it notices that the the pending bit for this signal is set 
Dialogue: 0,0:37:37.76,0:37:40.38,csapp,,0,0,0,,so it causes process a to receive that signal
Dialogue: 0,0:37:41.00,0:37:42.88,csapp,,0,0,0,,so that executes the handler code 
Dialogue: 0,0:37:43.68,0:37:48.12,csapp,,0,0,0,,when the handler returns it returns for brief briefly to the kernel 
Dialogue: 0,0:37:48.18,0:37:53.76,csapp,,0,0,0,,which then transfers control back to the the next instruction that  the process was going to execute 
Dialogue: 0,0:37:56.48,0:38:00.56,csapp,,0,0,0,,now handlers are also tricky because they can be interrupted by other handlers
Dialogue: 0,0:38:01.34,0:38:06.56,csapp,,0,0,0,, so suppose we have our main program  that catches a signal S 
Dialogue: 0,0:38:08.00,0:38:10.70,csapp,,0,0,0,,which causes a transfer of control to handle or s 
Dialogue: 0,0:38:11.44,0:38:13.76,csapp,,0,0,0,,and then we'll handle RS did you have a question okay
Dialogue: 0,0:38:15.24,0:38:19.00,csapp,,0,0,0,, well handle RS is is is executing
Dialogue: 0,0:38:22.96,0:38:28.28,csapp,,0,0,0,,the the program catches a signal T 
Dialogue: 0,0:38:30.62,0:38:35.78,csapp,,0,0,0,,which causes a transfer of control to the handler first for T 
Dialogue: 0,0:38:36.38,0:38:39.30,csapp,,0,0,0,,and when then when at handler returns it returns to the point to the 
Dialogue: 0,0:38:40.36,0:38:45.80,csapp,,0,0,0,,to the to the instruction and handle or else that was where it was interrupted
Dialogue: 0,0:38:46.36,0:38:50.50,csapp,,0,0,0,, and then handle or us continues its execution and eventually 
Dialogue: 0,0:38:50.50,0:38:54.34,csapp,,0,0,0,,return back to the the point in the main program where it was interrupted 
Dialogue: 0,0:38:58.70,0:39:02.61,csapp,,0,0,0,,now signals that the colonel always blocks
Dialogue: 0,0:39:03.32,0:39:06.44,csapp,,0,0,0,,pending signals of the type currently being handled right so
Dialogue: 0,0:39:07.56,0:39:12.46,csapp,,0,0,0,, a handler for a signal of type T can't be interrupted 
Dialogue: 0,0:39:13.20,0:39:16.16,csapp,,0,0,0,,by the receipt of another signal of that same type 
Dialogue: 0,0:39:16.96,0:39:20.98,csapp,,0,0,0,,okay can be as I showed in the previous slide it can be interrupted by a signal of another type
Dialogue: 0,0:39:21.46,0:39:23.42,csapp,,0,0,0,, but not by a signal of the same type 
Dialogue: 0,0:39:23.88,0:39:28.12,csapp,,0,0,0,,so that's sort of an implicit form of of blocking 
Dialogue: 0,0:39:29.22,0:39:36.70,csapp,,0,0,0,,but there's the kernel also provides a system call that allows you to explicitly block  and unblock signals 
Dialogue: 0,0:39:37.30,0:39:40.01,csapp,,0,0,0,,in the form of the sig proc mask function
Dialogue: 0,0:39:41.96,0:39:48.66,csapp,,0,0,0,,and then there's associated so this allows you to block and unblock a set of signals
Dialogue: 0,0:39:49.42,0:39:54.04,csapp,,0,0,0,, and then there some support functions that allow you to create those sets
Dialogue: 0,0:39:55.40,0:39:58.34,csapp,,0,0,0,, so just think of these as bit vectors
Dialogue: 0,0:39:58.38,0:40:05.34,csapp,,0,0,0,, and these functions will set in set and reset the bits and those those bit vectors 
Dialogue: 0,0:40:07.16,0:40:12.72,csapp,,0,0,0,,so let's see how we can use sig proc masks to temporarily block and unblock a signal 
Dialogue: 0,0:40:13.32,0:40:16.00,csapp,,0,0,0,,so this is going to this is going to turn out to be very important for you 
Dialogue: 0,0:40:16.00,0:40:21.24,csapp,,0,0,0,,when you working on your shells that which is your next your next lab assignment okay
Dialogue: 0,0:40:25.98,0:40:31.34,csapp,,0,0,0,,so what we do we'll use Sigemptyset to create an empty mask so this is a mask with all zeros 
Dialogue: 0,0:40:31.96,0:40:33.80,csapp,,0,0,0,,okay with with no elements in the set 
Dialogue: 0,0:40:34.80,0:40:39.46,csapp,,0,0,0,, and then we're going to add a single element to this set which is sigint 
Dialogue: 0,0:40:42.46,0:40:47.88,csapp,,0,0,0,,and now we temp we have some code that we don't want to be interrupted by the seed of sigint 
Dialogue: 0,0:40:49.36,0:40:53.08,csapp,,0,0,0,,okay so we want to temporarily block the receipt of sig n signals 
Dialogue: 0,0:40:54.08,0:40:58.70,csapp,,0,0,0,,and we do it by calling sig proc mask with the command
Dialogue: 0,0:40:59.20,0:41:02.56,csapp,,0,0,0,,say I want to block I want to block the signals
Dialogue: 0,0:41:03.84,0:41:08.78,csapp,,0,0,0,, that are spent that that are in the set specified by mask 
Dialogue: 0,0:41:12.36,0:41:16.22,csapp,,0,0,0,,and I'll assign the so this will become my new mask
Dialogue: 0,0:41:16.64,0:41:19.72,csapp,,0,0,0,, so this this becomes the new blocked bit vector 
Dialogue: 0,0:41:20.68,0:41:24.52,csapp,,0,0,0,,okay or the not the this  the new signal mask 
Dialogue: 0,0:41:24.62,0:41:31.28,csapp,,0,0,0,,and it makes a copy of the old one and stores it at at the address specified in the third argument
Dialogue: 0,0:41:32.82,0:41:35.50,csapp,,0,0,0,, so at this point after we returned from sigprocmask 
Dialogue: 0,0:41:36.04,0:41:38.50,csapp,,0,0,0,,sig n signals are blocked and they won't be received
Dialogue: 0,0:41:40.94,0:41:47.02,csapp,,0,0,0,, and then we so we can execute this code knowing that we won't be interrupted by receipt of a sigint 
Dialogue: 0,0:41:49.56,0:41:57.20,csapp,,0,0,0,,and then we can restore the previous block set by using the cig set mask  in stopper ation
Dialogue: 0,0:41:57.78,0:42:03.44,csapp,,0,0,0,, and passing in the previous mask that we that we saved up here when we when we initially blocks again
Dialogue: 0,0:42:09.96,0:42:15.12,csapp,,0,0,0,,okay so signals and signal handling is a really tricky business 
Dialogue: 0,0:42:15.54,0:42:17.48,csapp,,0,0,0,,and there's sort of three things that make them 
Dialogue: 0,0:42:18.82,0:42:21.44,csapp,,0,0,0,,so tricky and kind of nasty really 
Dialogue: 0,0:42:21.88,0:42:26.80,csapp,,0,0,0,,one is that you have to be very careful to write handlers that are safe
Dialogue: 0,0:42:27.54,0:42:33.96,csapp,,0,0,0,,okay so there's you can write signal handlers that are unsafe in the sense that they'll create a deadlock in your program
Dialogue: 0,0:42:36.68,0:42:41.68,csapp,,0,0,0,, okay or you can or you can write signal handlers that will that will corrupt a global data structure 
Dialogue: 0,0:42:42.58,0:42:46.24,csapp,,0,0,0,,that's being modified by the main program
Dialogue: 0,0:42:46.24,0:42:54.06,csapp,,0,0,0,, so I mean imagine imagine your main programming is updating some some data structure like a linked list 
Dialogue: 0,0:42:54.84,0:42:59.72,csapp,,0,0,0,,and right in the middle of updating that data structure when it's when it's no longer consistent
Dialogue: 0,0:43:01.44,0:43:04.02,csapp,,0,0,0,, the program gets interrupted by the receipt of a signal 
Dialogue: 0,0:43:05.22,0:43:11.54,csapp,,0,0,0,,and if that signal handler is updating that same data structure reading that structure or modifying it 
Dialogue: 0,0:43:12.62,0:43:17.18,csapp,,0,0,0,,then it's going to encounter it in an inconsistent state  and and and you're in trouble
Dialogue: 0,0:43:19.92,0:43:27.28,csapp,,0,0,0,, okay so this the fact that it's the fact that it's it's it's it's easy to write signal handlers
Dialogue: 0,0:43:27.30,0:43:32.04,csapp,,0,0,0,, that are that are unsafe is is is one aspect of that makes them tough to deal with 
Dialogue: 0,0:43:32.66,0:43:37.16,csapp,,0,0,0,,another aspect is they have this funny semantics that signals aren't cued
Dialogue: 0,0:43:38.04,0:43:40.60,csapp,,0,0,0,, and so if you're not if you're not really careful about this 
Dialogue: 0,0:43:41.12,0:43:45.68,csapp,,0,0,0,,it's very easy to use the receipt of signals to count events
Dialogue: 0,0:43:46.76,0:43:49.94,csapp,,0,0,0,, and you can't do that if signals were cued you could use 
Dialogue: 0,0:43:50.12,0:43:54.34,csapp,,0,0,0,,you could use the receipt of a signal to count events in the system but you can't do it because
Dialogue: 0,0:43:54.80,0:43:56.08,csapp,,0,0,0,, their signals aren't cued
Dialogue: 0,0:43:57.28,0:44:00.82,csapp,,0,0,0,,and then a third a third aspect of signals which makes them tough is that
Dialogue: 0,0:44:01.66,0:44:05.18,csapp,,0,0,0,,they're not even they're not even portable across different versions of Linux
Dialogue: 0,0:44:07.52,0:44:12.94,csapp,,0,0,0,, okay so if you use solaris or some form of bsd it's not necessarily
Dialogue: 0,0:44:13.24,0:44:16.70,csapp,,0,0,0,, the single handling semantics aren't necessarily the same as they are in Linux
Dialogue: 0,0:44:17.82,0:44:21.36,csapp,,0,0,0,,okay so we'll we'll look at all three of these in a little more detail 
Dialogue: 0,0:44:21.36,0:44:24.34,csapp,,0,0,0,,and first we'll start with writing safe handlers
Dialogue: 0,0:44:26.94,0:44:32.40,csapp,,0,0,0,,so let me give you some guidelines for how to write safe handlers
Dialogue: 0,0:44:33.24,0:44:38.16,csapp,,0,0,0,, and this is just a collection of fun this is just a
Dialogue: 0,0:44:39.16,0:44:43.78,csapp,,0,0,0,,collection of sort of collected wisdom from from various sources 
Dialogue: 0,0:44:44.16,0:44:48.58,csapp,,0,0,0,,but it covers a lot of aspects of signal handlers 
Dialogue: 0,0:44:49.34,0:44:53.66,csapp,,0,0,0,,so the first guideline is to keep your handlers as simple as possible for example
Dialogue: 0,0:44:54.04,0:44:58.94,csapp,,0,0,0,, the simplest possible handle I can think of just sets a global variable and then it returns 
Dialogue: 0,0:45:00.52,0:45:10.62,csapp,,0,0,0,,okay and in fact cert the CMU cert provides guidelines for sort of compliant programs 
Dialogue: 0,0:45:11.38,0:45:17.88,csapp,,0,0,0,,and this is the only signal handler that they allow this is the only compliant signal handler
Dialogue: 0,0:45:18.10,0:45:20.64,csapp,,0,0,0,, one that just sets a global variable and then returns 
Dialogue: 0,0:45:26.26,0:45:33.24,csapp,,0,0,0,,okay guideline number one call only functions in your handlers that are that have this property of async signals safety okay
Dialogue: 0,0:45:34.46,0:45:41.16,csapp,,0,0,0,,okay and we'll look at this in a second but I want to point out that printf s printf Malak exit 
Dialogue: 0,0:45:42.18,0:45:45.64,csapp,,0,0,0,,functions that are very common and commonly used are not safe
Dialogue: 0,0:45:48.88,0:45:54.80,csapp,,0,0,0,,okay guideline number two is to always save and restore error no on entry and exit
Dialogue: 0,0:45:55.14,0:45:56.62,csapp,,0,0,0,,so you know error no is a global 
Dialogue: 0,0:45:57.40,0:46:01.44,csapp,,0,0,0,,global variable that's set when there's whenever there's an error in a system-level function 
Dialogue: 0,0:46:02.56,0:46:06.42,csapp,,0,0,0,,so you need to save and you need to save and restore it on entry and exit 
Dialogue: 0,0:46:06.70,0:46:10.86,csapp,,0,0,0,,so that it doesn't get overwritten if you're interrupted by another handler
Dialogue: 0,0:46:15.92,0:46:18.32,csapp,,0,0,0,,okay if you're accessing any shared data structures
Dialogue: 0,0:46:19.00,0:46:25.24,csapp,,0,0,0,, inside a signal handler that are also accessed by your main routine
Dialogue: 0,0:46:25.34,0:46:29.16,csapp,,0,0,0,,then you need to temporarily block signals while you access that data structure
Dialogue: 0,0:46:29.80,0:46:31.98,csapp,,0,0,0,, both in the main routine and your signal handler 
Dialogue: 0,0:46:32.86,0:46:35.43,csapp,,0,0,0,,right and the reason for this is what I described earlier 
Dialogue: 0,0:46:36.04,0:46:39.88,csapp,,0,0,0,,if your main routine is updating that global data structure and then it gets interrupted
Dialogue: 0,0:46:40.40,0:46:44.46,csapp,,0,0,0,, and the signal handler is reading that data structure it's going to find it in an inconsistent state 
Dialogue: 0,0:46:44.88,0:46:46.40,csapp,,0,0,0,,and bad things will happen 
Dialogue: 0,0:46:50.88,0:46:55.76,csapp,,0,0,0,,okay you want to be sure to declare your any global variables that are shared between signal handlers
Dialogue: 0,0:46:55.96,0:46:57.94,csapp,,0,0,0,, and the main routine as volatile
Dialogue: 0,0:46:58.56,0:47:04.38,csapp,,0,0,0,, okay the volatile attribute will prevent the compiler from putting that that value in a register
Dialogue: 0,0:47:07.62,0:47:09.96,csapp,,0,0,0,, so if you declare a global variable as volatile
Dialogue: 0,0:47:10.58,0:47:14.58,csapp,,0,0,0,, it will always be reads and writes will always go to and from memory 
Dialogue: 0,0:47:15.94,0:47:22.76,csapp,,0,0,0,,okay so this is very important right you might if you don't declare these global variables at volatile 
Dialogue: 0,0:47:22.86,0:47:28.22,csapp,,0,0,0,,and the compiler chooses to put to put one of those in a in a register 
Dialogue: 0,0:47:29.64,0:47:33.04,csapp,,0,0,0,,then you may miss that variable being updated 
Dialogue: 0,0:47:33.06,0:47:37.68,csapp,,0,0,0,,so suppose suppose your signal handlers is setting a global variable 
Dialogue: 0,0:47:39.26,0:47:44.74,csapp,,0,0,0,,and now suppose your main routine is spinning waiting for that global variable to get set 
Dialogue: 0,0:47:46.56,0:47:51.82,csapp,,0,0,0,,well if it's in a register the write to that variable will just update the register
Dialogue: 0,0:47:51.92,0:47:58.70,csapp,,0,0,0,,right and so your main routine is in danger of just of spinning forever not not seeing the change right 
Dialogue: 0,0:48:00.54,0:48:04.62,csapp,,0,0,0,,okay so always use volatility so that they're not stored in registers 
Dialogue: 0,0:48:06.22,0:48:10.60,csapp,,0,0,0,,and then if you have fun if you have a special kind of global called a flag 
Dialogue: 0,0:48:11.18,0:48:19.22,csapp,,0,0,0,,which by definition is a variable it's only read or written not incremented or updated  it's just read or written 
Dialogue: 0,0:48:20.64,0:48:27.18,csapp,,0,0,0,,if you have if you have a variable with that property then you can declare it with this SIG atomic tea tribute
Dialogue: 0,0:48:28.72,0:48:34.46,csapp,,0,0,0,, and if you do that then the system guarantees that reads and writes to that variable will be atomic 
Dialogue: 0,0:48:34.68,0:48:39.22,csapp,,0,0,0,,so you don't have to in other words you don't have to protect accesses to the shared
Dialogue: 0,0:48:39.82,0:48:43.58,csapp,,0,0,0,,two accesses or references to those global variables 
Dialogue: 0,0:48:44.52,0:48:53.56,csapp,,0,0,0,,okay and so by this by atomic which means that the the read or write of that flag will always happen in one uninterruptible step 
Dialogue: 0,0:48:54.86,0:48:58.12,csapp,,0,0,0,,okay one uninterruptible load or store particular
Dialogue: 0,0:49:00.16,0:49:03.94,csapp,,0,0,0,,now in practice on most systems this SIG atomic T is an int 
Dialogue: 0,0:49:05.80,0:49:12.00,csapp,,0,0,0,,so you can you can read or write an int with one one instruction okay so it's it's atomic 
Dialogue: 0,0:49:12.62,0:49:16.06,csapp,,0,0,0,,but if you want to be portable you declare it with sig atomic T 
Dialogue: 0,0:49:16.30,0:49:21.94,csapp,,0,0,0,,and then it'll it'll work on none it will work on all systems
Dialogue: 0,0:49:24.78,0:49:27.44,csapp,,0,0,0,, okay we mentioned this property of a sync signal safety 
Dialogue: 0,0:49:28.66,0:49:32.66,csapp,,0,0,0,,now a function is is safe to be used inside of a signal handler
Dialogue: 0,0:49:33.56,0:49:38.54,csapp,,0,0,0,, if it's either reentrant okay or if it can't be interrupted by signals
Dialogue: 0,0:49:39.30,0:49:44.62,csapp,,0,0,0,,and will a reentrant function as we'll see when we study threads is a function where all of its
Dialogue: 0,0:49:45.16,0:49:48.20,csapp,,0,0,0,, all of the data that it accesses is on its own stack 
Dialogue: 0,0:49:50.64,0:49:56.06,csapp,,0,0,0,,okay so no global variables no pointers to global variables everything's stored on the stack locally 
Dialogue: 0,0:49:58.00,0:50:00.42,csapp,,0,0,0,,okay so that means you can be it's called reentrant 
Dialogue: 0,0:50:00.42,0:50:03.36,csapp,,0,0,0,,because you can write have multiple instances of that function
Dialogue: 0,0:50:03.36,0:50:08.52,csapp,,0,0,0,, and they all have their own separate copies of all of the variables that they're they're using 
Dialogue: 0,0:50:10.02,0:50:16.58,csapp,,0,0,0,,now the POSIX standard guarantees 117 different functions to be a sync signal saved
Dialogue: 0,0:50:19.80,0:50:24.42,csapp,,0,0,0,,these include underscore _exit,write,wait,waitpid,sleep,kill 
Dialogue: 0,0:50:25.52,0:50:30.81,csapp,,0,0,0,, but unfortunately there's some very popular functions that aren't on this list  printf,sprintf
Dialogue: 0,0:50:31.28,0:50:32.70,csapp,,0,0,0,,things that you really want to use 
Dialogue: 0,0:50:33.14,0:50:37.84,csapp,,0,0,0,,and in fact write is the only output function that's a sync signal safe
Dialogue: 0,0:50:41.06,0:50:43.14,csapp,,0,0,0,,so this is kind of a problem because
Dialogue: 0,0:50:44.34,0:50:50.52,csapp,,0,0,0,,especially when you know you something you'd often like your signal handlers to output information 
Dialogue: 0,0:50:51.52,0:50:56.38,csapp,,0,0,0,,but you can't if you want to really be pedantic and careful you can't use printf in fact 
Dialogue: 0,0:50:57.48,0:50:59.28,csapp,,0,0,0,,it's possible to write a program 
Dialogue: 0,0:51:00.46,0:51:04.16,csapp,,0,0,0,,and I'll try to I'll try to it's possible to write a program
Dialogue: 0,0:51:05.12,0:51:09.24,csapp,,0,0,0,, that does a tight loop of printouts in the main routine 
Dialogue: 0,0:51:10.96,0:51:18.32,csapp,,0,0,0,,and then a steady stream of interrupts which execute a handler which also does a printf 
Dialogue: 0,0:51:22.94,0:51:28.70,csapp,,0,0,0,,the printf call has to acquire what's called a lock on the terminal 
Dialogue: 0,0:51:29.24,0:51:32.88,csapp,,0,0,0,,okay each printf inside that that library function
Dialogue: 0,0:51:33.70,0:51:40.06,csapp,,0,0,0,,it acquires a lock which means only one instance of printf can write to the terminal at a point in time
Dialogue: 0,0:51:40.90,0:51:44.94,csapp,,0,0,0,, if another if another function tries to acquire that lock it has to wait `
Dialogue: 0,0:51:46.28,0:51:50.12,csapp,,0,0,0,,until whatever function owns the lock releases it 
Dialogue: 0,0:51:50.84,0:51:58.30,csapp,,0,0,0,,okay so a lock prevents a lock is a way for to get mutually exclusive access to two shared resources 
Dialogue: 0,0:51:59.68,0:52:04.90,csapp,,0,0,0,,so if we have a tight loop in our main routine with executing printf
Dialogue: 0,0:52:05.66,0:52:10.22,csapp,,0,0,0,, imagine what happens if one of those printouts acquires a lock on the terminal
Dialogue: 0,0:52:10.68,0:52:16.18,csapp,,0,0,0,, and then gets interrupted not by the receipt of a signal 
Dialogue: 0,0:52:16.88,0:52:20.58,csapp,,0,0,0,,now within the signal handler it calls another printf
Dialogue: 0,0:52:22.08,0:52:26.88,csapp,,0,0,0,, and that printf tries to acquire that lock  and it blocks forever 
Dialogue: 0,0:52:27.10,0:52:32.28,csapp,,0,0,0,,because nothing's going to release that lock because the the main routine was interrupted by the handler 
Dialogue: 0,0:52:35.28,0:52:40.48,csapp,,0,0,0,,so you have what's called a classical a classical condition called deadlock 
Dialogue: 0,0:52:41.06,0:52:44.32,csapp,,0,0,0,,which is we have a process waiting for an event that will never occur 
Dialogue: 0,0:52:44.36,0:52:50.48,csapp,,0,0,0,,in this case the the printf and the signal handler is waiting for a lock to be released that will never be released
Dialogue: 0,0:52:51.70,0:52:56.66,csapp,,0,0,0,,so it's interesting you can try this it's
Dialogue: 0,0:52:57.42,0:53:01.40,csapp,,0,0,0,, it's it's not too hard to to create this deadlock situation 
Dialogue: 0,0:53:02.90,0:53:05.74,csapp,,0,0,0,,so to deal with this I really didn't want to tell you guys
Dialogue: 0,0:53:05.74,0:53:09.92,csapp,,0,0,0,, that you couldn't have any output in your programs and writes a very difficult thing to deal with 
Dialogue: 0,0:53:11.10,0:53:16.84,csapp,,0,0,0,,so so I created a small little library called the safe i/o library 
Dialogue: 0,0:53:18.50,0:53:25.46,csapp,,0,0,0,,consists of three routines and they're available to you in the csapp.c file
Dialogue: 0,0:53:25.46,0:53:28.02,csapp,,0,0,0,, which is distributed on the website 
Dialogue: 0,0:53:28.94,0:53:31.42,csapp,,0,0,0,,and it consists of three reentrant routines 
Dialogue: 0,0:53:33.64,0:53:37.50,csapp,,0,0,0,,sio_puts prince/princess string 
Dialogue: 0,0:53:38.84,0:53:41.48,csapp,,0,0,0,,(sio_)putl prints a long
Dialogue: 0,0:53:42.82,0:53:48.04,csapp,,0,0,0,,and sio_error prints a message and then exits 
Dialogue: 0,0:53:50.82,0:53:55.92,csapp,,0,0,0,,okay so you can safely use take my word for it you can safely use this in your in your signal handlers 
Dialogue: 0,0:53:56.54,0:54:01.94,csapp,,0,0,0,,so if we were going to rewrite our sigint_handler from the from the binary bomb 
Dialogue: 0,0:54:02.60,0:54:08.38,csapp,,0,0,0,,we could rewrite it like this and now we have every function is is a sync signal safe
Dialogue: 0,0:54:11.60,0:54:16.58,csapp,,0,0,0,, all right now signals are also tucked because of this this funky non cueing semantics 
Dialogue: 0,0:54:19.56,0:54:21.70,csapp,,0,0,0,,of and so it's really easy to make mistakes 
Dialogue: 0,0:54:23.92,0:54:26.14,csapp,,0,0,0,,when you have an implicit assumption that 
Dialogue: 0,0:54:27.94,0:54:33.18,csapp,,0,0,0,,the that the receipt of a signal it can be used to count the occurrence of an event 
Dialogue: 0,0:54:34.82,0:54:38.32,csapp,,0,0,0,,so let's look at this let's look at this example program 
Dialogue: 0,0:54:40.88,0:54:42.92,csapp,,0,0,0,,we install a sick child handler
Dialogue: 0,0:54:43.92,0:54:49.40,csapp,,0,0,0,, okay and this is actually this this sort of close the loop member we talked about our example shell
Dialogue: 0,0:54:49.96,0:54:53.38,csapp,,0,0,0,,we're wondering how are we going to reap those those background children 
Dialogue: 0,0:54:53.76,0:54:57.42,csapp,,0,0,0,,well we do it by installing a sick child handle like we're doing in this example 
Dialogue: 0,0:54:58.26,0:55:03.62,csapp,,0,0,0,,so this here we have a program that installs this sick child handler
Dialogue: 0,0:55:04.28,0:55:08.86,csapp,,0,0,0,,and then it creates n different child processes
Dialogue: 0,0:55:09.64,0:55:12.86,csapp,,0,0,0,, where each child sleeps for a little bit and exits 
Dialogue: 0,0:55:17.02,0:55:22.16,csapp,,0,0,0,,and then it spins until the C count variable  becomes zero
Dialogue: 0,0:55:23.86,0:55:29.16,csapp,,0,0,0,,that the parent I'm sorry the parent spins until the C count variable becomes zero
Dialogue: 0,0:55:30.76,0:55:37.06,csapp,,0,0,0,, now in the in our child handler we we have a global that's
Dialogue: 0,0:55:37.88,0:55:40.32,csapp,,0,0,0,, that's initialized to zero ccount 
Dialogue: 0,0:55:43.94,0:55:48.40,csapp,,0,0,0,,and then we wait we're going to wait so this child when the child handler gets called that means
Dialogue: 0,0:55:48.84,0:55:51.14,csapp,,0,0,0,, it's called because we received a sick child signal
Dialogue: 0,0:55:53.30,0:55:58.52,csapp,,0,0,0,, okay so in our in our handler we're going to reap that child by calling weight 
Dialogue: 0,0:56:00.04,0:56:03.60,csapp,,0,0,0,,and we're going to Dec and then will decrement ccount 
Dialogue: 0,0:56:04.00,0:56:10.56,csapp,,0,0,0,,okay so once all of the children if then have been reaped ccount will be zero 
Dialogue: 0,0:56:10.56,0:56:13.88,csapp,,0,0,0,,and then the parent can exit this this while loop
Dialogue: 0,0:56:15.54,0:56:18.48,csapp,,0,0,0,, okay now in this particular example N was 5 
Dialogue: 0,0:56:20.20,0:56:26.72,csapp,,0,0,0,,but will you run this code we only the handle or only gets called twice
Dialogue: 0,0:56:29.46,0:56:35.38,csapp,,0,0,0,, okay so the the message handler Reap child only gets executed twice right
Dialogue: 0,0:56:35.38,0:56:37.76,csapp,,0,0,0,, which means the handler was only called twice 
Dialogue: 0,0:56:38.04,0:56:42.62,csapp,,0,0,0,,we created five children we terminated five children 
Dialogue: 0,0:56:43.58,0:56:45.16,csapp,,0,0,0,,but we only reaped two
Dialogue: 0,0:56:47.26,0:56:51.94,csapp,,0,0,0,,okay so that the problem is that when we the problem is that we assumed
Dialogue: 0,0:56:52.76,0:56:54.84,csapp,,0,0,0,, that the receipt that the that
Dialogue: 0,0:56:56.94,0:57:03.36,csapp,,0,0,0,,the execution of the child handled our correspondent to the single receipt of a single sick child signal 
Dialogue: 0,0:57:04.78,0:57:06.22,csapp,,0,0,0,,okay when when in reality
Dialogue: 0,0:57:07.30,0:57:09.38,csapp,,0,0,0,, we had in reality multiple sick right
Dialogue: 0,0:57:10.40,0:57:15.90,csapp,,0,0,0,, we had in reality multiple sick child signals were delivered to that child 
Dialogue: 0,0:57:15.90,0:57:19.10,csapp,,0,0,0,,which kept overriding that at bid in the pending bit vector 
Dialogue: 0,0:57:20.26,0:57:26.68,csapp,,0,0,0,,and the delivery of those signals didn't didn't have didn't cause any reaction in the process
Dialogue: 0,0:57:26.68,0:57:30.00,csapp,,0,0,0,, until that process was was just about ready to be rescheduled 
Dialogue: 0,0:57:30.44,0:57:33.02,csapp,,0,0,0,,and only then was where was a signal received
Dialogue: 0,0:57:33.92,0:57:37.84,csapp,,0,0,0,,but even though like say three signals were delivered only one was received
Dialogue: 0,0:57:41.04,0:57:43.80,csapp,,0,0,0,,okay so you can't use events in this case we're using event 
Dialogue: 0,0:57:44.58,0:57:50.40,csapp,,0,0,0,,we're using signals to count  events which in this case is the termination of a child 
Dialogue: 0,0:57:51.30,0:57:55.52,csapp,,0,0,0,,okay so the receipt of a signal in this case
Dialogue: 0,0:57:55.62,0:58:00.04,csapp,,0,0,0,,it only indicates that at least one child terminated 
Dialogue: 0,0:58:00.40,0:58:04.06,csapp,,0,0,0,,right not not one child terminated
Dialogue: 0,0:58:05.36,0:58:10.60,csapp,,0,0,0,, all we can infer from the receipt of that signal is that at least one child has terminated 
Dialogue: 0,0:58:11.70,0:58:17.88,csapp,,0,0,0,,okay so to fix that when we receive a sick child 
Dialogue: 0,0:58:18.68,0:58:23.80,csapp,,0,0,0,,we have to put we have to put the weight that's reaping on our children
Dialogue: 0,0:58:24.36,0:58:26.62,csapp,,0,0,0,, we have to put that in this in a loop 
Dialogue: 0,0:58:27.30,0:58:29.48,csapp,,0,0,0,,so we have to assume that the receipt of a sick child
Dialogue: 0,0:58:29.80,0:58:34.16,csapp,,0,0,0,, if we get a sick child there could be multiple terminated children 
Dialogue: 0,0:58:34.82,0:58:37.92,csapp,,0,0,0,,that we have to that we have to reap 
Dialogue: 0,0:58:38.68,0:58:42.78,csapp,,0,0,0,,and so we put we put that in this loop and we execute this loop 
Dialogue: 0,0:58:43.08,0:58:48.78,csapp,,0,0,0,,until there's no more terminated children in which case wait will will 
Dialogue: 0,0:58:49.24,0:58:53.22,csapp,,0,0,0,,will exit with an error code of -1 and a error know of a child
Dialogue: 0,0:58:53.80,0:58:58.00,csapp,,0,0,0,,so this isn't really an error it's just it just means there's no more terminated children
Dialogue: 0,0:58:58.00,0:59:03.30,csapp,,0,0,0,, so we check as long as if our error knows naughty child  then we have an error
Dialogue: 0,0:59:03.82,0:59:06.72,csapp,,0,0,0,, otherwise we terminated normally as we expect it 
Dialogue: 0,0:59:07.54,0:59:09.12,csapp,,0,0,0,,now if we run this code 
Dialogue: 0,0:59:10.46,0:59:15.94,csapp,,0,0,0,,now we we see that we reap all five children as  as we should
Dialogue: 0,0:59:18.70,0:59:23.30,csapp,,0,0,0,,okay so let's the litany of problems with signals first
Dialogue: 0,0:59:24.14,0:59:27.18,csapp,,0,0,0,, it's easy to write handlers that aren't safe 
Dialogue: 0,0:59:27.72,0:59:31.02,csapp,,0,0,0,,second it's easy to get the semantics wrong third
Dialogue: 0,0:59:32.30,0:59:35.88,csapp,,0,0,0,,they're often not even portable across different versions of Unix 
Dialogue: 0,0:59:36.82,0:59:39.86,csapp,,0,0,0,,so there's some older systems I don't know if any
Dialogue: 0,0:59:40.68,0:59:47.74,csapp,,0,0,0,,there's some earlier versions of Unix that after you catch a signal it restores the default action
Dialogue: 0,0:59:47.82,0:59:50.70,csapp,,0,0,0,, so you have to reinstall the handler every time 
Dialogue: 0,0:59:51.64,0:59:57.64,csapp,,0,0,0,,well every time a handler gets called you have to re-install that handler by calling signal inside the handler itself
Dialogue: 0,0:59:58.62,1:00:00.88,csapp,,0,0,0,,we don't have to do that for for Linux systems
Dialogue: 0,1:00:03.22,1:00:08.52,csapp,,0,0,0,, on on some systems when you have so-called slow sis calls 
Dialogue: 0,1:00:09.66,1:00:10.70,csapp,,0,0,0,,for example read
Dialogue: 0,1:00:11.96,1:00:13.54,csapp,,0,0,0,, you know if you do a read system call
Dialogue: 0,1:00:15.38,1:00:18.68,csapp,,0,0,0,, the kernel doesn't wait around for that data to arrive it's 
Dialogue: 0,1:00:20.48,1:00:25.46,csapp,,0,0,0,,it you know it sends a request to the disk controller and that schedules another process 
Dialogue: 0,1:00:26.70,1:00:31.22,csapp,,0,0,0,,right so in a way that the read call is sort of and then only when the data arrives
Dialogue: 0,1:00:31.54,1:00:34.64,csapp,,0,0,0,, and the interrupt comes in announcing that the data arrives 
Dialogue: 0,1:00:35.14,1:00:38.92,csapp,,0,0,0,,does that read call finish and then restore and return
Dialogue: 0,1:00:39.58,1:00:43.86,csapp,,0,0,0,,so you can think of read is actually kind of broken up into two parts right
Dialogue: 0,1:00:45.90,1:00:54.14,csapp,,0,0,0,,then and so that functions like read these kind of functions are called slow sis calls 
Dialogue: 0,1:00:55.36,1:00:59.68,csapp,,0,0,0,,and on some systems if the process receives a signal 
Dialogue: 0,1:01:00.16,1:01:02.54,csapp,,0,0,0,,before a slow system calls has finished
Dialogue: 0,1:01:04.24,1:01:09.22,csapp,,0,0,0,, the kernel will will just abort that system call and return from that system call with an error
Dialogue: 0,1:01:09.92,1:01:14.54,csapp,,0,0,0,, okay so from users point of view you're doing a read call 
Dialogue: 0,1:01:15.22,1:01:19.64,csapp,,0,0,0,,and it returns with this this e enter signal this e enter error 
Dialogue: 0,1:01:20.72,1:01:24.82,csapp,,0,0,0,,you did nothing wrong you just happen to have the bad luck of being interrupted by some signal
Dialogue: 0,1:01:25.14,1:01:27.26,csapp,,0,0,0,, and so in your user code you have to check for that
Dialogue: 0,1:01:27.32,1:01:33.34,csapp,,0,0,0,, and if if a slow system call like read is interrupted by signal you have to redo it 
Dialogue: 0,1:01:33.82,1:01:39.04,csapp,,0,0,0,,so you have to put which is really a pain right because you have to put these these read calls in a loop
Dialogue: 0,1:01:39.04,1:01:41.72,csapp,,0,0,0,, and keep keep looping until it succeeds 
Dialogue: 0,1:01:42.90,1:01:46.90,csapp,,0,0,0,,and finally some systems don't block signals of the type being handled right 
Dialogue: 0,1:01:48.92,1:01:52.32,csapp,,0,0,0,,so that the solution for this is a replacement for signal
Dialogue: 0,1:01:52.32,1:01:54.32,csapp,,0,0,0,, so the problem is with the signal syscall
Dialogue: 0,1:01:54.94,1:01:58.52,csapp,,0,0,0,, and the solution is a newer syscall called sigaction 
Dialogue: 0,1:01:59.00,1:02:02.32,csapp,,0,0,0,,which provides a mechanism a replacement for signal
Dialogue: 0,1:02:02.80,1:02:06.70,csapp,,0,0,0,,that provides a mechanism for portable and predictable signal handling
Dialogue: 0,1:02:07.54,1:02:14.18,csapp,,0,0,0,, and so what I've done what I've done is created a rapper called uppercase signal
Dialogue: 0,1:02:15.76,1:02:19.56,csapp,,0,0,0,,  that takes the same arguments as that the signal call 
Dialogue: 0,1:02:20.88,1:02:26.04,csapp,,0,0,0,,but inside it calls the sig action function to get portable signal handling 
Dialogue: 0,1:02:27.44,1:02:32.22,csapp,,0,0,0,,and so it's it's not really important to go into detail about this 
Dialogue: 0,1:02:34.22,1:02:42.78,csapp,,0,0,0,,the point is in your code you always want to call uppercase signal using the  rapper that provided in csapp.c 
Dialogue: 0,1:02:43.28,1:02:47.26,csapp,,0,0,0,,and then if you do that then you'll always block signals of the typing
Dialogue: 0,1:02:47.70,1:02:50.84,csapp,,0,0,0,, handle the system will automatically restart 
Dialogue: 0,1:02:52.02,1:02:55.28,csapp,,0,0,0,,slow syscalls that have been interrupted by by signals
Dialogue: 0,1:02:58.60,1:03:00.84,csapp,,0,0,0,,okay so fortunately there's an easy fix for this 
Dialogue: 0,1:03:04.48,1:03:06.74,csapp,,0,0,0,, now let's let's finish up with them
Dialogue: 0,1:03:08.78,1:03:11.60,csapp,,0,0,0,, there's some interesting I mentioned that signals are difficult 
Dialogue: 0,1:03:11.60,1:03:14.56,csapp,,0,0,0,,because of these the fact that they're they're concurrent flows  
Dialogue: 0,1:03:15.10,1:03:20.36,csapp,,0,0,0,,so I want to look at some sort of subtle issues that you can run into because of this concurrency
Dialogue: 0,1:03:21.98,1:03:26.56,csapp,,0,0,0,, and and I want to talk about how to identify those errors and how to fix them
Dialogue: 0,1:03:31.20,1:03:35.60,csapp,,0,0,0,,so here's a program that this is like a simple shell program 
Dialogue: 0,1:03:36.40,1:03:41.58,csapp,,0,0,0,,that maintains a jobs list right so every time it creates a new child 
Dialogue: 0,1:03:42.30,1:03:48.04,csapp,,0,0,0,,it adds it to the jobs list and every time that child terminates it removes it from the jobs list 
Dialogue: 0,1:03:51.06,1:04:01.76,csapp,,0,0,0,,okay so so our simple show just in a loop it just creates a child and then executes the program  within that child
Dialogue: 0,1:04:02.46,1:04:09.72,csapp,,0,0,0,, and then in the parent it correctly blocks all of the signals temporarily while it adds the job to the job queue 
Dialogue: 0,1:04:12.60,1:04:16.26,csapp,,0,0,0,,and then it unblocks and then it unblocks those signals 
Dialogue: 0,1:04:17.78,1:04:22.76,csapp,,0,0,0,,okay so this is correct and that it's it's protecting access to this the shared job queue
Dialogue: 0,1:04:25.76,1:04:31.88,csapp,,0,0,0,, because that that that job that job queue is also manipulated by the sick child handler
Dialogue: 0,1:04:32.06,1:04:37.68,csapp,,0,0,0,, so when when a child terminates and the parent receives the sick child
Dialogue: 0,1:04:38.26,1:04:40.54,csapp,,0,0,0,,this handler runs
Dialogue: 0,1:04:41.98,1:04:47.02,csapp,,0,0,0,, and this handler goes through and it reaps all of the children potentially terminated children 
Dialogue: 0,1:04:47.82,1:04:52.42,csapp,,0,0,0,,and then for each one it deletes that that job from the job queue
Dialogue: 0,1:04:52.92,1:04:57.66,csapp,,0,0,0,, all right so here's a classic case we have two concurrent flows our main routine 
Dialogue: 0,1:04:58.44,1:05:00.74,csapp,,0,0,0,,and our our signal handler 
Dialogue: 0,1:05:01.82,1:05:06.50,csapp,,0,0,0,,they're each accessing a shared data structure in this case the the job queue 
Dialogue: 0,1:05:08.78,1:05:16.62,csapp,,0,0,0,,okay and they're there correctly blocking signals while they update this this job queue
Dialogue: 0,1:05:19.12,1:05:23.26,csapp,,0,0,0,,but this program has a really subtle and nasty bug in it 
Dialogue: 0,1:05:25.42,1:05:26.58,csapp,,0,0,0,,can you see what it is
Dialogue: 0,1:05:30.60,1:05:32.26,csapp,,0,0,0,,what's the sequence of events that would
Dialogue: 0,1:05:33.58,1:05:36.50,csapp,,0,0,0,,cause this program to to fail 
Dialogue: 0,1:05:40.82,1:05:41.34,csapp,,0,0,0,,yes
Dialogue: 0,1:05:47.22,1:05:52.58,csapp,,0,0,0,,exactly that's exactly it so is it possible that the the child process
Dialogue: 0,1:05:53.34,1:05:58.02,csapp,,0,0,0,,could terminate before the parent has a chance to add that job to the queue and the answer is yes 
Dialogue: 0,1:05:58.66,1:06:04.78,csapp,,0,0,0,,right we you cannot make any assumptions about the execution ordering of the child in the process 
Dialogue: 0,1:06:05.14,1:06:06.40,csapp,,0,0,0,,or about how long they run right 
Dialogue: 0,1:06:06.78,1:06:09.42,csapp,,0,0,0,,so it's it's it's very possible 
Dialogue: 0,1:06:10.10,1:06:16.20,csapp,,0,0,0,,that the child can connect after after the four control returns to the child instead of the parent
Dialogue: 0,1:06:16.76,1:06:22.90,csapp,,0,0,0,, and then the child terminates before the parent ever has a chance to to add that job to the job queue 
Dialogue: 0,1:06:23.38,1:06:30.10,csapp,,0,0,0,,so now what's happened is that the the child is deleting
Dialogue: 0,1:06:30.92,1:06:35.43,csapp,,0,0,0,, a deleting a job that hasn't been added to the job queue  right 
Dialogue: 0,1:06:35.62,1:06:40.30,csapp,,0,0,0,,now when the parent finally gets around to running it adds that job to the job queue
Dialogue: 0,1:06:40.58,1:06:42.06,csapp,,0,0,0,, and that job will never be deleted
Dialogue: 0,1:06:43.96,1:06:50.42,csapp,,0,0,0,,right so this is the kind of subtle nasty horrible kind of bug that you run into
Dialogue: 0,1:06:50.78,1:06:52.46,csapp,,0,0,0,, when you're dealing with concurrency
Dialogue: 0,1:06:53.00,1:06:56.06,csapp,,0,0,0,, trying to keep track of all of these interleaving of events 
Dialogue: 0,1:06:56.82,1:06:58.78,csapp,,0,0,0,,can just make your head explode all right 
Dialogue: 0,1:06:59.62,1:07:04.90,csapp,,0,0,0,,now and it happens and Sigma it happens with any kind of concurrency 
Dialogue: 0,1:07:05.30,1:07:09.82,csapp,,0,0,0,,where you have concurrent flows accessing shared resources and signal handlers are no different
Dialogue: 0,1:07:10.68,1:07:15.88,csapp,,0,0,0,, now we'll look at principled ways where we can deal with this kind of sharing when we study threads later on
Dialogue: 0,1:07:17.34,1:07:22.16,csapp,,0,0,0,,but I just want to point this out to him scare you a little bit 
Dialogue: 0,1:07:23.34,1:07:24.96,csapp,,0,0,0,,all right so here's how we would fix that 
Dialogue: 0,1:07:27.28,1:07:37.74,csapp,,0,0,0,,what we have to do is somehow avoid the avoid the the avoid the  possibility of the child handle or executing 
Dialogue: 0,1:07:38.38,1:07:43.28,csapp,,0,0,0,,before the parent can add the corresponding job to the job queue 
Dialogue: 0,1:07:44.18,1:07:48.54,csapp,,0,0,0,,now we can't control whether the child executes first or the parent execute first 
Dialogue: 0,1:07:49.62,1:07:51.74,csapp,,0,0,0,,and we can't control how long the child runs 
Dialogue: 0,1:07:52.50,1:07:58.10,csapp,,0,0,0,,but we can control when the the sigchild handler runs because we can block signals
Dialogue: 0,1:07:58.81,1:08:00.84,csapp,,0,0,0,,okay so what we'll do
Dialogue: 0,1:08:02.44,1:08:04.34,csapp,,0,0,0,, we'll modify our program - 
Dialogue: 0,1:08:07.36,1:08:12.88,csapp,,0,0,0,,we'll use sigprocmask to block sigchild signals before we create the child 
Dialogue: 0,1:08:14.50,1:08:19.44,csapp,,0,0,0,,okay so at this point after this invocation of sigproc,sigchild, signals are blocked 
Dialogue: 0,1:08:21.64,1:08:23.32,csapp,,0,0,0,,okay then we create the child 
Dialogue: 0,1:08:24.68,1:08:27.54,csapp,,0,0,0,,and before we do execev
Dialogue: 0,1:08:27.90,1:08:34.30,csapp,,0,0,0,,since we don't know that child may may need to reap its children right we don't know if it we 
Dialogue: 0,1:08:34.82,1:08:38.40,csapp,,0,0,0,,by default children inherit the the blocked 
Dialogue: 0,1:08:39.48,1:08:42.82,csapp,,0,0,0,,a bit vector of their parents okay so when this child runs
Dialogue: 0,1:08:44.60,1:08:51.74,csapp,,0,0,0,, F after it returns from fork at this point right after the fork sigchild is blocked in the child as well right
Dialogue: 0,1:08:52.34,1:08:55.28,csapp,,0,0,0,, so if if we didn't do anything if and the child created children
Dialogue: 0,1:08:56.74,1:09:01.58,csapp,,0,0,0,, and tried to reap you know reap them with a sick child handle that sick child handler wouldn't run right
Dialogue: 0,1:09:01.60,1:09:02.44,csapp,,0,0,0,,  so that would be a problem
Dialogue: 0,1:09:03.42,1:09:08.30,csapp,,0,0,0,,so in the child before we execute that the program itself we unblock sigchild 
Dialogue: 0,1:09:09.16,1:09:11.60,csapp,,0,0,0,,and this was an example that I was alluding to last time
Dialogue: 0,1:09:12.40,1:09:19.44,csapp,,0,0,0,,how it's useful sometimes to separate creating processes with executing programs right then 
Dialogue: 0,1:09:20.72,1:09:27.52,csapp,,0,0,0,,so this allows us to get our our signal mask set up the way we want it before we run our program  in the child 
Dialogue: 0,1:09:29.34,1:09:33.82,csapp,,0,0,0,,so now even if the child terminates early 
Dialogue: 0,1:09:36.26,1:09:43.94,csapp,,0,0,0,,the sigchild handler won't run until after we've added the job to the to the job queue 
Dialogue: 0,1:09:44.42,1:09:49.74,csapp,,0,0,0,,because we don't unblock sick child until after the until after we call a job 
Dialogue: 0,1:09:57.82,1:09:58.98,csapp,,0,0,0,,okay now there's another
Dialogue: 0,1:09:59.26,1:10:04.40,csapp,,0,0,0,, so this this sort of scenario be very relevant to you when you do your shell lab 
Dialogue: 0,1:10:05.10,1:10:08.52,csapp,,0,0,0,,okay so you want to be careful not to not to make that mistake 
Dialogue: 0,1:10:12.28,1:10:15.84,csapp,,0,0,0,, another another thing that you you're going to need to do in your shell lab 
Dialogue: 0,1:10:16.92,1:10:20.22,csapp,,0,0,0,,now you remember in our simple our simple shell example we did the weight
Dialogue: 0,1:10:20.74,1:10:24.65,csapp,,0,0,0,, inside the main routine so we waited for foreground jobs using wait
Dialogue: 0,1:10:25.48,1:10:31.28,csapp,,0,0,0,,but now in a real shell we're going to have our sick child handler do all the all the weights call all the weights 
Dialogue: 0,1:10:32.28,1:10:37.58,csapp,,0,0,0,,and it week so we can't put the weight has to go in the sigchild handler can't go in the main routine 
Dialogue: 0,1:10:40.48,1:10:45.66,csapp,,0,0,0,,okay so if it so high if we can't put a weight in the main routine 
Dialogue: 0,1:10:46.88,1:10:50.88,csapp,,0,0,0,,how are we going to how are we going to detect that our foreground job is finished 
Dialogue: 0,1:10:56.50,1:11:01.42,csapp,,0,0,0,,okay so somehow so what we could do we could define in the sig child handler 
Dialogue: 0,1:11:03.00,1:11:05.16,csapp,,0,0,0,,when we read the foreground job 
Dialogue: 0,1:11:06.84,1:11:10.42,csapp,,0,0,0,,right we've created a foreground job when we read that foreground job 
Dialogue: 0,1:11:11.18,1:11:14.92,csapp,,0,0,0,,we could set this global flag
Dialogue: 0,1:11:16.02,1:11:18.48,csapp,,0,0,0,, we could declare the process this process ID 
Dialogue: 0,1:11:19.14,1:11:21.98,csapp,,0,0,0,,a variable PID as a as a global flag 
Dialogue: 0,1:11:22.64,1:11:27.86,csapp,,0,0,0,,and then just assign the process ID of the of the of the foreground job 
Dialogue: 0,1:11:29.50,1:11:34.06,csapp,,0,0,0,,okay so in this this is an example of a handler it just all it does it sets a flag and then exits
Dialogue: 0,1:11:38.92,1:11:45.56,csapp,,0,0,0,,and then in our main routine okay we want to we want to block sig tile just by just like before 
Dialogue: 0,1:11:45.94,1:11:51.24,csapp,,0,0,0,,okay to avoid that that race condition between the parent and the child 
Dialogue: 0,1:11:53.48,1:11:55.42,csapp,,0,0,0,,and then we create the child
Dialogue: 0,1:11:57.40,1:12:01.54,csapp,,0,0,0,, and then and then in the and then the parent we set PID to zero 
Dialogue: 0,1:12:03.92,1:12:05.70,csapp,,0,0,0,,okay then we unblock sigchild 
Dialogue: 0,1:12:07.30,1:12:11.76,csapp,,0,0,0,,and then we wait for the sick child handler to run and set PID to non zero 
Dialogue: 0,1:12:15.56,1:12:18.34,csapp,,0,0,0,,okay okay everybody see that I mean this so this is correct right
Dialogue: 0,1:12:19.70,1:12:21.30,csapp,,0,0,0,, but it's extremely wasteful right
Dialogue: 0,1:12:21.64,1:12:29.96,csapp,,0,0,0,,we're spinning we're using valuable processor cycles in this in this tight spin loop 
Dialogue: 0,1:12:30.14,1:12:33.74,csapp,,0,0,0,,just executing over and over and over and over and over and over  for who knows how long 
Dialogue: 0,1:12:35.14,1:12:38.72,csapp,,0,0,0,,okay so that's not a good that's not a good solution alright
Dialogue: 0,1:12:38.80,1:12:41.86,csapp,,0,0,0,, so let's look at a couple other things we might might consider 
Dialogue: 0,1:12:42.64,1:12:46.30,csapp,,0,0,0,,and that have been considered by generations of 213 students
Dialogue: 0,1:12:49.70,1:12:54.92,csapp,,0,0,0,, so one thing you might think well I'll just instead of just putting a semicolon here
Dialogue: 0,1:12:55.50,1:12:56.62,csapp,,0,0,0,, I'll pause 
Dialogue: 0,1:12:58.56,1:13:02.06,csapp,,0,0,0,,and then I'll wait for the sig child handler to run
Dialogue: 0,1:13:03.44,1:13:05.34,csapp,,0,0,0,,and then I'll go back up and I'll check
Dialogue: 0,1:13:06.26,1:13:07.44,csapp,,0,0,0,,I'll check PID again 
Dialogue: 0,1:13:08.80,1:13:11.64,csapp,,0,0,0,,now you have to put this in a loop it still has to be in a loop
Dialogue: 0,1:13:12.56,1:13:16.72,csapp,,0,0,0,, because we have other signal handlers in our program we have a SIGINT handler
Dialogue: 0,1:13:17.72,1:13:22.50,csapp,,0,0,0,, so it might be if we do the pause here and this again comes in and say get Sigyn handler runs 
Dialogue: 0,1:13:24.02,1:13:27.14,csapp,,0,0,0,,that would cause us to exit the pause function and go back up 
Dialogue: 0,1:13:27.36,1:13:29.80,csapp,,0,0,0,,so we have to keep checking PID because we're not sure 
Dialogue: 0,1:13:30.66,1:13:37.66,csapp,,0,0,0,,we have to keep checking for the specific signal handler sick child handler to run instead of other handlers that might run
Dialogue: 0,1:13:39.32,1:13:41.28,csapp,,0,0,0,,but this is actually wrong 
Dialogue: 0,1:13:44.36,1:13:47.74,csapp,,0,0,0,,because it has a race can you see what the race is
Dialogue: 0,1:13:54.54,1:13:58.62,csapp,,0,0,0,,what's wrong with this there's a good chance that this thing will block forever
Dialogue: 0,1:14:03.50,1:14:15.92,csapp,,0,0,0,, yes
Dialogue: 0,1:14:16.06,1:14:20.46,csapp,,0,0,0,,yeah that's so the the problem the problem with this is like 
Dialogue: 0,1:14:20.90,1:14:26.12,csapp,,0,0,0,,so if the signal if the signal is received after PID is checked 
Dialogue: 0,1:14:27.00,1:14:28.66,csapp,,0,0,0,,but before the pause executes
Dialogue: 0,1:14:29.54,1:14:31.82,csapp,,0,0,0,, okay which is possible right
Dialogue: 0,1:14:33.14,1:14:35.76,csapp,,0,0,0,,it's unlikely but it's possible
Dialogue: 0,1:14:37.54,1:14:41.52,csapp,,0,0,0,, if that if that signal is arrives here
Dialogue: 0,1:14:42.62,1:14:45.36,csapp,,0,0,0,, then the handler will set PID to non zero and
Dialogue: 0,1:14:46.08,1:14:47.82,csapp,,0,0,0,,then we'll execute the pause 
Dialogue: 0,1:14:49.00,1:14:53.32,csapp,,0,0,0,,and the pause will be blocked forever waiting for a signal that will never arrive right
Dialogue: 0,1:14:53.84,1:14:56.14,csapp,,0,0,0,, because the sync child signal already already came 
Dialogue: 0,1:14:57.56,1:14:58.80,csapp,,0,0,0,,very subtle right
Dialogue: 0,1:15:00.28,1:15:03.42,csapp,,0,0,0,,so this code looks okay it looks benign but it's wrong 
Dialogue: 0,1:15:04.46,1:15:08.48,csapp,,0,0,0,,and and and your program would just hang forever
Dialogue: 0,1:15:09.60,1:15:11.26,csapp,,0,0,0,, so we say well okay that's no good
Dialogue: 0,1:15:11.80,1:15:16.36,csapp,,0,0,0,,we could replace the pause with asleep so we could say let's let's check PID
Dialogue: 0,1:15:17.26,1:15:22.52,csapp,,0,0,0,,and then sleep for some predetermined amount of time in this case one second
Dialogue: 0,1:15:24.68,1:15:26.98,csapp,,0,0,0,,and then go back up and check PID again
Dialogue: 0,1:15:28.42,1:15:34.00,csapp,,0,0,0,,so this while this is correct it's way too slow right we're asking the system to wait for a second which is an eternity
Dialogue: 0,1:15:35.10,1:15:40.02,csapp,,0,0,0,, and there's there's forms of sleep nanosecond where you can wait instead of units of seconds
Dialogue: 0,1:15:40.02,1:15:41.76,csapp,,0,0,0,, you can wait in units of nanoseconds 
Dialogue: 0,1:15:42.26,1:15:44.32,csapp,,0,0,0,,but that what value do you use right 
Dialogue: 0,1:15:45.16,1:15:51.48,csapp,,0,0,0,,if it's it that so that's if you choose a value that's too large then you have this problem the slowness problem
Dialogue: 0,1:15:51.82,1:15:54.90,csapp,,0,0,0,, if you choose a sleep time that's too small
Dialogue: 0,1:15:55.30,1:15:57.64,csapp,,0,0,0,, then you have the other problem that it's inefficient
Dialogue: 0,1:15:59.20,1:16:01.14,csapp,,0,0,0,, so the solution is to use six suspend 
Dialogue: 0,1:16:03.04,1:16:05.70,csapp,,0,0,0,,which is the last last thing we're going to look at today 
Dialogue: 0,1:16:06.84,1:16:11.58,csapp,,0,0,0,,so six suspend is a function that takes a signal mask 
Dialogue: 0,1:16:12.94,1:16:17.64,csapp,,0,0,0,,and it's equivalent to an uninterruptible version of these three statements
Dialogue: 0,1:16:18.88,1:16:23.40,csapp,,0,0,0,, so we block the signals that are specified in the signal mask 
Dialogue: 0,1:16:25.18,1:16:27.46,csapp,,0,0,0,,and then it's atomic in the sense that
Dialogue: 0,1:16:30.28,1:16:36.22,csapp,,0,0,0,,after that this this these two statements can't be interrupted they're always executed together 
Dialogue: 0,1:16:37.28,1:16:39.34,csapp,,0,0,0,,okay so we blocked these signals 
Dialogue: 0,1:16:40.34,1:16:41.84,csapp,,0,0,0,,and then we execute the pause 
Dialogue: 0,1:16:44.08,1:16:45.30,csapp,,0,0,0,,okay so there's no chance
Dialogue: 0,1:16:46.18,1:16:51.60,csapp,,0,0,0,, of a signal interrupting this program in between the sigprocmask and the pause 
Dialogue: 0,1:16:54.58,1:16:58.74,csapp,,0,0,0,,okay and then and then when a signal does come in and 
Dialogue: 0,1:17:00.28,1:17:05.80,csapp,,0,0,0,,the execution of the handle or causes pause to exit then we set the mask back to what it was before
Dialogue: 0,1:17:08.34,1:17:10.82,csapp,,0,0,0,, okay so the proper way then to wait for a signal 
Dialogue: 0,1:17:11.74,1:17:13.88,csapp,,0,0,0,,is to use sig suspend in the following way 
Dialogue: 0,1:17:14.82,1:17:16.52,csapp,,0,0,0,,so here's our here's our program again 
Dialogue: 0,1:17:17.82,1:17:20.80,csapp,,0,0,0,,we before we create the child's we block sigchild
Dialogue: 0,1:17:21.54,1:17:22.78,csapp,,0,0,0,,then we create the child 
Dialogue: 0,1:17:23.96,1:17:26.42,csapp,,0,0,0,,and now we're going to wait for the sick child to be received
Dialogue: 0,1:17:27.72,1:17:29.48,csapp,,0,0,0,, now sick child is still blocked
Dialogue: 0,1:17:30.26,1:17:34.90,csapp,,0,0,0,,okay so there's no danger of the sick child handler running 
Dialogue: 0,1:17:35.42,1:17:38.26,csapp,,0,0,0,,okay so we set that global variable to zero 
Dialogue: 0,1:17:39.74,1:17:44.52,csapp,,0,0,0,,and then while it's while it's non zero we repeatedly call sigsuspend 
Dialogue: 0,1:17:46.22,1:17:48.48,csapp,,0,0,0,,and sick suspend is using the previous mask 
Dialogue: 0,1:17:49.02,1:17:51.76,csapp,,0,0,0,,that was set up here so sick suspend is using the mask 
Dialogue: 0,1:17:52.50,1:17:54.53,csapp,,0,0,0,,where sigchild is unblocked
Dialogue: 0,1:17:55.42,1:18:01.48,csapp,,0,0,0,,okay when we when we entered this first sigprocmask,sigchild was unblocked
Dialogue: 0,1:18:03.32,1:18:08.70,csapp,,0,0,0,,so this allows inside the sigsuspend sigchild is unblocked 
Dialogue: 0,1:18:09.80,1:18:15.42,csapp,,0,0,0,,okay so it allows for the the handler now to be received  or to be executed 
Dialogue: 0,1:18:17.16,1:18:21.20,csapp,,0,0,0,,okay so in it and it does it safely 
Dialogue: 0,1:18:21.72,1:18:24.84,csapp,,0,0,0,,because of the uh the atomic nature of those those first two instructions
Dialogue: 0,1:18:27.44,1:18:33.16,csapp,,0,0,0,,so once the so it's possible that the the implicit pause inside of sigchild
Dialogue: 0,1:18:33.16,1:18:37.02,csapp,,0,0,0,,could be interrupted by say another signal like SIGINT 
Dialogue: 0,1:18:38.28,1:18:42.60,csapp,,0,0,0,,okay in which case we'd loop back up we notice that PID was still zero
Dialogue: 0,1:18:42.96,1:18:47.18,csapp,,0,0,0,,and we go back into sigsuspend with with sigchild unblocked 
Dialogue: 0,1:18:47.56,1:18:50.16,csapp,,0,0,0,,okay so that makes sense to everybody
Dialogue: 0,1:18:50.16,1:18:55.42,csapp,,0,0,0,, and now so this is exactly the behavior we want where we're not wasting resources but we've eliminated the race
Dialogue: 0,1:18:59.28,1:19:04.44,csapp,,0,0,0,, okay so that's it for today if you're interested non non-local jumps are this weird thing and see
Dialogue: 0,1:19:04.94,1:19:08.92,csapp,,0,0,0,, that allows a function to return to some other function that didn't call it
Dialogue: 0,1:19:11.14,1:19:17.37,csapp,,0,0,0,,okay but it's described in your textbook and also in some additional slides here if you if you're interested
