[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video File: ../../../Desktop/csapp/Lecture 06  Machine Level Programming II  Control.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 847
Active Line: 857
Video Position: 132598

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.72,0:00:08.00,csapp,,0,0,0,,Okay let's continue on in our coverage of machine level programming 
Dialogue: 0,0:00:08.82,0:00:11.46,csapp,,0,0,0,,The second in i think a six part series 
Dialogue: 0,0:00:12.14,0:00:16.76,csapp,,0,0,0,,As i mentioned yesterday machine level programming is sort of the core of this course 
Dialogue: 0,0:00:16.92,0:00:23.04,csapp,,0,0,0,,That it gives you a set of tools and understanding  that take you well beyond 
Dialogue: 0,0:00:23.04,0:00:29.70,csapp,,0,0,0,,What you're sort of average run-of-the-mill of programmer or software developer would know about 
Dialogue: 0,0:00:30.08,0:00:34.52,csapp,,0,0,0,,And it's very powerful in terms of your better understanding of the system
Dialogue: 0,0:00:34.80,0:00:41.80,csapp,,0,0,0,,What goes wrong of why programs crash ? what the meaning of those are 
Dialogue: 0,0:00:41.82,0:00:43.82,csapp,,0,0,0,,So it's a fairly core part of the material 
Dialogue: 0,0:00:44.48,0:00:46.96,csapp,,0,0,0,,As you know the data lab is due tonight 
Dialogue: 0,0:00:47.74,0:00:53.26,csapp,,0,0,0,,And the next wave out is called the bomb lab and i believe that's coming out tonight as well 
Dialogue: 0,0:00:53.90,0:01:00.00,csapp,,0,0,0,,So the bomb lab will rely on your ability to understand machine level code 
Dialogue: 0,0:01:00.70,0:01:03.94,csapp,,0,0,0,,So the these two lectures will actually be enough to give 
Dialogue: 0,0:01:03.94,0:01:06.46,csapp,,0,0,0,,You started on some of the earlier parts of that lab 
Dialogue: 0,0:01:07.02,0:01:10.16,csapp,,0,0,0,,You'll learn a lot more at recitation on monday 
Dialogue: 0,0:01:10.16,0:01:14.20,csapp,,0,0,0,,Either in person or if you're viewing the recorded version of that
Dialogue: 0,0:01:14.64,0:01:17.54,csapp,,0,0,0,,That will help you move along on bomb lab 
Dialogue: 0,0:01:18.00,0:01:23.14,csapp,,0,0,0,,Like all the labs in this course at least the first two we give you a fair amount of time for them 
Dialogue: 0,0:01:23.72,0:01:29.62,csapp,,0,0,0,,But don't be fooled into thinking that means you can just slack off or work on other courses 
Dialogue: 0,0:01:30.20,0:01:34.90,csapp,,0,0,0,,And then the last few moments jump in and finish this lab the bomb lab 
Dialogue: 0,0:01:35.36,0:01:40.10,csapp,,0,0,0,,Once you get the hang of what you're doing it's pretty you can just kind of crank along 
Dialogue: 0,0:01:40.58,0:01:46.96,csapp,,0,0,0,,But there's a certain learning curve that will take you to even get started on it effectively 
Dialogue: 0,0:01:47.08,0:01:48.28,csapp,,0,0,0,,So don't put it off
Dialogue: 0,0:01:56.66,0:02:12.30,csapp,,0,0,0,,Um or is this
Dialogue: 0,0:02:12.30,0:02:16.40,csapp,,0,0,0,,So last time we introduced the very basic principles of machine level programming 
Dialogue: 0,0:02:16.40,0:02:21.84,csapp,,0,0,0,,The idea of there being special state that you have access to the registers 
Dialogue: 0,0:02:21.84,0:02:27.22,csapp,,0,0,0,,Which people came out to class nesta a register is part of memory?no 
Dialogue: 0,0:02:27.44,0:02:29.38,csapp,,0,0,0,,Are they part of the cache ？no.through
Dialogue: 0,0:02:29.90,0:02:34.18,csapp,,0,0,0,,They special,they're different they don't exist to a c level program 
Dialogue: 0,0:02:34.30,0:02:37.00,csapp,,0,0,0,,When you're programming and see you don't have any visibility into them
Dialogue: 0,0:02:37.66,0:02:39.36,csapp,,0,0,0,,And in general today 
Dialogue: 0,0:02:39.36,0:02:44.26,csapp,,0,0,0,,What we're going to do then is go beyond the sort of very basics  and start talking about the control.
Dialogue: 0,0:02:44.26,0:02:50.06,csapp,,0,0,0,,How you control the flow of execution of instructions in a at the machine level
Dialogue: 0,0:02:50.48,0:02:53.18,csapp,,0,0,0,,And how you use those techniques to implement 
Dialogue: 0,0:02:53.18,0:02:58.18,csapp,,0,0,0,,Basic constructs conditional statements,loops and switch statements
Dialogue: 0,0:02:59.08,0:03:02.72,csapp,,0,0,0,,And then next time we'll talk about procedures which warrants a whole lecture of its own 
Dialogue: 0,0:03:05.16,0:03:09.30,csapp,,0,0,0,,So that x86 and several machines of its generation 
Dialogue: 0,0:03:09.70,0:03:16.22,csapp,,0,0,0,,Have these curious little of one bit flags that are called condition codes 
Dialogue: 0,0:03:16.54,0:03:19.26,csapp,,0,0,0,,And they're the basis of how conditional operations work 
Dialogue: 0,0:03:20.86,0:03:26.30,csapp,,0,0,0,,So to a machine level programmer then we talked last time that
Dialogue: 0,0:03:26.30,0:03:34.04,csapp,,0,0,0,,You have visibility of the set of registers and a and the memory 
Dialogue: 0,0:03:34.44,0:03:37.94,csapp,,0,0,0,,But you also have more things and this is only a partial list 
Dialogue: 0,0:03:38.02,0:03:41.30,csapp,,0,0,0,,Actually there's more and more stuff that you can add to this picture 
Dialogue: 0,0:03:41.96,0:03:46.60,csapp,,0,0,0,,But we talked about in the 64-bit x86-64 there's 
Dialogue: 0,0:03:46.60,0:03:56.38,csapp,,0,0,0,,Now 16 registers,8 of which have names that are historic based on old x86 stuff 
Dialogue: 0,0:03:56.90,0:04:02.38,csapp,,0,0,0,,And 8 of which were introduced and so they simply named those %r8 through %r15 
Dialogue: 0,0:04:03.62,0:04:09.02,csapp,,0,0,0,,And other registers for the most part the only one that's really special is %rsp
Dialogue: 0,0:04:09.10,0:04:11.54,csapp,,0,0,0,,It's the stack pointer tells you where 
Dialogue: 0,0:04:11.76,0:04:15.76,csapp,,0,0,0,,And we'll learn a lot more about stacks starting next time 
Dialogue: 0,0:04:16.20,0:04:21.98,csapp,,0,0,0,,But it's sort of where the most the the state is that manages the execution of procedures 
Dialogue: 0,0:04:23.08,0:04:26.74,csapp,,0,0,0,,And so you can't just use that or set it in arbitrary ways 
Dialogue: 0,0:04:26.74,0:04:32.78,csapp,,0,0,0,,But the other ones you more or less come  in with qualifications to that statement 
Dialogue: 0,0:04:33.28,0:04:37.66,csapp,,0,0,0,,There's another register that they call the %rip which has nothing to do with death 
Dialogue: 0,0:04:40.54,0:04:43.42,csapp,,0,0,0,,It means that the %rip means instruction pointer 
Dialogue: 0,0:04:43.90,0:04:47.74,csapp,,0,0,0,,In ia32 is called a %eip and now it's called %rip
Dialogue: 0,0:04:47.74,0:04:50.84,csapp,,0,0,0,,Just like the registry used to be %eax and now it's %rip 
Dialogue: 0,0:04:52.06,0:04:56.52,csapp,,0,0,0,,So all it contains is the address of the currently executing instruction 
Dialogue: 0,0:04:57.12,0:04:58.60,csapp,,0,0,0,,And you can...
Dialogue: 0,0:04:59.04,0:05:02.92,csapp,,0,0,0,,It's not a register that you access in a normal way 
Dialogue: 0,0:05:02.92,0:05:07.16,csapp,,0,0,0,,But you actually there are tricks that you can find out what the value of that is 
Dialogue: 0,0:05:07.66,0:05:13.44,csapp,,0,0,0,,So that just tells you where in the program,what part of the program is currently being executed 
Dialogue: 0,0:05:13.90,0:05:16.36,csapp,,0,0,0,,And then there's these things that are called condition codes 
Dialogue: 0,0:05:16.36,0:05:19.32,csapp,,0,0,0,,And we're only showing four there's actually more like eight of them 
Dialogue: 0,0:05:19.90,0:05:22.90,csapp,,0,0,0,,But not a relevant to our general discussion 
Dialogue: 0,0:05:23.40,0:05:28.42,csapp,,0,0,0,,That are all one bit flags and they get set not directly 
Dialogue: 0,0:05:28.42,0:05:31.64,csapp,,0,0,0,,But as a side effect of other operations that take place 
Dialogue: 0,0:05:32.32,0:05:37.32,csapp,,0,0,0,,And they're the basis for which conditional operation gets decided 
Dialogue: 0,0:05:37.48,0:05:39.70,csapp,,0,0,0,,So let's go through what those mean 
Dialogue: 0,0:05:40.82,0:05:45.22,csapp,,0,0,0,,And they're given names, but these names are actually useful to memorize what they mean 
Dialogue: 0,0:05:45.82,0:05:48.26,csapp,,0,0,0,,So cf means the carry flag 
Dialogue: 0,0:05:48.90,0:05:53.20,csapp,,0,0,0,,And that's if you think of adding two numbers,think of them as two unsigned numbers 
Dialogue: 0,0:05:53.68,0:06:00.30,csapp,,0,0,0,,And you do the binary arithmetic and sometimes an extra one pops out of the left hand side right
Dialogue: 0,0:06:00.30,0:06:05.64,csapp,,0,0,0,,That's the carry bit if you the numbers you added sort of were too big 
Dialogue: 0,0:06:06.00,0:06:12.80,csapp,,0,0,0,,To be contained in the 32 or 64-bit or even 16 or 8-bit result 
Dialogue: 0,0:06:13.64,0:06:16.64,csapp,,0,0,0,,And so an extra bit was generated that's called the carry bit
Dialogue: 0,0:06:18.00,0:06:25.30,csapp,,0,0,0,,The zero flag(zf) is what it sounds like it's set if the the value you just computed is zero
Dialogue: 0,0:06:25.80,0:06:28.66,csapp,,0,0,0,,These are set typically by arithmetic instructions by the way
Dialogue: 0,0:06:29.28,0:06:35.44,csapp,,0,0,0,,The sign flag(sf) is said if the value just computed as a one in the most significant bit
Dialogue: 0,0:06:35.52,0:06:36.98,csapp,,0,0,0,,Meaning it's a negative value 
Dialogue: 0,0:06:37.60,0:06:44.04,csapp,,0,0,0,,And the overflow flag(of) is a two's complement version of overflow 
Dialogue: 0,0:06:44.64,0:06:51.88,csapp,,0,0,0,,So in particular if you remember from data lab. how do you know if addition of two values is overflowed.
Dialogue: 0,0:06:52.00,0:06:57.30,csapp,,0,0,0,,If the signs of the operands are the same,but the sign of the result is different than that 
Dialogue: 0,0:06:57.80,0:07:03.66,csapp,,0,0,0,,So either you added two positive numbers and got a negative result.that was a positive overflow.
Dialogue: 0,0:07:03.66,0:07:08.53,csapp,,0,0,0,,Or you added two negative numbers and got a negative result.that's negative overflow.
Dialogue: 0,0:07:08.90,0:07:13.35,csapp,,0,0,0,,You can't overflow if the two arguments are of opposite signs.right?
Dialogue: 0,0:07:14.24,0:07:21.48,csapp,,0,0,0,,So those four flags get,set as a sort of normal activity by many of the instructions 
Dialogue: 0,0:07:22.08,0:07:25.14,csapp,,0,0,0,,Not by our friend the lea instruction 
Dialogue: 0,0:07:25.14,0:07:31.18,csapp,,0,0,0,,Which i mentioned is kind of a quirky instruction that gcc really likes a lot and you'll see it in a lot of places 
Dialogue: 0,0:07:34.20,0:07:39.96,csapp,,0,0,0,,But in general and most of the time those flags get completely ignored,because who cares right
Dialogue: 0,0:07:40.82,0:07:45.08,csapp,,0,0,0,,But they do show up at various points when you're doing conditional operations 
Dialogue: 0,0:07:47.78,0:07:53.54,csapp,,0,0,0,,So there's some special instructions whose only effect is to set condition codes 
Dialogue: 0,0:07:53.54,0:07:57.72,csapp,,0,0,0,,And the one that you'll see is especially it's called compare cmp 
Dialogue: 0,0:07:58.34,0:08:04.72,csapp,,0,0,0,,And by the way the queue at the end of these is all just a reflection of their operating on 64-bit words
Dialogue: 0,0:08:05.64,0:08:07.34,csapp,,0,0,0,,Quadword as i said 
Dialogue: 0,0:08:07.88,0:08:13.12,csapp,,0,0,0,,So the comparison is sort of like a subtraction instruction except that you don't 
Dialogue: 0,0:08:14.66,0:08:16.40,csapp,,0,0,0,,You don't do anything with the result
Dialogue: 0,0:08:17.20,0:08:21.56,csapp,,0,0,0,,Normal subtraction instruction is like x minus equals y 
Dialogue: 0,0:08:22.52,0:08:26.76,csapp,,0,0,0,,It will read two numbers but then it will store the result wherever x is stored 
Dialogue: 0,0:08:28.08,0:08:33.40,csapp,,0,0,0,,But compare just takes these two values does the subtraction and doesn't do anything with the result 
Dialogue: 0,0:08:33.40,0:08:36.88,csapp,,0,0,0,,But it will set it's these four condition flags 
Dialogue: 0,0:08:38.66,0:08:45.96,csapp,,0,0,0,,And just a few things to keep in mind that are often will be sources of confuse
Dialogue: 0,0:08:46.56,0:08:54.36,csapp,,0,0,0,,Remember that the arguments in the way we write them in machine code is the opposite of what you'd expect 
Dialogue: 0,0:08:55.06,0:08:57.38,csapp,,0,0,0,,By the way,somebody asked me last time 
Dialogue: 0,0:08:57.38,0:09:02.84,csapp,,0,0,0,,There's another there's sort of two dialects of assembly code used on x86 machines
Dialogue: 0,0:09:03.46,0:09:07.64,csapp,,0,0,0,,There's the one that's used by intel and microsoft.and we don't use it 
Dialogue: 0,0:09:08.04,0:09:14.24,csapp,,0,0,0,,And then there's the one used that sort of used by linux systems and that's the one we use 
Dialogue: 0,0:09:14.66,0:09:19.66,csapp,,0,0,0,,And they're different and one of the quirks of them is they write their arguments in in different orders
Dialogue: 0,0:09:19.86,0:09:22.58,csapp,,0,0,0,,So it will drive you crazy reading trying to read 
Dialogue: 0,0:09:22.96,0:09:28.64,csapp,,0,0,0,,If you're familiar with one.it's like if you've ever tried to drive a car on the wrong side of the road 
Dialogue: 0,0:09:29.30,0:09:31.60,csapp,,0,0,0,,You often will crash or do bad things 
Dialogue: 0,0:09:33.76,0:09:36.74,csapp,,0,0,0,,Um so that's just an aside that 
Dialogue: 0,0:09:37.02,0:09:42.98,csapp,,0,0,0,,What i find by the way when i'm looking at code and i see a compare instruction 
Dialogue: 0,0:09:42.98,0:09:51.10,csapp,,0,0,0,,I actually write as a comment of compare of the two but i flipped the order 
Dialogue: 0,0:09:51.14,0:09:55.32,csapp,,0,0,0,,So that i'm sure that i sort of keep in my mind what the comparison was of 
Dialogue: 0,0:09:56.38,0:10:00.34,csapp,,0,0,0,,And so these flags get set according to the rules of subtraction 
Dialogue: 0,0:10:00.44,0:10:04.64,csapp,,0,0,0,,And so it turns out that the carry flag and the overflow flag 
Dialogue: 0,0:10:04.64,0:10:07.30,csapp,,0,0,0,,You have to sort of flip your sense of what happened 
Dialogue: 0,0:10:07.30,0:10:11.62,csapp,,0,0,0,,Because it's a subtraction rather than addition but it's the same general idea 
Dialogue: 0,0:10:14.84,0:10:18.92,csapp,,0,0,0,,So that sort of shows you one particular one 
Dialogue: 0,0:10:19.26,0:10:25.82,csapp,,0,0,0,,In another instruction that you'll see whose only purpose in the world is to to set condition flags 
Dialogue: 0,0:10:26.04,0:10:31.26,csapp,,0,0,0,,Condition codes is the test instruction and this is typically used the compare as 
Dialogue: 0,0:10:31.42,0:10:34.80,csapp,,0,0,0,,You'd think it's when you have two values and you want to compare them to each other 
Dialogue: 0,0:10:35.30,0:10:39.44,csapp,,0,0,0,,And the test is if you really just have one value and you want to see what it's like is
Dialogue: 0,0:10:39.64,0:10:43.96,csapp,,0,0,0,,It zero is it negative ,those are the main things you care about 
Dialogue: 0,0:10:44.10,0:10:45.84,csapp,,0,0,0,,In fact that's the only thing you can determine 
Dialogue: 0,0:10:46.40,0:10:53.56,csapp,,0,0,0,,But just because i guess they had up they had sort of a possibility of having two arguments to this 
Dialogue: 0,0:10:53.94,0:10:56.04,csapp,,0,0,0,,So they decided well let's to go ahead and do it 
Dialogue: 0,0:10:56.48,0:11:02.58,csapp,,0,0,0,,How do you have two arguments to a test instruction what's and the two results and then test that value 
Dialogue: 0,0:11:03.16,0:11:04.96,csapp,,0,0,0,,So what you'll typically see is a test 
Dialogue: 0,0:11:06.60,0:11:13.40,csapp,,0,0,0,,Where both arguments are the same so testq %rax comma %rax 
Dialogue: 0,0:11:14.24,0:11:20.34,csapp,,0,0,0,,Where so that you're just any register to itself and one property the end operation is 
Dialogue: 0,0:11:21.12,0:11:27.10,csapp,,0,0,0,,It's what they call item potent adding ending two things the same things together gives you that same thing
Dialogue: 0,0:11:31.62,0:11:33.46,csapp,,0,0,0,,So we can see these 
Dialogue: 0,0:11:33.46,0:11:35.46,csapp,,0,0,0,,And now 
Dialogue: 0,0:11:35.86,0:11:38.26,csapp,,0,0,0,,So i told you that's how the condition codes get set 
Dialogue: 0,0:11:38.26,0:11:41.14,csapp,,0,0,0,,Now how do you actually read them how do you make use of them 
Dialogue: 0,0:11:41.62,0:11:45.32,csapp,,0,0,0,,Well there's two in principle you can actually extract 
Dialogue: 0,0:11:45.36,0:11:51.00,csapp,,0,0,0,,And get the condition code values directly out of this special status register 
Dialogue: 0,0:11:51.00,0:11:53.16,csapp,,0,0,0,,But that's very unusual to do that 
Dialogue: 0,0:11:53.68,0:11:57.26,csapp,,0,0,0,,What's more common is you either try to read it in 
Dialogue: 0,0:11:57.26,0:12:02.72,csapp,,0,0,0,,And set a 1 bit flag based on the result in a read some other register 
Dialogue: 0,0:12:03.06,0:12:05.48,csapp,,0,0,0,,Or you try do a conditional branch 
Dialogue: 0,0:12:06.64,0:12:09.56,csapp,,0,0,0,,So the first example where you try to read it 
Dialogue: 0,0:12:10.08,0:12:13.92,csapp,,0,0,0,,In a way that you can make use of it is done with the set instruction 
Dialogue: 0,0:12:14.84,0:12:18.70,csapp,,0,0,0,,And you'll see there's a whole range of set instructions 
Dialogue: 0,0:12:19.32,0:12:25.98,csapp,,0,0,0,,But their only difference is really just what the condition they're setting based on
Dialogue: 0,0:12:27.28,0:12:30.40,csapp,,0,0,0,,So the what a set instruction does 
Dialogue: 0,0:12:30.50,0:12:36.06,csapp,,0,0,0,,Is it sets a single byte of a single register to either 1 or 0 
Dialogue: 0,0:12:36.90,0:12:43.90,csapp,,0,0,0,,And the basis for whether it's sets it to 1 or 0 is a based on 
Dialogue: 0,0:12:43.90,0:12:47.02,csapp,,0,0,0,,What the condition codes are as essence what's the 
Dialogue: 0,0:12:47.62,0:12:53.02,csapp,,0,0,0,,What happened your most recent instruction before hand was it a arithmetic instruction 
Dialogue: 0,0:12:53.46,0:12:58.44,csapp,,0,0,0,,Or a set instruction or a test instruction or a compare instruction 
Dialogue: 0,0:12:59.12,0:13:05.52,csapp,,0,0,0,,And as you can see there's they're all based on some logical combination of these condition codes
Dialogue: 0,0:13:06.04,0:13:10.04,csapp,,0,0,0,,That correspond to what the names imply 
Dialogue: 0,0:13:10.44,0:13:17.06,csapp,,0,0,0,,So for example the sets instruction is true if the sign flag is true 
Dialogue: 0,0:13:17.36,0:13:19.96,csapp,,0,0,0,,Meaning that the most recent result was negative 
Dialogue: 0,0:13:20.78,0:13:27.46,csapp,,0,0,0,,And there's other ones less than less than or equal to two's complement comparisons 
Dialogue: 0,0:13:27.90,0:13:33.64,csapp,,0,0,0,,And they have to take into consideration did the most recent result cause an overflow or not
Dialogue: 0,0:13:33.64,0:13:36.96,csapp,,0,0,0,,Because that will affect the result of the comparison 
Dialogue: 0,0:13:38.58,0:13:43.38,csapp,,0,0,0,,So that's part of the reason we tortured you with understanding two's complement arithmetic 
Dialogue: 0,0:13:43.38,0:13:47.70,csapp,,0,0,0,,And how you compare results and making you understand the bit-level behavior 
Dialogue: 0,0:13:48.08,0:13:50.48,csapp,,0,0,0,,So that you can understand what these instructions do
Dialogue: 0,0:13:52.40,0:13:55.06,csapp,,0,0,0,,So we're cruel but we have a reason for our cruelty 
Dialogue: 0,0:13:57.50,0:14:02.69,csapp,,0,0,0,,So you say 1 byte how do you deal with 1 byte well here's another thing we didn't tell you yet 
Dialogue: 0,0:14:03.24,0:14:05.76,csapp,,0,0,0,,And we're going to keep telling you more stuff over and over again
Dialogue: 0,0:14:06.14,0:14:09.30,csapp,,0,0,0,,It turns out for every one of these sixteen registers
Dialogue: 0,0:14:09.76,0:14:15.12,csapp,,0,0,0,,You can directly set the lowest order byte of it to either 0 or 1 
Dialogue: 0,0:14:15.66,0:14:20.92,csapp,,0,0,0,,And it won't affect it it turns out it doesn't affect any of the other 7 bytes of that register 
Dialogue: 0,0:14:22.02,0:14:24.14,csapp,,0,0,0,,So and they all have quirky names
Dialogue: 0,0:14:25.18,0:14:28.88,csapp,,0,0,0,,The l means low in there
Dialogue: 0,0:14:32.14,0:14:38.12,csapp,,0,0,0,,So here's an example of using putting all this together to do something that's vaguely useful 
Dialogue: 0,0:14:40.24,0:14:47.90,csapp,,0,0,0,,Suppose i want to function gt, that will take two numbers and compare them and set the result
Dialogue: 0,0:14:48.20,0:14:54.00,csapp,,0,0,0,,Return result value of 1 if x > y  and 0 otherwise
Dialogue: 0,0:14:56.04,0:14:59.76,csapp,,0,0,0,,And so here's the assembly code with some tabbing problems 
Dialogue: 0,0:15:03.26,0:15:13.38,csapp,,0,0,0,,Success nothing bugs me hold on
Dialogue: 0,0:15:13.40,0:15:31.70,csapp,,0,0,0,,I might know try and do this. well no 
Dialogue: 0,0:15:31.72,0:15:33.18,csapp,,0,0,0,,I will fix this later 
Dialogue: 0,0:15:33.20,0:15:35.94,csapp,,0,0,0,,Anyways it's not the end of the world 
Dialogue: 0,0:15:41.52,0:15:49.00,csapp,,0,0,0,,Normally an assembly code one thing you've noticed is that the instructions are indented by a tab space
Dialogue: 0,0:15:49.04,0:15:52.32,csapp,,0,0,0,,And the only  thing that's way over in the left margin labels 
Dialogue: 0,0:15:52.32,0:15:59.92,csapp,,0,0,0,,So this is just sort of this what the the assembler is actually quite tolerant of formatting things 
Dialogue: 0,0:15:59.92,0:16:01.40,csapp,,0,0,0,,But this isn't the way it normally book
Dialogue: 0,0:16:02.48,0:16:07.36,csapp,,0,0,0,,So anyways the point is there's a comparing the one rule that 
Dialogue: 0,0:16:07.36,0:16:10.20,csapp,,0,0,0,,You need to understand about procedures is that 
Dialogue: 0,0:16:10.30,0:16:16.20,csapp,,0,0,0,,The first argument is passed in register %rdi and the second register %rsi 
Dialogue: 0,0:16:16.68,0:16:23.10,csapp,,0,0,0,,And that if i'm going to return a result from a function i do that by storing it and register %rax before i return 
Dialogue: 0,0:16:24.62,0:16:28.36,csapp,,0,0,0,,So the first instruction compares these two 
Dialogue: 0,0:16:28.82,0:16:31.06,csapp,,0,0,0,,And you notice how i flip the order that 
Dialogue: 0,0:16:31.36,0:16:35.66,csapp,,0,0,0,,It sets %rsi which is y, and %rdi which is x
Dialogue: 0,0:16:36.48,0:16:39.14,csapp,,0,0,0,,But when i annotate it i say x to y 
Dialogue: 0,0:16:39.14,0:16:42.16,csapp,,0,0,0,,So that i mentally am thinking in the order 
Dialogue: 0,0:16:42.16,0:16:45.30,csapp,,0,0,0,,That the actual comparison is made rather than the way they're listed 
Dialogue: 0,0:16:45.98,0:16:50.04,csapp,,0,0,0,,So i always do that when i'm looking at code to help me flip those two around 
Dialogue: 0,0:16:52.46,0:16:58.18,csapp,,0,0,0,,And then here's our instruction.so that compare instruction set these four condition code register 
Dialogue: 0,0:16:58.78,0:17:00.40,csapp,,0,0,0,,And now the setg sets. 
Dialogue: 0,0:17:00.80,0:17:06.58,csapp,,0,0,0,,Now set this single byte register,the lowest byte of %rax to 1
Dialogue: 0,0:17:06.62,0:17:11.00,csapp,,0,0,0,,If the result was the comparison was greater 
Dialogue: 0,0:17:12.24,0:17:16.24,csapp,,0,0,0,,So according to this rule
Dialogue: 0,0:17:19.12,0:17:28.52,csapp,,0,0,0,,And the factor that was to set just as 1 byte of this 8 bytes register to either zero or one 
Dialogue: 0,0:17:29.06,0:17:34.86,csapp,,0,0,0,,Now my problem is that these remaining 7 bytes have whatever happened to be there before 
Dialogue: 0,0:17:35.34,0:17:36.88,csapp,,0,0,0,,And i want it to be all zeros 
Dialogue: 0,0:17:37.78,0:17:41.30,csapp,,0,0,0,,So the the way it does it is a bit weird
Dialogue: 0,0:17:43.54,0:17:48.26,csapp,,0,0,0,,There's an instruction called move with zero extension bite too long 
Dialogue: 0,0:17:50.84,0:17:53.02,csapp,,0,0,0,,Now you get to know these better if with time 
Dialogue: 0,0:17:54.10,0:17:54.82,csapp,,0,0,0,,Let me um...
Dialogue: 0,0:17:56.24,0:17:57.36,csapp,,0,0,0,,And what what...
Dialogue: 0,0:17:57.62,0:18:01.16,csapp,,0,0,0,,That means is you can actually copy a byte from any place 
Dialogue: 0,0:18:01.92,0:18:05.72,csapp,,0,0,0,,Like the lord or bite of some other register into a new register 
Dialogue: 0,0:18:06.50,0:18:11.48,csapp,,0,0,0,,And you'll put zeros to the left of it,that's what they mean by zero extension 
Dialogue: 0,0:18:12.54,0:18:17.82,csapp,,0,0,0,,That seems logical but one thing you'll notice is the destination here is %eax 
Dialogue: 0,0:18:18.68,0:18:21.38,csapp,,0,0,0,,Which you'll recall although it doesn't show here 
Dialogue: 0,0:18:21.38,0:18:25.76,csapp,,0,0,0,,That's the lower 32 bits of register %rax
Dialogue: 0,0:18:27.50,0:18:32.62,csapp,,0,0,0,,And then you'd say well that only got me halfway there right 
Dialogue: 0,0:18:32.62,0:18:35.98,csapp,,0,0,0,,How do i make sure the upper 32 bits are set to 0
Dialogue: 0,0:18:36.58,0:18:44.90,csapp,,0,0,0,,Well one of the weird quirks of x86-64 is for any computation 
Dialogue: 0,0:18:45.40,0:18:48.96,csapp,,0,0,0,,Where the result is a 32-bit result 
Dialogue: 0,0:18:49.76,0:18:53.72,csapp,,0,0,0,,It will add zeros to the remaining 32 bits of the register 
Dialogue: 0,0:18:55.04,0:18:59.28,csapp,,0,0,0,,And it's different for example the byte level operations only affect the bytes
Dialogue: 0,0:18:59.52,0:19:07.20,csapp,,0,0,0,,The two byte or operations like what you'd have if the data type were short
Dialogue: 0,0:19:07.66,0:19:09.08,csapp,,0,0,0,,Only affect those two bytes 
Dialogue: 0,0:19:09.72,0:19:13.22,csapp,,0,0,0,,But the four byte instructions set the upper bytes to 0
Dialogue: 0,0:19:13.78,0:19:18.28,csapp,,0,0,0,,And that was some somebody at amd and i don't know who it is 
Dialogue: 0,0:19:18.88,0:19:23.40,csapp,,0,0,0,,Decided this was a good idea and it might be a good idea but it's really confusing
Dialogue: 0,0:19:24.84,0:19:29.16,csapp,,0,0,0,,But that's something you'll have to just sort of remember in the back your mind 
Dialogue: 0,0:19:29.16,0:19:30.70,csapp,,0,0,0,,When you see things like this
Dialogue: 0,0:19:31.80,0:19:37.72,csapp,,0,0,0,,So the effect of this instruction is to take this one bit result,which is the lower bit of register %rax
Dialogue: 0,0:19:38.90,0:19:42.06,csapp,,0,0,0,,Copy it to the same place as it already is
Dialogue: 0,0:19:42.86,0:19:46.60,csapp,,0,0,0,,But then set the remaining 7 bytes to 0,which is what we want 
Dialogue: 0,0:19:48.00,0:19:49.88,csapp,,0,0,0,,So you'll see this pattern quite 
Dialogue: 0,0:19:54.62,0:19:55.72,csapp,,0,0,0,,Often question got it 
Dialogue: 0,0:19:56.62,0:20:00.60,csapp,,0,0,0,,Okay so now that's sort of sometimes i want to do this 
Dialogue: 0,0:20:01.26,0:20:05.36,csapp,,0,0,0,,I just want to get a one bit flag as a result of the comparison 
Dialogue: 0,0:20:06.12,0:20:11.90,csapp,,0,0,0,,But more generally i want to do something with that information and not just set one bit
Dialogue: 0,0:20:13.08,0:20:18.82,csapp,,0,0,0,,So the simplest version is what about a conditional  and if and possibly in else 
Dialogue: 0,0:20:20.54,0:20:24.96,csapp,,0,0,0,,Well that's done by this actually two ways to do it 
Dialogue: 0,0:20:24.99,0:20:28.84,csapp,,0,0,0,,So we'll go through the sort of general purpose traditional way 
Dialogue: 0,0:20:29.22,0:20:34.16,csapp,,0,0,0,,And then we'll show the more specialized newer way and we'll compare those 
Dialogue: 0,0:20:34.30,0:20:38.30,csapp,,0,0,0,,So the traditional way is to use what's known as a jump instruction 
Dialogue: 0,0:20:38.78,0:20:43.26,csapp,,0,0,0,,And the jump instruction normally instructions execute in a particular order
Dialogue: 0,0:20:43.74,0:20:47.62,csapp,,0,0,0,,Just like when you're writing a program and you write a series of statements
Dialogue: 0,0:20:48.18,0:20:50.02,csapp,,0,0,0,,They execute one after the next 
Dialogue: 0,0:20:51.00,0:20:55.12,csapp,,0,0,0,,A jump instruction is a way you can go from wherever you are to someplace else 
Dialogue: 0,0:20:55.66,0:21:02.48,csapp,,0,0,0,,And either skip over some instructions or jump back to some other a previous position or wherever 
Dialogue: 0,0:21:03.44,0:21:08.56,csapp,,0,0,0,,And there's two kinds of jumps ones that are unconditional whether several kinds 
Dialogue: 0,0:21:08.70,0:21:12.56,csapp,,0,0,0,,But an unconditional jump means when i say jump you jump 
Dialogue: 0,0:21:13.58,0:21:17.26,csapp,,0,0,0,,But there's others conditional jumps that will actually only do that jumping 
Dialogue: 0,0:21:17.26,0:21:20.08,csapp,,0,0,0,,If the condition codes are set appropriately 
Dialogue: 0,0:21:20.58,0:21:24.06,csapp,,0,0,0,,And you'll see that the names of these jump instructions are the same as 
Dialogue: 0,0:21:24.06,0:21:26.24,csapp,,0,0,0,,The set instructions with the same conditions 
Dialogue: 0,0:21:26.92,0:21:33.34,csapp,,0,0,0,,So there's a variety of different reasons that the program may be given to either jump or not jump
Dialogue: 0,0:21:38.48,0:21:43.00,csapp,,0,0,0,,So i'm going to use this one example to show you several different versions of it
Dialogue: 0,0:21:43.76,0:21:49.30,csapp,,0,0,0,,And like everything you'll see here these particular programs aren't that useful 
Dialogue: 0,0:21:49.30,0:21:51.54,csapp,,0,0,0,,But they illustrate ideas 
Dialogue: 0,0:21:52.24,0:22:00.84,csapp,,0,0,0,,So imagine i wanted to compute the the difference of two values and then take their absolute value 
Dialogue: 0,0:22:01.78,0:22:04.40,csapp,,0,0,0,,So there's various ways you can imagine doing it 
Dialogue: 0,0:22:04.40,0:22:09.48,csapp,,0,0,0,,By the way i'm going to do it is decide to either subtract y from x or x from y 
Dialogue: 0,0:22:09.48,0:22:12.38,csapp,,0,0,0,,Depending on the relative values of those two 
Dialogue: 0,0:22:12.96,0:22:16.20,csapp,,0,0,0,,And of course the astute observer will notice that 
Dialogue: 0,0:22:17.20,0:22:20.68,csapp,,0,0,0,,This has problems if you have a team in somewhere 
Dialogue: 0,0:22:22.10,0:22:26.22,csapp,,0,0,0,,If the result because there's no absolute value but we're not going to worry about that 
Dialogue: 0,0:22:27.70,0:22:29.86,csapp,,0,0,0,,Um...so...
Dialogue: 0,0:22:30.16,0:22:34.56,csapp,,0,0,0,,In other words i just want to say if x is greater than y, then i want to subtract y from x
Dialogue: 0,0:22:35.34,0:22:38.60,csapp,,0,0,0,,And if x is less than or equal to y, i want to subtract x from y
Dialogue: 0,0:22:39.74,0:22:44.86,csapp,,0,0,0,,And here's the code for it where the blue and the red or color coding the different parts of it 
Dialogue: 0,0:22:45.76,0:22:51.38,csapp,,0,0,0,,So here you see the compare instruction and again i've written them out 
Dialogue: 0,0:22:53.44,0:22:58.04,csapp,,0,0,0,,In the reverse order to help me keep track of what the comparison is 
Dialogue: 0,0:22:58.52,0:23:03.60,csapp,,0,0,0,,And it says i'm going to compare x and y and if x is less than or equal to y
Dialogue: 0,0:23:03.74,0:23:08.68,csapp,,0,0,0,,I want to jump to a location specified by this label l4 
Dialogue: 0,0:23:09.40,0:23:13.68,csapp,,0,0,0,,And so in general in assembly code if you give a name and then a colon 
Dialogue: 0,0:23:13.98,0:23:17.24,csapp,,0,0,0,,What's to the left of that is called a label 
Dialogue: 0,0:23:17.62,0:23:23.50,csapp,,0,0,0,,And it's just a tag that that it's only visible in the assembly code, it's not actually in the object code 
Dialogue: 0,0:23:24.10,0:23:32.16,csapp,,0,0,0,,That will later i'll be used to compute an address for determining that will encode 
Dialogue: 0,0:23:32.16,0:23:34.62,csapp,,0,0,0,,What where this jump will actually land 
Dialogue: 0,0:23:35.44,0:23:36.86,csapp,,0,0,0,,When you're looking at assembly code 
Dialogue: 0,0:23:36.86,0:23:43.90,csapp,,0,0,0,,One of the features it provides is a little bit easier way to understand it then to look at addresses
Dialogue: 0,0:23:44.32,0:23:49.00,csapp,,0,0,0,,And so it just tells you to be looking at that the jump would occur to this position
Dialogue: 0,0:23:50.58,0:23:52.78,csapp,,0,0,0,,And what you'll see here is 
Dialogue: 0,0:23:53.76,0:23:57.02,csapp,,0,0,0,,The in these two branches the blue code versus the red 
Dialogue: 0,0:23:57.02,0:24:01.74,csapp,,0,0,0,,What you're doing is in one case subtracting y from x 
Dialogue: 0,0:24:03.14,0:24:08.16,csapp,,0,0,0,,Here you move x into our ax and you subtract y from it
Dialogue: 0,0:24:08.74,0:24:12.36,csapp,,0,0,0,,And here you do the opposite you're subtracting x from what
Dialogue: 0,0:24:13.74,0:24:17.60,csapp,,0,0,0,,And in this case
Dialogue: 0,0:24:17.78,0:24:23.12,csapp,,0,0,0,,So in the first case  you'll make the jump if x is less than or equal to y
Dialogue: 0,0:24:23.74,0:24:27.52,csapp,,0,0,0,,You'll compact y from x and you'll do a return 
Dialogue: 0,0:24:27.72,0:24:33.50,csapp,,0,0,0,,And you remember that i don't have to do anything special to return a value back from a function 
Dialogue: 0,0:24:33.50,0:24:36.02,csapp,,0,0,0,,All i have to
Dialogue: 0,0:24:34.03,0:24:36.36,csapp,,0,0,0,,And the do is stick it and register %rax 
Dialogue: 0,0:24:36.78,0:24:39.96,csapp,,0,0,0,,And calling function will know that's where to find the return value 
Dialogue: 0,0:24:41.04,0:24:42.66,csapp,,0,0,0,,So here does a rep 
Dialogue: 0,0:24:42.98,0:24:47.50,csapp,,0,0,0,,And here it does the subtraction and it simply does a return directly from that part of it 
Dialogue: 0,0:24:50.84,0:24:53.62,csapp,,0,0,0,,So it's a pretty straightforward piece of code 
Dialogue: 0,0:24:53.62,0:25:00.82,csapp,,0,0,0,,But you can see it's using this jumping to create two different parts of code that get executed 
Dialogue: 0,0:25:01.10,0:25:02.86,csapp,,0,0,0,,Under different conditions
Dialogue: 0,0:25:03.08,0:25:14.06,csapp,,0,0,0,,Question ?what's that ?i'm sorry i didn't hear you
Dialogue: 0,0:25:14.16,0:25:18.79,csapp,,0,0,0,,Oh well there's a couple things one is you want the result to end up in %rax
Dialogue: 0,0:25:19.62,0:25:25.98,csapp,,0,0,0,,Right and remember the subtract instruction structions are just two argument instructions 
Dialogue: 0,0:25:27.14,0:25:35.18,csapp,,0,0,0,,There that you take two values and then you the one this,second argument the destination argument 
Dialogue: 0,0:25:35.66,0:25:38.00,csapp,,0,0,0,,You overwrite what was there with the new result 
Dialogue: 0,0:25:38.88,0:25:41.36,csapp,,0,0,0,,So this is a pretty typical pattern you'll see of 
Dialogue: 0,0:25:41.86,0:25:48.46,csapp,,0,0,0,,You move some value into a register and then you into %rax is very common 
Dialogue: 0,0:25:48.74,0:25:55.52,csapp,,0,0,0,,And then you do some arithmetic operation with that register as a destination to kind of update it 
Dialogue: 0,0:25:57.10,0:26:00.88,csapp,,0,0,0,,If it's like if you're writing and see if all the time you had to write sort of 
Dialogue: 0,0:26:01.30,0:26:03.08,csapp,,0,0,0,,X plus equals something,
Dialogue: 0,0:26:03.08,0:26:08.68,csapp,,0,0,0,,X minus equals and that all your arithmetic had to be expressed in those terms
Dialogue: 0,0:26:13.30,0:26:15.66,csapp,,0,0,0,,Okay so...
Dialogue: 0,0:26:16.10,0:26:21.39,csapp,,0,0,0,,It's fun to look at assembly code for about five minutes and then you get sick of it
Dialogue: 0,0:26:22.04,0:26:25.76,csapp,,0,0,0,,So one thing to sort of present these same ideas 
Dialogue: 0,0:26:25.76,0:26:31.42,csapp,,0,0,0,,But give it in a little bit more abstract form is to write it in c
Dialogue: 0,0:26:31.76,0:26:34.78,csapp,,0,0,0,,But in a form of c that looks a lot like assembly code 
Dialogue: 0,0:26:35.48,0:26:38.18,csapp,,0,0,0,,And in particular one of the features of c 
Dialogue: 0,0:26:38.18,0:26:44.18,csapp,,0,0,0,,That is not generally advertised is there's a statement called go-to 
Dialogue: 0,0:26:45.36,0:26:47.44,csapp,,0,0,0,,And you can put labels in your code
Dialogue: 0,0:26:52.26,0:26:55.16,csapp,,0,0,0,,And you can tell the program 
Dialogue: 0,0:26:55.16,0:26:59.02,csapp,,0,0,0,,That if something happens then you want to jump to that part of the program 
Dialogue: 0,0:26:59.88,0:27:02.10,csapp,,0,0,0,,So it looks a lot like that assembly code right 
Dialogue: 0,0:27:02.26,0:27:07.02,csapp,,0,0,0,,That you saw jump jle instead of what this says 
Dialogue: 0,0:27:07.50,0:27:10.64,csapp,,0,0,0,,It's like i'm doing a test 
Dialogue: 0,0:27:10.92,0:27:16.42,csapp,,0,0,0,,And then if the test is which in this case i call it end test because it's the opposite of the test 
Dialogue: 0,0:27:17.00,0:27:18.42,csapp,,0,0,0,,That's in the original program 
Dialogue: 0,0:27:19.34,0:27:24.84,csapp,,0,0,0,,And if that end test condition holds i want to jump to another part of the program i'm calling else
Dialogue: 0,0:27:25.98,0:27:32.14,csapp,,0,0,0,,And you notice i uppercase that because it's not the actual else of a if-then-else 
Dialogue: 0,0:27:33.28,0:27:35.92,csapp,,0,0,0,,And same way if this one is well...
Dialogue: 0,0:27:38.12,0:27:42.24,csapp,,0,0,0,,Actually to be most accurate i should have simply said return result from this point
Dialogue: 0,0:27:43.80,0:27:45.64,csapp,,0,0,0,,This codes a little bit out a day 
Dialogue: 0,0:27:46.92,0:27:48.62,csapp,,0,0,0,,So i should have said return result 
Dialogue: 0,0:27:49.06,0:27:53.78,csapp,,0,0,0,,But another version would be to have done a goto down to here and return the result from there 
Dialogue: 0,0:27:54.40,0:27:56.82,csapp,,0,0,0,,And you'll see different compilers generate in different forms 
Dialogue: 0,0:27:58.66,0:28:02.30,csapp,,0,0,0,,So i'm going to typically use this way of presenting code
Dialogue: 0,0:28:02.58,0:28:08.14,csapp,,0,0,0,,Just so that you can look at and understand what these control structures look like 
Dialogue: 0,0:28:08.50,0:28:13.96,csapp,,0,0,0,,Without having to sort of scrutinize the low-level assembly code instructions
Dialogue: 0,0:28:17.14,0:28:18.48,csapp,,0,0,0,,So we consider take this...
Dialogue: 0,0:28:18.60,0:28:19.15,csapp,,0,0,0,,Questions
Dialogue: 0,0:28:19.34,0:28:26.74,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:28:26.74,0:28:30.60,csapp,,0,0,0,,Yeah i think there's a homework or a practice problem of exactly that sort
Dialogue: 0,0:28:30.84,0:28:33.46,csapp,,0,0,0,,So in general you could do it neither way and
Dialogue: 0,0:28:33.60,0:28:35.90,csapp,,0,0,0,,Why the compiler picks one versus the other is 
Dialogue: 0,0:28:36.34,0:28:38.16,csapp,,0,0,0,,I think it's a completely arbitrary decision 
Dialogue: 0,0:28:39.04,0:28:41.66,csapp,,0,0,0,,But consistently i found gcc does it this way 
Dialogue: 0,0:28:45.62,0:28:52.40,csapp,,0,0,0,,Okay so let's sort of talking sort of imagine you're writing a compiler 
Dialogue: 0,0:28:52.40,0:28:55.90,csapp,,0,0,0,,How would you take this special case i just showed 
Dialogue: 0,0:28:56.12,0:29:02.14,csapp,,0,0,0,,And generalize it into a rule for compiling if-then-else expressions 
Dialogue: 0,0:29:02.70,0:29:07.64,csapp,,0,0,0,,And i'm going to use the version of in see the question mark : version 
Dialogue: 0,0:29:07.64,0:29:14.30,csapp,,0,0,0,,Where you kind of encapsulate that whole conditional is a single expression rather than the statement 
Dialogue: 0,0:29:14.30,0:29:18.22,csapp,,0,0,0,,But you can understand that these rules would be the same in either case 
Dialogue: 0,0:29:18.98,0:29:23.00,csapp,,0,0,0,,So imagine in general you had a c code 
Dialogue: 0,0:29:23.00,0:29:29.14,csapp,,0,0,0,,Where there's a test controlling whether to return the result of one expression or another 
Dialogue: 0,0:29:30.32,0:29:35.96,csapp,,0,0,0,,And this is what my abs diff code would look like if i wrote it in that form 
Dialogue: 0,0:29:37.76,0:29:39.78,csapp,,0,0,0,,And so in general what we can say is 
Dialogue: 0,0:29:41.18,0:29:46.54,csapp,,0,0,0,,What what we'll do is we'll compete well take the test and tit and invert it 
Dialogue: 0,0:29:47.42,0:29:52.64,csapp,,0,0,0,,And say if that test is not true then we will ...
Dialogue: 0,0:29:56.14,0:30:01.92,csapp,,0,0,0,,So if n test is true then we will jump to some part of the code 
Dialogue: 0,0:30:01.92,0:30:05.20,csapp,,0,0,0,,Where we've compiled the code for the eltz expression 
Dialogue: 0,0:30:06.02,0:30:11.64,csapp,,0,0,0,,And if it that test fails here so that the original test condition holds 
Dialogue: 0,0:30:12.38,0:30:18.78,csapp,,0,0,0,,Then we'll stick in whatever code it takes to to compute the venn expression 
Dialogue: 0,0:30:19.34,0:30:24.12,csapp,,0,0,0,,And then we'll merge back together in the case you saw where it's just a single little function 
Dialogue: 0,0:30:24.46,0:30:27.24,csapp,,0,0,0,,We can just call a rep here and get out of the thing 
Dialogue: 0,0:30:27.66,0:30:32.18,csapp,,0,0,0,,But if this is one line of code then there's a whole bunch of lines after that 
Dialogue: 0,0:30:32.66,0:30:36.04,csapp,,0,0,0,,Typically you want to merge back together again and continue from there 
Dialogue: 0,0:30:36.38,0:30:42.08,csapp,,0,0,0,,And so that's what this show is all i'll finish by going to whatever comes afterwards 
Dialogue: 0,0:30:43.46,0:30:48.78,csapp,,0,0,0,,So this is a way i like to you know,although we're not writing compilers in this course
Dialogue: 0,0:30:48.78,0:30:52.48,csapp,,0,0,0,,I think it helps to to think in terms of general rules 
Dialogue: 0,0:30:52.98,0:30:57.00,csapp,,0,0,0,,Of how a compiler would translate c code into assembly code
Dialogue: 0,0:30:57.50,0:31:02.46,csapp,,0,0,0,,So that when you see that assembly code you'll recognize these patterns  and know what they mean 
Dialogue: 0,0:31:02.58,0:31:08.86,csapp,,0,0,0,,Question....goes to the else clause doesn't like fall through to the john.yes yes 
Dialogue: 0,0:31:09.88,0:31:15.24,csapp,,0,0,0,,So just as we saw yes in general what like here 
Dialogue: 0,0:31:15.60,0:31:19.42,csapp,,0,0,0,,It would fall through to the done good question
Dialogue: 0,0:31:23.44,0:31:27.96,csapp,,0,0,0,,Okay so that's one version of a conditional and that's the most general way 
Dialogue: 0,0:31:27.96,0:31:30.08,csapp,,0,0,0,,And the way it used to always be done
Dialogue: 0,0:31:30.92,0:31:35.24,csapp,,0,0,0,,But there's another approach that you'll see fairly common in code 
Dialogue: 0,0:31:35.38,0:31:38.90,csapp,,0,0,0,,It's sort of an optimization called conditional move 
Dialogue: 0,0:31:40.06,0:31:45.50,csapp,,0,0,0,,And it's bit non-intuitive from a software developer's perspective why you'd ever want to do this 
Dialogue: 0,0:31:46.04,0:31:51.40,csapp,,0,0,0,,The basic idea is i'm going to compute both the then and the else the values they'd produce 
Dialogue: 0,0:31:52.12,0:31:54.62,csapp,,0,0,0,,And only after that i choose which one i use 
Dialogue: 0,0:31:55.62,0:31:59.94,csapp,,0,0,0,,So it seems wasteful but it actually turns out to be more efficient 
Dialogue: 0,0:32:00.50,0:32:03.06,csapp,,0,0,0,,If there are fairly simple computations 
Dialogue: 0,0:32:03.60,0:32:08.80,csapp,,0,0,0,,And the reason of that is and we'll see a little bit more when we talk about performance optimization 
Dialogue: 0,0:32:09.44,0:32:15.32,csapp,,0,0,0,,A modern processor is a little like an oil tanker sailing in the sea 
Dialogue: 0,0:32:15.62,0:32:19.26,csapp,,0,0,0,,Meaning that it plows along in a certain direction 
Dialogue: 0,0:32:19.62,0:32:23.40,csapp,,0,0,0,,And it really is hard to get it to stop or to turn 
Dialogue: 0,0:32:24.64,0:32:27.64,csapp,,0,0,0,,So that's you say what are you talking about but
Dialogue: 0,0:32:28.46,0:32:34.70,csapp,,0,0,0,,Think of an instruction sequences you know the ocean of code  that you're cruising through 
Dialogue: 0,0:32:35.14,0:32:39.20,csapp,,0,0,0,,And these things can just fly through a straight sequence of code 
Dialogue: 0,0:32:39.70,0:32:43.16,csapp,,0,0,0,,Because they are they do what they call pipelining 
Dialogue: 0,0:32:43.16,0:32:47.48,csapp,,0,0,0,,Meaning they start bringing in parts of one instruction before they're done with the next 
Dialogue: 0,0:32:47.72,0:32:51.72,csapp,,0,0,0,,And actually go up to depths of 20 or more instructions deep of 
Dialogue: 0,0:32:52.46,0:32:57.32,csapp,,0,0,0,,How far had they're working sort of fetching forward and future instructions 
Dialogue: 0,0:32:57.70,0:32:59.94,csapp,,0,0,0,,While finishing up the ones that still remain 
Dialogue: 0,0:33:00.32,0:33:03.36,csapp,,0,0,0,,So that's my ocean line or my tanker analogy 
Dialogue: 0,0:33:04.32,0:33:08.14,csapp,,0,0,0,,But all of a sudden you come and then what happens when they hit a branch 
Dialogue: 0,0:33:09.24,0:33:12.00,csapp,,0,0,0,,They'll try to guess it's called branch prediction
Dialogue: 0,0:33:12.46,0:33:15.68,csapp,,0,0,0,,And guess where is this kind of branch going to go 
Dialogue: 0,0:33:15.74,0:33:19.88,csapp,,0,0,0,,Where it you know well the conditional branch will be taken or is it going to fall through 
Dialogue: 0,0:33:20.48,0:33:24.94,csapp,,0,0,0,,And they're pretty good at that they're good at it 98% of the time 
Dialogue: 0,0:33:25.80,0:33:32.68,csapp,,0,0,0,,So they can even anticipate suta curves in the road  my analogy is breaking down 
Dialogue: 0,0:33:34.22,0:33:39.84,csapp,,0,0,0,,And start going in that direction and as long as they get it right it's very efficient
Dialogue: 0,0:33:40.46,0:33:44.64,csapp,,0,0,0,,But if they get it wrong it's as if you have to stop the thing 
Dialogue: 0,0:33:44.94,0:33:48.52,csapp,,0,0,0,,Back it up turn the other way start again 
Dialogue: 0,0:33:48.80,0:33:54.52,csapp,,0,0,0,,And that can take 40 instructions 40 clock cycles say to do in in bad situations 
Dialogue: 0,0:33:54.64,0:33:59.26,csapp,,0,0,0,,So and this is pretty common if you think of like an absolute value 
Dialogue: 0,0:33:59.78,0:34:04.90,csapp,,0,0,0,,Can you predict whether a value is going to be positive or negative? it not usually 
Dialogue: 0,0:34:05.50,0:34:09.36,csapp,,0,0,0,,So about half the time whatever you guess you're going to guess wrong
Dialogue: 0,0:34:10.06,0:34:13.30,csapp,,0,0,0,,So these conditional move instructions it turns out 
Dialogue: 0,0:34:13.30,0:34:17.64,csapp,,0,0,0,,It's much easier to just plow through compute both 
Dialogue: 0,0:34:17.64,0:34:23.04,csapp,,0,0,0,,And then at the last minute all you have to do is move a value into a register or not 
Dialogue: 0,0:34:23.04,0:34:27.24,csapp,,0,0,0,,And that doesn't require stopping the whole processor and making this turn 
Dialogue: 0,0:34:28.22,0:34:30.60,csapp,,0,0,0,,So that's my long explanation for 
Dialogue: 0,0:34:31.26,0:34:37.14,csapp,,0,0,0,,And if you don't want to understand that i'll just say well just trust me. it's a good idea sometimes .
Dialogue: 0,0:34:40.60,0:34:47.72,csapp,,0,0,0,,So the the general pattern then if i use the same idea is i want to compute both results 
Dialogue: 0,0:34:47.72,0:34:52.92,csapp,,0,0,0,,And i'll call the result and this is an eval this is eval the eltz value 
Dialogue: 0,0:34:53.66,0:34:55.18,csapp,,0,0,0,,I'll compute both of them
Dialogue: 0,0:34:55.66,0:35:01.16,csapp,,0,0,0,,I'll do my test and then this red thing imagine that's all done with a single instruction 
Dialogue: 0,0:35:01.16,0:35:05.82,csapp,,0,0,0,,That says i'll copy the value of eval to result 
Dialogue: 0,0:35:06.40,0:35:10.60,csapp,,0,0,0,,But only if my condition holds so that's why it's called a conditional move 
Dialogue: 0,0:35:12.82,0:35:14.86,csapp,,0,0,0,,Then we'll see this is the code 
Dialogue: 0,0:35:15.02,0:35:19.16,csapp,,0,0,0,,By the way you saw my original version starting to have to jump back 
Dialogue: 0,0:35:19.84,0:35:26.92,csapp,,0,0,0,,I had to explicitly tell the gcc don't put use conditional moves
Dialogue: 0,0:35:27.36,0:35:29.93,csapp,,0,0,0,,Because it really wants to a very badly
Dialogue: 0,0:35:30.28,0:35:34.26,csapp,,0,0,0,,And so you have to force it not to and i did that here
Dialogue: 0,0:35:37.66,0:35:41.72,csapp,,0,0,0,,So here's the actual code then and again you'll see the the color coding 
Dialogue: 0,0:35:42.40,0:35:45.44,csapp,,0,0,0,,That it's doing both subtractions 
Dialogue: 0,0:35:45.44,0:35:47.88,csapp,,0,0,0,,It's it's actually doing the move and subtract
Dialogue: 0,0:35:48.54,0:35:54.16,csapp,,0,0,0,,Move and subtract so it's doing both the branches you saw before the then and the else branch 
Dialogue: 0,0:35:55.26,0:36:00.18,csapp,,0,0,0,,It's doing a comparison and then here is the conditional move instruction 
Dialogue: 0,0:36:00.86,0:36:08.88,csapp,,0,0,0,,Cmove in this case the l here is not a word size it's the less than or equal to  a direction 
Dialogue: 0,0:36:09.38,0:36:15.18,csapp,,0,0,0,,So in the case the that i need the red value basically 
Dialogue: 0,0:36:15.78,0:36:19.18,csapp,,0,0,0,,You saw the the red value is stored in register %rdx 
Dialogue: 0,0:36:20.26,0:36:22.98,csapp,,0,0,0,,In that case i will copy it into the result register 
Dialogue: 0,0:36:24.56,0:36:31.22,csapp,,0,0,0,,So again it's like this idea of just go ahead and do everything and then pick at the last end 
Dialogue: 0,0:36:31.60,0:36:39.40,csapp,,0,0,0,,And the point is that this one instruction it looks just as far as for this processor execution 
Dialogue: 0,0:36:39.40,0:36:42.98,csapp,,0,0,0,,That's sort of like a a move instruction that it's fairly straightforward to do
Dialogue: 0,0:36:47.90,0:36:51.94,csapp,,0,0,0,,Okay so why doesn't it do that all the time well there's a couple reasons 
Dialogue: 0,0:36:52.36,0:36:57.68,csapp,,0,0,0,,One is that might be a really really bad idea to do both computations 
Dialogue: 0,0:36:57.68,0:37:01.50,csapp,,0,0,0,,If you have to like crack a password in one and 
Dialogue: 0,0:37:01.98,0:37:06.26,csapp,,0,0,0,,You know find the nth prime number and another you probably don't want to do both of those 
Dialogue: 0,0:37:06.98,0:37:11.18,csapp,,0,0,0,,So in general in that case
Dialogue: 0,0:37:11.72,0:37:14.86,csapp,,0,0,0,,And so the and you'll notice gcc will only do this 
Dialogue: 0,0:37:15.24,0:37:19.96,csapp,,0,0,0,,If both branches are fairly straightforward computations that they're trying to do 
Dialogue: 0,0:37:20.90,0:37:23.32,csapp,,0,0,0,,And there's some times when you just plain can't do it 
Dialogue: 0,0:37:23.92,0:37:27.34,csapp,,0,0,0,,So for example if you're using a conditional to guard 
Dialogue: 0,0:37:27.88,0:37:33.58,csapp,,0,0,0,,Whether a pointer can be dereferenced or not because it's a null pointer potentially a null pointer
Dialogue: 0,0:37:34.00,0:37:37.56,csapp,,0,0,0,,Then you really don't want to try that null pointer dereference 
Dialogue: 0,0:37:39.96,0:37:44.22,csapp,,0,0,0,,Just for the for as a way to save some time
Dialogue: 0,0:37:44.94,0:37:48.12,csapp,,0,0,0,,And similarly if you could have a side-effect 
Dialogue: 0,0:37:48.20,0:37:54.50,csapp,,0,0,0,,If the result of executing either branch could be to change some other part of the program state 
Dialogue: 0,0:37:55.10,0:37:56.85,csapp,,0,0,0,,Then you don't really want to do that either 
Dialogue: 0,0:37:57.42,0:38:03.58,csapp,,0,0,0,,And so the conditional move only gets used then in this somewhat special case 
Dialogue: 0,0:38:03.58,0:38:08.74,csapp,,0,0,0,,That you have two computations relatively easy to do safe to do no side-effects
Dialogue: 0,0:38:09.74,0:38:13.26,csapp,,0,0,0,,But that happens just often enough that this is actually a worthwhile thing
Dialogue: 0,0:38:16.70,0:38:19.48,csapp,,0,0,0,,Okay so that gets us conditionals 
Dialogue: 0,0:38:20.04,0:38:26.34,csapp,,0,0,0,,And now let's look at loops that's a sort of next step up in control structures 
Dialogue: 0,0:38:28.14,0:38:30.90,csapp,,0,0,0,,And c actually has three different kinds of loops 
Dialogue: 0,0:38:31.52,0:38:36.52,csapp,,0,0,0,,It has a a while loop which you're familiar with and a for loop which you're familiar with 
Dialogue: 0,0:38:36.84,0:38:41.72,csapp,,0,0,0,,And it has a third one which in my whole life of writing and i've written a lot of c code in my life 
Dialogue: 0,0:38:42.42,0:38:44.70,csapp,,0,0,0,,I've used this like about 6 times
Dialogue: 0,0:38:45.64,0:38:49.28,csapp,,0,0,0,,So but it turns out it's the simplest one to implement so we'll go ahead and do it 
Dialogue: 0,0:38:49.86,0:38:52.34,csapp,,0,0,0,,So that the it's called the do-while loop 
Dialogue: 0,0:38:53.00,0:38:59.26,csapp,,0,0,0,,And so the keyword is do and then there's some stuff you do that's the body of the do 
Dialogue: 0,0:38:59.90,0:39:05.41,csapp,,0,0,0,,And then there's a test at the end that tells you whether to keep repeating this loop 
Dialogue: 0,0:39:05.88,0:39:10.08,csapp,,0,0,0,,So it sort of flips a normal while loop you you have the conditional test at the front 
Dialogue: 0,0:39:10.46,0:39:11.94,csapp,,0,0,0,,And here you have it at the end
Dialogue: 0,0:39:15.84,0:39:20.52,csapp,,0,0,0,,So it turns out if we think in terms of go-to that's a pretty straightforward thing to replace this 
Dialogue: 0,0:39:22.14,0:39:28.54,csapp,,0,0,0,,With a code that will do a test and if the test holds it will jump back 
Dialogue: 0,0:39:29.00,0:39:33.26,csapp,,0,0,0,,And say ok a reacts acute that part of the program i was just in
Dialogue: 0,0:39:34.08,0:39:43.24,csapp,,0,0,0,,So it sets up a loop where you can think of it's literally a loop of control flow going round and round 
Dialogue: 0,0:39:46.44,0:39:51.48,csapp,,0,0,0,,And by the way this is actually a semi useful function it's called pop count sometimes 
Dialogue: 0,0:39:51.96,0:39:59.16,csapp,,0,0,0,,How many ones are there in a in a word of data  in this case it's 64-bit word
Dialogue: 0,0:39:59.56,0:40:02.38,csapp,,0,0,0,,There's been some generations of data lab 
Dialogue: 0,0:40:02.38,0:40:06.96,csapp,,0,0,0,,Where you were required to write this function using all your favorite operations
Dialogue: 0,0:40:09.68,0:40:14.80,csapp,,0,0,0,,And with a fairly small limit on operations but we're not doing that today 
Dialogue: 0,0:40:19.12,0:40:23.78,csapp,,0,0,0,,So here my point is you see that there's a fairly straightforward 
Dialogue: 0,0:40:24.40,0:40:30.08,csapp,,0,0,0,,Way of taking this particular loop and turning it into just a combination of conditional
Dialogue: 0,0:40:30.46,0:40:33.91,csapp,,0,0,0,,That where you do is you jump back to where you were before 
Dialogue: 0,0:40:34.60,0:40:36.28,csapp,,0,0,0,,And here's the actual code for it 
Dialogue: 0,0:40:37.84,0:40:44.62,csapp,,0,0,0,,I won't go through all of it but you can believe from these annotations that it very closely follows the code here 
Dialogue: 0,0:40:45.18,0:40:48.36,csapp,,0,0,0,,And the main thing to see is this jump if not equal 
Dialogue: 0,0:40:51.18,0:40:54.48,csapp,,0,0,0,,To label l2 and that takes you back to here
Dialogue: 0,0:40:57.16,0:41:03.18,csapp,,0,0,0,,And so the general form of it then is you take a do 
Dialogue: 0,0:41:03.18,0:41:06.34,csapp,,0,0,0,,And then this part of it's called the body of the loop and this is the test  
Dialogue: 0,0:41:06.96,0:41:11.88,csapp,,0,0,0,,And so now you set up some code where you can execute the body perform the test 
Dialogue: 0,0:41:12.30,0:41:14.40,csapp,,0,0,0,,And if the test holds you go back to the loop 
Dialogue: 0,0:41:17.30,0:41:20.58,csapp,,0,0,0,,So a while loop is really just why i could do loop
Dialogue: 0,0:41:21.58,0:41:24.78,csapp,,0,0,0,,A do while loop except that you move the test to the beginning 
Dialogue: 0,0:41:24.80,0:41:30.60,csapp,,0,0,0,,And the only difference therefore is with a do loop you never you don't do the test it 
Dialogue: 0,0:41:30.70,0:41:36.06,csapp,,0,0,0,,The first time through you're guaranteed to do it the first time no matter what
Dialogue: 0,0:41:36.86,0:41:40.72,csapp,,0,0,0,,While a while loop will explicitly test even at the very beginning and 
Dialogue: 0,0:41:41.16,0:41:44.02,csapp,,0,0,0,,And skip over the loop if the condition doesn't hold 
Dialogue: 0,0:41:45.50,0:41:50.72,csapp,,0,0,0,,So there's two ways to generate a code well there's more than two ways to generate code for a while loop 
Dialogue: 0,0:41:51.14,0:41:54.20,csapp,,0,0,0,,But you'll find gcc actually uses two different ways 
Dialogue: 0,0:41:54.80,0:42:01.12,csapp,,0,0,0,,A one is what we'll find when we use this optimization setting i talked about last time 
Dialogue: 0,0:42:01.12,0:42:04.16,csapp,,0,0,0,,Called -o which stands for optimized 
Dialogue: 0,0:42:04.72,0:42:09.10,csapp,,0,0,0,,G which means debug of course as you've already know 
Dialogue: 0,0:42:10.44,0:42:14.26,csapp,,0,0,0,,There's some history to what the -g flags means 
Dialogue: 0,0:42:15.24,0:42:21.18,csapp,,0,0,0,,So and as i mentioned last time this turns out to be the perfect level of optimization for this course
Dialogue: 0,0:42:21.80,0:42:24.70,csapp,,0,0,0,,Where you want to be able to look at machine code and understand it 
Dialogue: 0,0:42:25.48,0:42:30.42,csapp,,0,0,0,,And how it relates to the c code because it does some sort of simple optimizations 
Dialogue: 0,0:42:30.44,0:42:33.76,csapp,,0,0,0,,But it doesn't try to rewrite your whole program to make it run better 
Dialogue: 0,0:42:35.20,0:42:39.44,csapp,,0,0,0,,Whereas even with -o1 one which is the next level in the optimization 
Dialogue: 0,0:42:39.78,0:42:42.88,csapp,,0,0,0,,You'll find sometimes it will do some pretty quirky stuff 
Dialogue: 0,0:42:44.82,0:42:49.94,csapp,,0,0,0,,But when you actually as a program developer as a software developer out there 
Dialogue: 0,0:42:50.58,0:42:54.36,csapp,,0,0,0,,Or you talk to companies and you ask what optimization level do you use
Dialogue: 0,0:42:54.78,0:42:59.20,csapp,,0,0,0,,Those probably say -o2 that's sort of the common one 
Dialogue: 0,0:43:00.56,0:43:03.20,csapp,,0,0,0,,So usually there's higher levels optimization 
Dialogue: 0,0:43:03.48,0:43:07.30,csapp,,0,0,0,,And we're purposely backing off from that to make this code easier to understand 
Dialogue: 0,0:43:08.30,0:43:13.50,csapp,,0,0,0,,So anyways with the this default optimization we're using for this course 
Dialogue: 0,0:43:13.98,0:43:18.10,csapp,,0,0,0,,It does a transformation i call the jump to middle translation
Dialogue: 0,0:43:18.48,0:43:22.40,csapp,,0,0,0,,These are by the way my own names you won't find them in any other document
Dialogue: 0,0:43:24.32,0:43:30.82,csapp,,0,0,0,,But what the idea of it is imagine again i have a while loop of this form 
Dialogue: 0,0:43:30.82,0:43:33.68,csapp,,0,0,0,,Where there's a test in the body to execute
Dialogue: 0,0:43:34.26,0:43:40.38,csapp,,0,0,0,,Well what out the problem i have to do compared to before is some i've to execute the test before i start 
Dialogue: 0,0:43:41.13,0:43:42.68,csapp,,0,0,0,,The first iteration of the loop 
Dialogue: 0,0:43:43.08,0:43:49.32,csapp,,0,0,0,,So the way i'll do it here is i'll just jump to the middle of the what was the old loop code
Dialogue: 0,0:43:49.86,0:43:52.00,csapp,,0,0,0,,To the test portion of that loop 
Dialogue: 0,0:43:52.70,0:43:57.74,csapp,,0,0,0,,And then let that test determine whether i actually enter the the loop itself 
Dialogue: 0,0:43:59.72,0:44:09.34,csapp,,0,0,0,,And so this is an example of a go to a code version of my pop count function 
Dialogue: 0,0:44:09.78,0:44:13.10,csapp,,0,0,0,,So i've written the pop count function using a while loop this time 
Dialogue: 0,0:44:14.90,0:44:19.88,csapp,,0,0,0,,It turns out whether you use a do or a while loop you'll get the same result in this particular function 
Dialogue: 0,0:44:21.18,0:44:29.84,csapp,,0,0,0,,And you'll see the way it looks is  it it jumps to the test portion of the code 
Dialogue: 0,0:44:30.38,0:44:35.67,csapp,,0,0,0,,And then if that holds it then actually starts in the first execution of the loop
Dialogue: 0,0:44:36.14,0:44:38.78,csapp,,0,0,0,,And then from there on it looks the same as the do-while loop 
Dialogue: 0,0:44:38.78,0:44:45.02,csapp,,0,0,0,,It just does the what was in the loop does the test jumps back to the beginning
Dialogue: 0,0:44:49.26,0:44:53.72,csapp,,0,0,0,,Oh and then there's a second method which is in some ways more traditional
Dialogue: 0,0:44:54.42,0:45:00.28,csapp,,0,0,0,,And you'll find that if you use optimisation one which is a fairly useful thing to do in practice 
Dialogue: 0,0:45:00.48,0:45:06.90,csapp,,0,0,0,,So just to show you that instead of deciding which one i was going to show you i decided to show you both 
Dialogue: 0,0:45:09.30,0:45:15.64,csapp,,0,0,0,,And the idea of that is to do a essentially to take a while loop and turn it into a do-while loop 
Dialogue: 0,0:45:16.32,0:45:19.18,csapp,,0,0,0,,But introducing a conditional beforehand 
Dialogue: 0,0:45:19.74,0:45:23.18,csapp,,0,0,0,,That would essentially guard your entrance to the loop 
Dialogue: 0,0:45:24.10,0:45:25.96,csapp,,0,0,0,,So you do an initial test 
Dialogue: 0,0:45:26.14,0:45:30.24,csapp,,0,0,0,,And if that's false then you skip over the loop all together
Dialogue: 0,0:45:30.48,0:45:32.78,csapp,,0,0,0,,Otherwise it's performed like a do-while loop
Dialogue: 0,0:45:35.72,0:45:38.74,csapp,,0,0,0,,And so that has a fairly straightforward translation into code
Dialogue: 0,0:45:39.48,0:45:44.54,csapp,,0,0,0,,And that again it looks a little different from before that  it has an initial test 
Dialogue: 0,0:45:45.28,0:45:47.78,csapp,,0,0,0,,But then it looks so i could do while loop 
Dialogue: 0,0:45:51.76,0:45:54.22,csapp,,0,0,0,,So i won't show you the assembly versions of those
Dialogue: 0,0:45:54.30,0:46:03.94,csapp,,0,0,0,,But if you look at it actually the code is all in directories that are linked to your the the class directory 
Dialogue: 0,0:46:04.58,0:46:07.30,csapp,,0,0,0,,The class webpage  so you can actually look at the code
Dialogue: 0,0:46:07.66,0:46:10.96,csapp,,0,0,0,,And you'll see that it follows exactly the way i'm describing it 
Dialogue: 0,0:46:13.12,0:46:16.30,csapp,,0,0,0,,And then a third kind of loop is the for loop 
Dialogue: 0,0:46:16.82,0:46:24.58,csapp,,0,0,0,,Which in c is actually a very powerful very general type of thing and so it's very commonly used
Dialogue: 0,0:46:25.12,0:46:32.68,csapp,,0,0,0,,But you can see that the for loop has four components to it has an initialization as a test
Dialogue: 0,0:46:33.52,0:46:38.36,csapp,,0,0,0,,Has a rule for doing an update in case as a way to continue the loop
Dialogue: 0,0:46:38.70,0:46:40.30,csapp,,0,0,0,,And then it has the body of the loop
Dialogue: 0,0:46:40.90,0:46:43.62,csapp,,0,0,0,,And so here's a version of my pop count function 
Dialogue: 0,0:46:45.18,0:46:52.10,csapp,,0,0,0,,Where i'm just going through all the bits in the word extracting them out 
Dialogue: 0,0:46:52.50,0:46:56.13,csapp,,0,0,0,,And adding them accumulating them to be the result
Dialogue: 0,0:46:57.08,0:47:02.71,csapp,,0,0,0,,So ripping apart this for you'll see that these four blocks of
Dialogue: 0,0:47:03.08,0:47:07.56,csapp,,0,0,0,,Of the loop correspond to the initialization is to set equal to zero
Dialogue: 0,0:47:08.46,0:47:11.16,csapp,,0,0,0,,The test is to compare i to the word size 
Dialogue: 0,0:47:12.54,0:47:16.46,csapp,,0,0,0,,Which i've set here to be eight times
Dialogue: 0,0:47:16.56,0:47:22.08,csapp,,0,0,0,,So however many bytes there are in an int multiply that by 8 to get the word size 
Dialogue: 0,0:47:23.30,0:47:25.20,csapp,,0,0,0,,And then the update is i++
Dialogue: 0,0:47:25.70,0:47:28.66,csapp,,0,0,0,,And then the body is this stuff that's within the brackets here 
Dialogue: 0,0:47:30.78,0:47:34.24,csapp,,0,0,0,,So i can think of that in general one 
Dialogue: 0,0:47:34.84,0:47:41.82,csapp,,0,0,0,,One general way to think about a for loop in c is by this rule 
Dialogue: 0,0:47:43.34,0:47:45.28,csapp,,0,0,0,,That will turn a for loop into a while loop 
Dialogue: 0,0:47:47.22,0:47:52.28,csapp,,0,0,0,,And so what it says is i first do the initialization 
Dialogue: 0,0:47:52.90,0:47:57.72,csapp,,0,0,0,,And then i do a loop where i i guard it with this test 
Dialogue: 0,0:47:59.30,0:48:02.76,csapp,,0,0,0,,And then what i keep doing is executing the body 
Dialogue: 0,0:48:03.50,0:48:07.70,csapp,,0,0,0,,And then performing whatever update there is  and then continuing with the test 
Dialogue: 0,0:48:08.66,0:48:14.90,csapp,,0,0,0,,So that's sort of the semantics the the definition of the behavior of a for loop and c 
Dialogue: 0,0:48:17.66,0:48:21.86,csapp,,0,0,0,,So i can take my different pieces of my for loop 
Dialogue: 0,0:48:22.66,0:48:29.46,csapp,,0,0,0,,And say well okay i'll take that rule and use it to pack them in  to form a while loop 
Dialogue: 0,0:48:30.10,0:48:33.58,csapp,,0,0,0,,And of course you know that you can sort of go between those two
Dialogue: 0,0:48:33.90,0:48:39.92,csapp,,0,0,0,,It's somewhat a matter of taste whether a given loop should be written using a for loop or a while loop 
Dialogue: 0,0:48:46.00,0:48:54.20,csapp,,0,0,0,,So one reason why it's actually useful to do this  -o1 one optimization i talked to you about is 
Dialogue: 0,0:48:54.52,0:48:58.90,csapp,,0,0,0,,It's fairly common for the initial tests to be trivially trivially true 
Dialogue: 0,0:48:59.74,0:49:02.52,csapp,,0,0,0,,So for example in here if i=0
Dialogue: 0,0:49:02.96,0:49:07.52,csapp,,0,0,0,,And i'm comparing it to the word size which would typically be 32 
Dialogue: 0,0:49:08.86,0:49:11.54,csapp,,0,0,0,,Well that test is true that's a certain thing 
Dialogue: 0,0:49:11.92,0:49:15.14,csapp,,0,0,0,,And so what you'll see is that the compiler can figure that out 
Dialogue: 0,0:49:15.86,0:49:22.12,csapp,,0,0,0,,And just throw away this guarding code  that would have to be there otherwise 
Dialogue: 0,0:49:22.84,0:49:28.36,csapp,,0,0,0,,So that i believe is the main reason why this is the transformation 
Dialogue: 0,0:49:28.36,0:49:33.18,csapp,,0,0,0,,That gets used with the o1 optimization level is that often times
Dialogue: 0,0:49:33.80,0:49:35.54,csapp,,0,0,0,,It doesn't need this initial test
Dialogue: 0,0:49:40.64,0:49:48.94,csapp,,0,0,0,,Ok so now i'm going to finish up with what's in to me at least the loop stuff is sort of what you'd expect
Dialogue: 0,0:49:50.80,0:49:54.34,csapp,,0,0,0,,If you were to have to you know turn 
Dialogue: 0,0:49:54.98,0:50:01.10,csapp,,0,0,0,,A c code into something very low level where all you could do is jumps and test 
Dialogue: 0,0:50:01.74,0:50:03.64,csapp,,0,0,0,,Well maybe that's obvious but maybe not 
Dialogue: 0,0:50:04.26,0:50:07.32,csapp,,0,0,0,,The switch statement on the other hand is a totally different beast 
Dialogue: 0,0:50:07.98,0:50:12.92,csapp,,0,0,0,,And i want to show you that because there's no counterpart in normal c code  of 
Dialogue: 0,0:50:13.32,0:50:14.76,csapp,,0,0,0,,How you'd even think about it 
Dialogue: 0,0:50:16.24,0:50:21.10,csapp,,0,0,0,,And it's fairly a little bit harder to do cipher 
Dialogue: 0,0:50:21.58,0:50:23.42,csapp,,0,0,0,,And you're going to have to do it in the bomb lab
Dialogue: 0,0:50:25.22,0:50:28.90,csapp,,0,0,0,,So here's an example of a switch statement that is of 
Dialogue: 0,0:50:29.64,0:50:33.98,csapp,,0,0,0,,Nothing about this is useful except to demonstrate some principles of 
Dialogue: 0,0:50:34.00,0:50:37.48,csapp,,0,0,0,,How to turn a switch statement into a assembly code 
Dialogue: 0,0:50:38.32,0:50:45.88,csapp,,0,0,0,,So the point of it is as you know and c you switch on a particular value some type of integer value
Dialogue: 0,0:50:46.64,0:50:49.12,csapp,,0,0,0,,And then it will match different cases 
Dialogue: 0,0:50:49.66,0:50:53.74,csapp,,0,0,0,,Where each of these cases has to be some constant numeric value 
Dialogue: 0,0:50:54.58,0:50:57.44,csapp,,0,0,0,,Constant integer value 
Dialogue: 0,0:50:58.94,0:51:01.74,csapp,,0,0,0,,And one of the weirdest features of c is 
Dialogue: 0,0:51:02.28,0:51:06.38,csapp,,0,0,0,,If you don't at the end of the case if you don't explicitly say break 
Dialogue: 0,0:51:07.30,0:51:09.52,csapp,,0,0,0,,It'll do what's known as falling through 
Dialogue: 0,0:51:10.12,0:51:15.30,csapp,,0,0,0,,So in this example here it will divide y by z
Dialogue: 0,0:51:16.02,0:51:21.47,csapp,,0,0,0,,And then it will just glide right into this statement that adds z to w
Dialogue: 0,0:51:22.10,0:51:28.70,csapp,,0,0,0,,This is by the way like one of the worst design decisions in the history of programming languages 
Dialogue: 0,0:51:28.70,0:51:31.42,csapp,,0,0,0,,And it's been the cause of more and more 
Dialogue: 0,0:51:31.98,0:51:37.58,csapp,,0,0,0,,You know heartbreak and bugs that nobody could understand than any other single part of the language 
Dialogue: 0,0:51:38.50,0:51:43.88,csapp,,0,0,0,,And for some bizarre reason they've kept it alive even into java and all these other languages 
Dialogue: 0,0:51:44.80,0:51:49.12,csapp,,0,0,0,,That fixed a lot of the worst parts you know the most dangerous parts of c
Dialogue: 0,0:51:49.12,0:51:50.78,csapp,,0,0,0,,But somehow they kept this future  
Dialogue: 0,0:51:51.52,0:51:56.62,csapp,,0,0,0,,And so just as a advice as a programmer if you ever ever use this 
Dialogue: 0,0:51:57.32,0:52:01.08,csapp,,0,0,0,,Where you purposely want it to go from one case to another 
Dialogue: 0,0:52:01.50,0:52:04.28,csapp,,0,0,0,,You should have to put a comment in there to say 
Dialogue: 0,0:52:05.04,0:52:07.50,csapp,,0,0,0,,Trust me i really did want it to fall through
Dialogue: 0,0:52:07.50,0:52:10.98,csapp,,0,0,0,,I know you almost never want to do this but i do here 
Dialogue: 0,0:52:12.50,0:52:15.12,csapp,,0,0,0,,So that's a fairly common convention 
Dialogue: 0,0:52:15.40,0:52:20.68,csapp,,0,0,0,,I don't know how many times i've had bugs that were because i forgot to put breaks 
Dialogue: 0,0:52:22.20,0:52:25.22,csapp,,0,0,0,,Anyways enough of my editorializing 
Dialogue: 0,0:52:26.48,0:52:29.48,csapp,,0,0,0,,The other feature you see and see is 
Dialogue: 0,0:52:29.94,0:52:33.26,csapp,,0,0,0,,You can sort of a bunch up multiple cases 
Dialogue: 0,0:52:33.58,0:52:36.84,csapp,,0,0,0,,If you think of it that's just a special case of the fall through 
Dialogue: 0,0:52:37.18,0:52:40.89,csapp,,0,0,0,,Write the case five has nothing to do but to fall through to six
Dialogue: 0,0:52:41.12,0:52:44.92,csapp,,0,0,0,,But so that's the same general way and there's nothing that's not 
Dialogue: 0,0:52:45.60,0:52:48.08,csapp,,0,0,0,,That's not bad and it doesn't require a comment 
Dialogue: 0,0:52:49.54,0:52:53.48,csapp,,0,0,0,,And the other one is that there's a default so if none of these cases match  either
Dialogue: 0,0:52:54.12,0:52:58.34,csapp,,0,0,0,,Because x was 0 or smaller or x was a really big number 
Dialogue: 0,0:52:58.86,0:53:00.64,csapp,,0,0,0,,Or in this case if x were 4 
Dialogue: 0,0:53:02.12,0:53:03.62,csapp,,0,0,0,,There's no matching case 
Dialogue: 0,0:53:04.30,0:53:08.38,csapp,,0,0,0,,And of course you also know that these cases don't have to be in any particular order either 
Dialogue: 0,0:53:09.72,0:53:12.26,csapp,,0,0,0,,So that's all the sort of features of a case statement 
Dialogue: 0,0:53:13.76,0:53:17.80,csapp,,0,0,0,,Um a switch statements are up 
Dialogue: 0,0:53:18.54,0:53:26.20,csapp,,0,0,0,,So normally if you write this in sort of if you were told thou shalt not use switch statements anymore 
Dialogue: 0,0:53:26.84,0:53:32.50,csapp,,0,0,0,,What you'd probably do is write this big long chain of if else,if else,if else right 
Dialogue: 0,0:53:33.82,0:53:37.65,csapp,,0,0,0,,Uh and you'd expect that to be the machine code but it's not 
Dialogue: 0,0:53:37.84,0:53:41.78,csapp,,0,0,0,,And so let me show you what the machine code does
Dialogue: 0,0:53:42.30,0:53:43.84,csapp,,0,0,0,,It's kind of a long story 
Dialogue: 0,0:53:44.62,0:53:50.08,csapp,,0,0,0,,So think of the general form of it as being some blocks of code 
Dialogue: 0,0:53:51.78,0:53:56.44,csapp,,0,0,0,,The entry points of which are labeled by these case values 
Dialogue: 0,0:53:57.06,0:54:01.22,csapp,,0,0,0,,And then the box you know string together in various different ways and do various things
Dialogue: 0,0:54:02.02,0:54:06.80,csapp,,0,0,0,,What i'm going to do is compile a code for all of those blocks
Dialogue: 0,0:54:07.60,0:54:14.52,csapp,,0,0,0,,And store them away in some part of memory load up memory to contain these code blocks 
Dialogue: 0,0:54:14.90,0:54:16.56,csapp,,0,0,0,,And then i'm going to build a table 
Dialogue: 0,0:54:17.24,0:54:24.60,csapp,,0,0,0,,And each entry of this table describes the starting location of one of these code blocks 
Dialogue: 0,0:54:25.58,0:54:29.86,csapp,,0,0,0,,And i'll put them in order of my case labels if i have 
Dialogue: 0,0:54:30.74,0:54:37.52,csapp,,0,0,0,,You know i want to span a scope from well let's assume zero but typically that's not the case 
Dialogue: 0,0:54:37.96,0:54:40.94,csapp,,0,0,0,,Zero up to n-1 
Dialogue: 0,0:54:41.44,0:54:47.14,csapp,,0,0,0,,I'll have this table will have that many entries of addresses to tell me 
Dialogue: 0,0:54:48.76,0:54:52.00,csapp,,0,0,0,,Where these code blocks are located 
Dialogue: 0,0:54:53.58,0:54:56.62,csapp,,0,0,0,,And then i'm going to use this really cool instruction 
Dialogue: 0,0:54:57.40,0:55:04.36,csapp,,0,0,0,,Which is a sort of like it's as if you it's like a ray indexing 
Dialogue: 0,0:55:04.54,0:55:10.84,csapp,,0,0,0,,So if you think of a ray indexing it means you can grab a value out of the middle of some...
Dialogue: 0,0:55:11.60,0:55:18.48,csapp,,0,0,0,,You know array some set of values without having to step through them one by one 
Dialogue: 0,0:55:19.30,0:55:27.30,csapp,,0,0,0,,And it's the same idea here that i will take my value and use that to figure out directly 
Dialogue: 0,0:55:27.92,0:55:31.16,csapp,,0,0,0,,Where i should jump to a block of code 
Dialogue: 0,0:55:31.62,0:55:34.58,csapp,,0,0,0,,Without having to step through a bunch of other conditions 
Dialogue: 0,0:55:36.06,0:55:40.08,csapp,,0,0,0,,So and you can see the efficiency again from that it's the difference between 
Dialogue: 0,0:55:40.78,0:55:44.90,csapp,,0,0,0,,Sort of in one step knowing exactly where you want to be versus  
Dialogue: 0,0:55:46.28,0:55:51.68,csapp,,0,0,0,,Stepping through you know on average n over two conditions to get to where i want to go
Dialogue: 0,0:55:54.48,0:55:57.06,csapp,,0,0,0,,So let's look at this at the assembly code level 
Dialogue: 0,0:56:00.22,0:56:05.02,csapp,,0,0,0,,And it's a little bit of a long thing because we have to build some machinery around this
Dialogue: 0,0:56:06.96,0:56:10.56,csapp,,0,0,0,,So here's my example i've got three arguments 
Dialogue: 0,0:56:11.00,0:56:19.70,csapp,,0,0,0,,So just remember i told you are %rdi and %rsi for the first two arguments the third argument is in %rdx 
Dialogue: 0,0:56:21.48,0:56:25.70,csapp,,0,0,0,,And here's the beginning of the switch code 
Dialogue: 0,0:56:26.80,0:56:31.00,csapp,,0,0,0,,It's just making a copy of argument z here for some reason
Dialogue: 0,0:56:31.56,0:56:38.74,csapp,,0,0,0,,And then it's looking at comparing x to 6 and y is 6 an important number 
Dialogue: 0,0:56:40.62,0:56:47.70,csapp,,0,0,0,,Because you see 6 was the largest value of any of my cases
Dialogue: 0,0:56:48.16,0:56:53.18,csapp,,0,0,0,,And now it's using a jump instruction to go to .l8
Dialogue: 0,0:56:53.18,0:56:57.48,csapp,,0,0,0,,What we'll find is that tells you what the default behavior should be
Dialogue: 0,0:56:58.42,0:57:02.82,csapp,,0,0,0,,So it's sort of flushing away the default cases 
Dialogue: 0,0:57:02.82,0:57:06.82,csapp,,0,0,0,,The cases that are either x is too small or x is too large
Dialogue: 0,0:57:07.34,0:57:13.64,csapp,,0,0,0,,And i should mention there's a clever trick there if you look at 'ja' means jump above 
Dialogue: 0,0:57:13.98,0:57:17.16,csapp,,0,0,0,,That's the unsigned comparison 
Dialogue: 0,0:57:17.64,0:57:24.48,csapp,,0,0,0,,And what it's making use of is our our result that you remember that if a number is negative 
Dialogue: 0,0:57:25.08,0:57:29.64,csapp,,0,0,0,,If you think of it as an unsigned value it becomes very large positive value 
Dialogue: 0,0:57:30.42,0:57:38.14,csapp,,0,0,0,,So by doing the "ja" instead of a "jg" i jump greater than i'm doing jump above 
Dialogue: 0,0:57:38.98,0:57:43.14,csapp,,0,0,0,,It's saying i want to jump to the default 
Dialogue: 0,0:57:43.14,0:57:51.80,csapp,,0,0,0,,If either x is greater than 6 
Dialogue: 0,0:57:52.50,0:57:56.70,csapp,,0,0,0,,But also it will cause it to jump if x is less than 0 
Dialogue: 0,0:57:57.84,0:57:58.30,csapp,,0,0,0,,Got it
Dialogue: 0,0:57:58.88,0:58:04.00,csapp,,0,0,0,,So it's a clever trick of unsigned versus signed numbers it's taking advantage of
Dialogue: 0,0:58:05.02,0:58:12.64,csapp,,0,0,0,,And then the final part is this is the real heart of the work this is my very special  go-to instruction 
Dialogue: 0,0:58:14.14,0:58:22.10,csapp,,0,0,0,,That lets me index into a table and extract out of that an address  and then jump to that address 
Dialogue: 0,0:58:22.72,0:58:30.22,csapp,,0,0,0,,So that's what lets me go directly up to some block of code 
Dialogue: 0,0:58:30.64,0:58:36.74,csapp,,0,0,0,,Based on whether my values will we'll see will be in the range between 0 and 6 
Dialogue: 0,0:58:38.04,0:58:40.32,csapp,,0,0,0,,So there'll be seven entries in that table
Dialogue: 0,0:58:44.90,0:58:48.00,csapp,,0,0,0,,One thing just to keep track up for later
Dialogue: 0,0:58:48.62,0:58:53.12,csapp,,0,0,0,,You'll see that for some reason the gcc said you know 
Dialogue: 0,0:58:53.86,0:58:59.40,csapp,,0,0,0,,If i look at all the code i actually don't use w as initialized very much
Dialogue: 0,0:58:59.58,0:59:02.46,csapp,,0,0,0,,So i won't bother doing it until somewhere within the code blocks 
Dialogue: 0,0:59:03.18,0:59:05.68,csapp,,0,0,0,,So just we'll have to keep track of that here 
Dialogue: 0,0:59:06.56,0:59:10.90,csapp,,0,0,0,,Okay so this is the magic instruction 
Dialogue: 0,0:59:12.24,0:59:16.20,csapp,,0,0,0,,And now if we look and this is all assembly code 
Dialogue: 0,0:59:17.16,0:59:19.32,csapp,,0,0,0,,You'll see this is the actual jump table 
Dialogue: 0,0:59:20.04,0:59:23.68,csapp,,0,0,0,,And it's constructed it's specified in assembly code 
Dialogue: 0,0:59:23.70,0:59:27.42,csapp,,0,0,0,,And it's the job of the assembler to actually fill in the contents of this table
Dialogue: 0,0:59:28.88,0:59:31.16,csapp,,0,0,0,,Excuse me 
Dialogue: 0,0:59:32.00,0:59:36.16,csapp,,0,0,0,,But what the assembly code is telling the assembler is 
Dialogue: 0,0:59:36.68,0:59:41.98,csapp,,0,0,0,,I need a quad is just a declaration to say i need an 8 byte value here 
Dialogue: 0,0:59:42.46,0:59:45.54,csapp,,0,0,0,,And that value should match whatever address 
Dialogue: 0,0:59:46.02,0:59:49.42,csapp,,0,0,0,,You decide you later determine is the address of
Dialogue: 0,0:59:49.58,0:59:54.04,csapp,,0,0,0,,Where i'm going to stick and label 8  and all these other ones 
Dialogue: 0,0:59:54.44,0:59:58.54,csapp,,0,0,0,,And these are in the order as i mentioned from x equals 0 through 6 
Dialogue: 0,0:59:59.56,1:00:03.64,csapp,,0,0,0,,And we can already see a few cases that are interesting here
Dialogue: 0,1:00:04.36,1:00:07.16,csapp,,0,0,0,,Let me see if i've got a picture on this
Dialogue: 0,1:00:12.60,1:00:13.70,csapp,,0,0,0,,Yeah
Dialogue: 0,1:00:16.66,1:00:22.54,csapp,,0,0,0,,So we can actually already see some of the logic of this switch statement 
Dialogue: 0,1:00:22.96,1:00:25.68,csapp,,0,0,0,,Built into the ordering of entries in this table
Dialogue: 0,1:00:26.90,1:00:29.20,csapp,,0,0,0,,So in particular there is no case zero here 
Dialogue: 0,1:00:30.04,1:00:31.70,csapp,,0,0,0,,So case zero should be the default 
Dialogue: 0,1:00:32.56,1:00:34.30,csapp,,0,0,0,,There is no case for here 
Dialogue: 0,1:00:34.92,1:00:36.72,csapp,,0,0,0,,So case four should be the default 
Dialogue: 0,1:00:37.22,1:00:42.04,csapp,,0,0,0,,And it turns out and we already saw before the "ja" instruction going to .l8 
Dialogue: 0,1:00:42.20,1:00:47.06,csapp,,0,0,0,,So .l8 is actually where the code block is going to be for the default case
Dialogue: 0,1:00:47.64,1:00:53.90,csapp,,0,0,0,,So you see basically you can think of this as sometimes kept having holes in your switch statement 
Dialogue: 0,1:00:54.28,1:01:00.12,csapp,,0,0,0,,And we're going to just fill in those holes by saying those should go to the default case 
Dialogue: 0,1:01:03.40,1:01:09.24,csapp,,0,0,0,,And here you'll notice that they're not put in any particularly logical order 
Dialogue: 0,1:01:09.82,1:01:19.94,csapp,,0,0,0,,A one thing you'll see again is .l7 is repeated twice here 
Dialogue: 0,1:01:20.80,1:01:24.06,csapp,,0,0,0,,Because it covers both cases five and six 
Dialogue: 0,1:01:24.44,1:01:27.92,csapp,,0,0,0,,So again you'll see this sort of doubling up is handled automatically
Dialogue: 0,1:01:28.56,1:01:33.76,csapp,,0,0,0,,By the jump table will give you the same address for multiple different cases
Dialogue: 0,1:01:38.32,1:01:41.74,csapp,,0,0,0,,Okay and now the rest of it is to look at the various code box 
Dialogue: 0,1:01:41.74,1:01:48.43,csapp,,0,0,0,,And this by the way i'm showing you i'm took a file and i'm you know extracted little bits of it
Dialogue: 0,1:01:48.48,1:01:52.00,csapp,,0,0,0,,But normally you're looking at this whole listing in one big order 
Dialogue: 0,1:01:53.06,1:01:57.62,csapp,,0,0,0,,So now we can look at the individual code blocks and see what's going on 
Dialogue: 0,1:01:57.62,1:02:01.94,csapp,,0,0,0,,And you'll see for example case one told me to multiply two numbers 
Dialogue: 0,1:02:02.54,1:02:03.94,csapp,,0,0,0,,And you'll see that the break
Dialogue: 0,1:02:04.50,1:02:08.02,csapp,,0,0,0,,In general it's just going to be turned into returned instructions here 
Dialogue: 0,1:02:08.02,1:02:13.70,csapp,,0,0,0,,Because my function...let's go sorry to jump in code 
Dialogue: 0,1:02:13.76,1:02:17.86,csapp,,0,0,0,,You see this function did a switch statement and then whatever
Dialogue: 0,1:02:19.86,1:02:24.74,csapp,,0,0,0,,Whatever it gets computed within the switch statement gets returned as a result of this 
Dialogue: 0,1:02:25.50,1:02:32.24,csapp,,0,0,0,,So the compiler doesn't actually come to a single point and say okay  everyone returned at this point 
Dialogue: 0,1:02:32.24,1:02:36.60,csapp,,0,0,0,,It just sticks returns directly in wherever these breaks occur
Dialogue: 0,1:02:42.48,1:02:44.82,csapp,,0,0,0,,And so here it does a multiply and a return 
Dialogue: 0,1:02:46.94,1:02:53.80,csapp,,0,0,0,,Here is actually a curious by the way i'm always somewhat surprised by what the compiler does 
Dialogue: 0,1:02:53.80,1:02:57.54,csapp,,0,0,0,,It is never exactly what you'd expect 
Dialogue: 0,1:02:58.64,1:03:00.82,csapp,,0,0,0,,So in particular 
Dialogue: 0,1:03:03.12,1:03:09.52,csapp,,0,0,0,,It patched together this fall through case by two blocks of code
Dialogue: 0,1:03:11.32,1:03:17.52,csapp,,0,0,0,,And it had to do these separately because remember w was not set 
Dialogue: 0,1:03:17.90,1:03:22.84,csapp,,0,0,0,,Before i entered the this these code blocks it deferred setting that 
Dialogue: 0,1:03:23.30,1:03:26.42,csapp,,0,0,0,,And here i hit case three and all of a sudden i actually need 
Dialogue: 0,1:03:26.80,1:03:29.16,csapp,,0,0,0,,Whatever w was which was one 
Dialogue: 0,1:03:29.68,1:03:36.24,csapp,,0,0,0,,And so i guess the compiler said well gosh i guess i better set w to one here before we continue 
Dialogue: 0,1:03:36.96,1:03:39.48,csapp,,0,0,0,,So as the result it sort of creates two code blocks 
Dialogue: 0,1:03:39.50,1:03:43.18,csapp,,0,0,0,,But it jumps from the second one the 
Dialogue: 0,1:03:43.42,1:03:47.06,csapp,,0,0,0,,This block into partway through this other block 
Dialogue: 0,1:03:50.56,1:03:56.30,csapp,,0,0,0,,Here's some actual yeah so here's the actual code 
Dialogue: 0,1:03:57.28,1:04:01.96,csapp,,0,0,0,,This is the block that does the division it's very quirky how you have to write division 
Dialogue: 0,1:04:02.50,1:04:04.84,csapp,,0,0,0,,It's covered in the book i won't go through it here
Dialogue: 0,1:04:05.44,1:04:08.98,csapp,,0,0,0,,And then this jump .l6 is what i say go to merge 
Dialogue: 0,1:04:09.50,1:04:12.30,csapp,,0,0,0,,And the merge is where you're bringing these two cases together 
Dialogue: 0,1:04:12.86,1:04:15.00,csapp,,0,0,0,,Here is where it's setting l to one 
Dialogue: 0,1:04:17.22,1:04:19.96,csapp,,0,0,0,,Again it's making use of this feature 
Dialogue: 0,1:04:19.98,1:04:22.88,csapp,,0,0,0,,And that the upper 32 bits get set to zeros 
Dialogue: 0,1:04:22.96,1:04:26.72,csapp,,0,0,0,,So i can use a move l instruction here 
Dialogue: 0,1:04:26.72,1:04:27.56,csapp,,0,0,0,,Yes question
Dialogue: 0,1:04:27.72,1:04:33.94,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:04:33.98,1:04:39.24,csapp,,0,0,0,,Did not have the code for what...no the jump table is sort of embedded 
Dialogue: 0,1:04:39.94,1:04:41.34,csapp,,0,0,0,,Let me just show you real quick
Dialogue: 0,1:04:44.08,1:04:45.14,csapp,,0,0,0,,No probably bad idea 
Dialogue: 0,1:04:48.10,1:04:52.30,csapp,,0,0,0,,The jump if you look at the the .s file the assembly code file 
Dialogue: 0,1:04:52.98,1:04:56.84,csapp,,0,0,0,,Oh all this stuff i'm showing you i've extracted out of that 
Dialogue: 0,1:04:57.48,1:05:02.04,csapp,,0,0,0,,But it's all in there and so that the compiler generated these tables 
Dialogue: 0,1:05:02.48,1:05:05.12,csapp,,0,0,0,,At least the sort of framework for these tables 
Dialogue: 0,1:05:05.58,1:05:08.14,csapp,,0,0,0,,The details of which get filled in by the assembler
Dialogue: 0,1:05:08.82,1:05:11.06,csapp,,0,0,0,,So it is generated by the compiler
Dialogue: 0,1:05:16.66,1:05:23.34,csapp,,0,0,0,,Okay so that just shows you this one example of handling a particular way to handle the fall through case
Dialogue: 0,1:05:24.44,1:05:31.16,csapp,,0,0,0,,And then the remaining ones again you'll see here i got if i get to this case 
Dialogue: 0,1:05:31.30,1:05:34.04,csapp,,0,0,0,,I need the fact that w is initialized to 1 
Dialogue: 0,1:05:34.68,1:05:35.88,csapp,,0,0,0,,So we'll do so here
Dialogue: 0,1:05:37.20,1:05:41.06,csapp,,0,0,0,,In the default case it just assigns to 2w and so that's all it does
Dialogue: 0,1:05:41.94,1:05:44.66,csapp,,0,0,0,,So anyways i've actually shown you all the code box 
Dialogue: 0,1:05:44.88,1:05:50.62,csapp,,0,0,0,,But i've shown you one by one but they're just all kind of strung in the file and in no particular order
Dialogue: 0,1:05:51.14,1:05:52.93,csapp,,0,0,0,,It doesn't matter what order they are
Dialogue: 0,1:05:53.38,1:05:54.04,csapp,,0,0,0,,Yes 
Dialogue: 0,1:05:55.34,1:06:02.24,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:06:02.24,1:06:06.00,csapp,,0,0,0,,Yes so that was the reason for that jump above at the beginning 
Dialogue: 0,1:06:10.10,1:06:17.76,csapp,,0,0,0,,So this jump above .l8 was a way that if x was either less than zero or greater than 6
Dialogue: 0,1:06:18.74,1:06:23.40,csapp,,0,0,0,,It would go to the default case and it will only do this indexing trick 
Dialogue: 0,1:06:24.48,1:06:31.36,csapp,,0,0,0,,If the if x is between 0 and 6 
Dialogue: 0,1:06:32.72,1:06:35.92,csapp,,0,0,0,,And that's typically the way this works that you'll see that
Dialogue: 0,1:06:36.28,1:06:42.36,csapp,,0,0,0,,Whatever range of values you give it has to figure out the smallest and the largest one set up 
Dialogue: 0,1:06:42.54,1:06:45.78,csapp,,0,0,0,,So it goes to the default case if it's out of that range
Dialogue: 0,1:06:46.12,1:06:48.90,csapp,,0,0,0,,And then set up a table for the values within that range 
Dialogue: 0,1:06:49.34,1:06:50.06,csapp,,0,0,0,,Question 
Dialogue: 0,1:06:50.24,1:06:58.52,csapp,,0,0,0,,...number two...yeah...does it try to like do the index into it with that x 
Dialogue: 0,1:06:58.52,1:07:02.20,csapp,,0,0,0,,So the question i'm rose i should be repeating questions 
Dialogue: 0,1:07:02.62,1:07:08.38,csapp,,0,0,0,,The question is of what if it's a negative number for your case which is perfectly legal 
Dialogue: 0,1:07:08.78,1:07:12.12,csapp,,0,0,0,,It will typically add a bias to it effectively 
Dialogue: 0,1:07:12.14,1:07:16.32,csapp,,0,0,0,,So that whatever your lowest value was become zero 
Dialogue: 0,1:07:17.02,1:07:20.76,csapp,,0,0,0,,Or it'll do something like that to avoid having to do negative indexing 
Dialogue: 0,1:07:21.74,1:07:25.02,csapp,,0,0,0,,Another question i see yes
Dialogue: 0,1:07:25.62,1:07:32.20,csapp,,0,0,0,,....yeah so you can go from zero to a million ....
Dialogue: 0,1:07:33.12,1:07:36.34,csapp,,0,0,0,,Yeah they could be you could go zero in a million and nothing in between right
Dialogue: 0,1:07:36.86,1:07:42.10,csapp,,0,0,0,,So you'd have two cases you really don't want a million entry table for just two cases 
Dialogue: 0,1:07:42.66,1:07:44.80,csapp,,0,0,0,,So it will turn it into if felts code 
Dialogue: 0,1:07:45.28,1:07:48.24,csapp,,0,0,0,,But the clever thing it will do if you know binary search
Dialogue: 0,1:07:49.38,1:07:54.82,csapp,,0,0,0,,It relies on the fact that it knows in advance all the values and it will actually set up a tree of if felts is 
Dialogue: 0,1:07:55.58,1:08:02.16,csapp,,0,0,0,,So really it will do it if you want to thank algorithmically it does it with a logarithmic number of tests 
Dialogue: 0,1:08:02.88,1:08:07.16,csapp,,0,0,0,,Rather than a linear number of tests 
Dialogue: 0,1:08:07.16,1:08:09.16,csapp,,0,0,0,,Question
Dialogue: 0,1:08:09.30,1:08:19.74,csapp,,0,0,0,,Oh yes yeah so 
Dialogue: 0,1:08:20.62,1:08:22.26,csapp,,0,0,0,,So these two answers that 
Dialogue: 0,1:08:22.26,1:08:25.46,csapp,,0,0,0,,One is if which i actually answered both now 
Dialogue: 0,1:08:25.98,1:08:32.12,csapp,,0,0,0,,If one is what if there's some negative values or what if the lowest number is 5700 right 
Dialogue: 0,1:08:32.54,1:08:35.42,csapp,,0,0,0,,Well what it will typically do is put some bias 
Dialogue: 0,1:08:36.22,1:08:41.14,csapp,,0,0,0,,And you'll add or subtract some value so that the first case is at value 0 
Dialogue: 0,1:08:41.86,1:08:45.36,csapp,,0,0,0,,So that's why it handles you know ones that are just completely out of range 
Dialogue: 0,1:08:45.62,1:08:50.98,csapp,,0,0,0,,And the other is what if it's a really big spread of values and relatively sparse 
Dialogue: 0,1:08:51.50,1:08:55.58,csapp,,0,0,0,,How much you're using it and there will revert to if-else code 
Dialogue: 0,1:08:55.74,1:08:59.22,csapp,,0,0,0,,And the compiler has its own rules about how it does these things
Dialogue: 0,1:08:59.22,1:09:02.34,csapp,,0,0,0,,You can sort of run experiments and try and reverse engineer 
Dialogue: 0,1:09:03.28,1:09:06.46,csapp,,0,0,0,,Those 0 these are all valid questions by the way appreciate
Dialogue: 0,1:09:11.98,1:09:15.86,csapp,,0,0,0,,Okay so we're going to get through this
Dialogue: 0,1:09:17.48,1:09:26.26,csapp,,0,0,0,,Oh so anyways in like i said i think in my own experience you know understanding
Dialogue: 0,1:09:27.90,1:09:36.42,csapp,,0,0,0,,The conditionals you can kind of figure that out it's intuitive sort of feels like what you'd expect a program to do
Dialogue: 0,1:09:36.82,1:09:43.56,csapp,,0,0,0,,Whereas the switch statement is maybe unexpected it's a way to do something
Dialogue: 0,1:09:44.00,1:09:50.92,csapp,,0,0,0,,That is not totally obvious but if then when you think about it and appreciate it
Dialogue: 0,1:09:50.94,1:09:54.68,csapp,,0,0,0,,It's actually it gives you a good performance boost 
Dialogue: 0,1:09:55.12,1:09:57.86,csapp,,0,0,0,,You know again algorithmically this jump table makes it
Dialogue: 0,1:09:58.34,1:10:06.28,csapp,,0,0,0,,So it's a constant time a constant number of steps to get to where you need to in the switch statement 
Dialogue: 0,1:10:06.86,1:10:10.48,csapp,,0,0,0,,If you just did it linearly one after the other 
Dialogue: 0,1:10:10.92,1:10:16.10,csapp,,0,0,0,,Then that would be linear time and you'd expect on you know if everything's uniform and average 
Dialogue: 0,1:10:16.52,1:10:19.92,csapp,,0,0,0,,About how you'd be about halfway through on average 
Dialogue: 0,1:10:20.74,1:10:25.10,csapp,,0,0,0,,If you're if it's sparse you'll see it will set up a tree of conditionals 
Dialogue: 0,1:10:25.60,1:10:27.76,csapp,,0,0,0,,So it can do in logarithmic time so 
Dialogue: 0,1:10:28.08,1:10:32.66,csapp,,0,0,0,,No matter what it will be better than just what you'd get in the obvious form of your felts 
Dialogue: 0,1:10:32.79,1:10:33.96,csapp,,0,0,0,,I saw a question over here
Dialogue: 0,1:10:34.00,1:10:37.90,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:10:37.90,1:10:44.58,csapp,,0,0,0,,Well the good news is,i don't set up the jump tree the compiler sets up the jump tree right 
Dialogue: 0,1:10:45.46,1:10:49.52,csapp,,0,0,0,,But if you're asking if i were a compiler how would i set up the jump tree right 
Dialogue: 0,1:10:49.52,1:10:51.02,csapp,,0,0,0,,Which is a good question
Dialogue: 0,1:10:51.44,1:10:53.28,csapp,,0,0,0,,If you know binary search right 
Dialogue: 0,1:10:53.28,1:10:57.80,csapp,,0,0,0,,That you've got a range of values and you pick you compare it to the middle value
Dialogue: 0,1:10:58.14,1:11:01.22,csapp,,0,0,0,,And it's either less or it's greater or equal 
Dialogue: 0,1:11:01.86,1:11:07.40,csapp,,0,0,0,,And if it's less than you sort of recursively handle the one set and if it's greater at the other hip 
Dialogue: 0,1:11:07.72,1:11:09.90,csapp,,0,0,0,,That's exactly what these trees look like 
Dialogue: 0,1:11:10.58,1:11:13.90,csapp,,0,0,0,,So they're balanced binary trees and they're taking advantage of the fact
Dialogue: 0,1:11:14.52,1:11:16.86,csapp,,0,0,0,,That in c which is not true in all languages 
Dialogue: 0,1:11:17.30,1:11:23.98,csapp,,0,0,0,,That all the this case conditions you're looking at our constants they're determined
Dialogue: 0,1:11:24.74,1:11:28.16,csapp,,0,0,0,,When the compiler is doing the compilation those are constant values
Dialogue: 0,1:11:28.26,1:11:33.02,csapp,,0,0,0,,So it can sort them figure out how many there are what range of values 
Dialogue: 0,1:11:33.02,1:11:36.88,csapp,,0,0,0,,So there are decide which version to do the clang and generate the code 
Dialogue: 0,1:11:38.44,1:11:39.32,csapp,,0,0,0,,Other questions
Dialogue: 0,1:11:41.75,1:11:45.32,csapp,,0,0,0,,So these are all good and is a very good question so 
Dialogue: 0,1:11:45.56,1:11:48.18,csapp,,0,0,0,,And you're starting to think about 
Dialogue: 0,1:11:48.56,1:11:51.04,csapp,,0,0,0,,You know which is the way that computer scientists should think is 
Dialogue: 0,1:11:51.04,1:11:53.66,csapp,,0,0,0,,How do you take some idea i've seen one case of 
Dialogue: 0,1:11:54.04,1:11:59.78,csapp,,0,0,0,,Well how do i handle condition x and condition y and you know what happens if this that's exactly 
Dialogue: 0,1:12:00.46,1:12:02.14,csapp,,0,0,0,,What we do we sort of 
Dialogue: 0,1:12:02.66,1:12:06.12,csapp,,0,0,0,,We're never happy with a simple explanation we want to understand 
Dialogue: 0,1:12:06.12,1:12:09.40,csapp,,0,0,0,,How we could actually implement it as a program if we ever had to do so
Dialogue: 0,1:12:13.84,1:12:15.94,csapp,,0,0,0,,So and 
Dialogue: 0,1:12:17.42,1:12:23.38,csapp,,0,0,0,,So just in general that the main thing you see is that there's a fairly limited bag of tricks 
Dialogue: 0,1:12:23.92,1:12:28.42,csapp,,0,0,0,,For which the program implements conditional constructs 
Dialogue: 0,1:12:28.50,1:12:30.76,csapp,,0,0,0,,You've seen basically three
Dialogue: 0,1:12:32.04,1:12:37.66,csapp,,0,0,0,,One is to use conditional jumps go to different parts of the code 
Dialogue: 0,1:12:38.22,1:12:40.54,csapp,,0,0,0,,Another to use conditional moves 
Dialogue: 0,1:12:41.50,1:12:44.72,csapp,,0,0,0,,And the third is to use this jump table idea 
Dialogue: 0,1:12:45.14,1:12:52.64,csapp,,0,0,0,,And those are really that put plus a little bit to do of procedures  the suta all there is
Dialogue: 0,1:12:52.92,1:12:57.72,csapp,,0,0,0,,And all the other stuff you see in a program that sort of changes 
Dialogue: 0,1:12:58.42,1:13:04.90,csapp,,0,0,0,,The flow of execution or what gets executed are all built out of those basic primitives 
Dialogue: 0,1:13:05.94,1:13:08.36,csapp,,0,0,0,,And that's generally true that what we see is
Dialogue: 0,1:13:09.80,1:13:15.02,csapp,,0,0,0,,You know when you go from c code to machine code you often have to kind of piece together various 
Dialogue: 0,1:13:15.70,1:13:19.38,csapp,,0,0,0,,Low-level instructions to implement some higher-level construct
Dialogue: 0,1:13:22.38,1:13:25.72,csapp,,0,0,0,,And so we've seen these all in different form stone 
Dialogue: 0,1:13:26.84,1:13:29.46,csapp,,0,0,0,,And next time then we'll talk about procedures 
Dialogue: 0,1:13:29.48,1:13:32.88,csapp,,0,0,0,,And that's as you can imagine a fairly major topic 
Dialogue: 0,1:13:32.88,1:13:35.92,csapp,,0,0,0,,Because it is worth one entire procedure 
Dialogue: 0,1:13:36.42,1:13:39.96,csapp,,0,0,0,,Okay very good thank you
13:39.96,csapp,,0,0,0,,okay very good thank you
