[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 16 System Level I-O.mp4
Video File: ../../../../Desktop/csapp/Lecture 16 System Level I-O.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Active Line: 5
Video Position: 558

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.00,English,,0,0,0,,Good afternoon everyone
Dialogue: 0,0:00:03.02,0:00:07.52,English,,0,0,0,,So i apologize i have to i'm going to sit mostly through this lecture
Dialogue: 0,0:00:07.52,0:00:10.54,English,,0,0,0,,I managed to do something to my knee yesterday
Dialogue: 0,0:00:11.04,0:00:13.12,English,,0,0,0,,And i'm having trouble moving around very much
Dialogue: 0,0:00:13.86,0:00:18.56,English,,0,0,0,,But today what we're going to talk about is input/output
Dialogue: 0,0:00:18.60,0:00:23.52,English,,0,0,0,,What it looks like from the programmers perspective
Dialogue: 0,0:00:24.62,0:00:33.72,English,,0,0,0,,And this is a you've already learned sort of a lot of the standard unix libraries for like printf and scanf
Dialogue: 0,0:00:34.26,0:00:37.30,English,,0,0,0,,And those routines and we'll talk about them a little but
Dialogue: 0,0:00:37.68,0:00:40.68,English,,0,0,0,,What will first talk about is actually lower level io
Dialogue: 0,0:00:40.68,0:00:44.40,English,,0,0,0,,Stuff that is directly interfacing to the operating system
Dialogue: 0,0:00:45.26,0:00:47.94,English,,0,0,0,,And this is what you're going to need to learn about
Dialogue: 0,0:00:48.78,0:00:52.76,English,,0,0,0,,Apartly some of this material you're going to need for the next lab
Dialogue: 0,0:00:52.76,0:00:55.82,English,,0,0,0,,That comes out at midnight tonight the shell lab
Dialogue: 0,0:00:56.48,0:00:58.32,English,,0,0,0,,And you'll need to
Dialogue: 0,0:00:58.96,0:01:04.50,English,,0,0,0,,Also you'll be revisiting this at several other labs along the course including the final lab
Dialogue: 0,0:01:04.88,0:01:07.72,English,,0,0,0,,The the web proxy lab
Dialogue: 0,0:01:07.86,0:01:17.08,English,,0,0,0,,So this is sort of where we're we're really digging down deeply into this type of programming you do
Dialogue: 0,0:01:17.08,0:01:23.54,English,,0,0,0,,If you're writing system software things that are very just barely above the operating system level
Dialogue: 0,0:01:24.00,0:01:32.38,English,,0,0,0,,And i know for myself learning this material i actually learned this material from 213
Dialogue: 0,0:01:32.38,0:01:36.50,English,,0,0,0,,My co-author david o'halloran is the one who knew this stuff already
Dialogue: 0,0:01:36.78,0:01:38.12,English,,0,0,0,,He wrote that part of the book
Dialogue: 0,0:01:38.46,0:01:40.74,English,,0,0,0,,I learned it by reading the book just like you are
Dialogue: 0,0:01:41.04,0:01:45.94,English,,0,0,0,,But i found it actually very useful to know in a variety of different other situations
Dialogue: 0,0:01:45.94,0:01:49.46,English,,0,0,0,,I've been in in the meantime this is quite a few years
Dialogue: 0,0:01:49.96,0:01:52.56,English,,0,0,0,,Ago and so i think it's worth understanding
Dialogue: 0,0:01:53.20,0:01:56.00,English,,0,0,0,,And i'll also mention this kind of material usually is taught
Dialogue: 0,0:01:56.10,0:02:00.18,English,,0,0,0,,You don't really see it covered in most books
Dialogue: 0,0:02:01.14,0:02:06.06,English,,0,0,0,,Except for ones that are really oriented toward system programmers and are fairly arcane
Dialogue: 0,0:02:06.64,0:02:09.81,English,,0,0,0,,Or you try and learn it by reading man pages
Dialogue: 0,0:02:09.81,0:02:13.86,English,,0,0,0,,And that's a fairly cryptic way to try and understand
Dialogue: 0,0:02:14.34,0:02:17.86,English,,0,0,0,,Sort of a set of abstractions provided by an api
Dialogue: 0,0:02:18.08,0:02:19.52,English,,0,0,0,,So i hope you'll find this useful
Dialogue: 0,0:02:21.52,0:02:27.00,English,,0,0,0,,So what we'll talk about then is that what i mentioned this low-level i/o that
Dialogue: 0,0:02:27.34,0:02:31.68,English,,0,0,0,,I supported by unix and other related operating systems
Dialogue: 0,0:02:32.36,0:02:36.34,English,,0,0,0,,And then a package called rio which stands to robust i/o
Dialogue: 0,0:02:37.10,0:02:45.42,English,,0,0,0,,And you will actually not be using this package until the last lab  for the course the proxy lab
Dialogue: 0,0:02:45.90,0:02:47.74,English,,0,0,0,,At which time you'll use it a lot
Dialogue: 0,0:02:48.30,0:02:50.38,English,,0,0,0,,But it's worth looking at and partly
Dialogue: 0,0:02:50.86,0:02:53.80,English,,0,0,0,,It's in the book it's well documented in the book
Dialogue: 0,0:02:54.34,0:02:58.24,English,,0,0,0,,And if you really want to understand how software works or a system works
Dialogue: 0,0:02:58.74,0:03:04.28,English,,0,0,0,,The best thing you can do is if you if it there's good quality source code to look at and study
Dialogue: 0,0:03:04.56,0:03:06.22,English,,0,0,0,,You can learn a lot from doing that
Dialogue: 0,0:03:06.22,0:03:12.57,English,,0,0,0,,And i really recommend for that chapter in the book that you go ahead and study all of the code
Dialogue: 0,0:03:12.86,0:03:15.24,English,,0,0,0,,That makes up rio it's not a huge amount and
Dialogue: 0,0:03:15.84,0:03:19.82,English,,0,0,0,,Just get an appreciation for the subtleties involved in
Dialogue: 0,0:03:19.82,0:03:24.72,English,,0,0,0,,How you deal with errors how you deal with exceptional conditions and things like that
Dialogue: 0,0:03:26.16,0:03:33.04,English,,0,0,0,,And then we'll talk some about how files are represented the sort of various data structures behind files
Dialogue: 0,0:03:33.60,0:03:37.78,English,,0,0,0,,How they support standard i/o and i/o redirection in unix
Dialogue: 0,0:03:38.66,0:03:43.72,English,,0,0,0,,And we'll also talk about the so-called buffered i/o
Dialogue: 0,0:03:43.72,0:03:47.64,English,,0,0,0,,The i/o that you're more familiar with and see when you use printf and scanf
Dialogue: 0,0:03:49.86,0:03:54.54,English,,0,0,0,,So unix actually has a much simpler and more unified view of i/o
Dialogue: 0,0:03:54.54,0:03:58.90,English,,0,0,0,,Than any other operating system and it's one of the nice design features of
Dialogue: 0,0:03:59.56,0:04:03.74,English,,0,0,0,,It is that a lot of abstractions are built into the notion of a file
Dialogue: 0,0:04:04.36,0:04:06.80,English,,0,0,0,,And a file is really just a sequence of bytes
Dialogue: 0,0:04:07.60,0:04:17.10,English,,0,0,0,,And in unix does not distinguish between different classes of files unlike say windows or earlier versions the macintosh operating system
Dialogue: 0,0:04:17.34,0:04:25.94,English,,0,0,0,,It just thanks to them as bytes and the operating system level has essentially no understanding of a more detailed structure inside of a file
Dialogue: 0,0:04:27.44,0:04:33.15,English,,0,0,0,,And one of the things it does is a file is normally originally thought of is
Dialogue: 0,0:04:33.78,0:04:39.78,English,,0,0,0,,Something that stored on say a disk drive or some other external storage device
Dialogue: 0,0:04:40.52,0:04:44.94,English,,0,0,0,,And that you open you read it or write it you close it
Dialogue: 0,0:04:45.36,0:04:47.30,English,,0,0,0,,Those sort of standard operations
Dialogue: 0,0:04:47.76,0:04:54.38,English,,0,0,0,,But unix also use the notion of a file to represent many other different  things
Dialogue: 0,0:04:54.38,0:04:57.62,English,,0,0,0,,Including for example the devices
Dialogue: 0,0:04:58.16,0:05:05.38,English,,0,0,0,,That are the i/o devices that are connected to a particular machine the tty stands for teletype
Dialogue: 0,0:05:06.00,0:05:14.42,English,,0,0,0,,Which is a antique terminology for how people used to actually interface typewriters to computers
Dialogue: 0,0:05:15.10,0:05:21.92,English,,0,0,0,,The other thing that our viewed as like files are the network connections what are known as sockets
Dialogue: 0,0:05:22.46,0:05:26.16,English,,0,0,0,,And when you do communication over the internet
Dialogue: 0,0:05:26.56,0:05:30.74,English,,0,0,0,,You do it by you send a message by writing to a socket
Dialogue: 0,0:05:31.32,0:05:36.78,English,,0,0,0,,And you accept incoming communication by reading from a socket
Dialogue: 0,0:05:36.80,0:05:42.10,English,,0,0,0,,And so the same low-level api is the same
Dialogue: 0,0:05:42.12,0:05:48.22,English,,0,0,0,,Whether you're reading or writing files on your disk drive or sending packets over the internet
Dialogue: 0,0:05:54.76,0:06:01.68,English,,0,0,0,,So the the core operations then associated with files of course are opening and closing them  and reading and writing them
Dialogue: 0,0:06:03.06,0:06:07.76,English,,0,0,0,,The other sort of attribute that's associated with most but not all files
Dialogue: 0,0:06:08.22,0:06:12.22,English,,0,0,0,,Is what's called the file position so if again if you imagine
Dialogue: 0,0:06:12.52,0:06:17.58,English,,0,0,0,,When you're reading from a file you don't want to always start at the beginning every time you do a read
Dialogue: 0,0:06:18.04,0:06:20.74,English,,0,0,0,,You you read some data and then you read some more data
Dialogue: 0,0:06:20.74,0:06:25.40,English,,0,0,0,,And so that's a tracked by a file position which is just a counter
Dialogue: 0,0:06:25.66,0:06:31.56,English,,0,0,0,,That says how many bytes has have been written written read from this file so far
Dialogue: 0,0:06:31.56,0:06:37.76,English,,0,0,0,,So that i know where to go and you can actually even alter that value with
Dialogue: 0,0:06:38.06,0:06:40.70,English,,0,0,0,,A various classes operation called seeking
Dialogue: 0,0:06:41.06,0:06:44.94,English,,0,0,0,,Which is just a way of changing the file pointer the position pointer
Dialogue: 0,0:06:45.96,0:06:48.64,English,,0,0,0,,Now that doesn't work too well if your input is a terminal
Dialogue: 0,0:06:49.06,0:06:56.18,English,,0,0,0,,Where you can't move you can't sort of back up and have a recover data
Dialogue: 0,0:06:56.18,0:07:01.96,English,,0,0,0,,That was presented to it earlier or jump ahead and start accepting data that hasn't been typed yet
Dialogue: 0,0:07:02.36,0:07:06.20,English,,0,0,0,,So there's some kinds of files have a file position and seeking
Dialogue: 0,0:07:06.54,0:07:08.96,English,,0,0,0,,And others don't similar to a network socket
Dialogue: 0,0:07:08.96,0:07:16.68,English,,0,0,0,,You can't jump a socket for it in time you can only read or write the particular packets as they come in
Dialogue: 0,0:07:18.98,0:07:22.59,English,,0,0,0,,But in general think of it then is the file position
Dialogue: 0,0:07:22.94,0:07:26.70,English,,0,0,0,,As part of the the data associated with an open file
Dialogue: 0,0:07:27.06,0:07:30.30,English,,0,0,0,,That tells me how far along in this file have i read or written
Dialogue: 0,0:07:34.58,0:07:41.62,English,,0,0,0,,And then again the files are because there's all these different things they're sort of unified in this file abstraction
Dialogue: 0,0:07:41.64,0:07:43.58,English,,0,0,0,,But obviously these differences
Dialogue: 0,0:07:44.10,0:07:46.44,English,,0,0,0,,And different attributes to them and so
Dialogue: 0,0:07:47.80,0:07:51.08,English,,0,0,0,,There's sort of many different categories and subcategories
Dialogue: 0,0:07:51.10,0:07:57.94,English,,0,0,0,,But the ones we'll think about our a regular files just think of things that are on a disk drive  directories
Dialogue: 0,0:07:58.04,0:08:06.66,English,,0,0,0,,Which is a directory is considered a type of file meaning the data that's in there is just enough as a file
Dialogue: 0,0:08:07.02,0:08:12.06,English,,0,0,0,,But of course it's special kind of file and that it actually does have an interpretation
Dialogue: 0,0:08:12.34,0:08:17.06,English,,0,0,0,,That entries in that file describe the locations and attributes of other files
Dialogue: 0,0:08:18.64,0:08:23.66,English,,0,0,0,,And then as i mentioned the term socket is a connection to a network
Dialogue: 0,0:08:24.24,0:08:28.30,English,,0,0,0,,And it's both for sending and for receiving messages over the network
Dialogue: 0,0:08:29.38,0:08:33.54,English,,0,0,0,,There's other files that we won't really talk about for example when you pipe
Dialogue: 0,0:08:34.18,0:08:37.06,English,,0,0,0,,When you from one application to another
Dialogue: 0,0:08:37.66,0:08:46.82,English,,0,0,0,,That's both the output of the first program and the input of the second are special types of files called pipes
Dialogue: 0,0:08:47.50,0:08:57.58,English,,0,0,0,,And they're handled by writing is putting something into the pipe and reading is to take something out of that pipe
Dialogue: 0,0:08:58.24,0:09:01.74,English,,0,0,0,,A similar something called a symbolic link which is just a way that
Dialogue: 0,0:09:01.74,0:09:04.76,English,,0,0,0,,You can have multiple names for a file
Dialogue: 0,0:09:04.76,0:09:08.10,English,,0,0,0,,And pointers to a file that aren't really
Dialogue: 0,0:09:11.38,0:09:14.94,English,,0,0,0,,Without having to make separate copies of a file
Dialogue: 0,0:09:15.46,0:09:17.82,English,,0,0,0,,And then other special types of devices
Dialogue: 0,0:09:18.50,0:09:24.16,English,,0,0,0,,So we won't really will only consider for the first three types of files
Dialogue: 0,0:09:24.16,0:09:26.54,English,,0,0,0,,And in fact for today mostly the first two
Dialogue: 0,0:09:33.20,0:09:37.30,English,,0,0,0,,So the idea of a file then is it just contains arbitrary data
Dialogue: 0,0:09:37.30,0:09:43.96,English,,0,0,0,,And the operating system really for regular file doesn't try to get into the details of what's inside that file
Dialogue: 0,0:09:44.86,0:09:52.04,English,,0,0,0,,And there's some class of applications that will distinguish between a text file and a binary file
Dialogue: 0,0:09:53.06,0:09:56.68,English,,0,0,0,,Not really at the operating system level but more higher levels
Dialogue: 0,0:09:57.16,0:10:05.64,English,,0,0,0,,And the main difference with that is it a text file should only have the standard characters of ascii
Dialogue: 0,0:10:06.18,0:10:10.62,English,,0,0,0,,Or another class would be various encoding that allow you to do
Dialogue: 0,0:10:10.86,0:10:13.36,English,,0,0,0,,In coatings of non-english alphabets
Dialogue: 0,0:10:14.96,0:10:27.58,English,,0,0,0,,And binary files would be things like an image or a actual object code or a video or audio file or something
Dialogue: 0,0:10:27.78,0:10:35.58,English,,0,0,0,,That it's the you're within that code there's a sequence of bytes that are encoding numbers in some form directly
Dialogue: 0,0:10:40.12,0:10:45.62,English,,0,0,0,,And then the main thing about a text file is that there's certain functions that
Dialogue: 0,0:10:46.10,0:10:51.18,English,,0,0,0,,Distinguish a newline character meaning the end of it line of text
Dialogue: 0,0:10:52.22,0:10:59.28,English,,0,0,0,,And you already learned about that character it's that got the code of a 0a as a bytecode
Dialogue: 0,0:10:59.58,0:11:02.94,English,,0,0,0,,And that became one of the forbidden codes of your attacks
Dialogue: 0,0:11:03.08,0:11:07.62,English,,0,0,0,,Because it would be interpreted as a newline by the function gets
Dialogue: 0,0:11:10.02,0:11:12.76,English,,0,0,0,,Just to mention that and this is one place
Dialogue: 0,0:11:12.76,0:11:17.80,English,,0,0,0,,When you're transferring files between say a windows machine and a linux or a mac
Dialogue: 0,0:11:18.28,0:11:22.02,English,,0,0,0,,One of the things if it's a text file that has to be changed is
Dialogue: 0,0:11:22.02,0:11:28.20,English,,0,0,0,,That two classes of systems have different ways of interpreting of encoding when is the end of a line
Dialogue: 0,0:11:28.74,0:11:35.42,English,,0,0,0,,And in a linux or mac file it's just uh this character code a
Dialogue: 0,0:11:36.20,0:11:38.38,English,,0,0,0,,Which stands for line feed
Dialogue: 0,0:11:38.98,0:11:45.12,English,,0,0,0,,Whereas the windows files finish with a two character end of line
Dialogue: 0,0:11:45.12,0:11:46.70,English,,0,0,0,,A carriage return in line feed
Dialogue: 0,0:11:46.70,0:11:51.74,English,,0,0,0,,And i show you this picture of an object that you've probably only seen in museums
Dialogue: 0,0:11:52.32,0:11:57.32,English,,0,0,0,,But it's a typewriter and just to tell you what the heck is a carriage return and what's the line feed
Dialogue: 0,0:11:57.68,0:12:02.10,English,,0,0,0,,I thought you might like to in case you've never actually used an old-fashioned typewriter
Dialogue: 0,0:12:03.28,0:12:09.46,English,,0,0,0,,Basically at the end of it on the left hand side of a typewriter is this bar
Dialogue: 0,0:12:09.96,0:12:11.84,English,,0,0,0,,And when you start typing along
Dialogue: 0,0:12:14.10,0:12:21.20,English,,0,0,0,,I'll the paid the the this roller with your page on it sinks along
Dialogue: 0,0:12:22.04,0:12:26.26,English,,0,0,0,,And it comes to the end and then you want to get back to the beginning of the next line
Dialogue: 0,0:12:26.26,0:12:28.74,English,,0,0,0,,So you want to both do the carriage return
Dialogue: 0,0:12:29.84,0:12:33.29,English,,0,0,0,,Which is this thing shove it to the right
Dialogue: 0,0:12:33.84,0:12:40.02,English,,0,0,0,,And you want to do a line feed you want the roller on it to go down to the next line
Dialogue: 0,0:12:41.06,0:12:43.86,English,,0,0,0,,So there's a knob here that you can twist by hand
Dialogue: 0,0:12:43.88,0:12:47.20,English,,0,0,0,,But in general what you do is you type along and then you go slam
Dialogue: 0,0:12:47.66,0:12:53.58,English,,0,0,0,,Like that and this lever both pushes the thing back and it rotates the
Dialogue: 0,0:12:55.62,0:12:58.08,English,,0,0,0,,The roller by one lines worth and
Dialogue: 0,0:12:58.30,0:13:04.66,English,,0,0,0,,So carriage return line feed is where that actually comes from  in case you wonder
Dialogue: 0,0:13:09.26,0:13:13.24,English,,0,0,0,,And then a directory as i mentioned it's it's stored as a file
Dialogue: 0,0:13:13.24,0:13:20.56,English,,0,0,0,,But it's a file that the operating system at least the file system part of the operating system actually interprets in very specific ways
Dialogue: 0,0:13:21.46,0:13:26.04,English,,0,0,0,,And as you know within every dot directory there's two special files
Dialogue: 0,0:13:26.10,0:13:32.14,English,,0,0,0,,Dot and dot dot referring to the local file and its parent in the tree structure
Dialogue: 0,0:13:33.58,0:13:37.74,English,,0,0,0,,And so in in most systems
Dialogue: 0,0:13:37.96,0:13:41.70,English,,0,0,0,,Systems that i know of there's a sort of hierarchical organization to the files
Dialogue: 0,0:13:42.26,0:13:45.54,English,,0,0,0,,We're not going to talk much about file systems
Dialogue: 0,0:13:45.64,0:13:49.90,English,,0,0,0,,But there's a hierarchical organization
Dialogue: 0,0:13:50.74,0:13:56.24,English,,0,0,0,,And that's maintained as a series of files each being the directory
Dialogue: 0,0:13:56.62,0:14:00.48,English,,0,0,0,,And the directory then is a pointer to its subdirectory which again are files
Dialogue: 0,0:14:01.94,0:14:04.92,English,,0,0,0,,And so what's referred to in unix terminology
Dialogue: 0,0:14:04.92,0:14:11.94,English,,0,0,0,,And most other operating systems what's known as a path name is a way to navigate
Dialogue: 0,0:14:11.98,0:14:17.20,English,,0,0,0,,Through this hierarchy of files and identify one particular one
Dialogue: 0,0:14:19.58,0:14:26.20,English,,0,0,0,,And so that all comes to say that the low-level unix operations
Dialogue: 0,0:14:26.26,0:14:31.40,English,,0,0,0,,That use to implement this are to open a file to read it and write it  and to close it
Dialogue: 0,0:14:31.40,0:14:33.62,English,,0,0,0,,And those literally those are the names of the functions
Dialogue: 0,0:14:34.70,0:14:37.64,English,,0,0,0,,So the open function then you give a path name
Dialogue: 0,0:14:38.34,0:14:42.60,English,,0,0,0,,And remember pathnames can be absolute meaning that they start with a slash
Dialogue: 0,0:14:43.52,0:14:47.28,English,,0,0,0,,And they go all the way down the hierarchy
Dialogue: 0,0:14:47.56,0:14:54.05,English,,0,0,0,,They can be relative to a particular whatever your current directory is where
Dialogue: 0,0:14:54.56,0:15:03.88,English,,0,0,0,,And they can also be relative to a user if you use the tilde slash or tilde l
Dialogue: 0,0:15:04.38,0:15:08.66,English,,0,0,0,,Then that sort of a shortcut in this path name to get to particular users
Dialogue: 0,0:15:09.50,0:15:15.90,English,,0,0,0,,So a path name can be any of those forms when you open it it just has to be some way that just like you specify
Dialogue: 0,0:15:15.90,0:15:21.20,English,,0,0,0,,In other places that you tell where this particular file is you're trying to open
Dialogue: 0,0:15:22.90,0:15:26.26,English,,0,0,0,,And so it's given a path name and then it's given a
Dialogue: 0,0:15:27.00,0:15:32.52,English,,0,0,0,,Integer code that says what do you want to do when you open this file
Dialogue: 0,0:15:32.52,0:15:34.10,English,,0,0,0,,In what form do you want to open it
Dialogue: 0,0:15:34.66,0:15:42.90,English,,0,0,0,,And that's specified by a series of constants that are already predefined when you include the propria file
Dialogue: 0,0:15:44.62,0:15:48.42,English,,0,0,0,,And you can and those actually get bitwise
Dialogue: 0,0:15:48.76,0:15:53.92,English,,0,0,0,,Each of those is a one bit flag in a some power of two position
Dialogue: 0,0:15:54.46,0:15:58.92,English,,0,0,0,,Or it's a position one bit in a field somewhere
Dialogue: 0,0:15:59.38,0:16:03.16,English,,0,0,0,,And so you can logically or those together if you want multiple combinations
Dialogue: 0,0:16:03.94,0:16:09.44,English,,0,0,0,,So for example i can say read-only i can say read and write
Dialogue: 0,0:16:09.98,0:16:12.78,English,,0,0,0,,I can say append meaning don't
Dialogue: 0,0:16:13.02,0:16:19.68,English,,0,0,0,,If i'm opening it to write don't begin it the don't start writing at the beginning start writing it wherever the end of the file
Dialogue: 0,0:16:20.36,0:16:23.18,English,,0,0,0,,Is no so all those can be done and this is described in the book
Dialogue: 0,0:16:23.62,0:16:30.20,English,,0,0,0,,By using the right set of names of constants and oaring them together
Dialogue: 0,0:16:31.44,0:16:34.22,English,,0,0,0,,And that will return something that's called a file descriptor
Dialogue: 0,0:16:34.74,0:16:39.48,English,,0,0,0,,And that's a very important idea that and one of the reasons why we're talking about this today
Dialogue: 0,0:16:39.48,0:16:41.48,English,,0,0,0,,This is going to be very important in your lab
Dialogue: 0,0:16:42.06,0:16:45.84,English,,0,0,0,,Is the notion of a file descriptor which is just a small integer
Dialogue: 0,0:16:46.36,0:16:51.34,English,,0,0,0,,That lists which particular one of the open files
Dialogue: 0,0:16:51.76,0:16:56.16,English,,0,0,0,,That's being used by this particular program are you referring to
Dialogue: 0,0:16:56.74,0:17:02.02,English,,0,0,0,,And so it's a small number because these are a sign sequentially
Dialogue: 0,0:17:02.02,0:17:04.20,English,,0,0,0,,When you begin your program and you run
Dialogue: 0,0:17:05.36,0:17:09.74,English,,0,0,0,,And you're in fact limited on most machines to some
Dialogue: 0,0:17:10.00,0:17:13.92,English,,0,0,0,,Some bounded number of open files you're allowed to have at any time
Dialogue: 0,0:17:14.24,0:17:16.18,English,,0,0,0,,In fact if you go to
Dialogue: 0,0:17:18.96,0:17:19.66,English,,0,0,0,,Let's see on
Dialogue: 0,0:17:20.52,0:17:22.96,English,,0,0,0,,If you're on a machine and you type in limits limit
Dialogue: 0,0:17:30.26,0:17:32.78,English,,0,0,0,,You'll see there that entry called descriptors
Dialogue: 0,0:17:33.88,0:17:39.90,English,,0,0,0,,1024 says that you can't have more than 1024 files open at any given time
Dialogue: 0,0:17:40.16,0:17:42.96,English,,0,0,0,,And in fact if you've got 1024 files open
Dialogue: 0,0:17:43.12,0:17:45.80,English,,0,0,0,,It's a chance you're doing something really seriously wrong
Dialogue: 0,0:17:46.42,0:17:49.18,English,,0,0,0,,Being that you haven't been closing the files you should be closing
Dialogue: 0,0:17:59.96,0:18:05.22,English,,0,0,0,,And all the system calls including these always have return code
Dialogue: 0,0:18:05.66,0:18:12.10,English,,0,0,0,,And the return codes very sometimes a negative number is an error sometimes a zero is an error
Dialogue: 0,0:18:12.50,0:18:17.12,English,,0,0,0,,Now they're all different and all confusing and all inscrutable
Dialogue: 0,0:18:17.12,0:18:22.60,English,,0,0,0,,So you have to look at the documentation for every single one of those functions
Dialogue: 0,0:18:22.60,0:18:26.66,English,,0,0,0,,And one of the the rules we're going to hammer away at in this course
Dialogue: 0,0:18:27.34,0:18:31.34,English,,0,0,0,,Is every time you make a system call you should check the return code
Dialogue: 0,0:18:31.98,0:18:36.10,English,,0,0,0,,To see if there's an error and then do some appropriate way of handling the error
Dialogue: 0,0:18:36.10,0:18:38.32,English,,0,0,0,,That's just a practice it's a pain in the butt
Dialogue: 0,0:18:38.84,0:18:41.70,English,,0,0,0,,It makes your code look like a rat's nest of conditionals
Dialogue: 0,0:18:42.24,0:18:45.78,English,,0,0,0,,You really would rather not because often there's an error you
Dialogue: 0,0:18:46.22,0:18:49.04,English,,0,0,0,,Deciding what you're going to do when there's an error is harder than
Dialogue: 0,0:18:49.56,0:18:51.73,English,,0,0,0,,Then figuring just ignoring it all together
Dialogue: 0,0:18:52.84,0:18:54.52,English,,0,0,0,,And so there's a lot of code out there
Dialogue: 0,0:18:54.52,0:18:58.06,English,,0,0,0,,Where people just cross their fingers and hope there's never errors in their system calls
Dialogue: 0,0:18:58.96,0:19:05.08,English,,0,0,0,,But we're going to really push on you hard to say every time you make a system call check the return code
Dialogue: 0,0:19:05.26,0:19:06.84,English,,0,0,0,,And do something if it's not right
Dialogue: 0,0:19:09.38,0:19:15.30,English,,0,0,0,,And so the open will return a number so that it's an int that it returns
Dialogue: 0,0:19:15.30,0:19:20.32,English,,0,0,0,,But if it's a negative number that means it couldn't open the the file
Dialogue: 0,0:19:20.32,0:19:25.24,English,,0,0,0,,For example the file doesn't exist or you're trying to open it in a mode
Dialogue: 0,0:19:25.26,0:19:27.56,English,,0,0,0,,That you're not authorized to open it in
Dialogue: 0,0:19:30.44,0:19:37.66,English,,0,0,0,,So there's three particular file descriptors associated with every single process  that runs
Dialogue: 0,0:19:37.66,0:19:42.02,English,,0,0,0,,One is standard input the other standard output the third is standard error
Dialogue: 0,0:19:42.30,0:19:47.36,English,,0,0,0,,And they always have a file descriptor number zero one and two  dandumb
Dialogue: 0,0:19:49.86,0:19:56.88,English,,0,0,0,,So that you shouldn't really refer to them by their file descriptor numbers
Dialogue: 0,0:19:56.90,0:20:00.74,English,,0,0,0,,Even though you actually can reliably depend on those values
Dialogue: 0,0:20:02.82,0:20:04.74,English,,0,0,0,,Same way if you want to close a file
Dialogue: 0,0:20:04.76,0:20:11.12,English,,0,0,0,,You also open you see you give a path name and a one bit a one integer field
Dialogue: 0,0:20:11.18,0:20:15.12,English,,0,0,0,,That gives these flags say something about the modes in which you want to open it
Dialogue: 0,0:20:16.58,0:20:22.36,English,,0,0,0,,To close a file you just say close and you give the file descriptor number not the name of the file
Dialogue: 0,0:20:22.86,0:20:24.84,English,,0,0,0,,And it returns a return code too
Dialogue: 0,0:20:26.72,0:20:33.86,English,,0,0,0,,So you might say now why in the world could you ever get an error closing a file  it's open
Dialogue: 0,0:20:34.22,0:20:36.56,English,,0,0,0,,And the answers that actually can happen
Dialogue: 0,0:20:37.24,0:20:42.02,English,,0,0,0,,In particular we'll see when we have multi-threaded programs
Dialogue: 0,0:20:42.02,0:20:50.54,English,,0,0,0,,Where it's possible to have to essentially two programs running at the same time sharing their data structures and
Dialogue: 0,0:20:51.06,0:20:53.56,English,,0,0,0,,Interacting with each other sharing their memory
Dialogue: 0,0:20:54.02,0:20:59.78,English,,0,0,0,,It's a very important kind of programming and one that you can really make bad horrible mistakes in
Dialogue: 0,0:21:00.02,0:21:04.31,English,,0,0,0,,And one of the bad horrible mistakes is if you try to close a file that's already been closed
Dialogue: 0,0:21:04.58,0:21:09.66,English,,0,0,0,,It'll be an error and that can happen if there's two different parts of your program running
Dialogue: 0,0:21:10.10,0:21:12.50,English,,0,0,0,,And each of them tries to close the file
Dialogue: 0,0:21:15.26,0:21:20.04,English,,0,0,0,,So in the book and in the in this code you'll see
Dialogue: 0,0:21:20.48,0:21:24.58,English,,0,0,0,,We introduced some error handling routines one of which is called perror
Dialogue: 0,0:21:25.16,0:21:30.86,English,,0,0,0,,And all it does is print some not whatever message you want to print
Dialogue: 0,0:21:31.36,0:21:33.42,English,,0,0,0,,And then it exits the program
Dialogue: 0,0:21:37.16,0:21:41.00,English,,0,0,0,,Or no i guess it doesn't that i'll mention in a little while
Dialogue: 0,0:21:42.18,0:21:44.02,English,,0,0,0,,It just prints an error message
Dialogue: 0,0:21:44.88,0:21:50.08,English,,0,0,0,,But the point is even even something as mundane as closing a file you should be checking the return code
Dialogue: 0,0:21:52.08,0:21:55.12,English,,0,0,0,,Okay so this is the function that reads
Dialogue: 0,0:21:56.56,0:21:58.42,English,,0,0,0,,At this low level is called read
Dialogue: 0,0:21:59.22,0:22:01.27,English,,0,0,0,,And it's given a file descriptor
Dialogue: 0,0:22:01.70,0:22:04.18,English,,0,0,0,,You provided a pointer to a buffer
Dialogue: 0,0:22:04.64,0:22:09.30,English,,0,0,0,,That's you you've had to allocate either aesthetically or via malloc
Dialogue: 0,0:22:10.12,0:22:15.82,English,,0,0,0,,And you also specify how long that buffer is  so that it can't overflow that buffer
Dialogue: 0,0:22:16.74,0:22:21.96,English,,0,0,0,,And read just means read as many bytes as you feel like
Dialogue: 0,0:22:22.86,0:22:25.06,English,,0,0,0,,But no more than the number i tell you to
Dialogue: 0,0:22:26.08,0:22:28.08,English,,0,0,0,,Which sounds like a weird statement
Dialogue: 0,0:22:28.46,0:22:29.94,English,,0,0,0,,What do you mean what you feel like
Dialogue: 0,0:22:31.50,0:22:35.74,English,,0,0,0,,Well it has to read at least one byte so if for example it's
Dialogue: 0,0:22:37.18,0:22:41.58,English,,0,0,0,,A standard input it will hang there and wait until
Dialogue: 0,0:22:41.98,0:22:48.38,English,,0,0,0,,Actually with standard input it will wait until you've typed in a string and hit the return
Dialogue: 0,0:22:49.66,0:22:54.66,English,,0,0,0,,And it will then read at least some fraction of that into the program
Dialogue: 0,0:22:55.66,0:22:59.58,English,,0,0,0,,If it's a network connection again
Dialogue: 0,0:22:59.76,0:23:05.12,English,,0,0,0,,The read won't just wait it will hang until something arrives
Dialogue: 0,0:23:05.22,0:23:10.30,English,,0,0,0,,On that particular network connection and then read in some number of bytes
Dialogue: 0,0:23:11.42,0:23:15.48,English,,0,0,0,,That have been sent to it and i'm being vague by saying some number
Dialogue: 0,0:23:15.88,0:23:20.64,English,,0,0,0,,Because the truth is it there's no guarantee it will read any fixed number of bytes
Dialogue: 0,0:23:21.86,0:23:23.27,English,,0,0,0,,It will read at least one
Dialogue: 0,0:23:23.90,0:23:26.68,English,,0,0,0,,And it won't read any more than that buffer is
Dialogue: 0,0:23:27.12,0:23:29.48,English,,0,0,0,,But the number between that might be variable
Dialogue: 0,0:23:30.02,0:23:35.22,English,,0,0,0,,And so when it reads less than that the number of maximum number bytes
Dialogue: 0,0:23:35.26,0:23:37.34,English,,0,0,0,,You specify that it's called a short read
Dialogue: 0,0:23:38.50,0:23:41.62,English,,0,0,0,,And that canon does happen and you have to write your code
Dialogue: 0,0:23:41.96,0:23:44.82,English,,0,0,0,,Expecting it and we'll talk about that a little bit
Dialogue: 0,0:23:49.98,0:23:55.62,English,,0,0,0,,Oh and so again and by reed returns in a signed number
Dialogue: 0,0:23:56.14,0:24:03.22,English,,0,0,0,,Actually of data type ssize_t like  s size underscore t
Dialogue: 0,0:24:03.64,0:24:07.26,English,,0,0,0,,Which is typically a long int
Dialogue: 0,0:24:07.76,0:24:14.32,English,,0,0,0,,So a potentially negative number  in it that that number is if it says zero
Dialogue: 0,0:24:15.50,0:24:19.12,English,,0,0,0,,It means that it's hid its detected and into file
Dialogue: 0,0:24:19.62,0:24:25.26,English,,0,0,0,,That you've run to the end of the stored file that the network connection has been closed or something has happened
Dialogue: 0,0:24:26.16,0:24:30.04,English,,0,0,0,,If it's positive then that's the number of bytes that were read
Dialogue: 0,0:24:30.34,0:24:32.26,English,,0,0,0,,And if it's negative it's an error code
Dialogue: 0,0:24:39.06,0:24:42.80,English,,0,0,0,,So as i mentioned if it if it reads fewer than the number of bytes you specify
Dialogue: 0,0:24:42.82,0:24:46.62,English,,0,0,0,,That's referred to as a short count and i'll talk about why that would occur
Dialogue: 0,0:24:48.26,0:24:54.46,English,,0,0,0,,Writing is sort of the same idea that you provide a file descriptor you provide a buffer
Dialogue: 0,0:24:54.78,0:24:57.94,English,,0,0,0,,Where the the data that you want to write out is stored
Dialogue: 0,0:24:58.56,0:25:01.98,English,,0,0,0,,And you give up how many bytes long do you want your right to be
Dialogue: 0,0:25:03.30,0:25:11.52,English,,0,0,0,,And it will write a sum number of bytes to the output at least one  and no more than n bytes
Dialogue: 0,0:25:11.72,0:25:15.52,English,,0,0,0,,But it might not be all of them which is kind of weird because you said
Dialogue: 0,0:25:15.76,0:25:19.92,English,,0,0,0,,I want to write this i want to send it to a file i want to send it over the internet
Dialogue: 0,0:25:20.66,0:25:23.80,English,,0,0,0,,But it can potentially not send them all
Dialogue: 0,0:25:25.38,0:25:28.10,English,,0,0,0,,And well we'll talk about that a little bit
Dialogue: 0,0:25:28.58,0:25:30.64,English,,0,0,0,,So again that's called a short write
Dialogue: 0,0:25:33.08,0:25:36.62,English,,0,0,0,,And simile it will return the number of bytes that were written
Dialogue: 0,0:25:37.36,0:25:41.16,English,,0,0,0,,And so if it's less than zero that's an error code
Dialogue: 0,0:25:44.38,0:25:48.60,English,,0,0,0,,So just to give you a really simple example of this in action
Dialogue: 0,0:25:48.82,0:25:54.28,English,,0,0,0,,This code does what you call echoing meaning that you type in something and it will print it out
Dialogue: 0,0:25:55.02,0:25:57.48,English,,0,0,0,,And it does it in the most mundane way possible
Dialogue: 0,0:25:58.04,0:26:03.02,English,,0,0,0,,By reading specifying a single byte reads and single byte writes
Dialogue: 0,0:26:03.72,0:26:09.20,English,,0,0,0,,So you remember i told you read well read at least one byte but no more than the number you've told it
Dialogue: 0,0:26:09.96,0:26:13.34,English,,0,0,0,,So when you give it one it means it will read exactly one byte
Dialogue: 0,0:26:13.40,0:26:18.94,English,,0,0,0,,And similarly with right if you say right one byte that's all
Dialogue: 0,0:26:20.68,0:26:23.84,English,,0,0,0,,And so this is really really bad code
Dialogue: 0,0:26:24.44,0:26:27.62,English,,0,0,0,,In the sense that called to read or to write
Dialogue: 0,0:26:27.62,0:26:31.14,English,,0,0,0,,The system level call is a relatively expensive call
Dialogue: 0,0:26:31.70,0:26:38.32,English,,0,0,0,,It means kicking your whole operation up to the operating system doing what's called a context switch
Dialogue: 0,0:26:39.28,0:26:46.86,English,,0,0,0,,Meaning it will go into the kernel of the system invoke operating system functions
Dialogue: 0,0:26:47.72,0:26:53.54,English,,0,0,0,,Do whatever the reader right tells it to do come back out switch back to your job
Dialogue: 0,0:26:53.88,0:26:59.40,English,,0,0,0,,And that will typically take maybe 20,000 to 40,000 clock cycles
Dialogue: 0,0:27:00.12,0:27:05.10,English,,0,0,0,,Which you know a clock cycle nowadays is less than a nanosecond so you say
Dialogue: 0,0:27:05.40,0:27:08.04,English,,0,0,0,,Yeah it's a you're talking
Dialogue: 0,0:27:08.84,0:27:11.68,English,,0,0,0,,Maybe 10 microseconds what's the big deal there
Dialogue: 0,0:27:12.22,0:27:16.84,English,,0,0,0,,But that'll add up if you start sending long files out over
Dialogue: 0,0:27:17.44,0:27:22.62,English,,0,0,0,,You know millions of bytes if you start sending them a one byte at a time
Dialogue: 0,0:27:23.82,0:27:29.90,English,,0,0,0,,You'll spend most of that time sitting in the operating system going going crazy
Dialogue: 0,0:27:31.38,0:27:36.10,English,,0,0,0,,So this is not a good idea but it does work and that's actually a easy mistake
Dialogue: 0,0:27:36.10,0:27:41.96,English,,0,0,0,,You can make as a programmer is to not use it is to use as low level writing and reading
Dialogue: 0,0:27:42.52,0:27:46.52,English,,0,0,0,,And the program will function fine it's just it will be really really slow
Dialogue: 0,0:27:47.60,0:27:52.20,English,,0,0,0,,But just to give you a demo of this idea of
Dialogue: 0,0:27:55.04,0:27:56.78,English,,0,0,0,,Our calls to the operating system
Dialogue: 0,0:27:57.54,0:27:59.10,English,,0,0,0,,There's a pretty cool
Dialogue: 0,0:28:03.14,0:28:05.78,English,,0,0,0,,So this program and this is on the web
Dialogue: 0,0:28:05.96,0:28:09.58,English,,0,0,0,,Linked off the webpage the code for this lecture
Dialogue: 0,0:28:10.14,0:28:15.32,English,,0,0,0,,So this one called cpe standard in meaning copy standard input
Dialogue: 0,0:28:16.58,0:28:18.62,English,,0,0,0,,Is just the code i showed you and
Dialogue: 0,0:28:18.62,0:28:21.40,English,,0,0,0,,So if you type something it will just echo it back
Dialogue: 0,0:28:24.14,0:28:28.82,English,,0,0,0,,So it's reading in so it looks to you and to me
Dialogue: 0,0:28:30.82,0:28:32.02,English,,0,0,0,,Like it up
Dialogue: 0,0:28:35.88,0:28:41.20,English,,0,0,0,,Reading on line of text and then echoing it back but what it's actually doing
Dialogue: 0,0:28:42.74,0:28:49.56,English,,0,0,0,,Is again the interface to the terminal is one that it doesn't actually wake up this code until it gets a complete line
Dialogue: 0,0:28:49.98,0:28:54.14,English,,0,0,0,,But it's actually just printing these characters back one one character at a time
Dialogue: 0,0:28:55.86,0:29:00.24,English,,0,0,0,,And i can demo that by there's a pretty interesting
Dialogue: 0,0:29:02.06,0:29:04.74,English,,0,0,0,,Facility called tracing s trace then what strace
Dialogue: 0,0:29:06.62,0:29:09.62,English,,0,0,0,,Will do if you give it the name of a program
Dialogue: 0,0:29:10.26,0:29:16.02,English,,0,0,0,,Is it will detect every every system call that you make
Dialogue: 0,0:29:16.70,0:29:20.30,English,,0,0,0,,Every basically call to the operating system functions
Dialogue: 0,0:29:20.98,0:29:23.40,English,,0,0,0,,That you make when you run a program
Dialogue: 0,0:29:23.86,0:29:28.84,English,,0,0,0,,And it will generally spew out this huge amount of inscrutable stuff that you don't really want to see
Dialogue: 0,0:29:29.40,0:29:30.96,English,,0,0,0,,I'll just show you this
Dialogue: 0,0:29:32.86,0:29:38.28,English,,0,0,0,,Oh it's telling you logging every single call and it's usually way too much stuff
Dialogue: 0,0:29:39.18,0:29:41.12,English,,0,0,0,,So the more useful way to do this
Dialogue: 0,0:29:42.46,0:29:50.68,English,,0,0,0,,Is to give it an argument that says i only want to watch some limited class of functions  of when this is running
Dialogue: 0,0:29:50.76,0:29:55.80,English,,0,0,0,,And so what i just want our calls to the right the low level output right
Dialogue: 0,0:29:57.94,0:30:02.14,English,,0,0,0,,And you'll see that what happens then is this string i typed in
Dialogue: 0,0:30:03.30,0:30:07.58,English,,0,0,0,,Turned into a series of 1 byte rights
Dialogue: 0,0:30:08.08,0:30:10.68,English,,0,0,0,,Calls to the low level right function
Dialogue: 0,0:30:12.80,0:30:16.64,English,,0,0,0,,And of course some way i could show you the reads and writes
Dialogue: 0,0:30:18.88,0:30:19.54,English,,0,0,0,,Let's try that
Dialogue: 0,0:30:25.18,0:30:29.70,English,,0,0,0,,And it's all confused because i'm i'm measuring this comes out on standard error
Dialogue: 0,0:30:30.16,0:30:34.64,English,,0,0,0,,But on the terminal it's sort of interleaving standard error and standard out so it's kind of messy to look at
Dialogue: 0,0:30:35.36,0:30:39.04,English,,0,0,0,,But again you can see that it's taking my characters
Dialogue: 0,0:30:39.50,0:30:42.12,English,,0,0,0,,And it's reading 1 and writing 1 in this loop
Dialogue: 0,0:30:48.76,0:30:53.44,English,,0,0,0,,So let's see ctrl-d to get out of it back to the code
Dialogue: 0,0:31:02.26,0:31:05.24,English,,0,0,0,,So what's this short count business why would that occur
Dialogue: 0,0:31:05.90,0:31:09.40,English,,0,0,0,,Well there's a couple ones as i mentioned if you counter an end-of-file
Dialogue: 0,0:31:09.66,0:31:13.58,English,,0,0,0,,You're not going to read in however many bytes you are given for the buffer
Dialogue: 0,0:31:15.08,0:31:18.52,English,,0,0,0,,If you are reading text lines from a terminal
Dialogue: 0,0:31:19.98,0:31:24.02,English,,0,0,0,,The terminal handler will just send a wine
Dialogue: 0,0:31:24.22,0:31:27.74,English,,0,0,0,,It's worth at a time with the newline character terminating it
Dialogue: 0,0:31:28.38,0:31:31.34,English,,0,0,0,,If you're reading or writing a network packet
Dialogue: 0,0:31:31.96,0:31:36.14,English,,0,0,0,,The way network packets work is that or messages
Dialogue: 0,0:31:36.14,0:31:39.48,English,,0,0,0,,If you have a big long message it's broken into smaller chunks
Dialogue: 0,0:31:42.86,0:31:45.38,English,,0,0,0,,Typically about a thousand bytes or so question
Dialogue: 0,0:31:45.38,0:31:52.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:52.66,0:31:56.68,English,,0,0,0,,If you are trying to read from an end-of-file return 0
Dialogue: 0,0:32:01.12,0:32:05.00,English,,0,0,0,,Um is that a short count it's a really short count yes but it's not a negative
Dialogue: 0,0:32:06.68,0:32:10.38,English,,0,0,0,,Yes so as it says here if you encounter an inter file
Dialogue: 0,0:32:11.54,0:32:14.86,English,,0,0,0,,It will actually there's two things actually it's a really good question
Dialogue: 0,0:32:15.28,0:32:21.08,English,,0,0,0,,If you're like near the end of a file you have a hundred bytes left and you say read 200
Dialogue: 0,0:32:22.14,0:32:24.32,English,,0,0,0,,Your first call to read will come back and
Dialogue: 0,0:32:24.78,0:32:28.56,English,,0,0,0,,Get 100 character it would say 100 and it will get that number
Dialogue: 0,0:32:29.12,0:32:32.80,English,,0,0,0,,And then you call again the second time and it will return zero
Dialogue: 0,0:32:33.18,0:32:36.28,English,,0,0,0,,And so that's how you actually detect the the true end of file
Dialogue: 0,0:32:36.78,0:32:41.08,English,,0,0,0,,As opposed to you know some other reason you might have gotten a short count is if that
Dialogue: 0,0:32:41.46,0:32:45.30,English,,0,0,0,,You actually get a read of 0 the only case you'll get at 4 is an end of file
Dialogue: 0,0:32:45.56,0:32:48.56,English,,0,0,0,,So that's a good question thanks
Dialogue: 0,0:32:50.08,0:32:55.98,English,,0,0,0,,So again if over the internet typically packets are round a thousand bytes
Dialogue: 0,0:32:55.98,0:33:02.36,English,,0,0,0,,It's actually depends on what where it's gone through what layers in the protocols it's gone through
Dialogue: 0,0:33:02.36,0:33:08.40,English,,0,0,0,,But 1500 bytes is actually the the standard what they call minimum transmission unit
Dialogue: 0,0:33:08.88,0:33:12.26,English,,0,0,0,,So if you have a big long file we'll come back in in blocks like that
Dialogue: 0,0:33:12.86,0:33:15.40,English,,0,0,0,,And if you're trying to read into a larger buffer
Dialogue: 0,0:33:15.88,0:33:18.71,English,,0,0,0,,It will typically come back in chunks
Dialogue: 0,0:33:19.12,0:33:24.44,English,,0,0,0,,Question
Dialogue: 0,0:33:25.92,0:33:27.38,English,,0,0,0,,No in other words you
Dialogue: 0,0:33:27.88,0:33:35.38,English,,0,0,0,,And again if you're writing code you shouldn't expect any number particularly it will be dependent on the implementation
Dialogue: 0,0:33:35.38,0:33:43.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:33:43.54,0:33:48.10,English,,0,0,0,,No because i'm only i'm only reading or writing one character at a time right
Dialogue: 0,0:33:49.42,0:33:57.70,English,,0,0,0,,So i guess you're asking what if i like spent a week typing characters in a really long string and hit return
Dialogue: 0,0:33:58.10,0:34:01.10,English,,0,0,0,,How to know if you try it let me know the answer
Dialogue: 0,0:34:03.90,0:34:09.20,English,,0,0,0,,But it won't cause an error but that part believe me they've really gone through that code a lot of times
Dialogue: 0,0:34:09.64,0:34:14.10,English,,0,0,0,,And and gotten rid of all those lurking buffer overflow vulnerabilities in the code
Dialogue: 0,0:34:15.00,0:34:17.04,English,,0,0,0,,But will let you do it i don't actually know but
Dialogue: 0,0:34:18.02,0:34:22.72,English,,0,0,0,,But within the you should write your code again expecting short counts as a possibility
Dialogue: 0,0:34:23.04,0:34:26.98,English,,0,0,0,,And by the way that's one of the the headaches of using this low-level i/o is
Dialogue: 0,0:34:27.40,0:34:32.14,English,,0,0,0,,Is dealing with short counts is not is often sort of a nuisance of an application level
Dialogue: 0,0:34:33.26,0:34:42.46,English,,0,0,0,,So you don't you usually package this up this kind of low-level file i/o into other libraries  that you're calling
Dialogue: 0,0:34:42.46,0:34:46.88,English,,0,0,0,,It's only where are we demonstrating this is the sort of lowest level in the stack
Dialogue: 0,0:34:52.26,0:34:55.22,English,,0,0,0,,And writing also can give you a short count
Dialogue: 0,0:34:55.32,0:35:01.32,English,,0,0,0,,For example if you're sending packets over a network it will only send as many as is that packet can hold
Dialogue: 0,0:35:01.90,0:35:06.80,English,,0,0,0,,And then return back to you and you have to keep pumping them out to send the different packets
Dialogue: 0,0:35:07.90,0:35:13.76,English,,0,0,0,,And so usually when you write code that uses this goal of while you have to anticipate these short counts
Dialogue: 0,0:35:15.90,0:35:21.64,English,,0,0,0,,So professor o'halloran wrote a package called rio
Dialogue: 0,0:35:22.06,0:35:27.52,English,,0,0,0,,And you'll for now we'll just talk about what this package is
Dialogue: 0,0:35:27.52,0:35:32.68,English,,0,0,0,,This is a package that you're really going to want to use for the final web for the course
Dialogue: 0,0:35:33.20,0:35:39.20,English,,0,0,0,,And so for right now it's more of a high-level here's an example of code that uses low-level i/o
Dialogue: 0,0:35:39.68,0:35:42.96,English,,0,0,0,,And packages up in a way that makes it a little bit more palatable
Dialogue: 0,0:35:43.84,0:35:47.36,English,,0,0,0,,So rio provides actually a number of different two different
Dialogue: 0,0:35:49.66,0:35:51.64,English,,0,0,0,,Well actually three
Dialogue: 0,0:35:52.48,0:36:00.60,English,,0,0,0,,Two different levels of of interface to the file this file i/o
Dialogue: 0,0:36:00.96,0:36:06.06,English,,0,0,0,,The lowest one is basically just a fairly small wrapper around
Dialogue: 0,0:36:08.46,0:36:12.00,English,,0,0,0,,The the existing the the i/o  reads and writes you saw
Dialogue: 0,0:36:12.46,0:36:14.60,English,,0,0,0,,That will handle the short count issue
Dialogue: 0,0:36:15.16,0:36:21.62,English,,0,0,0,,And so when you say with rio if you make a call to the read end function and you say some number of bytes
Dialogue: 0,0:36:22.40,0:36:27.08,English,,0,0,0,,Then that function will not return until it's read that number of bytes
Dialogue: 0,0:36:27.20,0:36:33.56,English,,0,0,0,,So better be careful that that that many bytes are there if it's a network socket or a file
Dialogue: 0,0:36:33.82,0:36:37.52,English,,0,0,0,,Well because it will flag an error message
Dialogue: 0,0:36:37.52,0:36:44.44,English,,0,0,0,,If it's what will actually hang up if it's a network connection  waiting to read the bytes
Dialogue: 0,0:36:45.18,0:36:49.08,English,,0,0,0,,Or return an error if it hits a none to file what it's not expecting
Dialogue: 0,0:36:49.64,0:36:54.02,English,,0,0,0,,And similarly with write n is sort of a wrapper around the write function
Dialogue: 0,0:36:54.36,0:36:59.34,English,,0,0,0,,That we'll deal with just loop until the short counts are taken care of
Dialogue: 0,0:37:00.70,0:37:06.26,English,,0,0,0,,And then there is a another class of of i/o that's called buffered i/o
Dialogue: 0,0:37:06.78,0:37:09.18,English,,0,0,0,,And this is what you really want to use in practice
Dialogue: 0,0:37:09.74,0:37:15.20,English,,0,0,0,,And what you mostly use with the standard unix io at functions
Dialogue: 0,0:37:15.72,0:37:20.26,English,,0,0,0,,Is it you want to within the the user code build up a little buffer of
Dialogue: 0,0:37:20.90,0:37:26.94,English,,0,0,0,,Of bytes that have either been read in but not yet consumed by the application program
Dialogue: 0,0:37:27.38,0:37:31.02,English,,0,0,0,,Or you accumulate some number of bytes in your program
Dialogue: 0,0:37:31.18,0:37:35.56,English,,0,0,0,,Before it's actually shoved out into the file or out onto the network
Dialogue: 0,0:37:38.12,0:37:46.90,English,,0,0,0,,And there's two versions of that one is a text oriented wine oriented i/o and the other is just a byte oriented i/o
Dialogue: 0,0:37:50.12,0:37:55.62,English,,0,0,0,,So let's go through the what the functions are and actually look at the code for them
Dialogue: 0,0:37:56.04,0:38:00.04,English,,0,0,0,,So as i mentioned the ones called read and write n are just very thin
Dialogue: 0,0:38:00.04,0:38:03.82,English,,0,0,0,,They have the same general semantics as the read and write
Dialogue: 0,0:38:04.32,0:38:06.12,English,,0,0,0,,But they deal with the short count issue
Dialogue: 0,0:38:06.98,0:38:09.68,English,,0,0,0,,So let's actually take a look at read n
Dialogue: 0,0:38:11.20,0:38:14.90,English,,0,0,0,,So again read n is given a file descriptor
Dialogue: 0,0:38:15.72,0:38:18.40,English,,0,0,0,,A destination buffer
Dialogue: 0,0:38:19.96,0:38:25.28,English,,0,0,0,,And a indication of how many characters
Dialogue: 0,0:38:25.52,0:38:29.24,English,,0,0,0,,How many bytes it's supposed to read and it's supposed to
Dialogue: 0,0:38:36.48,0:38:43.46,English,,0,0,0,,It's supposed to meet a return i guess it will return either a negative number if there's an error 0
Dialogue: 0,0:38:43.48,0:38:45.98,English,,0,0,0,,If it's at an end of file
Dialogue: 0,0:38:49.62,0:38:51.48,English,,0,0,0,,Or the number of bytes read
Dialogue: 0,0:38:51.48,0:38:55.70,English,,0,0,0,,So i guess i was a little bit i should have been more careful
Dialogue: 0,0:38:55.70,0:39:00.12,English,,0,0,0,,If it hits an end of file partway through it will return a short count
Dialogue: 0,0:39:00.74,0:39:03.74,English,,0,0,0,,But that's the only case it won't return a short count
Dialogue: 0,0:39:04.32,0:39:06.12,English,,0,0,0,,If if there really it could have read more bytes
Dialogue: 0,0:39:07.24,0:39:13.70,English,,0,0,0,,So the main loop here you see is it keeps calling read over and over again until it's happy
Dialogue: 0,0:39:14.72,0:39:18.18,English,,0,0,0,,Ah one way it can be happy as if it's read as many bytes
Dialogue: 0,0:39:18.44,0:39:21.86,English,,0,0,0,,As it was supposed to write read in the first place
Dialogue: 0,0:39:23.12,0:39:26.34,English,,0,0,0,,The other is that if it hits an error code
Dialogue: 0,0:39:28.52,0:39:29.70,English,,0,0,0,,And you'll notice that
Dialogue: 0,0:39:37.86,0:39:43.14,English,,0,0,0,,Oh and that there's some subtlety of tracking which type of error that is
Dialogue: 0,0:39:43.24,0:39:47.90,English,,0,0,0,,But in general the common cases it will return the negative number indicating an error
Dialogue: 0,0:39:49.62,0:39:54.46,English,,0,0,0,,If it if the number read is zero
Dialogue: 0,0:39:55.34,0:39:57.26,English,,0,0,0,,Then that indicated an into file
Dialogue: 0,0:39:58.36,0:40:02.94,English,,0,0,0,,And so what it will return is as many bytes as it's read
Dialogue: 0,0:40:03.30,0:40:05.04,English,,0,0,0,,So return the short count
Dialogue: 0,0:40:06.49,0:40:14.18,English,,0,0,0,,And here it's just saying okay i've read this number of bytes  and increment and decrement the right values
Dialogue: 0,0:40:14.24,0:40:20.04,English,,0,0,0,,So the point is it will keep looping keep doing reads until it either gets the number of bytes it should
Dialogue: 0,0:40:20.34,0:40:23.00,English,,0,0,0,,It hits an error or it encounters an end-of-file
Dialogue: 0,0:40:25.62,0:40:30.50,English,,0,0,0,,And you'll see it has its checking for all these different error conditions for every call
Dialogue: 0,0:40:32.72,0:40:35.30,English,,0,0,0,,It makes so this code by the way is sort of typical that
Dialogue: 0,0:40:35.74,0:40:40.60,English,,0,0,0,,It looks a little messy when you first look at it but if you sort of study it all makes sense
Dialogue: 0,0:40:43.08,0:40:46.18,English,,0,0,0,,Um so now let's talk about buffered i/o and
Dialogue: 0,0:40:46.38,0:40:49.00,English,,0,0,0,,What buffered i/o is and this is a very important concept
Dialogue: 0,0:40:49.10,0:40:51.44,English,,0,0,0,,So it's part of the reason we want to show you the code for it
Dialogue: 0,0:40:58.94,0:41:06.35,English,,0,0,0,,So the idea of buffered i/o is that there's a buffer meaning just an
Dialogue: 0,0:41:06.86,0:41:09.16,English,,0,0,0,,Array of byte character's array of bytes
Dialogue: 0,0:41:09.64,0:41:14.58,English,,0,0,0,,They're allocated and associated with this particular file
Dialogue: 0,0:41:15.34,0:41:20.16,English,,0,0,0,,And the program if it's on to read what it will do is it will fill up
Dialogue: 0,0:41:20.58,0:41:24.64,English,,0,0,0,,This buffer if it will give a read with a much larger number
Dialogue: 0,0:41:24.86,0:41:29.20,English,,0,0,0,,With a large number basically the size of the actual
Dialogue: 0,0:41:29.68,0:41:32.32,English,,0,0,0,,How much memory you've allocated for this buffer
Dialogue: 0,0:41:33.00,0:41:38.34,English,,0,0,0,,And the system will fill that up with  up to that number of characters
Dialogue: 0,0:41:39.10,0:41:44.70,English,,0,0,0,,And then when the user program wants to now look at this get some bytes
Dialogue: 0,0:41:45.10,0:41:49.94,English,,0,0,0,,It will first check do i already have some in the buffer that haven't been read yet
Dialogue: 0,0:41:50.36,0:41:52.08,English,,0,0,0,,And if so i'll just return those
Dialogue: 0,0:41:53.42,0:41:56.08,English,,0,0,0,,Ah and if not then i'll refill the buffer
Dialogue: 0,0:41:56.32,0:42:00.92,English,,0,0,0,,So the idea of it is instead of every time going to the operating system
Dialogue: 0,0:42:00.92,0:42:03.88,English,,0,0,0,,And asking for one character small number of characters
Dialogue: 0,0:42:05.02,0:42:11.78,English,,0,0,0,,The called the operating system says give me pretty much as many characters as you've got up to some limit
Dialogue: 0,0:42:12.68,0:42:16.36,English,,0,0,0,,And then i'll just go away and what the application program
Dialogue: 0,0:42:16.50,0:42:20.76,English,,0,0,0,,I sort of pull these out a couple bytes at a time
Dialogue: 0,0:42:21.22,0:42:25.80,English,,0,0,0,,But i won't bug the operating system to do it i being the real function
Dialogue: 0,0:42:27.00,0:42:32.52,English,,0,0,0,,And the way it does it is by just keeping a pointer  of that indicates
Dialogue: 0,0:42:32.96,0:42:35.26,English,,0,0,0,,What part of the the bytes
Dialogue: 0,0:42:35.42,0:42:42.28,English,,0,0,0,,That i've already brought in from the operating system call
Dialogue: 0,0:42:42.66,0:42:46.16,English,,0,0,0,,But the haven't been supplied yet to the application program
Dialogue: 0,0:42:46.74,0:42:52.52,English,,0,0,0,,And so in this sort of larger picture of things if you imagine you're you're walking through a file
Dialogue: 0,0:42:54.38,0:43:00.20,English,,0,0,0,,At any given point in time this buffer will represent some a range of in that file
Dialogue: 0,0:43:00.56,0:43:05.24,English,,0,0,0,,Where the green is the stuff that's already been read by the application program
Dialogue: 0,0:43:05.82,0:43:08.64,English,,0,0,0,,The pink is the stuff that's been read
Dialogue: 0,0:43:09.00,0:43:11.56,English,,0,0,0,,But from the operating system out of file
Dialogue: 0,0:43:12.00,0:43:14.68,English,,0,0,0,,But not yet read by the application program
Dialogue: 0,0:43:16.88,0:43:20.30,English,,0,0,0,,And the way this is implemented once you think about
Dialogue: 0,0:43:20.36,0:43:22.18,English,,0,0,0,,It it's not too hard to do is
Dialogue: 0,0:43:22.46,0:43:29.88,English,,0,0,0,,It associated with every file connection then is a file descriptor
Dialogue: 0,0:43:31.48,0:43:34.60,English,,0,0,0,,Account that tells you how many bytes
Dialogue: 0,0:43:35.32,0:43:38.16,English,,0,0,0,,There are that have not been read yet
Dialogue: 0,0:43:39.34,0:43:46.68,English,,0,0,0,,A a pointer to where this this changeover is
Dialogue: 0,0:43:47.20,0:43:52.98,English,,0,0,0,,And then the actual storage of the the buffer itself
Dialogue: 0,0:43:53.02,0:43:56.18,English,,0,0,0,,The characters allocated the bytes allocated to the buffer itself
Dialogue: 0,0:44:00.38,0:44:07.44,English,,0,0,0,,And so here's an example then of of using rio to do this
Dialogue: 0,0:44:07.44,0:44:17.78,English,,0,0,0,,Echo that you first read online and reading a line means it will look for and stop at a line feed character
Dialogue: 0,0:44:18.68,0:44:23.42,English,,0,0,0,,And writing it back out and again if you do the demo
Dialogue: 0,0:44:31.22,0:44:32.42,English,,0,0,0,,Of this code
Dialogue: 0,0:44:48.96,0:44:56.64,English,,0,0,0,,It's a little again you get let me just trace rights cuz it's a little hard to see the reeds are hard to figure out with...
Dialogue: 0,0:45:04.94,0:45:06.64,English,,0,0,0,,So you'll see that it
Dialogue: 0,0:45:08.94,0:45:13.34,English,,0,0,0,,Read the whole line and now it's done to add the operating system level
Dialogue: 0,0:45:13.74,0:45:21.34,English,,0,0,0,,It's written just one chunks worth one call to the operating systems write function
Dialogue: 0,0:45:25.48,0:45:27.66,English,,0,0,0,,Instead of a byte by byte
Dialogue: 0,0:45:38.92,0:45:42.18,English,,0,0,0,,Okay so again i'm not going to go through all the code
Dialogue: 0,0:45:42.18,0:45:45.16,English,,0,0,0,,But it's actually worth your while to do this
Dialogue: 0,0:45:45.58,0:45:51.82,English,,0,0,0,,And by the way i've actually done some applications where i took the real code i want to add some features to it
Dialogue: 0,0:45:52.42,0:45:57.66,English,,0,0,0,,But it's a very useful starting point to be able to build your own customized routines
Dialogue: 0,0:45:59.42,0:46:02.24,English,,0,0,0,,Okay so let's talk about some other parts of files
Dialogue: 0,0:46:04.02,0:46:08.70,English,,0,0,0,,One is that associated with a file is what they call metadata
Dialogue: 0,0:46:10.08,0:46:14.56,English,,0,0,0,,So the data are the actual contents of the file actual bytes inside that file
Dialogue: 0,0:46:14.96,0:46:18.40,English,,0,0,0,,But there's a whole bunch of other stuff that's associated with the file
Dialogue: 0,0:46:20.02,0:46:22.22,English,,0,0,0,,Information about what type of file it is
Dialogue: 0,0:46:22.74,0:46:27.30,English,,0,0,0,,What protection read/write/execute protections it has
Dialogue: 0,0:46:30.06,0:46:33.64,English,,0,0,0,,Some information about the ownership of that file
Dialogue: 0,0:46:34.04,0:46:39.46,English,,0,0,0,,What type it is and also the times associated with it
Dialogue: 0,0:46:39.46,0:46:44.08,English,,0,0,0,,When was it created when was it last accessed in when was the west notified
Dialogue: 0,0:46:44.66,0:46:51.38,English,,0,0,0,,So that's known as a metadata and every a file has that kind of information associated with it
Dialogue: 0,0:46:51.94,0:46:55.50,English,,0,0,0,,And you can actually and it's in a data structure called a step
Dialogue: 0,0:46:59.10,0:47:00.25,English,,0,0,0,,Data structure
Dialogue: 0,0:47:00.68,0:47:11.88,English,,0,0,0,,And you can if you want to write code that then sort of probes the directory structure of a of a file system
Dialogue: 0,0:47:12.38,0:47:15.06,English,,0,0,0,,You can make a call to the stat function
Dialogue: 0,0:47:15.18,0:47:20.08,English,,0,0,0,,And it's given the the path name of the file you want to stat
Dialogue: 0,0:47:20.66,0:47:27.34,English,,0,0,0,,And then a a pointer to it one of these step data structures and then that
Dialogue: 0,0:47:27.96,0:47:32.50,English,,0,0,0,,Our data structure will get filled in by the information for this particular file
Dialogue: 0,0:47:32.90,0:47:36.86,English,,0,0,0,,And then you can test various attributes about that file
Dialogue: 0,0:47:37.30,0:47:41.32,English,,0,0,0,,And see basically get the information that
Dialogue: 0,0:47:42.10,0:47:44.48,English,,0,0,0,,That's stored here
Dialogue: 0,0:47:44.58,0:47:47.78,English,,0,0,0,,And there's all these nasty compile time constants
Dialogue: 0,0:47:47.90,0:47:57.20,English,,0,0,0,,That you use or macros that use to look at and examine these these metadata
Dialogue: 0,0:48:04.70,0:48:07.18,English,,0,0,0,,So here's an example i will do it but
Dialogue: 0,0:48:07.20,0:48:10.98,English,,0,0,0,,But it's a function called stat check it's in the same directory
Dialogue: 0,0:48:11.54,0:48:16.30,English,,0,0,0,,And so if you check some file or typically say well it's a regular file
Dialogue: 0,0:48:16.84,0:48:18.92,English,,0,0,0,,And yes you're allowed to read it
Dialogue: 0,0:48:19.34,0:48:28.46,English,,0,0,0,,But now if i a to call chmod to eliminate set all the protections to zero
Dialogue: 0,0:48:28.76,0:48:30.76,English,,0,0,0,,It'll say no you can't read it now
Dialogue: 0,0:48:32.90,0:48:37.72,English,,0,0,0,,And so again that's just making use of this data here
Dialogue: 0,0:48:39.46,0:48:44.04,English,,0,0,0,,So now this is the part that gets a lot more tricky
Dialogue: 0,0:48:44.46,0:48:49.74,English,,0,0,0,,Is how our files how are all this information about file is actually represented by the programs
Dialogue: 0,0:48:49.78,0:49:06.64,English,,0,0,0,,Question yes stat gist
Dialogue: 0,0:49:07.82,0:49:10.40,English,,0,0,0,,I'll tell you one way you can find out what step does
Dialogue: 0,0:49:13.32,0:49:15.24,English,,0,0,0,,If you say man 2 step
Dialogue: 0,0:49:16.58,0:49:18.80,English,,0,0,0,,You'll get more than you want to know
Dialogue: 0,0:49:19.42,0:49:22.96,English,,0,0,0,,So in general you know if you say man's debt
Dialogue: 0,0:49:27.10,0:49:33.08,English,,0,0,0,,It'll give a unix of command that you can use to step a file
Dialogue: 0,0:49:33.74,0:49:36.26,English,,0,0,0,,So i can say stat
Dialogue: 0,0:49:39.94,0:49:43.28,English,,0,0,0,,Top and it will print out some information about a file
Dialogue: 0,0:49:45.56,0:49:48.52,English,,0,0,0,,In this case my local directory let's see
Dialogue: 0,0:49:51.66,0:49:54.32,English,,0,0,0,,I can stat any file
Dialogue: 0,0:49:54.88,0:49:59.60,English,,0,0,0,,Here and it will print out some some cryptic information about it
Dialogue: 0,0:50:01.94,0:50:04.12,English,,0,0,0,,But if you say man 2 stat
Dialogue: 0,0:50:04.82,0:50:09.08,English,,0,0,0,,The unix man pages are divided into different categories
Dialogue: 0,0:50:10.34,0:50:13.00,English,,0,0,0,,And things that our system calls
Dialogue: 0,0:50:13.76,0:50:20.00,English,,0,0,0,,Unix system library calls are typically in section 2 of the man pages
Dialogue: 0,0:50:20.78,0:50:22.97,English,,0,0,0,,And so that will return information about it
Dialogue: 0,0:50:23.48,0:50:28.74,English,,0,0,0,,But the main point of it is stat is then a function that you call
Dialogue: 0,0:50:28.74,0:50:32.38,English,,0,0,0,,Where you give it a path name and a pointer to a buffer that you want it
Dialogue: 0,0:50:33.00,0:50:41.94,English,,0,0,0,,And it will then fill in the contents the buffer with the information about that particular file
Dialogue: 0,0:50:42.62,0:50:49.26,English,,0,0,0,,And the form that it fills it in is one of these data structures called a struct step
Dialogue: 0,0:50:50.64,0:50:57.10,English,,0,0,0,,And that's pretty typical of a lot of these functions is that they have some predefined struct
Dialogue: 0,0:50:57.96,0:51:01.96,English,,0,0,0,,And if you want to get the if you want to get information you pat
Dialogue: 0,0:51:01.96,0:51:05.02,English,,0,0,0,,You allocate one of those struts you pass a pointer to it
Dialogue: 0,0:51:05.46,0:51:08.38,English,,0,0,0,,And then the library function will fill in the details
Dialogue: 0,0:51:09.30,0:51:11.28,English,,0,0,0,,Does that make sense okay
Dialogue: 0,0:51:23.46,0:51:28.76,English,,0,0,0,,Okay so now let's look at some of the internal data structures that
Dialogue: 0,0:51:29.47,0:51:34.14,English,,0,0,0,,The operating system maintains regarding the files associated with a program
Dialogue: 0,0:51:34.60,0:51:39.10,English,,0,0,0,,And this is a source of really nasty exam problems
Dialogue: 0,0:51:39.10,0:51:44.18,English,,0,0,0,,I'll just warn you so you're going to want to read this part of the book carefully
Dialogue: 0,0:51:44.78,0:51:47.66,English,,0,0,0,,Study the practice problems look at the old exams
Dialogue: 0,0:51:47.66,0:51:51.92,English,,0,0,0,,Because i can guarantee you you're going to get some of these on the final that's a promise
Dialogue: 0,0:51:53.02,0:51:56.16,English,,0,0,0,,And they can be infinitely obscure so
Dialogue: 0,0:51:56.98,0:51:58.94,English,,0,0,0,,We can we can torch you with these
Dialogue: 0,0:51:59.84,0:52:06.12,English,,0,0,0,,So that the main point is that associated with any executing process
Dialogue: 0,0:52:06.16,0:52:09.70,English,,0,0,0,,Which you can think of a process is a running program
Dialogue: 0,0:52:11.16,0:52:17.32,English,,0,0,0,,Is a something called the descriptor table
Dialogue: 0,0:52:17.90,0:52:19.46,English,,0,0,0,,And what that contains is
Dialogue: 0,0:52:19.94,0:52:23.12,English,,0,0,0,,For every open file that you have
Dialogue: 0,0:52:24.02,0:52:28.30,English,,0,0,0,,It has a pointer to a data structure called
Dialogue: 0,0:52:29.32,0:52:34.04,English,,0,0,0,,An entry in a table that's maintained by the operating system globally
Dialogue: 0,0:52:36.66,0:52:41.52,English,,0,0,0,,Which describes each of the open files
Dialogue: 0,0:52:42.30,0:52:48.16,English,,0,0,0,,Actually each of every time a file is opened
Dialogue: 0,0:52:48.40,0:52:53.90,English,,0,0,0,,That allocates a record in this open file table
Dialogue: 0,0:52:56.38,0:53:02.58,English,,0,0,0,,And so as i mentioned file descriptor 0 1 and 2 have specific  meanings
Dialogue: 0,0:53:03.14,0:53:09.74,English,,0,0,0,,And the other files are other ones that you've opened up during the course of your program execution and have not yet closed
Dialogue: 0,0:53:11.00,0:53:20.23,English,,0,0,0,,So that's so each of these then is a reference to a particular open file
Dialogue: 0,0:53:20.60,0:53:23.58,English,,0,0,0,,And it gives information about that file
Dialogue: 0,0:53:24.54,0:53:27.16,English,,0,0,0,,And it also gives the position in the file that
Dialogue: 0,0:53:27.30,0:53:30.62,English,,0,0,0,,Currently is that i told you every time you open a file there's
Dialogue: 0,0:53:31.16,0:53:32.50,English,,0,0,0,,A for a regular file at least
Dialogue: 0,0:53:32.94,0:53:37.68,English,,0,0,0,,There's an associated position of where in the file was your last reader right
Dialogue: 0,0:53:38.46,0:53:40.10,English,,0,0,0,,Or where would you be your next reader right
Dialogue: 0,0:53:41.34,0:53:42.64,English,,0,0,0,,And so that's the file pause
Dialogue: 0,0:53:44.10,0:53:49.32,English,,0,0,0,,And there's also a reference count which is used by the operating system to keep track of
Dialogue: 0,0:53:50.90,0:53:57.50,English,,0,0,0,,Because we'll see it's possible to have multiple  multiple processes sharing
Dialogue: 0,0:53:58.50,0:54:00.90,English,,0,0,0,,An entry in this open file table and
Dialogue: 0,0:54:01.20,0:54:06.66,English,,0,0,0,,It uses this reference count which is standard way of keeping track of memory allocation
Dialogue: 0,0:54:07.32,0:54:13.24,English,,0,0,0,,To know when it no longer needs that entry if when there's been enough
Dialogue: 0,0:54:14.92,0:54:20.18,English,,0,0,0,,When the file is no longer accessible and therefore this entry is not needed
Dialogue: 0,0:54:21.74,0:54:27.32,English,,0,0,0,,So for every one of your open files that will have an entry in this table
Dialogue: 0,0:54:27.50,0:54:31.40,English,,0,0,0,,And this table as i said is shared across the whole operating system
Dialogue: 0,0:54:32.90,0:54:38.26,English,,0,0,0,,And then associated with every file is called a v node
Dialogue: 0,0:54:38.40,0:54:40.20,English,,0,0,0,,Which stands for virtual node
Dialogue: 0,0:54:40.50,0:54:46.64,English,,0,0,0,,And this is where that contains the sort of information about this file
Dialogue: 0,0:54:46.90,0:54:53.60,English,,0,0,0,,In particular where is it stored on this information that you can get from stat and things like that
Dialogue: 0,0:54:54.84,0:54:58.82,English,,0,0,0,,How big it is and things like that
Dialogue: 0,0:54:59.72,0:55:06.86,English,,0,0,0,,So that's for every every file in the system actually has a v node entry
Dialogue: 0,0:55:07.26,0:55:08.67,English,,0,0,0,,Whether it's open or closed
Dialogue: 0,0:55:09.56,0:55:11.72,English,,0,0,0,,Now this can get complicated
Dialogue: 0,0:55:12.88,0:55:17.74,English,,0,0,0,,So for example if within a single program you call open twice on the same function
Dialogue: 0,0:55:19.02,0:55:21.40,English,,0,0,0,,You'll actually get two different file descriptors
Dialogue: 0,0:55:22.82,0:55:28.80,English,,0,0,0,,And you'll be able to access that same file  and have two different positions in it
Dialogue: 0,0:55:28.94,0:55:34.32,English,,0,0,0,,Then it makes sense if you imagine you're reading from a file
Dialogue: 0,0:55:35.42,0:55:41.16,English,,0,0,0,,And you might want to read from two different positions in that file
Dialogue: 0,0:55:41.16,0:55:44.40,English,,0,0,0,,Within the same program and you can do that that's perfectly legal
Dialogue: 0,0:55:45.06,0:55:50.16,English,,0,0,0,,You just call open twice and that will keep track of two different positions
Dialogue: 0,0:55:51.54,0:55:55.89,English,,0,0,0,,So the point is these file descriptors might be referring to the same file
Dialogue: 0,0:55:56.34,0:55:58.98,English,,0,0,0,,But they're actually at different positions within the file
Dialogue: 0,0:55:59.34,0:56:05.38,English,,0,0,0,,And that can happen also if you're if you've opened a file for both reading and for writing
Dialogue: 0,0:56:05.74,0:56:11.18,English,,0,0,0,,And you're writing ahead and then reading characters bytes that have already been written
Dialogue: 0,0:56:12.04,0:56:12.90,English,,0,0,0,,That makes sense
Dialogue: 0,0:56:13.42,0:56:17.22,English,,0,0,0,,It's not such a good idea to have two different write
Dialogue: 0,0:56:18.32,0:56:24.50,English,,0,0,0,,File opens that are writing simultaneously you can mess up the file pretty badly that way
Dialogue: 0,0:56:24.92,0:56:27.86,English,,0,0,0,,But there's nothing in the operating system that prevents you from doing that
Dialogue: 0,0:56:28.82,0:56:34.66,English,,0,0,0,,So it won't it's not a good idea but it's a legal operation
Dialogue: 0,0:56:35.84,0:56:41.88,English,,0,0,0,,So that's the point is you have to distinguish at what level is sharing taking place and you see that
Dialogue: 0,0:56:43.89,0:56:53.20,English,,0,0,0,,If you have two different oh table entries sharing one file
Dialogue: 0,0:56:53.64,0:56:57.88,English,,0,0,0,,Then that what's different there is that you can be working at different file positions
Dialogue: 0,0:57:00.68,0:57:04.20,English,,0,0,0,,Uh similarly of course the more common thing is
Dialogue: 0,0:57:06.30,0:57:09.85,English,,0,0,0,,You have two different open files in there refer to different files
Dialogue: 0,0:57:10.74,0:57:13.48,English,,0,0,0,,But now and this is where life gets exciting
Dialogue: 0,0:57:13.98,0:57:18.46,English,,0,0,0,,If you call fork you remember about fork that it spawns a child
Dialogue: 0,0:57:19.86,0:57:23.88,English,,0,0,0,,But that child inherits a lot of information from its parent
Dialogue: 0,0:57:23.98,0:57:25.58,English,,0,0,0,,And one of the things it inherits
Dialogue: 0,0:57:26.22,0:57:30.28,English,,0,0,0,,Is its descriptor table it gets a replica of that descriptor table
Dialogue: 0,0:57:31.54,0:57:34.09,English,,0,0,0,,And so now both the parent and the child
Dialogue: 0,0:57:34.88,0:57:38.94,English,,0,0,0,,Have identical entries in their descriptor table
Dialogue: 0,0:57:38.94,0:57:40.78,English,,0,0,0,,And so they're sharing files
Dialogue: 0,0:57:41.32,0:57:45.06,English,,0,0,0,,But not at the file level but at the open file table
Dialogue: 0,0:57:45.72,0:57:49.18,English,,0,0,0,,And what that means is if the parent does a read
Dialogue: 0,0:57:49.66,0:57:51.94,English,,0,0,0,,It'll bump along the file position
Dialogue: 0,0:57:52.44,0:57:54.18,English,,0,0,0,,And if the child now doesn't read
Dialogue: 0,0:57:55.22,0:57:59.16,English,,0,0,0,,It will it will see oh this from this new position
Dialogue: 0,0:57:59.72,0:58:02.58,English,,0,0,0,,So you can see why the exam problems get really interesting
Dialogue: 0,0:58:03.29,0:58:08.44,English,,0,0,0,,That will keep track of all these different possibilities
Dialogue: 0,0:58:08.86,0:58:09.98,English,,0,0,0,,And they'll do different things
Dialogue: 0,0:58:11.82,0:58:14.28,English,,0,0,0,,And so
Dialogue: 0,0:58:14.82,0:58:19.02,English,,0,0,0,,And then of course the parent or the child can start opening and closing their own files as well
Dialogue: 0,0:58:19.02,0:58:20.64,English,,0,0,0,,And that will get very messy
Dialogue: 0,0:58:21.16,0:58:25.10,English,,0,0,0,,And here's what you see the reason for having reference counts here that
Dialogue: 0,0:58:26.64,0:58:29.68,English,,0,0,0,,If you have a lot of forking going on
Dialogue: 0,0:58:30.66,0:58:36.64,English,,0,0,0,,Then you can create multiple pointers to this a table entry
Dialogue: 0,0:58:37.14,0:58:44.20,English,,0,0,0,,And in order to really really close the file each of these has to call closed
Dialogue: 0,0:58:45.60,0:58:50.38,English,,0,0,0,,Before the file is truly truly closed from an operating system perspective
Dialogue: 0,0:58:55.52,0:59:03.58,English,,0,0,0,,So there's other fun things that make a wife interesting too and contribute to the exam problem possibilities
Dialogue: 0,0:59:04.08,0:59:05.90,English,,0,0,0,,What is it called called dup2
Dialogue: 0,0:59:06.98,0:59:09.48,English,,0,0,0,,And the purpose the dup2 is -
Dialogue: 0,0:59:13.16,0:59:20.04,English,,0,0,0,,Excuse me duplicate a.m. entry in the descriptor table
Dialogue: 0,0:59:20.68,0:59:29.14,English,,0,0,0,,And the most common use of that is is a io redirection the either greater or less than sign to either
Dialogue: 0,0:59:29.36,0:59:33.18,English,,0,0,0,,Redirect read the instead of from standard input from the file
Dialogue: 0,0:59:34.02,0:59:38.22,English,,0,0,0,,Or instead of writing to standard output to write to a file
Dialogue: 0,0:59:38.86,0:59:43.76,English,,0,0,0,,And the way the operating system actually implements that is shortly after starting the program
Dialogue: 0,0:59:44.42,0:59:46.50,English,,0,0,0,,It will call called dup2
Dialogue: 0,0:59:48.52,1:00:01.30,English,,0,0,0,,To make it so that the file descriptor 1 is not the standard output of the for this process
Dialogue: 0,1:00:01.34,1:00:04.74,English,,0,0,0,,But it's actually the original standard output
Dialogue: 0,1:00:04.74,1:00:09.56,English,,0,0,0,,But it's actually a descriptor for the file that it's supposed to write
Dialogue: 0,1:00:09.88,1:00:12.24,English,,0,0,0,,And same width of it's doing input redirection
Dialogue: 0,1:00:14.16,1:00:16.40,English,,0,0,0,,And but you can call dup2 yourself
Dialogue: 0,1:00:16.90,1:00:20.60,English,,0,0,0,,And do these kind of things and there's actually good reasons for doing so
Dialogue: 0,1:00:26.88,1:00:29.50,English,,0,0,0,,So in particular imagine i open the file
Dialogue: 0,1:00:29.92,1:00:33.94,English,,0,0,0,,And standard output points to the sort of normal thing
Dialogue: 0,1:00:36.84,1:00:40.28,English,,0,0,0,,And i open a new file i call it b
Dialogue: 0,1:00:41.18,1:00:42.58,English,,0,0,0,,And then i call dup2
Dialogue: 0,1:00:42.96,1:00:43.52,English,,0,0,0,,Excuse me
Dialogue: 0,1:00:44.04,1:00:48.54,English,,0,0,0,,And now what both file descriptor 1 and file descriptor for are sharing
Dialogue: 0,1:00:48.92,1:00:52.68,English,,0,0,0,,This entry in the file table and you see the reference count of 2
Dialogue: 0,1:00:53.90,1:00:56.50,English,,0,0,0,,And so in order to really close it then
Dialogue: 0,1:00:56.88,1:01:02.34,English,,0,0,0,,What would typically happen at this point is the this has happens before
Dialogue: 0,1:01:02.34,1:01:06.02,English,,0,0,0,,It starts to your program you'd want to close file descriptor for
Dialogue: 0,1:01:10.30,1:01:15.18,English,,0,0,0,,And in fact there's a lot of bugs you can make by not closing files
Dialogue: 0,1:01:15.60,1:01:19.80,English,,0,0,0,,It's easy to make mistakes when you have multiple entries in these tables
Dialogue: 0,1:01:19.90,1:01:25.32,English,,0,0,0,,Yes
Dialogue: 0,1:01:25.42,1:01:30.70,English,,0,0,0,,/no see if i call closed this one it just decrements this reference count
Dialogue: 0,1:01:31.16,1:01:33.02,English,,0,0,0,,But this remains a valid entry here
Dialogue: 0,1:01:33.02,1:01:38.70,English,,0,0,0,,[student speaking]
Dialogue: 0,1:01:38.74,1:01:48.48,English,,0,0,0,,Yes but dupe 2 will decrement the reference count of the original
Dialogue: 0,1:01:51.52,1:01:54.72,English,,0,0,0,,So it's dup2 goes backwards from where you think it should
Dialogue: 0,1:01:57.74,1:01:59.22,English,,0,0,0,,So dup2 is the
Dialogue: 0,1:02:01.54,1:02:06.78,English,,0,0,0,,I want what what i referred to for example file descriptor
Dialogue: 0,1:02:08.86,1:02:15.46,English,,0,0,0,,I want file descriptor for to become what i can use to and refer to with file descriptor 1 here
Dialogue: 0,1:02:16.14,1:02:19.12,English,,0,0,0,,It will actually decrement the reference count
Dialogue: 0,1:02:19.76,1:02:23.70,English,,0,0,0,,Of this before it it done does the copy
Dialogue: 0,1:02:24.76,1:02:32.52,English,,0,0,0,,Otherwise it would create like a an orphan in this table right
Dialogue: 0,1:02:37.22,1:02:43.40,English,,0,0,0,,Um so anyways dup2 also is a powerful but dangerous mechanism
Dialogue: 0,1:02:44.96,1:02:49.58,English,,0,0,0,,So now finally let me just mention the much more common i/o that
Dialogue: 0,1:02:49.96,1:02:51.49,English,,0,0,0,,Application programs use
Dialogue: 0,1:02:51.92,1:02:56.14,English,,0,0,0,,Is what's known as the standard i/o and that's what's documented in k&r and
Dialogue: 0,1:02:56.20,1:02:59.16,English,,0,0,0,,It's actually part of the the c standard
Dialogue: 0,1:02:59.36,1:03:01.14,English,,0,0,0,,All these different functions
Dialogue: 0,1:03:01.54,1:03:08.38,English,,0,0,0,,And so the main feature it adds is sort of like what you saw with the reo package it adds buffering
Dialogue: 0,1:03:09.46,1:03:11.60,English,,0,0,0,,So it doesn't have to do this low-level stuff
Dialogue: 0,1:03:12.00,1:03:14.28,English,,0,0,0,,And it voids all than some of the nastiness
Dialogue: 0,1:03:19.16,1:03:26.46,English,,0,0,0,,And the the way it works is what we've already seen it uses buffering to do the i/o
Dialogue: 0,1:03:27.60,1:03:30.80,English,,0,0,0,,So just in it is an example
Dialogue: 0,1:03:45.30,1:03:48.14,English,,0,0,0,,Here's some code that calls printf
Dialogue: 0,1:03:48.74,1:03:51.82,English,,0,0,0,,One character at a time to print the word hello
Dialogue: 0,1:03:54.22,1:03:57.20,English,,0,0,0,,But if i run that and is trace it
Dialogue: 0,1:04:06.02,1:04:09.36,English,,0,0,0,,You see that there's only one system call to 2 right
Dialogue: 0,1:04:09.76,1:04:12.16,English,,0,0,0,,And it works the same way you saw with the real code
Dialogue: 0,1:04:12.72,1:04:17.70,English,,0,0,0,,It builds up a buffer and it's not until this call to f flush
Dialogue: 0,1:04:18.96,1:04:23.56,English,,0,0,0,,That forces the output to actually be a printed output
Dialogue: 0,1:04:24.36,1:04:32.10,English,,0,0,0,,Usually that happens automatically actually if you print f up a line feed it will flush it
Dialogue: 0,1:04:33.08,1:04:36.52,English,,0,0,0,,So but that i think that call to f wash is probably redundant here
Dialogue: 0,1:04:44.16,1:04:53.10,English,,0,0,0,,So and so that's the benefit so buffered i/o is much more efficient
Dialogue: 0,1:04:53.10,1:04:55.60,English,,0,0,0,,Because it because of the buffering
Dialogue: 0,1:05:00.76,1:05:07.12,English,,0,0,0,,So as a result we've now seen three different types of i/o
Dialogue: 0,1:05:07.12,1:05:11.74,English,,0,0,0,,There's the low-level i/o called you referred to as unix i/o
Dialogue: 0,1:05:12.12,1:05:16.40,English,,0,0,0,,You saw this package that was written specifically for the book and for the course called rio
Dialogue: 0,1:05:16.80,1:05:18.74,English,,0,0,0,,And then there's a much larger
Dialogue: 0,1:05:19.14,1:05:21.67,English,,0,0,0,,And in fact richer set of i/o functions
Dialogue: 0,1:05:22.10,1:05:25.50,English,,0,0,0,,Provided by the unix standard library
Dialogue: 0,1:05:26.10,1:05:31.86,English,,0,0,0,,So you might ask a couple questions one is why the heck did you write this when you've already got that
Dialogue: 0,1:05:32.80,1:05:36.46,English,,0,0,0,,If if unix provides buffered i/o why did you do it yourself
Dialogue: 0,1:05:36.98,1:05:40.98,English,,0,0,0,,And the reason is this stuff doesn't it works really well for
Dialogue: 0,1:05:41.54,1:05:44.76,English,,0,0,0,,The i/o you do to a terminal or to files
Dialogue: 0,1:05:45.18,1:05:47.62,English,,0,0,0,,But it doesn't do very well with network connections
Dialogue: 0,1:05:47.90,1:05:52.46,English,,0,0,0,,It wasn't really designed for that and so it gets really messed up
Dialogue: 0,1:05:52.86,1:05:57.96,English,,0,0,0,,And so the main reason you're going to find yourself using this is when you're starting to use network connections
Dialogue: 0,1:05:59.04,1:06:05.62,English,,0,0,0,,The other thing is these do not coexist very well buffered i/o with a rio i/o
Dialogue: 0,1:06:05.62,1:06:09.60,English,,0,0,0,,Because they each maintain their own buffers and they don't know about each other
Dialogue: 0,1:06:09.96,1:06:11.40,English,,0,0,0,,And they get terribly confused
Dialogue: 0,1:06:11.88,1:06:16.88,English,,0,0,0,,So you kind of have to pick one or the other with respect to any particular i/o connection
Dialogue: 0,1:06:17.16,1:06:18.86,English,,0,0,0,,And don't try to mix and match them
Dialogue: 0,1:06:22.38,1:06:29.42,English,,0,0,0,,So like i said unix i/o then the low-level stuff from an application perspective
Dialogue: 0,1:06:29.42,1:06:33.92,English,,0,0,0,,It's like really painful to use especially with short counts and error codes
Dialogue: 0,1:06:34.58,1:06:35.70,English,,0,0,0,,And and all that stuff and
Dialogue: 0,1:06:38.92,1:06:43.86,English,,0,0,0,,So in general you want to either write your own package or use some other package around it
Dialogue: 0,1:06:44.40,1:06:49.84,English,,0,0,0,,And so as i said standard i/o it gives you printf and scanf and all these nice features
Dialogue: 0,1:06:50.10,1:06:52.84,English,,0,0,0,,It's uniform it exists on all systems
Dialogue: 0,1:06:53.34,1:06:55.10,English,,0,0,0,,It's reasonably standardized
Dialogue: 0,1:07:01.02,1:07:06.34,English,,0,0,0,,So in general then use the the standard i/o for most year
Dialogue: 0,1:07:06.40,1:07:09.18,English,,0,0,0,,Day-to-day uses of files
Dialogue: 0,1:07:10.60,1:07:15.64,English,,0,0,0,,I'll use a raw io for low-level stuff like when you have to
Dialogue: 0,1:07:16.10,1:07:19.42,English,,0,0,0,,And partly it turns out signals are not
Dialogue: 0,1:07:20.16,1:07:23.68,English,,0,0,0,,You shouldn't use standard i/o when you're writing signal handlers
Dialogue: 0,1:07:24.32,1:07:29.00,English,,0,0,0,,And then the reo you're going to find useful for in pre curricular for doing networking
Dialogue: 0,1:07:29.92,1:07:38.28,English,,0,0,0,,One other thing that you should one bug that students do over and over again in this course
Dialogue: 0,1:07:38.84,1:07:44.50,English,,0,0,0,,Is they try to do a line oriented i/o on things that aren't lines
Dialogue: 0,1:07:45.02,1:07:47.42,English,,0,0,0,,So like a jpeg image or something like that
Dialogue: 0,1:07:47.84,1:07:50.56,English,,0,0,0,,And the reason that's important is that these functions
Dialogue: 0,1:07:51.30,1:07:56.30,English,,0,0,0,,Are treat the end of line character 0a is a very special character
Dialogue: 0,1:07:56.42,1:08:02.06,English,,0,0,0,,They'll stop reading or something like that or if it's going between windows and unix
Dialogue: 0,1:08:02.14,1:08:07.90,English,,0,0,0,,It will actually change one from carriage returned from line feed to carriage return line feed
Dialogue: 0,1:08:08.42,1:08:12.82,English,,0,0,0,,Same way functions like sterlin and ster copy will stop when they hit a null byte
Dialogue: 0,1:08:13.54,1:08:17.84,English,,0,0,0,,And that's not what you want to do when these are network packets you're trying to send out
Dialogue: 0,1:08:19.38,1:08:24.73,English,,0,0,0,,So be careful some of the functions you've used a lot and you're very familiar with
Dialogue: 0,1:08:25.44,1:08:31.76,English,,0,0,0,,May be completely inappropriate for things where you're doing binary of data
Dialogue: 0,1:08:32.36,1:08:35.54,English,,0,0,0,,Or you're communicating over networks and things like that
Dialogue: 0,1:08:35.56,1:08:40.88,English,,0,0,0,,So be sure you understand what you're doing when you start to use these kind of functions
Dialogue: 0,1:08:43.60,1:08:46.42,English,,0,0,0,,So those who you really want to know this stuff
Dialogue: 0,1:08:47.20,1:08:50.10,English,,0,0,0,,There's a there's a fellow named richard stevens who unfortunately died
Dialogue: 0,1:08:53.08,1:08:54.74,English,,0,0,0,,Awhile quite a while ago
Dialogue: 0,1:08:55.14,1:09:02.52,English,,0,0,0,,But his books live on and there's various people have signed up to become co-authors with him  in his absence
Dialogue: 0,1:09:04.56,1:09:10.70,English,,0,0,0,,And creating new editions of these books that used to date back way far
Dialogue: 0,1:09:11.26,1:09:15.84,English,,0,0,0,,So and if you really want to know how this stuff works you want to be the ace programmer
Dialogue: 0,1:09:16.44,1:09:18.20,English,,0,0,0,,These books are the best you can get
Dialogue: 0,1:09:18.22,1:09:24.52,English,,0,0,0,,But i'll also warn you your bookshelf will become very heavy laden because there's
Dialogue: 0,1:09:25.06,1:09:30.16,English,,0,0,0,,There's the volumes one two and three and then there's networking books and
Dialogue: 0,1:09:30.24,1:09:33.36,English,,0,0,0,,Stevens is like a encyclopedic reference
Dialogue: 0,1:09:33.46,1:09:37.96,English,,0,0,0,,But they're excellent books if you really want to understand something  read stevens
Dialogue: 0,1:09:39.02,1:09:47.04,English,,0,0,0,,And there's another book that is just specific to linux that's fairly nice and somewhat it's very detailed
Dialogue: 0,1:09:47.64,1:09:54.98,English,,0,0,0,,But since it's only trying to deal with linux it's a little bit less weird than trying to read stevens
Dialogue: 0,1:09:55.02,1:10:01.46,English,,0,0,0,,Because stevens will say in this version of unix it works this way in this version it works that way and blah blah blah
Dialogue: 0,1:10:01.50,1:10:03.48,English,,0,0,0,,And it's all different and it will drive you crazy
Dialogue: 0,1:10:04.44,1:10:07.22,English,,0,0,0,,But stevens is still it's an outstanding set of books
Dialogue: 0,1:10:08.10,1:10:10.54,English,,0,0,0,,Ok so
Dialogue: 0,1:10:11.60,1:10:13.90,English,,0,0,0,,This is an example and i'm not going to go through it
Dialogue: 0,1:10:13.90,1:10:17.78,English,,0,0,0,,But these are the kind of things that we use to torture students that you
Dialogue: 0,1:10:18.30,1:10:22.42,English,,0,0,0,,Open some file descriptors and you do some dupes and you do
Dialogue: 0,1:10:23.10,1:10:29.50,English,,0,0,0,,Some forks and so you end up with a real spaghetti for all the pointers and
Dialogue: 0,1:10:29.50,1:10:33.42,English,,0,0,0,,What's shared and what's not shared and then you ask what will this print
Dialogue: 0,1:10:33.86,1:10:38.28,English,,0,0,0,,And of course you'll have to trace through in great detail what's really going on
Dialogue: 0,1:10:39.10,1:10:43.62,English,,0,0,0,,So those are in the book and i recommend you work on some of those
Dialogue: 0,1:10:44.46,1:10:52.08,English,,0,0,0,,Ok that'll do us for today then
Dialogue: 0,1:10:48.94,1:10:51.00,English,,0,0,0,,You
ose are in the book and I recommend you work on some of those
Dialogue: 0,1:10:44.46,1:10:52.08,English,,0,0,0,, ok that'll do us for today then
Dialogue: 0,1:10:48.94,1:10:51.00,English,,0,0,0,,you
