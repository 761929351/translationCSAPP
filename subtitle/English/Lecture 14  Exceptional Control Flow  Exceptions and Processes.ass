[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video File: ../../../../Desktop/csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 788
Active Line: 797
Video Position: 129548

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.96,English,,0,0,0,,All right good afternoon everybody
Dialogue: 0,0:00:03.44,0:00:04.66,English,,0,0,0,,Welcome good to see you
Dialogue: 0,0:00:08.06,0:00:13.46,English,,0,0,0,,So today we're going to look at an idea called exceptional control flow
Dialogue: 0,0:00:14.22,0:00:18.56,English,,0,0,0,,That's a very important part of making modern systems
Dialogue: 0,0:00:19.18,0:00:26.32,English,,0,0,0,,And it exists at all levels of the system from the lowest level hardware,all the way up to software
Dialogue: 0,0:00:30.62,0:00:38.22,English,,0,0,0,,So the idea is when you turn on a computer (from the very) from the very first time you turn it on
Dialogue: 0,0:00:38.92,0:00:43.16,English,,0,0,0,,On it just does execute one instruction after another until that you turn it off
Dialogue: 0,0:00:43.96,0:00:50.08,English,,0,0,0,,Okay and if each core if you have multiple cores then each of those cores are executing instructions one after the other
Dialogue: 0,0:00:51.52,0:00:56.20,English,,0,0,0,,Now the sequence of instructions is called the control flow
Dialogue: 0,0:00:57.04,0:01:03.62,English,,0,0,0,,Okay and the actual sequence of instructions that the hardware is executing is called the physical control flow
Dialogue: 0,0:01:04.76,0:01:05.60,English,,0,0,0,,Now normally
Dialogue: 0,0:01:07.52,0:01:15.18,English,,0,0,0,,Normally,this control flow that executes just one instruction after another just sequentially in memory
Dialogue: 0,0:01:16.12,0:01:21.32,English,,0,0,0,,And we've so far we've seen two mechanisms for altering the control flow
Dialogue: 0,0:01:21.32,0:01:22.46,English,,0,0,0,,So that it's not
Dialogue: 0,0:01:22.92,0:01:25.68,English,,0,0,0,,So that we're not executing just the next instruction
Dialogue: 0,0:01:26.32,0:01:31.32,English,,0,0,0,,So that's branches and jumps and procedure call and return
Dialogue: 0,0:01:32.76,0:01:37.42,English,,0,0,0,,Okay now jumps and call... branches jumps call and return
Dialogue: 0,0:01:38.22,0:01:41.16,English,,0,0,0,,Those are reacting to changes in program state
Dialogue: 0,0:01:41.96,0:01:45.70,English,,0,0,0,,So when you do a branch you check the control condition codes
Dialogue: 0,0:01:46.18,0:01:50.82,English,,0,0,0,,And then based on some the results of that comparison then you do the branch
Dialogue: 0,0:01:52.28,0:01:57.48,English,,0,0,0,,Okay but it real system needs to be able to adapt to changes in the system state
Dialogue: 0,0:01:59.36,0:02:01.86,English,,0,0,0,,Okay so for example data arrives from a disk
Dialogue: 0,0:02:04.56,0:02:10.10,English,,0,0,0,,Or some network use types Ctrl-C
Dialogue: 0,0:02:10.92,0:02:13.90,English,,0,0,0,,Okay the program executes an illegal instruction
Dialogue: 0,0:02:14.30,0:02:20.60,English,,0,0,0,,Okay all of these represent some change, some kind of change in the system state
Dialogue: 0,0:02:21.18,0:02:23.82,English,,0,0,0,,And we need some way to react to that
Dialogue: 0,0:02:24.90,0:02:25.42,English,,0,0,0,,So this...
Dialogue: 0,0:02:26.90,0:02:29.60,English,,0,0,0,,So what we need is we call this exceptional control flow
Dialogue: 0,0:02:30.04,0:02:34.20,English,,0,0,0,,Because it's sort of outside of the normal control flow that we see in our programs
Dialogue: 0,0:02:36.20,0:02:41.22,English,,0,0,0,,Now exceptional control flow(ECF) exists at all levels in the system
Dialogue: 0,0:02:42.66,0:02:45.18,English,,0,0,0,,From the very lowest level of hardware
Dialogue: 0,0:02:48.64,0:02:51.52,English,,0,0,0,,At the very lowest level we have what are called exceptions
Dialogue: 0,0:02:52.26,0:02:58.16,English,,0,0,0,,And these are changes in the control flow in response to some low level system event
Dialogue: 0,0:02:59.32,0:03:04.18,English,,0,0,0,,So this is a...or and by event we mean a change in the state
Dialogue: 0,0:03:05.24,0:03:11.38,English,,0,0,0,,Now exceptions are implemented using a combination of hardware and OS software which we'll see in it in a minute
Dialogue: 0,0:03:12.08,0:03:16.58,English,,0,0,0,,But these exceptional control flow exists at higher levels too
Dialogue: 0,0:03:17.44,0:03:23.08,English,,0,0,0,,So in the a process context switch is an example of exceptional control flow
Dialogue: 0,0:03:23.66,0:03:28.58,English,,0,0,0,,That's also it's implemented by a hardware and the operating system kernel
Dialogue: 0,0:03:29.42,0:03:34.94,English,,0,0,0,,And it so a process context switches we'll see later later today
Dialogue: 0,0:03:35.62,0:03:40.66,English,,0,0,0,,You're executing your code in the current in your current process
Dialogue: 0,0:03:42.32,0:03:47.82,English,,0,0,0,,And then all of a sudden this the system is executing code from another process
Dialogue: 0,0:03:48.14,0:03:50.38,English,,0,0,0,,Right so your process gets like suspended
Dialogue: 0,0:03:51.34,0:03:55.74,English,,0,0,0,,And so there's a...so that's a form of exceptional control flow
Dialogue: 0,0:03:55.74,0:04:01.82,English,,0,0,0,,Where you're executing statements instructions within one process
Dialogue: 0,0:04:01.82,0:04:06.54,English,,0,0,0,,And then all of a sudden you're executing statements instructions in another process
Dialogue: 0,0:04:08.56,0:04:11.22,English,,0,0,0,,At a higher level are totally in software
Dialogue: 0,0:04:11.60,0:04:13.18,English,,0,0,0,,We have the idea of a signal
Dialogue: 0,0:04:13.82,0:04:19.40,English,,0,0,0,,And this is implemented by operating system software and we'll learn all about signals next lecture
Dialogue: 0,0:04:20.60,0:04:25.08,English,,0,0,0,,And then even higher,at an even higher level you have nonlocal jumps in C
Dialogue: 0,0:04:25.60,0:04:28.26,English,,0,0,0,,Which are just implemented by the C run library
Dialogue: 0,0:04:28.76,0:04:33.68,English,,0,0,0,,So this allows you nonlocal jumps allow you to break the normal call and return pattern
Dialogue: 0,0:04:33.68,0:04:34.54,English,,0,0,0,,So from one...
Dialogue: 0,0:04:35.18,0:04:40.82,English,,0,0,0,,So from within a function normally you can only return to the function that calls that called you
Dialogue: 0,0:04:41.46,0:04:50.12,English,,0,0,0,,Nonlocal jumps allow you to within a function break that and return to some other function or some other part of the code
Dialogue: 0,0:04:51.16,0:04:54.38,English,,0,0,0,,So we'll look at signals and nonlocal jumps next lecture
Dialogue: 0,0:04:54.84,0:04:57.62,English,,0,0,0,,Today we're going to look at exceptions and processes
Dialogue: 0,0:05:00.12,0:05:07.08,English,,0,0,0,,So an exception is a transfer of control to the operating systems kernel
Dialogue: 0,0:05:07.70,0:05:13.32,English,,0,0,0,,Where the kernel is the memory resident part of the operating system you know
Dialogue: 0,0:05:13.34,0:05:23.86,English,,0,0,0,,So an operating system provides all kinds of programs like to list files,to change directories,to list the current processes
Dialogue: 0,0:05:24.48,0:05:27.68,English,,0,0,0,,So all of that stuff constitutes the operating system
Dialogue: 0,0:05:27.68,0:05:33.20,English,,0,0,0,,The kernel is the part of the operating system that's always resident in memory
Dialogue: 0,0:05:34.98,0:05:40.64,English,,0,0,0,,So an exception is really low-level transfer of control to the operating system
Dialogue: 0,0:05:40.64,0:05:42.66,English,,0,0,0,,Because something happened in the system
Dialogue: 0,0:05:43.48,0:05:46.66,English,,0,0,0,,So you're executing your code,user code
Dialogue: 0,0:05:47.70,0:05:53.32,English,,0,0,0,,And then something happens some event, so by event we mean there's some change in the system state
Dialogue: 0,0:05:54.96,0:06:04.34,English,,0,0,0,,In response to that there the exception transfers control from your user code to code in the kernel
Dialogue: 0,0:06:04.82,0:06:06.42,English,,0,0,0,,Which is called an exception handler
Dialogue: 0,0:06:07.18,0:06:10.58,English,,0,0,0,,And then the kernel responds to that change in some way
Dialogue: 0,0:06:12.72,0:06:14.50,English,,0,0,0,,This is called the exception processing
Dialogue: 0,0:06:15.66,0:06:21.98,English,,0,0,0,,And then there's three things that can happen after the kernel handles the exception
Dialogue: 0,0:06:22.74,0:06:25.92,English,,0,0,0,,It can return and reexecute that the current instruction
Dialogue: 0,0:06:27.86,0:06:33.88,English,,0,0,0,,Okay and we'll see this is useful for things like page faults allows us to implement virtual memory
Dialogue: 0,0:06:35.76,0:06:37.86,English,,0,0,0,,It could return to the next instruction
Dialogue: 0,0:06:39.04,0:06:43.00,English,,0,0,0,,Which I've shown here or it could abort
Dialogue: 0,0:06:46.64,0:06:49.56,English,,0,0,0,,Now exceptions are implemented by hardware and software
Dialogue: 0,0:06:49.56,0:06:53.30,English,,0,0,0,,So the actual transfer of control
Dialogue: 0,0:06:54.26,0:07:00.16,English,,0,0,0,,You know the change in the program counter or %rip is done by the hardware
Dialogue: 0,0:07:01.22,0:07:09.80,English,,0,0,0,,But the code that executes as a result of that exception is set up and determined by the operating system kernel
Dialogue: 0,0:07:10.44,0:07:15.26,English,,0,0,0,,So every type of event has a unique exception number
Dialogue: 0,0:07:15.78,0:07:19.48,English,,0,0,0,,Which serves as an index into a jump table called an exception table
Dialogue: 0,0:07:20.66,0:07:24.24,English,,0,0,0,,Okay and so when event k happens
Dialogue: 0,0:07:25.36,0:07:30.42,English,,0,0,0,,Then the hardware looks uses k as in as an index into this table
Dialogue: 0,0:07:30.90,0:07:36.10,English,,0,0,0,,And gets the address of the exception handler for that exception
Dialogue: 0,0:07:38.02,0:07:43.82,English,,0,0,0,,And so every time that event k happens that handler handler k is invoked
Dialogue: 0,0:07:45.36,0:07:52.84,English,,0,0,0,,Now there's a different kinds of exceptions we distinguish them as being asynchronous or synchronous
Dialogue: 0,0:07:53.46,0:08:03.12,English,,0,0,0,,Asynchronous exceptions happen as a result of changes in state that are occurred outside of the processor
Dialogue: 0,0:08:03.92,0:08:06.28,English,,0,0,0,,So these are called interrupts
Dialogue: 0,0:08:07.20,0:08:09.64,English,,0,0,0,,And those changes in state are...
Dialogue: 0,0:08:10.44,0:08:17.06,English,,0,0,0,,The processor is notified about those changes in state by setting a pin on the processor
Dialogue: 0,0:08:17.06,0:08:20.28,English,,0,0,0,,An external pin called the interrupt pin
Dialogue: 0,0:08:21.37,0:08:28.56,English,,0,0,0,,So this is the kind of when see a disk controller finishes doing a direct memory access
Dialogue: 0,0:08:28.78,0:08:31.62,English,,0,0,0,,And copying data from the disk into memory
Dialogue: 0,0:08:32.02,0:08:39.72,English,,0,0,0,,It notifies the processor that it's finished that copy by setting the interrupt pin hi okay
Dialogue: 0,0:08:42.58,0:08:48.38,English,,0,0,0,,And so after an interrupt happens the handler returns to the next instruction
Dialogue: 0,0:08:48.52,0:08:55.42,English,,0,0,0,,So an interrupt typically it's the so you're running your program,you're running your program and then there's like this little
Dialogue: 0,0:08:57.28,0:09:01.78,English,,0,0,0,,There's like this little pause while the interrupt handler runs and then your program just continues to run okay
Dialogue: 0,0:09:02.22,0:09:11.52,English,,0,0,0,,So it's usually sort of done behind the scenes and doesn't affect your execution of your program
Dialogue: 0,0:09:12.28,0:09:18.74,English,,0,0,0,,Now the most common...a common example of a interrupt is the timer interrupts
Dialogue: 0,0:09:19.66,0:09:25.44,English,,0,0,0,,So you're all systems have a built-in timer that goes off every few milliseconds
Dialogue: 0,0:09:26.36,0:09:29.76,English,,0,0,0,,And when it,when the timer goes off it sets the interrupts pin high
Dialogue: 0,0:09:30.38,0:09:34.02,English,,0,0,0,,And there's a special exception number for timer interrupts
Dialogue: 0,0:09:34.88,0:09:37.54,English,,0,0,0,,And this is we need this in order for the
Dialogue: 0,0:09:37.96,0:09:43.20,English,,0,0,0,,This allows we need this to allow the kernel to get control of the system again
Dialogue: 0,0:09:43.20,0:09:47.38,English,,0,0,0,,Otherwise a user program could just run forever in an infinite loop
Dialogue: 0,0:09:47.74,0:09:52.50,English,,0,0,0,,And no one...they be no way for the operating system to get control
Dialogue: 0,0:09:52.50,0:10:00.40,English,,0,0,0,,So every few milliseconds this timer goes off that causes a transient exception into the kernel
Dialogue: 0,0:10:00.86,0:10:05.24,English,,0,0,0,,And then the kernel can...as we see the kernel can decide what to do
Dialogue: 0,0:10:05.70,0:10:09.48,English,,0,0,0,,Maybe maybe schedule a new process or let the current process run
Dialogue: 0,0:10:12.46,0:10:17.64,English,,0,0,0,,And then this an i/o interrupt from an external devices is also a common example
Dialogue: 0,0:10:18.44,0:10:21.22,English,,0,0,0,,Now the other class of exceptions are synchronous exceptions
Dialogue: 0,0:10:21.66,0:10:23.32,English,,0,0,0,,And there are three classes of those
Dialogue: 0,0:10:25.76,0:10:32.54,English,,0,0,0,,One is that,one class is called the trap,a trap is a intentional exception
Dialogue: 0,0:10:32.54,0:10:35.52,English,,0,0,0,,So this is an exception that's caused intentionally by the program
Dialogue: 0,0:10:36.32,0:10:40.08,English,,0,0,0,,And the most common form of a trap is a system call
Dialogue: 0,0:10:41.42,0:10:46.58,English,,0,0,0,,So you know the operating system kernel provides all kinds of services to a program
Dialogue: 0,0:10:46.58,0:10:48.62,English,,0,0,0,,But your program doesn't have direct access
Dialogue: 0,0:10:49.86,0:10:54.25,English,,0,0,0,,Your program can't call functions in the kernel,can't access data directly in the kernel
Dialogue: 0,0:10:54.54,0:10:58.68,English,,0,0,0,,Because that memory is protected and unavailable to user programs
Dialogue: 0,0:10:59.66,0:11:08.42,English,,0,0,0,,So what the kernel does is they provide a interface that allows programs to make requests to effectively
Dialogue: 0,0:11:08.92,0:11:12.80,English,,0,0,0,,Call functions within the kernel and to make requests for various services
Dialogue: 0,0:11:13.32,0:11:15.82,English,,0,0,0,,And this interface is called a system call
Dialogue: 0,0:11:17.28,0:11:19.24,English,,0,0,0,,Ok so a program makes a system call
Dialogue: 0,0:11:20.16,0:11:25.60,English,,0,0,0,,And requests various functions from the kernel
Dialogue: 0,0:11:26.02,0:11:30.30,English,,0,0,0,,The kernel provides those sort of reacts to that request
Dialogue: 0,0:11:30.30,0:11:34.62,English,,0,0,0,,And then returns control back to the the function there the calling program
Dialogue: 0,0:11:35.24,0:11:38.70,English,,0,0,0,,So you can think of a system call as kind of it's a...
Dialogue: 0,0:11:39.56,0:11:43.88,English,,0,0,0,,It looks like a function call but it's really transferring control into the kernel
Dialogue: 0,0:11:47.42,0:11:54.26,English,,0,0,0,,Okay then there's some so traps are intentional faults are unintentional but may be recoverable
Dialogue: 0,0:11:54.72,0:11:59.86,English,,0,0,0,,Okay so things like page faults which
Dialogue: 0,0:12:01.50,0:12:04.64,English,,0,0,0,,When we will learn more about these when we study virtual memory
Dialogue: 0,0:12:04.64,0:12:08.88,English,,0,0,0,,But something like a page fault it's actually recoverable
Dialogue: 0,0:12:08.88,0:12:16.70,English,,0,0,0,,It just that the kernel has to it means that the the data the portion of the address space that your program referenced isn't actually in memory
Dialogue: 0,0:12:17.92,0:12:21.80,English,,0,0,0,,It needs to be copied from disk where it's stored into memory
Dialogue: 0,0:12:22.28,0:12:27.42,English,,0,0,0,,And then the instruction that that caused a fault needs is just restarted and then it works
Dialogue: 0,0:12:28.50,0:12:33.58,English,,0,0,0,,That the memory is there and then the instruction works properly
Dialogue: 0,0:12:33.88,0:12:38.70,English,,0,0,0,,But other faults are unrecoverable like protection fault
Dialogue: 0,0:12:38.70,0:12:43.78,English,,0,0,0,,So if you try to access a portion of memory that's not allocated
Dialogue: 0,0:12:44.14,0:12:49.96,English,,0,0,0,,Or floating-point exceptions often times those can be recoverable
Dialogue: 0,0:12:51.84,0:12:59.16,English,,0,0,0,,So in either case when there's a fault it either re-execute the current instruction all the abort
Dialogue: 0,0:13:00.82,0:13:08.26,English,,0,0,0,,And then there's unintentional and unrecoverable exceptions which are called the aborts and those those always abort
Dialogue: 0,0:13:08.80,0:13:14.74,English,,0,0,0,,So if you execute an illegal instruction,if there's a problem with your memory,memory and it's it's corrupted
Dialogue: 0,0:13:15.86,0:13:21.36,English,,0,0,0,,There's some problem with the machine those creative warts that always...
Dialogue: 0,0:13:22.34,0:13:26.92,English,,0,0,0,,That are unrecoverable and never return back to the program
Dialogue: 0,0:13:28.68,0:13:30.40,English,,0,0,0,,Now system calls there's...
Dialogue: 0,0:13:32.02,0:13:35.28,English,,0,0,0,,Many different kinds of system calls and they all have their own unique number
Dialogue: 0,0:13:35.76,0:13:38.16,English,,0,0,0,,Which is assigned by Linux
Dialogue: 0,0:13:39.84,0:13:46.38,English,,0,0,0,,So for example to read a file,there's a system call called read
Dialogue: 0,0:13:46.38,0:13:53.40,English,,0,0,0,,Which is number 0 opening a file, a system call number 2 and so on
Dialogue: 0,0:13:56.14,0:14:01.58,English,,0,0,0,,And there's an instruction called syscall
Dialogue: 0,0:14:01.58,0:14:06.34,English,,0,0,0,,Which actually performs the system call
Dialogue: 0,0:14:07.04,0:14:12.44,English,,0,0,0,,Now you usually don't use this system call and strike the syscall instruction directly in your program the
Dialogue: 0,0:14:12.96,0:14:17.98,English,,0,0,0,,Linux wraps those in system level functions which actually call it for you
Dialogue: 0,0:14:18.74,0:14:22.28,English,,0,0,0,,But it's interesting in C how it actually works
Dialogue: 0,0:14:22.28,0:14:27.58,English,,0,0,0,,So opposed you want to open a file you call the system level function called open
Dialogue: 0,0:14:28.46,0:14:32.10,English,,0,0,0,,With a file name and some options say read only write only
Dialogue: 0,0:14:36.10,0:14:42.66,English,,0,0,0,,And so in at the syscall instruction takes the first the syscall number is %rax
Dialogue: 0,0:14:44.12,0:14:50.60,English,,0,0,0,,And then other arguments are %rdi,%rsi,%rdx, %r10, %r9, %r8
Dialogue: 0,0:14:51.36,0:14:57.72,English,,0,0,0,,So you can see if we look in the the open function calls the __open function which actually invokes
Dialogue: 0,0:14:58.22,0:15:02.04,English,,0,0,0,,The syscall so if you look at that code you see it moves the 0x2
Dialogue: 0,0:15:02.04,0:15:07.52,English,,0,0,0,,which is the syscall number for read into %eax and then it does the syscall
Dialogue: 0,0:15:09.72,0:15:15.54,English,,0,0,0,,And then the the syscall returns its status in %rax
Dialogue: 0,0:15:16.30,0:15:19.80,English,,0,0,0,,If it's a negative number then that means something some error occurred
Dialogue: 0,0:15:20.76,0:15:25.40,English,,0,0,0,,If it's a positive number then that means something that no error occurred
Dialogue: 0,0:15:26.32,0:15:30.42,English,,0,0,0,,So in this case and in the open it's returning a file descriptor
Dialogue: 0,0:15:30.42,0:15:36.74,English,,0,0,0,,A small integer called the file descriptor which then you can use in subsequent calls to read and write
Dialogue: 0,0:15:37.34,0:15:40.64,English,,0,0,0,,And then you can see the code is checking for this negative return value
Dialogue: 0,0:15:40.96,0:15:43.26,English,,0,0,0,,And there's a whole series of these compares
Dialogue: 0,0:15:50.18,0:15:53.36,English,,0,0,0,,So let's look at an example of a fault
Dialogue: 0,0:15:54.28,0:16:00.54,English,,0,0,0,,So here suppose we have this program that we're writing into a valid region of memory
Dialogue: 0,0:16:00.54,0:16:07.70,English,,0,0,0,,But it's not actually stored on...it's not actually in the memory,it needs to be loaded from disk into into memory
Dialogue: 0,0:16:07.70,0:16:10.88,English,,0,0,0,,So this is a...so called page fault
Dialogue: 0,0:16:12.52,0:16:14.82,English,,0,0,0,,So this instruction this movl
Dialogue: 0,0:16:15.40,0:16:22.82,English,,0,0,0,,Because this because the memory at this address isn't available triggers a page fault
Dialogue: 0,0:16:24.60,0:16:30.92,English,,0,0,0,,So that creates an exception a transfer of control into the the page fault handler in the kernel
Dialogue: 0,0:16:31.64,0:16:34.32,English,,0,0,0,,Which copies that page from disk to memory
Dialogue: 0,0:16:36.24,0:16:40.98,English,,0,0,0,,And then it returns and when it returns it reacts acutes the movl instruction
Dialogue: 0,0:16:41.52,0:16:42.24,English,,0,0,0,,So that's kind of cool
Dialogue: 0,0:16:42.24,0:16:44.88,English,,0,0,0,,So now the memory is available
Dialogue: 0,0:16:45.58,0:16:52.02,English,,0,0,0,,And now that the movl this movl instruction when it's reacts acute completes
Dialogue: 0,0:16:53.66,0:16:54.68,English,,0,0,0,,And then we continue
Dialogue: 0,0:16:55.66,0:16:58.80,English,,0,0,0,,Now another type of fault is an invalid memory reference
Dialogue: 0,0:16:58.80,0:17:02.46,English,,0,0,0,,So here we have a...we're accessing an element of a
Dialogue: 0,0:17:03.24,0:17:07.74,English,,0,0,0,,Which doesn't exist and it's an illegal,it's an invalid reference
Dialogue: 0,0:17:09.22,0:17:12.16,English,,0,0,0,,So in this case the movl instruction
Dialogue: 0,0:17:12.90,0:17:15.36,English,,0,0,0,,It looks like a...it looks like a page fault
Dialogue: 0,0:17:16.72,0:17:21.74,English,,0,0,0,,But the kernel detects that it's an invalid address that there isn't anything that can be loaded from disk
Dialogue: 0,0:17:21.74,0:17:25.70,English,,0,0,0,,This is an invalid region of the the virtual address space
Dialogue: 0,0:17:27.38,0:17:34.24,English,,0,0,0,,So it sends a signal to the to the process and then never returns
Dialogue: 0,0:17:35.96,0:17:40.06,English,,0,0,0,,So the signal that sends is the infamous segmentation
Dialogue: 0,0:17:40.06,0:17:46.90,English,,0,0,0,,The signal that causes the infamous sauce segmentation fault message to print out
Dialogue: 0,0:17:47.94,0:17:52.28,English,,0,0,0,,And we'll see you next lecture,we'll see how these signals actually work
Dialogue: 0,0:17:56.26,0:18:01.88,English,,0,0,0,,Okay so I said we've seen exceptions or very low-level transfers of control
Dialogue: 0,0:18:02.36,0:18:06.58,English,,0,0,0,,That are implemented by both hardware and the operating system software...it could sue
Dialogue: 0,0:18:08.58,0:18:12.84,English,,0,0,0,,At the higher level is another form of exceptional control flow called
Dialogue: 0,0:18:14.28,0:18:18.72,English,,0,0,0,,And we see it in the context of a process context switch
Dialogue: 0,0:18:21.00,0:18:25.34,English,,0,0,0,,So let's look at and let's look at what a process is
Dialogue: 0,0:18:26.64,0:18:32.38,English,,0,0,0,,So a process,the idea of a process is one of the most fundamental and important ideas in computer science
Dialogue: 0,0:18:33.34,0:18:39.22,English,,0,0,0,,And this classical definition of is that a process is an instance of a running program
Dialogue: 0,0:18:40.88,0:18:43.20,English,,0,0,0,,Okay it's different from a program
Dialogue: 0,0:18:43.68,0:18:47.18,English,,0,0,0,,A program exists can exist in many different places right
Dialogue: 0,0:18:47.18,0:18:51.38,English,,0,0,0,,A program exists in you save as text in a C file
Dialogue: 0,0:18:51.98,0:18:57.24,English,,0,0,0,,It can exist as the .text section of a binary
Dialogue: 0,0:18:58.38,0:19:01.86,English,,0,0,0,,It can exist as bytes that have been loaded into memory
Dialogue: 0,0:19:02.26,0:19:06.96,English,,0,0,0,,A process is an instance of a program that's running,that's in execution
Dialogue: 0,0:19:13.40,0:19:16.92,English,,0,0,0,,And a process provides two key abstractions
Dialogue: 0,0:19:17.80,0:19:24.36,English,,0,0,0,,Okay it's the first abstraction is that it gives it gives you the illusion that you have
Dialogue: 0,0:19:25.88,0:19:29.66,English,,0,0,0,,Exclusive access to the CPU and registers
Dialogue: 0,0:19:30.60,0:19:31.58,English,,0,0,0,,Okay so when you're running
Dialogue: 0,0:19:31.98,0:19:33.90,English,,0,0,0,,When you're running your program in a process
Dialogue: 0,0:19:34.58,0:19:39.20,English,,0,0,0,,You never have to worry about any other programs modifying your registers
Dialogue: 0,0:19:39.86,0:19:45.46,English,,0,0,0,,And you can't even tell that there's even other processes running on the system
Dialogue: 0,0:19:45.76,0:19:51.86,English,,0,0,0,,Right it looks except for occasional delays like an instruction that just takes a little longer to run
Dialogue: 0,0:19:53.16,0:20:01.06,English,,0,0,0,,Except for that it looks like you have unique exclusive use of the of the processor and it's registers
Dialogue: 0,0:20:02.36,0:20:06.50,English,,0,0,0,,The the other abstraction that it provides is the illusion that you have your own address space
Dialogue: 0,0:20:08.70,0:20:09.84,English,,0,0,0,,Okay so you have
Dialogue: 0,0:20:10.12,0:20:13.58,English,,0,0,0,,And this is provided by a mechanism called virtual memory
Dialogue: 0,0:20:14.28,0:20:20.58,English,,0,0,0,,So each running program has its own code data heap stack
Dialogue: 0,0:20:21.20,0:20:24.06,English,,0,0,0,,And you never see that the code...
Dialogue: 0,0:20:24.68,0:20:27.72,English,,0,0,0,,And you never see the memory that's being used by other processes
Dialogue: 0,0:20:28.54,0:20:33.68,English,,0,0,0,,Okay so it looks for all intents and purposes process gives you this illusion that
Dialogue: 0,0:20:33.68,0:20:39.82,English,,0,0,0,,You have access to the exclusive access to all the memory and the and the processor
Dialogue: 0,0:20:42.88,0:20:46.64,English,,0,0,0,,Now that the system runs many of these processes simultaneously
Dialogue: 0,0:20:49.06,0:20:58.86,English,,0,0,0,,Even on a system with a single core,many of these multiple processes are actually running at the same time concurrently
Dialogue: 0,0:20:59.16,0:21:03.92,English,,0,0,0,,And you can see this if you look at this here I ran top on my mac
Dialogue: 0,0:21:04.60,0:21:13.18,English,,0,0,0,,And you can see it's running 123 total processes, 5 of which are actually running
Dialogue: 0,0:21:13.94,0:21:19.60,English,,0,0,0,,And each one of these processes has its own unique process id,this is integer
Dialogue: 0,0:21:24.04,0:21:30.80,English,,0,0,0,,Now the way so it looks like you have unique access or exclusive access to the system
Dialogue: 0,0:21:31.96,0:21:39.14,English,,0,0,0,,But in reality on a suppose we have a single core on a you're actually sharing the system
Dialogue: 0,0:21:39.14,0:21:43.42,English,,0,0,0,,And the operating system is is sort of managing that sharing
Dialogue: 0,0:21:44.20,0:21:45.24,English,,0,0,0,,So what it does is it
Dialogue: 0,0:21:49.32,0:21:51.04,English,,0,0,0,,We have a process that's running
Dialogue: 0,0:21:52.72,0:21:57.16,English,,0,0,0,,And it has its own...it has its own address space
Dialogue: 0,0:21:58.26,0:22:02.50,English,,0,0,0,,And it has its own registers
Dialogue: 0,0:22:03.18,0:22:04.62,English,,0,0,0,,And at some point either
Dialogue: 0,0:22:05.42,0:22:10.56,English,,0,0,0,,Because...at some point an exception occurs either because of a timer interrupt
Dialogue: 0,0:22:11.18,0:22:14.40,English,,0,0,0,,Or a fault of some kind or a trap
Dialogue: 0,0:22:15.00,0:22:18.86,English,,0,0,0,,At some point the operating system gets control of the system
Dialogue: 0,0:22:19.42,0:22:23.82,English,,0,0,0,,And in this case let's say it decides that it wants to run another process
Dialogue: 0,0:22:25.28,0:22:31.94,English,,0,0,0,,So it copies the registers,the current register values into memory and saves them
Dialogue: 0,0:22:34.04,0:22:37.04,English,,0,0,0,,And then it schedules the next process for execution
Dialogue: 0,0:22:38.18,0:22:46.00,English,,0,0,0,,And it loads the registers that were saved from the last time that process was running
Dialogue: 0,0:22:46.00,0:22:48.04,English,,0,0,0,,It loads those into the cpu registers
Dialogue: 0,0:22:48.64,0:22:54.48,English,,0,0,0,,And then it switches the address space to the address space for this process
Dialogue: 0,0:22:55.44,0:23:00.20,English,,0,0,0,,So this the address space and the register values are the context
Dialogue: 0,0:23:01.56,0:23:09.02,English,,0,0,0,,And so the context switch is what is the change in the address space and the registers
Dialogue: 0,0:23:11.38,0:23:14.00,English,,0,0,0,,Ok so then at that point the that process is running
Dialogue: 0,0:23:15.98,0:23:19.02,English,,0,0,0,,Now in reality on modern systems with multiple cores
Dialogue: 0,0:23:21.18,0:23:25.80,English,,0,0,0,,The operating system will schedule processes on those multiple cores
Dialogue: 0,0:23:25.96,0:23:31.46,English,,0,0,0,,And then if there's not enough course to handle the processes then it will do the context switching
Dialogue: 0,0:23:31.92,0:23:34.08,English,,0,0,0,,Just like we showed before
Dialogue: 0,0:23:37.74,0:23:41.92,English,,0,0,0,,Now each process represents a what we call a logical control flow
Dialogue: 0,0:23:42.72,0:23:45.32,English,,0,0,0,,So if you were to you know there's a physical control flow
Dialogue: 0,0:23:45.84,0:23:47.96,English,,0,0,0,,Which if we just looked at all the PC values
Dialogue: 0,0:23:50.20,0:23:53.52,English,,0,0,0,,We'd be executing instructions from one process
Dialogue: 0,0:23:53.52,0:23:56.64,English,,0,0,0,,And then all of a sudden we'd be executing from another process
Dialogue: 0,0:23:57.38,0:24:02.26,English,,0,0,0,,But within a single process there's a logical control flow which are all the instructions for that process
Dialogue: 0,0:24:03.48,0:24:07.16,English,,0,0,0,,Now we say that two processes run concurrently
Dialogue: 0,0:24:07.46,0:24:10.64,English,,0,0,0,,If their flows overlap in time otherwise they're sequential
Dialogue: 0,0:24:11.50,0:24:15.52,English,,0,0,0,,So let's look at an example we have three processes
Dialogue: 0,0:24:15.68,0:24:22.56,English,,0,0,0,,Process A runs for a while and then it's interrupted by process B and process C
Dialogue: 0,0:24:22.78,0:24:26.00,English,,0,0,0,,And then eventually it continues running and then it terminates
Dialogue: 0,0:24:26.84,0:24:32.78,English,,0,0,0,,Process B interrupts process A and then it runs for a while and then it terminates
Dialogue: 0,0:24:34.00,0:24:39.70,English,,0,0,0,,Process C once when process B finishes then process C gets to run for a while
Dialogue: 0,0:24:40.84,0:24:44.24,English,,0,0,0,,Then process A runs for a while and then process C terminates
Dialogue: 0,0:24:45.14,0:24:48.10,English,,0,0,0,,Okay so given this definition of concurrency
Dialogue: 0,0:24:51.20,0:24:54.78,English,,0,0,0,,Which of these processes are running concurrently
Dialogue: 0,0:24:58.12,0:24:59.52,English,,0,0,0,,What about a A and B?
Dialogue: 0,0:25:07.50,0:25:12.56,English,,0,0,0,,So A and B flows, B's flow overlaps with A's flow right
Dialogue: 0,0:25:13.30,0:25:17.62,English,,0,0,0,,So B
Dialogue: 0,0:25:21.04,0:25:23.82,English,,0,0,0,,B finishes starts and finish
Dialogue: 0,0:25:27.30,0:25:31.58,English,,0,0,0,,Some portion this portion of B flow overlaps with A flow right
Dialogue: 0,0:25:32.18,0:25:34.46,English,,0,0,0,,Because B is still running hasn't finished
Dialogue: 0,0:25:34.90,0:25:40.94,English,,0,0,0,,Ok so A and B are concurrent as and similarly C and a overlap
Dialogue: 0,0:25:41.62,0:25:42.84,English,,0,0,0,,So they're concurrent
Dialogue: 0,0:25:43.36,0:25:48.90,English,,0,0,0,,But B and C are not concurrent right B finishes before C starts
Dialogue: 0,0:25:52.82,0:25:56.66,English,,0,0,0,,Now this idea of concurrency it doesn't
Dialogue: 0,0:25:57.74,0:26:01.92,English,,0,0,0,,This definition of concurrency holds regardless of the number of cores
Dialogue: 0,0:26:02.62,0:26:07.70,English,,0,0,0,,Right even if you have one core this example that I showed you was on one core
Dialogue: 0,0:26:08.14,0:26:11.52,English,,0,0,0,,But even if you have multiple cores as long as the flows overlap in time
Dialogue: 0,0:26:12.12,0:26:13.56,English,,0,0,0,,They're concurrent
Dialogue: 0,0:26:14.98,0:26:20.58,English,,0,0,0,,But we can think of these no matter what,we can think of these as running in parallel with each other
Dialogue: 0,0:26:20.58,0:26:23.72,English,,0,0,0,,At least from the point of view of these individual processes
Dialogue: 0,0:26:30.90,0:26:33.24,English,,0,0,0,,Now this notion of a context which
Dialogue: 0,0:26:35.78,0:26:38.76,English,,0,0,0,,It's managed by...its managed by the kernel
Dialogue: 0,0:26:39.94,0:26:43.86,English,,0,0,0,,Okay and it's important to realize that the kernel is not like a separate process that's running
Dialogue: 0,0:26:43.86,0:26:46.54,English,,0,0,0,,It always runs in the context of some existing process
Dialogue: 0,0:26:47.96,0:26:53.82,English,,0,0,0,,And it's just code that's in the upper portion of the address space
Dialogue: 0,0:26:54.60,0:26:57.02,English,,0,0,0,,That gets executed as a result of an exception
Dialogue: 0,0:26:59.12,0:27:04.14,English,,0,0,0,,So what what happens the way to think about this is that you have this process a that runs
Dialogue: 0,0:27:04.36,0:27:07.62,English,,0,0,0,,And then an exception occurs which transfers control to the kernel
Dialogue: 0,0:27:08.46,0:27:14.04,English,,0,0,0,,The kernel invokes its scheduler which decides whether to let A continue to run
Dialogue: 0,0:27:14.62,0:27:18.86,English,,0,0,0,,Or to to do a context switch and run a new process another process
Dialogue: 0,0:27:19.44,0:27:25.56,English,,0,0,0,,So in this example the scheduler is decided to run process B
Dialogue: 0,0:27:25.56,0:27:32.92,English,,0,0,0,,So it executes code and then sort of changes sort of once it repoint the address space
Dialogue: 0,0:27:34.58,0:27:36.99,English,,0,0,0,,Then it's running in the context of process B
Dialogue: 0,0:27:37.42,0:27:43.60,English,,0,0,0,,And it finishes loading the registers for process B general-purpose registers
Dialogue: 0,0:27:43.62,0:27:48.00,English,,0,0,0,,And then transfers control to B and B picks up where it left off
Dialogue: 0,0:27:49.10,0:27:49.74,English,,0,0,0,,Okay
Dialogue: 0,0:27:51.50,0:27:53.80,English,,0,0,0,,And that at some point another exception occurs
Dialogue: 0,0:27:54.42,0:28:00.62,English,,0,0,0,,And in the kernel decides to transfer control back to process A which picks up where it left off right here
Dialogue: 0,0:28:01.68,0:28:04.62,English,,0,0,0,,So whatever instruction it finishes executing
Dialogue: 0,0:28:05.60,0:28:11.66,English,,0,0,0,,Whatever instruction was executing at the time of the exception execute the next instruction here
Dialogue: 0,0:28:17.56,0:28:20.54,English,,0,0,0,,Now Linux provides a number of functions
Dialogue: 0,0:28:21.12,0:28:24.42,English,,0,0,0,,You can call from a user program to manipulate processes
Dialogue: 0,0:28:24.90,0:28:30.40,English,,0,0,0,,And this process this act of manipulating processes we refer to as process control
Dialogue: 0,0:28:32.20,0:28:40.28,English,,0,0,0,,Now all of these functions,most I should say,most of these functions call invoke system make system calls
Dialogue: 0,0:28:40.68,0:28:45.96,English,,0,0,0,,But they're wrapped in higher levels what we call system level functions that
Dialogue: 0,0:28:46.12,0:28:48.64,English,,0,0,0,,That are the things you actually call from your user program
Dialogue: 0,0:28:49.60,0:28:57.58,English,,0,0,0,,Now system level the Linux system level functions that will typically return -1 if there's an error
Dialogue: 0,0:28:58.26,0:29:02.42,English,,0,0,0,,And then they'll set a global variable called error no to indicate the reason
Dialogue: 0,0:29:03.58,0:29:06.68,English,,0,0,0,,So there's a hard and fast rule when you're doing
Dialogue: 0,0:29:08.12,0:29:10.60,English,,0,0,0,,When you're invoking system level functions
Dialogue: 0,0:29:11.84,0:29:16.60,English,,0,0,0,,You must check the return values from those functions you should
Dialogue: 0,0:29:17.10,0:29:20.64,English,,0,0,0,,And this you never you'll get into huge trouble
Dialogue: 0,0:29:21.18,0:29:23.78,English,,0,0,0,,If you neglect to check the return values
Dialogue: 0,0:29:24.26,0:29:30.84,English,,0,0,0,,Okay so you should never make a system level function call without checking the return value
Dialogue: 0,0:29:31.64,0:29:35.56,English,,0,0,0,,The and the only exception there's some functions that return void
Dialogue: 0,0:29:37.98,0:29:42.10,English,,0,0,0,,Such as exit or free don't return anything
Dialogue: 0,0:29:43.32,0:29:47.14,English,,0,0,0,,So the way the typical way you would do this is like the fork call
Dialogue: 0,0:29:47.14,0:29:53.82,English,,0,0,0,,Which we use to create processes returns the process idea of the process that it created
Dialogue: 0,0:29:54.36,0:29:57.54,English,,0,0,0,,Which is always positive if there's an error returns -1
Dialogue: 0,0:29:57.54,0:30:04.12,English,,0,0,0,,So we check for the return value to be less than 0 and then we deal with that error somehow
Dialogue: 0,0:30:06.18,0:30:09.52,English,,0,0,0,,Ok in this case we're just printing a message and exiting
Dialogue: 0,0:30:10.68,0:30:13.82,English,,0,0,0,,Now this gets although it's essential to do this it gets
Dialogue: 0,0:30:16.16,0:30:20.58,English,,0,0,0,,From my point of view we're trying to present code to you
Dialogue: 0,0:30:22.06,0:30:25.10,English,,0,0,0,,It gets really messy it takes up a lot of space
Dialogue: 0,0:30:25.10,0:30:25.40,English,,0,0,0,,Yes
Dialogue: 0,0:30:25.84,0:30:31.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:30:31.76,0:30:33.62,English,,0,0,0,,I'm checking that it's less than zero
Dialogue: 0,0:30:37.20,0:30:43.72,English,,0,0,0,,Oh yeah that probably that should be normally the convention is to return non zero so you're right that
Dialogue: 0,0:30:44.82,0:30:49.68,English,,0,0,0,,It's not a hard and fast rule but that's typically the convention so I guess it should be exit one
Dialogue: 0,0:30:54.04,0:30:56.22,English,,0,0,0,,So what we'll do to simplify this
Dialogue: 0,0:30:56.76,0:31:00.19,English,,0,0,0,,In the code that we present to you and in the code that we present you in the book
Dialogue: 0,0:31:00.68,0:31:03.54,English,,0,0,0,,Well we'll define error reporting functions
Dialogue: 0,0:31:04.32,0:31:09.82,English,,0,0,0,,So unix-style errors where the function returns -1 and then sets there error no
Dialogue: 0,0:31:11.92,0:31:16.20,English,,0,0,0,,Well if we get that kind of...if we get that kind of error will
Dialogue: 0,0:31:16.98,0:31:23.12,English,,0,0,0,,Will print the will print a message and we'll report what that error was  before we exit
Dialogue: 0,0:31:23.46,0:31:30.96,English,,0,0,0,,And so then in the code we can replace that body of that if statement with just a single line
Dialogue: 0,0:31:31.36,0:31:34.00,English,,0,0,0,,Okay so that makes the code a little tighter
Dialogue: 0,0:31:34.56,0:31:38.52,English,,0,0,0,,But we'll go even further than that and we'll define these wrappers
Dialogue: 0,0:31:38.52,0:31:44.80,English,,0,0,0,,Which were pioneered by a great technical writer named W.Richards Stevens
Dialogue: 0,0:31:45.86,0:31:51.62,English,,0,0,0,,And what we do here is we replace each function with an error at a wrapper
Dialogue: 0,0:31:52.10,0:31:58.02,English,,0,0,0,,That has the identical interface as the function the original function
Dialogue: 0,0:31:58.28,0:32:01.30,English,,0,0,0,,And it has the first,the first letter uppercase
Dialogue: 0,0:32:02.64,0:32:08.98,English,,0,0,0,,And then what this wrapper does is it calls,it calls the original function checks for the errors
Dialogue: 0,0:32:09.12,0:32:14.54,English,,0,0,0,,And then if there's no error returns what the original function would have returned
Dialogue: 0,0:32:15.42,0:32:20.80,English,,0,0,0,,So the behavior of this wrapper is identical to the wrapped function
Dialogue: 0,0:32:21.20,0:32:22.28,English,,0,0,0,,If there's not an error
Dialogue: 0,0:32:22.86,0:32:27.10,English,,0,0,0,,Okay and if there is an error then it deals with it somehow and prints a message
Dialogue: 0,0:32:27.52,0:32:32.92,English,,0,0,0,,And so then this allows us to make our code really compact without violating this
Dialogue: 0,0:32:33.52,0:32:36.38,English,,0,0,0,,Hard and fast rule that we have to check for errors
Dialogue: 0,0:32:40.34,0:32:44.64,English,,0,0,0,,Okay the simplest function process control functions are
Dialogue: 0,0:32:45.08,0:32:48.96,English,,0,0,0,,Functions that allow you to get the pid for the current process which is getpid
Dialogue: 0,0:32:49.66,0:32:54.58,English,,0,0,0,,Or the the processor idea of you if the parent process that created the current process
Dialogue: 0,0:32:55.26,0:33:00.58,English,,0,0,0,,Okay so this these take no arguments and they return an integer which is a process id
Dialogue: 0,0:33:05.20,0:33:09.06,English,,0,0,0,,Now Linux provides ways to create and terminate processes
Dialogue: 0,0:33:09.64,0:33:17.68,English,,0,0,0,,And from a programmers perspective we can think of a process as being in one of three states running
Dialogue: 0,0:33:17.76,0:33:22.06,English,,0,0,0,,So in this case the process is actually running and executes instructions
Dialogue: 0,0:33:22.68,0:33:25.74,English,,0,0,0,,Or it can be scheduled
Dialogue: 0,0:33:25.74,0:33:28.88,English,,0,0,0,,Maybe it's not running but it can be scheduled at a later time
Dialogue: 0,0:33:31.12,0:33:33.24,English,,0,0,0,,And it's waiting is waiting to be scheduled
Dialogue: 0,0:33:33.98,0:33:39.36,English,,0,0,0,,It can be stopped which means that execution is suspended
Dialogue: 0,0:33:40.68,0:33:42.80,English,,0,0,0,,And won't be scheduled until further notice
Dialogue: 0,0:33:42.82,0:33:46.10,English,,0,0,0,,So we'll see how this works when we study signals in the next lecture
Dialogue: 0,0:33:46.28,0:33:51.28,English,,0,0,0,,But usually a process is stopped because it receives a certain kind of signal
Dialogue: 0,0:33:51.78,0:33:55.76,English,,0,0,0,,And then that the process becomes stopped in ways it won't be executed
Dialogue: 0,0:33:56.42,0:34:02.46,English,,0,0,0,,It won't be scheduled until you explicitly tell it to be scheduled
Dialogue: 0,0:34:02.88,0:34:06.60,English,,0,0,0,,Or process can be terminated which means it stopped permanently
Dialogue: 0,0:34:06.84,0:34:08.94,English,,0,0,0,,Okay so it'll never be scheduled again it's done
Dialogue: 0,0:34:11.58,0:34:14.80,English,,0,0,0,,Now a process can be terminated for one of three reasons
Dialogue: 0,0:34:15.48,0:34:20.26,English,,0,0,0,,So one it receives a signal whose default action is to terminate it
Dialogue: 0,0:34:20.86,0:34:24.86,English,,0,0,0,,Or your program returns from the main routine
Dialogue: 0,0:34:25.16,0:34:28.84,English,,0,0,0,,So you know you can...if you know the definition for main is int
Dialogue: 0,0:34:30.02,0:34:31.82,English,,0,0,0,,See main routines always return an int
Dialogue: 0,0:34:32.78,0:34:35.22,English,,0,0,0,,So you can return from main and that will terminate your
Dialogue: 0,0:34:35.74,0:34:40.52,English,,0,0,0,,Event it will terminate the process or you can explicitly call the exit function
Dialogue: 0,0:34:41.96,0:34:49.06,English,,0,0,0,,The exit function exits the program with an exit status of the of its argument
Dialogue: 0,0:34:49.76,0:34:56.02,English,,0,0,0,,So as as you pointed out that the convention is that for normal return is to return 0
Dialogue: 0,0:34:56.34,0:34:57.72,English,,0,0,0,,And then nonzero on error
Dialogue: 0,0:34:59.36,0:35:04.62,English,,0,0,0,,Or you can...another way to do this is just return an integer value from the main routine
Dialogue: 0,0:35:04.86,0:35:06.34,English,,0,0,0,,And that will set the exit status
Dialogue: 0,0:35:07.54,0:35:09.44,English,,0,0,0,,Now exit is kind of unusual
Dialogue: 0,0:35:09.44,0:35:13.96,English,,0,0,0,,And you'll see this is typical of all these process control functions
Dialogue: 0,0:35:14.54,0:35:18.90,English,,0,0,0,,That they normally functions you call them once and then they return once
Dialogue: 0,0:35:19.54,0:35:22.50,English,,0,0,0,,Okay but exit you call once and then it never returns
Dialogue: 0,0:35:23.32,0:35:27.46,English,,0,0,0,,Okay so that's a little unusual
Dialogue: 0,0:35:29.14,0:35:34.02,English,,0,0,0,,Now a parent process can create a child process by calling the fork function
Dialogue: 0,0:35:35.86,0:35:39.26,English,,0,0,0,,So fork takes no arguments
Dialogue: 0,0:35:41.94,0:35:47.54,English,,0,0,0,,And it returns an integer,it creates a new child process
Dialogue: 0,0:35:49.70,0:35:53.18,English,,0,0,0,,And then it returns in both the parent and the child
Dialogue: 0,0:35:55.26,0:35:57.72,English,,0,0,0,,So this is a little hard to wrap your head around at first
Dialogue: 0,0:35:58.02,0:36:00.24,English,,0,0,0,,It's called once by the parent
Dialogue: 0,0:36:01.58,0:36:08.16,English,,0,0,0,,But then it returns in both...it creates a new process and then it returns in both the parent and the child
Dialogue: 0,0:36:09.82,0:36:11.90,English,,0,0,0,,And to the child it returns 0
Dialogue: 0,0:36:13.12,0:36:16.52,English,,0,0,0,,To the parent return it returns to the child's process id
Dialogue: 0,0:36:21.86,0:36:26.12,English,,0,0,0,,Okay the child gets an identical copy of the parents virtual address space
Dialogue: 0,0:36:26.94,0:36:29.99,English,,0,0,0,,But separate right there they're distinct
Dialogue: 0,0:36:30.86,0:36:37.36,English,,0,0,0,,But immediately after the fork returns the addresses the address space is identical
Dialogue: 0,0:36:37.70,0:36:43.56,English,,0,0,0,,So that means that all the variables,all the global variables the stack  the code
Dialogue: 0,0:36:44.22,0:36:50.10,English,,0,0,0,,Everything is identical and the child it has the exact same values as it as it does in the parent
Dialogue: 0,0:36:51.86,0:36:56.98,English,,0,0,0,,The child gets identical copies of the parents open open file descriptors
Dialogue: 0,0:36:57.02,0:37:04.16,English,,0,0,0,,So the child has access to any open files including like standard in and standard out that the parent had
Dialogue: 0,0:37:05.60,0:37:09.50,English,,0,0,0,,And the only difference is that the child gets a different process id than the parent
Dialogue: 0,0:37:10.88,0:37:12.78,English,,0,0,0,,So fork is really strange
Dialogue: 0,0:37:13.66,0:37:19.02,English,,0,0,0,,Because it's called once,but returns twice once, in the parent and once in the child
Dialogue: 0,0:37:21.56,0:37:23.04,English,,0,0,0,,So here's an example of this
Dialogue: 0,0:37:25.94,0:37:34.66,English,,0,0,0,,Here's...this is an example program, it has a local variable called x on the stack initialized to 1
Dialogue: 0,0:37:36.62,0:37:48.60,English,,0,0,0,,And then it calls fork and fork creates the child and returns a value to that both the parent and the child
Dialogue: 0,0:37:50.56,0:37:55.84,English,,0,0,0,,The only way we can distinguish whether we're executing in the parent or the child is to check that return value
Dialogue: 0,0:37:56.84,0:38:00.02,English,,0,0,0,,Okay so here if the process id if pid == 0
Dialogue: 0,0:38:00.52,0:38:02.02,English,,0,0,0,,Then we're executing in the child
Dialogue: 0,0:38:02.74,0:38:14.10,English,,0,0,0,,Now remember the child got exactly the same has exactly the same memory and encode is the parent
Dialogue: 0,0:38:15.14,0:38:18.46,English,,0,0,0,,So x in the child is 1
Dialogue: 0,0:38:18.86,0:38:25.20,English,,0,0,0,,So when we print this message from the child,we increment x and then print this message
Dialogue: 0,0:38:25.80,0:38:29.52,English,,0,0,0,,So the child will print 1+1=2
Dialogue: 0,0:38:30.52,0:38:31.56,English,,0,0,0,,And then exit
Dialogue: 0,0:38:33.60,0:38:36.40,English,,0,0,0,,In the parent when we check that this process id
Dialogue: 0,0:38:36.40,0:38:39.96,English,,0,0,0,,It's going to be nonzero because it's the process id of the child
Dialogue: 0,0:38:40.56,0:38:46.52,English,,0,0,0,,So in this case...so the parent won't execute this the body of this conditional
Dialogue: 0,0:38:47.28,0:38:49.60,English,,0,0,0,,So the parent will execute this printf
Dialogue: 0,0:38:50.20,0:38:53.00,English,,0,0,0,,And in the parent we decrement x before we print it
Dialogue: 0,0:38:53.46,0:38:57.18,English,,0,0,0,,So the parent prints out 1-1 is 0
Dialogue: 0,0:38:58.84,0:39:05.04,English,,0,0,0,,Now there's no guarantee we have no guarantee whether the child or the parent executes first
Dialogue: 0,0:39:05.04,0:39:07.46,English,,0,0,0,,It could at when the fork
Dialogue: 0,0:39:08.34,0:39:12.46,English,,0,0,0,,When the fork returns the kernel may decide to schedule the child first
Dialogue: 0,0:39:13.70,0:39:18.40,English,,0,0,0,,Okay in which case this code in the body of the conditional would run
Dialogue: 0,0:39:18.96,0:39:22.20,English,,0,0,0,,Or it may decide to run the parent first okay
Dialogue: 0,0:39:23.00,0:39:28.06,English,,0,0,0,,And there's no way to predict and you it's is wrong,it's an error to make any assumption
Dialogue: 0,0:39:28.92,0:39:31.36,English,,0,0,0,,Like that about what's going to run first the parent of the child
Dialogue: 0,0:39:33.06,0:39:35.90,English,,0,0,0,,And you can see that they share the same open files because
Dialogue: 0,0:39:36.64,0:39:42.24,English,,0,0,0,,Both the parent and the child print to standard out and it prints on the terminal okay
Dialogue: 0,0:39:43.04,0:39:46.54,English,,0,0,0,,Yes
Dialogue: 0,0:39:46.58,0:39:50.44,English,,0,0,0,,Oh what if...the question is what if you call fork multiple times, I'll show you some examples of those
Dialogue: 0,0:39:52.70,0:39:59.78,English,,0,0,0,,It gets a little hairy will have...will use a model called the process graph to sort sort of understand what happens
Dialogue: 0,0:40:04.52,0:40:10.88,English,,0,0,0,,Okay so like just like you said forks,forks can be kind of complex
Dialogue: 0,0:40:11.12,0:40:14.52,English,,0,0,0,,And time to sin especially if they're nested or you call them multiple times
Dialogue: 0,0:40:15.12,0:40:24.54,English,,0,0,0,,So we use a tool called the process graph to capture sort of what could happen when we call forks
Dialogue: 0,0:40:24.66,0:40:30.18,English,,0,0,0,,Right we can't make any assumption about the ordering of of different processes
Dialogue: 0,0:40:30.50,0:40:35.88,English,,0,0,0,,But we can capture the partial ordering of events using this tool called a process graph
Dialogue: 0,0:40:36.86,0:40:41.20,English,,0,0,0,,So what we'll do is we'll let each vertex correspond to the execution of a statement
Dialogue: 0,0:40:42.06,0:40:46.84,English,,0,0,0,,And then an edge is that happens before relation so a happens before b
Dialogue: 0,0:40:47.38,0:40:50.16,English,,0,0,0,,And we will label edges with current values of variables
Dialogue: 0,0:40:50.94,0:40:52.94,English,,0,0,0,,If we have a printf vertices
Dialogue: 0,0:40:53.38,0:40:57.44,English,,0,0,0,,A printed x that corresponds to a printf we can label that with the output
Dialogue: 0,0:40:58.28,0:41:02.38,English,,0,0,0,,And then the every graph starts with a vertex with no edges
Dialogue: 0,0:41:03.56,0:41:07.28,English,,0,0,0,,So given this graph then any topological sort of the graph represents
Dialogue: 0,0:41:07.58,0:41:11.98,English,,0,0,0,,Some feasible total ordering of events
Dialogue: 0,0:41:13.08,0:41:17.30,English,,0,0,0,,And by topological sort we mean a total ordering of the vertices
Dialogue: 0,0:41:17.40,0:41:19.98,English,,0,0,0,,Where all the edges go from left to right
Dialogue: 0,0:41:22.18,0:41:24.82,English,,0,0,0,,Okay so let's look at how this would work for our example program
Dialogue: 0,0:41:27.04,0:41:31.74,English,,0,0,0,,Here we have the parent initially x==1
Dialogue: 0,0:41:32.60,0:41:34.12,English,,0,0,0,,And then the parent calls fork
Dialogue: 0,0:41:36.00,0:41:39.72,English,,0,0,0,,The fork returns in both the parent and the child
Dialogue: 0,0:41:40.88,0:41:48.76,English,,0,0,0,,The child prints...and both the parent and the child print the value of x  after incrementing or decrementing
Dialogue: 0,0:41:49.38,0:41:50.46,English,,0,0,0,,And then they both exit
Dialogue: 0,0:41:51.44,0:41:52.84,English,,0,0,0,,Ok so you can think of these
Dialogue: 0,0:41:54.76,0:42:01.94,English,,0,0,0,,As happening...so these happen concurrently right which means they can be interleaved in any way the
Dialogue: 0,0:42:01.94,0:42:07.84,English,,0,0,0,,So the topological sort of this graph will tell us a feasible
Dialogue: 0,0:42:08.48,0:42:11.06,English,,0,0,0,,What's a feasible? What feasible inter leavings?
Dialogue: 0,0:42:14.26,0:42:18.96,English,,0,0,0,,Okay so we can...so if we real able the graph just to keep it simple
Dialogue: 0,0:42:18.96,0:42:22.68,English,,0,0,0,,So if we real able these edges with just single letters
Dialogue: 0,0:42:25.76,0:42:30.04,English,,0,0,0,,Then this total ordering abecfd
Dialogue: 0,0:42:30.80,0:42:36.04,English,,0,0,0,,Represent is represents it's a topological sort and thus a feasible total ordering
Dialogue: 0,0:42:36.56,0:42:40.40,English,,0,0,0,,So here we have a executing then b
Dialogue: 0,0:42:41.60,0:42:43.36,English,,0,0,0,,Then e execute in the child
Dialogue: 0,0:42:44.50,0:42:55.70,English,,0,0,0,,And then at this point the kernel decides to swap out,swap out e, swap out the child and now let the parent run
Dialogue: 0,0:42:56.12,0:42:59.44,English,,0,0,0,,So the parent picks up and executes c
Dialogue: 0,0:43:01.04,0:43:06.12,English,,0,0,0,,And then it gets rescheduled to chat then the child gets scheduled and executes f
Dialogue: 0,0:43:06.54,0:43:09.48,English,,0,0,0,,And then the parent the parent runs and finally finishes
Dialogue: 0,0:43:10.18,0:43:12.76,English,,0,0,0,,Right so this is very unlikely that
Dialogue: 0,0:43:13.28,0:43:20.20,English,,0,0,0,,It you only execute one instruction and then b,and then have a context switch but it's it's feasible
Dialogue: 0,0:43:20.98,0:43:22.45,English,,0,0,0,,Right because it represents
Dialogue: 0,0:43:23.28,0:43:27.88,English,,0,0,0,,Because the total ordering is a topological ordering
Dialogue: 0,0:43:29.16,0:43:34.70,English,,0,0,0,,On the other hand this is infeasible because f
Dialogue: 0,0:43:35.66,0:43:39.48,English,,0,0,0,,Here in this total ordering we're executing f before e
Dialogue: 0,0:43:40.30,0:43:43.26,English,,0,0,0,,And you can see that this that just can't happen right
Dialogue: 0,0:43:43.26,0:43:47.96,English,,0,0,0,,So the edges on these the logical flow represented by this child
Dialogue: 0,0:43:48.20,0:43:51.82,English,,0,0,0,,Have to occur in this order first e and then f right
Dialogue: 0,0:43:51.92,0:43:59.92,English,,0,0,0,,By the just because f follows e in the code right that the compilers not
Dialogue: 0,0:44:04.02,0:44:04.98,English,,0,0,0,,Going to it's not going to alter those
Dialogue: 0,0:44:07.06,0:44:09.64,English,,0,0,0,,Okay so what happens if now we have two consecutive forks
Dialogue: 0,0:44:13.46,0:44:17.56,English,,0,0,0,,Well let's draw the process graph will help us understand this
Dialogue: 0,0:44:18.38,0:44:22.78,English,,0,0,0,,So in the parent we print L0  and then fork
Dialogue: 0,0:44:23.76,0:44:26.48,English,,0,0,0,,And that creates a child and both
Dialogue: 0,0:44:27.44,0:44:31.04,English,,0,0,0,,And so the fork returns to this printf in both the parent and the child
Dialogue: 0,0:44:31.04,0:44:34.58,English,,0,0,0,,So they both the parent and the child print L1
Dialogue: 0,0:44:36.86,0:44:39.40,English,,0,0,0,,And then both parent and child execute a fork
Dialogue: 0,0:44:41.54,0:44:47.22,English,,0,0,0,,So that creates another child,that creates two more,now two children
Dialogue: 0,0:44:48.48,0:44:53.90,English,,0,0,0,,And then and so that returns to the printf which says bye
Dialogue: 0,0:44:54.80,0:44:59.50,English,,0,0,0,,So the result of this of calling fork twice like this is that it creates four processes
Dialogue: 0,0:45:01.40,0:45:02.16,English,,0,0,0,,And you can
Dialogue: 0,0:45:02.80,0:45:06.66,English,,0,0,0,,And if it's confusing you can always work it out with the the process graph like this
Dialogue: 0,0:45:07.18,0:45:11.84,English,,0,0,0,,Okay so we can see feasible and infeasible orderings
Dialogue: 0,0:45:12.66,0:45:14.68,English,,0,0,0,,So this one's feasible take my word for
Dialogue: 0,0:45:14.70,0:45:16.92,English,,0,0,0,,This one is infeasible
Dialogue: 0,0:45:17.62,0:45:19.88,English,,0,0,0,,And let's see why so L0
Dialogue: 0,0:45:22.06,0:45:28.18,English,,0,0,0,,And there's no way to print by before the first fork
Dialogue: 0,0:45:28.56,0:45:29.66,English,,0,0,0,,All right so that's infeasible
Dialogue: 0,0:45:29.82,0:45:34.82,English,,0,0,0,,If we drew out this process graph we'd have a backward edge
Dialogue: 0,0:45:38.38,0:45:41.47,English,,0,0,0,,Okay now what happens if we nest forks in the parent
Dialogue: 0,0:45:41.88,0:45:45.60,English,,0,0,0,,Okay I'm not sure why you'd want to do this except maybe to torture 213 students
Dialogue: 0,0:45:46.78,0:45:47.22,English,,0,0,0,,But
Dialogue: 0,0:45:50.80,0:45:53.50,English,,0,0,0,,So we can just work this out by drawing the process graph
Dialogue: 0,0:45:54.86,0:45:57.12,English,,0,0,0,,So here we have the parent it prints L0
Dialogue: 0,0:45:57.76,0:46:01.04,English,,0,0,0,,And then it does a fork so that creates a child
Dialogue: 0,0:46:04.02,0:46:09.74,English,,0,0,0,,So the child if fork is not equal to 0
Dialogue: 0,0:46:10.86,0:46:13.82,English,,0,0,0,,Then we're in the parent right so this code executes in the parent
Dialogue: 0,0:46:15.44,0:46:16.88,English,,0,0,0,,If fork is 0
Dialogue: 0,0:46:17.74,0:46:21.14,English,,0,0,0,,Then we're executing the child and the child just prints by and then
Dialogue: 0,0:46:23.06,0:46:28.78,English,,0,0,0,,And then terminate it eventually terminates I didn't show it here but  calls exit
Dialogue: 0,0:46:29.60,0:46:32.58,English,,0,0,0,,Think the function that called this function calls exit
Dialogue: 0,0:46:33.98,0:46:40.70,English,,0,0,0,,So the parent,so fork not equal to 0 indicates that this is the parent
Dialogue: 0,0:46:42.26,0:46:46.00,English,,0,0,0,,So the parent prints L1 and then it does another fork
Dialogue: 0,0:46:47.16,0:46:48.64,English,,0,0,0,,That fork creates a child
Dialogue: 0,0:46:52.00,0:46:54.88,English,,0,0,0,,So if fork is not equal to 0
Dialogue: 0,0:46:55.50,0:47:02.50,English,,0,0,0,,Then we're in the parent so the parent prints L2 and then exits this conditional and prints by
Dialogue: 0,0:47:03.62,0:47:08.90,English,,0,0,0,,If fork returns 0 then that means we're executing the child
Dialogue: 0,0:47:08.96,0:47:12.60,English,,0,0,0,,So we don't execute this code we jump out of this conditional
Dialogue: 0,0:47:12.98,0:47:15.32,English,,0,0,0,,And then the child just prints by
Dialogue: 0,0:47:16.32,0:47:16.72,English,,0,0,0,,Okay
Dialogue: 0,0:47:19.26,0:47:20.26,English,,0,0,0,,And we can
Dialogue: 0,0:47:23.76,0:47:27.42,English,,0,0,0,,So this represents an infeasible output from this program
Dialogue: 0,0:47:30.10,0:47:30.98,English,,0,0,0,,L0...
Dialogue: 0,0:47:32.74,0:47:36.02,English,,0,0,0,,So L0 followed by bye, that's feasible
Dialogue: 0,0:47:37.18,0:47:39.56,English,,0,0,0,,And then followed by L1 that's okay
Dialogue: 0,0:47:42.58,0:47:45.32,English,,0,0,0,,And then the next bye is okay but it since
Dialogue: 0,0:47:45.80,0:47:51.86,English,,0,0,0,,We can't have this...we can't have this by proceeding this L2
Dialogue: 0,0:47:52.74,0:47:58.08,English,,0,0,0,,Because L2 will this printf will execute before this printf
Dialogue: 0,0:48:00.80,0:48:07.54,English,,0,0,0,,Okay and I'll let you work out this one as an exercise
Dialogue: 0,0:48:09.14,0:48:14.28,English,,0,0,0,,All right now when a process terminates for whatever reason
Dialogue: 0,0:48:14.70,0:48:18.08,English,,0,0,0,,The system actually keeps it around for until it's reaped
Dialogue: 0,0:48:19.36,0:48:22.10,English,,0,0,0,,And the reason until it's reaped by its parent
Dialogue: 0,0:48:23.20,0:48:28.38,English,,0,0,0,,And the reason it does this is that the parent may want to know about the exit status of the child
Dialogue: 0,0:48:28.40,0:48:30.56,English,,0,0,0,,So but if a parent creates a child
Dialogue: 0,0:48:31.04,0:48:35.90,English,,0,0,0,,It may want to wait for that child to finish and and check its exit status
Dialogue: 0,0:48:36.76,0:48:38.60,English,,0,0,0,,So when any process terminates
Dialogue: 0,0:48:38.96,0:48:43.52,English,,0,0,0,,The system leaves that it doesn't remove it entirely from the system
Dialogue: 0,0:48:43.74,0:48:46.96,English,,0,0,0,,It keeps it a little bit of state associated with that child
Dialogue: 0,0:48:47.40,0:48:50.88,English,,0,0,0,,In the form of a the exit status of the child
Dialogue: 0,0:48:51.54,0:48:55.74,English,,0,0,0,,And the in some other tables some other OS tables
Dialogue: 0,0:48:56.70,0:49:00.38,English,,0,0,0,,So because this child that's terminated but it's not gone
Dialogue: 0,0:49:01.04,0:49:04.42,English,,0,0,0,,It they're called zombies so there's sort of half half-living half-dead
Dialogue: 0,0:49:08.34,0:49:11.16,English,,0,0,0,,And so a process a zombie
Dialogue: 0,0:49:11.52,0:49:15.52,English,,0,0,0,,Remains a zombie until it's reaped by its parent
Dialogue: 0,0:49:16.00,0:49:18.38,English,,0,0,0,,Using a function called wait or waitpid
Dialogue: 0,0:49:19.46,0:49:22.98,English,,0,0,0,,And as a result of doing wait or waitpid
Dialogue: 0,0:49:23.14,0:49:25.66,English,,0,0,0,,The parent is given the exit status information
Dialogue: 0,0:49:26.00,0:49:28.90,English,,0,0,0,,And then the kernel deletes the zombie process
Dialogue: 0,0:49:32.12,0:49:35.94,English,,0,0,0,,Now what if the parent doesn't reap it's one of its child zombies
Dialogue: 0,0:49:36.74,0:49:42.20,English,,0,0,0,,So if any parent if the parent terminates
Dialogue: 0,0:49:43.34,0:49:47.64,English,,0,0,0,,Then the system arranges for the very first process that existed in the system
Dialogue: 0,0:49:48.14,0:49:50.90,English,,0,0,0,,Called the init process which has a process id of one
Dialogue: 0,0:49:51.18,0:49:54.46,English,,0,0,0,,It arranges for the init process to reap that that child
Dialogue: 0,0:49:57.26,0:50:04.52,English,,0,0,0,,So there's so orphaned children will always be reaped by the init process
Dialogue: 0,0:50:04.92,0:50:10.04,English,,0,0,0,,So we only really have to worry about reaping zombies
Dialogue: 0,0:50:10.54,0:50:16.68,English,,0,0,0,,In the case where we have long-running parents like shells or servers
Dialogue: 0,0:50:17.44,0:50:22.30,English,,0,0,0,,Because in that case a server may create millions of child processes
Dialogue: 0,0:50:22.30,0:50:29.06,English,,0,0,0,,Each one of those does...each one of those child processes when they terminate
Dialogue: 0,0:50:29.38,0:50:31.40,English,,0,0,0,,Become zombies and they have state
Dialogue: 0,0:50:31.64,0:50:33.48,English,,0,0,0,,That takes up room in the kernel so
Dialogue: 0,0:50:34.20,0:50:37.02,English,,0,0,0,,You can get this it's a form of memory leak
Dialogue: 0,0:50:37.92,0:50:43.60,English,,0,0,0,,If you don't...if you don't reap these zombie children that can eventually fill up the memory space and crash the kernel
Dialogue: 0,0:50:48.84,0:50:52.32,English,,0,0,0,,So for cases where you have long-running programs
Dialogue: 0,0:50:52.32,0:50:56.48,English,,0,0,0,,Then we have to use wait or waitpit to reap the children
Dialogue: 0,0:50:58.32,0:51:05.86,English,,0,0,0,,So let's look at an example,first let's look at an example of this zombie phenomenon
Dialogue: 0,0:51:06.56,0:51:09.06,English,,0,0,0,,So here we have a function we call fork
Dialogue: 0,0:51:10.14,0:51:17.18,English,,0,0,0,,And then within the child we print a message of the process idea of that child and then we exit the child
Dialogue: 0,0:51:18.24,0:51:22.48,English,,0,0,0,,Within the parent we print a message and then we go into an infinite loop
Dialogue: 0,0:51:22.92,0:51:28.74,English,,0,0,0,,Okay so this is a parent that's that never reaps the child that it created
Dialogue: 0,0:51:30.00,0:51:34.18,English,,0,0,0,,So if we run this program called forks
Dialogue: 0,0:51:36.20,0:51:38.32,English,,0,0,0,,You can see it prints these two messages
Dialogue: 0,0:51:39.92,0:51:44.98,English,,0,0,0,,The parent prints a message and the child prints a message and then
Dialogue: 0,0:51:46.28,0:51:48.92,English,,0,0,0,,And we're running it in the background with this ampersand
Dialogue: 0,0:51:49.16,0:51:54.04,English,,0,0,0,,Okay because we're going to otherwise it would...it's still running
Dialogue: 0,0:51:54.04,0:51:56.76,English,,0,0,0,,And we wouldn't be able to inspect it
Dialogue: 0,0:51:57.32,0:51:59.50,English,,0,0,0,,So after we run this program in the background
Dialogue: 0,0:51:59.96,0:52:02.32,English,,0,0,0,,Then we use ps to print the current processes
Dialogue: 0,0:52:03.00,0:52:08.92,English,,0,0,0,,And we can see that there's two...we can see here at the parent which is process id 6639
Dialogue: 0,0:52:09.76,0:52:12.74,English,,0,0,0,,And then the child which is 6640 and
Dialogue: 0,0:52:14.70,0:52:16.88,English,,0,0,0,,That the defunct indicates that it's a zombie
Dialogue: 0,0:52:19.16,0:52:23.78,English,,0,0,0,,Okay now if we kill 6639 that's the parent
Dialogue: 0,0:52:25.78,0:52:30.32,English,,0,0,0,,And then do another ps you see that the zombies gone that the child is gone
Dialogue: 0,0:52:30.32,0:52:33.02,English,,0,0,0,,Because it's been reaped by the init process one
Dialogue: 0,0:52:36.82,0:52:41.36,English,,0,0,0,,Now what happens if the child doesn't terminate you might wonder like if a parent creates a child
Dialogue: 0,0:52:43.40,0:52:50.66,English,,0,0,0,,And then the parent,and then the child never terminates
Dialogue: 0,0:52:51.64,0:52:54.88,English,,0,0,0,,And the parent terminates then what would happen right mark
Dialogue: 0,0:52:56.54,0:52:58.94,English,,0,0,0,,So let's just let's look at an example of those in C
Dialogue: 0,0:52:59.92,0:53:04.52,English,,0,0,0,,So here we're calling fork we're creating a child
Dialogue: 0,0:53:05.34,0:53:10.48,English,,0,0,0,,Within the child we'd print a message and then the child goes into an infinite loop
Dialogue: 0,0:53:11.80,0:53:15.48,English,,0,0,0,,And the parent prints a message and then exits
Dialogue: 0,0:53:16.74,0:53:18.12,English,,0,0,0,,So if we run this program
Dialogue: 0,0:53:20.58,0:53:23.72,English,,0,0,0,,You can see that the two messages from parent and child
Dialogue: 0,0:53:25.52,0:53:28.68,English,,0,0,0,,And then if we look at the...if we look at the processes
Dialogue: 0,0:53:28.68,0:53:32.30,English,,0,0,0,,We can see that the child is still running
Dialogue: 0,0:53:39.58,0:53:43.52,English,,0,0,0,,Okay so the channel process is still running even though the parents's has terminated
Dialogue: 0,0:53:45.06,0:53:48.90,English,,0,0,0,,And now if we kill this child 6676
Dialogue: 0,0:53:54.70,0:53:59.08,English,,0,0,0,,And then if we kill it,then we can see that it's it's gone,it's no longer in the system okay so
Dialogue: 0,0:54:00.12,0:54:02.72,English,,0,0,0,,That child when we killed it that terminated
Dialogue: 0,0:54:03.46,0:54:09.36,English,,0,0,0,,It it had no parents so the unit process reaped it and it it's no longer a zombie
Dialogue: 0,0:54:12.08,0:54:19.20,English,,0,0,0,,So the function that we use to synchronize with children and reap them
Dialogue: 0,0:54:20.74,0:54:22.20,English,,0,0,0,,The simplest one is called wait
Dialogue: 0,0:54:23.50,0:54:27.20,English,,0,0,0,,And wait it takes an optional status
Dialogue: 0,0:54:28.64,0:54:33.20,English,,0,0,0,,Where you can get the exit status of the inspect the exit status of the child
Dialogue: 0,0:54:34.26,0:54:39.14,English,,0,0,0,,Basically wait suspends the execution of the process that calls it
Dialogue: 0,0:54:40.12,0:54:42.36,English,,0,0,0,,Until one or one of its children terminates
Dialogue: 0,0:54:42.88,0:54:48.26,English,,0,0,0,,And it doesn't specify which one it just waits,until one of the children that it created terminates
Dialogue: 0,0:54:50.48,0:54:53.16,English,,0,0,0,,And then if this child status is not null
Dialogue: 0,0:54:54.02,0:54:58.82,English,,0,0,0,,Then the integer that it returns or the integer that it points to this is a pointer
Dialogue: 0,0:54:59.50,0:55:05.54,English,,0,0,0,,The integer that it points to will be set to some value that indicated the reason the child terminated and its exit status
Dialogue: 0,0:55:06.10,0:55:08.50,English,,0,0,0,,And you can check that using these macros
Dialogue: 0,0:55:10.00,0:55:14.16,English,,0,0,0,,Which your textbook describes in more detail and let you
Dialogue: 0,0:55:16.61,0:55:19.24,English,,0,0,0,,So let's look at how this works in a simple example
Dialogue: 0,0:55:19.88,0:55:26.04,English,,0,0,0,,So here we're calling fork and creating a child which prints a message and then exits
Dialogue: 0,0:55:27.88,0:55:33.14,English,,0,0,0,,The parent prints a message and then it waits for the child to terminate
Dialogue: 0,0:55:34.14,0:55:37.40,English,,0,0,0,,And when the child terminates it prints a message
Dialogue: 0,0:55:38.24,0:55:41.74,English,,0,0,0,,And indicating that the child terminated and then prints by
Dialogue: 0,0:55:42.40,0:55:45.34,English,,0,0,0,,So if we were to look at the process graph for this
Dialogue: 0,0:55:46.14,0:55:50.36,English,,0,0,0,,You would see that we would have the fork creates the parent and the child
Dialogue: 0,0:55:51.52,0:55:54.14,English,,0,0,0,,Both the parent and the child do they're printf
Dialogue: 0,0:55:55.74,0:56:04.46,English,,0,0,0,,And then the parent waits it suspends until that the child terminates in this case by calling exit
Dialogue: 0,0:56:07.56,0:56:10.10,English,,0,0,0,,Okay so what that means is it's infeasible
Dialogue: 0,0:56:13.10,0:56:14.70,English,,0,0,0,,So you can say hello from the parent
Dialogue: 0,0:56:18.40,0:56:20.07,English,,0,0,0,,It's infeasible though for this
Dialogue: 0,0:56:20.92,0:56:26.46,English,,0,0,0,,This child terminated message CT to occur before the bye
Dialogue: 0,0:56:28.42,0:56:29.30,English,,0,0,0,,Because
Dialogue: 0,0:56:34.10,0:56:37.70,English,,0,0,0,,Because the child hasn't yet terminated so
Dialogue: 0,0:56:39.62,0:56:42.36,English,,0,0,0,,It's these two...these two messages will never be printed
Dialogue: 0,0:56:42.86,0:56:45.46,English,,0,0,0,,Until the child is terminated by calling exit
Dialogue: 0,0:56:47.92,0:56:49.42,English,,0,0,0,,So is that clear yes
Dialogue: 0,0:56:56.32,0:56:58.72,English,,0,0,0,,So the question is can you have an output HP
Dialogue: 0,0:57:03.24,0:57:09.08,English,,0,0,0,,HP,HC,CT bye yes
Dialogue: 0,0:57:10.76,0:57:20.32,English,,0,0,0,,Yes because the parent prints HP, there's a context switch the child prints HC and then exits
Dialogue: 0,0:57:21.20,0:57:24.25,English,,0,0,0,,And now the parent will the wait will return
Dialogue: 0,0:57:24.56,0:57:26.42,English,,0,0,0,,And then it prints CT bye
Dialogue: 0,0:57:33.32,0:57:41.02,English,,0,0,0,,Okay here's this is a...this is a little more a little more involved example
Dialogue: 0,0:57:41.56,0:57:44.42,English,,0,0,0,,So here what we want to do we're going to create a bunch of children
Dialogue: 0,0:57:45.06,0:57:47.42,English,,0,0,0,,And then we're going to wait for them all to terminate
Dialogue: 0,0:57:48.10,0:57:52.70,English,,0,0,0,,And we're going to wait but we won't be able to wait in any specific order right we're just...
Dialogue: 0,0:57:55.28,0:57:58.02,English,,0,0,0,,So here we have a loop 0 through n
Dialogue: 0,0:57:59.24,0:58:06.44,English,,0,0,0,,And in each loop body we're going to fork a child and exit with a return status
Dialogue: 0,0:58:06.44,0:58:08.62,English,,0,0,0,,That that's going to tell us which child it was
Dialogue: 0,0:58:12.02,0:58:16.86,English,,0,0,0,,In the parent so we do this n times
Dialogue: 0,0:58:18.96,0:58:25.78,English,,0,0,0,,And then afterward the parent inside a similar loop 0 to n
Dialogue: 0,0:58:26.32,0:58:29.18,English,,0,0,0,,Add waits for a child to terminate
Dialogue: 0,0:58:29.18,0:58:32.22,English,,0,0,0,,So it will wait for n children to terminate
Dialogue: 0,0:58:34.50,0:58:41.20,English,,0,0,0,,Wait returns the the process id
Dialogue: 0,0:58:42.22,0:58:51.26,English,,0,0,0,,And then a status which is... in this child status variable
Dialogue: 0,0:58:52.40,0:58:57.02,English,,0,0,0,,And so we take that variable now and we can use this w if exited macro to determine
Dialogue: 0,0:58:57.03,0:59:00.06,English,,0,0,0,,If it terminated normally with an exit by calling exit
Dialogue: 0,0:59:00.84,0:59:06.68,English,,0,0,0,,And if so then we can check its exit status using the WEXITSTATUS macro
Dialogue: 0,0:59:07.28,0:59:10.29,English,,0,0,0,,Otherwise if w exited it
Dialogue: 0,0:59:10.64,0:59:17.64,English,,0,0,0,,Is false then that means something the child terminated for some other reason not because it called exit
Dialogue: 0,0:59:21.32,0:59:22.60,English,,0,0,0,,Okay there's a
Dialogue: 0,0:59:24.06,0:59:28.84,English,,0,0,0,,We can actually use waitpit which is similar to wait
Dialogue: 0,0:59:28.84,0:59:33.08,English,,0,0,0,,But it allows us to wait for a specific process a specific child
Dialogue: 0,0:59:33.32,0:59:37.72,English,,0,0,0,,A specific child with a specific process id to terminate
Dialogue: 0,0:59:38.40,0:59:44.52,English,,0,0,0,,And I'll let you can waitpit is really involved and
Dialogue: 0,0:59:44.98,0:59:48.10,English,,0,0,0,,It's described in detail in your textbook
Dialogue: 0,0:59:48.48,0:59:52.20,English,,0,0,0,,And so you'll need to look, you'll need to look there for the details on how that works
Dialogue: 0,0:59:55.08,0:59:58.68,English,,0,0,0,,Now another important so we've learned how to create new processes
Dialogue: 0,1:00:02.38,1:00:05.30,English,,0,0,0,,The but we haven't learned how to when we call fork
Dialogue: 0,1:00:05.30,1:00:10.82,English,,0,0,0,,We just create an exact copy of the child is just an exact copy of the parent
Dialogue: 0,1:00:11.24,1:00:14.26,English,,0,0,0,,Running the same code,same program,same variables
Dialogue: 0,1:00:14.98,1:00:20.28,English,,0,0,0,,Okay to run a different program inside of a process we use a function called execve
Dialogue: 0,1:00:22.50,1:00:26.40,English,,0,0,0,,And execve loads and runs
Dialogue: 0,1:00:28.38,1:00:30.92,English,,0,0,0,,Within the current process it loads and runs
Dialogue: 0,1:00:31.46,1:00:34.54,English,,0,0,0,,The executable file name which is its first argument
Dialogue: 0,1:00:35.48,1:00:39.16,English,,0,0,0,,And file name can be either a binary executable binary
Dialogue: 0,1:00:40.52,1:00:43.54,English,,0,0,0,,Okay or it can be a script,it can be a text file
Dialogue: 0,1:00:45.22,1:00:47.72,English,,0,0,0,,A so-called script file that starts
Dialogue: 0,1:00:49.08,1:00:56.50,English,,0,0,0,,Whose first line starts with a pound bang and then that the path of some interpreter
Dialogue: 0,1:00:56.78,1:00:59.58,English,,0,0,0,,So for example if you want to write a shell script
Dialogue: 0,1:01:00.50,1:01:05.57,English,,0,0,0,,You the first line of your shell script is a pound bang and then
Dialogue: 0,1:01:06.02,1:01:07.96,English,,0,0,0,,The path name of the bash
Dialogue: 0,1:01:08.94,1:01:11.50,English,,0,0,0,,And then that will execute bash
Dialogue: 0,1:01:11.90,1:01:17.34,English,,0,0,0,,And then bash will read in that the lines following and interpret them
Dialogue: 0,1:01:18.08,1:01:21.04,English,,0,0,0,,As just as though you'd type them in at the command line
Dialogue: 0,1:01:23.10,1:01:27.42,English,,0,0,0,,So in either case it executes either an interpreter or it executes a binary
Dialogue: 0,1:01:28.42,1:01:31.96,English,,0,0,0,,With who's argued with the argument list argv
Dialogue: 0,1:01:33.04,1:01:36.24,English,,0,0,0,,And a list of environment very in envp
Dialogue: 0,1:01:38.52,1:01:41.54,English,,0,0,0,,Okay now by default are the first argument
Dialogue: 0,1:01:42.18,1:01:48.24,English,,0,0,0,,In argv is the name of the file that that's being executed so it's this file name
Dialogue: 0,1:01:51.32,1:01:52.60,English,,0,0,0,,So what that allows you to do is
Dialogue: 0,1:01:53.04,1:01:58.60,English,,0,0,0,,In your code you can check argv[0] if you want to print out the name of the file,the name of the program that's executing
Dialogue: 0,1:01:59.08,1:02:00.72,English,,0,0,0,,You just print out argv[0]
Dialogue: 0,1:02:05.98,1:02:12.04,English,,0,0,0,,Okay now and exits all of the code and the data and the stack
Dialogue: 0,1:02:12.16,1:02:16.80,English,,0,0,0,,It overwrites the completely overrides the virtual address space
Dialogue: 0,1:02:17.82,1:02:20.78,English,,0,0,0,,So once you call eggs a within a process
Dialogue: 0,1:02:22.52,1:02:25.14,English,,0,0,0,,It blows away the current program that's it
Dialogue: 0,1:02:25.70,1:02:31.70,English,,0,0,0,,Okay however it retains that it's still the same process, it's just running now a different program
Dialogue: 0,1:02:35.06,1:02:39.44,English,,0,0,0,,And so it retains the process id and any open files that you have
Dialogue: 0,1:02:43.18,1:02:47.43,English,,0,0,0,,So execve is really mind-blowing because it's called once
Dialogue: 0,1:02:48.34,1:02:49.36,English,,0,0,0,,But it never returns
Dialogue: 0,1:02:53.12,1:02:54.50,English,,0,0,0,,Except if there's an error
Dialogue: 0,1:02:54.58,1:02:59.30,English,,0,0,0,,So if this file doesn't exist for example then then exec will return on -1
Dialogue: 0,1:02:59.90,1:03:03.04,English,,0,0,0,,But otherwise in normal operation it never returns
Dialogue: 0,1:03:06.00,1:03:07.86,English,,0,0,0,,All right so let's look at the structure of the stack
Dialogue: 0,1:03:07.88,1:03:10.54,English,,0,0,0,,When this new program starts so after
Dialogue: 0,1:03:11.42,1:03:15.54,English,,0,0,0,,After exit...after the egg argv finishes its work it creates
Dialogue: 0,1:03:16.60,1:03:23.98,English,,0,0,0,,It create a new stack, it loads in new code and data creates a new empty heap
Dialogue: 0,1:03:25.70,1:03:26.78,English,,0,0,0,,Ok everything's new
Dialogue: 0,1:03:28.42,1:03:32.28,English,,0,0,0,,And the stack that it creates has the following form
Dialogue: 0,1:03:33.64,1:03:38.38,English,,0,0,0,,Ok at the bottom here's the bottom of the stack and our stack is growing this way
Dialogue: 0,1:03:40.76,1:03:42.44,English,,0,0,0,,So the first function that executes
Dialogue: 0,1:03:43.84,1:03:47.78,English,,0,0,0,,Is a function called libc_start_main
Dialogue: 0,1:03:48.44,1:03:50.50,English,,0,0,0,,So that has a stack frame
Dialogue: 0,1:03:53.83,1:03:59.00,English,,0,0,0,,So let's look this is what I'm showing here is the situation right before the startup code calls main
Dialogue: 0,1:04:00.76,1:04:07.35,English,,0,0,0,,So there's the future stack frame for main will be here at the top of this
Dialogue: 0,1:04:07.70,1:04:09.40,English,,0,0,0,,Following the top of the stack
Dialogue: 0,1:04:11.46,1:04:20.24,English,,0,0,0,,There's some padding and then the argument list in argv  is contained on the stack
Dialogue: 0,1:04:20.24,1:04:25.00,English,,0,0,0,,So that the argv is a list of pointers terminated by the null pointer
Dialogue: 0,1:04:25.72,1:04:31.29,English,,0,0,0,,And each one of these pointers points up into a string that corresponds to an argument
Dialogue: 0,1:04:32.26,1:04:38.14,English,,0,0,0,,Okay so when you run a program you specify the program name
Dialogue: 0,1:04:39.34,1:04:41.30,English,,0,0,0,,And then arguments separated by spaces
Dialogue: 0,1:04:42.86,1:04:49.94,English,,0,0,0,,Okay and so these arguments this argv is a list of pointers to those arguments strings
Dialogue: 0,1:04:51.08,1:04:55.60,English,,0,0,0,,And it's pointed to right as main is called
Dialogue: 0,1:04:55.60,1:04:59.12,English,,0,0,0,,It's the second argument to main
Dialogue: 0,1:04:59.46,1:05:05.16,English,,0,0,0,,So it's contained in %rsi the address of this argument lists
Dialogue: 0,1:05:06.10,1:05:10.78,English,,0,0,0,,The number of arguments is contained is the first argument argc
Dialogue: 0,1:05:10.82,1:05:17.08,English,,0,0,0,,And that's contained in %rdi by the x86-64  parameter passing convention
Dialogue: 0,1:05:17.68,1:05:21.62,English,,0,0,0,,Now the environment list is also contained on the stack
Dialogue: 0,1:05:21.70,1:05:28.98,English,,0,0,0,,And it too consists of a list of pointers each of which points into a environment string
Dialogue: 0,1:05:28.98,1:05:31.50,English,,0,0,0,,Which is a set of key equal value pairs okay
Dialogue: 0,1:05:33.98,1:05:38.24,English,,0,0,0,,And it's pointed to by the global environment variable environ
Dialogue: 0,1:05:39.20,1:05:46.40,English,,0,0,0,,And if it's passed in it's pointed at an envp it which is contained in %rdx
Dialogue: 0,1:05:46.40,1:05:49.40,English,,0,0,0,,Which is the always holds the third argument
Dialogue: 0,1:05:52.26,1:05:55.22,English,,0,0,0,,Okay so let's look now how we would use this
Dialogue: 0,1:05:57.44,1:06:02.08,English,,0,0,0,,So we want to within our current program we want to execute the ls command
Dialogue: 0,1:06:03.08,1:06:08.20,English,,0,0,0,,With two arguments - lt and /usr/include
Dialogue: 0,1:06:08.20,1:06:13.28,English,,0,0,0,,So what this is saying is list,list the files in /usr/include
Dialogue: 0,1:06:14.48,1:06:18.08,English,,0,0,0,,Show the long form of the listing and sort them in time order
Dialogue: 0,1:06:18.48,1:06:21.04,English,,0,0,0,,From most recently used to at least recently used
Dialogue: 0,1:06:23.08,1:06:26.66,English,,0,0,0,,So the way we do this
Dialogue: 0,1:06:28.32,1:06:31.24,English,,0,0,0,,If we just called execve it blow away our program
Dialogue: 0,1:06:31.24,1:06:35.08,English,,0,0,0,,So assuming we want to continue to do work after we execute ls
Dialogue: 0,1:06:36.24,1:06:40.78,English,,0,0,0,,The the standard way to do this is to to create a child using fork
Dialogue: 0,1:06:41.92,1:06:44.40,English,,0,0,0,,And then x act within the child
Dialogue: 0,1:06:45.60,1:06:46.84,English,,0,0,0,,Right have the child do the work
Dialogue: 0,1:06:47.76,1:06:53.56,English,,0,0,0,,And then the child terminates and the parent maybe will wait for the child maybe not right just
Dialogue: 0,1:06:55.04,1:06:56.52,English,,0,0,0,,Usually it will wait for the child
Dialogue: 0,1:06:58.44,1:07:04.62,English,,0,0,0,,So within the parent we fork a child check that it's 0
Dialogue: 0,1:07:05.78,1:07:10.88,English,,0,0,0,,And so if it's 0 then we're executing that this code executes within the child
Dialogue: 0,1:07:11.46,1:07:12.96,English,,0,0,0,,So the child does the exact
Dialogue: 0,1:07:15.02,1:07:18.52,English,,0,0,0,,It passes the name of the function since the
Dialogue: 0,1:07:19.16,1:07:22.88,English,,0,0,0,,The name of the function that we want to the program that we want to execute
Dialogue: 0,1:07:22.88,1:07:26.04,English,,0,0,0,,Is always contained in the first element of argv
Dialogue: 0,1:07:26.50,1:07:31.08,English,,0,0,0,,We call exit with a parameter of myargv[0]
Dialogue: 0,1:07:33.46,1:07:38.20,English,,0,0,0,,And we've set up the argument list in myargv
Dialogue: 0,1:07:39.62,1:07:43.34,English,,0,0,0,,And we pass the global environment variable environment
Dialogue: 0,1:07:43.54,1:07:48.70,English,,0,0,0,,We're just going to use the current list of environment variables that we have in the parent
Dialogue: 0,1:07:52.00,1:07:58.06,English,,0,0,0,,Okay and these environment variables are things of the form USER=droh current working directory
Dialogue: 0,1:08:02.22,1:08:04.04,English,,0,0,0,,And so the the...
Dialogue: 0,1:08:06.46,1:08:12.76,English,,0,0,0,,If this program in myargv[0] doesn't exist then exact will return -0
Dialogue: 0,1:08:13.28,1:08:17.19,English,,0,0,0,,So we check for that condition and then exit
Dialogue: 0,1:08:17.64,1:08:21.92,English,,0,0,0,,Otherwise it never returns right it executes ls
Dialogue: 0,1:08:22.66,1:08:24.60,English,,0,0,0,,ls the code for ls
Dialogue: 0,1:08:24.94,1:08:29.98,English,,0,0,0,,This is the name of a binary this is a /bin/ls is a binary file
Dialogue: 0,1:08:30.94,1:08:33.04,English,,0,0,0,,That binary file gets loaded into memory
Dialogue: 0,1:08:35.36,1:08:37.83,English,,0,0,0,,That code gets executed and it terminates
Dialogue: 0,1:08:38.48,1:08:42.12,English,,0,0,0,,Okay so the child at this point after the exit
Dialogue: 0,1:08:43.60,1:08:47.00,English,,0,0,0,,The child is running that the ls code
Dialogue: 0,1:08:47.00,1:08:50.56,English,,0,0,0,,And it's no longer running any of this code
Dialogue: 0,1:08:52.00,1:09:00.38,English,,0,0,0,,Now this seems the first time you see this combination of fork and exec it seems a little odd doesn't it
Dialogue: 0,1:09:00.86,1:09:01.50,English,,0,0,0,, why not just
Dialogue: 0,1:09:02.80,1:09:06.24,English,,0,0,0,,Why not just have one command that creates a new process and runs
Dialogue: 0,1:09:07.04,1:09:09.08,English,,0,0,0,,And runs a program in that process why
Dialogue: 0,1:09:09.74,1:09:15.04,English,,0,0,0,,Why separate why have these two separate fork and exec
Dialogue: 0,1:09:19.32,1:09:24.98,English,,0,0,0,,I mean in fact windows does this windows has like one command that creates a process and executes
Dialogue: 0,1:09:25.46,1:09:31.92,English,,0,0,0,,But it turns out that having a separate function like fork
Dialogue: 0,1:09:32.72,1:09:35.90,English,,0,0,0,,Just to create processes is actually really useful
Dialogue: 0,1:09:36.46,1:09:40.16,English,,0,0,0,,I mean sometimes you just want to create replicas of your current process for example
Dialogue: 0,1:09:40.58,1:09:41.79,English,,0,0,0,,Let's say you have a server
Dialogue: 0,1:09:42.64,1:09:47.86,English,,0,0,0,,And you want to create a concurrent server you want to create multiple copies of that server then you just fork
Dialogue: 0,1:09:48.76,1:09:53.92,English,,0,0,0,,A bunch you have the main the parent server can fork a bunch of children
Dialogue: 0,1:09:53.92,1:09:56.22,English,,0,0,0,,So that's useful they're just all running the same code
Dialogue: 0,1:09:56.84,1:09:59.72,English,,0,0,0,,But what's all...what this also allows you to do
Dialogue: 0,1:10:00.46,1:10:03.34,English,,0,0,0,,Is it allows you to execute code in the child
Dialogue: 0,1:10:04.12,1:10:05.98,English,,0,0,0,,Before you call execve
Dialogue: 0,1:10:07.02,1:10:12.20,English,,0,0,0,,So you may want to set some,you may want to set some...
Dialogue: 0,1:10:13.02,1:10:16.28,English,,0,0,0,,Like some signal with is especially useful when you're dealing with
Dialogue: 0,1:10:16.96,1:10:21.86,English,,0,0,0,,With things like signals if you want to block certain signals or unblock certain signals
Dialogue: 0,1:10:22.38,1:10:27.52,English,,0,0,0,,You can do it right here in this this gap between the fork and the exact
Dialogue: 0,1:10:32.94,1:10:38.96,English,,0,0,0,,Okay so that's it so just to summarize what we've talked about today
Dialogue: 0,1:10:39.86,1:10:50.04,English,,0,0,0,,Exceptions are in response to events that require some kind of non-standard or exceptional call exceptional control flow
Dialogue: 0,1:10:50.84,1:10:56.66,English,,0,0,0,,They can be generated internally in the form of interrupts or internally in the form of traps and faults
Dialogue: 0,1:10:57.62,1:11:02.64,English,,0,0,0,,So at any point in time a process has multiple a system as multiple processes
Dialogue: 0,1:11:03.32,1:11:05.84,English,,0,0,0,,Only one of which can execute on a single core
Dialogue: 0,1:11:06.62,1:11:11.54,English,,0,0,0,,So the process execution is interleaved by the kernel
Dialogue: 0,1:11:13.10,1:11:19.50,English,,0,0,0,,And each process thinks that it has total control of the processor in its address space
Dialogue: 0,1:11:21.88,1:11:24.96,English,,0,0,0,,There's only one mechanism to spawn processes that's fork
Dialogue: 0,1:11:25.92,1:11:27.80,English,,0,0,0,,And it's called once and returns twice
Dialogue: 0,1:11:29.80,1:11:35.12,English,,0,0,0,,We can terminate our process by calling exit which is called once and never returns
Dialogue: 0,1:11:36.06,1:11:39.30,English,,0,0,0,,We reap and wait for processes using wait or waitpit
Dialogue: 0,1:11:39.88,1:11:42.50,English,,0,0,0,,And we load and run programs using execve
Dialogue: 0,1:11:43.02,1:11:44.96,English,,0,0,0,,Or one of its one of its variants
Dialogue: 0,1:11:45.86,1:11:48.62,English,,0,0,0,,And this one is called once and and normally never returns
Dialogue: 0,1:11:50.00,1:11:52.92,English,,0,0,0,,Okay so that's it for today and
Dialogue: 0,1:11:53.88,1:11:58.28,English,,0,0,0,,We'll see you have a good weekend and we'll see you on Tuesday
