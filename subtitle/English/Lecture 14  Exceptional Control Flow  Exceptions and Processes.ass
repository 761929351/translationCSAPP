[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video File: ../../../Desktop/csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.875000
Scroll Position: 787
Active Line: 799
Video Position: 129417

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.96,csapp,,0,0,0,,all right good afternoon everybody
Dialogue: 0,0:00:03.30,0:00:04.80,csapp,,0,0,0,,welcome good to see you
Dialogue: 0,0:00:06.58,0:00:13.46,csapp,,0,0,0,,so today we're going to look at an idea called exceptional control flow
Dialogue: 0,0:00:14.22,0:00:18.56,csapp,,0,0,0,,that's a very important part of making modern systems
Dialogue: 0,0:00:19.18,0:00:26.32,csapp,,0,0,0,,and it exists at all levels of the system from the lowest level Hardware all the way up to software
Dialogue: 0,0:00:30.62,0:00:38.22,csapp,,0,0,0,,so the idea is when when you turn on a computer from the very from the very first time you turn it on
Dialogue: 0,0:00:38.92,0:00:43.16,csapp,,0,0,0,,on it just does execute one instruction after another until that you turn it off
Dialogue: 0,0:00:43.96,0:00:46.86,csapp,,0,0,0,,okay and if each core if you have multiple cores
Dialogue: 0,0:00:46.86,0:00:50.08,csapp,,0,0,0,,then each of those cores are executing instructions one after the other
Dialogue: 0,0:00:51.52,0:00:56.20,csapp,,0,0,0,,now the the sequence of instructions is called the control flow
Dialogue: 0,0:00:57.04,0:01:03.62,csapp,,0,0,0,,okay and the the actual sequence of instructions that the hardware is executing is called the physical control flow
Dialogue: 0,0:01:04.74,0:01:09.88,csapp,,0,0,0,,now normally normally this control flow
Dialogue: 0,0:01:10.56,0:01:15.18,csapp,,0,0,0,,that executes just one instruction after another just sequentially in memory
Dialogue: 0,0:01:16.12,0:01:21.32,csapp,,0,0,0,,and we've so far we've seen two two mechanisms for altering the control flow
Dialogue: 0,0:01:21.32,0:01:25.68,csapp,,0,0,0,,so that it's it's not so that we're not executing just the next instruction
Dialogue: 0,0:01:26.32,0:01:31.32,csapp,,0,0,0,,so that's branches and jumps and procedure call and return
Dialogue: 0,0:01:32.76,0:01:37.42,csapp,,0,0,0,,okay now now jumps and call it branches jumps call and return
Dialogue: 0,0:01:38.22,0:01:41.16,csapp,,0,0,0,,those are reacting to changes in program State
Dialogue: 0,0:01:41.96,0:01:45.70,csapp,,0,0,0,,so when you do a branch you check the control condition codes
Dialogue: 0,0:01:46.18,0:01:50.82,csapp,,0,0,0,,and then based on some the results of that comparison then you then you do the branch
Dialogue: 0,0:01:52.28,0:01:57.48,csapp,,0,0,0,,okay but it real system needs to be able to adapt to changes in the system State
Dialogue: 0,0:01:59.36,0:02:01.86,csapp,,0,0,0,,okay so for example data arrives from a disk
Dialogue: 0,0:02:04.56,0:02:10.10,csapp,,0,0,0,,or some network use types control C
Dialogue: 0,0:02:10.92,0:02:13.90,csapp,,0,0,0,,okay the program executes an illegal instruction
Dialogue: 0,0:02:14.30,0:02:20.60,csapp,,0,0,0,,okay all of these represent some change some kind of change in the in the system State
Dialogue: 0,0:02:21.18,0:02:23.82,csapp,,0,0,0,,and we need some way to react to that
Dialogue: 0,0:02:24.92,0:02:29.60,csapp,,0,0,0,,that so this the so what we need is we call this exceptional control flow
Dialogue: 0,0:02:30.04,0:02:34.20,csapp,,0,0,0,,because it's sort of outside of the normal control flow that we we see in our programs
Dialogue: 0,0:02:36.20,0:02:41.22,csapp,,0,0,0,,now exceptional control flow or ECF exists at all levels in the system
Dialogue: 0,0:02:42.66,0:02:45.18,csapp,,0,0,0,,from the very lowest level of hardware
Dialogue: 0,0:02:48.64,0:02:51.52,csapp,,0,0,0,,at the very lowest level  we have what are called exceptions
Dialogue: 0,0:02:52.26,0:02:58.16,csapp,,0,0,0,,and these are changes in the control flow in response to some low level system event
Dialogue: 0,0:02:59.32,0:03:04.18,csapp,,0,0,0,,so this is a or and by event we mean a change in the state
Dialogue: 0,0:03:05.24,0:03:09.70,csapp,,0,0,0,, now exceptions are implemented using a combination of hardware and os software
Dialogue: 0,0:03:09.72,0:03:11.38,csapp,,0,0,0,,which we'll see in it in a minute
Dialogue: 0,0:03:12.08,0:03:16.58,csapp,,0,0,0,, but these these exceptional control flow exists at higher levels too
Dialogue: 0,0:03:17.44,0:03:23.08,csapp,,0,0,0,,so in the a process context switch is an example of exceptional control flow
Dialogue: 0,0:03:23.66,0:03:28.58,csapp,,0,0,0,,that's also it's implemented by a hardware and the operating system kernel
Dialogue: 0,0:03:29.42,0:03:34.94,csapp,,0,0,0,,and it so a process context switches we'll see later later today
Dialogue: 0,0:03:35.62,0:03:40.66,csapp,,0,0,0,,you're executing you're executing your code in the current in your current process
Dialogue: 0,0:03:42.32,0:03:47.82,csapp,,0,0,0,,and then all of a sudden this the system is executing code from another process
Dialogue: 0,0:03:48.14,0:03:50.38,csapp,,0,0,0,,right so your process gets like suspended
Dialogue: 0,0:03:51.34,0:03:55.74,csapp,,0,0,0,,and so there's a so that's a form of exceptional control flow
Dialogue: 0,0:03:55.74,0:04:02.18,csapp,,0,0,0,,where you're executing statements instructions within one one process and then
Dialogue: 0,0:04:02.48,0:04:06.54,csapp,,0,0,0,,all of a sudden you're executing statements instructions in another process
Dialogue: 0,0:04:08.56,0:04:11.22,csapp,,0,0,0,,  um at a higher level are totally in software
Dialogue: 0,0:04:11.60,0:04:13.18,csapp,,0,0,0,,we have the idea of a signal
Dialogue: 0,0:04:13.82,0:04:19.40,csapp,,0,0,0,,and this is implemented by operating system software and we'll learn all about signals next lecture
Dialogue: 0,0:04:20.60,0:04:25.08,csapp,,0,0,0,,and then even higher at an even higher level you have non-local jumps in C
Dialogue: 0,0:04:25.60,0:04:28.26,csapp,,0,0,0,,which are just implemented by the C run library
Dialogue: 0,0:04:28.76,0:04:33.68,csapp,,0,0,0,,so this allows you non-local jumps allow you to break the normal call and return pattern
Dialogue: 0,0:04:33.68,0:04:40.82,csapp,,0,0,0,,so from one from within a function normally you can only return to the the function that calls that called you
Dialogue: 0,0:04:41.46,0:04:46.08,csapp,,0,0,0,,non-local jumps allow you to within a function break that
Dialogue: 0,0:04:46.08,0:04:50.12,csapp,,0,0,0,,and return to some other some other function or some other part of the code
Dialogue: 0,0:04:51.16,0:04:54.38,csapp,,0,0,0,, so we'll look at signals and non-local jumps next lecture
Dialogue: 0,0:04:54.84,0:04:57.62,csapp,,0,0,0,, today we're going to look at exceptions and processes
Dialogue: 0,0:05:00.12,0:05:07.08,csapp,,0,0,0,,  so an exception is a transfer of control to the operating systems kernel
Dialogue: 0,0:05:07.70,0:05:13.00,csapp,,0,0,0,,where the kernel is the memory resident part of the operating system you know
Dialogue: 0,0:05:13.02,0:05:15.86,csapp,,0,0,0,,so an operating system provides all kinds of programs like
Dialogue: 0,0:05:16.32,0:05:23.86,csapp,,0,0,0,,to list files to change directories to list the current processes
Dialogue: 0,0:05:24.48,0:05:27.82,csapp,,0,0,0,,so all of that stuff constitutes the operating system
Dialogue: 0,0:05:27.82,0:05:33.20,csapp,,0,0,0,,the kernel is the part of the operating system that's always resident in memory
Dialogue: 0,0:05:34.98,0:05:40.80,csapp,,0,0,0,,so an exception is this really low-level transfer of control to the operating system
Dialogue: 0,0:05:40.80,0:05:42.66,csapp,,0,0,0,,because something happened in the system
Dialogue: 0,0:05:43.48,0:05:46.66,csapp,,0,0,0,,so you're executing your code user code
Dialogue: 0,0:05:47.70,0:05:53.32,csapp,,0,0,0,,and then something happens some event so by event we mean there's some change in the system state
Dialogue: 0,0:05:54.96,0:06:04.34,csapp,,0,0,0,,in response to that there the exception transfers control from from your user code to code in the kernel
Dialogue: 0,0:06:04.82,0:06:06.42,csapp,,0,0,0,,which is called an exception Handler
Dialogue: 0,0:06:07.18,0:06:10.58,csapp,,0,0,0,,and then the kernel responds to that change in some way
Dialogue: 0,0:06:12.72,0:06:14.50,csapp,,0,0,0,, this is called the exception processing
Dialogue: 0,0:06:15.66,0:06:21.98,csapp,,0,0,0,, and then there's three there's three things that can happen after the kernel handles the exception
Dialogue: 0,0:06:22.74,0:06:25.92,csapp,,0,0,0,,it can return and re execute that the current instruction
Dialogue: 0,0:06:27.86,0:06:33.88,csapp,,0,0,0,, okay and we'll see this is this is useful for things like page faults   allows us to implement virtual memory
Dialogue: 0,0:06:35.76,0:06:37.86,csapp,,0,0,0,, it could return to the next instruction
Dialogue: 0,0:06:39.04,0:06:43.00,csapp,,0,0,0,,which I've shown here or it could abort
Dialogue: 0,0:06:46.64,0:06:49.56,csapp,,0,0,0,,now exceptions are implemented by hardware and software
Dialogue: 0,0:06:49.56,0:06:53.30,csapp,,0,0,0,,so the the actual transfer of control
Dialogue: 0,0:06:54.26,0:07:00.16,csapp,,0,0,0,,you know the change in the program counter or IP is is is done by the hardware
Dialogue: 0,0:07:01.22,0:07:09.80,csapp,,0,0,0,,but the code that executes as a result of that exception is set up and determined by the operating system kernel
Dialogue: 0,0:07:10.44,0:07:15.26,csapp,,0,0,0,,so every every type of event has a unique exception number
Dialogue: 0,0:07:15.78,0:07:19.48,csapp,,0,0,0,,which serves as an index into a jump table called an exception table
Dialogue: 0,0:07:20.66,0:07:24.24,csapp,,0,0,0,,okay and so when when event K happens
Dialogue: 0,0:07:25.36,0:07:30.42,csapp,,0,0,0,, then the hardware looks uses K as in as an index into this table
Dialogue: 0,0:07:30.90,0:07:36.10,csapp,,0,0,0,,and gets the address of the exception handler for that for that for that exception
Dialogue: 0,0:07:38.02,0:07:43.82,csapp,,0,0,0,, and so every time that event K happens that handler handler K is invoked
Dialogue: 0,0:07:45.36,0:07:52.84,csapp,,0,0,0,,now there's a different kinds of exceptions we distinguish them as being asynchronous or synchronous
Dialogue: 0,0:07:53.46,0:08:03.12,csapp,,0,0,0,,asynchronous exceptions happen as a result of changes in state that are occurred outside the outside of the processor
Dialogue: 0,0:08:03.92,0:08:06.28,csapp,,0,0,0,,so these are called interrupts
Dialogue: 0,0:08:07.16,0:08:16.88,csapp,,0,0,0,,and those changes in state are are the processor is notified about those changes in state by setting a pin on the on the processor
Dialogue: 0,0:08:16.88,0:08:20.20,csapp,,0,0,0,,an external pin called the interrupt pin
Dialogue: 0,0:08:21.37,0:08:28.56,csapp,,0,0,0,,so this is the kind of when see a disk controller finishes doing a direct memory access
Dialogue: 0,0:08:28.78,0:08:31.62,csapp,,0,0,0,, and copying data from the disk into memory
Dialogue: 0,0:08:32.02,0:08:39.72,csapp,,0,0,0,, it notifies the processor that it's finished that copy by setting the interrupt pin hi okay
Dialogue: 0,0:08:42.58,0:08:48.38,csapp,,0,0,0,,and so after an interrupt happens the handler returns to the next instruction
Dialogue: 0,0:08:48.52,0:08:55.42,csapp,,0,0,0,,so an interrupt typically it's the so you're running your program you're running your program and then there's like this little
Dialogue: 0,0:08:57.28,0:09:02.52,csapp,,0,0,0,,there's like this little pause while the interrupt handler runs and then your program just continues to run okay
Dialogue: 0,0:09:02.88,0:09:11.52,csapp,,0,0,0,, so it's it's usually sort of done behind the scenes and doesn't doesn't affect your execution of your program
Dialogue: 0,0:09:12.28,0:09:18.74,csapp,,0,0,0,,now the most common or a common example of a interrupt is the timer interrupts
Dialogue: 0,0:09:19.66,0:09:25.44,csapp,,0,0,0,,so you're all systems have a a built-in timer that goes off every few milliseconds
Dialogue: 0,0:09:26.36,0:09:29.76,csapp,,0,0,0,,and when it when the timer goes off it sets the interrupts in high
Dialogue: 0,0:09:30.38,0:09:34.02,csapp,,0,0,0,,and there's a special exception number four for timer interrupts
Dialogue: 0,0:09:34.88,0:09:37.54,csapp,,0,0,0,,and this is we need this in order for the
Dialogue: 0,0:09:37.96,0:09:43.86,csapp,,0,0,0,,this allows we need this to allow the kernel to get control of the system again otherwise
Dialogue: 0,0:09:44.08,0:09:47.38,csapp,,0,0,0,,a user program could just run forever in an infinite loop
Dialogue: 0,0:09:47.74,0:09:52.50,csapp,,0,0,0,,and no one would be no way for the operating system to get to get control
Dialogue: 0,0:09:52.50,0:10:00.40,csapp,,0,0,0,,so every few milliseconds this timer goes off that causes a transient exception into the into the kernel
Dialogue: 0,0:10:00.86,0:10:05.24,csapp,,0,0,0,,and then the kernel can as we see the kernel can decide what to do
Dialogue: 0,0:10:05.70,0:10:09.48,csapp,,0,0,0,, maybe maybe schedule a new process or let the current process run
Dialogue: 0,0:10:12.46,0:10:17.64,csapp,,0,0,0,,and then and then this an i/o interrupt from an external devices is also a common example
Dialogue: 0,0:10:18.44,0:10:21.22,csapp,,0,0,0,,now the other class of exceptions are synchronous exceptions
Dialogue: 0,0:10:21.66,0:10:23.32,csapp,,0,0,0,,and there are three classes of those
Dialogue: 0,0:10:25.76,0:10:32.54,csapp,,0,0,0,,one is that one class is called the trap a trap is a intentional exception
Dialogue: 0,0:10:32.54,0:10:35.52,csapp,,0,0,0,,so this is an  exception that's caused intentionally by the program
Dialogue: 0,0:10:36.32,0:10:40.08,csapp,,0,0,0,,and the most the most common form of a trap is a system call
Dialogue: 0,0:10:41.42,0:10:46.58,csapp,,0,0,0,,so you know the operating system kernel provides all kinds of services to to a program
Dialogue: 0,0:10:46.58,0:10:51.98,csapp,,0,0,0,,but your program doesn't have direct access your program can't call functions in the kernel
Dialogue: 0,0:10:51.98,0:10:54.25,csapp,,0,0,0,, it can't access data directly in the kernel
Dialogue: 0,0:10:54.54,0:10:58.68,csapp,,0,0,0,,because that memory is protected and and unavailable to user programs
Dialogue: 0,0:10:59.66,0:11:04.40,csapp,,0,0,0,,so what the kernel does is they provide a interface
Dialogue: 0,0:11:04.40,0:11:12.80,csapp,,0,0,0,,that allows programs to make requests to effectively call functions within the kernel  and to make requests for various services
Dialogue: 0,0:11:13.32,0:11:15.82,csapp,,0,0,0,, and this this interface is called a system call
Dialogue: 0,0:11:17.28,0:11:19.24,csapp,,0,0,0,,ok so a program makes a system call
Dialogue: 0,0:11:20.16,0:11:25.60,csapp,,0,0,0,,and and and requests various functions from the kernel
Dialogue: 0,0:11:26.02,0:11:30.30,csapp,,0,0,0,,the kernel provides those sort of reacts to that request
Dialogue: 0,0:11:30.30,0:11:34.62,csapp,,0,0,0,,and then returns control back to the the function there the calling program
Dialogue: 0,0:11:35.24,0:11:38.70,csapp,,0,0,0,,so you can think of a system call as kind of it's a
Dialogue: 0,0:11:39.56,0:11:43.88,csapp,,0,0,0,,it looks like a function call but it's really transferring control into the kernel
Dialogue: 0,0:11:47.42,0:11:54.26,csapp,,0,0,0,,okay then there's some so traps are intentional faults are unintentional but but may be recoverable
Dialogue: 0,0:11:54.72,0:11:59.86,csapp,,0,0,0,,okay so things like page faults which
Dialogue: 0,0:12:01.50,0:12:04.64,csapp,,0,0,0,,when we will learn more about these when we study virtual memory
Dialogue: 0,0:12:04.64,0:12:08.88,csapp,,0,0,0,,but something like a page fault it's actually recoverable
Dialogue: 0,0:12:08.88,0:12:16.70,csapp,,0,0,0,, it just that the kernel has to it means that the the data the portion of the address space that your program referenced isn't actually in memory
Dialogue: 0,0:12:17.92,0:12:21.80,csapp,,0,0,0,,it needs to be copied from disk where it's stored into memory
Dialogue: 0,0:12:22.28,0:12:27.42,csapp,,0,0,0,,and then the instruction that that that caused a fault needs is just restarted and then it works
Dialogue: 0,0:12:28.50,0:12:33.58,csapp,,0,0,0,,that the the memory is is there and then the instruction works properly
Dialogue: 0,0:12:33.88,0:12:38.70,csapp,,0,0,0,,but other faults are unintentional unrecoverable like protection fault
Dialogue: 0,0:12:38.70,0:12:43.78,csapp,,0,0,0,,so if you try to access a portion of memory that's that's not allocated
Dialogue: 0,0:12:44.14,0:12:49.96,csapp,,0,0,0,,or floating-point exceptions often times those those can be recoverable
Dialogue: 0,0:12:51.84,0:12:59.16,csapp,,0,0,0,,so eat in either case when there's a fault it either re-execute the current instruction or to boat or or the boards
Dialogue: 0,0:13:00.82,0:13:08.26,csapp,,0,0,0,,and then there's unintentional and unrecoverable exceptions which are called the boards and those  those always abort
Dialogue: 0,0:13:08.80,0:13:14.74,csapp,,0,0,0,,so if you execute an illegal instruction if there's a problem with your memory memory and it's it's corrupted
Dialogue: 0,0:13:15.86,0:13:21.36,csapp,,0,0,0,,there's some problem with the machine those creative warts that that always
Dialogue: 0,0:13:22.34,0:13:26.92,csapp,,0,0,0,,that are unrecoverable and never return back to the to the program
Dialogue: 0,0:13:28.68,0:13:35.28,csapp,,0,0,0,,now system calls there's many different kinds of system calls and they all have their own unique number
Dialogue: 0,0:13:35.76,0:13:38.16,csapp,,0,0,0,,which is assigned by by Linux
Dialogue: 0,0:13:39.84,0:13:46.38,csapp,,0,0,0,,so in a for example to read a file there's a system call called read
Dialogue: 0,0:13:46.38,0:13:53.40,csapp,,0,0,0,,which is number zero opening a file a system call number two  and so on
Dialogue: 0,0:13:56.14,0:14:01.58,csapp,,0,0,0,,and there's a there's an instruction called syscall
Dialogue: 0,0:14:01.58,0:14:06.34,csapp,,0,0,0,,which actually performs the the system call
Dialogue: 0,0:14:07.04,0:14:12.44,csapp,,0,0,0,,now you usually don't use this system call and strike the syscall instruction directly in your program the
Dialogue: 0,0:14:12.96,0:14:17.98,csapp,,0,0,0,,Linux wraps those in system level functions which actually call it for you
Dialogue: 0,0:14:18.74,0:14:22.28,csapp,,0,0,0,,but it it's interesting to see how it actually works
Dialogue: 0,0:14:22.28,0:14:27.58,csapp,,0,0,0,,so opposed you want to open a file you call the system level function called open
Dialogue: 0,0:14:28.46,0:14:32.10,csapp,,0,0,0,,with a file name and some options say read only write only
Dialogue: 0,0:14:36.10,0:14:42.66,csapp,,0,0,0,,and so in at the syscall instruction takes the first the syscall number is %rax
Dialogue: 0,0:14:44.12,0:14:50.60,csapp,,0,0,0,,and then other other arguments are %rdi,%rsi,%rdx, %r10, %r9, %r8
Dialogue: 0,0:14:51.36,0:14:57.72,csapp,,0,0,0,,so you can see if we look in the the open function calls the underscore underscore open function which actually invokes
Dialogue: 0,0:14:58.22,0:15:04.14,csapp,,0,0,0,,the syscall so if you look at that code you see it moves the two which is the syscall number for read
Dialogue: 0,0:15:04.38,0:15:07.56,csapp,,0,0,0,, into %eax and then it does the syscall
Dialogue: 0,0:15:09.72,0:15:15.54,csapp,,0,0,0,,and then the the syscall returns its status in %rax
Dialogue: 0,0:15:16.30,0:15:19.80,csapp,,0,0,0,,if it's a negative number then that means something some error occurred
Dialogue: 0,0:15:20.76,0:15:25.40,csapp,,0,0,0,, if it's a positive number then that means something that no error occurred
Dialogue: 0,0:15:26.32,0:15:30.42,csapp,,0,0,0,,so in this case and I in it the open it's returning a file descriptor
Dialogue: 0,0:15:30.42,0:15:36.74,csapp,,0,0,0,,a small integer called the file descriptor which then you you can use in subsequent calls to read and write
Dialogue: 0,0:15:37.34,0:15:40.64,csapp,,0,0,0,,and then you can see the code is checking for this negative return value
Dialogue: 0,0:15:40.96,0:15:43.26,csapp,,0,0,0,, too and there's a whole series of these compares
Dialogue: 0,0:15:50.18,0:15:53.36,csapp,,0,0,0,,so let's look at an example of a fault
Dialogue: 0,0:15:54.28,0:16:00.54,csapp,,0,0,0,, so here suppose we have this program that we're writing into a valid region of memory
Dialogue: 0,0:16:00.54,0:16:07.70,csapp,,0,0,0,, but it's it's not actually stored on it's not actually in the memory it needs to be loaded from disk into into memory
Dialogue: 0,0:16:07.70,0:16:10.88,csapp,,0,0,0,,so this is a so-called page fault
Dialogue: 0,0:16:12.52,0:16:14.82,csapp,,0,0,0,,so this this instruction this movl
Dialogue: 0,0:16:15.40,0:16:22.82,csapp,,0,0,0,,because this because the memory at this address isn't isn't available triggers a page fault
Dialogue: 0,0:16:24.60,0:16:30.92,csapp,,0,0,0,,so that that creates an exception a transfer of control into the the page fault handler in the kernel
Dialogue: 0,0:16:31.64,0:16:34.32,csapp,,0,0,0,,which copies that page from disk to memory
Dialogue: 0,0:16:36.24,0:16:40.98,csapp,,0,0,0,,and then it returns and when it returns it reacts Acutes the movl instruction
Dialogue: 0,0:16:41.52,0:16:42.24,csapp,,0,0,0,,so that's kind of cool
Dialogue: 0,0:16:42.24,0:16:44.88,csapp,,0,0,0,,so now the memory is available
Dialogue: 0,0:16:45.58,0:16:52.02,csapp,,0,0,0,,and now that the movl this movl instruction when it's reacts acute 'add completes
Dialogue: 0,0:16:53.66,0:16:54.68,csapp,,0,0,0,,and then we continue
Dialogue: 0,0:16:55.66,0:16:58.80,csapp,,0,0,0,, now another type of fault is an invalid memory reference
Dialogue: 0,0:16:58.80,0:17:02.46,csapp,,0,0,0,,so here we have a we're accessing an element of a
Dialogue: 0,0:17:03.24,0:17:07.74,csapp,,0,0,0,,which doesn't exist and it's an illegal it's an invalid reference
Dialogue: 0,0:17:09.22,0:17:12.16,csapp,,0,0,0,,so in this case the movl instruction
Dialogue: 0,0:17:12.90,0:17:15.36,csapp,,0,0,0,, it looks like a it looks like a page fault
Dialogue: 0,0:17:16.72,0:17:21.74,csapp,,0,0,0,,but the kernel detects that it's an invalid address that there isn't anything that can be loaded from disk
Dialogue: 0,0:17:21.74,0:17:25.70,csapp,,0,0,0,, this is an invalid region of the the virtual address space
Dialogue: 0,0:17:27.38,0:17:34.24,csapp,,0,0,0,,so it it sends a signal to the to the process and then never never returns
Dialogue: 0,0:17:35.96,0:17:40.06,csapp,,0,0,0,,yet so the the signal that sends is the infamous segmentation
Dialogue: 0,0:17:40.06,0:17:46.90,csapp,,0,0,0,, the signal that causes the infamous sauce segmentation fault message to print out
Dialogue: 0,0:17:47.94,0:17:52.28,csapp,,0,0,0,,and we'll see you next lecture we'll see we'll see how these signals actually actually work
Dialogue: 0,0:17:56.26,0:18:01.88,csapp,,0,0,0,,okay so I said we've seen exceptions or very low-level transfers of control
Dialogue: 0,0:18:02.36,0:18:06.58,csapp,,0,0,0,,that are implemented by both hardware and the operating system software it could sue
Dialogue: 0,0:18:08.58,0:18:12.84,csapp,,0,0,0,,at the higher level is another form of exceptional control flow called
Dialogue: 0,0:18:14.28,0:18:18.72,csapp,,0,0,0,,and we see it in the in the context of a process context switch
Dialogue: 0,0:18:21.00,0:18:25.34,csapp,,0,0,0,,so let's look at and let's look at what what a process is
Dialogue: 0,0:18:26.64,0:18:32.38,csapp,,0,0,0,,so a process the idea of a process is one of the most fundamental and important ideas in computer science
Dialogue: 0,0:18:33.34,0:18:39.22,csapp,,0,0,0,,and this classical definition of is that a process is an instance of a running program
Dialogue: 0,0:18:40.88,0:18:43.20,csapp,,0,0,0,,okay it's different from a program
Dialogue: 0,0:18:43.68,0:18:47.18,csapp,,0,0,0,, a program exists can exist in many different places right
Dialogue: 0,0:18:47.18,0:18:51.38,csapp,,0,0,0,,a program exists in yourseif as text in a C file
Dialogue: 0,0:18:51.98,0:18:57.24,csapp,,0,0,0,,it can exist as the dot text section of a binary
Dialogue: 0,0:18:58.38,0:19:01.86,csapp,,0,0,0,, it can exist as bytes that have been loaded into memory
Dialogue: 0,0:19:02.26,0:19:06.96,csapp,,0,0,0,,a process is an instance of a program that's that's running that's in execution
Dialogue: 0,0:19:13.40,0:19:16.92,csapp,,0,0,0,,and a process provides two key abstractions
Dialogue: 0,0:19:17.80,0:19:24.36,csapp,,0,0,0,,okay it's the first abstraction is that it gives it gives you the illusion that you have
Dialogue: 0,0:19:25.88,0:19:29.66,csapp,,0,0,0,, exclusive access to the CPU and thus and the registers
Dialogue: 0,0:19:30.62,0:19:33.90,csapp,,0,0,0,,okay so when you're running when you're running your program in a process
Dialogue: 0,0:19:34.58,0:19:39.20,csapp,,0,0,0,,you never have to worry about any other any other programs modifying your registers
Dialogue: 0,0:19:39.86,0:19:45.46,csapp,,0,0,0,,and and you can't even tell that there's even other processes running on the system
Dialogue: 0,0:19:45.76,0:19:51.86,csapp,,0,0,0,,right it looks except for occasional delays like an instruction that just takes a little longer to run
Dialogue: 0,0:19:53.16,0:20:01.06,csapp,,0,0,0,,except for that it looks like you have unique exclusive exclusive use of the of the processor  and it's and it's registers
Dialogue: 0,0:20:02.36,0:20:06.50,csapp,,0,0,0,,the the other abstraction that it provides is the illusion that you have your own address space
Dialogue: 0,0:20:08.74,0:20:13.58,csapp,,0,0,0,,okay so you have and this is provided by a mechanism called virtual memory
Dialogue: 0,0:20:14.28,0:20:20.58,csapp,,0,0,0,,so each each running program has its own code data heap stack
Dialogue: 0,0:20:21.20,0:20:24.06,csapp,,0,0,0,,and you never see that the code
Dialogue: 0,0:20:24.68,0:20:27.72,csapp,,0,0,0,,and you never see the memory that's being used by other processes
Dialogue: 0,0:20:28.54,0:20:33.68,csapp,,0,0,0,,okay so it looks for all intents and purposes process gives you this illusion that
Dialogue: 0,0:20:33.68,0:20:39.82,csapp,,0,0,0,,you have access to the exclusive access to all the the memory and the and the processor
Dialogue: 0,0:20:42.88,0:20:46.64,csapp,,0,0,0,,now that the system runs many of these processes simultaneously
Dialogue: 0,0:20:49.06,0:20:53.60,csapp,,0,0,0,,even even on a system with a single core many of these
Dialogue: 0,0:20:54.04,0:20:58.86,csapp,,0,0,0,,multiple processes are actually running at the same time concurrently
Dialogue: 0,0:20:59.16,0:21:03.92,csapp,,0,0,0,,and you can see this if you look at this here I ran top on on my Mac
Dialogue: 0,0:21:04.60,0:21:13.18,csapp,,0,0,0,,and you can see it's running 123 123 total processes  five of which are actually running
Dialogue: 0,0:21:13.94,0:21:19.60,csapp,,0,0,0,,and each one of these processes has its own unique process ID this is integer
Dialogue: 0,0:21:24.04,0:21:30.80,csapp,,0,0,0,,now the way so it looks it looks like you have unique access or exclusive access to the to the system
Dialogue: 0,0:21:31.96,0:21:39.14,csapp,,0,0,0,,but in reality on a suppose we have a single core on a you're actually sharing the system
Dialogue: 0,0:21:39.14,0:21:43.42,csapp,,0,0,0,, and the the operating the operating system is is sort of managing that sharing
Dialogue: 0,0:21:44.20,0:21:45.24,csapp,,0,0,0,,so what it does is it
Dialogue: 0,0:21:49.32,0:21:51.04,csapp,,0,0,0,,we have a process that's running
Dialogue: 0,0:21:52.72,0:21:57.16,csapp,,0,0,0,,and it has its own it has its own address space
Dialogue: 0,0:21:58.26,0:22:04.62,csapp,,0,0,0,,and and it has it sits and it has its own registers and at some point either
Dialogue: 0,0:22:05.42,0:22:10.56,csapp,,0,0,0,,because be cut at some point an exception occurs either because of a timer interrupt
Dialogue: 0,0:22:11.18,0:22:14.40,csapp,,0,0,0,, or a fault of some kind or a trap
Dialogue: 0,0:22:15.00,0:22:18.86,csapp,,0,0,0,,at some point the the operating system gets control of the system
Dialogue: 0,0:22:19.42,0:22:23.82,csapp,,0,0,0,,and and in this case let's say it decides that it wants to run another process
Dialogue: 0,0:22:25.28,0:22:31.94,csapp,,0,0,0,, so it copies the the registers the current the current register values into memory and saves them
Dialogue: 0,0:22:34.04,0:22:37.04,csapp,,0,0,0,,and then it schedules the next process for execution
Dialogue: 0,0:22:38.18,0:22:46.00,csapp,,0,0,0,,and it loads the the registers that were saved from the last time that process was was running
Dialogue: 0,0:22:46.00,0:22:48.04,csapp,,0,0,0,, it loads those into the CPU registers
Dialogue: 0,0:22:48.64,0:22:54.48,csapp,,0,0,0,, and then it switches the address space to the address space for for this process
Dialogue: 0,0:22:55.44,0:23:00.20,csapp,,0,0,0,,so this this the address space and the register values are the context
Dialogue: 0,0:23:01.56,0:23:09.02,csapp,,0,0,0,, and so the context switch is is what is the change in the in the address space and the registers
Dialogue: 0,0:23:11.38,0:23:14.00,csapp,,0,0,0,,ok so then at that point the that process is running
Dialogue: 0,0:23:15.98,0:23:19.02,csapp,,0,0,0,,now in reality on modern systems with multiple cores
Dialogue: 0,0:23:21.18,0:23:25.80,csapp,,0,0,0,,the operating system will schedule processes on those multiple cores
Dialogue: 0,0:23:25.96,0:23:31.46,csapp,,0,0,0,,and then if there's no if there's not enough course to handle the processes then it will do the context switching
Dialogue: 0,0:23:31.92,0:23:34.08,csapp,,0,0,0,, just like we showed before
Dialogue: 0,0:23:37.74,0:23:41.92,csapp,,0,0,0,,now each process represents a what we call a logical control flow
Dialogue: 0,0:23:42.72,0:23:45.32,csapp,,0,0,0,,so if you were to you know there's a physical control flow
Dialogue: 0,0:23:45.84,0:23:47.96,csapp,,0,0,0,,which if we just looked at all the PC values
Dialogue: 0,0:23:50.20,0:23:53.52,csapp,,0,0,0,,we'd be executing instructions from one process
Dialogue: 0,0:23:53.52,0:23:56.64,csapp,,0,0,0,, and then all of a sudden we'd be executing from another process
Dialogue: 0,0:23:57.38,0:24:02.26,csapp,,0,0,0,, but within a single process there's a logical control flow which are all the instructions for that process
Dialogue: 0,0:24:03.48,0:24:07.16,csapp,,0,0,0,, now we say that two processes run concurrently
Dialogue: 0,0:24:07.46,0:24:10.64,csapp,,0,0,0,, if their flows overlap in time otherwise they're sequential
Dialogue: 0,0:24:11.50,0:24:15.52,csapp,,0,0,0,,so let's look at let's look an example we have three processes
Dialogue: 0,0:24:15.68,0:24:22.56,csapp,,0,0,0,,process a runs for a while and then it's it's interrupted by process B and process C
Dialogue: 0,0:24:22.78,0:24:26.00,csapp,,0,0,0,,and then eventually it it continues running and then it terminates
Dialogue: 0,0:24:26.84,0:24:32.78,csapp,,0,0,0,,process B interrupts process a and then it runs for a while and then it terminates
Dialogue: 0,0:24:34.00,0:24:39.70,csapp,,0,0,0,,process C once when process B finishes then process C gets to run for a while
Dialogue: 0,0:24:40.84,0:24:44.24,csapp,,0,0,0,,then process a runs for a while and then process C terminates
Dialogue: 0,0:24:45.14,0:24:48.10,csapp,,0,0,0,, okay so given given this definition of concurrency
Dialogue: 0,0:24:51.20,0:24:54.78,csapp,,0,0,0,,which which of these processes are running concurrently
Dialogue: 0,0:24:58.12,0:24:59.52,csapp,,0,0,0,,what about a a and B yes
Dialogue: 0,0:25:07.50,0:25:12.56,csapp,,0,0,0,,so so a and B's flows B B's flow overlaps with A's flow right
Dialogue: 0,0:25:13.30,0:25:17.62,csapp,,0,0,0,, so B
Dialogue: 0,0:25:21.04,0:25:23.82,csapp,,0,0,0,,B finishes starts and finish
Dialogue: 0,0:25:27.30,0:25:31.58,csapp,,0,0,0,,some portion this portion of Bees flow overlaps with A's flow right
Dialogue: 0,0:25:32.18,0:25:34.46,csapp,,0,0,0,,because b is still running hasn't finished
Dialogue: 0,0:25:34.90,0:25:40.94,csapp,,0,0,0,,ok so so a and B are concurrent as and similarly C and a overlap
Dialogue: 0,0:25:41.62,0:25:42.84,csapp,,0,0,0,,so they're concurrent
Dialogue: 0,0:25:43.36,0:25:48.90,csapp,,0,0,0,, but B and C are not concurrent right B finishes before C starts
Dialogue: 0,0:25:52.82,0:25:56.66,csapp,,0,0,0,, now this idea of concurrency it doesn't
Dialogue: 0,0:25:57.74,0:26:01.92,csapp,,0,0,0,,this this definition of concurrency holds regardless of the number of cores
Dialogue: 0,0:26:02.62,0:26:07.70,csapp,,0,0,0,,right if even if you have one core this example that I showed you was on one core
Dialogue: 0,0:26:08.14,0:26:11.52,csapp,,0,0,0,,but even if you have multiple cores as long as the flows overlap in time
Dialogue: 0,0:26:12.12,0:26:13.56,csapp,,0,0,0,,they're concurrent
Dialogue: 0,0:26:14.98,0:26:20.58,csapp,,0,0,0,,but we can think of these no matter what we can we can think of these as running in parallel with each other
Dialogue: 0,0:26:20.58,0:26:23.72,csapp,,0,0,0,,at least from the point of view of these individual processes
Dialogue: 0,0:26:30.90,0:26:33.24,csapp,,0,0,0,,now this this notion of a context which
Dialogue: 0,0:26:35.78,0:26:38.76,csapp,,0,0,0,,is it's managed by its managed by the kernel
Dialogue: 0,0:26:39.94,0:26:43.86,csapp,,0,0,0,,okay and it's important to realize that the kernel is not like a separate process that's running
Dialogue: 0,0:26:43.86,0:26:46.54,csapp,,0,0,0,,it always runs in the context of some existing process
Dialogue: 0,0:26:47.96,0:26:53.82,csapp,,0,0,0,,and it's it's it's it's just code that's in the upper portion of the address space
Dialogue: 0,0:26:54.60,0:26:57.02,csapp,,0,0,0,, that gets executed as a result of an exception
Dialogue: 0,0:26:59.12,0:27:04.14,csapp,,0,0,0,,so what what happens the way to think about this is that you have this process a that runs
Dialogue: 0,0:27:04.36,0:27:07.62,csapp,,0,0,0,,and then an exception occurs which transfers control to the kernel
Dialogue: 0,0:27:08.46,0:27:14.04,csapp,,0,0,0,, the kernel invokes its scheduler which decides whether to let a continue to run
Dialogue: 0,0:27:14.62,0:27:18.86,csapp,,0,0,0,,or to to do a context switch and run a new process another process
Dialogue: 0,0:27:19.44,0:27:25.56,csapp,,0,0,0,,so in this example the scheduler is decided to to run process B
Dialogue: 0,0:27:25.56,0:27:32.92,csapp,,0,0,0,,so it executes code and then sort of changes sort of once it repoint s' the address space
Dialogue: 0,0:27:34.58,0:27:36.99,csapp,,0,0,0,,then it's running in the context of process B
Dialogue: 0,0:27:37.42,0:27:43.60,csapp,,0,0,0,,and it finishes loading the registers for for process B general-purpose registers
Dialogue: 0,0:27:43.62,0:27:48.00,csapp,,0,0,0,,and then transfers control to b and b picks up where it left off
Dialogue: 0,0:27:49.10,0:27:49.74,csapp,,0,0,0,,okay
Dialogue: 0,0:27:51.50,0:27:53.80,csapp,,0,0,0,,and that at some point another exception occurs
Dialogue: 0,0:27:54.42,0:28:00.62,csapp,,0,0,0,,and in the kernel decides to transfer control back to process a which picks up where it left off right here
Dialogue: 0,0:28:01.68,0:28:04.62,csapp,,0,0,0,,so whatever instruction it finishes executing
Dialogue: 0,0:28:05.60,0:28:11.66,csapp,,0,0,0,,whatever instruction instruction was executing at the time of the exception execute the next instruction here
Dialogue: 0,0:28:17.56,0:28:20.54,csapp,,0,0,0,,now Linux provides a number of functions
Dialogue: 0,0:28:21.12,0:28:24.42,csapp,,0,0,0,,that you can you can call from a user program to manipulate processes
Dialogue: 0,0:28:24.90,0:28:30.40,csapp,,0,0,0,,and this this this process this act of manipulating processes  we refer to as process control
Dialogue: 0,0:28:32.20,0:28:36.92,csapp,,0,0,0,,now all of these functions most are I should say most of these functions
Dialogue: 0,0:28:37.42,0:28:40.28,csapp,,0,0,0,,call invoke system make system calls
Dialogue: 0,0:28:40.68,0:28:45.96,csapp,,0,0,0,,but they're they're they're wrapped in higher levels what we call system level functions that
Dialogue: 0,0:28:46.12,0:28:48.64,csapp,,0,0,0,,that are the things you actually call from your user program
Dialogue: 0,0:28:49.60,0:28:57.58,csapp,,0,0,0,, now system level the Linux system level functions that will typically return a -1 if there's an error
Dialogue: 0,0:28:58.26,0:29:02.42,csapp,,0,0,0,,and then they'll set a global variable called error no to indicate the reason
Dialogue: 0,0:29:03.58,0:29:06.68,csapp,,0,0,0,, so there's a hard and fast rule when you're doing
Dialogue: 0,0:29:08.12,0:29:10.60,csapp,,0,0,0,, when you're invoking system level functions
Dialogue: 0,0:29:11.84,0:29:16.60,csapp,,0,0,0,,you must check the return values from those functions you should
Dialogue: 0,0:29:17.10,0:29:20.64,csapp,,0,0,0,,and this you never you'll get it you'll get into huge trouble
Dialogue: 0,0:29:21.18,0:29:23.78,csapp,,0,0,0,, if you if you neglect to check the return values
Dialogue: 0,0:29:24.26,0:29:30.84,csapp,,0,0,0,, okay so you should never make a system a system level function call without checking the return value
Dialogue: 0,0:29:31.64,0:29:35.56,csapp,,0,0,0,,the and the only exception there's some functions that return void
Dialogue: 0,0:29:37.98,0:29:42.10,csapp,,0,0,0,,such as exit or free don't return anything
Dialogue: 0,0:29:43.32,0:29:47.14,csapp,,0,0,0,, so the way the typical way you would do this is like the fork call
Dialogue: 0,0:29:47.14,0:29:53.82,csapp,,0,0,0,,which we use to create processes returns the process idea of the of the the process that it created
Dialogue: 0,0:29:54.36,0:29:57.54,csapp,,0,0,0,, which is always positive if there's an error returns -1
Dialogue: 0,0:29:57.54,0:30:04.12,csapp,,0,0,0,,so we check for the return value to be less than 0 and then we we deal with that error somehow
Dialogue: 0,0:30:06.18,0:30:09.52,csapp,,0,0,0,, ok in this case we're just printing a message and exiting
Dialogue: 0,0:30:10.68,0:30:13.82,csapp,,0,0,0,, now this gets although it's essential to do this it gets
Dialogue: 0,0:30:16.16,0:30:20.58,csapp,,0,0,0,,sort of forked from from my point of view we're trying to present code to you
Dialogue: 0,0:30:22.06,0:30:25.10,csapp,,0,0,0,,it gets really messy it takes up a lot of space
Dialogue: 0,0:30:25.10,0:30:31.54,csapp,,0,0,0,,yes
Dialogue: 0,0:30:31.76,0:30:33.62,csapp,,0,0,0,,I'm checking that it's less than zero
Dialogue: 0,0:30:37.20,0:30:43.72,csapp,,0,0,0,, oh yeah that probably that should be normally the convention is to return non zero so you're right that
Dialogue: 0,0:30:44.82,0:30:49.68,csapp,,0,0,0,, it's it's not a hard and fast rule but that's that's typically the convention so I guess it should be  exit one
Dialogue: 0,0:30:54.04,0:30:56.22,csapp,,0,0,0,,so what we'll do to simplify this
Dialogue: 0,0:30:56.76,0:31:00.19,csapp,,0,0,0,,in the code that we present to you and in the code that we present you in the book
Dialogue: 0,0:31:00.68,0:31:03.54,csapp,,0,0,0,,well we'll define error reporting functions
Dialogue: 0,0:31:04.32,0:31:09.82,csapp,,0,0,0,, so unix-style errors where the function returns -1 and then sets there are no will
Dialogue: 0,0:31:11.92,0:31:16.20,csapp,,0,0,0,,well if we get that kind of if we get that kind of error will
Dialogue: 0,0:31:16.98,0:31:23.12,csapp,,0,0,0,,will print the will print a message and we'll report what that error was  before we exit
Dialogue: 0,0:31:23.46,0:31:26.34,csapp,,0,0,0,,and so then in the code we can replace that
Dialogue: 0,0:31:26.90,0:31:30.96,csapp,,0,0,0,,that that body of that if statement with just a single line
Dialogue: 0,0:31:31.36,0:31:34.00,csapp,,0,0,0,,okay so that that makes the code a little tighter
Dialogue: 0,0:31:34.56,0:31:38.52,csapp,,0,0,0,, but we'll go even further than that and we'll define these wrappers
Dialogue: 0,0:31:38.52,0:31:44.80,csapp,,0,0,0,,which were pioneered by a great technical writer named w richards of stevens
Dialogue: 0,0:31:45.86,0:31:51.62,csapp,,0,0,0,,and what we do here is we we replace each function with a an error at a wrapper
Dialogue: 0,0:31:52.10,0:31:58.02,csapp,,0,0,0,,that has the identical interface as the function the original function
Dialogue: 0,0:31:58.28,0:32:01.30,csapp,,0,0,0,, and it has the first the first letter uppercase
Dialogue: 0,0:32:02.64,0:32:08.98,csapp,,0,0,0,,and then what this wrapper does is it calls it calls the original function checks for the errors
Dialogue: 0,0:32:09.12,0:32:14.54,csapp,,0,0,0,,and then and then if there's no error returns what the original function would have returned
Dialogue: 0,0:32:15.42,0:32:20.80,csapp,,0,0,0,,so the behavior of this wrapper is identical to the wrapped
Dialogue: 0,0:32:21.20,0:32:22.28,csapp,,0,0,0,, if there's not an error
Dialogue: 0,0:32:22.86,0:32:27.10,csapp,,0,0,0,,okay and if there is an error then it deals with it somehow and prints a message
Dialogue: 0,0:32:27.52,0:32:32.92,csapp,,0,0,0,,and so then this allows us to make our code really compact without violating this
Dialogue: 0,0:32:33.52,0:32:36.38,csapp,,0,0,0,,hard and fast rule that  we have to we have to check for errors
Dialogue: 0,0:32:40.34,0:32:44.64,csapp,,0,0,0,,okay the simplest function process control functions are
Dialogue: 0,0:32:45.08,0:32:48.96,csapp,,0,0,0,, functions that allow you to get the pig for the current process which is getpid
Dialogue: 0,0:32:49.66,0:32:54.58,csapp,,0,0,0,,or the the processor idea of you if the parent process that created the current process
Dialogue: 0,0:32:55.26,0:33:00.58,csapp,,0,0,0,,okay so this these take no arguments and they return an integer which is a process ID
Dialogue: 0,0:33:05.20,0:33:09.06,csapp,,0,0,0,,now linux provides ways to create and terminate processes
Dialogue: 0,0:33:09.64,0:33:17.68,csapp,,0,0,0,,and from a programmers perspective we can think of a process as being in one of three states running
Dialogue: 0,0:33:17.76,0:33:22.06,csapp,,0,0,0,, so in this case the process is actually running and executes instructions
Dialogue: 0,0:33:22.68,0:33:25.74,csapp,,0,0,0,, or its it can be scheduled
Dialogue: 0,0:33:25.74,0:33:28.88,csapp,,0,0,0,,maybe it's not running but it can be scheduled at a later time
Dialogue: 0,0:33:31.12,0:33:33.24,csapp,,0,0,0,, right and it's waiting is waiting to be scheduled
Dialogue: 0,0:33:33.98,0:33:39.36,csapp,,0,0,0,, it can be stopped which means that execution is suspended
Dialogue: 0,0:33:40.68,0:33:43.04,csapp,,0,0,0,,and won't be scheduled until further notice
Dialogue: 0,0:33:43.04,0:33:46.10,csapp,,0,0,0,, so we'll see how this works when we study signals in the next lecture
Dialogue: 0,0:33:46.28,0:33:51.28,csapp,,0,0,0,,but usually a process is stopped because it receives a certain kind of signal
Dialogue: 0,0:33:51.78,0:33:55.76,csapp,,0,0,0,,and then that the process becomes stopped in ways it won't be executed
Dialogue: 0,0:33:56.42,0:34:02.46,csapp,,0,0,0,,it won't be scheduled until you explicitly tell it to be scheduled
Dialogue: 0,0:34:02.88,0:34:06.60,csapp,,0,0,0,,or process can be terminated which means it stopped permanently
Dialogue: 0,0:34:06.84,0:34:08.94,csapp,,0,0,0,,okay so it'll never be scheduled again it's done
Dialogue: 0,0:34:11.58,0:34:14.80,csapp,,0,0,0,, now a process can be terminated for one of three reasons
Dialogue: 0,0:34:15.48,0:34:20.26,csapp,,0,0,0,,so one it receives a signal whose default action is to terminate it
Dialogue: 0,0:34:20.86,0:34:24.86,csapp,,0,0,0,,or your your program returns from the main routine
Dialogue: 0,0:34:25.16,0:34:28.84,csapp,,0,0,0,,so you know you can if you know the definition for main is int
Dialogue: 0,0:34:30.02,0:34:31.82,csapp,,0,0,0,,see main routines always return an int
Dialogue: 0,0:34:32.78,0:34:35.22,csapp,,0,0,0,,so you can return from main and that will terminate your
Dialogue: 0,0:34:35.74,0:34:40.52,csapp,,0,0,0,, event it will terminate the process or you can explicitly call the exit function
Dialogue: 0,0:34:41.96,0:34:49.06,csapp,,0,0,0,,the exit function exits the program with an exit status of the of its argument
Dialogue: 0,0:34:49.76,0:34:56.02,csapp,,0,0,0,,so as as you pointed out that the convention is that for normal return is to return zero
Dialogue: 0,0:34:56.34,0:34:57.72,csapp,,0,0,0,,and then non zero on error
Dialogue: 0,0:34:59.36,0:35:04.62,csapp,,0,0,0,,or you can another way to do this is just return an integer value from the main routine
Dialogue: 0,0:35:04.86,0:35:06.34,csapp,,0,0,0,,and that will that will set the exit status
Dialogue: 0,0:35:07.54,0:35:09.44,csapp,,0,0,0,,now exit is kind of unusual
Dialogue: 0,0:35:09.44,0:35:13.96,csapp,,0,0,0,, and you'll see this is typical of all these process control functions
Dialogue: 0,0:35:14.54,0:35:18.90,csapp,,0,0,0,,that they normally functions you call them once and then they return once
Dialogue: 0,0:35:19.54,0:35:22.50,csapp,,0,0,0,, okay but exit you call once and then it never returns
Dialogue: 0,0:35:23.32,0:35:27.46,csapp,,0,0,0,, okay so that's so that's a little unusual 
Dialogue: 0,0:35:29.14,0:35:34.02,csapp,,0,0,0,,now a parent process can create a child process by calling the fork function 
Dialogue: 0,0:35:35.86,0:35:39.26,csapp,,0,0,0,,so fork takes no arguments
Dialogue: 0,0:35:41.94,0:35:47.54,csapp,,0,0,0,,and it returns an integer it it creates a new child process 
Dialogue: 0,0:35:49.70,0:35:53.18,csapp,,0,0,0,,and then it returns in both the parent and the child 
Dialogue: 0,0:35:55.26,0:35:57.72,csapp,,0,0,0,,so this is a little hard to wrap your head around at first 
Dialogue: 0,0:35:58.02,0:36:00.24,csapp,,0,0,0,,it's called once by the parent
Dialogue: 0,0:36:01.58,0:36:08.16,csapp,,0,0,0,, but it then it returns in both it creates a new process and then it returns in both the parent and the child
Dialogue: 0,0:36:09.82,0:36:11.90,csapp,,0,0,0,,and to the child it returns zero 
Dialogue: 0,0:36:13.12,0:36:16.52,csapp,,0,0,0,,to the parent return it returns to the child's process ID 
Dialogue: 0,0:36:21.86,0:36:26.12,csapp,,0,0,0,,okay the child gets an identical copy of the parents virtual address space 
Dialogue: 0,0:36:26.94,0:36:29.99,csapp,,0,0,0,,but separate right there they're distinct
Dialogue: 0,0:36:30.86,0:36:37.36,csapp,,0,0,0,,but immediately after the fork returns the the addresses the address space is identical
Dialogue: 0,0:36:37.70,0:36:43.56,csapp,,0,0,0,, so that means that all the variables all the global variables the stack  the code 
Dialogue: 0,0:36:44.22,0:36:50.10,csapp,,0,0,0,,everything is identical and the child it has the exact same values as it as it does in the parent 
Dialogue: 0,0:36:51.86,0:36:56.98,csapp,,0,0,0,,the the child gets identical copies of the parents open open file descriptors
Dialogue: 0,0:36:57.02,0:37:04.16,csapp,,0,0,0,, so the child has access to any open files including like standard in and standard out  that the parent had 
Dialogue: 0,0:37:05.60,0:37:09.50,csapp,,0,0,0,,and the only difference is that the child gets a different process ID than the parent 
Dialogue: 0,0:37:10.88,0:37:12.78,csapp,,0,0,0,,so fork is really strange
Dialogue: 0,0:37:13.66,0:37:19.02,csapp,,0,0,0,, because it's called once but returns twice once in the parent and once in the child 
Dialogue: 0,0:37:21.56,0:37:23.04,csapp,,0,0,0,,so here's an example of this 
Dialogue: 0,0:37:25.94,0:37:34.66,csapp,,0,0,0,,here's a this is an example program that has a it has a local variable called X  on the stack initialized to 1 
Dialogue: 0,0:37:36.62,0:37:43.66,csapp,,0,0,0,,and then it calls fork and fork creates the child and returns the it 
Dialogue: 0,0:37:44.62,0:37:48.60,csapp,,0,0,0,,returns a value to that both the parent and the child 
Dialogue: 0,0:37:50.56,0:37:55.84,csapp,,0,0,0,,we the only way we can distinguish whether we're executing in the parent or the child is to check that return value 
Dialogue: 0,0:37:56.84,0:38:00.02,csapp,,0,0,0,,okay so here if the process ID if pid = 0
Dialogue: 0,0:38:00.52,0:38:02.02,csapp,,0,0,0,,then we're executing in the child 
Dialogue: 0,0:38:02.74,0:38:14.10,csapp,,0,0,0,,now remember the child got exactly the same has exactly the same memory and encode is the parent 
Dialogue: 0,0:38:15.14,0:38:18.46,csapp,,0,0,0,,so X in the child is is one 
Dialogue: 0,0:38:18.86,0:38:25.20,csapp,,0,0,0,,so when we print we print this message from the child we increment X and then print this this message
Dialogue: 0,0:38:25.80,0:38:29.52,csapp,,0,0,0,, so the child will print 1+1 2
Dialogue: 0,0:38:30.52,0:38:31.56,csapp,,0,0,0,,and then exit 
Dialogue: 0,0:38:33.60,0:38:36.40,csapp,,0,0,0,,in the parent when we check that this process ID
Dialogue: 0,0:38:36.40,0:38:39.96,csapp,,0,0,0,, it's going to be non zero because it's the process idea of that of the child 
Dialogue: 0,0:38:40.56,0:38:46.52,csapp,,0,0,0,,so in this case so so the parent won't execute this the body of this conditional
Dialogue: 0,0:38:47.28,0:38:49.60,csapp,,0,0,0,, so the parent will execute this printf 
Dialogue: 0,0:38:50.20,0:38:53.00,csapp,,0,0,0,,and in the parent we decrement X before we print it
Dialogue: 0,0:38:53.46,0:38:57.18,csapp,,0,0,0,, so the parent prints out 1-1 is 0 
Dialogue: 0,0:38:58.84,0:39:05.04,csapp,,0,0,0,,now there's no guarantee we have no guarantee whether the child or the parent executes first
Dialogue: 0,0:39:05.04,0:39:07.46,csapp,,0,0,0,, it could at with the fork 
Dialogue: 0,0:39:08.34,0:39:12.46,csapp,,0,0,0,,when the fork returns the the kernel may decide to schedule the child first
Dialogue: 0,0:39:13.70,0:39:18.40,csapp,,0,0,0,, okay in which in which case this code in the body of the conditional would run 
Dialogue: 0,0:39:18.96,0:39:22.20,csapp,,0,0,0,,or it may it may decide to run the parent first okay
Dialogue: 0,0:39:23.00,0:39:28.06,csapp,,0,0,0,, and and there's no way to predict and you it's is wrong it's an error to make any assumption
Dialogue: 0,0:39:28.92,0:39:31.36,csapp,,0,0,0,,like that about what's going to run first the parent of the child 
Dialogue: 0,0:39:33.06,0:39:35.90,csapp,,0,0,0,,and you can see that they share the same open files because 
Dialogue: 0,0:39:36.64,0:39:42.24,csapp,,0,0,0,,both the parent and the child print to standard out and it prints on the terminal okay 
Dialogue: 0,0:39:43.04,0:39:46.54,csapp,,0,0,0,,yes 
Dialogue: 0,0:39:46.58,0:39:50.44,csapp,,0,0,0,,Oh what if the question is what if you call fork multiple times I'll show you some examples of those
Dialogue: 0,0:39:52.70,0:39:59.78,csapp,,0,0,0,, it gets a little hairy will have a will use a model called the process graph to sort sort of understand what happens
Dialogue: 0,0:40:04.52,0:40:10.88,csapp,,0,0,0,,okay so like just like you said forks forks are kind of can be kind of complex
Dialogue: 0,0:40:11.12,0:40:14.52,csapp,,0,0,0,,and time to sin especially if they're nested or you call them multiple times
Dialogue: 0,0:40:15.12,0:40:17.68,csapp,,0,0,0,,so we use a tool called the process graph to 
Dialogue: 0,0:40:19.48,0:40:22.76,csapp,,0,0,0,,to capture sort of what what could happen 
Dialogue: 0,0:40:23.18,0:40:24.54,csapp,,0,0,0,,when we call Forks 
Dialogue: 0,0:40:24.66,0:40:30.18,csapp,,0,0,0,,right we can we can't we can't make any assumption about the ordering of of different processes 
Dialogue: 0,0:40:30.50,0:40:35.88,csapp,,0,0,0,,but we can capture the partial ordering of events using this this tool called a process graph 
Dialogue: 0,0:40:36.86,0:40:41.20,csapp,,0,0,0,,so what we'll do is we'll let each vertex correspond to the execution of a statement
Dialogue: 0,0:40:42.06,0:40:46.84,csapp,,0,0,0,, and then an edge is that happens before relation so a happens before B 
Dialogue: 0,0:40:47.38,0:40:50.16,csapp,,0,0,0,,and we will label edges with current values of variables 
Dialogue: 0,0:40:50.94,0:40:52.94,csapp,,0,0,0,,if we have a printf vertices 
Dialogue: 0,0:40:53.38,0:40:57.44,csapp,,0,0,0,,a printed X that corresponds to a printf we can label that with the output 
Dialogue: 0,0:40:58.28,0:41:02.38,csapp,,0,0,0,,and then the every graph starts with a vertex with no edges
Dialogue: 0,0:41:03.56,0:41:07.28,csapp,,0,0,0,,so given this graph then any topological sort of the graph represents 
Dialogue: 0,0:41:07.58,0:41:11.98,csapp,,0,0,0,,some feasible some feasible total ordering of events
Dialogue: 0,0:41:13.08,0:41:17.30,csapp,,0,0,0,, and by topological sort we mean a total ordering of the vertices 
Dialogue: 0,0:41:17.40,0:41:19.98,csapp,,0,0,0,,where all the edges go from left to right 
Dialogue: 0,0:41:22.18,0:41:24.82,csapp,,0,0,0,,okay so let's look at how this would work for our example program
Dialogue: 0,0:41:27.04,0:41:31.74,csapp,,0,0,0,, here we have the parent initially X is equal to 1 
Dialogue: 0,0:41:32.60,0:41:34.12,csapp,,0,0,0,,and then the parent calls fork 
Dialogue: 0,0:41:36.00,0:41:39.72,csapp,,0,0,0,,the fork returns in both the parent and the child
Dialogue: 0,0:41:40.88,0:41:48.76,csapp,,0,0,0,,the child prints and both the parent and the child print the value of x  after incrementing or decrementing 
Dialogue: 0,0:41:49.38,0:41:50.46,csapp,,0,0,0,,and then they both exit 
Dialogue: 0,0:41:51.44,0:41:55.58,csapp,,0,0,0,,ok so you can think of these as as happening 
Dialogue: 0,0:41:56.44,0:42:01.94,csapp,,0,0,0,,so these happen concurrently right which means they can be interleaved in in in any way the
Dialogue: 0,0:42:01.94,0:42:07.84,csapp,,0,0,0,,so the topological sort of this graph will tell us a feasible 
Dialogue: 0,0:42:08.48,0:42:11.06,csapp,,0,0,0,,what's a feasible water feasible interleavings
Dialogue: 0,0:42:14.26,0:42:18.96,csapp,,0,0,0,,okay so we can so if we if we real able the graph just to keep it simple 
Dialogue: 0,0:42:18.96,0:42:22.68,csapp,,0,0,0,,so if we if we real able these edges with just single letters 
Dialogue: 0,0:42:25.76,0:42:30.04,csapp,,0,0,0,,then this total ordering ABEC FD 
Dialogue: 0,0:42:30.80,0:42:36.04,csapp,,0,0,0,,represent is represents it's a topological sort and thus a feasible total ordering 
Dialogue: 0,0:42:36.56,0:42:39.58,csapp,,0,0,0,,so here we have a executing
Dialogue: 0,0:42:39.58,0:42:43.36,csapp,,0,0,0,, then B then I execute CIN the child
Dialogue: 0,0:42:44.50,0:42:50.00,csapp,,0,0,0,, and then at this point the the kernel decides to swap out 
Dialogue: 0,0:42:51.66,0:42:55.70,csapp,,0,0,0,,swap out e swap out the child and now let the parent run 
Dialogue: 0,0:42:56.12,0:42:59.44,csapp,,0,0,0,,so the parent picks up and executes C 
Dialogue: 0,0:43:01.04,0:43:06.12,csapp,,0,0,0,,and then and then it gets rescheduled to chat then the child gets scheduled and executes F 
Dialogue: 0,0:43:06.54,0:43:09.48,csapp,,0,0,0,,and then the parent the parent runs and finally finishes
Dialogue: 0,0:43:10.18,0:43:12.76,csapp,,0,0,0,, right so this is this is very unlikely that 
Dialogue: 0,0:43:13.28,0:43:16.46,csapp,,0,0,0,,it you only execute one instruction and then and then B 
Dialogue: 0,0:43:17.74,0:43:20.20,csapp,,0,0,0,,and then have a context switch but it's it's feasible
Dialogue: 0,0:43:20.98,0:43:22.45,csapp,,0,0,0,, right because it represents
Dialogue: 0,0:43:23.28,0:43:27.88,csapp,,0,0,0,,because the the total ordering is a is a is a topological ordering 
Dialogue: 0,0:43:29.16,0:43:34.70,csapp,,0,0,0,,on the other hand this is this is infeasible because F
Dialogue: 0,0:43:35.66,0:43:39.48,csapp,,0,0,0,, here in this total ordering we're executing F before E 
Dialogue: 0,0:43:40.30,0:43:43.26,csapp,,0,0,0,,and you can see that this that just can't happen right
Dialogue: 0,0:43:43.26,0:43:47.96,csapp,,0,0,0,,so the the edges on these the logical flow represented by this child
Dialogue: 0,0:43:48.20,0:43:51.82,csapp,,0,0,0,, have to occur in this order first E and then F right
Dialogue: 0,0:43:51.92,0:43:59.92,csapp,,0,0,0,, by the just because F follows E in the code right that the compilers not
Dialogue: 0,0:44:04.02,0:44:04.98,csapp,,0,0,0,,going to it's not going to alter those
Dialogue: 0,0:44:07.06,0:44:09.64,csapp,,0,0,0,,okay so what happens if now if we have two consecutive Forks 
Dialogue: 0,0:44:13.46,0:44:17.56,csapp,,0,0,0,,well let's draw the the process graph will help us understand this 
Dialogue: 0,0:44:18.38,0:44:22.78,csapp,,0,0,0,,so in the parent we print l0  and then fork 
Dialogue: 0,0:44:23.76,0:44:26.48,csapp,,0,0,0,,and that creates a child and both 
Dialogue: 0,0:44:27.44,0:44:31.04,csapp,,0,0,0,,and so the fork returns to this printf in both the parent and the child 
Dialogue: 0,0:44:31.04,0:44:34.58,csapp,,0,0,0,,so they both the parent and the child print l1 
Dialogue: 0,0:44:36.86,0:44:39.40,csapp,,0,0,0,,and then both parent and child execute a fork 
Dialogue: 0,0:44:41.54,0:44:47.22,csapp,,0,0,0,,so that creates that creates another child that creates two more now two two children 
Dialogue: 0,0:44:48.48,0:44:53.90,csapp,,0,0,0,,and then and so that returns to the printf which says bye 
Dialogue: 0,0:44:54.80,0:44:59.50,csapp,,0,0,0,,so the result of this of calling Fork twice like this is that it creates four processes 
Dialogue: 0,0:45:01.30,0:45:06.66,csapp,,0,0,0,,okay and you can and if it's confusing you can always work it out with the the process graph like this
Dialogue: 0,0:45:07.18,0:45:11.84,csapp,,0,0,0,, okay so we can weaken us we can see feasible and infeasible orderings
Dialogue: 0,0:45:12.66,0:45:14.68,csapp,,0,0,0,, so this one's feasible take my word for
Dialogue: 0,0:45:14.70,0:45:16.92,csapp,,0,0,0,, it this one is infeasible 
Dialogue: 0,0:45:17.62,0:45:19.88,csapp,,0,0,0,,and let's see why so L 0 
Dialogue: 0,0:45:22.06,0:45:28.18,csapp,,0,0,0,,and there's no way to to print by before the first fork 
Dialogue: 0,0:45:28.56,0:45:29.66,csapp,,0,0,0,,all right so that's infeasible
Dialogue: 0,0:45:29.82,0:45:34.82,csapp,,0,0,0,, if we if we drew out this process graph we'd have a backward  a backward edge 
Dialogue: 0,0:45:38.38,0:45:41.47,csapp,,0,0,0,,okay now what happens if we nest Forks in the parent
Dialogue: 0,0:45:41.88,0:45:45.60,csapp,,0,0,0,,okay I'm not sure why you'd want to do this except maybe to torture to 13 students 
Dialogue: 0,0:45:46.78,0:45:47.22,csapp,,0,0,0,,but
Dialogue: 0,0:45:50.80,0:45:53.50,csapp,,0,0,0,,so we can just work this out by drawing the process graph 
Dialogue: 0,0:45:54.86,0:45:57.12,csapp,,0,0,0,,so here we have the parent it prints L0 
Dialogue: 0,0:45:57.76,0:46:01.04,csapp,,0,0,0,,and then it does a fork so that creates a child
Dialogue: 0,0:46:04.02,0:46:09.74,csapp,,0,0,0,, so the child if fork is not equal to 0 
Dialogue: 0,0:46:10.86,0:46:13.82,csapp,,0,0,0,,then we're in the parent right so this code executes sin the parent 
Dialogue: 0,0:46:15.44,0:46:16.88,csapp,,0,0,0,,if fork is 0
Dialogue: 0,0:46:17.74,0:46:21.14,csapp,,0,0,0,,then we're executing the child and the child just prints by and then 
Dialogue: 0,0:46:23.06,0:46:28.78,csapp,,0,0,0,,and then terminate it eventually terminates I didn't show it here but  calls exit 
Dialogue: 0,0:46:29.60,0:46:32.58,csapp,,0,0,0,,think the function that called this function calls exit 
Dialogue: 0,0:46:33.98,0:46:40.70,csapp,,0,0,0,,so the parent so fork not equal to 0  indicates that this is the parent
Dialogue: 0,0:46:42.26,0:46:46.00,csapp,,0,0,0,, so the parent prints l1 and then it does another fork 
Dialogue: 0,0:46:47.16,0:46:48.64,csapp,,0,0,0,,that fork creates a child
Dialogue: 0,0:46:52.00,0:46:54.88,csapp,,0,0,0,, so if if fork is not equal to 0
Dialogue: 0,0:46:55.50,0:47:02.50,csapp,,0,0,0,,then we're in the parent so the parent prints l2 and then exits this conditional and prints by 
Dialogue: 0,0:47:03.62,0:47:08.90,csapp,,0,0,0,,if if fork returns 0 then that means we're executing the child 
Dialogue: 0,0:47:08.96,0:47:12.60,csapp,,0,0,0,,so we don't execute this code we jump out of this conditional
Dialogue: 0,0:47:12.98,0:47:15.32,csapp,,0,0,0,, and then the child just prints by 
Dialogue: 0,0:47:16.32,0:47:16.72,csapp,,0,0,0,,okay 
Dialogue: 0,0:47:19.26,0:47:20.26,csapp,,0,0,0,,and we can 
Dialogue: 0,0:47:23.76,0:47:27.42,csapp,,0,0,0,, represents an infeasible output from this program 
Dialogue: 0,0:47:30.08,0:47:36.02,csapp,,0,0,0,,l0 Fork week so L 0 followed by by that's feasible 
Dialogue: 0,0:47:37.18,0:47:39.56,csapp,,0,0,0,,and then followed by L 1 that's okay 
Dialogue: 0,0:47:42.58,0:47:45.32,csapp,,0,0,0,,and then the next by is okay but it since 
Dialogue: 0,0:47:45.80,0:47:51.86,csapp,,0,0,0,,we can't have this we can't have this by proceeding this L2 
Dialogue: 0,0:47:52.74,0:47:58.08,csapp,,0,0,0,,because L2 will this printf will execute before this printf
Dialogue: 0,0:48:00.80,0:48:07.54,csapp,,0,0,0,,okay and I'll let you work out this one as a as an exercise 
Dialogue: 0,0:48:09.14,0:48:14.28,csapp,,0,0,0,,all right now when up when a process terminates  for whatever reason 
Dialogue: 0,0:48:14.70,0:48:18.08,csapp,,0,0,0,,the system actually keeps it around for until it's reaped
Dialogue: 0,0:48:19.36,0:48:22.10,csapp,,0,0,0,,and the reason until it's reaped by its parent
Dialogue: 0,0:48:23.20,0:48:28.38,csapp,,0,0,0,, and the reason it does this is that the parent may want to know about the exit status of the child 
Dialogue: 0,0:48:28.40,0:48:30.56,csapp,,0,0,0,,so but if a parent creates a child 
Dialogue: 0,0:48:31.04,0:48:35.90,csapp,,0,0,0,,it may want to wait for that child to finish and and check its exit status 
Dialogue: 0,0:48:36.76,0:48:38.60,csapp,,0,0,0,,so when when any process terminates 
Dialogue: 0,0:48:38.96,0:48:43.52,csapp,,0,0,0,,the system leaves that it doesn't it doesn't remove it entirely from the system 
Dialogue: 0,0:48:43.74,0:48:46.96,csapp,,0,0,0,,it it keeps it a little bit of state associated with that child 
Dialogue: 0,0:48:47.40,0:48:50.88,csapp,,0,0,0,,in the form of a the exit status of the child 
Dialogue: 0,0:48:51.54,0:48:55.74,csapp,,0,0,0,,and the in some other tables some other OS tables 
Dialogue: 0,0:48:56.70,0:49:00.38,csapp,,0,0,0,,so because this child that's terminated but it's not gone
Dialogue: 0,0:49:01.04,0:49:04.42,csapp,,0,0,0,, it they're called zombies so there's sort of half half-living half-dead 
Dialogue: 0,0:49:08.34,0:49:11.16,csapp,,0,0,0,,and so a process a zombie
Dialogue: 0,0:49:11.52,0:49:15.52,csapp,,0,0,0,,remains a zombie until it's it's it's reaped by its parent
Dialogue: 0,0:49:16.00,0:49:18.38,csapp,,0,0,0,, using a function called weight or weight pit 
Dialogue: 0,0:49:19.46,0:49:22.98,csapp,,0,0,0,,and as a result of as a result of doing weight or weight pit 
Dialogue: 0,0:49:23.14,0:49:25.66,csapp,,0,0,0,,the parent is given the exit status information 
Dialogue: 0,0:49:26.00,0:49:28.90,csapp,,0,0,0,,and then the kernel deletes the zombie process 
Dialogue: 0,0:49:32.12,0:49:35.94,csapp,,0,0,0,,now what if the parent doesn't reap it's one of its child zombies 
Dialogue: 0,0:49:36.74,0:49:42.20,csapp,,0,0,0,,so it if any parent if the parent terminates 
Dialogue: 0,0:49:43.34,0:49:47.64,csapp,,0,0,0,,then the system arranges for the very first process that existed in the system
Dialogue: 0,0:49:48.14,0:49:50.90,csapp,,0,0,0,, called the init process which has a process ID of one 
Dialogue: 0,0:49:51.18,0:49:54.46,csapp,,0,0,0,,it arranges for the anit process to reap that that child 
Dialogue: 0,0:49:57.26,0:50:04.52,csapp,,0,0,0,,so there's so orphaned orphaned children will always be reaped by by the anit process 
Dialogue: 0,0:50:04.92,0:50:10.04,csapp,,0,0,0,,so we only really have to worry about about reaping zombies 
Dialogue: 0,0:50:10.54,0:50:16.68,csapp,,0,0,0,,in in the case where we have long-running parents like shells or servers 
Dialogue: 0,0:50:17.44,0:50:22.30,csapp,,0,0,0,,because in that case a server may create millions of child processes 
Dialogue: 0,0:50:22.30,0:50:29.06,csapp,,0,0,0,,each one of those each one of those does each one of those child processes when they terminate
Dialogue: 0,0:50:29.38,0:50:31.40,csapp,,0,0,0,, become zombies and they they have state 
Dialogue: 0,0:50:31.64,0:50:33.48,csapp,,0,0,0,,that takes up room in the kernel so 
Dialogue: 0,0:50:34.20,0:50:37.02,csapp,,0,0,0,,you can get this it's a form of memory leak
Dialogue: 0,0:50:37.92,0:50:43.60,csapp,,0,0,0,, if you don't if you don't reap these zombie children that can eventually fill up the memory space and crash the kernel 
Dialogue: 0,0:50:48.84,0:50:52.32,csapp,,0,0,0,,so for for cases where you have long-running programs 
Dialogue: 0,0:50:52.32,0:50:56.48,csapp,,0,0,0,,then we have to we have to use wait or wait pit to reap the children
Dialogue: 0,0:50:58.32,0:51:05.86,csapp,,0,0,0,, so let's look at an example first let's let's look at an example of  this zombie phenomenon 
Dialogue: 0,0:51:06.56,0:51:09.06,csapp,,0,0,0,,so here we have a function we call fork 
Dialogue: 0,0:51:10.14,0:51:17.18,csapp,,0,0,0,,and then within the child we print a message of the process idea of that child  and then we exit the child 
Dialogue: 0,0:51:18.24,0:51:22.48,csapp,,0,0,0,,within the parent we print a message and then we go into an infinite loop 
Dialogue: 0,0:51:22.92,0:51:28.74,csapp,,0,0,0,,okay so this is a parent that's that never never reaps the child that it created 
Dialogue: 0,0:51:30.00,0:51:34.18,csapp,,0,0,0,,so if we run this program called Forks 
Dialogue: 0,0:51:36.20,0:51:38.32,csapp,,0,0,0,,you can see it prints these two messages 
Dialogue: 0,0:51:39.92,0:51:44.98,csapp,,0,0,0,,the parent prints a message and the child prints a message and then 
Dialogue: 0,0:51:46.28,0:51:48.92,csapp,,0,0,0,,and we're running it in the background with this ampersand 
Dialogue: 0,0:51:49.16,0:51:54.04,csapp,,0,0,0,,okay because we're going to otherwise it would it would it's it's it's still v
Dialogue: 0,0:51:54.04,0:51:56.76,csapp,,0,0,0,, and we wouldn't be able to inspect it 
Dialogue: 0,0:51:57.32,0:51:59.50,csapp,,0,0,0,,so after we run this program in the background
Dialogue: 0,0:51:59.96,0:52:02.32,csapp,,0,0,0,, then we use PS to print the current processes 
Dialogue: 0,0:52:03.00,0:52:08.92,csapp,,0,0,0,,and we can see that there's two we can see here at the parent which is process ID 6639
Dialogue: 0,0:52:09.76,0:52:12.74,csapp,,0,0,0,,and then the child which is 66410 and
Dialogue: 0,0:52:14.70,0:52:16.88,csapp,,0,0,0,,that the defunct indicates that it's a zombie
Dialogue: 0,0:52:19.16,0:52:23.78,csapp,,0,0,0,,okay now if we kill six 6639 that's the parent
Dialogue: 0,0:52:25.78,0:52:30.32,csapp,,0,0,0,, and then do another PS you see that the zombies gone that the child is gone
Dialogue: 0,0:52:30.32,0:52:33.02,csapp,,0,0,0,, because it's been reaped by the init process one 
Dialogue: 0,0:52:36.82,0:52:41.36,csapp,,0,0,0,,now what happens if the child doesn't terminate you might wonder like if if a parent creates a child 
Dialogue: 0,0:52:43.40,0:52:50.66,csapp,,0,0,0,,and then the parent and then the chattin the the child never terminates 
Dialogue: 0,0:52:51.64,0:52:54.88,csapp,,0,0,0,,and and the parent terminates then what would happen right mark
Dialogue: 0,0:52:56.54,0:52:58.94,csapp,,0,0,0,,so let's just let's look at an example of those in C 
Dialogue: 0,0:52:59.92,0:53:04.52,csapp,,0,0,0,,so here we're we're calling Fork we're creating a child
Dialogue: 0,0:53:05.34,0:53:10.48,csapp,,0,0,0,,within the child we'd print a message and then the child goes into an infinite loop
Dialogue: 0,0:53:11.80,0:53:15.48,csapp,,0,0,0,, and the parent prints a message and then exits 
Dialogue: 0,0:53:16.74,0:53:18.12,csapp,,0,0,0,,so if we run this program 
Dialogue: 0,0:53:20.58,0:53:23.72,csapp,,0,0,0,,you can see that the two messages from parent and child 
Dialogue: 0,0:53:25.52,0:53:28.68,csapp,,0,0,0,,and then if we look at the if we look at the processes 
Dialogue: 0,0:53:28.68,0:53:32.30,csapp,,0,0,0,,we can see we can see that the child is still running
Dialogue: 0,0:53:39.58,0:53:43.52,csapp,,0,0,0,,okay so the channel process is still running even though the parents's has terminated
Dialogue: 0,0:53:45.06,0:53:48.90,csapp,,0,0,0,, and now if we kill this child 6676
Dialogue: 0,0:53:54.70,0:53:59.08,csapp,,0,0,0,,and then if we kill it then we can see that it's it's gone it's no longer in the system okay so 
Dialogue: 0,0:54:00.12,0:54:02.72,csapp,,0,0,0,,that child when we when we killed it that terminated 
Dialogue: 0,0:54:03.46,0:54:09.36,csapp,,0,0,0,,it it had no parents so the unit process reaped it and it it's no longer a zombie
Dialogue: 0,0:54:12.08,0:54:19.20,csapp,,0,0,0,,so the the the function that we use to to synchronize with children and reap them
Dialogue: 0,0:54:20.74,0:54:22.20,csapp,,0,0,0,, the simplest one is called wait 
Dialogue: 0,0:54:23.50,0:54:27.20,csapp,,0,0,0,,and wait it takes an optional status 
Dialogue: 0,0:54:28.64,0:54:33.20,csapp,,0,0,0,,where you can get the exit status of the inspect the exit status of the child 
Dialogue: 0,0:54:34.26,0:54:39.14,csapp,,0,0,0,,basically wait suspends the execution of the process that calls it 
Dialogue: 0,0:54:40.12,0:54:42.36,csapp,,0,0,0,,until one or one of its children terminates 
Dialogue: 0,0:54:42.88,0:54:48.26,csapp,,0,0,0,,and it doesn't specify which one it just waits until one of the children that it created terminates 
Dialogue: 0,0:54:50.48,0:54:53.16,csapp,,0,0,0,,and then if this child status is is not null 
Dialogue: 0,0:54:54.02,0:54:58.82,csapp,,0,0,0,,then the integer that it returns or the integer that it points to this is a pointer 
Dialogue: 0,0:54:59.50,0:55:05.54,csapp,,0,0,0,,the integer that it points to will be set to some value that indicated the reason the child terminated and its exit status 
Dialogue: 0,0:55:06.10,0:55:08.50,csapp,,0,0,0,,and you can you can check that using these macros
Dialogue: 0,0:55:10.00,0:55:14.16,csapp,,0,0,0,, which your your textbook describes in more detail and let you 
Dialogue: 0,0:55:16.61,0:55:19.24,csapp,,0,0,0,,so let's look at how how this works in a simple example 
Dialogue: 0,0:55:19.88,0:55:26.04,csapp,,0,0,0,,so here we're calling fork and creating a child which prints a message and then exits 
Dialogue: 0,0:55:27.88,0:55:33.14,csapp,,0,0,0,,the parent prints a message and then it waits for the child to terminate 
Dialogue: 0,0:55:34.14,0:55:37.40,csapp,,0,0,0,,and when the child terminates it prints a message 
Dialogue: 0,0:55:38.24,0:55:41.74,csapp,,0,0,0,,and indicating that the child terminated and then prints by 
Dialogue: 0,0:55:42.40,0:55:45.34,csapp,,0,0,0,,so if we were to look at the the process graph for this 
Dialogue: 0,0:55:46.14,0:55:50.36,csapp,,0,0,0,,you would see that we would have the fork creates the parent and the child
Dialogue: 0,0:55:51.52,0:55:54.14,csapp,,0,0,0,, both the parent and the child do they're they're print outs 
Dialogue: 0,0:55:55.74,0:56:04.46,csapp,,0,0,0,,and then the parent waits it suspends until that the child terminates in this case by calling exit
Dialogue: 0,0:56:07.56,0:56:10.10,csapp,,0,0,0,,okay so what that means is it's it's infeasible
Dialogue: 0,0:56:13.10,0:56:14.70,csapp,,0,0,0,, so you can say hello from the parent
Dialogue: 0,0:56:18.40,0:56:20.07,csapp,,0,0,0,, it's infeasible though for this
Dialogue: 0,0:56:20.92,0:56:26.46,csapp,,0,0,0,,this child terminated message CT to occur before the bye 
Dialogue: 0,0:56:28.42,0:56:29.30,csapp,,0,0,0,,because
Dialogue: 0,0:56:34.10,0:56:37.70,csapp,,0,0,0,,because the the child hasn't yet terminated so 
Dialogue: 0,0:56:39.62,0:56:42.36,csapp,,0,0,0,,it's these two these two messages will never be printed 
Dialogue: 0,0:56:42.86,0:56:45.46,csapp,,0,0,0,,until the child is terminated by calling exit 
Dialogue: 0,0:56:47.92,0:56:49.42,csapp,,0,0,0,,so is that clear yes
Dialogue: 0,0:56:56.32,0:56:58.72,csapp,,0,0,0,, so the question is can you have an output HP 
Dialogue: 0,0:57:03.24,0:57:09.08,csapp,,0,0,0,,HP HC CT bye yes 
Dialogue: 0,0:57:10.76,0:57:19.06,csapp,,0,0,0,,yes because the parent ex-prince HP there's a context switch the child prints HC 
Dialogue: 0,0:57:19.58,0:57:24.25,csapp,,0,0,0,,and then exits and now the parent will the wait will return 
Dialogue: 0,0:57:24.56,0:57:26.42,csapp,,0,0,0,,and then it prints CT bye
Dialogue: 0,0:57:33.32,0:57:41.02,csapp,,0,0,0,,okay here's this is a and this is a little more a little more involved example
Dialogue: 0,0:57:41.56,0:57:44.42,csapp,,0,0,0,, so here what we want to do we're going to create a bunch of children 
Dialogue: 0,0:57:45.06,0:57:47.42,csapp,,0,0,0,,and then we're going to wait for them all to terminate
Dialogue: 0,0:57:48.10,0:57:52.70,csapp,,0,0,0,, and we're going to wait but we won't be able to wait in any specific order right we're just 
Dialogue: 0,0:57:55.28,0:57:58.02,csapp,,0,0,0,,so here we have a loop 0 through n 
Dialogue: 0,0:57:59.24,0:58:06.44,csapp,,0,0,0,,and in each loop body we're going to we're going to fork a child and exit with a return status 
Dialogue: 0,0:58:06.44,0:58:08.62,csapp,,0,0,0,,that that's going to tell us which child it was
Dialogue: 0,0:58:12.02,0:58:16.86,csapp,,0,0,0,,was ok so in the parent so we do this we do this a n times 
Dialogue: 0,0:58:18.96,0:58:25.78,csapp,,0,0,0,,and then and then afterward the parent inside inside a similar loop 0 to n
Dialogue: 0,0:58:26.32,0:58:29.18,csapp,,0,0,0,,add waits for a child to terminate
Dialogue: 0,0:58:29.18,0:58:32.22,csapp,,0,0,0,, so it'll it'll work it will wait for M children to terminate
Dialogue: 0,0:58:34.50,0:58:41.20,csapp,,0,0,0,,wait returns a way returns the the process ID 
Dialogue: 0,0:58:42.22,0:58:51.26,csapp,,0,0,0,,and then a status which is in in this child status variable 
Dialogue: 0,0:58:52.40,0:58:57.02,csapp,,0,0,0,,and so we take that variable now and we can use this w if exited macro to determine 
Dialogue: 0,0:58:57.03,0:59:00.06,csapp,,0,0,0,,if it terminated normally with an exit by calling exit 
Dialogue: 0,0:59:00.84,0:59:06.68,csapp,,0,0,0,,and if so then we can check its exit status using the W exit status macro
Dialogue: 0,0:59:07.28,0:59:10.29,csapp,,0,0,0,, otherwise if it if W if exited it
Dialogue: 0,0:59:10.64,0:59:14.84,csapp,,0,0,0,,is false then that means some something the child terminated 
Dialogue: 0,0:59:14.84,0:59:17.64,csapp,,0,0,0,,for some other reason not not because it called exit
Dialogue: 0,0:59:21.32,0:59:22.60,csapp,,0,0,0,,okay there's a 
Dialogue: 0,0:59:24.06,0:59:28.84,csapp,,0,0,0,,weekend we can actually use wait pit which is similar to wait 
Dialogue: 0,0:59:28.84,0:59:33.08,csapp,,0,0,0,,but it allows us to wait for a specific process a specific child 
Dialogue: 0,0:59:33.32,0:59:37.72,csapp,,0,0,0,,a specific process a specific child with a specific process ID to terminate 
Dialogue: 0,0:59:38.40,0:59:44.52,csapp,,0,0,0,,and I'll I'll let you you can wait pit is really involved and
Dialogue: 0,0:59:44.98,0:59:48.10,csapp,,0,0,0,,it's described in detail in the in your textbook
Dialogue: 0,0:59:48.48,0:59:52.20,csapp,,0,0,0,, and so you'll need to look you'll need to look there for the details on how that works 
Dialogue: 0,0:59:55.08,0:59:58.68,csapp,,0,0,0,,now another important so we've learned how to create new processes 
Dialogue: 0,1:00:02.38,1:00:05.30,csapp,,0,0,0,,the but we haven't learned how to when we when we call fork 
Dialogue: 0,1:00:05.30,1:00:10.82,csapp,,0,0,0,,we just create an exact copy of the the child is just an exact copy of the parrot 
Dialogue: 0,1:00:11.24,1:00:14.26,csapp,,0,0,0,,running the same code same program same variables
Dialogue: 0,1:00:14.98,1:00:20.28,csapp,,0,0,0,, okay to run a different program inside of a process we use a function called execve
Dialogue: 0,1:00:22.52,1:00:26.40,csapp,,0,0,0,,and exit loads and runs 
Dialogue: 0,1:00:28.38,1:00:30.92,csapp,,0,0,0,,within the current process it loads and runs 
Dialogue: 0,1:00:31.46,1:00:34.54,csapp,,0,0,0,,the executable file name which is its first argument 
Dialogue: 0,1:00:35.48,1:00:39.16,csapp,,0,0,0,,and file name can be either a binary executable binary
Dialogue: 0,1:00:40.52,1:00:43.54,csapp,,0,0,0,, okay or it can be a script it can be a text file 
Dialogue: 0,1:00:45.22,1:00:47.72,csapp,,0,0,0,,a so-called script file that starts 
Dialogue: 0,1:00:49.08,1:00:56.50,csapp,,0,0,0,,whose first line starts with a pound bang and then and then that the path of some interpreter 
Dialogue: 0,1:00:56.78,1:00:59.58,csapp,,0,0,0,,so for example if you if you want to write a shell script
Dialogue: 0,1:01:00.50,1:01:05.57,csapp,,0,0,0,, you the first line of your shell script is is a pound bang and then  
Dialogue: 0,1:01:06.02,1:01:07.96,csapp,,0,0,0,,the path name of the bash 
Dialogue: 0,1:01:08.94,1:01:11.50,csapp,,0,0,0,,and then that will that will execute bash
Dialogue: 0,1:01:11.90,1:01:17.34,csapp,,0,0,0,,and then bash will will read in that the lines following and interpret them 
Dialogue: 0,1:01:18.08,1:01:21.04,csapp,,0,0,0,,as just as though you'd type them in at the at the command line 
Dialogue: 0,1:01:23.10,1:01:27.42,csapp,,0,0,0,, so in either case it executes either an interpreter or it executes a binary 
Dialogue: 0,1:01:28.42,1:01:31.96,csapp,,0,0,0,,with who's argued with the argument list ArgV 
Dialogue: 0,1:01:33.04,1:01:36.24,csapp,,0,0,0,,and a list of environment very in envp
Dialogue: 0,1:01:38.52,1:01:41.54,csapp,,0,0,0,,okay now by default are the first argument 
Dialogue: 0,1:01:42.18,1:01:48.24,csapp,,0,0,0,,in RV is the name of the file that that's being executed  so it it's it's this file name 
Dialogue: 0,1:01:51.32,1:01:52.60,csapp,,0,0,0,,so what that allows you to do is
Dialogue: 0,1:01:53.04,1:01:58.60,csapp,,0,0,0,, in your code you can check our v-0 if you want to print out the name of the file the name of the program that's executing 
Dialogue: 0,1:01:59.08,1:02:00.72,csapp,,0,0,0,,you just print out our v-0 
Dialogue: 0,1:02:05.98,1:02:12.04,csapp,,0,0,0,,okay now and exits all of the code and the data and the stack
Dialogue: 0,1:02:12.16,1:02:16.80,csapp,,0,0,0,, it overwrites the completely overrides the virtual address space 
Dialogue: 0,1:02:17.82,1:02:20.78,csapp,,0,0,0,,so once you call eggs AK within a within a process
Dialogue: 0,1:02:22.52,1:02:25.14,csapp,,0,0,0,, it blows away the current program that's it
Dialogue: 0,1:02:25.70,1:02:31.70,csapp,,0,0,0,,okay however it retains that it's still the same process it's just running now a different program 
Dialogue: 0,1:02:35.06,1:02:39.44,csapp,,0,0,0,,and so it retains the process ID and any open files that you have
Dialogue: 0,1:02:43.18,1:02:47.43,csapp,,0,0,0,, so x''k is really is really mind-blowing because it's called once
Dialogue: 0,1:02:48.34,1:02:49.36,csapp,,0,0,0,,but it never returns 
Dialogue: 0,1:02:53.12,1:02:54.50,csapp,,0,0,0,,except if there's an error 
Dialogue: 0,1:02:54.58,1:02:59.30,csapp,,0,0,0,,so if this file doesn't exist for example then then exec will return on -1 
Dialogue: 0,1:02:59.90,1:03:03.04,csapp,,0,0,0,,but otherwise in normal operation it never returns 
Dialogue: 0,1:03:06.00,1:03:07.86,csapp,,0,0,0,,all right so let's look at the structure of the stack 
Dialogue: 0,1:03:07.88,1:03:10.54,csapp,,0,0,0,,when this new program starts so after 
Dialogue: 0,1:03:11.42,1:03:15.54,csapp,,0,0,0,,app after exit after the eggs egg ve finishes its work it creates 
Dialogue: 0,1:03:16.60,1:03:23.98,csapp,,0,0,0,,a new stack it loads in new code and data creates a new empty heap
Dialogue: 0,1:03:25.70,1:03:26.78,csapp,,0,0,0,, ok everything's new 
Dialogue: 0,1:03:28.42,1:03:32.28,csapp,,0,0,0,,and the stack that it creates has the following form
Dialogue: 0,1:03:33.64,1:03:38.38,csapp,,0,0,0,,ok at the bottom here's the bottom of the stack and our stack is growing this way
Dialogue: 0,1:03:40.76,1:03:42.44,csapp,,0,0,0,, so the first function that executes
Dialogue: 0,1:03:43.84,1:03:47.78,csapp,,0,0,0,,is is a function called Lipsy underscore start underscore main
Dialogue: 0,1:03:48.44,1:03:50.50,csapp,,0,0,0,,so that has it that has a stack frame 
Dialogue: 0,1:03:53.83,1:03:59.00,csapp,,0,0,0,,so let's look this is what I'm showing here is the situation right before the startup code calls main 
Dialogue: 0,1:04:00.76,1:04:07.35,csapp,,0,0,0,,so there's there's the future stack frame for main will be here at the top of this
Dialogue: 0,1:04:07.70,1:04:09.40,csapp,,0,0,0,,following the top of the stack 
Dialogue: 0,1:04:11.46,1:04:20.24,csapp,,0,0,0,,there's some padding and then the argument list in RV  is contained on the on the stack
Dialogue: 0,1:04:20.24,1:04:25.00,csapp,,0,0,0,,so that the RV is a list of pointers terminated by the null pointer 
Dialogue: 0,1:04:25.72,1:04:31.29,csapp,,0,0,0,,and each one of these pointers points up into a string that corresponds to an argument
Dialogue: 0,1:04:32.26,1:04:38.14,csapp,,0,0,0,,okay so when you run a program you specify the program name 
Dialogue: 0,1:04:39.34,1:04:41.30,csapp,,0,0,0,,and then arguments separated by spaces 
Dialogue: 0,1:04:42.86,1:04:49.94,csapp,,0,0,0,,okay and so these these arguments this arc V is a list of pointers to those arguments strings
Dialogue: 0,1:04:51.08,1:04:55.60,csapp,,0,0,0,, and it's pointed to right right as main is called 
Dialogue: 0,1:04:55.60,1:04:59.12,csapp,,0,0,0,,it's it's it's it's the second argument to main 
Dialogue: 0,1:04:59.46,1:05:05.16,csapp,,0,0,0,,so it's contained in %rsi the address of this argument lists 
Dialogue: 0,1:05:06.10,1:05:10.78,csapp,,0,0,0,,the number of arguments is contained is the first argument argc
Dialogue: 0,1:05:10.82,1:05:17.08,csapp,,0,0,0,,and that's contained in %rdi by the x86-64  parameter passing convention 
Dialogue: 0,1:05:17.68,1:05:21.62,csapp,,0,0,0,,now the environment list is also contained on the stack 
Dialogue: 0,1:05:21.70,1:05:28.98,csapp,,0,0,0,,and it too consists of a list of pointers each of which points into a environment  string 
Dialogue: 0,1:05:28.98,1:05:31.50,csapp,,0,0,0,,which is a set of key equal value pairs okay 
Dialogue: 0,1:05:33.98,1:05:38.24,csapp,,0,0,0,,and it's pointed to by the global environment variable environ
Dialogue: 0,1:05:39.20,1:05:46.40,csapp,,0,0,0,, and if it's passed in it's pointed at an envp it which is contained in %rdx
Dialogue: 0,1:05:46.40,1:05:49.40,csapp,,0,0,0,,which is the always holds the third argument
Dialogue: 0,1:05:52.26,1:05:55.22,csapp,,0,0,0,,okay so let's look now how how we would use this 
Dialogue: 0,1:05:57.44,1:06:02.08,csapp,,0,0,0,,so we want to within our current program we want to execute the LS command 
Dialogue: 0,1:06:03.08,1:06:08.20,csapp,,0,0,0,,with two arguments - LT and /usr/include 
Dialogue: 0,1:06:08.20,1:06:13.28,csapp,,0,0,0,,so what this is saying is list list the files in /usr/include
Dialogue: 0,1:06:14.48,1:06:18.08,csapp,,0,0,0,,show the long form of the listing and sort them in time order 
Dialogue: 0,1:06:18.48,1:06:21.04,csapp,,0,0,0,,from most recently used to at least recently used
Dialogue: 0,1:06:23.08,1:06:26.66,csapp,,0,0,0,, so so the way we do this
Dialogue: 0,1:06:28.32,1:06:31.24,csapp,,0,0,0,, if we just called execve it blow away our program
Dialogue: 0,1:06:31.24,1:06:35.08,csapp,,0,0,0,, so assuming we want to continue to do work after we execute LS
Dialogue: 0,1:06:36.24,1:06:40.78,csapp,,0,0,0,, the the standard way to do this is to to create a child using Fork 
Dialogue: 0,1:06:41.92,1:06:44.40,csapp,,0,0,0,,and then X act within the child 
Dialogue: 0,1:06:45.60,1:06:46.84,csapp,,0,0,0,,right have the child do the work
Dialogue: 0,1:06:47.76,1:06:53.56,csapp,,0,0,0,, and then the child terminates and the parent maybe will wait for the child maybe not right just 
Dialogue: 0,1:06:55.04,1:06:56.52,csapp,,0,0,0,,usually it will wait for the child 
Dialogue: 0,1:06:58.44,1:07:04.62,csapp,,0,0,0,,so within the parent we we we fork a child  check that it's 0
Dialogue: 0,1:07:05.78,1:07:10.88,csapp,,0,0,0,,and so if it's 0 then we're executing that this code executes within the child
Dialogue: 0,1:07:11.46,1:07:12.96,csapp,,0,0,0,,so the child does the exact 
Dialogue: 0,1:07:15.02,1:07:18.52,csapp,,0,0,0,,it it passes the name of the function since the 
Dialogue: 0,1:07:19.16,1:07:22.88,csapp,,0,0,0,,the name of the function that we want to the the program that we want to execute 
Dialogue: 0,1:07:22.88,1:07:26.04,csapp,,0,0,0,,is always contained in the first element of vard V 
Dialogue: 0,1:07:26.50,1:07:31.08,csapp,,0,0,0,,we call exit with a parameter of myargv[0] 
Dialogue: 0,1:07:33.46,1:07:38.20,csapp,,0,0,0,,and we've set up the argument list in myargv
Dialogue: 0,1:07:39.62,1:07:43.34,csapp,,0,0,0,,and we pass the global environment variable environment 
Dialogue: 0,1:07:43.54,1:07:48.70,csapp,,0,0,0,,we're just going to use the current list of environment variables that we have in the parent 
Dialogue: 0,1:07:52.00,1:07:58.06,csapp,,0,0,0,,okay and these environment variables are things of the form user=droh current working directory
Dialogue: 0,1:08:02.22,1:08:04.04,csapp,,0,0,0,,and so the the 
Dialogue: 0,1:08:06.46,1:08:12.76,csapp,,0,0,0,,if there's if this program in myargv[0] doesn't exist then exact will return -0
Dialogue: 0,1:08:13.28,1:08:17.19,csapp,,0,0,0,,so we check for that that condition and then exit
Dialogue: 0,1:08:17.64,1:08:21.92,csapp,,0,0,0,,otherwise it never returns right it executes ls 
Dialogue: 0,1:08:22.66,1:08:24.60,csapp,,0,0,0,,LS the code for LS
Dialogue: 0,1:08:24.94,1:08:29.98,csapp,,0,0,0,, this is the name of a binary this is a /bin/ls is a binary file 
Dialogue: 0,1:08:30.94,1:08:33.04,csapp,,0,0,0,,that binary file gets loaded into memory 
Dialogue: 0,1:08:35.36,1:08:37.83,csapp,,0,0,0,,that code gets executed and it terminates
Dialogue: 0,1:08:38.48,1:08:42.12,csapp,,0,0,0,,okay so the child at this point after the exit
Dialogue: 0,1:08:43.60,1:08:47.00,csapp,,0,0,0,, the child is running that the LS code 
Dialogue: 0,1:08:47.00,1:08:50.56,csapp,,0,0,0,,and it's no longer running any of this code 
Dialogue: 0,1:08:52.00,1:08:57.20,csapp,,0,0,0,,now this seems the first time you see this this combination of fork and exec it seems 
Dialogue: 0,1:08:58.14,1:09:01.50,csapp,,0,0,0,,it seems a little odd doesn't it why not just 
Dialogue: 0,1:09:02.80,1:09:06.24,csapp,,0,0,0,,why not just have one command that creates a new process and runs 
Dialogue: 0,1:09:07.04,1:09:09.08,csapp,,0,0,0,,and runs a program in that process why 
Dialogue: 0,1:09:09.74,1:09:15.04,csapp,,0,0,0,,why separate why have these these two separate fork and exec 
Dialogue: 0,1:09:19.32,1:09:24.98,csapp,,0,0,0,,I mean in fact Windows does this Windows has like one command that creates a process and executes 
Dialogue: 0,1:09:25.46,1:09:31.92,csapp,,0,0,0,,sit but it turns out that having having a separate function like fork 
Dialogue: 0,1:09:32.72,1:09:35.90,csapp,,0,0,0,,just to create processes is actually really useful
Dialogue: 0,1:09:36.46,1:09:40.16,csapp,,0,0,0,,I mean sometimes you just want to create replicas of your current process for example
Dialogue: 0,1:09:40.58,1:09:41.79,csapp,,0,0,0,, let's say you have a server 
Dialogue: 0,1:09:42.64,1:09:47.86,csapp,,0,0,0,,and you want to create a concurrent server you want to create multiple copies of that server then you just fork 
Dialogue: 0,1:09:48.76,1:09:53.92,csapp,,0,0,0,,a bunch you have the main the parent server can fork a bunch of of children 
Dialogue: 0,1:09:53.92,1:09:56.22,csapp,,0,0,0,,so that's useful they're just all running the same code
Dialogue: 0,1:09:56.84,1:09:59.72,csapp,,0,0,0,,but what's all what this also allows you to do 
Dialogue: 0,1:10:00.46,1:10:03.34,csapp,,0,0,0,,is it allows you to execute code in the child
Dialogue: 0,1:10:04.12,1:10:05.98,csapp,,0,0,0,, before you call x'q 
Dialogue: 0,1:10:07.02,1:10:12.20,csapp,,0,0,0,,so you may want to set some you may want to set some
Dialogue: 0,1:10:13.02,1:10:16.28,csapp,,0,0,0,, like some signal with is especially useful when you're dealing with
Dialogue: 0,1:10:16.96,1:10:21.86,csapp,,0,0,0,, with things like signals if you want to block certain signals or unblock certain signals 
Dialogue: 0,1:10:22.38,1:10:27.52,csapp,,0,0,0,,you can do it right here in this this gap between the fork and the exact
Dialogue: 0,1:10:32.94,1:10:38.96,csapp,,0,0,0,,okay so so that's it so just to summarize what we've we've talked about today
Dialogue: 0,1:10:39.86,1:10:50.04,csapp,,0,0,0,, exceptions are in response to events that require some kind of non-standard or exceptional call exceptional control flow
Dialogue: 0,1:10:50.84,1:10:56.66,csapp,,0,0,0,, they can be generated internally in the form of interrupts or internally in the form of traps and faults
Dialogue: 0,1:10:57.62,1:11:02.64,csapp,,0,0,0,, so it at any point in time a process has multiple a system as multiple processes 
Dialogue: 0,1:11:03.32,1:11:05.84,csapp,,0,0,0,,only one of which can execute on a single core 
Dialogue: 0,1:11:06.62,1:11:11.54,csapp,,0,0,0,,so the process execution is interleaved by the kernel
Dialogue: 0,1:11:13.10,1:11:19.50,csapp,,0,0,0,,and each process thinks that it has total total control of the processor in its address space
Dialogue: 0,1:11:21.88,1:11:24.96,csapp,,0,0,0,, there's only one mechanism to spawn processes that's fork
Dialogue: 0,1:11:25.92,1:11:27.80,csapp,,0,0,0,,and it's called once and returns twice
Dialogue: 0,1:11:29.80,1:11:35.12,csapp,,0,0,0,,we can terminate our process by calling X exit which is called once and never returns
Dialogue: 0,1:11:36.06,1:11:39.30,csapp,,0,0,0,, we reap and wait for processes using wait or wait pit 
Dialogue: 0,1:11:39.88,1:11:42.50,csapp,,0,0,0,,and we load and run programs using execve
Dialogue: 0,1:11:43.02,1:11:44.96,csapp,,0,0,0,,or one of its one of its variants 
Dialogue: 0,1:11:45.86,1:11:48.62,csapp,,0,0,0,,and this one is called once and and normally never returns
Dialogue: 0,1:11:50.00,1:11:52.92,csapp,,0,0,0,, okay so that's that's it for today and 
Dialogue: 0,1:11:53.88,1:11:58.28,csapp,,0,0,0,,we'll see you have a good weekend and we'll see you on Tuesday
