[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Audio File: ../../../Desktop/csapp/Lecture 20  Dynamic Memory Allocation  Advanced Concepts.mp4
Video File: ../../../Desktop/csapp/Lecture 20  Dynamic Memory Allocation  Advanced Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1081
Active Line: 1091
Video Position: 148516

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.38,csapp,,0,0,0,,Good afternoon everybody 
Dialogue: 0,0:00:02.44,0:00:03.74,csapp,,0,0,0,,welcome good to see you 
Dialogue: 0,0:00:03.86,0:00:07.52,csapp,,0,0,0,,and welcome to all those who are watching on videotape as well
Dialogue: 0,0:00:10.38,0:00:13.28,csapp,,0,0,0,, I want to clear up I realized after the last lecture 
Dialogue: 0,0:00:13.28,0:00:17.48,csapp,,0,0,0,,that I didn't explain the idea of peak memory utilization very well to you 
Dialogue: 0,0:00:17.50,0:00:23.66,csapp,,0,0,0,,so I want to just explain that it's an important idea and I want to make sure that  that we have it clear
Dialogue: 0,0:00:24.64,0:00:34.08,csapp,,0,0,0,,so if you recall  recall from  we have we're executing a series a sequence of requests 
Dialogue: 0,0:00:35.78,0:00:38.34,csapp,,0,0,0,,R0,R1,R2,
Dialogue: 0,0:00:40.70,0:00:46.16,csapp,,0,0,0,,RK up to our n-1 
Dialogue: 0,0:00:47.58,0:00:51.82,csapp,,0,0,0,,and at any point in time after K 1 k + 1 requests 
Dialogue: 0,0:00:54.56,0:00:57.16,csapp,,0,0,0,,we have HK 
Dialogue: 0,0:00:58.36,0:01:01.72,csapp,,0,0,0,,which is the the heap size 
Dialogue: 0,0:01:05.74,0:01:07.94,csapp,,0,0,0,,after k1 requests 
Dialogue: 0,0:01:17.88,0:01:20.86,csapp,,0,0,0,,now we have a PK which is the aggregate 
Dialogue: 0,0:01:27.78,0:01:30.00,csapp,,0,0,0,,the the sum of all of the payloads 
Dialogue: 0,0:01:32.06,0:01:33.72,csapp,,0,0,0,,after k + 1 requests 
Dialogue: 0,0:01:37.44,0:01:40.82,csapp,,0,0,0,,okay so what we're trying to do with this this PK measure
Dialogue: 0,0:01:41.36,0:01:44.56,csapp,,0,0,0,, this aggregate payload is at any point in time so 
Dialogue: 0,0:01:45.36,0:01:48.00,csapp,,0,0,0,,as we as we execute requests one after the other 
Dialogue: 0,0:01:49.40,0:01:51.40,csapp,,0,0,0,,the sum of all the payloads in the heap
Dialogue: 0,0:01:52.14,0:01:56.48,csapp,,0,0,0,, is going to either increase or decrease right so if we execute a an allocate 
Dialogue: 0,0:01:57.34,0:01:59.62,csapp,,0,0,0,,then the size of the payloads will increase 
Dialogue: 0,0:02:00.60,0:02:06.12,csapp,,0,0,0,,if we execute a free the size of all those  allocated payloads will decrease right so 
Dialogue: 0,0:02:06.82,0:02:09.62,csapp,,0,0,0,,so as we're executing this the sequence of requests these 
Dialogue: 0,0:02:10.28,0:02:14.90,csapp,,0,0,0,,the aggregate the sum of all the payloads is going to be increasing and decreasing 
Dialogue: 0,0:02:16.88,0:02:23.18,csapp,,0,0,0,,okay and so what were what we're capturing with the sum of all these payloads is like a perfect allocator that has no overheads 
Dialogue: 0,0:02:23.62,0:02:26.18,csapp,,0,0,0,,and and even more so one that we can 
Dialogue: 0,0:02:27.58,0:02:29.18,csapp,,0,0,0,,where we're allowed to compact blocks 
Dialogue: 0,0:02:29.52,0:02:34.92,csapp,,0,0,0,,so the sum of all of the the payloads is the minimum possible heap size 
Dialogue: 0,0:02:36.50,0:02:42.60,csapp,,0,0,0,,or it's the minimum possible number of bytes required by those allocated blocks 
Dialogue: 0,0:02:43.02,0:02:46.50,csapp,,0,0,0,,okay so it's very very aggressive and it's impossible to achieve 
Dialogue: 0,0:02:47.02,0:02:49.00,csapp,,0,0,0,,but we're going to use that as sort of our best case 
Dialogue: 0,0:02:49.44,0:02:49.86,csapp,,0,0,0,,okay 
Dialogue: 0,0:02:51.14,0:02:55.16,csapp,,0,0,0,,and so to measure a peak
Dialogue: 0,0:02:58.80,0:03:00.34,csapp,,0,0,0,,peak memory utilization 
Dialogue: 0,0:03:05.98,0:03:06.96,csapp,,0,0,0,,after 
Dialogue: 0,0:03:08.74,0:03:09.96,csapp,,0,0,0,,K+1 requests 
Dialogue: 0,0:03:12.44,0:03:13.84,csapp,,0,0,0,,which will denote U of K 
Dialogue: 0,0:03:15.58,0:03:17.46,csapp,,0,0,0,,that's going to be equal to 
Dialogue: 0,0:03:18.28,0:03:20.82,csapp,,0,0,0,,the the max
Dialogue: 0,0:03:24.56,0:03:26.80,csapp,,0,0,0,, for all I less than or equal to K 
Dialogue: 0,0:03:32.98,0:03:34.44,csapp,,0,0,0,,of our aggregate payloads 
Dialogue: 0,0:03:36.58,0:03:37.72,csapp,,0,0,0,,divided by 
Dialogue: 0,0:03:38.26,0:03:41.54,csapp,,0,0,0,,the size of the heap after after k+1 requests 
Dialogue: 0,0:03:42.76,0:03:45.18,csapp,,0,0,0,,okay so what what we're doing with this max is
Dialogue: 0,0:03:46.50,0:03:48.38,csapp,,0,0,0,, we're remembering the high-water mark 
Dialogue: 0,0:03:49.36,0:03:51.90,csapp,,0,0,0,, you know as our as our aggregate payloads 
Dialogue: 0,0:03:52.78,0:03:55.72,csapp,,0,0,0,,increase and decrease we're remembering the high-water mark
Dialogue: 0,0:03:56.16,0:04:00.72,csapp,,0,0,0,,right so that was sort of the worst that was like the biggest set of payloads that we had 
Dialogue: 0,0:04:01.42,0:04:07.66,csapp,,0,0,0,,and then so the max is remembering his room is remembering that high-water mark 
Dialogue: 0,0:04:08.24,0:04:13.00,csapp,,0,0,0,,and then we're dividing by the total size of the heap in order to get an efficiency measure 
Dialogue: 0,0:04:13.50,0:04:15.30,csapp,,0,0,0,,okay so so this max 
Dialogue: 0,0:04:16.84,0:04:23.30,csapp,,0,0,0,,PK is kind of this is the best we could have done divided by the total the total heap size 
Dialogue: 0,0:04:23.72,0:04:25.08,csapp,,0,0,0,,okay so yes 
Dialogue: 0,0:04:25.08,0:04:29.82,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:04:31.12,0:04:34.56,csapp,,0,0,0,,well that the allocator keeps track of of how big the heap
Dialogue: 0,0:04:35.92,0:04:36.96,csapp,,0,0,0,, is so that's pretty easy right 
Dialogue: 0,0:04:36.96,0:04:41.60,csapp,,0,0,0,,so as every time it every time it does every time it calls s break
Dialogue: 0,0:04:41.60,0:04:44.96,csapp,,0,0,0,,it just that that adds to the size of the heap and remember we're 
Dialogue: 0,0:04:45.50,0:04:51.54,csapp,,0,0,0,, we're assuming that the heap in this case is always increasing okay so 
Dialogue: 0,0:04:52.98,0:04:55.36,csapp,,0,0,0,,but even if even if we allow the heap size to decrease 
Dialogue: 0,0:04:55.82,0:05:01.50,csapp,,0,0,0,,could just if the allocator is controlling the size of the heap by calls to s break 
Dialogue: 0,0:05:03.38,0:05:04.44,csapp,,0,0,0,,okay so is that clear
Dialogue: 0,0:05:05.92,0:05:08.08,csapp,,0,0,0,,so for UK the higher the better
Dialogue: 0,0:05:10.16,0:05:14.12,csapp,,0,0,0,, okay and for any sequence of allocates and freeze
Dialogue: 0,0:05:14.66,0:05:16.78,csapp,,0,0,0,,this max PK will be the same
Dialogue: 0,0:05:17.28,0:05:18.68,csapp,,0,0,0,,okay that's constant right 
Dialogue: 0,0:05:20.02,0:05:27.24,csapp,,0,0,0,,but what what varies is H of K and that depends on how efficient your  your allocator is is using the heap storage 
Dialogue: 0,0:05:28.36,0:05:29.50,csapp,,0,0,0,,okay yes question
Dialogue: 0,0:05:29.50,0:05:34.52,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:05:34.52,0:05:37.56,csapp,,0,0,0,,so what we're doing is at any point in time 
Dialogue: 0,0:05:38.82,0:05:41.04,csapp,,0,0,0,,after we're after K +1 requests
Dialogue: 0,0:05:41.76,0:05:46.80,csapp,,0,0,0,,we're about we're evaluating the utilization of our heap up till that point so it should be K
Dialogue: 0,0:05:46.80,0:05:52.16,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:05:52.16,0:05:54.32,csapp,,0,0,0,,for I I less than or equal to K 
Dialogue: 0,0:05:57.48,0:05:58.38,csapp,,0,0,0,,oh I'm sorry
Dialogue: 0,0:06:10.86,0:06:19.56,csapp,,0,0,0,,yeah sorry good good catch so that should be an eye right we want to look at all the  all the for all the requests that came before 
Dialogue: 0,0:06:23.06,0:06:24.00,csapp,,0,0,0,,okay any other questions 
Dialogue: 0,0:06:36.06,0:06:41.64,csapp,,0,0,0,,okay all right so last time we looked at some simple the basics of dynamic storage allocation 
Dialogue: 0,0:06:42.18,0:06:45.86,csapp,,0,0,0,,today we're going to look at some more sophisticated techniques using 
Dialogue: 0,0:06:47.54,0:06:50.64,csapp,,0,0,0,,different data structures to store the free list primarily 
Dialogue: 0,0:06:52.62,0:06:54.72,csapp,,0,0,0,,we'll look at implicit allocators 
Dialogue: 0,0:06:54.82,0:06:59.00,csapp,,0,0,0,,so we'll get a sort of a brief survey of how garbage collectors work 
Dialogue: 0,0:06:59.02,0:07:03.58,csapp,,0,0,0,,and we'll just look at one just just one very simple kind of garbage collector 
Dialogue: 0,0:07:03.58,0:07:06.84,csapp,,0,0,0,,but it will give you an idea of of what that means 
Dialogue: 0,0:07:07.46,0:07:08.44,csapp,,0,0,0,,and then we'll finish up 
Dialogue: 0,0:07:10.42,0:07:13.78,csapp,,0,0,0,,we'll finish up by looking at all the ways you can get yourself into trouble 
Dialogue: 0,0:07:15.00,0:07:16.96,csapp,,0,0,0,,by using dynamically allocated storage 
Dialogue: 0,0:07:17.04,0:07:21.60,csapp,,0,0,0,,so once once you once you use once you start dynamically allocating storage
Dialogue: 0,0:07:22.10,0:07:24.84,csapp,,0,0,0,, things can go really bad really quickly 
Dialogue: 0,0:07:25.02,0:07:29.60,csapp,,0,0,0,,and so we'll go over some of those some of those bad things that can happen and
Dialogue: 0,0:07:30.42,0:07:33.60,csapp,,0,0,0,, try to alert you to those so you don't do them in your programs
Dialogue: 0,0:07:44.60,0:07:52.92,csapp,,0,0,0,,okay so we looked at how to store a free lip free list in this sort of implicit form by just  walking the entire heat 
Dialogue: 0,0:07:53.58,0:07:56.84,csapp,,0,0,0,,and and thereby sort of being able to visit all the free blocks 
Dialogue: 0,0:07:57.30,0:07:58.62,csapp,,0,0,0,,but we can do better
Dialogue: 0,0:07:59.08,0:08:05.18,csapp,,0,0,0,,if we actually have a EE if we store the free block the free list is using as a doubly linked list  
Dialogue: 0,0:08:07.76,0:08:10.16,csapp,,0,0,0,,so in we call these explicit free lists 
Dialogue: 0,0:08:11.02,0:08:13.86,csapp,,0,0,0,,so the idea with an explicit free list is that 
Dialogue: 0,0:08:15.38,0:08:16.50,csapp,,0,0,0,,we put pointers 
Dialogue: 0,0:08:18.24,0:08:21.52,csapp,,0,0,0,,we put the pointers that implement the the doubly linked list
Dialogue: 0,0:08:22.20,0:08:25.38,csapp,,0,0,0,,inside the the body of the of a free block 
Dialogue: 0,0:08:25.64,0:08:28.04,csapp,,0,0,0,,say where the old payload used to go so 
Dialogue: 0,0:08:28.58,0:08:31.94,csapp,,0,0,0,,allocated blocks look exactly the same as they did before right 
Dialogue: 0,0:08:31.94,0:08:35.36,csapp,,0,0,0,,there's a header boundary tag optional boundary tag footer
Dialogue: 0,0:08:35.92,0:08:38.14,csapp,,0,0,0,, and then this the payload and any padding 
Dialogue: 0,0:08:39.70,0:08:47.20,csapp,,0,0,0,,free blocks though the allocator and the allocator is not allowed to touch anything in the inside the 
Dialogue: 0,0:08:47.60,0:08:50.56,csapp,,0,0,0,, the the payload of an allocated block 
Dialogue: 0,0:08:50.94,0:08:53.20,csapp,,0,0,0,,but free blocks are free right nobody's using them 
Dialogue: 0,0:08:53.62,0:08:55.84,csapp,,0,0,0,,and so we the allocator can put the 
Dialogue: 0,0:08:57.42,0:09:02.14,csapp,,0,0,0,,the pointers that implement the data structure inside the what was the old payload 
Dialogue: 0,0:09:04.12,0:09:09.48,csapp,,0,0,0,,so logically this is just a simple doubly linked list okay that you've all seen before 
Dialogue: 0,0:09:11.02,0:09:15.62,csapp,,0,0,0,,but actually these things can be anywhere in memory right 
Dialogue: 0,0:09:15.62,0:09:17.60,csapp,,0,0,0,,and so you know here we have 
Dialogue: 0,0:09:18.82,0:09:21.16,csapp,,0,0,0,,we have a block of size six 
Dialogue: 0,0:09:22.00,0:09:25.54,csapp,,0,0,0,,and it has a four word pointer that points to some other link 
Dialogue: 0,0:09:26.00,0:09:28.24,csapp,,0,0,0,,and it has a backwards pointer that points to 
Dialogue: 0,0:09:28.64,0:09:33.12,csapp,,0,0,0,,this block which happens to be have a greater memory address than  then it 
Dialogue: 0,0:09:34.92,0:09:37.38,csapp,,0,0,0,,okay so just the idea is you can't 
Dialogue: 0,0:09:38.34,0:09:42.22,csapp,,0,0,0,,you know unless unless you make unless you go to great pains to maintain 
Dialogue: 0,0:09:42.72,0:09:45.64,csapp,,0,0,0,, this sort of address ordered structure 
Dialogue: 0,0:09:47.32,0:09:51.68,csapp,,0,0,0,,these these these blocks can be sort of scattered anywhere in memory
Dialogue: 0,0:09:51.78,0:09:57.10,csapp,,0,0,0,,several times on that long 
Dialogue: 0,0:09:57.12,0:09:59.12,csapp,,0,0,0,,oh yeah so this is after several 
Dialogue: 0,0:09:59.78,0:10:03.98,csapp,,0,0,0,,you know just sort of indefinite number of Malik's and fries and 
Dialogue: 0,0:10:04.84,0:10:05.42,csapp,,0,0,0,,yes 
Dialogue: 0,0:10:05.42,0:10:09.64,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:10:09.64,0:10:10.82,csapp,,0,0,0,,oh yeah good question it's like
Dialogue: 0,0:10:11.32,0:10:15.90,csapp,,0,0,0,, so the question is what would happen if you free to a block that was in between two free blocks 
Dialogue: 0,0:10:16.62,0:10:20.62,csapp,,0,0,0,,and so you have to coalesce it gets a little tricky and I'll show you in a second 
Dialogue: 0,0:10:21.30,0:10:25.04,csapp,,0,0,0,,good now allocating oh yes questions
Dialogue: 0,0:10:25.04,0:10:31.62,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:10:31.66,0:10:33.68,csapp,,0,0,0,,so the question is what happens with locality 
Dialogue: 0,0:10:34.38,0:10:37.50,csapp,,0,0,0,,so you still get you still get block locality
Dialogue: 0,0:10:38.70,0:10:40.42,csapp,,0,0,0,, you know use blocks are still contiguous 
Dialogue: 0,0:10:41.42,0:10:41.90,csapp,,0,0,0,,so if 
Dialogue: 0,0:10:43.26,0:10:50.82,csapp,,0,0,0,,but if if you're scanning sort of a set of allocated blocks it would be better 
Dialogue: 0,0:10:50.82,0:10:54.40,csapp,,0,0,0,,if you could keep them all contiguous right that so that's really 
Dialogue: 0,0:10:55.38,0:11:00.14,csapp,,0,0,0,,and so there's a you know that's a trade-off I don't 
Dialogue: 0,0:11:03.06,0:11:05.66,csapp,,0,0,0,,it gets difficult if you think how can you maintain 
Dialogue: 0,0:11:05.66,0:11:10.12,csapp,,0,0,0,,so you don't really care about the locality of free blocks right you're just walking a linked list 
Dialogue: 0,0:11:12.56,0:11:14.34,csapp,,0,0,0,,well no I shouldn't say that that's 
Dialogue: 0,0:11:14.46,0:11:18.16,csapp,,0,0,0,,if you're walking that list if you hit one one free block 
Dialogue: 0,0:11:18.72,0:11:22.26,csapp,,0,0,0,,it would it would bring in a whole page so it'd be better
Dialogue: 0,0:11:22.94,0:11:27.96,csapp,,0,0,0,, if you were walking if the list you know if as much of that list was contained within that page 
Dialogue: 0,0:11:27.96,0:11:30.48,csapp,,0,0,0,,so even that's so you would benefit
Dialogue: 0,0:11:31.44,0:11:38.08,csapp,,0,0,0,,you could benefit eat with both allocated blocks because applications would be using them  and with free blocks
Dialogue: 0,0:11:38.08,0:11:41.32,csapp,,0,0,0,,because the allocator would be walking that that free list 
Dialogue: 0,0:11:42.44,0:11:42.90,csapp,,0,0,0,,so question so even
Dialogue: 0,0:11:42.94,0:12:08.90,csapp,,0,0,0,,though say you only need even though say you're like alkane interest constructor if you know the feature can allocate a thousand of them somehow let me out the other day you're going to try to help you knowledge it didn't work
Dialogue: 0,0:12:08.90,0:12:09.84,csapp,,0,0,0,, that's a really good question 
Dialogue: 0,0:12:09.84,0:12:15.38,csapp,,0,0,0,,so the question is could would it be possible for an application to  sort of give hints to the allocator
Dialogue: 0,0:12:15.80,0:12:20.18,csapp,,0,0,0,, that would increase that improve the allocators performance or memory utilization
Dialogue: 0,0:12:21.70,0:12:23.94,csapp,,0,0,0,, the the answer you absolutely could
Dialogue: 0,0:12:25.98,0:12:29.46,csapp,,0,0,0,, but it's if you did it wouldn't be a general-purpose allocator
Dialogue: 0,0:12:29.52,0:12:32.12,csapp,,0,0,0,,so like malloc is a general-purpose allocator 
Dialogue: 0,0:12:32.80,0:12:35.44,csapp,,0,0,0,,so it and it provides no there's no option
Dialogue: 0,0:12:35.44,0:12:39.00,csapp,,0,0,0,, it doesn't provide any arguments in its interface for passing that information in 
Dialogue: 0,0:12:39.46,0:12:45.54,csapp,,0,0,0,,but it absolutely if it had some knowledge about the future behavior of a program that could benefit
Dialogue: 0,0:12:45.72,0:12:50.46,csapp,,0,0,0,,right so especially I consider you always have this decision when you place an allocated block 
Dialogue: 0,0:12:50.80,0:12:52.24,csapp,,0,0,0,,whether to split that block or not 
Dialogue: 0,0:12:53.44,0:12:55.42,csapp,,0,0,0,,well if you knew that you were going to get a request 
Dialogue: 0,0:12:57.04,0:13:00.95,csapp,,0,0,0,,you know for if you split that block and and you knew that you were going to get requests
Dialogue: 0,0:13:01.44,0:13:05.56,csapp,,0,0,0,,coming in the future first for sizes of the original block then you wouldn't want to split it 
Dialogue: 0,0:13:06.20,0:13:10.24,csapp,,0,0,0,,because then you would want it you would just keep it unsplit and then 
Dialogue: 0,0:13:11.70,0:13:15.76,csapp,,0,0,0,,when you freed it then you'd have a block that would be the right size for that that future request 
Dialogue: 0,0:13:16.46,0:13:20.54,csapp,,0,0,0,,and so it's you can absolutely benefit from that 
Dialogue: 0,0:13:21.14,0:13:26.42,csapp,,0,0,0,,and so although you can't if general-purpose allocators there's no provision for that kind of hinting 
Dialogue: 0,0:13:26.72,0:13:32.14,csapp,,0,0,0,,but there's nothing to prevent an alligator from doing predictions based on the the previous pattern of requests 
Dialogue: 0,0:13:33.62,0:13:38.08,csapp,,0,0,0,,you know so if you're getting a pattern of requests it's alternating large block small block large box small block 
Dialogue: 0,0:13:38.12,0:13:44.14,csapp,,0,0,0,,you could you could exploit that maybe maybe predict that the next request will be for a you know if it 
Dialogue: 0,0:13:44.76,0:13:49.22,csapp,,0,0,0,,if the previous request is for a large block the next one might be for a small block and you could
Dialogue: 0,0:13:51.20,0:13:54.12,csapp,,0,0,0,,that's good question any any other questions wizard yes
Dialogue: 0,0:14:06.74,0:14:07.60,csapp,,0,0,0,, I don't know I 
Dialogue: 0,0:14:07.90,0:14:12.00,csapp,,0,0,0,,so the question is are there are there intelligent alligators that do that kind of prediction
Dialogue: 0,0:14:12.42,0:14:16.62,csapp,,0,0,0,, and if there are I don't know of them but I wouldn't I wouldn't say no 
Dialogue: 0,0:14:20.30,0:14:20.82,csapp,,0,0,0,,yes 
Dialogue: 0,0:14:20.82,0:14:39.14,csapp,,0,0,0,,what would happen you end up with a free buckets of block just like just a single block 
Dialogue: 0,0:14:39.14,0:14:43.76,csapp,,0,0,0,,oh well so the question is what if you ended up with a free block
Dialogue: 0,0:14:44.22,0:14:47.40,csapp,,0,0,0,, that's a single block  by two allocated blocks 
Dialogue: 0,0:14:48.06,0:14:53.32,csapp,,0,0,0,,well in fact I mean that's one of the invariants that a good alligator has to maintain 
Dialogue: 0,0:14:53.78,0:14:56.02,csapp,,0,0,0,,you should never have two contiguous free blocks 
Dialogue: 0,0:14:56.78,0:15:00.38,csapp,,0,0,0,,right the alligator should always be coalescing as much as it can 
Dialogue: 0,0:15:00.90,0:15:02.98,csapp,,0,0,0,,and if it if it does that coalescing
Dialogue: 0,0:15:03.34,0:15:09.68,csapp,,0,0,0,, if it if it always does that coalescing then then there will never be two contiguous free blocks okay
Dialogue: 0,0:15:11.64,0:15:12.38,csapp,,0,0,0,,yeah it's question 
Dialogue: 0,0:15:12.38,0:15:18.08,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:15:18.08,0:15:22.32,csapp,,0,0,0,,oh you'll see when we it comes into play when we free a block
Dialogue: 0,0:15:23.36,0:15:25.22,csapp,,0,0,0,,because you have to sort of stitch up
Dialogue: 0,0:15:25.56,0:15:31.86,csapp,,0,0,0,,when you free a block you have to sort of stitch up the the linked list and 
Dialogue: 0,0:15:31.86,0:15:33.84,csapp,,0,0,0,,so you need both you need both pointers 
Dialogue: 0,0:15:34.60,0:15:36.42,csapp,,0,0,0,,you can do it with singly linked lists
Dialogue: 0,0:15:36.44,0:15:42.16,csapp,,0,0,0,, so in your in the K in our book there's a an alligator that uses a singly linked list
Dialogue: 0,0:15:42.80,0:15:45.82,csapp,,0,0,0,,but the the disadvantages that free requires a search 
Dialogue: 0,0:15:46.16,0:15:50.90,csapp,,0,0,0,,so it requires a search from the beginning of the list to find the previous block 
Dialogue: 0,0:15:55.34,0:15:56.98,csapp,,0,0,0,,and there are questions these are good yes question 
Dialogue: 0,0:15:57.04,0:16:05.86,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:16:05.88,0:16:07.68,csapp,,0,0,0,,okay so the question is for memory utilization 
Dialogue: 0,0:16:07.68,0:16:11.68,csapp,,0,0,0,,how does the header and footer count towards memory utilization 
Dialogue: 0,0:16:12.96,0:16:17.26,csapp,,0,0,0,,and so those those are overhead  that decrease memory utilization 
Dialogue: 0,0:16:17.96,0:16:21.06,csapp,,0,0,0,, okay because they're not payload so when we were computing memory utilization
Dialogue: 0,0:16:21.74,0:16:26.72,csapp,,0,0,0,, we're doing it by we're using the payload the aggregate payload to 
Dialogue: 0,0:16:27.84,0:16:33.20,csapp,,0,0,0,,to to estimate our utilization or to compute our utilization 
Dialogue: 0,0:16:33.56,0:16:37.54,csapp,,0,0,0,,so anything that's not payload sorry is is overhead 
Dialogue: 0,0:16:37.54,0:16:47.60,csapp,,0,0,0,,
Dialogue: 0,0:16:47.66,0:16:51.38,csapp,,0,0,0,,okay was also one word so we had if all of our payloads were one word and our overhead 
Dialogue: 0,0:16:51.88,0:16:54.76,csapp,,0,0,0,,was was one word then there'd be 50%
Dialogue: 0,0:16:59.30,0:17:09.10,csapp,,0,0,0,,yes if you have the book this pointer to the next and previously block you still
Dialogue: 0,0:17:09.10,0:17:11.76,csapp,,0,0,0,, need yeah so the question is do you still need a boundary tag if you have
Dialogue: 0,0:17:12.34,0:17:17.24,csapp,,0,0,0,,these these next and previous pointers and the answer is yes absolutely 
Dialogue: 0,0:17:17.34,0:17:18.90,csapp,,0,0,0,,and you'll see in a second why 
Dialogue: 0,0:17:21.06,0:17:21.62,csapp,,0,0,0,,yes 
Dialogue: 0,0:17:32.60,0:17:33.94,csapp,,0,0,0,,okay that's a really good question 
Dialogue: 0,0:17:33.94,0:17:37.86,csapp,,0,0,0,,so you know what do you do if you have next in previous pointers 
Dialogue: 0,0:17:38.50,0:17:43.20,csapp,,0,0,0,,what happened what happens if there's a request for a smaller a smaller block 
Dialogue: 0,0:17:43.88,0:17:48.78,csapp,,0,0,0,,so the answer is that all of those things the the header the footer the next and previous pointers 
Dialogue: 0,0:17:49.08,0:17:50.58,csapp,,0,0,0,,impose a minimum block size 
Dialogue: 0,0:17:51.65,0:17:58.74,csapp,,0,0,0,,so if you have a one word header one word footer one word pre even one word next
Dialogue: 0,0:17:59.68,0:18:02.62,csapp,,0,0,0,, then your your minimum block sizes is four bytes 
Dialogue: 0,0:18:02.86,0:18:05.60,csapp,,0,0,0,,and that would be with a zero a zero size payload 
Dialogue: 0,0:18:06.64,0:18:10.60,csapp,,0,0,0,, so you can never allocate a block smaller  than your minimum block size
Dialogue: 0,0:18:10.88,0:18:13.04,csapp,,0,0,0,, so that's very good very good question 
Dialogue: 0,0:18:14.42,0:18:16.62,csapp,,0,0,0,, so it makes a difference right even though 
Dialogue: 0,0:18:18.48,0:18:20.82,csapp,,0,0,0,,even though we're you know it looks like we're getting these
Dialogue: 0,0:18:22.02,0:18:24.28,csapp,,0,0,0,, it looks like we're getting these pointers here for free 
Dialogue: 0,0:18:25.22,0:18:29.08,csapp,,0,0,0,, but we're not really because of this minimum block size  requirement 
Dialogue: 0,0:18:29.22,0:18:29.68,csapp,,0,0,0,,yes
Dialogue: 0,0:18:29.68,0:18:34.10,csapp,,0,0,0,, their weight of course to allocate a
Dialogue: 0,0:18:34.14,0:18:39.48,csapp,,0,0,0,,gigantic block and export Malecha give you specifically parts of that
Dialogue: 0,0:18:39.70,0:18:44.16,csapp,,0,0,0,, so say c1 CY allocate 100 trucks 
Dialogue: 0,0:18:44.50,0:18:50.52,csapp,,0,0,0,,can you allocate the side 120 today you just work against one space to let you use it right
Dialogue: 0,0:18:50.60,0:18:56.56,csapp,,0,0,0,, but if you wanted to like take the first half make them take second have taken integers or something 
Dialogue: 0,0:18:57.04,0:19:00.66,csapp,,0,0,0,,and 50 say all the stuff might program ridiculous 
Dialogue: 0,0:19:01.86,0:19:08.42,csapp,,0,0,0,,it's like here explicitly asking for that one gigantic block 
Dialogue: 0,0:19:08.84,0:19:10.02,csapp,,0,0,0,,yeah okay so
Dialogue: 0,0:19:12.68,0:19:16.40,csapp,,0,0,0,, the question is can you just get a get one large block and then split it up
Dialogue: 0,0:19:16.66,0:19:21.60,csapp,,0,0,0,, and I guess you're assuming that the request would be four equally sized objects right so
Dialogue: 0,0:19:22.86,0:19:25.02,csapp,,0,0,0,,this and and that's a really good strategy actually 
Dialogue: 0,0:19:25.32,0:19:31.70,csapp,,0,0,0,,so if you if you know or if you think that your workload is going to have 
Dialogue: 0,0:19:31.86,0:19:34.08,csapp,,0,0,0,,no you can't do this in general-purpose allocators  
Dialogue: 0,0:19:34.08,0:19:36.02,csapp,,0,0,0,,but for like a special-purpose allocator 
Dialogue: 0,0:19:36.02,0:19:39.44,csapp,,0,0,0,,if you know that you're going to be asking for objects that are all the same size 
Dialogue: 0,0:19:39.82,0:19:44.20,csapp,,0,0,0,,like compilers for example may maintain abstract syntax trees 
Dialogue: 0,0:19:44.60,0:19:48.30,csapp,,0,0,0,,and and they're allocating nodes dynamically and those nodes are the same size
Dialogue: 0,0:19:49.08,0:19:53.94,csapp,,0,0,0,, so if you can you can exploit that by just allocating a large chunk 
Dialogue: 0,0:19:55.52,0:19:58.60,csapp,,0,0,0,,and then allocating all the objects of that size out of that chunk
Dialogue: 0,0:19:59.22,0:20:03.30,csapp,,0,0,0,, it's very efficient you don't even need pointers or anything all you need is a bit vector 
Dialogue: 0,0:20:03.78,0:20:06.94,csapp,,0,0,0,,to tell you which chunks are allocated in which chunks are free
Dialogue: 0,0:20:07.40,0:20:10.22,csapp,,0,0,0,,and then and you also has a side effect you'll get that contiguous 
Dialogue: 0,0:20:11.54,0:20:15.56,csapp,,0,0,0,,that contiguous access so if a program access those those objects like 
Dialogue: 0,0:20:17.28,0:20:20.98,csapp,,0,0,0,,to be part of a linked list there was something that it was going to traverse
Dialogue: 0,0:20:21.46,0:20:26.84,csapp,,0,0,0,, you could allocate those in order and contiguously 
Dialogue: 0,0:20:27.64,0:20:31.40,csapp,,0,0,0,, now with with a general-purpose allocator where you don't really know
Dialogue: 0,0:20:31.76,0:20:33.54,csapp,,0,0,0,, what's going to be requested that
Dialogue: 0,0:20:34.76,0:20:42.06,csapp,,0,0,0,, it's probably going to allocate also a vector-based 
Dialogue: 0,0:20:42.38,0:20:46.96,csapp,,0,0,0,,absolutely you could do that you can make general assumptions about the  sort of behavior of your programs 
Dialogue: 0,0:20:46.96,0:20:52.74,csapp,,0,0,0,,and you know you could you could run traces or like in the case of malok lab you could look at the traces
Dialogue: 0,0:20:54.26,0:20:56.44,csapp,,0,0,0,,but that's no that's a really good thing you know you can't 
Dialogue: 0,0:20:57.42,0:21:02.36,csapp,,0,0,0,,you're you can't just like do if statements to say well 
Dialogue: 0,0:21:02.36,0:21:06.70,csapp,,0,0,0,,if the size is 42 and then the next size is 24 then I know it's this trace 
Dialogue: 0,0:21:08.02,0:21:11.00,csapp,,0,0,0,,but you can look at a trace and say whom there's an interesting pattern here
Dialogue: 0,0:21:11.78,0:21:15.90,csapp,,0,0,0,, I'm going to account for that pattern I'm going to optimize for that pattern 
Dialogue: 0,0:21:16.02,0:21:20.02,csapp,,0,0,0,,and that that would just and that's perfectly valid that's just like taking advantage of
Dialogue: 0,0:21:20.30,0:21:22.98,csapp,,0,0,0,,your workload right that's what we do in systems all the time
Dialogue: 0,0:21:23.78,0:21:24.22,csapp,,0,0,0,, yes
Dialogue: 0,0:21:26.42,0:21:43.22,csapp,,0,0,0,,but can we divided up in and at the end of the first part
Dialogue: 0,0:21:43.34,0:21:45.50,csapp,,0,0,0,,Oh Oh so the question is why can't we
Dialogue: 0,0:21:46.26,0:21:51.22,csapp,,0,0,0,,why can't we sort of have separate areas of the heap for the pointers  and the payloads all right
Dialogue: 0,0:21:51.98,0:22:00.86,csapp,,0,0,0,, join them up with pointers 
Dialogue: 0,0:22:00.86,0:22:04.90,csapp,,0,0,0,,oh why not okay so the question is why not why can't we split up payloads 
Dialogue: 0,0:22:06.18,0:22:08.00,csapp,,0,0,0,, and link them together with pointers 
Dialogue: 0,0:22:09.00,0:22:12.64,csapp,,0,0,0,,the answer is that the applications expecting a contiguous block 
Dialogue: 0,0:22:13.18,0:22:16.40,csapp,,0,0,0,,you can't allocate or can't put anything in the payload 
Dialogue: 0,0:22:17.20,0:22:23.60,csapp,,0,0,0,,right it all I can do all it's allowed to do is return a contiguous block of the size of the application requested 
Dialogue: 0,0:22:24.36,0:22:27.55,csapp,,0,0,0,,and app once it does that it can't touch it okay
Dialogue: 0,0:22:28.48,0:22:29.58,csapp,,0,0,0,,all right good good 
Dialogue: 0,0:22:32.86,0:22:35.28,csapp,,0,0,0,,all right so let's look at how we'd allocate and free 
Dialogue: 0,0:22:35.48,0:22:41.02,csapp,,0,0,0,,once if we have this this explicit list how we would allocate and free blocks 
Dialogue: 0,0:22:41.64,0:22:43.96,csapp,,0,0,0,,so allocating is pretty simple 
Dialogue: 0,0:22:45.44,0:22:49.64,csapp,,0,0,0,,we'll have so here's our sort of a graphic of our free list 
Dialogue: 0,0:22:50.62,0:22:54.02,csapp,,0,0,0,,so we have four word pointers and backward pointers 
Dialogue: 0,0:22:54.92,0:22:58.06,csapp,,0,0,0,,and the idea is we want to allocate out of this middle block 
Dialogue: 0,0:23:01.06,0:23:01.76,csapp,,0,0,0,,so 
Dialogue: 0,0:23:03.20,0:23:05.84,csapp,,0,0,0,,we allocate the block of the size that we need 
Dialogue: 0,0:23:08.38,0:23:12.76,csapp,,0,0,0,,and then we just update the forward and back pointers of the the previous and next blocks 
Dialogue: 0,0:23:14.72,0:23:16.28,csapp,,0,0,0,,to point to this new free block 
Dialogue: 0,0:23:18.62,0:23:25.18,csapp,,0,0,0,,okay so that's pretty simple we're just we're updating one two three four five six six pointers
Dialogue: 0,0:23:29.38,0:23:32.80,csapp,,0,0,0,,okay now it gets it gets trickier when we have to free because 
Dialogue: 0,0:23:33.72,0:23:35.30,csapp,,0,0,0,,because we require coalescing 
Dialogue: 0,0:23:37.28,0:23:38.40,csapp,,0,0,0,,so when you free a block 
Dialogue: 0,0:23:39.10,0:23:41.04,csapp,,0,0,0,,that's that was previously allocated
Dialogue: 0,0:23:41.80,0:23:45.24,csapp,,0,0,0,, the question is what do you do with that free block right it wasn't in the free list 
Dialogue: 0,0:23:45.76,0:23:47.12,csapp,,0,0,0,,because it was an allocated block 
Dialogue: 0,0:23:48.12,0:23:50.10,csapp,,0,0,0,,so now that you've freed the block where do you put it
Dialogue: 0,0:23:50.78,0:23:51.98,csapp,,0,0,0,, which you've got to put it somewhere 
Dialogue: 0,0:23:52.94,0:23:56.00,csapp,,0,0,0,,so that the simplest thing is is this LIFO policy
Dialogue: 0,0:23:56.18,0:23:59.42,csapp,,0,0,0,, so the simplest thing is just put it at the beginning of the list 
Dialogue: 0,0:24:00.30,0:24:04.20,csapp,,0,0,0,,so the last block freed is the the first block allocated if it did fit fits 
Dialogue: 0,0:24:04.86,0:24:06.24,csapp,,0,0,0,,okay so that's so-called LIFO 
Dialogue: 0,0:24:07.72,0:24:10.14,csapp,,0,0,0,,now this is simple
Dialogue: 0,0:24:10.14,0:24:13.46,csapp,,0,0,0,,because you're always doing the same thing you're just putting the block at the beginning the list 
Dialogue: 0,0:24:14.14,0:24:17.06,csapp,,0,0,0,,and it's constant time you're just updating a few pointers
Dialogue: 0,0:24:18.46,0:24:25.38,csapp,,0,0,0,,okay but the studies suggest that the the fragmentation can be worse than the alternative technique 
Dialogue: 0,0:24:26.00,0:24:28.56,csapp,,0,0,0,,which is to keep the blocks ordered by address 
Dialogue: 0,0:24:29.66,0:24:36.76,csapp,,0,0,0,,okay so why not if you if you if you choose this address ordered policy when you when you free an allocated block 
Dialogue: 0,0:24:38.60,0:24:42.92,csapp,,0,0,0,,you're going to somehow figure out you're going to somehow place that block in the list 
Dialogue: 0,0:24:43.98,0:24:46.58,csapp,,0,0,0,,so that the previous block begins at a smaller address 
Dialogue: 0,0:24:46.78,0:24:48.84,csapp,,0,0,0,,and the next block begins at a larger address 
Dialogue: 0,0:24:49.98,0:24:52.20,csapp,,0,0,0,,right so this generally involves some kind of search
Dialogue: 0,0:24:52.48,0:24:55.62,csapp,,0,0,0,,right you don't you're just given this allocated block 
Dialogue: 0,0:24:56.32,0:24:58.38,csapp,,0,0,0,,and then somehow you've got and you know it's address 
Dialogue: 0,0:24:58.64,0:25:01.50,csapp,,0,0,0,,and so now you've got to somehow search the the free list 
Dialogue: 0,0:25:02.16,0:25:05.70,csapp,,0,0,0,,to find the you know the proper place to insert it 
Dialogue: 0,0:25:06.60,0:25:08.84,csapp,,0,0,0,,now I suppose you could do better if you had some kind of 
Dialogue: 0,0:25:09.40,0:25:14.22,csapp,,0,0,0,,so if you could speed up that search with some kind of  balance tree that would be one option
Dialogue: 0,0:25:15.00,0:25:19.94,csapp,,0,0,0,, right but then that the the problem we always run into with balance trees and 
Dialogue: 0,0:25:20.30,0:25:26.96,csapp,,0,0,0,,usually one student at lis somebody always tries to implement malloc with some kind of balance tree red-black tree or something
Dialogue: 0,0:25:27.60,0:25:29.90,csapp,,0,0,0,, and it seems like a really good idea 
Dialogue: 0,0:25:30.64,0:25:39.06,csapp,,0,0,0,,but you have to realize that you're you're competing with with other techniques  specifically segregated lists
Dialogue: 0,0:25:39.74,0:25:43.52,csapp,,0,0,0,, that are very fast they have very small constant factors
Dialogue: 0,0:25:44.16,0:25:47.78,csapp,,0,0,0,, and there's even though even though ordered lists are I think 
Dialogue: 0,0:25:48.52,0:25:54.00,csapp,,0,0,0,,it's usually nlog(n) to update an order tree a binary ordered tree 
Dialogue: 0,0:25:54.46,0:25:56.84,csapp,,0,0,0,,the constant factors can be can be quite large 
Dialogue: 0,0:25:56.84,0:26:01.46,csapp,,0,0,0,,and so usually get nailed up with the constant factors of maintaining the tree 
Dialogue: 0,0:26:03.08,0:26:06.54,csapp,,0,0,0,,and you don't get help that the search time is log(n) 
Dialogue: 0,0:26:07.06,0:26:08.82,csapp,,0,0,0,,but as we'll see with segregated lists
Dialogue: 0,0:26:10.76,0:26:17.32,csapp,,0,0,0,, in the in the limit has it in the limit as the number of different size classes increases 
Dialogue: 0,0:26:17.80,0:26:20.16,csapp,,0,0,0,,the the search time approaches constant time
Dialogue: 0,0:26:20.48,0:26:24.88,csapp,,0,0,0,,and if you if you have size classes that cover ranges of powers of two 
Dialogue: 0,0:26:25.12,0:26:27.44,csapp,,0,0,0,,then the search time reduces to log time anyway
Dialogue: 0,0:26:28.20,0:26:33.18,csapp,,0,0,0,,because the the size of each classes are now logarithmic the log
Dialogue: 0,0:26:35.38,0:26:37.52,csapp,,0,0,0,, so you know I would suggest on 
Dialogue: 0,0:26:39.62,0:26:42.90,csapp,,0,0,0,,you know just doing the simple thing usually whenever you're you're dealt with 
Dialogue: 0,0:26:43.34,0:26:47.68,csapp,,0,0,0,,sort of large design space like malloc it's you're better off doing the simple thing 
Dialogue: 0,0:26:48.80,0:26:52.86,csapp,,0,0,0,,and then optimizing only when you see that there's that you need to optimize 
Dialogue: 0,0:26:54.00,0:27:00.38,csapp,,0,0,0,,okay so remember last time we talked about this trick to to eliminate the boundary tag footer and allocated blocks
Dialogue: 0,0:27:01.62,0:27:04.18,csapp,,0,0,0,, that's an example of an optimization you should defer 
Dialogue: 0,0:27:05.16,0:27:12.24,csapp,,0,0,0,,so that wait you know wait get do the simple thing and then try to improve incrementally by bayi 
Dialogue: 0,0:27:12.80,0:27:18.04,csapp,,0,0,0,,by you know this this optimization or another optimization 
Dialogue: 0,0:27:18.66,0:27:25.38,csapp,,0,0,0,,so there's this this phenomena of a lot of lot of programmers make the mistake of what we call premature optimization 
Dialogue: 0,0:27:25.38,0:27:28.36,csapp,,0,0,0,,so try to think of all the fancy things they can do 
Dialogue: 0,0:27:28.78,0:27:30.48,csapp,,0,0,0,,and then they put all those in at the beginning
Dialogue: 0,0:27:30.88,0:27:33.48,csapp,,0,0,0,, and before they even know that it needs to be optimized 
Dialogue: 0,0:27:33.76,0:27:37.94,csapp,,0,0,0,,okay so the sort of the way you want to work on this and any any sort of complex 
Dialogue: 0,0:27:38.74,0:27:40.34,csapp,,0,0,0,,problem like like an alligator
Dialogue: 0,0:27:40.82,0:27:45.42,csapp,,0,0,0,, is to you know first do fairly simple things and then look and see where 
Dialogue: 0,0:27:45.78,0:27:49.04,csapp,,0,0,0,,where the slowdowns are your inefficiencies are and then just sort of 
Dialogue: 0,0:27:49.74,0:27:53.48,csapp,,0,0,0,,hit those one after the other and optimize only for the things that are necessary
Dialogue: 0,0:27:54.70,0:27:56.32,csapp,,0,0,0,,and this is a good example of that 
Dialogue: 0,0:28:00.54,0:28:03.62,csapp,,0,0,0,,okay now to get to your question about freeing
Dialogue: 0,0:28:09.32,0:28:12.08,csapp,,0,0,0,, freeing is tough because we always have to do this coalescing right
Dialogue: 0,0:28:12.09,0:28:18.40,csapp,,0,0,0,,because of this invariant that we can never have to free blocks  to adjacent free blocks 
Dialogue: 0,0:28:19.62,0:28:23.20,csapp,,0,0,0,,so let's go through each of those four cases that we went over last time 
Dialogue: 0,0:28:23.20,0:28:24.12,csapp,,0,0,0,,and see how we would do it 
Dialogue: 0,0:28:24.12,0:28:29.72,csapp,,0,0,0,,now that we have this this this explicit free list 
Dialogue: 0,0:28:30.84,0:28:33.10,csapp,,0,0,0,,so here we have the root of our free list 
Dialogue: 0,0:28:33.52,0:28:35.96,csapp,,0,0,0,,pointing to the first block in the free list
Dialogue: 0,0:28:36.78,0:28:38.52,csapp,,0,0,0,, there's an all back pointer and then that
Dialogue: 0,0:28:39.20,0:28:44.60,csapp,,0,0,0,, there's a null prief pointer and then the next next pointer points to some unspecified block
Dialogue: 0,0:28:45.86,0:28:48.68,csapp,,0,0,0,,and so we have this yellow block which is allocated 
Dialogue: 0,0:28:48.86,0:28:54.02,csapp,,0,0,0,,and now the application is called free free with a pointer that points to the beginning of this block
Dialogue: 0,0:28:55.61,0:28:56.28,csapp,,0,0,0,, so what do we do 
Dialogue: 0,0:28:57.22,0:28:59.68,csapp,,0,0,0,,well this case is pretty simple because there's no coalescing 
Dialogue: 0,0:28:59.68,0:29:06.14,csapp,,0,0,0,,because both the predecessor and successor blocks  are are allocated 
Dialogue: 0,0:29:07.80,0:29:12.86,csapp,,0,0,0,,okay so we just this newly freed block now becomes we're going to do a LIFO policy
Dialogue: 0,0:29:12.86,0:29:15.36,csapp,,0,0,0,,so this becomes the first block in the free list 
Dialogue: 0,0:29:16.64,0:29:18.68,csapp,,0,0,0,,and so we update the root to point to this 
Dialogue: 0,0:29:19.14,0:29:25.80,csapp,,0,0,0,,this newly freed block and we update the forward pointer of that block to point to what used to be the first block  in the heap
Dialogue: 0,0:29:30.02,0:29:31.52,csapp,,0,0,0,,now I'm going to be careful 
Dialogue: 0,0:29:33.38,0:29:34.76,csapp,,0,0,0,,it's a little bit confusing 
Dialogue: 0,0:29:35.58,0:29:40.82,csapp,,0,0,0,,because we've got sort of two notions of like previous and next right there's the 
Dialogue: 0,0:29:41.96,0:29:44.20,csapp,,0,0,0,,you know given some given some block
Dialogue: 0,0:29:45.56,0:29:51.32,csapp,,0,0,0,,there's the predecessor block in memory which may or may not be allocated or free right
Dialogue: 0,0:29:51.32,0:29:52.86,csapp,,0,0,0,, it may or may not be in a free list 
Dialogue: 0,0:29:54.24,0:29:55.68,csapp,,0,0,0,,and there's a successor block
Dialogue: 0,0:29:56.18,0:30:03.38,csapp,,0,0,0,,okay so we'll use predecessor and successor to distinguish adjacency in memory 
Dialogue: 0,0:30:04.18,0:30:08.50,csapp,,0,0,0,,okay and we'll use pre even next to denote adjacency in the free list
Dialogue: 0,0:30:08.98,0:30:15.16,csapp,,0,0,0,,okay so this this block is the next block for the current block 
Dialogue: 0,0:30:15.70,0:30:18.06,csapp,,0,0,0,,and it has no previous block okay
Dialogue: 0,0:30:20.94,0:30:26.90,csapp,,0,0,0,,all right now what about case to remember case to the predecessor block is free 
Dialogue: 0,0:30:27.94,0:30:30.16,csapp,,0,0,0,,and the successor block is is allocated 
Dialogue: 0,0:30:30.94,0:30:32.12,csapp,,0,0,0,,and now we want to free this
Dialogue: 0,0:30:32.58,0:30:36.72,csapp,,0,0,0,,what was an allocated block  denoted by yellow
Dialogue: 0,0:30:38.12,0:30:43.76,csapp,,0,0,0,, and we have that this this successor this predecessor block is part of the free list 
Dialogue: 0,0:30:43.98,0:30:47.40,csapp,,0,0,0,,right so it has it has previous and next blocks
Dialogue: 0,0:30:48.04,0:30:49.26,csapp,,0,0,0,, that are just part of the free list 
Dialogue: 0,0:30:49.98,0:30:53.84,csapp,,0,0,0,,and so our route points just the first block in the list and then eventually 
Dialogue: 0,0:30:56.10,0:31:00.80,csapp,,0,0,0,,you get to this free block which points to this free block which points to this free block 
Dialogue: 0,0:31:02.28,0:31:04.06,csapp,,0,0,0,,ok so what we have to do then 
Dialogue: 0,0:31:05.26,0:31:11.06,csapp,,0,0,0,,is we have to coalesce these two these two blocks into one big free block 
Dialogue: 0,0:31:12.48,0:31:15.68,csapp,,0,0,0,,okay and then we have to splice it out and stick it at the beginning of the list 
Dialogue: 0,0:31:18.76,0:31:23.98,csapp,,0,0,0,,ok so what that looks like conceptually is we we 
Dialogue: 0,0:31:24.58,0:31:27.98,csapp,,0,0,0,,we coalesce these two blocks now to form this one free block 
Dialogue: 0,0:31:30.08,0:31:32.16,csapp,,0,0,0,,and then we splice it out by
Dialogue: 0,0:31:33.72,0:31:40.06,csapp,,0,0,0,,having what was the what was its previous block now point to what used to be the next block
Dialogue: 0,0:31:41.24,0:31:42.38,csapp,,0,0,0,, okay of the current block 
Dialogue: 0,0:31:43.80,0:31:44.68,csapp,,0,0,0,,okay so this
Dialogue: 0,0:31:47.60,0:31:51.34,csapp,,0,0,0,,the pointer from this block now points to this block 
Dialogue: 0,0:31:51.84,0:31:57.20,csapp,,0,0,0,,okay and then the so we've effectively spliced that that current block out of the free list 
Dialogue: 0,0:31:57.94,0:32:00.90,csapp,,0,0,0,,and then the route we have the route point to that block 
Dialogue: 0,0:32:01.32,0:32:03.22,csapp,,0,0,0,,so that's now the new first block of the list 
Dialogue: 0,0:32:08.08,0:32:11.60,csapp,,0,0,0,,okay and then we have to update what used to be the first block in the list 
Dialogue: 0,0:32:12.28,0:32:16.86,csapp,,0,0,0,,so now it points back to the the newly freed coalesced block 
Dialogue: 0,0:32:18.84,0:32:20.26,csapp,,0,0,0,,so that cleared everybody it yes 
Dialogue: 0,0:32:25.00,0:32:27.80,csapp,,0,0,0,,so with the route be a global variable it could be or it could be
Dialogue: 0,0:32:30.66,0:32:33.34,csapp,,0,0,0,, there's there's two ways to do this right it could just be a global variable 
Dialogue: 0,0:32:33.76,0:32:40.78,csapp,,0,0,0,,or it could be a it could be a struct that  of like previous and next pointer 
Dialogue: 0,0:32:40.78,0:32:44.94,csapp,,0,0,0,,so sometimes it's easier if you keep the same you know when you're doing a linked list that 
Dialogue: 0,0:32:45.30,0:32:48.74,csapp,,0,0,0,,the route if you just make it the same as all the other nodes it can simplify things 
Dialogue: 0,0:32:49.34,0:32:52.50,csapp,,0,0,0,,but yeah it could be a global variable global scalar in the allocator
Dialogue: 0,0:32:58.26,0:33:02.14,csapp,,0,0,0,,okay so case oh now one thing one thing that comes to mind there is like 
Dialogue: 0,0:33:04.10,0:33:06.08,csapp,,0,0,0,,there is an optimization that we could do 
Dialogue: 0,0:33:08.30,0:33:11.52,csapp,,0,0,0,,in this case do you see when we when we coalesce 
Dialogue: 0,0:33:13.22,0:33:16.36,csapp,,0,0,0,,we could just lead that block right there in the free list 
Dialogue: 0,0:33:16.58,0:33:19.08,csapp,,0,0,0,,right we didn't although we've adopted 
Dialogue: 0,0:33:19.36,0:33:24.20,csapp,,0,0,0,,so the examples I'm going to show you are assuming a LIFO policy for insertion 
Dialogue: 0,0:33:25.38,0:33:29.02,csapp,,0,0,0,,we could just leave it there right that and just don't update anything 
Dialogue: 0,0:33:29.18,0:33:33.40,csapp,,0,0,0,,just increase create this newly coalesce block and then mentally 
Dialogue: 0,0:33:33.62,0:33:37.32,csapp,,0,0,0,,we don't require in this case we wouldn't require any free list manipulation 
Dialogue: 0,0:33:38.52,0:33:42.18,csapp,,0,0,0,,okay but that would be that would be one of these optimizations right 
Dialogue: 0,0:33:44.46,0:33:45.00,csapp,,0,0,0,,that now 
Dialogue: 0,0:33:47.48,0:33:52.56,csapp,,0,0,0,,case three if you recall is the case where the the predecessor block is allocated 
Dialogue: 0,0:33:53.22,0:33:56.08,csapp,,0,0,0,,and the successor block is free
Dialogue: 0,0:34:00.96,0:34:02.48,csapp,,0,0,0,,the successor block is free 
Dialogue: 0,0:34:04.20,0:34:06.30,csapp,,0,0,0,,so in this case what we have to do is we have to create 
Dialogue: 0,0:34:06.80,0:34:13.92,csapp,,0,0,0,,we have to coalesce the newly freed block with the with the successor block 
Dialogue: 0,0:34:15.46,0:34:19.04,csapp,,0,0,0,,and then we have to splice it out in just the same way we did in case two
Dialogue: 0,0:34:21.48,0:34:23.34,csapp,,0,0,0,,so we splice it out of the the list 
Dialogue: 0,0:34:25.82,0:34:29.32,csapp,,0,0,0,,and then put it at the beginning of the list by pointing the root at it 
Dialogue: 0,0:34:29.94,0:34:33.50,csapp,,0,0,0,,and then updating what used to be the first block in the list 
Dialogue: 0,0:34:34.14,0:34:39.72,csapp,,0,0,0,,updating its back pointer it's pre pointer to point to the  newly coalesced block
Dialogue: 0,0:34:40.26,0:34:44.70,csapp,,0,0,0,, okay so it's this is completely symmetric with the case that we looked at before 
Dialogue: 0,0:34:46.34,0:34:47.60,csapp,,0,0,0,,but now we no longer have 
Dialogue: 0,0:34:48.06,0:34:51.90,csapp,,0,0,0,,it's a little bit trickier if we just wanted to leave this block in the free list 
Dialogue: 0,0:34:52.66,0:34:55.26,csapp,,0,0,0,,we'd have to update all these pointers to point back 
Dialogue: 0,0:34:56.28,0:34:58.16,csapp,,0,0,0,,to the beginning of the newly created block
Dialogue: 0,0:34:58.50,0:35:00.74,csapp,,0,0,0,,okay so there's
Dialogue: 0,0:35:02.50,0:35:04.32,csapp,,0,0,0,, so in this case there's no performance 
Dialogue: 0,0:35:05.62,0:35:08.28,csapp,,0,0,0,,optimization right we're still updating the same number of pointers 
Dialogue: 0,0:35:08.50,0:35:10.62,csapp,,0,0,0,,whether we put it in the beginning of the list 
Dialogue: 0,0:35:10.68,0:35:14.02,csapp,,0,0,0,,or if we if we splice it or if we leave it there 
Dialogue: 0,0:35:17.84,0:35:19.86,csapp,,0,0,0,,and now case four is the 
Dialogue: 0,0:35:20.80,0:35:24.92,csapp,,0,0,0,,that's the case where both the predecessor and successor blocks are free 
Dialogue: 0,0:35:26.14,0:35:34.26,csapp,,0,0,0,,so we have to apply the same splicing technique  to both the the predecessor block 
Dialogue: 0,0:35:35.68,0:35:39.80,csapp,,0,0,0,,and we have to we have to create this new coalesced block 
Dialogue: 0,0:35:39.80,0:35:41.04,csapp,,0,0,0,,and then we have to splice 
Dialogue: 0,0:35:42.92,0:35:45.90,csapp,,0,0,0,,we have to we have to sort of splice it out by updating 
Dialogue: 0,0:35:46.40,0:35:51.82,csapp,,0,0,0,,two different sets of previous and successor blocks 
Dialogue: 0,0:35:56.08,0:35:58.24,csapp,,0,0,0,,so when we're when we're finished with that
Dialogue: 0,0:35:58.92,0:36:05.08,csapp,,0,0,0,,that the this newly coalesced block now is the first block  in the in the heap
Dialogue: 0,0:36:06.70,0:36:07.78,csapp,,0,0,0,,the four in the free list
Dialogue: 0,0:36:08.12,0:36:13.14,csapp,,0,0,0,, and we've spliced it we splice it out from these two different parts of the of the free list
Dialogue: 0,0:36:18.46,0:36:19.96,csapp,,0,0,0,,okay so any questions about 
Dialogue: 0,0:36:22.26,0:36:23.76,csapp,,0,0,0,,this is this is where you really
Dialogue: 0,0:36:25.02,0:36:28.46,csapp,,0,0,0,, it looks it looks really simple to do 
Dialogue: 0,0:36:30.30,0:36:31.86,csapp,,0,0,0,,but I guarantee you this will be
Dialogue: 0,0:36:32.78,0:36:33.68,csapp,,0,0,0,,some the hardest 
Dialogue: 0,0:36:34.46,0:36:36.40,csapp,,0,0,0,,It's only like 200 lines of code 
Dialogue: 0,0:36:36.48,0:36:38.40,csapp,,0,0,0,,but some of the hardest code you'll have to write because 
Dialogue: 0,0:36:40.58,0:36:45.24,csapp,,0,0,0,,you you're sort of free of the C's types us that you have to do everything by explicitly casting 
Dialogue: 0,0:36:45.46,0:36:48.22,csapp,,0,0,0,,these pointers are just in the middle of arbitrary blocks 
Dialogue: 0,0:36:49.02,0:36:49.50,csapp,,0,0,0,,and 
Dialogue: 0,0:36:51.42,0:36:55.92,csapp,,0,0,0,,so it looks simple with the diagram but you're going to have to be really careful when you do this
Dialogue: 0,0:36:57.50,0:36:58.94,csapp,,0,0,0,, in fact what I would suggest the
Dialogue: 0,0:37:00.74,0:37:02.36,csapp,,0,0,0,,best suggestion I can give you is 
Dialogue: 0,0:37:03.48,0:37:06.54,csapp,,0,0,0,,if is to start with the implicit list allocator 
Dialogue: 0,0:37:07.32,0:37:10.52,csapp,,0,0,0,,that we describe in the book which is too slow to get any credit
Dialogue: 0,0:37:10.64,0:37:11.52,csapp,,0,0,0,, it's a terrible allocator 
Dialogue: 0,0:37:11.52,0:37:14.48,csapp,,0,0,0,,but it contains all the basic ideas 
Dialogue: 0,0:37:15.50,0:37:21.14,csapp,,0,0,0,,and then write function write a function called insert block and write another function called remove block 
Dialogue: 0,0:37:21.70,0:37:27.62,csapp,,0,0,0,,that inserts a block into the free list and removes a block from the free list respectively
Dialogue: 0,0:37:28.74,0:37:31.12,csapp,,0,0,0,,and if you if you write if you abstract it like that
Dialogue: 0,0:37:31.78,0:37:34.04,csapp,,0,0,0,,  if you use that kind of abstraction it's pretty simple
Dialogue: 0,0:37:34.56,0:37:38.64,csapp,,0,0,0,, to to convert the implicit list allocator to an explicit list allocator 
Dialogue: 0,0:37:41.06,0:37:43.18,csapp,,0,0,0,,it'll still be too slow to get 
Dialogue: 0,0:37:43.70,0:37:48.48,csapp,,0,0,0,,so then that'll go from like a F allocator to a b- allocator
Dialogue: 0,0:37:50.04,0:37:55.18,csapp,,0,0,0,, and then to really make a good allocator like an a allocator you need to use segregated lists 
Dialogue: 0,0:37:55.72,0:37:57.06,csapp,,0,0,0,,which we'll look at in a second 
Dialogue: 0,0:37:59.94,0:38:01.56,csapp,,0,0,0,,okay so the explicit lists 
Dialogue: 0,0:38:01.84,0:38:06.76,csapp,,0,0,0,,now the the allocation time is is linear in the number of free blocks instead of the total size 
Dialogue: 0,0:38:07.36,0:38:11.64,csapp,,0,0,0,,of the instead of the total size of the heap
Dialogue: 0,0:38:11.66,0:38:14.96,csapp,,0,0,0,, so it's this is much faster than that when you have a lot of allocated blocks 
Dialogue: 0,0:38:16.80,0:38:19.70,csapp,,0,0,0,,it's a little more complicated because of all the splicing business 
Dialogue: 0,0:38:20.22,0:38:23.50,csapp,,0,0,0,,and and you do need some extra space in your
Dialogue: 0,0:38:25.28,0:38:28.72,csapp,,0,0,0,, for these these pointers which increases the minimum block size 
Dialogue: 0,0:38:28.98,0:38:32.68,csapp,,0,0,0,,and creates additional and overhead 
Dialogue: 0,0:38:34.28,0:38:39.74,csapp,,0,0,0,,now the link list the explicit list allocators aren't really
Dialogue: 0,0:38:40.30,0:38:45.06,csapp,,0,0,0,,efficient enough to be used for sort of general purpose real-life  allocator 
Dialogue: 0,0:38:45.08,0:38:49.84,csapp,,0,0,0,,but they are useful in as part of a segregated list allocator 
Dialogue: 0,0:38:49.84,0:38:54.58,csapp,,0,0,0,,so you can have you can have multiple free lists each of which is an explicit list 
Dialogue: 0,0:38:55.50,0:38:58.44,csapp,,0,0,0,,and this it's fine for that for that application 
Dialogue: 0,0:39:00.78,0:39:05.06,csapp,,0,0,0,,alright so let's look at our third method which is to create call a segregated free list 
Dialogue: 0,0:39:05.82,0:39:10.32,csapp,,0,0,0,,which is to have multiple free lists with different size classes 
Dialogue: 0,0:39:12.76,0:39:14.68,csapp,,0,0,0,,so the the idea is that each
Dialogue: 0,0:39:15.84,0:39:17.28,csapp,,0,0,0,,each class of sizes 
Dialogue: 0,0:39:18.84,0:39:21.32,csapp,,0,0,0,,block sizes has its own free list 
Dialogue: 0,0:39:21.86,0:39:25.90,csapp,,0,0,0,,and that that class can be singleton so you know maybe a one particular size 
Dialogue: 0,0:39:26.48,0:39:28.18,csapp,,0,0,0,,or it can be a range of sizes 
Dialogue: 0,0:39:28.26,0:39:31.24,csapp,,0,0,0,,so you might you might have a number of different 
Dialogue: 0,0:39:32.10,0:39:37.24,csapp,,0,0,0,,you know if you're if you're if your workload consists of a lot of these small blocks
Dialogue: 0,0:39:37.26,0:39:39.96,csapp,,0,0,0,, and you know that there's going to be a lot of requests for blocks 
Dialogue: 0,0:39:40.92,0:39:41.80,csapp,,0,0,0,,of 1 through 4 
Dialogue: 0,0:39:41.82,0:39:47.43,csapp,,0,0,0,,you can have different free lists for those small for those small block sizes 
Dialogue: 0,0:39:47.96,0:39:51.40,csapp,,0,0,0,,and then after that you can go and just do ranges of power of two 
Dialogue: 0,0:39:51.40,0:39:53.42,csapp,,0,0,0,,so that's a that's a common technique 
Dialogue: 0,0:39:53.96,0:39:57.94,csapp,,0,0,0,,so here we have a size class that covers blocks from size 5 to 8
Dialogue: 0,0:39:58.42,0:40:03.60,csapp,,0,0,0,, and then the another size class that covers everything else
Dialogue: 0,0:40:07.38,0:40:09.70,csapp,,0,0,0,,so the idea with the seg list allocators that 
Dialogue: 0,0:40:09.92,0:40:15.20,csapp,,0,0,0,,so given a given an array of these free lists one each one for for some size class 
Dialogue: 0,0:40:16.34,0:40:18.60,csapp,,0,0,0,,if we want to allocate a block of size n 
Dialogue: 0,0:40:19.40,0:40:22.02,csapp,,0,0,0,,then we we go to the appropriate free list 
Dialogue: 0,0:40:22.54,0:40:27.04,csapp,,0,0,0,,right there's only there's always going to be one free list for any any n 
Dialogue: 0,0:40:28.40,0:40:31.36,csapp,,0,0,0,,and then we search that list just like we did before
Dialogue: 0,0:40:31.70,0:40:35.36,csapp,,0,0,0,, for some size at a block size M greater than n
Dialogue: 0,0:40:38.26,0:40:40.78,csapp,,0,0,0,,and then if if we find it then we place
Dialogue: 0,0:40:41.48,0:40:42.60,csapp,,0,0,0,,we place the new block 
Dialogue: 0,0:40:43.70,0:40:46.68,csapp,,0,0,0,,we place the block in that in the block that we found
Dialogue: 0,0:40:46.98,0:40:47.76,csapp,,0,0,0,,we split it 
Dialogue: 0,0:40:48.64,0:40:52.42,csapp,,0,0,0,,and we take this the split block and we put it into the appropriate size class 
Dialogue: 0,0:40:52.66,0:40:54.38,csapp,,0,0,0,,so that the block that we split off 
Dialogue: 0,0:40:54.94,0:40:58.24,csapp,,0,0,0,,may or may not may or may not belong to the current size class anymore
Dialogue: 0,0:40:58.64,0:41:03.96,csapp,,0,0,0,,right so we may have to move it and insert it into a whatever the appropriate size class is 
Dialogue: 0,0:41:06.18,0:41:08.76,csapp,,0,0,0,,if there's no block if we can't find a block
Dialogue: 0,0:41:09.00,0:41:11.06,csapp,,0,0,0,, then we have to try the next larger size class
Dialogue: 0,0:41:12.12,0:41:14.80,csapp,,0,0,0,,okay so it's possible for a given size class
Dialogue: 0,0:41:14.80,0:41:17.22,csapp,,0,0,0,, they're just there might not be a block that fits 
Dialogue: 0,0:41:20.12,0:41:23.94,csapp,,0,0,0,,so I mean one so we just have to we go to the next size 
Dialogue: 0,0:41:23.94,0:41:28.10,csapp,,0,0,0,,we try the next larger class and chances are we'll find a block that fits there 
Dialogue: 0,0:41:28.80,0:41:33.60,csapp,,0,0,0,,and if we and you keep doing that until you eventually if you can't find it 
Dialogue: 0,0:41:33.60,0:41:39.16,csapp,,0,0,0,,you're eventually looking in the size class that that that covers all the rest the last size class 
Dialogue: 0,0:41:40.10,0:41:49.56,csapp,,0,0,0,,and if then you can't find it then that the allocator has to allocate more memory with by calling s break
Dialogue: 0,0:41:53.58,0:41:56.26,csapp,,0,0,0,,okay to free a block you coalesce like before
Dialogue: 0,0:41:56.26,0:41:57.84,csapp,,0,0,0,,before and then you place it on the appropriate list 
Dialogue: 0,0:41:58.26,0:42:03.88,csapp,,0,0,0,,so that's that's straightforward and again you have this option to try to maintain a listed
Dialogue: 0,0:42:04.46,0:42:07.44,csapp,,0,0,0,,address order or just do the simple thing and put it at the beginning of the list 
Dialogue: 0,0:42:09.38,0:42:17.43,csapp,,0,0,0,,okay so say egg list alligators are that by far the best type of alligator
Dialogue: 0,0:42:18.40,0:42:25.12,csapp,,0,0,0,,because they're they offer you improvements in both performance throughput and memory utilization 
Dialogue: 0,0:42:26.42,0:42:28.96,csapp,,0,0,0,,so they're faster they have higher throughputs because the
Dialogue: 0,0:42:29.38,0:42:32.62,csapp,,0,0,0,, the individual size classes are  are smaller 
Dialogue: 0,0:42:33.00,0:42:35.68,csapp,,0,0,0,,then than just like the one giant free list 
Dialogue: 0,0:42:36.52,0:42:37.96,csapp,,0,0,0,,but also you're searching 
Dialogue: 0,0:42:39.24,0:42:42.26,csapp,,0,0,0,,you're you know that the the list that you're searching
Dialogue: 0,0:42:42.32,0:42:47.04,csapp,,0,0,0,,is going to be close to the size that you're looking for so the chances of finding something quickly
Dialogue: 0,0:42:48.12,0:42:51.78,csapp,,0,0,0,, in that in that particular size class  are higher than they are
Dialogue: 0,0:42:52.06,0:42:53.36,csapp,,0,0,0,, if you're just searching
Dialogue: 0,0:42:53.92,0:42:57.24,csapp,,0,0,0,,on you know a single free list that holds all different size classes 
Dialogue: 0,0:42:58.08,0:43:03.26,csapp,,0,0,0,,okay so search is faster so that increases increases throughput 
Dialogue: 0,0:43:03.84,0:43:06.90,csapp,,0,0,0,,but the big thing about egg list alligators is that 
Dialogue: 0,0:43:07.50,0:43:12.20,csapp,,0,0,0,,like we talked about before they approximate best fit without sacrificing performance
Dialogue: 0,0:43:12.90,0:43:17.00,csapp,,0,0,0,,right before if we wanted to do best fit on a single a free list 
Dialogue: 0,0:43:17.00,0:43:18.60,csapp,,0,0,0,,we had to search the whole free list 
Dialogue: 0,0:43:19.00,0:43:20.84,csapp,,0,0,0,,and then choose the block that fit the best 
Dialogue: 0,0:43:22.62,0:43:25.72,csapp,,0,0,0,,in this case we get we get best fit for free 
Dialogue: 0,0:43:26.38,0:43:28.82,csapp,,0,0,0,,by by virtue of having these size classes 
Dialogue: 0,0:43:31.28,0:43:33.36,csapp,,0,0,0,,and so this is 
Dialogue: 0,0:43:34.46,0:43:38.06,csapp,,0,0,0,,you know this is this is how you can improve your your memory utilization 
Dialogue: 0,0:43:38.70,0:43:39.28,csapp,,0,0,0,,yes
Dialogue: 0,0:43:39.28,0:43:51.44,csapp,,0,0,0,,[student speaking] we just allocate and more bytes or 
Dialogue: 0,0:43:51.44,0:43:52.68,csapp,,0,0,0,,oh yeah yeah good question 
Dialogue: 0,0:43:52.68,0:43:56.62,csapp,,0,0,0,,so the question is is is is break constant time
Dialogue: 0,0:43:57.12,0:43:58.68,csapp,,0,0,0,, it is but it's very expensive 
Dialogue: 0,0:43:59.32,0:44:03.80,csapp,,0,0,0,,so it's a sis call so it has to pass from user space into the kernel that involves 
Dialogue: 0,0:44:04.56,0:44:06.54,csapp,,0,0,0,,changing contacts changing stacks 
Dialogue: 0,0:44:08.04,0:44:08.82,csapp,,0,0,0,,so sis calls
Dialogue: 0,0:44:10.32,0:44:15.70,csapp,,0,0,0,,generally you can you can count on assist call being like several hundred microseconds 
Dialogue: 0,0:44:16.52,0:44:18.54,csapp,,0,0,0,,okay it's a non-trivial overhead 
Dialogue: 0,0:44:20.24,0:44:22.10,csapp,,0,0,0,,and so in that case you wouldn't want 
Dialogue: 0,0:44:22.10,0:44:25.36,csapp,,0,0,0,,you you want to amortize the cost of the of the break
Dialogue: 0,0:44:25.96,0:44:28.26,csapp,,0,0,0,, by allocating is somewhat larger chunk 
Dialogue: 0,0:44:29.02,0:44:33.50,csapp,,0,0,0,,but you have to be careful if you allocate too large of a chunk then your memory utilization goes down
Dialogue: 0,0:44:34.10,0:44:36.94,csapp,,0,0,0,, so it's a trade-off it's another one of these space-time trade-offs 
Dialogue: 0,0:44:37.68,0:44:38.04,csapp,,0,0,0,,question 
Dialogue: 0,0:44:38.04,0:44:40.90,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:44:40.96,0:44:42.54,csapp,,0,0,0,,so where do you store this array of free lists 
Dialogue: 0,0:44:44.06,0:44:45.70,csapp,,0,0,0,,so you store it in the beginning of the heap 
Dialogue: 0,0:44:48.90,0:44:51.54,csapp,,0,0,0,,yeah in fact for your malloc lab we require you to do that 
Dialogue: 0,0:44:52.18,0:44:52.66,csapp,,0,0,0,,we don't know 
Dialogue: 0,0:44:53.14,0:44:54.28,csapp,,0,0,0,,and the reason is we can't 
Dialogue: 0,0:44:55.86,0:44:59.14,csapp,,0,0,0,,that that array affects in some small part 
Dialogue: 0,0:44:59.32,0:45:02.76,csapp,,0,0,0,,depending on how large that array is it affects your memory utilization 
Dialogue: 0,0:45:03.46,0:45:05.12,csapp,,0,0,0,,and so it should be at the beginning of the heap
Dialogue: 0,0:45:13.20,0:45:17.40,csapp,,0,0,0,,okay there's a allocators have been around forever and
Dialogue: 0,0:45:18.22,0:45:23.46,csapp,,0,0,0,, that the the classic references canuse 1973 text 
Dialogue: 0,0:45:25.28,0:45:29.06,csapp,,0,0,0,,and there's also this great paper which you can get from the the books website
Dialogue: 0,0:45:29.74,0:45:32.28,csapp,,0,0,0,, from 1995 that does a survey of 
Dialogue: 0,0:45:33.38,0:45:36.06,csapp,,0,0,0,,you know literate dozens and dozens of techniques like
Dialogue: 0,0:45:36.10,0:45:37.86,csapp,,0,0,0,,we're just scratching the surface here
Dialogue: 0,0:45:38.36,0:45:39.92,csapp,,0,0,0,,so if you're really interested in this stuff
Dialogue: 0,0:45:41.30,0:45:43.66,csapp,,0,0,0,, that that is that papers a fascinating read 
Dialogue: 0,0:45:43.76,0:45:46.32,csapp,,0,0,0,,and it may give you some ideas for your free lab 
Dialogue: 0,0:45:49.66,0:45:50.88,csapp,,0,0,0,,ok now so far 
Dialogue: 0,0:45:51.56,0:45:58.20,csapp,,0,0,0,,we're assuming that the application is responsible for both allocating storage and freeing storage 
Dialogue: 0,0:45:59.74,0:46:05.34,csapp,,0,0,0,,but there's a form of memory managers called implicit memory managers 
Dialogue: 0,0:46:05.94,0:46:07.78,csapp,,0,0,0,,that do the freeing for you 
Dialogue: 0,0:46:08.44,0:46:10.74,csapp,,0,0,0,,so so applications allocate space 
Dialogue: 0,0:46:10.74,0:46:15.58,csapp,,0,0,0,,but they never have to worry about freeing space the system does that automatically 
Dialogue: 0,0:46:16.82,0:46:23.70,csapp,,0,0,0,,and so the the idea is to identify so-called garbage
Dialogue: 0,0:46:24.24,0:46:27.82,csapp,,0,0,0,, so areas of memory that can never be referenced anymore
Dialogue: 0,0:46:28.94,0:46:30.18,csapp,,0,0,0,,and then free up those blocks 
Dialogue: 0,0:46:32.78,0:46:38.44,csapp,,0,0,0,,okay so what's garbage well here's an example we have a function foo  that Malick's 128 bytes 
Dialogue: 0,0:46:39.26,0:46:41.72,csapp,,0,0,0,,it stores the address in this pointer P 
Dialogue: 0,0:46:42.88,0:46:45.86,csapp,,0,0,0,,and then at some point when it returns from foo 
Dialogue: 0,0:46:46.64,0:46:50.26,csapp,,0,0,0,,this pointer is lost forever right because P is a local variable on the stack 
Dialogue: 0,0:46:50.98,0:46:53.46,csapp,,0,0,0,,so once once this function returns
Dialogue: 0,0:46:54.14,0:46:59.10,csapp,,0,0,0,, that the block of memory pointed to by P is garbage  can never be referenced again 
Dialogue: 0,0:47:00.46,0:47:04.20,csapp,,0,0,0,,because there's no way there's no way for the program to get get access to that 
Dialogue: 0,0:47:05.46,0:47:07.82,csapp,,0,0,0,,and so what an alligator will recognize 
Dialogue: 0,0:47:08.02,0:47:11.78,csapp,,0,0,0,, at some point that this block of memory is is garbage 
Dialogue: 0,0:47:12.18,0:47:14.64,csapp,,0,0,0,,and that it will free those blocks by calling free
Dialogue: 0,0:47:14.64,0:47:17.34,csapp,,0,0,0,, it's the same kind of exactly the same free call 
Dialogue: 0,0:47:17.90,0:47:19.42,csapp,,0,0,0,,as we've discussed 
Dialogue: 0,0:47:19.58,0:47:24.40,csapp,,0,0,0,,but now it's it's it's it's called by the garbage collector not by the application
Dialogue: 0,0:47:25.20,0:47:30.00,csapp,,0,0,0,,okay so you see this in all different kinds of dynamic languages 
Dialogue: 0,0:47:30.52,0:47:34.74,csapp,,0,0,0,,and there's there's there's also variants available for C 
Dialogue: 0,0:47:34.74,0:47:38.36,csapp,,0,0,0,,but because of C's pointer properties
Dialogue: 0,0:47:38.96,0:47:42.96,csapp,,0,0,0,, that the garbage collectors for C are conservative in the sense 
Dialogue: 0,0:47:42.96,0:47:45.24,csapp,,0,0,0,,that there's some blocks won't be freed
Dialogue: 0,0:47:45.48,0:47:48.42,csapp,,0,0,0,, there's some garbage blocks that that won't be free
Dialogue: 0,0:47:48.42,0:47:54.72,csapp,,0,0,0,,  because the allocator can't determine that   that they are indeed garbage 
Dialogue: 0,0:47:55.10,0:47:57.42,csapp,,0,0,0,, so it has to be careful when it whenever there's a doubt 
Dialogue: 0,0:47:58.08,0:48:02.94,csapp,,0,0,0,,it it leaves it doesn't reclaim the the allocated block 
Dialogue: 0,0:48:07.04,0:48:12.16,csapp,,0,0,0,,so it gets to this question of like how does the memory manager know when memory can be free 
Dialogue: 0,0:48:13.18,0:48:15.52,csapp,,0,0,0,,and you know if we knew 
Dialogue: 0,0:48:16.50,0:48:19.44,csapp,,0,0,0,,if somehow we knew we could predict all of the future requests 
Dialogue: 0,0:48:20.28,0:48:24.94,csapp,,0,0,0,,and then if we knew that there were no future requests access that block then we could free it 
Dialogue: 0,0:48:25.62,0:48:26.88,csapp,,0,0,0,,okay but we can't predict that 
Dialogue: 0,0:48:28.64,0:48:29.64,csapp,,0,0,0,,okay so we have to
Dialogue: 0,0:48:31.66,0:48:32.94,csapp,,0,0,0,,but if there's no pointers
Dialogue: 0,0:48:33.48,0:48:37.44,csapp,,0,0,0,, if no pointers exist to a particular block then we know that it can't be accessed
Dialogue: 0,0:48:38.06,0:48:40.50,csapp,,0,0,0,,okay and so that we can predict right if there's some way
Dialogue: 0,0:48:40.98,0:48:49.36,csapp,,0,0,0,, we can sort of scan the program identify or scan the memory identify all the pointers in that memory
Dialogue: 0,0:48:50.00,0:48:52.80,csapp,,0,0,0,,and and see which which blocks are pointed to 
Dialogue: 0,0:48:53.30,0:48:57.88,csapp,,0,0,0,,and if they're if they're not pointed to by any pointer than then they're garbage by definition 
Dialogue: 0,0:48:58.98,0:49:02.56,csapp,,0,0,0,,okay so to do this though it's it's it's difficult
Dialogue: 0,0:49:04.00,0:49:08.66,csapp,,0,0,0,,so first of all the memory manager has to be able to distinguish pointers from non pointers 
Dialogue: 0,0:49:09.66,0:49:14.58,csapp,,0,0,0,,which we can't do and see right there just these they're just these integral values
Dialogue: 0,0:49:14.62,0:49:17.18,csapp,,0,0,0,, right we don't know it could be it
Dialogue: 0,0:49:18.12,0:49:19.98,csapp,,0,0,0,, if we see this large integral value 
Dialogue: 0,0:49:20.56,0:49:22.96,csapp,,0,0,0,,this large long a 8 byte value 
Dialogue: 0,0:49:23.70,0:49:28.04,csapp,,0,0,0,,it could be it could be pointing to a data structure it could just be a large integer right 
Dialogue: 0,0:49:28.10,0:49:28.92,csapp,,0,0,0,,we don't know 
Dialogue: 0,0:49:32.48,0:49:36.98,csapp,,0,0,0,,and then we also all pointers have to point to the start of a block which is not true and see either
Dialogue: 0,0:49:38.60,0:49:42.92,csapp,,0,0,0,,okay so if we have a pointer and we identify that it's a pointer
Dialogue: 0,0:49:43.08,0:49:45.92,csapp,,0,0,0,, then we know that it points it points to some block 
Dialogue: 0,0:49:45.92,0:49:49.78,csapp,,0,0,0,,if it points inside of a block how do we how do we find the beginning of that block 
Dialogue: 0,0:49:50.92,0:49:52.80,csapp,,0,0,0,,you know how do we know how big that block is 
Dialogue: 0,0:49:53.24,0:49:58.14,csapp,,0,0,0,,all right so it has to point to the beginning of the block where the header  tells us the size and
Dialogue: 0,0:50:00.98,0:50:03.14,csapp,,0,0,0,,the and and and there can't be a way to hide pointers
Dialogue: 0,0:50:03.14,0:50:06.66,csapp,,0,0,0,, the point that the property of being a pointer has to be some kind of static  
Dialogue: 0,0:50:07.64,0:50:09.66,csapp,,0,0,0,,thing that doesn't that can't change 
Dialogue: 0,0:50:11.92,0:50:13.04,csapp,,0,0,0,,so that's sort of the challenges
Dialogue: 0,0:50:13.04,0:50:15.60,csapp,,0,0,0,, if you're thinking about how in the world can you implement a garbage collector 
Dialogue: 0,0:50:15.60,0:50:18.76,csapp,,0,0,0,,so those are some of the challenges that  that they present 
Dialogue: 0,0:50:19.38,0:50:25.54,csapp,,0,0,0,,and because of that this is this been a the history of research and garbage collectors is is old 
Dialogue: 0,0:50:26.00,0:50:28.04,csapp,,0,0,0,,its ancient and ongoing 
Dialogue: 0,0:50:28.14,0:50:32.74,csapp,,0,0,0,,it's still it's still ongoing today particularly in the context of parallel programs 
Dialogue: 0,0:50:32.78,0:50:36.44,csapp,,0,0,0,,and garbage collecting programs that are running multiple threads 
Dialogue: 0,0:50:37.10,0:50:38.50,csapp,,0,0,0,,so there's a whole bunch of these things
Dialogue: 0,0:50:40.24,0:50:43.00,csapp,,0,0,0,, that people have looked at going all the way back to 1960 
Dialogue: 0,0:50:44.44,0:50:47.34,csapp,,0,0,0,,today we'll look at we'll look at the simplest
Dialogue: 0,0:50:48.06,0:50:50.18,csapp,,0,0,0,,what one of the simpler variants called mark-and-sweep
Dialogue: 0,0:50:50.40,0:50:51.94,csapp,,0,0,0,,and we won't we won't discuss the rest
Dialogue: 0,0:50:52.58,0:50:57.12,csapp,,0,0,0,,but if you're interested in them there's a pretty good book that describes that describes these things 
Dialogue: 0,0:51:00.24,0:51:01.86,csapp,,0,0,0,,all right so how do we build an allocator 
Dialogue: 0,0:51:02.66,0:51:05.16,csapp,,0,0,0,,so we start by viewing memory as a directed graph 
Dialogue: 0,0:51:05.88,0:51:11.30,csapp,,0,0,0,,where each each node in the graph corresponds to a block 
Dialogue: 0,0:51:13.46,0:51:14.76,csapp,,0,0,0,,okay a block a heap block 
Dialogue: 0,0:51:19.39,0:51:21.64,csapp,,0,0,0,,and an allocated heap block 
Dialogue: 0,0:51:24.52,0:51:28.62,csapp,,0,0,0,,and each edge is a pointer that's contained somewhere within that block 
Dialogue: 0,0:51:29.82,0:51:31.04,csapp,,0,0,0,,okay a pointer to another block 
Dialogue: 0,0:51:33.42,0:51:37.08,csapp,,0,0,0,,and then there's a and then there's special nodes called root nodes 
Dialogue: 0,0:51:37.92,0:51:40.68,csapp,,0,0,0,,that contain pointers into the heap but they're not part of the heap 
Dialogue: 0,0:51:41.26,0:51:43.94,csapp,,0,0,0,,so for example pointers that are stored on the stack 
Dialogue: 0,0:51:44.82,0:51:46.36,csapp,,0,0,0,,pointers that are stored in registers 
Dialogue: 0,0:51:47.30,0:51:49.60,csapp,,0,0,0,,they point to memory locations in the heap 
Dialogue: 0,0:51:50.72,0:51:56.06,csapp,,0,0,0,,but nothing nothing and but there outside of the heap 
Dialogue: 0,0:51:56.66,0:51:57.92,csapp,,0,0,0,,so and we call those route notes 
Dialogue: 0,0:51:57.92,0:52:00.88,csapp,,0,0,0,,so nothing points to them or at least if something does point to them 
Dialogue: 0,0:52:00.88,0:52:02.16,csapp,,0,0,0,,we don't care about what it is 
Dialogue: 0,0:52:04.06,0:52:09.98,csapp,,0,0,0,,okay we're only we're only concerned about characterizing nodes that correspond to memory in the heap 
Dialogue: 0,0:52:11.22,0:52:15.44,csapp,,0,0,0,,so I we say that a a node or a block is reachable
Dialogue: 0,0:52:15.44,0:52:17.48,csapp,,0,0,0,, if there's some path from a root node
Dialogue: 0,0:52:19.90,0:52:21.62,csapp,,0,0,0,, from a root node to that block 
Dialogue: 0,0:52:21.68,0:52:24.10,csapp,,0,0,0,,so and we've denoted those by green 
Dialogue: 0,0:52:24.16,0:52:26.70,csapp,,0,0,0,,so all of these green blocks in the heap are reachable 
Dialogue: 0,0:52:27.17,0:52:33.54,csapp,,0,0,0,,because you can start at a root node and just follow some some sequence of pointers to get to that node okay
Dialogue: 0,0:52:35.44,0:52:40.34,csapp,,0,0,0,,notes that aren't reachable are called our garbage
Dialogue: 0,0:52:40.74,0:52:44.50,csapp,,0,0,0,, because there's no there's no way to get to them from the root nodes 
Dialogue: 0,0:52:45.18,0:52:48.46,csapp,,0,0,0,,okay so there's no node inside the heap  that points to them 
Dialogue: 0,0:52:48.46,0:52:52.06,csapp,,0,0,0,,and there's no node there's no root node that points to them 
Dialogue: 0,0:52:52.06,0:52:54.32,csapp,,0,0,0,,so basically there's just no path from a root node 
Dialogue: 0,0:52:54.66,0:52:59.04,csapp,,0,0,0,,that'll get you to one of these non reachable or garbage nodes 
Dialogue: 0,0:53:00.04,0:53:01.44,csapp,,0,0,0,,and since they're non reachable 
Dialogue: 0,0:53:03.20,0:53:06.04,csapp,,0,0,0,,the application will never be able to reference them in the future 
Dialogue: 0,0:53:06.38,0:53:07.88,csapp,,0,0,0,,so we can predict with certainty 
Dialogue: 0,0:53:08.26,0:53:10.78,csapp,,0,0,0,,that that those are garbage and they can be freed 
Dialogue: 0,0:53:13.56,0:53:16.28,csapp,,0,0,0,,so basically after we free these then they're removed from the graph
Dialogue: 0,0:53:23.58,0:53:25.14,csapp,,0,0,0,,so now we can we can build 
Dialogue: 0,0:53:26.62,0:53:30.48,csapp,,0,0,0,,a simple garbage collector on top of the existing malloc and free package 
Dialogue: 0,0:53:30.72,0:53:33.64,csapp,,0,0,0,,right so you implement malloc and free just like before 
Dialogue: 0,0:53:34.78,0:53:36.62,csapp,,0,0,0,,and then you the program 
Dialogue: 0,0:53:38.88,0:53:41.30,csapp,,0,0,0,,calls malloc just like before 
Dialogue: 0,0:53:41.30,0:53:45.18,csapp,,0,0,0,,and you just you do malloc exactly the same way until you run out of space 
Dialogue: 0,0:53:45.70,0:53:48.40,csapp,,0,0,0,,by whatever different definition you want to use of running out of space 
Dialogue: 0,0:53:48.40,0:53:51.78,csapp,,0,0,0,,maybe you have some kind of maximum heap size you're willing to use
Dialogue: 0,0:53:52.16,0:53:55.40,csapp,,0,0,0,,or at some point the OS will just stop giving you virtual memory 
Dialogue: 0,0:53:56.94,0:53:58.08,csapp,,0,0,0,,when you run out of space 
Dialogue: 0,0:54:01.26,0:54:06.68,csapp,,0,0,0,,you you add an extra mark bit into the header of each block 
Dialogue: 0,0:54:06.68,0:54:10.40,csapp,,0,0,0,,so this could be you know we have like three or four spare bits
Dialogue: 0,0:54:10.40,0:54:11.68,csapp,,0,0,0,, that we can use in the header 
Dialogue: 0,0:54:12.06,0:54:14.14,csapp,,0,0,0,,so we can denote one of those as the mark bit 
Dialogue: 0,0:54:15.42,0:54:17.48,csapp,,0,0,0,,and then we are garbage collection 
Dialogue: 0,0:54:20.30,0:54:24.28,csapp,,0,0,0,,our garbage collection phase when we run out of space consists of two
Dialogue: 0,0:54:25.22,0:54:28.86,csapp,,0,0,0,, two different sub phases one is the mark phase which starts at all the roots 
Dialogue: 0,0:54:29.66,0:54:32.88,csapp,,0,0,0,,and then and it just traverses this from the roots
Dialogue: 0,0:54:32.88,0:54:36.00,csapp,,0,0,0,, it traverses the set of of nodes
Dialogue: 0,0:54:36.00,0:54:39.90,csapp,,0,0,0,, that are reachable from the root and it sets the mark bit in each each one of those nodes
Dialogue: 0,0:54:40.60,0:54:47.54,csapp,,0,0,0,,okay and then once after you finish marking all of the all of the reachable blocks 
Dialogue: 0,0:54:47.96,0:54:51.36,csapp,,0,0,0,,then you sweep through the entire heap starting at the very beginning of the heap 
Dialogue: 0,0:54:52.26,0:54:57.30,csapp,,0,0,0,,and you look for you look for all allocated blocks that aren't marked
Dialogue: 0,0:54:58.36,0:55:00.78,csapp,,0,0,0,,KB so they're not marked they're not reachable in their garbage
Dialogue: 0,0:55:02.88,0:55:10.96,csapp,,0,0,0,,so first so you do this so you sort of do - you do a search from the from the roots 
Dialogue: 0,0:55:10.98,0:55:12.94,csapp,,0,0,0,,and then you do a sweep of the entire heap
Dialogue: 0,0:55:18.14,0:55:22.52,csapp,,0,0,0,,so let's say before before mark we have before the marks 
Dialogue: 0,0:55:23.48,0:55:28.70,csapp,,0,0,0,,phase we have a heap that looks like this we have a single root that points to this block 
Dialogue: 0,0:55:29.78,0:55:34.92,csapp,,0,0,0,,and what we're going to do here we're always going to point to the payload right  of the of the block
Dialogue: 0,0:55:35.30,0:55:36.64,csapp,,0,0,0,, it's just a convention that we use 
Dialogue: 0,0:55:37.82,0:55:40.16,csapp,,0,0,0,,so we're pointing to the beginning of the block 
Dialogue: 0,0:55:40.78,0:55:46.18,csapp,,0,0,0,,because we know that it's we know that the the header is one one word behind it 
Dialogue: 0,0:55:47.90,0:55:50.60,csapp,,0,0,0,,and so let's say and in this case 
Dialogue: 0,0:55:52.34,0:55:55.50,csapp,,0,0,0,,the the edges denote pointers that are contained in the block
Dialogue: 0,0:55:55.86,0:55:58.58,csapp,,0,0,0,,so they're not the previous and next pointers that we were maintaining
Dialogue: 0,0:55:58.58,0:56:02.36,csapp,,0,0,0,, these are just pointers that the application has put into those blocks 
Dialogue: 0,0:56:03.62,0:56:08.08,csapp,,0,0,0,,so we have so here we have the root pointing to this the central block 
Dialogue: 0,0:56:08.94,0:56:12.96,csapp,,0,0,0,,and then there's an and there's a pointer that points to this block 
Dialogue: 0,0:56:12.96,0:56:15.62,csapp,,0,0,0,,and there's another pointer that points to this block and 
Dialogue: 0,0:56:16.18,0:56:18.76,csapp,,0,0,0,,and there's a pointer in this block that points to this block 
Dialogue: 0,0:56:20.72,0:56:22.00,csapp,,0,0,0,,so after we do the mark
Dialogue: 0,0:56:22.78,0:56:25.96,csapp,,0,0,0,, and we search this we search these and then
Dialogue: 0,0:56:26.52,0:56:30.58,csapp,,0,0,0,,all of the reachable blocks have the mark bit set which is denoted by pink
Dialogue: 0,0:56:31.80,0:56:36.56,csapp,,0,0,0,, and so then you see in that and then the the blocks that aren't aren't marked then we can free 
Dialogue: 0,0:56:38.74,0:56:39.82,csapp,,0,0,0,,and return to the free list
Dialogue: 0,0:56:43.32,0:56:48.48,csapp,,0,0,0,,okay so let's look at the assumptions for a simple implementation just to make make sure this is clear 
Dialogue: 0,0:56:49.60,0:56:55.28,csapp,,0,0,0,,so the application calls new to get a pointer to a block with with all the values cleared
Dialogue: 0,0:56:57.28,0:57:00.94,csapp,,0,0,0,, it calls read(b,i) to read location I of Block B
Dialogue: 0,0:57:01.74,0:57:08.14,csapp,,0,0,0,, and it uses write(b,i,v) to write a value V into location I of Block B
Dialogue: 0,0:57:09.08,0:57:13.06,csapp,,0,0,0,, then each block will have a header word which will address as b[-1]
Dialogue: 0,0:57:16.64,0:57:18.24,csapp,,0,0,0,, and then the garbage collector has
Dialogue: 0,0:57:19.58,0:57:24.06,csapp,,0,0,0,, it has functions that it uses to identify whether a pointer 
Dialogue: 0,0:57:24.50,0:57:27.34,csapp,,0,0,0,,whether its input parameter is indeed a pointer 
Dialogue: 0,0:57:27.54,0:57:30.48,csapp,,0,0,0,,okay so there's some way to distinguish a pointer from an on pointer 
Dialogue: 0,0:57:31.54,0:57:33.32,csapp,,0,0,0,,and it can get the length of some block 
Dialogue: 0,0:57:34.76,0:57:37.50,csapp,,0,0,0,,not including the header and it can get a set of all of the routes 
Dialogue: 0,0:57:41.56,0:57:44.32,csapp,,0,0,0,,so given those given those assumptions
Dialogue: 0,0:57:45.36,0:57:47.62,csapp,,0,0,0,, we our pseudocode for the mark step
Dialogue: 0,0:57:48.50,0:57:49.22,csapp,,0,0,0,, it takes
Dialogue: 0,0:57:50.98,0:57:54.98,csapp,,0,0,0,, so this initially is a is a pointer a route pointer 
Dialogue: 0,0:57:57.78,0:58:00.22,csapp,,0,0,0,,okay and then we check as our terminating condition 
Dialogue: 0,0:58:00.90,0:58:05.00,csapp,,0,0,0,,we check to see if that that input is indeed a pointer and if so we return
Dialogue: 0,0:58:07.18,0:58:11.80,csapp,,0,0,0,, okay and then then we do a depth-first traversal of the of the graph 
Dialogue: 0,0:58:12.72,0:58:13.32,csapp,,0,0,0,,so if 
Dialogue: 0,0:58:15.18,0:58:20.74,csapp,,0,0,0,,and this so we're doing a depth-first traversal of the graph and this is pointer is sort of our terminating condition for that 
Dialogue: 0,0:58:21.14,0:58:22.40,csapp,,0,0,0,,that depth-first traversal 
Dialogue: 0,0:58:24.24,0:58:27.96,csapp,,0,0,0,,then we check the mark bit and if it's set then that's another terminating condition 
Dialogue: 0,0:58:27.96,0:58:33.60,csapp,,0,0,0,,there's no there's no reason to search once we find a marked  marked node 
Dialogue: 0,0:58:34.62,0:58:37.84,csapp,,0,0,0,,we know that all of will from that node is is marked 
Dialogue: 0,0:58:37.94,0:58:41.82,csapp,,0,0,0,,so we we can terminate our return and just stop the search
Dialogue: 0,0:58:42.62,0:58:45.08,csapp,,0,0,0,, if it's not set then we set the mark bit 
Dialogue: 0,0:58:45.94,0:58:48.38,csapp,,0,0,0,,and then we look at each word in the block
Dialogue: 0,0:58:51.36,0:58:54.36,csapp,,0,0,0,,and we recursively call mark on each one of those words
Dialogue: 0,0:58:54.84,0:58:58.48,csapp,,0,0,0,, now each one of those words may or may not be a pointer right so if it's not a pointer
Dialogue: 0,0:58:59.40,0:59:02.80,csapp,,0,0,0,, then mark will just return instantly immediately 
Dialogue: 0,0:59:03.50,0:59:07.42,csapp,,0,0,0,,if it is a pointer then it will continue the recursive depth first search 
Dialogue: 0,0:59:09.16,0:59:14.52,csapp,,0,0,0,,okay so does that make make sense it's just familiar the familiar def first graph traversal bit
Dialogue: 0,0:59:16.28,0:59:17.32,csapp,,0,0,0,, that we all know about
Dialogue: 0,0:59:19.76,0:59:25.50,csapp,,0,0,0,,okay and then the sweep sweep takes a pointer to the beginning of the heap 
Dialogue: 0,0:59:25.66,0:59:28.36,csapp,,0,0,0,,the first it takes a pointer to the first block in the heap 
Dialogue: 0,0:59:28.90,0:59:31.28,csapp,,0,0,0,,and then some a pointer to the end of the heap 
Dialogue: 0,0:59:33.40,0:59:37.66,csapp,,0,0,0,,and then in a while loop then it scans the heap each block
Dialogue: 0,0:59:38.86,0:59:40.96,csapp,,0,0,0,, if the mark bit is set it clears it
Dialogue: 0,0:59:45.28,0:59:50.26,csapp,,0,0,0,,if it's if it's allocated it frees it right 
Dialogue: 0,0:59:53.64,0:59:57.30,csapp,,0,0,0,,and then it updates and then it gets the address of the the next block
Dialogue: 0,0:59:57.50,0:59:59.12,csapp,,0,0,0,,and then just continues until the end
Dialogue: 0,1:00:05.44,1:00:07.56,csapp,,0,0,0,,okay so how do we do such a thing in C right 
Dialogue: 0,1:00:07.56,1:00:12.26,csapp,,0,0,0,,because all of these assumptions I've made don't hold and C right you can't tell a pointer from an on pointer
Dialogue: 0,1:00:12.82,1:00:14.10,csapp,,0,0,0,,pointers can point anywhere 
Dialogue: 0,1:00:17.60,1:00:20.76,csapp,,0,0,0,,so what you could do so the big issue is that 
Dialogue: 0,1:00:22.42,1:00:23.80,csapp,,0,0,0,,if we get some value 
Dialogue: 0,1:00:26.92,1:00:31.80,csapp,,0,0,0,,we it even if it is a pointer it could point right into the middle of the block 
Dialogue: 0,1:00:34.84,1:00:35.76,csapp,,0,0,0,,so given that 
Dialogue: 0,1:00:36.44,1:00:40.24,csapp,,0,0,0,,so first of all we don't know if that value really is a pointer it could just be a big integer 
Dialogue: 0,1:00:40.98,1:00:44.14,csapp,,0,0,0,,but it also could be a pointer that's pointing into some data structure 
Dialogue: 0,1:00:45.52,1:00:50.28,csapp,,0,0,0,,so if it is a pointer how do we how do we find the beginning of the block 
Dialogue: 0,1:00:52.46,1:00:54.48,csapp,,0,0,0,,so what we could do is just assume that 
Dialogue: 0,1:00:55.12,1:00:56.56,csapp,,0,0,0,,every value is a pointer 
Dialogue: 0,1:00:57.34,1:01:01.08,csapp,,0,0,0,,and then we maintain a balance tree to keep track of all the allocated blocks 
Dialogue: 0,1:01:01.70,1:01:04.00,csapp,,0,0,0,,and so whenever we encounter a particular value
Dialogue: 0,1:01:04.72,1:01:09.34,csapp,,0,0,0,,we would search that binary tree to see if it if assuming it is a pointer
Dialogue: 0,1:01:09.50,1:01:14.26,csapp,,0,0,0,, if it falls within the the beginning and end of some allocated block 
Dialogue: 0,1:01:15.50,1:01:18.92,csapp,,0,0,0,,okay if if that condition is true then we assume that it's 
Dialogue: 0,1:01:19.42,1:01:21.74,csapp,,0,0,0,,pointing that that's a pointer to an allocated block 
Dialogue: 0,1:01:22.24,1:01:25.04,csapp,,0,0,0,,and we assume that that block is reachable 
Dialogue: 0,1:01:25.84,1:01:30.02,csapp,,0,0,0,, now the reason it's conservative is because it really may not be a pointer it might be this integer 
Dialogue: 0,1:01:30.36,1:01:32.78,csapp,,0,0,0,,and we'll we'll assume it's a pointer and assume that 
Dialogue: 0,1:01:33.26,1:01:36.56,csapp,,0,0,0,,the block that it purportedly points to is is allocated
Dialogue: 0,1:01:37.04,1:01:40.20,csapp,,0,0,0,,but it may in fact be not be a pointer and the block that
Dialogue: 0,1:01:40.70,1:01:41.78,csapp,,0,0,0,,  it points to is garbage 
Dialogue: 0,1:01:42.14,1:01:48.52,csapp,,0,0,0,,right so what with this with this scheme we would leave some some non non reachable blocks
Dialogue: 0,1:01:50.22,1:01:54.54,csapp,,0,0,0,, we will indicate that some non reachable blocks are are really reachable
Dialogue: 0,1:01:57.52,1:01:58.30,csapp,,0,0,0,,okay so 
Dialogue: 0,1:02:00.20,1:02:04.16,csapp,,0,0,0,,so once now that we've got this great tool to dynamically allocate memory 
Dialogue: 0,1:02:06.12,1:02:07.46,csapp,,0,0,0,,we can use it in our programs 
Dialogue: 0,1:02:08.06,1:02:10.64,csapp,,0,0,0,,and shoot ourselves in the foot in all different kinds of ways 
Dialogue: 0,1:02:10.86,1:02:16.14,csapp,,0,0,0,,okay so I'm going to I'm going to try to help  help you out here by identifying 
Dialogue: 0,1:02:16.66,1:02:24.28,csapp,,0,0,0,,some of the perils and pitfalls that that we can run into with with with memory related operations or operations on memory
Dialogue: 0,1:02:25.24,1:02:29.82,csapp,,0,0,0,, and opera errors errors involving memory 
Dialogue: 0,1:02:30.10,1:02:35.70,csapp,,0,0,0,,are the worst the worst kinds of bugs  to try to find out 
Dialogue: 0,1:02:36.96,1:02:39.98,csapp,,0,0,0,,and the reason is that they're distant in both space and time
Dialogue: 0,1:02:40.96,1:02:44.74,csapp,,0,0,0,,so let's say you write to the wrong memory location and corrupt some data structure
Dialogue: 0,1:02:46.00,1:02:48.42,csapp,,0,0,0,, the right doesn't elicit any error 
Dialogue: 0,1:02:49.08,1:02:53.44,csapp,,0,0,0,,you only find out about that illy that erroneous right 
Dialogue: 0,1:02:53.44,1:02:57.22,csapp,,0,0,0,,when you try to reference that data structure or that particular part of the data structure
Dialogue: 0,1:02:57.84,1:03:02.56,csapp,,0,0,0,,which may be in a part of the code that's way far away from the right that caused the problem 
Dialogue: 0,1:03:03.80,1:03:08.14,csapp,,0,0,0,,both in space you know in distance you know lines of code it could be a completely different function 
Dialogue: 0,1:03:08.14,1:03:09.68,csapp,,0,0,0,,and a completely different module 
Dialogue: 0,1:03:10.32,1:03:12.98,csapp,,0,0,0,,but also in time it may not you know you may do the right 
Dialogue: 0,1:03:13.18,1:03:16.36,csapp,,0,0,0,,and then eons later other some read and it fails 
Dialogue: 0,1:03:16.80,1:03:21.06,csapp,,0,0,0,,right so this is a fundamental thing that makes memory related bugs just so nasty
Dialogue: 0,1:03:23.76,1:03:28.42,csapp,,0,0,0,,and another big thing another thing that makes them hard to deal with
Dialogue: 0,1:03:28.88,1:03:33.16,csapp,,0,0,0,, is people's misunderstanding and misuse of pointers right 
Dialogue: 0,1:03:33.16,1:03:35.26,csapp,,0,0,0,,so usually an erroneous right is some is 
Dialogue: 0,1:03:36.08,1:03:41.72,csapp,,0,0,0,,some either a misunderstanding of pointers or an improperly initialized pointer
Dialogue: 0,1:03:42.10,1:03:43.98,csapp,,0,0,0,, so it all boils down to these pointers 
Dialogue: 0,1:03:48.10,1:03:51.10,csapp,,0,0,0,,okay and so I'm going to show you how to understand pointers 
Dialogue: 0,1:03:52.76,1:03:53.98,csapp,,0,0,0,,okay for the first time in your lives
Dialogue: 0,1:03:56.76,1:03:58.64,csapp,,0,0,0,,I don't know about you but when I learned C
Dialogue: 0,1:04:01.28,1:04:02.38,csapp,,0,0,0,, I learned about pointers
Dialogue: 0,1:04:02.60,1:04:07.50,csapp,,0,0,0,,I just knew about what a few different types of pointers  were by and I did it by pattern matching
Dialogue: 0,1:04:08.16,1:04:11.72,csapp,,0,0,0,, so I knew that int *p was a pointer to an int 
Dialogue: 0,1:04:12.56,1:04:15.64,csapp,,0,0,0,,I knew that int **p was was an array
Dialogue: 0,1:04:16.48,1:04:18.02,csapp,,0,0,0,,I knew that int *p 
Dialogue: 0,1:04:18.66,1:04:24.48,csapp,,0,0,0,,open bracket closed bracket was also an array just a different way to  express that array 
Dialogue: 0,1:04:24.48,1:04:28.76,csapp,,0,0,0,,so I had a small handful of pointers types that I could deal with 
Dialogue: 0,1:04:29.36,1:04:33.98,csapp,,0,0,0,, but I had no underlying understanding of what that meant or anything was just pure pattern matching 
Dialogue: 0,1:04:34.98,1:04:36.68,csapp,,0,0,0,,and I'll bet you that's the way you do it too 
Dialogue: 0,1:04:38.40,1:04:40.28,csapp,,0,0,0,,all right but that's all going to change today
Dialogue: 0,1:04:41.90,1:04:42.58,csapp,,0,0,0,,all right so
Dialogue: 0,1:04:43.94,1:04:45.84,csapp,,0,0,0,, in order to really understand pointers 
Dialogue: 0,1:04:46.80,1:04:51.54,csapp,,0,0,0,,you need to understand the precedence of various operators in C 
Dialogue: 0,1:04:52.70,1:04:56.02,csapp,,0,0,0,,because the pointer types are declared using these operators 
Dialogue: 0,1:04:56.70,1:05:01.08,csapp,,0,0,0,, and so my copy of K and R is it has a dog-eared at page 53 
Dialogue: 0,1:05:01.48,1:05:04.34,csapp,,0,0,0,, this table comes from page 53 of knr 
Dialogue: 0,1:05:05.12,1:05:09.22,csapp,,0,0,0,,and you should have a paper clip or have that folded over for reference 
Dialogue: 0,1:05:10.66,1:05:12.42,csapp,,0,0,0,, now the thing to notice is that 
Dialogue: 0,1:05:13.62,1:05:18.46,csapp,,0,0,0,,function and array and then and these struct these various struct operators
Dialogue: 0,1:05:18.96,1:05:21.46,csapp,,0,0,0,,  have the highest priority highest precedence 
Dialogue: 0,1:05:23.86,1:05:29.58,csapp,,0,0,0,,and that and then that's followed by unary operators so the star this is the dereference operator 
Dialogue: 0,1:05:29.58,1:05:32.46,csapp,,0,0,0,,and then the the address of operator 
Dialogue: 0,1:05:33.60,1:05:36.00,csapp,,0,0,0,,the they fall right below 
Dialogue: 0,1:05:37.34,1:05:40.76,csapp,,0,0,0,,the highest the highest precedence operators 
Dialogue: 0,1:05:41.34,1:05:47.58,csapp,,0,0,0,,and then the binary versions of operators you know that you use in arithmetic operations are below those
Dialogue: 0,1:05:48.72,1:05:49.74,csapp,,0,0,0,,okay so just remember 
Dialogue: 0,1:05:50.64,1:05:54.46,csapp,,0,0,0,,that function and array is higher than star 
Dialogue: 0,1:05:56.80,1:05:58.16,csapp,,0,0,0,,that too deep the dereference 
Dialogue: 0,1:06:00.34,1:06:04.96,csapp,,0,0,0,,now the great thing about pointers although they always seem really complicated
Dialogue: 0,1:06:05.86,1:06:07.86,csapp,,0,0,0,, is that there's there's an algorithm for 
Dialogue: 0,1:06:09.22,1:06:10.70,csapp,,0,0,0,,it for there's an algorithm for 
Dialogue: 0,1:06:11.66,1:06:15.90,csapp,,0,0,0,,constructing an English sentence that explains exactly what what that pointer 
Dialogue: 0,1:06:17.04,1:06:20.54,csapp,,0,0,0,,what that definition of the pointer means 
Dialogue: 0,1:06:21.48,1:06:25.32,csapp,,0,0,0,,okay and if you're interested it's in the KN are in Section 5.12
Dialogue: 0,1:06:26.38,1:06:28.60,csapp,,0,0,0,,but I'll I'll explain it to you now 
Dialogue: 0,1:06:29.80,1:06:33.58,csapp,,0,0,0,, now I don't know I don't know how much in this class you're going to remember
Dialogue: 0,1:06:34.74,1:06:38.66,csapp,,0,0,0,, okay but I guarantee you're going to remember this as the day you finally understood pointers okay 
Dialogue: 0,1:06:38.82,1:06:39.06,csapp,,0,0,0,,so all
Dialogue: 0,1:06:43.37,1:06:44.45,csapp,,0,0,0,,right so here's how it works
Dialogue: 0,1:06:45.28,1:06:49.62,csapp,,0,0,0,,you always start it the this is a definition of a pointer some kind 
Dialogue: 0,1:06:50.80,1:06:54.52,csapp,,0,0,0,,you always start  with the variable name 
Dialogue: 0,1:07:01.20,1:07:02.68,csapp,,0,0,0,,and then you use your precedence t
Dialogue: 0,1:07:03.08,1:07:06.46,csapp,,0,0,0,,then you look for operators on either side of that variable name
Dialogue: 0,1:07:06.54,1:07:08.66,csapp,,0,0,0,, and you choose the one that has the highest precedence 
Dialogue: 0,1:07:10.66,1:07:15.86,csapp,,0,0,0,, okay so we start with the variable so we say P  is a
Dialogue: 0,1:07:17.04,1:07:18.62,csapp,,0,0,0,, then we look to the left and the right 
Dialogue: 0,1:07:18.62,1:07:22.36,csapp,,0,0,0,,there's nothing to the right but there's a there's a pointer symbol to the left 
Dialogue: 0,1:07:22.38,1:07:25.12,csapp,,0,0,0,,so we say P is a pointer 
Dialogue: 0,1:07:25.66,1:07:30.32,csapp,,0,0,0,,and there's nothing more and then we always end up with the the type of thing that it points that 
Dialogue: 0,1:07:31.06,1:07:33.58,csapp,,0,0,0,,so P is a pointer to an int
Dialogue: 0,1:07:43.70,1:07:44.76,csapp,,0,0,0,,right so P is 
Dialogue: 0,1:07:46.50,1:07:50.76,csapp,,0,0,0,,P as a pointer to some to some integer in memory okay 
Dialogue: 0,1:07:50.94,1:07:52.44,csapp,,0,0,0,,so we all know that one that's pretty easy 
Dialogue: 0,1:07:53.64,1:07:54.64,csapp,,0,0,0,,okay what about the next one 
Dialogue: 0,1:07:56.04,1:07:57.76,csapp,,0,0,0,,you've probably seen something like this
Dialogue: 0,1:07:59.32,1:08:02.24,csapp,,0,0,0,,some programs declare our V using this notation 
Dialogue: 0,1:08:04.34,1:08:06.92,csapp,,0,0,0,,and so this you can have an optional size or not 
Dialogue: 0,1:08:10.38,1:08:13.80,csapp,,0,0,0,,so so we always start out we say P is a 
Dialogue: 0,1:08:15.22,1:08:17.69,csapp,,0,0,0,,well now in this case there's operators to the left and the right
Dialogue: 0,1:08:18.04,1:08:24.86,csapp,,0,0,0,,remember the array operator has higher precedence than the the the dereferencing operator the pointer operators 
Dialogue: 0,1:08:24.88,1:08:34.20,csapp,,0,0,0,,so we say so P is an array 13 array of size 13  of
Dialogue: 0,1:08:35.64,1:08:39.04,csapp,,0,0,0,,so there's nothing more so we go to the left  of pointers 
Dialogue: 0,1:08:39.56,1:08:44.10,csapp,,0,0,0,,so P is an array 13 of pointers to ints
Dialogue: 0,1:08:51.08,1:08:52.58,csapp,,0,0,0,,so P is an array
Dialogue: 0,1:08:57.20,1:08:58.46,csapp,,0,0,0,, of 13 pointers 
Dialogue: 0,1:09:00.42,1:09:04.02,csapp,,0,0,0,,each of which points to an int 
Dialogue: 0,1:09:05.14,1:09:07.62,csapp,,0,0,0,,right in this case P is just the name of the array 
Dialogue: 0,1:09:08.32,1:09:09.78,csapp,,0,0,0,,so by default P 
Dialogue: 0,1:09:10.62,1:09:14.50,csapp,,0,0,0,,P is a is equivalent is the address of the array 
Dialogue: 0,1:09:14.70,1:09:21.42,csapp,,0,0,0,,when you reference an array name you're you're you're addressing your ax dressing the address of the first element 
Dialogue: 0,1:09:23.84,1:09:24.96,csapp,,0,0,0,,okay how about the next one 
Dialogue: 0,1:09:27.22,1:09:30.96,csapp,,0,0,0,,here we're being if we put parentheses around things then we can be explicit
Dialogue: 0,1:09:31.22,1:09:32.44,csapp,,0,0,0,, okay and this is a good practice 
Dialogue: 0,1:09:33.60,1:09:34.94,csapp,,0,0,0,,so here we're saying P 
Dialogue: 0,1:09:35.52,1:09:38.00,csapp,,0,0,0,,and we have to look at this one first because of the parentheses 
Dialogue: 0,1:09:39.30,1:09:43.02,csapp,,0,0,0,, so P is an array thirteen of pointers to ints
Dialogue: 0,1:09:43.28,1:09:44.26,csapp,,0,0,0,,so that's the same thing 
Dialogue: 0,1:09:44.80,1:09:46.36,csapp,,0,0,0,,and here we're just being more explicit 
Dialogue: 0,1:09:47.38,1:09:48.86,csapp,,0,0,0,,now what about **p
Dialogue: 0,1:09:50.70,1:09:55.22,csapp,,0,0,0,,so P is a pointer to a pointer to an int
Dialogue: 0,1:09:56.84,1:09:58.58,csapp,,0,0,0,,okay so this is a different type of array
Dialogue: 0,1:10:02.10,1:10:03.42,csapp,,0,0,0,,so P is a pointer 
Dialogue: 0,1:10:05.96,1:10:06.86,csapp,,0,0,0,,to a pointer 
Dialogue: 0,1:10:08.86,1:10:09.38,csapp,,0,0,0,,to an int 
Dialogue: 0,1:10:10.90,1:10:13.30,csapp,,0,0,0,,okay and 
Dialogue: 0,1:10:15.16,1:10:17.46,csapp,,0,0,0,,and typically so this is another way to do arrays 
Dialogue: 0,1:10:20.66,1:10:23.60,csapp,,0,0,0,,so the same way the char star points to a string 
Dialogue: 0,1:10:24.64,1:10:26.36,csapp,,0,0,0,,this this can point
Dialogue: 0,1:10:27.18,1:10:31.72,csapp,,0,0,0,, it points to it points to a pointer but then you can index on that
Dialogue: 0,1:10:32.38,1:10:36.86,csapp,,0,0,0,,each one of those then points corresponds to a pointer
Dialogue: 0,1:10:40.70,1:10:42.02,csapp,,0,0,0,,whoops okay 
Dialogue: 0,1:10:43.98,1:10:48.46,csapp,,0,0,0,,here's another one now P because and because of the parentheses we have to go left 
Dialogue: 0,1:10:48.46,1:10:52.48,csapp,,0,0,0,,so P is a pointer to an array thirteen of ints
Dialogue: 0,1:10:56.42,1:11:02.06,csapp,,0,0,0,,okay so P is an appointee to an array of 13 ints
Dialogue: 0,1:11:11.84,1:11:12.92,csapp,,0,0,0,,right now what about this one
Dialogue: 0,1:11:14.62,1:11:17.82,csapp,,0,0,0,, f is a function or RF
Dialogue: 0,1:11:19.18,1:11:21.00,csapp,,0,0,0,, is it a function or a pointer 
Dialogue: 0,1:11:22.78,1:11:24.84,csapp,,0,0,0,,F is a function right because of the precedence 
Dialogue: 0,1:11:25.44,1:11:30.26,csapp,,0,0,0,,so f is if f is a function returning pointer to int okay
Dialogue: 0,1:11:32.70,1:11:33.76,csapp,,0,0,0,,ok so if we go
Dialogue: 0,1:11:35.98,1:11:37.18,csapp,,0,0,0,, if we go P equal F
Dialogue: 0,1:11:39.40,1:11:43.70,csapp,,0,0,0,, then that returns that initialized P to point to some int
Dialogue: 0,1:11:49.92,1:11:50.66,csapp,,0,0,0,,all right 
Dialogue: 0,1:11:52.64,1:11:56.20,csapp,,0,0,0,,and I'm going to do this one let's jump down in the interest of time
Dialogue: 0,1:11:57.46,1:12:01.66,csapp,,0,0,0,,totally ridiculous case just so you can see that this algorithm works
Dialogue: 0,1:12:02.58,1:12:07.96,csapp,,0,0,0,,all right so X is an array of pointers
Dialogue: 0,1:12:09.72,1:12:14.62,csapp,,0,0,0,,to functions returning pointers 
Dialogue: 0,1:12:16.26,1:12:17.56,csapp,,0,0,0,,to an array five events 
Dialogue: 0,1:12:19.44,1:12:21.68,csapp,,0,0,0,,and if you ever use anything like that in your code 
Dialogue: 0,1:12:22.72,1:12:23.44,csapp,,0,0,0,,shame on you
Dialogue: 0,1:12:26.26,1:12:27.64,csapp,,0,0,0,,all right so there you go so that's
Dialogue: 0,1:12:28.22,1:12:30.06,csapp,,0,0,0,, now you know now you understand pointers
Dialogue: 0,1:12:30.32,1:12:34.82,csapp,,0,0,0,,simple as can be and all you need is page 53 of knr is a handy reference
Dialogue: 0,1:12:36.24,1:12:39.36,csapp,,0,0,0,, all right so let's we'll take the last five minutes and I'll show you some 
Dialogue: 0,1:12:40.70,1:12:42.40,csapp,,0,0,0,,some of the ways you can trip yourself up 
Dialogue: 0,1:12:43.04,1:12:44.22,csapp,,0,0,0,,when you're accessing memory
Dialogue: 0,1:12:44.82,1:12:47.04,csapp,,0,0,0,,okay so first is the classic scanf bug
Dialogue: 0,1:12:47.12,1:12:51.56,csapp,,0,0,0,,you probably you've probably all done this where you forget to pass it the address of 
Dialogue: 0,1:12:52.42,1:12:55.44,csapp,,0,0,0,,a variable instead you pass it the address
Dialogue: 0,1:12:56.82,1:13:02.96,csapp,,0,0,0,, so scanf doesn't know where to put the you know put the put the data
Dialogue: 0,1:13:04.52,1:13:07.68,csapp,,0,0,0,,okay another another common mistake is to read uninitialized memory 
Dialogue: 0,1:13:07.68,1:13:10.90,csapp,,0,0,0,,so suit you can't really assume that your heap data is initialized to 0 
Dialogue: 0,1:13:11.96,1:13:16.82,csapp,,0,0,0,,so here we're we're Malachy an array of an ints
Dialogue: 0,1:13:17.24,1:13:18.72,csapp,,0,0,0,,and then we're going through and we're doing
Dialogue: 0,1:13:19.12,1:13:20.78,csapp,,0,0,0,,we're updating this vector
Dialogue: 0,1:13:21.54,1:13:24.82,csapp,,0,0,0,, this Y vector we're reading y[i]
Dialogue: 0,1:13:25.54,1:13:29.90,csapp,,0,0,0,,we're taking y[i] = y[i] + A[i][j]*x[j]
Dialogue: 0,1:13:30.42,1:13:37.68,csapp,,0,0,0,,okay so we're using we're assuming that Y that malloc returns memory that's all zeros 
Dialogue: 0,1:13:38.22,1:13:39.06,csapp,,0,0,0,,so that'll get you
Dialogue: 0,1:13:42.30,1:13:46.34,csapp,,0,0,0,,it's also easy to allocate the wrong sized object 
Dialogue: 0,1:13:47.08,1:13:48.26,csapp,,0,0,0,, so here we want to create 
Dialogue: 0,1:13:49.60,1:13:54.48,csapp,,0,0,0,,an array  of n pointers of n pointers to ints
Dialogue: 0,1:13:56.06,1:13:58.88,csapp,,0,0,0,,okay and then for each one we want to allocate M ints 
Dialogue: 0,1:13:59.04,1:14:01.86,csapp,,0,0,0,,all right so this work we're creating a two-dimensional array 
Dialogue: 0,1:14:03.64,1:14:05.40,csapp,,0,0,0,,and can you see the mistake which
Dialogue: 0,1:14:10.42,1:14:12.06,csapp,,0,0,0,,which line is buggy this one 
Dialogue: 0,1:14:17.72,1:14:19.26,csapp,,0,0,0,,this one or this one
Dialogue: 0,1:14:20.76,1:14:23.42,csapp,,0,0,0,, the first one right because we really want size event star 
Dialogue: 0,1:14:24.40,1:14:29.30,csapp,,0,0,0,,right so we're we're erroneous incorrectly assuming that intz are the same sizes as pointers
Dialogue: 0,1:14:30.84,1:14:32.26,csapp,,0,0,0,, this is a classic 
Dialogue: 0,1:14:33.60,1:14:36.10,csapp,,0,0,0,,on this this assumption is true for 32-bit code 
Dialogue: 0,1:14:36.24,1:14:39.60,csapp,,0,0,0,,ints and pointers are the same size but it's not true for 64-bit 
Dialogue: 0,1:14:40.06,1:14:47.82,csapp,,0,0,0,,and so this is why when you when you port when people port 32-bit code to 64-bit machine a lot of times it breaks 
Dialogue: 0,1:14:48.20,1:14:49.50,csapp,,0,0,0,,because they have this assumption 
Dialogue: 0,1:14:51.28,1:14:54.42,csapp,,0,0,0,,okay another way you it's easy to overwrite memory 
Dialogue: 0,1:14:55.28,1:14:59.18,csapp,,0,0,0,,so here we're creating correctly creating this array
Dialogue: 0,1:14:59.56,1:15:02.74,csapp,,0,0,0,,but then when we create each of the each of the sub arrays 
Dialogue: 0,1:15:04.38,1:15:06.88,csapp,,0,0,0,,instead of I less than or equal to n we're actually 
Dialogue: 0,1:15:07.22,1:15:10.58,csapp,,0,0,0,,we only created n of these things but we're traversing n + 1
Dialogue: 0,1:15:10.64,1:15:12.00,csapp,,0,0,0,, because of this less than or equal 
Dialogue: 0,1:15:12.32,1:15:13.96,csapp,,0,0,0,,so this is a classic off by one bug
Dialogue: 0,1:15:16.68,1:15:21.56,csapp,,0,0,0,, ok another another problem you saw it with the code injection attacks from your attack lab
Dialogue: 0,1:15:21.94,1:15:24.06,csapp,,0,0,0,, not checking the the size of a buffer 
Dialogue: 0,1:15:24.66,1:15:28.10,csapp,,0,0,0,,so get get ass is a classic example of this 
Dialogue: 0,1:15:28.84,1:15:30.02,csapp,,0,0,0,,so that will get you into trouble 
Dialogue: 0,1:15:32.34,1:15:35.88,csapp,,0,0,0,,another another classic mistake is misunderstanding pointer arithmetic 
Dialogue: 0,1:15:36.57,1:15:38.16,csapp,,0,0,0,,all right so if you increment a pointer 
Dialogue: 0,1:15:41.22,1:15:46.90,csapp,,0,0,0,,then it point it's incremented by the size of the object that pointer points to 
Dialogue: 0,1:15:48.16,1:15:51.08,csapp,,0,0,0,,right so if you increment an int star  by one 
Dialogue: 0,1:15:51.60,1:15:53.42,csapp,,0,0,0,,it actually increments it by four 
Dialogue: 0,1:15:54.20,1:15:55.36,csapp,,0,0,0,,because that's the size of an int 
Dialogue: 0,1:15:58.04,1:16:00.24,csapp,,0,0,0,,he's got that's a really important distinction 
Dialogue: 0,1:16:00.86,1:16:03.14,csapp,,0,0,0,,and so people will often 
Dialogue: 0,1:16:03.94,1:16:07.22,csapp,,0,0,0,,so here it's assuming that incrementing so P is a pointer 
Dialogue: 0,1:16:07.84,1:16:12.00,csapp,,0,0,0,,and the programmer here assumed that he wants to increment the pointer to sort of traverse it 
Dialogue: 0,1:16:12.36,1:16:15.40,csapp,,0,0,0,,an array so he he doesn't understand pointer arithmetic 
Dialogue: 0,1:16:16.00,1:16:21.04,csapp,,0,0,0,,and so to get to the next in increments  P by size event 
Dialogue: 0,1:16:21.62,1:16:24.68,csapp,,0,0,0,,okay this will really increment it by sixteen not by four 
Dialogue: 0,1:16:27.70,1:16:30.72,csapp,,0,0,0,, okay overriding memory that's a really nasty one 
Dialogue: 0,1:16:31.60,1:16:38.96,csapp,,0,0,0,,and a lot of times this can happen if you don't understand the precedence of the of the operators 
Dialogue: 0,1:16:38.96,1:16:39.90,csapp,,0,0,0,,that you're working with 
Dialogue: 0,1:16:40.66,1:16:44.76,csapp,,0,0,0,,so this is a heap not not too kind of heap we've been talking about but oh the heap data structure 
Dialogue: 0,1:16:45.38,1:16:48.30,csapp,,0,0,0,,and this is a this is a function to delete from a heap 
Dialogue: 0,1:16:48.30,1:16:50.84,csapp,,0,0,0,,and this actually is from my own code I have to admit 
Dialogue: 0,1:16:52.44,1:16:57.44,csapp,,0,0,0,, and so I wanted to leave I want to delete in it an element
Dialogue: 0,1:16:58.78,1:17:00.62,csapp,,0,0,0,, I want to delete the first element of the heap 
Dialogue: 0,1:17:01.18,1:17:03.20,csapp,,0,0,0,,right and then I want to reify it 
Dialogue: 0,1:17:04.10,1:17:06.98,csapp,,0,0,0,,okay so I and then I want to return I want to return that 
Dialogue: 0,1:17:07.68,1:17:09.90,csapp,,0,0,0,,so I I get the first element the heap
Dialogue: 0,1:17:10.98,1:17:14.62,csapp,,0,0,0,, I that the size of the heap 
Dialogue: 0,1:17:15.11,1:17:18.58,csapp,,0,0,0,,or I take the the last element and make that the first element 
Dialogue: 0,1:17:21.96,1:17:25.18,csapp,,0,0,0,,and and now I want to decrease the size of the heap 
Dialogue: 0,1:17:25.88,1:17:29.44,csapp,,0,0,0,,because this delete operation will will delete the heap size by one 
Dialogue: 0,1:17:30.70,1:17:33.06,csapp,,0,0,0,,so notice here we passed size n as a pointer 
Dialogue: 0,1:17:34.00,1:17:35.92,csapp,,0,0,0,,and when this when this function terminate 
Dialogue: 0,1:17:35.92,1:17:40.52,csapp,,0,0,0,,when this function return size should be updated dated size as a pointer
Dialogue: 0,1:17:40.56,1:17:42.76,csapp,,0,0,0,, the value that it points to you should be decremented
Dialogue: 0,1:17:43.22,1:17:44.06,csapp,,0,0,0,,okay that's our intent 
Dialogue: 0,1:17:44.74,1:17:47.72,csapp,,0,0,0,,and we do it right here with the size minus minus star
Dialogue: 0,1:17:47.72,1:17:50.58,csapp,,0,0,0,, so what we want to do is we want to dereference size 
Dialogue: 0,1:17:51.76,1:17:53.20,csapp,,0,0,0,,and then decrement that value 
Dialogue: 0,1:17:54.36,1:18:02.92,csapp,,0,0,0,,but because the unary minus minus has higher of precedence than then the dereference 
Dialogue: 0,1:18:03.70,1:18:06.74,csapp,,0,0,0,,what we're really doing is we're decrementing the pointer 
Dialogue: 0,1:18:07.16,1:18:09.04,csapp,,0,0,0,,and then dereferencing the value that's 
Dialogue: 0,1:18:10.30,1:18:14.78,csapp,,0,0,0,,one word less than our size variable
Dialogue: 0,1:18:15.00,1:18:16.24,csapp,,0,0,0,, all right so these are nasty 
Dialogue: 0,1:18:16.92,1:18:18.94,csapp,,0,0,0,,and it would have been much cleaner
Dialogue: 0,1:18:20.02,1:18:26.16,csapp,,0,0,0,, if I had just put parentheses around like I intended just parentheses star sized parentheses
Dialogue: 0,1:18:27.98,1:18:32.96,csapp,,0,0,0,,alright another another way you can mess up is referencing forgetting the local variables disappear 
Dialogue: 0,1:18:33.68,1:18:38.16,csapp,,0,0,0,,so if you have a function that returns an address of a local variable no good 
Dialogue: 0,1:18:38.76,1:18:40.40,csapp,,0,0,0,,okay no good at all
Dialogue: 0,1:18:41.46,1:18:46.36,csapp,,0,0,0,,it might be okay for a while until somebody another function  reuses that space
Dialogue: 0,1:18:46.84,1:18:51.02,csapp,,0,0,0,, that could be a return address it could be another another functions local variable 
Dialogue: 0,1:18:54.72,1:18:58.78,csapp,,0,0,0,, another terrible mistake this is a really bad one is freeing a block multiple time 
Dialogue: 0,1:18:59.32,1:19:02.26,csapp,,0,0,0,,now you know from from your understanding now of malloc
Dialogue: 0,1:19:02.64,1:19:07.36,csapp,,0,0,0,, that free actually writes to the heap right it's coalescing it's changing pointers
Dialogue: 0,1:19:07.86,1:19:09.36,csapp,,0,0,0,,it's changing size block sizes 
Dialogue: 0,1:19:10.02,1:19:13.78,csapp,,0,0,0,,so if you free a block that's already been freed terrible things will happen 
Dialogue: 0,1:19:17.36,1:19:21.78,csapp,,0,0,0,,another thing you can do wrong is to reference a block you forget that you freed a block and then you reference 
Dialogue: 0,1:19:22.04,1:19:24.24,csapp,,0,0,0,,it so here we free of this block X 
Dialogue: 0,1:19:25.02,1:19:26.32,csapp,,0,0,0,,and then we're referencing it here 
Dialogue: 0,1:19:28.42,1:19:30.10,csapp,,0,0,0,,another another big problem is 
Dialogue: 0,1:19:30.64,1:19:34.30,csapp,,0,0,0,,memory leaks so failing to free block so allocating some block
Dialogue: 0,1:19:34.86,1:19:36.40,csapp,,0,0,0,,function and then returning
Dialogue: 0,1:19:36.96,1:19:39.48,csapp,,0,0,0,, that block will stay there forever right because it's garbage
Dialogue: 0,1:19:43.58,1:19:47.20,csapp,,0,0,0,,okay so there's a there's a number of ways to deal with memory bugs 
Dialogue: 0,1:19:47.20,1:19:51.86,csapp,,0,0,0,, gdb is sometimes good at least it'll tell you where a seg fault occurs
Dialogue: 0,1:19:52.52,1:19:54.48,csapp,,0,0,0,, then you got to track down what the right that
Dialogue: 0,1:19:55.22,1:19:56.78,csapp,,0,0,0,, sort of caused that seg fault 
Dialogue: 0,1:19:58.64,1:19:59.92,csapp,,0,0,0,,the best thing you can do 
Dialogue: 0,1:20:00.56,1:20:06.18,csapp,,0,0,0,,but gdb falls down whenever you're doing manipulation of complex data structures
Dialogue: 0,1:20:06.82,1:20:09.54,csapp,,0,0,0,,it's just simple sort of looking one instruction at a time 
Dialogue: 0,1:20:10.00,1:20:14.74,csapp,,0,0,0,,what you really need to do is identify any complex data structure like a heap for example 
Dialogue: 0,1:20:15.62,1:20:20.10,csapp,,0,0,0,,is identify invariance for that structure that that data structure should always maintain 
Dialogue: 0,1:20:21.08,1:20:22.34,csapp,,0,0,0,,and then you write a function
Dialogue: 0,1:20:22.68,1:20:27.34,csapp,,0,0,0,,that iterates over that structure that data structure and checks that all those they're invariants are true 
Dialogue: 0,1:20:28.06,1:20:30.34,csapp,,0,0,0,,so for example in it 
Dialogue: 0,1:20:31.14,1:20:34.50,csapp,,0,0,0,,and in allocator one of the invariance is that there should be no 
Dialogue: 0,1:20:35.52,1:20:37.82,csapp,,0,0,0,,that there should never be two contiguous free blocks
Dialogue: 0,1:20:38.14,1:20:44.52,csapp,,0,0,0,, right so your your consistency checker should go through the heap and make sure there's no no contiguous free blocks 
Dialogue: 0,1:20:45.26,1:20:50.36,csapp,,0,0,0,,or another invariant is that every free block should be in a free list somewhere 
Dialogue: 0,1:20:51.32,1:20:57.04,csapp,,0,0,0,,right so you would you would you would up your consistency checker would scan the heap count the number of free blocks 
Dialogue: 0,1:20:57.56,1:20:59.44,csapp,,0,0,0,,and then scan the free list and make sure 
Dialogue: 0,1:20:59.80,1:21:03.32,csapp,,0,0,0,,that the number of blocks in the free list is the same as the number of free blocks
Dialogue: 0,1:21:04.24,1:21:07.58,csapp,,0,0,0,,okay so this idea of a consistency checker is something you'll use in your malloc lamp 
Dialogue: 0,1:21:07.80,1:21:11.06,csapp,,0,0,0,,but it's something it's also something you should you should use
Dialogue: 0,1:21:11.06,1:21:13.92,csapp,,0,0,0,,whenever you're updating any kind of complex data structure 
Dialogue: 0,1:21:16.08,1:21:20.04,csapp,,0,0,0,,and the and you know about valgrind but the great thing about these heap checkers 
Dialogue: 0,1:21:20.54,1:21:22.10,csapp,,0,0,0,,ok I'm passionate about heap checkers 
Dialogue: 0,1:21:23.15,1:21:24.26,csapp,,0,0,0,,or consistency checkers 
Dialogue: 0,1:21:25.28,1:21:29.38,csapp,,0,0,0,,the really powerful thing about them is you write them to run silently 
Dialogue: 0,1:21:30.64,1:21:35.48,csapp,,0,0,0,,they don't print anything unless they find that a violation of the invariance
Dialogue: 0,1:21:36.50,1:21:40.12,csapp,,0,0,0,, if you write your consistency checker like this then you can use it like a probe 
Dialogue: 0,1:21:40.94,1:21:42.30,csapp,,0,0,0,,so your program crashes
Dialogue: 0,1:21:43.22,1:21:47.54,csapp,,0,0,0,, so you do it you use this heap checker to do a binary search to isolate the cause
Dialogue: 0,1:21:48.30,1:21:52.42,csapp,,0,0,0,,so you know you put your you put your heap checker here 
Dialogue: 0,1:21:52.96,1:21:54.06,csapp,,0,0,0,,everything is ok 
Dialogue: 0,1:21:54.40,1:21:56.08,csapp,,0,0,0,,and then later the program crash
Dialogue: 0,1:21:56.96,1:21:58.76,csapp,,0,0,0,,so now you stick the heap checker here
Dialogue: 0,1:22:00.02,1:22:04.32,csapp,,0,0,0,,and now it crash the heap checker detects an in violation 
Dialogue: 0,1:22:04.58,1:22:06.98,csapp,,0,0,0,,so you know that the problem is somewhere here 
Dialogue: 0,1:22:06.98,1:22:09.44,csapp,,0,0,0,,and you can just keep narrowing it down so it's just like a probe 
Dialogue: 0,1:22:09.96,1:22:12.92,csapp,,0,0,0,,surgical probe that you can use to to track down bugs 
Dialogue: 0,1:22:14.28,1:22:15.76,csapp,,0,0,0,,and so that's if you do this like it's 
Dialogue: 0,1:22:17.06,1:22:20.60,csapp,,0,0,0,,I don't know how anybody debugs malik without this kind of tool 
Dialogue: 0,1:22:24.92,1:22:26.70,csapp,,0,0,0,,okay so that's it for today 
Dialogue: 0,1:22:28.70,1:22:30.54,csapp,,0,0,0,,have a good weekend we'll see you on Tuesday
