[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video File: ../../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.007812
Scroll Position: 858
Active Line: 862

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:04.92,English,,0,0,0,,So we've now gotten through all the lectures on machine code
Dialogue: 0,0:00:04.92,0:00:07.00,English,,0,0,0,,And we're starting to talk about...
Dialogue: 0,0:00:07.34,0:00:10.12,English,,0,0,0,,Okay now that you know this stuff what can you do with it
Dialogue: 0,0:00:10.88,0:00:14.30,English,,0,0,0,,And this lecture is along the lines of that
Dialogue: 0,0:00:14.30,0:00:17.64,English,,0,0,0,,This is sort of what you are now empowered to do now that
Dialogue: 0,0:00:17.64,0:00:21.06,English,,0,0,0,,You can look at an understand machine code
Dialogue: 0,0:00:21.44,0:00:26.20,English,,0,0,0,,This material is a little this actually there's a whole chapter
Dialogue: 0,0:00:26.20,0:00:29.10,English,,0,0,0,,Of the book chapter five on performance optimization
Dialogue: 0,0:00:29.10,0:00:33.11,English,,0,0,0,,And we're only going to do one lecture on it and we don't have any labs
Dialogue: 0,0:00:33.28,0:00:38.36,English,,0,0,0,,Unfortunately that really get you to push your limits on this which is too bad
Dialogue: 0,0:00:38.36,0:00:43.08,English,,0,0,0,,Because it's a very interesting topic and one I think you'd find yourself well equipped for
Dialogue: 0,0:00:43.56,0:00:50.26,English,,0,0,0,,There are typically a few small exam problems that are sort of based on some of the material here
Dialogue: 0,0:00:50.26,0:00:52.12,English,,0,0,0,,You'll find in old exams
Dialogue: 0,0:00:52.72,0:00:56.02,English,,0,0,0,,But really the idea is how can I make programs run fast
Dialogue: 0,0:00:56.66,0:01:02.30,English,,0,0,0,,Given that I i sort of know what algorithm I'm using
Dialogue: 0,0:01:02.30,0:01:05.66,English,,0,0,0,,And I've perhaps gotten a program that runs
Dialogue: 0,0:01:05.96,0:01:12.34,English,,0,0,0,,How can I make it run faster and one of the the themes of it
Dialogue: 0,0:01:12.66,0:01:18.16,English,,0,0,0,,Is you can sort of do this in layers you can sort of first of all do the stuff to avoid
Dialogue: 0,0:01:21.30,0:01:22.10,English,,0,0,0,,A sort of
Dialogue: 0,0:01:23.34,0:01:29.52,English,,0,0,0,,Things that make programs run slow across a wide variety of machines  and just make your
Dialogue: 0,0:01:29.68,0:01:34.50,English,,0,0,0,,And I would describe it as making your code more compiler friendly
Dialogue: 0,0:01:34.50,0:01:36.04,English,,0,0,0,,And we'll talk about what that means
Dialogue: 0,0:01:36.60,0:01:40.74,English,,0,0,0,,And you have to have some understanding and appreciation for what compilers are good
Dialogue: 0,0:01:41.20,0:01:43.94,English,,0,0,0,,At and what they're not good at to be able to do that
Dialogue: 0,0:01:43.94,0:01:48.82,English,,0,0,0,,And I describe these is the kind of things that you should just be in the habit of
Dialogue: 0,0:01:49.20,0:01:53.24,English,,0,0,0,,When you write programs writing this code that I'll describe is compiler friendly
Dialogue: 0,0:01:53.92,0:02:00.02,English,,0,0,0,,And then the next level is okay given that I've sort of taken away
Dialogue: 0,0:02:00.34,0:02:03.04,English,,0,0,0,,The things that really shouldn't have been there in the first place
Dialogue: 0,0:02:03.40,0:02:06.38,English,,0,0,0,,Now how can I make my programs run faster
Dialogue: 0,0:02:06.38,0:02:12.46,English,,0,0,0,,In particular how can I adapt it to the capabilities of the the types of machines
Dialogue: 0,0:02:12.46,0:02:14.12,English,,0,0,0,,That this program is going to run on
Dialogue: 0,0:02:14.44,0:02:18.64,English,,0,0,0,,And that can again go from ones that will generally make programs run fast
Dialogue: 0,0:02:18.64,0:02:24.32,English,,0,0,0,,Across a wide variety of machines to ones that become very specific and very specific
Dialogue: 0,0:02:24.46,0:02:30.08,English,,0,0,0,,Is a risky thing because even in the world of  say x86 machines
Dialogue: 0,0:02:30.32,0:02:34.56,English,,0,0,0,,There's quite a variety of them that are available at any given point in time
Dialogue: 0,0:02:35.04,0:02:37.02,English,,0,0,0,,And they evolve over time as well
Dialogue: 0,0:02:37.02,0:02:44.44,English,,0,0,0,,So you can make a program run really fast on one particular model of one x86 processor
Dialogue: 0,0:02:44.82,0:02:48.56,English,,0,0,0,,But it might not that if you're trying too hard
Dialogue: 0,0:02:48.56,0:02:51.54,English,,0,0,0,,You'll find your effort is sort of wasted when you move it to another
Dialogue: 0,0:02:51.94,0:02:57.38,English,,0,0,0,,On the other hand these general ideas I'm going to describe actually work across quite a range of machines
Dialogue: 0,0:02:58.62,0:03:01.10,English,,0,0,0,,So and I'll talk about that more as we go along
Dialogue: 0,0:03:02.96,0:03:06.32,English,,0,0,0,,So it used to be in the bad old days that
Dialogue: 0,0:03:06.32,0:03:09.88,English,,0,0,0,,If you wanted a program to run fast you had to write an assembly code
Dialogue: 0,0:03:10.20,0:03:13.60,English,,0,0,0,,And that's just plain not true anymore and if anyone tells you it's true
Dialogue: 0,0:03:13.94,0:03:16.70,English,,0,0,0,,It's because they're full of it it's just not true
Dialogue: 0,0:03:17.04,0:03:23.32,English,,0,0,0,,Unless except for the exceptional case where you're running on a very small resource constrained machine
Dialogue: 0,0:03:23.98,0:03:27.56,English,,0,0,0,,Such as a very small underpowered embedded system
Dialogue: 0,0:03:29.09,0:03:32.56,English,,0,0,0,,So let's just assume that we're going to use a compiler
Dialogue: 0,0:03:33.02,0:03:36.66,English,,0,0,0,,And we'll assume for this course we're going to use gcc because it's generally available
Dialogue: 0,0:03:37.06,0:03:44.40,English,,0,0,0,,It's not actually the best compiler out there intel makes a compiler that costs money to license and stuff
Dialogue: 0,0:03:44.40,0:03:49.88,English,,0,0,0,,But it's it really can do some amazing things and other compilers exist
Dialogue: 0,0:03:49.88,0:03:53.96,English,,0,0,0,,But gcc is sort of a a good enough compiler for most people
Dialogue: 0,0:03:56.80,0:04:02.80,English,,0,0,0,,But there's some features of some things that sort of puzzle compilers that they don't really understand
Dialogue: 0,0:04:02.80,0:04:07.80,English,,0,0,0,,Compilers don't really understand for example that the numbers you're using
Dialogue: 0,0:04:08.24,0:04:13.14,English,,0,0,0,,When you say it's an int might actually range over a much smaller set of values
Dialogue: 0,0:04:14.18,0:04:18.92,English,,0,0,0,,And they have a very hard time understanding memory referencing patterns
Dialogue: 0,0:04:19.30,0:04:21.18,English,,0,0,0,,And the effect of procedure calls
Dialogue: 0,0:04:26.50,0:04:29.62,English,,0,0,0,,And so in general what happens with the compiler is it
Dialogue: 0,0:04:29.92,0:04:35.92,English,,0,0,0,,Has a whole sort of cookbook of optimization strategies
Dialogue: 0,0:04:35.92,0:04:40.84,English,,0,0,0,,And some recipes for how to try out different strategies and apply them
Dialogue: 0,0:04:41.44,0:04:46.14,English,,0,0,0,,But in general if it ever feels like this code is something that
Dialogue: 0,0:04:46.14,0:04:50.14,English,,0,0,0,,It doesn't feel confident about being able to make certain transformations
Dialogue: 0,0:04:50.48,0:04:56.98,English,,0,0,0,,That it just won't it will keep things sort of a more direct implementation of exactly what you described
Dialogue: 0,0:04:57.36,0:05:00.04,English,,0,0,0,,And we'll show examples of that as we go along
Dialogue: 0,0:05:00.70,0:05:06.82,English,,0,0,0,,So the thing about it optimizing compilers it always has a fallback position which is to not optimize
Dialogue: 0,0:05:07.42,0:05:11.86,English,,0,0,0,,And sometimes that will get in trouble if you want your program to run faster
Dialogue: 0,0:05:12.28,0:05:19.10,English,,0,0,0,,And the compiler just in its own conservative white decides not to do that optimization
Dialogue: 0,0:05:19.30,0:05:22.18,English,,0,0,0,,And one of the tricks that you'll find is pretty useful
Dialogue: 0,0:05:22.56,0:05:25.80,English,,0,0,0,,Now that you can read assembly code is you run the compiler
Dialogue: 0,0:05:26.22,0:05:28.32,English,,0,0,0,,You see what optimizations it does
Dialogue: 0,0:05:28.90,0:05:33.38,English,,0,0,0,,And if it doesn't make something that you expect it to be able to do you go back and figure it out
Dialogue: 0,0:05:33.44,0:05:42.30,English,,0,0,0,,So it's very common by the way to rewrite your program in the same language
Dialogue: 0,0:05:42.30,0:05:49.74,English,,0,0,0,,And sort of tune it in and up to make it run faster to make it more compiler friendly
Dialogue: 0,0:05:49.74,0:05:51.32,English,,0,0,0,,That's there's nothing wrong with that
Dialogue: 0,0:05:51.78,0:05:55.96,English,,0,0,0,,As long as you don't then just totally obliterate the program and make it totally illegible
Dialogue: 0,0:05:57.66,0:06:01.50,English,,0,0,0,,So let's just describe some sort of general optimizations
Dialogue: 0,0:06:01.50,0:06:06.82,English,,0,0,0,,And you've actually seen versions of this in some of the assembly code we've already looked at
Dialogue: 0,0:06:08.02,0:06:13.70,English,,0,0,0,,Oh and I'll use mostly sort of examples from multi-dimensional arrays
Dialogue: 0,0:06:13.70,0:06:17.68,English,,0,0,0,,Because those are actually fairly easy optimization type of tasks
Dialogue: 0,0:06:18.40,0:06:21.16,English,,0,0,0,,But these applied to other types of program as well
Dialogue: 0,0:06:21.98,0:06:29.58,English,,0,0,0,,So you saw before when we described how to do array indexing in multi-dimensional arrays
Dialogue: 0,0:06:30.22,0:06:36.63,English,,0,0,0,,That the old style of code was if you had a a variable sized array
Dialogue: 0,0:06:36.84,0:06:40.78,English,,0,0,0,,It was up to you the programmer to write the formula
Dialogue: 0,0:06:40.88,0:06:46.66,English,,0,0,0,,Of how you convert row I column j into a position in a one-dimensional array
Dialogue: 0,0:06:47.58,0:06:53.46,English,,0,0,0,,So remember it's just the number of columns times the row number plus the column numbers standard one
Dialogue: 0,0:06:54.12,0:06:57.68,English,,0,0,0,,So that would give this would be pretty typical code
Dialogue: 0,0:06:57.68,0:07:00.72,English,,0,0,0,,Then it would give you a notation like this
Dialogue: 0,0:07:00.72,0:07:09.60,English,,0,0,0,,If you wanted to set one row in array a to the values in a one dimensional row of b
Dialogue: 0,0:07:10.98,0:07:13.08,English,,0,0,0,,This is a code you'd write
Dialogue: 0,0:07:13.52,0:07:16.28,English,,0,0,0,,And the main observation is within this loop
Dialogue: 0,0:07:16.74,0:07:19.04,English,,0,0,0,,The only variable that's changing is j
Dialogue: 0,0:07:20.24,0:07:25.82,English,,0,0,0,,And so from the array perspective your this computation n* i··
Dialogue: 0,0:07:25.82,0:07:28.56,English,,0,0,0,,If it gets repeated over and over again within this loop
Dialogue: 0,0:07:29.22,0:07:32.52,English,,0,0,0,,Then you're just wasting it's a wasted effort
Dialogue: 0,0:07:32.92,0:07:35.16,English,,0,0,0,,So you can do what's called code motion
Dialogue: 0,0:07:35.42,0:07:40.54,English,,0,0,0,,Which is to pre compute the value of n*i outside of the loop
Dialogue: 0,0:07:40.96,0:07:45.74,English,,0,0,0,,And then use it over and over again inside and compilers will generally do this
Dialogue: 0,0:07:47.36,0:07:53.78,English,,0,0,0,,When they can detect for example that it's a array access code and it has this technique
Dialogue: 0,0:07:54.14,0:07:56.84,English,,0,0,0,,It will generally do optimizations like this
Dialogue: 0,0:07:56.84,0:08:03.42,English,,0,0,0,,If you set say an optimization level of 1 or higher to gcc
Dialogue: 0,0:08:07.14,0:08:14.42,English,,0,0,0,,And we can see this in fact this is this code that I ran it through gcc using optimization 1
Dialogue: 0,0:08:14.68,0:08:19.22,English,,0,0,0,,And you see as this read instruction shows it boosted this multiplication outside of the loop
Dialogue: 0,0:08:20.60,0:08:25.90,English,,0,0,0,,And it's a little as if you actually this code does even more
Dialogue: 0,0:08:25.90,0:08:29.50,English,,0,0,0,,It turns the code into something that looks more like a pointer code
Dialogue: 0,0:08:29.78,0:08:38.34,English,,0,0,0,,Accessing array a and stepping through that element by element  of the array
Dialogue: 0,0:08:39.62,0:08:42.46,English,,0,0,0,,Another one and we've seen this already that when
Dialogue: 0,0:08:42.94,0:08:49.30,English,,0,0,0,,Gcc turns a multiplication or a division by shifting and adding an operations like that
Dialogue: 0,0:08:49.67,0:08:51.97,English,,0,0,0,,Multiplication or division by constants
Dialogue: 0,0:08:52.12,0:08:55.90,English,,0,0,0,,We've seen examples of that and a similar one would happen if
Dialogue: 0,0:09:01.58,0:09:09.82,English,,0,0,0,,If we took that program I showed before  and applied it to every row
Dialogue: 0,0:09:09.96,0:09:16.78,English,,0,0,0,,So we want to set for array a we wanted to set every one of its rows to the value of the one dimensional array b
Dialogue: 0,0:09:19.22,0:09:24.80,English,,0,0,0,,Then again if we we took that code we boosted the end times I in there
Dialogue: 0,0:09:25.62,0:09:31.32,English,,0,0,0,,So now the inner loop is good but you realize that this multiplication isn't necessary either
Dialogue: 0,0:09:31.32,0:09:36.20,English,,0,0,0,,Because what we're doing from I equals 0 to I equals 1 to I equals 2 is
Dialogue: 0,0:09:36.68,0:09:41.26,English,,0,0,0,,Is we're just increasing the parameter ni by we're adding m to it
Dialogue: 0,0:09:41.86,0:09:49.12,English,,0,0,0,,So we can and that's called a reduction in strength we've taken a multiplication and turned it into addition
Dialogue: 0,0:09:49.12,0:09:56.02,English,,0,0,0,,Because there's some predictable pattern of how this variable ni is going to be updated
Dialogue: 0,0:09:56.34,0:10:02.30,English,,0,0,0,,Another example and again array indexing is a good example for optimizations
Dialogue: 0,0:10:02.64,0:10:10.60,English,,0,0,0,,Imagine we had a image that we represent as a two-dimensional array of pixel values
Dialogue: 0,0:10:11.38,0:10:15.58,English,,0,0,0,,And we want to do something that's what a filtering operation
Dialogue: 0,0:10:15.58,0:10:22.62,English,,0,0,0,,Where we want to take the sum of the four neighbors of a given pixel north south east and west
Dialogue: 0,0:10:23.14,0:10:26.56,English,,0,0,0,,And average those together or sum them together
Dialogue: 0,0:10:27.68,0:10:37.20,English,,0,0,0,,And so the natural way you'd write this and see is to say I want usually i
Dialogue: 0,0:10:38.04,0:10:40.94,English,,0,0,0,,N images you count from the top down and so
Dialogue: 0,0:10:41.28,0:10:45.10,English,,0,0,0,,You'd say this is the the pixel above
Dialogue: 0,0:10:45.58,0:10:50.00,English,,0,0,0,,This is the pixel below this is the pixel to the left and this is the pixel to the right
Dialogue: 0,0:10:50.98,0:10:56.60,English,,0,0,0,,And if you do this in and just compile it straight through
Dialogue: 0,0:10:56.94,0:11:02.36,English,,0,0,0,,Unfortunately it appears as if there's three different multiplications by n
Dialogue: 0,0:11:02.74,0:11:05.08,English,,0,0,0,,I-1, i+1 and i
Dialogue: 0,0:11:05.56,0:11:11.94,English,,0,0,0,,And if the compiler isn't too clever it won't realize that these are related to each other
Dialogue: 0,0:11:11.94,0:11:16.02,English,,0,0,0,,And it will issue three different multiply operations just to do this one pixel thing
Dialogue: 0,0:11:16.78,0:11:18.94,English,,0,0,0,,Whereas if I'm a little more clever
Dialogue: 0,0:11:19.40,0:11:22.76,English,,0,0,0,,And this is one where I manually rewrote the code
Dialogue: 0,0:11:22.76,0:11:24.42,English,,0,0,0,,So the compiler would pick it up
Dialogue: 0,0:11:25.00,0:11:30.84,English,,0,0,0,,I'd say well if I on so I and j is I times n plus j
Dialogue: 0,0:11:31.52,0:11:37.36,English,,0,0,0,,And I can get the the pixel above the pixel below by shifting that
Dialogue: 0,0:11:37.46,0:11:39.74,English,,0,0,0,,Off setting that by a value of m
Dialogue: 0,0:11:42.06,0:11:46.42,English,,0,0,0,,And then it will issue the code this will compile with the code with just one multiply
Dialogue: 0,0:11:46.54,0:11:51.36,English,,0,0,0,,And in general by the way multiply used to be a very expensive instruction
Dialogue: 0,0:11:51.80,0:11:57.20,English,,0,0,0,,Nowadays is enough hardware resources that it takes about three clock cycles so it's not a huge deal
Dialogue: 0,0:11:57.74,0:12:02.38,English,,0,0,0,,But anytime you can take three multiplies and use just one instead that's generally a good idea
Dialogue: 0,0:12:02.38,0:12:08.54,English,,0,0,0,,Question
Dialogue: 0,0:12:08.60,0:12:11.48,English,,0,0,0,,So the question is what if you're trying to optimize for space
Dialogue: 0,0:12:11.48,0:12:13.84,English,,0,0,0,,And there are a lot of optimizations that will
Dialogue: 0,0:12:14.54,0:12:19.48,English,,0,0,0,,Make your code be bigger at the expense of in order to go faster right
Dialogue: 0,0:12:19.90,0:12:22.78,English,,0,0,0,,This one though I'd argue this is actually shorter code right
Dialogue: 0,0:12:24.10,0:12:26.30,English,,0,0,0,,And just look at the number of instructions so
Dialogue: 0,0:12:26.64,0:12:32.02,English,,0,0,0,,And usually so code you know that used to be a bigger concern when memory was sort of
Dialogue: 0,0:12:32.44,0:12:37.16,English,,0,0,0,,You know back the original ibm pc had 640 kilobytes of memory so
Dialogue: 0,0:12:37.56,0:12:42.34,English,,0,0,0,,In its maximum configuration and that was a big deal to actually buy it that much
Dialogue: 0,0:12:42.88,0:12:46.72,English,,0,0,0,,So you know back then that was a big deal memory but nowadays memory
Dialogue: 0,0:12:47.10,0:12:52.02,English,,0,0,0,,The size of the program is usually a pretty small fraction of what you're dealing with overall
Dialogue: 0,0:12:52.56,0:12:53.72,English,,0,0,0,,But it's a valid question
Dialogue: 0,0:12:57.14,0:13:02.80,English,,0,0,0,,Okay so that just shows you an example and in general compilers are pretty good at doing
Dialogue: 0,0:13:03.26,0:13:07.92,English,,0,0,0,,Those low-level optimizations like that if you write the code in a way that's reasonable
Dialogue: 0,0:13:08.40,0:13:13.58,English,,0,0,0,,But there's some other ones that the compiler and even a the fanciest compiler you can buy
Dialogue: 0,0:13:13.84,0:13:15.48,English,,0,0,0,,Might not be able to figure it out
Dialogue: 0,0:13:15.90,0:13:20.70,English,,0,0,0,,And so I like to illustrate this with when the first term we ever taught 2:13
Dialogue: 0,0:13:21.16,0:13:26.08,English,,0,0,0,,I was looking at some lab a code
Dialogue: 0,0:13:26.08,0:13:29.32,English,,0,0,0,,That some of the students wrote and I was horrified about this code
Dialogue: 0,0:13:30.08,0:13:33.68,English,,0,0,0,,And I showed it to the tas and none of them figured out what was wrong
Dialogue: 0,0:13:33.68,0:13:38.76,English,,0,0,0,,And I've shown it to many other highly-trained C programmers professionals
Dialogue: 0,0:13:39.04,0:13:40.70,English,,0,0,0,,They go looks ok to me
Dialogue: 0,0:13:42.22,0:13:45.40,English,,0,0,0,,So let's figure out what's why I was horrified by this code
Dialogue: 0,0:13:45.86,0:13:49.56,English,,0,0,0,,So the idea of this code is supposed to be pretty straightforward there's a string s
Dialogue: 0,0:13:50.18,0:13:56.64,English,,0,0,0,,And I want to convert that string all the characters in it to lowercase
Dialogue: 0,0:13:58.34,0:14:03.24,English,,0,0,0,,So I'm just going to read through the string and for each string position
Dialogue: 0,0:14:04.02,0:14:09.06,English,,0,0,0,,Test that character and if it's somewhere between upper case a and upper case z
Dialogue: 0,0:14:09.38,0:14:14.56,English,,0,0,0,,Then I'm going to shift it to being between lowercase a and lowercase z otherwise I will change it
Dialogue: 0,0:14:15.00,0:14:16.36,English,,0,0,0,,So pretty straightforward
Dialogue: 0,0:14:17.30,0:14:20.52,English,,0,0,0,,But if you run this you see that
Dialogue: 0,0:14:21.08,0:14:24.20,English,,0,0,0,,If you go up to half a million characters
Dialogue: 0,0:14:25.26,0:14:33.66,English,,0,0,0,,Which might sound like a lot but it takes 240 or so so  so four minutes to run this code
Dialogue: 0,0:14:35.30,0:14:37.78,English,,0,0,0,,And you go well that's a pretty big string
Dialogue: 0,0:14:37.78,0:14:43.04,English,,0,0,0,,It's really not a big string you should be able to do lowercase conversion of a string
Dialogue: 0,0:14:43.04,0:14:44.92,English,,0,0,0,,And a lot less than four seconds
Dialogue: 0,0:14:45.26,0:14:48.68,English,,0,0,0,,And you also notice this growth is nonlinear it's quadratic
Dialogue: 0,0:14:48.68,0:14:52.78,English,,0,0,0,,It's growing as the square of the string length so this is not good
Dialogue: 0,0:14:53.48,0:14:58.74,English,,0,0,0,,And unfortunately it's the kind and by the way this is one of the that is very easy surprisingly easy
Dialogue: 0,0:14:58.74,0:15:03.64,English,,0,0,0,,To have programs that have some hidden performance bug
Dialogue: 0,0:15:03.90,0:15:06.46,English,,0,0,0,,That makes them run quadratic and you run test
Dialogue: 0,0:15:07.14,0:15:11.26,English,,0,0,0,,And you test for strings of 10,000 or less
Dialogue: 0,0:15:11.68,0:15:16.16,English,,0,0,0,,And it doesn't look like a big deal because the run time is insignificant so
Dialogue: 0,0:15:16.64,0:15:19.76,English,,0,0,0,,But then all of a sudden it hits a really bad case
Dialogue: 0,0:15:20.30,0:15:25.68,English,,0,0,0,,So this is a there's something wrong here
Dialogue: 0,0:15:26.30,0:15:28.72,English,,0,0,0,,So what's so bad about this program well
Dialogue: 0,0:15:29.82,0:15:35.36,English,,0,0,0,,The key is I went in a test like this of calling sterlin
Dialogue: 0,0:15:36.34,0:15:41.20,English,,0,0,0,,So the way it's determining whether it's reached the end of the string
Dialogue: 0,0:15:41.56,0:15:44.62,English,,0,0,0,,Is by calling sterling to figure out how long the string is
Dialogue: 0,0:15:46.66,0:15:51.68,English,,0,0,0,,And the now and remember if we do the conversion of a four loop
Dialogue: 0,0:15:52.06,0:15:57.08,English,,0,0,0,,Into a go to form like you've seen there's various ways to convert it
Dialogue: 0,0:15:57.08,0:16:00.98,English,,0,0,0,,But all of them the test gets built into the loop
Dialogue: 0,0:16:02.02,0:16:08.94,English,,0,0,0,,So the main feature of that is this call to sterling will happen every time you go through the loop
Dialogue: 0,0:16:11.14,0:16:13.28,English,,0,0,0,,And people overlook that fact
Dialogue: 0,0:16:14.18,0:16:17.66,English,,0,0,0,,When you look at the different parts of a four loop
Dialogue: 0,0:16:18.20,0:16:20.70,English,,0,0,0,,The initialization only gets executed once
Dialogue: 0,0:16:21.36,0:16:28.98,English,,0,0,0,,But both the tests and the update get incremented  get applied every time you run through the loop
Dialogue: 0,0:16:30.14,0:16:36.44,English,,0,0,0,,So if that's getting called as many times as there are characters in the loop  in the string right
Dialogue: 0,0:16:37.60,0:16:42.58,English,,0,0,0,,And now how does sterling work remember and see the only way you know how long a string is
Dialogue: 0,0:16:43.06,0:16:47.26,English,,0,0,0,,Is to step through the whole thing and find the null character at the end
Dialogue: 0,0:16:48.18,0:16:52.28,English,,0,0,0,,So sterlin itself is a linear time operation in the string
Dialogue: 0,0:16:54.02,0:16:59.84,English,,0,0,0,,And you're doing that and so you're doing n calls to a function that takes time n
Dialogue: 0,0:17:00.80,0:17:04.66,English,,0,0,0,,If the string is getting shorter as you go but not very fast so
Dialogue: 0,0:17:05.10,0:17:07.06,English,,0,0,0,,Basically that's quadratic performance
Dialogue: 0,0:17:09.98,0:17:12.46,English,,0,0,0,,And that explains why you get that runtime
Dialogue: 0,0:17:13.64,0:17:16.62,English,,0,0,0,,So in particular if I just make the following little change
Dialogue: 0,0:17:17.14,0:17:20.56,English,,0,0,0,,I introduce a local variable called glen
Dialogue: 0,0:17:21.38,0:17:24.50,English,,0,0,0,,And I pre compute sterlin
Dialogue: 0,0:17:24.50,0:17:29.26,English,,0,0,0,,Because the string isn't the length of the string isn't changing I'm just changing the characters
Dialogue: 0,0:17:30.10,0:17:34.46,English,,0,0,0,,In this string um then so the the program will do the same thing
Dialogue: 0,0:17:34.78,0:17:38.22,English,,0,0,0,,But now the runtime is so short it doesn't even show up
Dialogue: 0,0:17:38.60,0:17:43.68,English,,0,0,0,,It's it's maybe a second to do a million characters it's just not a big deal at all
Dialogue: 0,0:17:44.28,0:17:46.66,English,,0,0,0,,As it should be it's just running through
Dialogue: 0,0:17:47.22,0:17:53.72,English,,0,0,0,,And so that's just an example one of many that I've seen in my career where
Dialogue: 0,0:17:54.42,0:18:00.14,English,,0,0,0,,Something that that seems almost insignificant turns out to be a serious performance problem
Dialogue: 0,0:18:03.58,0:18:06.34,English,,0,0,0,,So why couldn't a compiler figure this out
Dialogue: 0,0:18:07.62,0:18:09.58,English,,0,0,0,,Why couldn't a smart compiler
Dialogue: 0,0:18:13.08,0:18:14.90,English,,0,0,0,,Look at the original code
Dialogue: 0,0:18:17.14,0:18:22.68,English,,0,0,0,,And say look you know this is what the programmer wrote
Dialogue: 0,0:18:22.68,0:18:26.52,English,,0,0,0,,But I know a better way to do it I'll pre compute sterlin in advance
Dialogue: 0,0:18:27.36,0:18:32.66,English,,0,0,0,,Well there's a couple reasons one is actually if you look at the code for strlen
Dialogue: 0,0:18:32.90,0:18:35.80,English,,0,0,0,,You see that it's actually modifying the string
Dialogue: 0,0:18:36.34,0:18:42.06,English,,0,0,0,,And strlen at this I mean the the code here is modifying the string and we're calling sterling on it
Dialogue: 0,0:18:42.20,0:18:48.24,English,,0,0,0,,So you'd have to be pretty careful to do the analysis the compiler would to figure out that
Dialogue: 0,0:18:48.72,0:18:50.72,English,,0,0,0,,Even though the string is changing
Dialogue: 0,0:18:51.54,0:18:55.62,English,,0,0,0,,The result you're going to get from sterling is not going to change
Dialogue: 0,0:18:58.89,0:19:03.80,English,,0,0,0,,So that's a one reason
Dialogue: 0,0:19:04.26,0:19:12.54,English,,0,0,0,,And the second is well and how do how does the can the compiler be sure which version of sterling
Dialogue: 0,0:19:12.76,0:19:14.36,English,,0,0,0,,Is actually going to get used
Dialogue: 0,0:19:14.80,0:19:18.66,English,,0,0,0,,You remember and see each of the files gets compiled separately
Dialogue: 0,0:19:19.00,0:19:23.68,English,,0,0,0,,And only afterwards does it all get brought together  in the linking phase
Dialogue: 0,0:19:23.68,0:19:26.70,English,,0,0,0,,And some of that even happens after the program gets started
Dialogue: 0,0:19:27.48,0:19:30.74,English,,0,0,0,,So even though there's a standard strlen function
Dialogue: 0,0:19:31.36,0:19:37.26,English,,0,0,0,,It's not necessarily the case that that's the one that will actually get used in the final program
Dialogue: 0,0:19:37.26,0:19:40.98,English,,0,0,0,,So the compiler really can't be sure of that
Dialogue: 0,0:19:41.18,0:19:46.70,English,,0,0,0,,In particular imagine I provided a sort of customized sterlin function like this
Dialogue: 0,0:19:47.40,0:19:53.26,English,,0,0,0,,That is keeping track of the sum of the lengths of all the strings that it's been called on
Dialogue: 0,0:19:53.72,0:19:57.12,English,,0,0,0,,Or some other side effect like that that
Dialogue: 0,0:19:57.84,0:20:02.20,English,,0,0,0,,Well that that program would produce a very different result than if
Dialogue: 0,0:20:02.78,0:20:05.86,English,,0,0,0,,If I whether or not I make the optimization
Dialogue: 0,0:20:05.98,0:20:08.78,English,,0,0,0,,So the compiler has to assume that
Dialogue: 0,0:20:09.28,0:20:12.36,English,,0,0,0,,Sterling is just a black box that does whatever it does
Dialogue: 0,0:20:12.76,0:20:16.62,English,,0,0,0,,And can't make any assumptions about what how
Dialogue: 0,0:20:17.30,0:20:19.68,English,,0,0,0,,What side effects it might have and so forth
Dialogue: 0,0:20:19.72,0:20:26.52,English,,0,0,0,,So it won't make that optimization on any machine  even with the best compiler
Dialogue: 0,0:20:27.44,0:20:35.70,English,,0,0,0,,So that's just an example that and you can tell that I've gotten kind of sensitized to this
Dialogue: 0,0:20:36.24,0:20:39.06,English,,0,0,0,,So that I spot these but a lot of people don't
Dialogue: 0,0:20:42.52,0:20:44.12,English,,0,0,0,,Um so let's look at this
Dialogue: 0,0:20:44.98,0:20:47.12,English,,0,0,0,,Let's see
Dialogue: 0,0:20:50.78,0:20:54.28,English,,0,0,0,,Oh this is another bad example a bad coding example
Dialogue: 0,0:20:55.50,0:21:06.36,English,,0,0,0,,Of imagine I want to compute for a two-dimensional array a  and a one-dimensional array b
Dialogue: 0,0:21:06.76,0:21:14.90,English,,0,0,0,,I want to make b be b sub I be the sum of of all the elements in row I of  a
Dialogue: 0,0:21:15.94,0:21:20.46,English,,0,0,0,,So again this is a fairly obvious kind of way to write this program that you say
Dialogue: 0,0:21:21.60,0:21:27.64,English,,0,0,0,,Say well b I cook 0 and I'm going to just accumulate it I'll step through the row and accumulate all the values
Dialogue: 0,0:21:28.40,0:21:33.12,English,,0,0,0,,And of course we know now we could improve this by moving i*n
Dialogue: 0,0:21:33.20,0:21:35.56,English,,0,0,0,,Out and so forth I'm not trying to illustrate that
Dialogue: 0,0:21:36.64,0:21:39.52,English,,0,0,0,,But what you'll see in the program this is in the inner loop
Dialogue: 0,0:21:40.08,0:21:44.58,English,,0,0,0,,And we've looked briefly at some floating-point instructions
Dialogue: 0,0:21:44.82,0:21:47.18,English,,0,0,0,,And remember that the main feature of them is
Dialogue: 0,0:21:47.74,0:21:51.24,English,,0,0,0,,The move instructions look like the move ones you're familiar with
Dialogue: 0,0:21:51.50,0:21:56.08,English,,0,0,0,,Except when we we put floating-point data in one of these %xmm registers
Dialogue: 0,0:21:57.32,0:22:02.42,English,,0,0,0,,So the main thing you see here is it's reading from memory
Dialogue: 0,0:22:02.94,0:22:06.42,English,,0,0,0,,It's adding something to it and then it's writing back to memory
Dialogue: 0,0:22:06.98,0:22:10.48,English,,0,0,0,,And what that memory location corresponds to b of i
Dialogue: 0,0:22:11.30,0:22:18.64,English,,0,0,0,,So what it means is every time through this loop it's having to do a memory read and a memory write  of b
Dialogue: 0,0:22:19.08,0:22:21.12,English,,0,0,0,,In addition to the memory read of a
Dialogue: 0,0:22:22.08,0:22:29.30,English,,0,0,0,,Even though presumably b of ai is the same of value that you just updated it to
Dialogue: 0,0:22:30.46,0:22:33.56,English,,0,0,0,,Well in the previous execution of this loop right
Dialogue: 0,0:22:33.82,0:22:37.10,English,,0,0,0,,So why do you have to why do you read it why do you write it out
Dialogue: 0,0:22:37.52,0:22:41.54,English,,0,0,0,,And then read it back in increment it and then again copy it back out
Dialogue: 0,0:22:41.54,0:22:47.78,English,,0,0,0,,Why does it have to go keep jumping back and forth between memory and registers  over and over again
Dialogue: 0,0:22:49.28,0:22:53.24,English,,0,0,0,,Well the reason is because in C you can't be sure
Dialogue: 0,0:22:53.78,0:22:57.86,English,,0,0,0,,That there isn't what's known as aliasing and I'm demonstrating it here
Dialogue: 0,0:22:58.24,0:23:04.54,English,,0,0,0,,Imagine if row b is just declared to be that
Dialogue: 0,0:23:05.32,0:23:10.10,English,,0,0,0,,Okay so imagine and you can do this and see this is legal C code
Dialogue: 0,0:23:10.50,0:23:16.34,English,,0,0,0,,You can make one memory data structure overlay another data structure
Dialogue: 0,0:23:16.34,0:23:21.02,English,,0,0,0,,That's referred to as aliasing when too soon as separate parts of
Dialogue: 0,0:23:21.02,0:23:24.54,English,,0,0,0,,The program are referring to the same locations in memory
Dialogue: 0,0:23:25.04,0:23:27.28,English,,0,0,0,,And the C compiler has no way of knowing
Dialogue: 0,0:23:29.14,0:23:35.44,English,,0,0,0,,Whether there's a lot of work and optimizing compilers to detect aliasing possibilities
Dialogue: 0,0:23:35.80,0:23:38.30,English,,0,0,0,,But in general as to assume aliasing might happen
Dialogue: 0,0:23:38.84,0:23:47.72,English,,0,0,0,,So imagine this aliasing happened so that array b can corresponds then to this row of array a
Dialogue: 0,0:23:49.50,0:23:53.10,English,,0,0,0,,Well then of course its initial value is 4, 8, 16
Dialogue: 0,0:23:53.10,0:23:55.20,English,,0,0,0,,But if you trace through what this code will do
Dialogue: 0,0:23:55.58,0:24:00.76,English,,0,0,0,,It has a sort of odd behavior that is probably not useful for anything
Dialogue: 0,0:24:01.28,0:24:09.30,English,,0,0,0,,But it just demonstrates that what will happen is as this as b gets updated
Dialogue: 0,0:24:09.66,0:24:15.46,English,,0,0,0,,It's effectively changing a and it's changing then what's being read during the summation
Dialogue: 0,0:24:17.70,0:24:20.86,English,,0,0,0,,And so this is a real possibility in c
Dialogue: 0,0:24:21.72,0:24:24.70,English,,0,0,0,,And so the compiler when it's given code like this
Dialogue: 0,0:24:25.72,0:24:32.18,English,,0,0,0,,It has to assume that the these two memory locations might court overlap each other
Dialogue: 0,0:24:32.22,0:24:37.68,English,,0,0,0,,So that's why it's carefully writing it out and then reading it back in over and over again
Dialogue: 0,0:24:40.50,0:24:45.32,English,,0,0,0,,And so if I just rewrite this code by introducing again a local variable
Dialogue: 0,0:24:46.20,0:24:48.44,English,,0,0,0,,And accumulating in that local variable
Dialogue: 0,0:24:49.06,0:24:52.98,English,,0,0,0,,And then only at the end do I sign that to b sub
Dialogue: 0,0:24:53.64,0:24:57.18,English,,0,0,0,,I then you'll see this exact same loop all of a sudden gets a lot simpler
Dialogue: 0,0:24:57.24,0:25:02.82,English,,0,0,0,,It's just a read floating point read an ad to do that
Dialogue: 0,0:25:03.80,0:25:12.90,English,,0,0,0,,And we'll see in fact the memory is actually one of the limiting perform performance limiters in a program
Dialogue: 0,0:25:12.90,0:25:16.71,English,,0,0,0,,So this is won't be a significantly faster
Dialogue: 0,0:25:16.88,0:25:22.08,English,,0,0,0,,And again that's something that you as a programmer would hardly think is a big deal
Dialogue: 0,0:25:23.08,0:25:25.32,English,,0,0,0,,But the C compiler can't do that in general
Dialogue: 0,0:25:25.56,0:25:30.62,English,,0,0,0,,Because it can't determine in advance what possible aliasing there can be
Dialogue: 0,0:25:35.20,0:25:41.84,English,,0,0,0,,So as is these two examples say sort of get in the habit of introducing local variables  and using them
Dialogue: 0,0:25:42.12,0:25:47.74,English,,0,0,0,,And it's your way of telling the compiler don't call the same function over and over again
Dialogue: 0,0:25:47.74,0:25:50.70,English,,0,0,0,,Don't read and write the same memory location over and over again
Dialogue: 0,0:25:50.70,0:25:53.38,English,,0,0,0,,Just hold it in a temporary one
Dialogue: 0,0:25:53.58,0:25:58.26,English,,0,0,0,,And then it will automatically allocate a register and store it in that register and everything will be good
Dialogue: 0,0:26:01.40,0:26:09.88,English,,0,0,0,,Okay so that's sort of the the kind of what we call optimization blockers the kind of things that
Dialogue: 0,0:26:10.40,0:26:12.48,English,,0,0,0,,You as a programmer can make a difference on
Dialogue: 0,0:26:12.48,0:26:17.10,English,,0,0,0,,And the main blockers are memory referencing aliasing and function calls
Dialogue: 0,0:26:17.60,0:26:21.54,English,,0,0,0,,And sort of understanding what might happen in that function call
Dialogue: 0,0:26:22.38,0:26:24.70,English,,0,0,0,,And so now what we're going to do is transition
Dialogue: 0,0:26:24.82,0:26:48.50,English,,0,0,0,,Question equals three of this seem to be I think these two makes a distinction
Dialogue: 0,0:26:48.78,0:26:51.36,English,,0,0,0,,Oh no no this is alan C code
Dialogue: 0,0:26:53.96,0:26:57.12,English,,0,0,0,,I'm sure this is known C code because it ran
Dialogue: 0,0:26:59.86,0:27:08.50,English,,0,0,0,,So this is initializing calling it an array b remember these are in stars these aren't two-dimensional arrays right
Dialogue: 0,0:27:11.24,0:27:14.82,English,,0,0,0,,So this is saying a is now a
Dialogue: 0,0:27:15.80,0:27:19.72,English,,0,0,0,,Think of it as a linear array of four elements of nine elements
Dialogue: 0,0:27:20.38,0:27:24.68,English,,0,0,0,,And a plus three is just to go in three
Dialogue: 0,0:27:25.02,0:27:28.80,English,,0,0,0,,So this is it is declaring b is not a pointer it's an array
Dialogue: 0,0:27:29.10,0:27:33.14,English,,0,0,0,,But remember with an array you can refuse that the name of that array
Dialogue: 0,0:27:33.14,0:27:38.02,English,,0,0,0,,As a reference to a pointer a readable reference not a writable reference right
Dialogue: 0,0:27:38.34,0:27:44.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:27:44.72,0:27:48.02,English,,0,0,0,,Right for this exact code well I'll double check it
Dialogue: 0,0:27:48.02,0:28:05.78,English,,0,0,0,,This design of the seafront language use null terminated strange instead of like hot dogs ice cream
Dialogue: 0,0:28:05.80,0:28:08.58,English,,0,0,0,,So the question is why to see use null terminated strings
Dialogue: 0,0:28:09.20,0:28:14.28,English,,0,0,0,,And it it does and it might be a bad decision for multiple reasons right but
Dialogue: 0,0:28:14.84,0:28:22.12,English,,0,0,0,,I think in general think of C was somebody who had or a couple people
Dialogue: 0,0:28:22.12,0:28:28.16,English,,0,0,0,,Who had been writing a lot of assembly code and wanted to lift up that level
Dialogue: 0,0:28:28.16,0:28:30.80,English,,0,0,0,,So they weren't writing the same stuff over and over again
Dialogue: 0,0:28:31.16,0:28:35.98,English,,0,0,0,,But not thinking in terms of how can I be the most abstract possible
Dialogue: 0,0:28:35.98,0:28:41.54,English,,0,0,0,,So they were trying to provide sort of a minimum layer on top of machine level programming
Dialogue: 0,0:28:41.84,0:28:45.00,English,,0,0,0,,That would let them write code that could run from one machine to another
Dialogue: 0,0:28:45.38,0:28:51.84,English,,0,0,0,,So in everything they do they sort of use the most simple representation and don't assume any kind of
Dialogue: 0,0:28:52.06,0:28:58.74,English,,0,0,0,,There's no array you know most languages would have array bounds checking
Dialogue: 0,0:28:58.86,0:29:06.12,English,,0,0,0,,And array would be a data structure that would include its size you know range of values and stuff and
Dialogue: 0,0:29:06.50,0:29:09.68,English,,0,0,0,,See just doesn't so everything about see is suit at the minimum
Dialogue: 0,0:29:10.46,0:29:15.78,English,,0,0,0,,And you know it's been around for a 40 or something year so
Dialogue: 0,0:29:15.78,0:29:20.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:29:20.70,0:29:25.78,English,,0,0,0,,No pascal does not proceed see no as simply not true
Dialogue: 0,0:29:26.04,0:29:31.10,English,,0,0,0,,Pascal was created as a language for teaching by this phone and nick was very
Dialogue: 0,0:29:31.80,0:29:35.02,English,,0,0,0,,And it was very much an instructional language
Dialogue: 0,0:29:35.02,0:29:39.88,English,,0,0,0,,So it was really designed to help students who needed help
Dialogue: 0,0:29:40.34,0:29:43.18,English,,0,0,0,,And C was designed by professional programmers
Dialogue: 0,0:29:43.60,0:29:48.72,English,,0,0,0,,To let them write their code and not get in their way
Dialogue: 0,0:29:48.86,0:29:52.74,English,,0,0,0,,So they're very different theory between the two languages right
Dialogue: 0,0:29:54.02,0:30:08.04,English,,0,0,0,,Yes what's that
Dialogue: 0,0:30:08.04,0:30:11.16,English,,0,0,0,,I'm sorry f oh yes that's a mistake there
Dialogue: 0,0:30:12.36,0:30:19.35,English,,0,0,0,,I'll double-check this or people could check it I'm pretty sure this code is okay though
Dialogue: 0,0:30:20.72,0:30:25.02,English,,0,0,0,,If not you can certainly say double star b equals a plus three and that would work right
Dialogue: 0,0:30:26.12,0:30:35.10,English,,0,0,0,,Question
Dialogue: 0,0:30:35.10,0:30:40.52,English,,0,0,0,,You think what
Dialogue: 0,0:30:40.62,0:30:46.56,English,,0,0,0,,You think this is 28 yeah well I'm not going to try and execute it here
Dialogue: 0,0:30:46.56,0:30:49.28,English,,0,0,0,,But let's check it you and I will check this code out
Dialogue: 0,0:30:49.80,0:30:53.30,English,,0,0,0,,And we'll fix it if it needs to be fixed okay thanks for pointing it out
Dialogue: 0,0:30:53.76,0:31:01.92,English,,0,0,0,,Yeah
Dialogue: 0,0:31:01.98,0:31:04.86,English,,0,0,0,,No that doesn't make any difference at all in this code
Dialogue: 0,0:31:06.10,0:31:09.08,English,,0,0,0,,No know where it's allocated makes no difference at all here
Dialogue: 0,0:31:10.38,0:31:13.76,English,,0,0,0,,So I'll check that might have to be double star b equals a plus 3
Dialogue: 0,0:31:13.76,0:31:18.02,English,,0,0,0,,But I this was a while ago that I wrote this code oh double-check  it number
Dialogue: 0,0:31:19.76,0:31:31.08,English,,0,0,0,,Ok so anyway sets the sort of end of the story for for simple
Dialogue: 0,0:31:32.42,0:31:36.38,English,,0,0,0,,Simple optima and they are simple optimizations it's just you have to get in the habit of doing it
Dialogue: 0,0:31:38.44,0:31:41.80,English,,0,0,0,,Ok now what we're going to do is go a little bit fancier than this
Dialogue: 0,0:31:41.96,0:31:45.94,English,,0,0,0,,And as I said this becomes somewhat more system dependent but
Dialogue: 0,0:31:46.22,0:31:51.88,English,,0,0,0,,Pretty much nowadays all processors are have similar implementation
Dialogue: 0,0:31:51.88,0:31:55.24,English,,0,0,0,,They all do what's known as out of order execution
Dialogue: 0,0:31:56.68,0:31:59.38,English,,0,0,0,,Except for the most primitive micro controllers
Dialogue: 0,0:31:59.92,0:32:02.84,English,,0,0,0,,And so this is a the kind of optimization oh sure
Dialogue: 0,0:32:03.12,0:32:09.46,English,,0,0,0,,You'll find well this general approach will work across quite a variety machines
Dialogue: 0,0:32:11.64,0:32:15.68,English,,0,0,0,,So what I'm going to do is is do this by a series of examples
Dialogue: 0,0:32:15.76,0:32:19.70,English,,0,0,0,,Starting from some not very efficient code and making it run faster and faster
Dialogue: 0,0:32:19.70,0:32:24.24,English,,0,0,0,,And we'll get a speed-up of around 40
Dialogue: 0,0:32:25.02,0:32:27.02,English,,0,0,0,,Just in doing what we're doing
Dialogue: 0,0:32:28.08,0:32:32.80,English,,0,0,0,,So as I'll start by saying well assume I have a data structure
Dialogue: 0,0:32:32.80,0:32:35.48,English,,0,0,0,,That looks like the way pascal implements arrays
Dialogue: 0,0:32:37.08,0:32:38.86,English,,0,0,0,,Sorry I have nothing against pascal
Dialogue: 0,0:32:40.18,0:32:43.46,English,,0,0,0,,We used to teach it back in the old days but um
Dialogue: 0,0:32:43.72,0:32:47.46,English,,0,0,0,,So a typical way you'd implement an array in a language is
Dialogue: 0,0:32:47.72,0:32:51.66,English,,0,0,0,,You'd provide both the values that are stored in that array
Dialogue: 0,0:32:51.94,0:32:57.28,English,,0,0,0,,And then there'd be other information associated with it for example what size it is
Dialogue: 0,0:32:58.02,0:33:02.64,English,,0,0,0,,And so this is sort of the sort of nice abstract way to do it
Dialogue: 0,0:33:03.26,0:33:10.26,English,,0,0,0,,And you write code that makes sure that if you ever try to exceed the bounds on the array
Dialogue: 0,0:33:10.52,0:33:13.20,English,,0,0,0,,You'd return an error signal
Dialogue: 0,0:33:13.56,0:33:17.78,English,,0,0,0,,And so this particular function you're seeing
Dialogue: 0,0:33:18.88,0:33:23.54,English,,0,0,0,,Is what I want to retrieve an element I passed an a pointer
Dialogue: 0,0:33:23.74,0:33:30.08,English,,0,0,0,,And then that value the pointer gets used to retrieve the value from the array
Dialogue: 0,0:33:30.82,0:33:36.20,English,,0,0,0,,And the return value of this function is then to 0 or 1 0 meaning failure in one meaning success
Dialogue: 0,0:33:36.86,0:33:41.98,English,,0,0,0,,And I'm writing it this way that I use a datatype I'll call data underscore t
Dialogue: 0,0:33:42.40,0:33:45.26,English,,0,0,0,,And that way I can run this I can compile this code
Dialogue: 0,0:33:45.46,0:33:50.48,English,,0,0,0,,Using different definitions of data underscore t to get in so long floats and doubles
Dialogue: 0,0:33:50.98,0:33:57.08,English,,0,0,0,,And we'll see how the performance characteristics of those shift with the different data types
Dialogue: 0,0:33:59.38,0:34:03.30,English,,0,0,0,,And the benchmark I'm going to use is a fairly simple one
Dialogue: 0,0:34:03.30,0:34:10.06,English,,0,0,0,,It's just to for a an array or one of these vectors
Dialogue: 0,0:34:10.88,0:34:15.76,English,,0,0,0,,I just want to combine all the elements of it either compute their sum or their product
Dialogue: 0,0:34:16.52,0:34:22.16,English,,0,0,0,,And again I'm going to use macros here ident and up   and define those
Dialogue: 0,0:34:22.88,0:34:26.30,English,,0,0,0,,So that op is addition and the identity value is 0
Dialogue: 0,0:34:26.88,0:34:31.36,English,,0,0,0,,Or the op is multiplication and the identity element is 1
Dialogue: 0,0:34:31.66,0:34:34.24,English,,0,0,0,,So that I can compare addition in multiplication
Dialogue: 0,0:34:35.10,0:34:37.66,English,,0,0,0,,So that gives us sort of eight possibilities here
Dialogue: 0,0:34:37.88,0:34:40.24,English,,0,0,0,,Two different operations in four different data types
Dialogue: 0,0:34:42.06,0:34:45.84,English,,0,0,0,,And so this is written in the sort of most straightforward manner that
Dialogue: 0,0:34:45.84,0:34:48.58,English,,0,0,0,,I'm using this function called get vac element
Dialogue: 0,0:34:49.04,0:34:52.46,English,,0,0,0,,To retrieve the successive values of this array
Dialogue: 0,0:34:53.04,0:34:55.96,English,,0,0,0,,And then performing this operation on them
Dialogue: 0,0:34:57.48,0:35:01.98,English,,0,0,0,,So now to express a performance of this
Dialogue: 0,0:35:02.62,0:35:06.58,English,,0,0,0,,We're going to use a metric I introduced called cpe
Dialogue: 0,0:35:06.82,0:35:10.68,English,,0,0,0,,Which stands for cycles per element
Dialogue: 0,0:35:11.16,0:35:15.04,English,,0,0,0,,And the idea is that usually when you write code that say steps through a vector
Dialogue: 0,0:35:15.04,0:35:18.40,English,,0,0,0,,Anything that has sort of some linear performance as you get bigger
Dialogue: 0,0:35:19.02,0:35:28.88,English,,0,0,0,,You don't really want to know for exactly it takes this many seconds or microseconds or nanoseconds to do an operation
Dialogue: 0,0:35:29.32,0:35:33.66,English,,0,0,0,,You kind of want to know often more what's its overall performance characteristics
Dialogue: 0,0:35:34.38,0:35:38.90,English,,0,0,0,,And also it turns out when you're doing low-level code optimization
Dialogue: 0,0:35:38.90,0:35:44.94,English,,0,0,0,,It's much more useful to think in terms of clock cycles of the inner clock of the processor
Dialogue: 0,0:35:45.12,0:35:48.36,English,,0,0,0,,Rather than an absolute term such as nanoseconds
Dialogue: 0,0:35:48.66,0:35:52.88,English,,0,0,0,,Because whether a processor is running at two gigahertz through 2.3 gigahertz
Dialogue: 0,0:35:53.68,0:35:57.68,English,,0,0,0,,I don't really I have no control over that as a programmer
Dialogue: 0,0:35:57.96,0:36:01.02,English,,0,0,0,,But I can control sort of it the low-level
Dialogue: 0,0:36:01.42,0:36:05.08,English,,0,0,0,,How many clock cycles are being used for different parts of the computation
Dialogue: 0,0:36:06.64,0:36:09.62,English,,0,0,0,,So that's why it's called cycles per element
Dialogue: 0,0:36:09.72,0:36:13.84,English,,0,0,0,,And you can think of it as and this shows some actual measurements
Dialogue: 0,0:36:14.36,0:36:21.48,English,,0,0,0,,But typically a function like this get what I showed the combine will have some overhead
Dialogue: 0,0:36:21.78,0:36:24.82,English,,0,0,0,,A fixed amount that's associated with setting up the loop
Dialogue: 0,0:36:24.98,0:36:27.42,English,,0,0,0,,Doing the top level call and all that stuff
Dialogue: 0,0:36:27.82,0:36:31.20,English,,0,0,0,,And then some component that's linear in the size
Dialogue: 0,0:36:31.68,0:36:35.00,English,,0,0,0,,And so what I want to know is the slope of that linear component
Dialogue: 0,0:36:37.66,0:36:41.56,English,,0,0,0,,I'll and that will determine that's what I'll call the cycles per element
Dialogue: 0,0:36:41.56,0:36:48.36,English,,0,0,0,,The sort of incremental cost of adding one more element to the array
Dialogue: 0,0:36:53.88,0:36:56.64,English,,0,0,0,,So now if I run this function
Dialogue: 0,0:36:57.12,0:37:01.26,English,,0,0,0,,I showed you and I'm only showing I'll mostly only show four results
Dialogue: 0,0:37:01.26,0:37:07.44,English,,0,0,0,,Because it turns out whether it's int or long or float or double
Dialogue: 0,0:37:07.92,0:37:12.26,English,,0,0,0,,Is not going to actually have any effect on performance for most of the cases
Dialogue: 0,0:37:13.04,0:37:15.56,English,,0,0,0,,So if I just run this code through a compiler
Dialogue: 0,0:37:15.56,0:37:19.66,English,,0,0,0,,And don't do any optimizations it takes around 20 cycles per element
Dialogue: 0,0:37:20.22,0:37:26.48,English,,0,0,0,,And if I turn on optimization level 1 which is sort of the first serious optimization
Dialogue: 0,0:37:26.80,0:37:27.92,English,,0,0,0,,It takes the time in half
Dialogue: 0,0:37:28.06,0:37:33.30,English,,0,0,0,,So I'm down to 10 clock cycles per element just by changing the compilation
Dialogue: 0,0:37:33.90,0:37:37.28,English,,0,0,0,,And that's using the most unoptimized code I could think of here
Dialogue: 0,0:37:41.20,0:37:47.02,English,,0,0,0,,And then I won't go through it all but using sort of the kind of things
Dialogue: 0,0:37:47.02,0:37:53.08,English,,0,0,0,,I described earlier of sort of cut away some of the redundancy in this program
Dialogue: 0,0:37:53.42,0:37:55.98,English,,0,0,0,,You can get it down to something a little bit simpler
Dialogue: 0,0:37:56.10,0:37:59.58,English,,0,0,0,,And so one thing instead of you saw before I was making a call to this
Dialogue: 0,0:38:00.12,0:38:04.10,English,,0,0,0,,Get veck element and every time it did that it went bounds checking
Dialogue: 0,0:38:04.44,0:38:08.50,English,,0,0,0,,And it's kind of silly to keep bounds checking the same array over and over again
Dialogue: 0,0:38:08.72,0:38:15.58,English,,0,0,0,,When I'm stepping I'm using its length as the determinate of how many elements to access
Dialogue: 0,0:38:16.14,0:38:18.68,English,,0,0,0,,So if I'm willing to suit a forgo bounds checking
Dialogue: 0,0:38:19.04,0:38:26.14,English,,0,0,0,,What I can do is introduce a function that will just give me the actual data storage part of this vector
Dialogue: 0,0:38:26.50,0:38:28.30,English,,0,0,0,,And skip over all the other stuff
Dialogue: 0,0:38:29.26,0:38:35.82,English,,0,0,0,,And so I can write a loop that and I introduce you know local variables and all the kind of things we described
Dialogue: 0,0:38:37.28,0:38:41.82,English,,0,0,0,,And accumulating temporaries and things like that
Dialogue: 0,0:38:42.64,0:38:45.62,English,,0,0,0,,Then the program actually gets a lot faster
Dialogue: 0,0:38:46.38,0:38:49.90,English,,0,0,0,,Again with this is everything from here out is optimization level one
Dialogue: 0,0:38:50.54,0:38:56.94,English,,0,0,0,,And so it drops it down to a little over a clock cycle for integers addition of
Dialogue: 0,0:38:57.44,0:39:01.70,English,,0,0,0,,Or three clock cycles up to five clock cycles for double precision multiplier
Dialogue: 0,0:39:02.14,0:39:06.14,English,,0,0,0,,So that's pretty good I've sort of definitely improved things
Dialogue: 0,0:39:06.52,0:39:09.70,English,,0,0,0,,But the question is well is that the best  there is
Dialogue: 0,0:39:09.88,0:39:15.84,English,,0,0,0,,And first and well so try to understand what is it about these numbers three five
Dialogue: 0,0:39:16.38,0:39:19.02,English,,0,0,0,,And this seems to be something close to one point two five
Dialogue: 0,0:39:19.02,0:39:25.58,English,,0,0,0,,So where those numbers coming from and does that indicate some fundamental limitation in my program
Dialogue: 0,0:39:27.92,0:39:32.74,English,,0,0,0,,Well in order to do that you have to have some understanding of the underlying hardware
Dialogue: 0,0:39:32.82,0:39:38.62,English,,0,0,0,,And there's a really good course you can take I think it's called ece 741
Dialogue: 0,0:39:39.82,0:39:44.02,English,,0,0,0,,That will tell you everything you ever could imagine wanting to know about processor design
Dialogue: 0,0:39:44.86,0:39:47.50,English,,0,0,0,,And you actually design processors like this
Dialogue: 0,0:39:47.98,0:39:50.36,English,,0,0,0,,But I'm assuming you're not going to do that for a while
Dialogue: 0,0:39:50.36,0:39:53.28,English,,0,0,0,,Because you have up seven prerequisites to do before that happens
Dialogue: 0,0:39:55.82,0:39:59.28,English,,0,0,0,,So let me just give you the simple version
Dialogue: 0,0:39:59.80,0:40:05.52,English,,0,0,0,,And this is sort of a an idea of what a processor has looked like since about 1995
Dialogue: 0,0:40:05.86,0:40:12.34,English,,0,0,0,,So this is old stuff but it's enough actually to really understand it
Dialogue: 0,0:40:12.34,0:40:16.82,English,,0,0,0,,It's so hard it's really the details are pretty massive
Dialogue: 0,0:40:17.26,0:40:23.70,English,,0,0,0,,And so it's not even taught for example 447 is the ece is the computer architecture course
Dialogue: 0,0:40:23.70,0:40:26.60,English,,0,0,0,,And they don't really go into this kind of design here
Dialogue: 0,0:40:26.92,0:40:29.32,English,,0,0,0,,Because they're pretty hard they're actually hard to design on your own
Dialogue: 0,0:40:30.14,0:40:34.24,English,,0,0,0,,But the the basic idea is you think about a program as
Dialogue: 0,0:40:34.78,0:40:39.94,English,,0,0,0,,Is the computer just reads in an instruction does whatever it says to do
Dialogue: 0,0:40:40.64,0:40:43.52,English,,0,0,0,,Reads in another instruction does what that says to do
Dialogue: 0,0:40:44.14,0:40:46.98,English,,0,0,0,,And that has nothing to do with how programs actually execute
Dialogue: 0,0:40:47.30,0:40:51.02,English,,0,0,0,,What they've built up is this massive hardware infrastructure
Dialogue: 0,0:40:51.46,0:40:54.20,English,,0,0,0,,To make a program run way faster than
Dialogue: 0,0:40:54.90,0:40:57.74,English,,0,0,0,,It would if it were just doing one instruction at a time
Dialogue: 0,0:40:58.26,0:41:03.12,English,,0,0,0,,And it employs a technique that's called superscalar out of order execution
Dialogue: 0,0:41:03.72,0:41:07.60,English,,0,0,0,,And the idea is roughly speaking it it takes your program
Dialogue: 0,0:41:07.60,0:41:10.84,English,,0,0,0,,If you think of your program as a linear sequence of instructions
Dialogue: 0,0:41:11.40,0:41:14.12,English,,0,0,0,,And it just sucks in as many of those as it can
Dialogue: 0,0:41:14.68,0:41:18.48,English,,0,0,0,,And it pulls it apart to realize that certain operations
Dialogue: 0,0:41:18.96,0:41:23.76,English,,0,0,0,,Don't really do on each other so I can start one even though it's later in the program
Dialogue: 0,0:41:24.18,0:41:27.51,English,,0,0,0,,Than the one I'm working on right now because they're independent of each other
Dialogue: 0,0:41:27.82,0:41:32.34,English,,0,0,0,,And it's extracting what they call instruction level parallelism choices where
Dialogue: 0,0:41:32.94,0:41:36.24,English,,0,0,0,,Even though your program is a linear sequence of instruction
Dialogue: 0,0:41:37.12,0:41:43.42,English,,0,0,0,,Buried in there is actually a sort of forest of different computations that need to be done
Dialogue: 0,0:41:43.78,0:41:46.18,English,,0,0,0,,Some which depend on each other and some which don't
Dialogue: 0,0:41:47.24,0:41:49.44,English,,0,0,0,,And then it has a bunch of hardware
Dialogue: 0,0:41:50.34,0:41:57.70,English,,0,0,0,,And so that's up here this upper part shows this idea of of fetching instructions
Dialogue: 0,0:41:57.70,0:42:02.88,English,,0,0,0,,So there's a cache memory a high performance high speed local memory
Dialogue: 0,0:42:03.42,0:42:07.05,English,,0,0,0,,That is just pulling in your instructions as fast as it can
Dialogue: 0,0:42:07.72,0:42:14.00,English,,0,0,0,,And those instructions are then feeding a big pile of hardware that will  extract out of it
Dialogue: 0,0:42:14.36,0:42:19.00,English,,0,0,0,,These low-level operations and figure out which ones depend on which others
Dialogue: 0,0:42:21.20,0:42:26.78,English,,0,0,0,,And then the there is a set of functional units in this part of it
Dialogue: 0,0:42:26.78,0:42:33.90,English,,0,0,0,,That are able to perform these low-level operations to do arithmetic floating-point operations
Dialogue: 0,0:42:34.28,0:42:39.24,English,,0,0,0,,To read data from memory to store data back to memory
Dialogue: 0,0:42:39.40,0:42:43.34,English,,0,0,0,,All using a cache which is something you're going to learn about fairly soon
Dialogue: 0,0:42:43.68,0:42:50.08,English,,0,0,0,,How what all this cache is but think of this as a high speed copy of some of the data memory
Dialogue: 0,0:42:51.44,0:42:59.13,English,,0,0,0,,And and so what this this logic tries to do is keep a forking out
Dialogue: 0,0:42:59.86,0:43:02.48,English,,0,0,0,,Spawning off operations based on your  program
Dialogue: 0,0:43:02.76,0:43:05.58,English,,0,0,0,,And keeping these as busy as they can be
Dialogue: 0,0:43:05.90,0:43:11.40,English,,0,0,0,,Doing different fragments of your code doing different instructions in a different order from before
Dialogue: 0,0:43:12.02,0:43:20.96,English,,0,0,0,,And it turns out you think of a register as a little the set of registers is a part of memory that  get read and written
Dialogue: 0,0:43:21.34,0:43:25.98,English,,0,0,0,,It turns out that in executing a register now just becomes the name
Dialogue: 0,0:43:26.32,0:43:30.82,English,,0,0,0,,Of something that one instruction produces and some other instructions consume
Dialogue: 0,0:43:30.82,0:43:34.18,English,,0,0,0,,It's a destination for some it's a source for other
Dialogue: 0,0:43:34.72,0:43:39.84,English,,0,0,0,,And this whole a bunch of stuff here just sort of magically passes
Dialogue: 0,0:43:40.40,0:43:45.38,English,,0,0,0,,The results of one computation to the input to another computation
Dialogue: 0,0:43:45.70,0:43:50.92,English,,0,0,0,,Based on register names without ever storing them in a and a explicit register file
Dialogue: 0,0:43:51.26,0:43:55.90,English,,0,0,0,,There is a register file when things kind of settle down they get stored away
Dialogue: 0,0:43:56.68,0:43:59.14,English,,0,0,0,,Anyways there's a lot of stuff going on here
Dialogue: 0,0:43:59.58,0:44:07.74,English,,0,0,0,,But the main thing to think about is your machine has resources to do multiple operations  all at the same time
Dialogue: 0,0:44:07.74,0:44:13.74,English,,0,0,0,,If you can somehow structure your program so that those can all get used
Dialogue: 0,0:44:16.04,0:44:20.42,English,,0,0,0,,So this is as I mentioned it's called a superscalar instruct  processor
Dialogue: 0,0:44:20.42,0:44:23.84,English,,0,0,0,,Is one that can do more than one instruction every clock cycle
Dialogue: 0,0:44:25.38,0:44:32.96,English,,0,0,0,,And actually intel started in 93 the very first pentium could do two instructions at once
Dialogue: 0,0:44:33.50,0:44:36.86,English,,0,0,0,,But then a little later they came out with one called the pentium pro
Dialogue: 0,0:44:37.04,0:44:40.08,English,,0,0,0,,Which is sort of the basis of all modern processors
Dialogue: 0,0:44:40.52,0:44:43.22,English,,0,0,0,,And the lead architect by the way was a cmu graduate
Dialogue: 0,0:44:45.14,0:44:50.38,English,,0,0,0,,But this out order execution is the model that's used nowadays
Dialogue: 0,0:44:51.86,0:44:58.53,English,,0,0,0,,So the other thing is those functional units are more complex than you think they might be
Dialogue: 0,0:44:58.90,0:45:00.92,English,,0,0,0,,And that they have what's called pipelining
Dialogue: 0,0:45:01.46,0:45:07.38,English,,0,0,0,,And the ideas of pipelining is imagine you can break up a computation into a series of distinct stages
Dialogue: 0,0:45:09.24,0:45:13.50,English,,0,0,0,,A simple example is if you want to compute a times b plus c
Dialogue: 0,0:45:13.88,0:45:16.16,English,,0,0,0,,You first do the times then you do the plus
Dialogue: 0,0:45:17.06,0:45:21.22,English,,0,0,0,,But it actually gets more than that you can take something like multiplication
Dialogue: 0,0:45:22.24,0:45:26.16,English,,0,0,0,,And break it up into smaller steps
Dialogue: 0,0:45:26.76,0:45:28.88,English,,0,0,0,,That can be done one after the other
Dialogue: 0,0:45:29.50,0:45:34.16,English,,0,0,0,,In a way that and then if you have a separate dedicated hardware for each of those stages
Dialogue: 0,0:45:34.62,0:45:37.22,English,,0,0,0,,Then you can do what's called pipelining which is
Dialogue: 0,0:45:37.86,0:45:40.94,English,,0,0,0,,When one operation moves from one stage to the next
Dialogue: 0,0:45:41.40,0:45:45.22,English,,0,0,0,,A new operation can come in behind and start start its thing
Dialogue: 0,0:45:45.82,0:45:51.98,English,,0,0,0,,So this example shows imagine I had a three stage pipeline multiplier
Dialogue: 0,0:45:52.56,0:45:59.56,English,,0,0,0,,And I want to do this computation a*b, a*c  and now multiply those together
Dialogue: 0,0:46:00.56,0:46:06.16,English,,0,0,0,,So the thing to observe is that a*b and a*c don't depend on each other in any way
Dialogue: 0,0:46:07.06,0:46:12.10,English,,0,0,0,,So I can do them both and I don't have hardware to do them simultaneously
Dialogue: 0,0:46:12.10,0:46:15.52,English,,0,0,0,,But I have them enough to do one right after the other
Dialogue: 0,0:46:16.20,0:46:23.70,English,,0,0,0,,So I can feed the first computation into the first stage a*b on step time step one
Dialogue: 0,0:46:24.24,0:46:27.06,English,,0,0,0,,And then time step two it will move on to stage two
Dialogue: 0,0:46:27.06,0:46:32.18,English,,0,0,0,,And times step three it will move on to stage three
Dialogue: 0,0:46:32.82,0:46:37.28,English,,0,0,0,,But now I can start a*c in the time step two
Dialogue: 0,0:46:38.10,0:46:40.68,English,,0,0,0,,Because this stage became available
Dialogue: 0,0:46:40.98,0:46:45.10,English,,0,0,0,,Once a*b moved from stage one to stage two
Dialogue: 0,0:46:45.46,0:46:51.32,English,,0,0,0,,And so I can follow right behind just one clock cycle behind this other operation
Dialogue: 0,0:46:52.86,0:46:58.00,English,,0,0,0,,Now a p times one times p2 obviously depends on both of these products
Dialogue: 0,0:46:58.78,0:47:03.22,English,,0,0,0,,So it can't start until a times C is completed
Dialogue: 0,0:47:03.68,0:47:07.32,English,,0,0,0,,And then it will run through the pipeline without anything else
Dialogue: 0,0:47:07.86,0:47:15.44,English,,0,0,0,,So overall then we've done what would have normally seemed to be nine steps worth of arithmetic
Dialogue: 0,0:47:16.44,0:47:20.66,English,,0,0,0,,In a total of seven steps here because of pipelining
Dialogue: 0,0:47:20.78,0:47:27.54,English,,0,0,0,,Question
Dialogue: 0,0:47:27.56,0:47:31.84,English,,0,0,0,,What's it if you had like in this a a picture here
Dialogue: 0,0:47:32.58,0:47:36.50,English,,0,0,0,,If there were different multipliers in these different places yes you could do
Dialogue: 0,0:47:37.50,0:47:39.86,English,,0,0,0,,Those two completely independent of each other
Dialogue: 0,0:47:39.92,0:47:48.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:47:48.80,0:47:53.50,English,,0,0,0,,Yes this is all in a single core of a single processor  multi-core is yet another
Dialogue: 0,0:47:53.90,0:47:57.12,English,,0,0,0,,This is a lower level parallelism than you get through multi-core
Dialogue: 0,0:47:57.82,0:48:03.14,English,,0,0,0,,And it's present except in the sort of lowest n lowest powered embedded processors
Dialogue: 0,0:48:03.14,0:48:04.52,English,,0,0,0,,Some version of this exists
Dialogue: 0,0:48:05.30,0:48:09.30,English,,0,0,0,,And most of the time your hardware is not being fully utilized it's one thing you're going to learn from this
Dialogue: 0,0:48:12.50,0:48:16.64,English,,0,0,0,,So that's the idea of pipelining it it's  a sort of like parallelism
Dialogue: 0,0:48:16.64,0:48:20.96,English,,0,0,0,,But it's not that you have multiple copies of resources it's that you have
Dialogue: 0,0:48:21.30,0:48:29.62,English,,0,0,0,,This ability to stream operations through a single hardware resource  in close succession to each other
Dialogue: 0,0:48:33.28,0:48:39.34,English,,0,0,0,,And so as well which is a little bit more recent than the sharp machines
Dialogue: 0,0:48:39.34,0:48:41.98,English,,0,0,0,,But not that much more
Dialogue: 0,0:48:42.38,0:48:47.12,English,,0,0,0,,Is one of the most recent versions of the intel x86 series
Dialogue: 0,0:48:48.60,0:48:55.50,English,,0,0,0,,And the functional units include there's a lot of functional units that can do different things
Dialogue: 0,0:48:55.52,0:49:02.10,English,,0,0,0,,But when you add it all up there's a possibility of it doing  two loads in one store
Dialogue: 0,0:49:02.54,0:49:07.74,English,,0,0,0,,For integer operations two floating-point multiplies one addition and one division
Dialogue: 0,0:49:08.26,0:49:13.72,English,,0,0,0,,They can't all happen at the same time because there's some are share functional units
Dialogue: 0,0:49:13.86,0:49:17.88,English,,0,0,0,,But the point is there's really a lot of equipment there that can do stuff
Dialogue: 0,0:49:20.30,0:49:25.50,English,,0,0,0,,And also you can measure how an instruction now has
Dialogue: 0,0:49:25.98,0:49:30.34,English,,0,0,0,,Two characteristics and operation is how long does it take from beginning to end
Dialogue: 0,0:49:30.78,0:49:36.84,English,,0,0,0,,But also how closely spaced can two in stations be  because of this pipelining
Dialogue: 0,0:49:37.34,0:49:42.48,English,,0,0,0,,So you see that most to them take some number of clock cycles to perform
Dialogue: 0,0:49:42.94,0:49:46.46,English,,0,0,0,,But they're also pipelines so that you can do a series of them
Dialogue: 0,0:49:47.12,0:49:48.44,English,,0,0,0,,Just one cycle apart
Dialogue: 0,0:49:48.92,0:49:52.36,English,,0,0,0,,The only different ones that are does you'll notice the division
Dialogue: 0,0:49:52.74,0:49:55.74,English,,0,0,0,,Is both very slow and it's not pipelined
Dialogue: 0,0:49:55.74,0:50:01.28,English,,0,0,0,,And division is a very expensive operation on most machines  relatively speaking
Dialogue: 0,0:50:05.18,0:50:10.46,English,,0,0,0,,Um so what I claim then is is these these characteristics then
Dialogue: 0,0:50:11.42,0:50:19.24,English,,0,0,0,,Provide a limit on how fast our program can run our original program in that
Dialogue: 0,0:50:19.90,0:50:24.02,English,,0,0,0,,I have a series of multiplications for example of integers here
Dialogue: 0,0:50:25.20,0:50:27.18,English,,0,0,0,,And this shows the code for it
Dialogue: 0,0:50:27.70,0:50:33.52,English,,0,0,0,,And the result of I need the result of one multiplication before I can begin the next
Dialogue: 0,0:50:33.74,0:50:37.28,English,,0,0,0,,So there's a three clock cycle bound here
Dialogue: 0,0:50:37.72,0:50:41.28,English,,0,0,0,,And you'll see that in fact my measurements all correspond to
Dialogue: 0,0:50:41.28,0:50:46.78,English,,0,0,0,,What I'm calling the latency bound of these machines which is just based on
Dialogue: 0,0:50:46.94,0:50:51.08,English,,0,0,0,,How much time it takes from a beginning of an operation to the end
Dialogue: 0,0:50:52.42,0:50:57.32,English,,0,0,0,,And the reason is we considered diagram the computation being done by this program
Dialogue: 0,0:50:57.88,0:51:00.86,English,,0,0,0,,That it's doing a series of multiplications
Dialogue: 0,0:51:01.46,0:51:06.30,English,,0,0,0,,And I require the result of one multiplication before I can start the next
Dialogue: 0,0:51:07.00,0:51:09.04,English,,0,0,0,,In general if you look at this loop code
Dialogue: 0,0:51:09.86,0:51:12.18,English,,0,0,0,,It has to compute ecx
Dialogue: 0,0:51:12.38,0:51:16.88,English,,0,0,0,,The updated value of it before it can now start the next one
Dialogue: 0,0:51:18.12,0:51:23.48,English,,0,0,0,,And so that's why even though this I have a pi point multiplier
Dialogue: 0,0:51:24.34,0:51:30.26,English,,0,0,0,,My program itself limits me to of the sequential execution of all the multiplies
Dialogue: 0,0:51:35.58,0:51:40.54,English,,0,0,0,,So let's see if we can't get beyond that bound that latency bound
Dialogue: 0,0:51:41.12,0:51:43.68,English,,0,0,0,,Well there's a fairly common technique that
Dialogue: 0,0:51:43.68,0:51:46.42,English,,0,0,0,,You might have heard of before that's called loop unrolling
Dialogue: 0,0:51:47.02,0:51:50.14,English,,0,0,0,,And the idea of loop unrolling is just that you
Dialogue: 0,0:51:53.90,0:51:59.46,English,,0,0,0,,Rather than executing one value within a loop you execute a multiple ones
Dialogue: 0,0:51:59.92,0:52:02.48,English,,0,0,0,,And so this code shows unrolling by two
Dialogue: 0,0:52:02.86,0:52:09.54,English,,0,0,0,,And what it says is I'm going to step through this array  two elements at a time
Dialogue: 0,0:52:09.86,0:52:15.96,English,,0,0,0,,And within each of the inner group I'm going to combine the values  from di and di plus one
Dialogue: 0,0:52:16.42,0:52:19.08,English,,0,0,0,,And I have to put in some extra code to finish off
Dialogue: 0,0:52:19.50,0:52:22.40,English,,0,0,0,,What happens if the original rate was a von wenk
Dialogue: 0,0:52:22.68,0:52:24.19,English,,0,0,0,,But you get the idea and
Dialogue: 0,0:52:24.64,0:52:27.50,English,,0,0,0,,This idea I showed this code of of two
Dialogue: 0,0:52:27.50,0:52:31.68,English,,0,0,0,,But you could imagine this applying for different values of loop unrolling
Dialogue: 0,0:52:32.84,0:52:34.14,English,,0,0,0,,So will this help us any well
Dialogue: 0,0:52:35.68,0:52:41.12,English,,0,0,0,,When I run it I get that the integer addition got a little faster
Dialogue: 0,0:52:41.46,0:52:43.26,English,,0,0,0,,But the other ones didn't improve at all
Dialogue: 0,0:52:44.58,0:52:46.70,English,,0,0,0,,So this one is going faster
Dialogue: 0,0:52:46.70,0:52:55.66,English,,0,0,0,,Because basically the old code is the overhead of the loop indexing and incrementing was enough  to be slowing me down
Dialogue: 0,0:52:55.96,0:52:58.42,English,,0,0,0,,Because it's already close to a clock cycle
Dialogue: 0,0:52:58.44,0:53:05.80,English,,0,0,0,,So I just managed to knock that down to be at the latency bound of this particular instruction
Dialogue: 0,0:53:06.58,0:53:11.44,English,,0,0,0,,But it didn't have the other ones because I still have this sequential dependency
Dialogue: 0,0:53:11.88,0:53:15.70,English,,0,0,0,,In order to get my new value of x I have to first
Dialogue: 0,0:53:16.44,0:53:21.42,English,,0,0,0,,Do one computation and then do the other before I can begin another one
Dialogue: 0,0:53:23.98,0:53:30.94,English,,0,0,0,,But this shows me the way I could make a very very small change and change performance fairly dramatically
Dialogue: 0,0:53:31.52,0:53:36.38,English,,0,0,0,,What if I take these parentheses and shift them to the right um
Dialogue: 0,0:53:41.40,0:53:43.16,English,,0,0,0,,What would that make any difference
Dialogue: 0,0:53:44.94,0:53:49.22,English,,0,0,0,,And lo and behold yes you find that
Dialogue: 0,0:53:49.80,0:54:01.46,English,,0,0,0,,And I'll call that transformation unrolling by two computing a one element at a time
Dialogue: 0,0:54:01.46,0:54:02.70,English,,0,0,0,,I'll talk about that in a minute
Dialogue: 0,0:54:03.38,0:54:08.16,English,,0,0,0,,But I'll use this lowercase a to say I've done an associate ivities formation
Dialogue: 0,0:54:08.76,0:54:13.18,English,,0,0,0,,And you see all of a sudden my time's dropped in half  for these three cases
Dialogue: 0,0:54:16.97,0:54:18.02,English,,0,0,0,,So something's going on
Dialogue: 0,0:54:20.14,0:54:24.60,English,,0,0,0,,Um and so let's see why that isn't and now I'll introduce
Dialogue: 0,0:54:27.64,0:54:30.44,English,,0,0,0,,It and so if I take my picture from before
Dialogue: 0,0:54:31.50,0:54:34.88,English,,0,0,0,,And think about what those computations employ you'll see that
Dialogue: 0,0:54:35.46,0:54:38.88,English,,0,0,0,,Right now I've changed the structure of the computation
Dialogue: 0,0:54:38.88,0:54:46.04,English,,0,0,0,,So that I'm pairwise combining each element of pair of elements of the array
Dialogue: 0,0:54:46.50,0:54:51.02,English,,0,0,0,,And then accumulating those into the overall computation
Dialogue: 0,0:54:51.02,0:54:55.40,English,,0,0,0,,So I've actually that shifting of the parentheses fundamentally changed
Dialogue: 0,0:54:55.82,0:54:57.40,English,,0,0,0,,How I'm doing my computation
Dialogue: 0,0:54:59.12,0:55:02.90,English,,0,0,0,,And you can see now that this critical path which is what determines
Dialogue: 0,0:55:03.30,0:55:05.96,English,,0,0,0,,In this case the the performance limitation
Dialogue: 0,0:55:06.20,0:55:08.66,English,,0,0,0,,Just got shorter by a factor of two
Dialogue: 0,0:55:08.94,0:55:11.62,English,,0,0,0,,And that's why I'm now running twice as fast
Dialogue: 0,0:55:11.82,0:55:16.50,English,,0,0,0,,For for the operations not for energy or addition
Dialogue: 0,0:55:17.02,0:55:21.48,English,,0,0,0,,But for the other three operations I've cut by a factor or two
Dialogue: 0,0:55:22.58,0:55:26.48,English,,0,0,0,,Just by that shift now there's some good news and bad news here
Dialogue: 0,0:55:27.20,0:55:29.88,English,,0,0,0,,The good news is if this is integer arithmetic
Dialogue: 0,0:55:29.88,0:55:39.56,English,,0,0,0,,We know already you know that  a two's complement arithmetic is associative and commutative
Dialogue: 0,0:55:39.96,0:55:44.14,English,,0,0,0,,So it really doesn't matter for both multiplication and addition
Dialogue: 0,0:55:44.32,0:55:47.24,English,,0,0,0,,So it really doesn't matter what order I combine these elements in
Dialogue: 0,0:55:47.24,0:55:49.84,English,,0,0,0,,I'm going to get the exact same answer no matter what
Dialogue: 0,0:55:50.70,0:55:53.30,English,,0,0,0,,But you also solve for floating-point that's not the case
Dialogue: 0,0:55:53.92,0:55:58.18,English,,0,0,0,,So with floating-point that shift shifting these parentheses
Dialogue: 0,0:55:58.74,0:56:02.58,English,,0,0,0,,Because of rounding possibilities and even potentially overflow
Dialogue: 0,0:56:03.12,0:56:07.02,English,,0,0,0,,You might get different values results from these computations
Dialogue: 0,0:56:07.58,0:56:13.46,English,,0,0,0,,But then again if you think about you know is that really going to happen chances are no
Dialogue: 0,0:56:14.02,0:56:17.16,English,,0,0,0,,That it's not really going to affect the outcome of your program
Dialogue: 0,0:56:17.46,0:56:21.64,English,,0,0,0,,But it's enough of a change that most C compilers or most compilers period
Dialogue: 0,0:56:21.92,0:56:24.96,English,,0,0,0,,Will not make any change that changes associativity
Dialogue: 0,0:56:24.96,0:56:28.22,English,,0,0,0,,Because they're very conservative when it comes to floating-point
Dialogue: 0,0:56:29.98,0:56:34.62,English,,0,0,0,,So that's something you as an application programmer has to have to know well enough is
Dialogue: 0,0:56:34.62,0:56:38.20,English,,0,0,0,,This a valid can I do this transformation without messing things up
Dialogue: 0,0:56:41.16,0:56:45.90,English,,0,0,0,,And now without I'll say is now there's a new set of bounds
Dialogue: 0,0:56:45.90,0:56:52.46,English,,0,0,0,,So a bound is what would appear to be sort of the best you can do based on some constraint in the program
Dialogue: 0,0:56:52.88,0:56:56.20,English,,0,0,0,,And before it was saying well the latency
Dialogue: 0,0:56:56.42,0:56:59.58,English,,0,0,0,,The total time through a given for a given operation was abound
Dialogue: 0,0:57:00.50,0:57:05.56,English,,0,0,0,,And now I say well there's an even more fundamental bound which I'll call the throughput bound
Dialogue: 0,0:57:05.56,0:57:09.66,English,,0,0,0,,Which is just based on I only have so much hardware out there
Dialogue: 0,0:57:09.92,0:57:12.54,English,,0,0,0,,And I can only a pump it so fast
Dialogue: 0,0:57:13.32,0:57:19.26,English,,0,0,0,,So for example these two that the throughput bound is one
Dialogue: 0,0:57:19.82,0:57:28.78,English,,0,0,0,,Because I only have that actually becomes limited by the requirement
Dialogue: 0,0:57:28.78,0:57:32.34,English,,0,0,0,,That I'm having to read from memory
Dialogue: 0,0:57:32.74,0:57:35.10,English,,0,0,0,,And I have two different load units
Dialogue: 0,0:57:39.02,0:57:45.28,English,,0,0,0,,Oh no I'm sorry I only have one multiplier for integers in one for  addition
Dialogue: 0,0:57:46.00,0:57:49.84,English,,0,0,0,,The throughput bound for these two actually is just a half
Dialogue: 0,0:57:50.38,0:57:55.68,English,,0,0,0,,Because it turns out there's some odd part of the hardware design that has two 14-point multipliers
Dialogue: 0,0:57:56.20,0:57:57.96,English,,0,0,0,,But only one floating point adder
Dialogue: 0,0:57:58.18,0:58:03.08,English,,0,0,0,,And we'll see that we can actually make this multiplication code run faster than addition code
Dialogue: 0,0:58:03.64,0:58:08.28,English,,0,0,0,,And over here again my limit will be that I only have to load units now to be
Dialogue: 0,0:58:09.30,0:58:14.74,English,,0,0,0,,And I have to read for every element I'm computing I have to be reading one element from memory
Dialogue: 0,0:58:14.74,0:58:16.14,English,,0,0,0,,So I can't get below
Dialogue: 0,0:58:20.18,0:58:23.26,English,,0,0,0,,That okay so but we saw this transformation now is let us
Dialogue: 0,0:58:23.70,0:58:28.60,English,,0,0,0,,Break out of this latency limitation and get something closer to throughput
Dialogue: 0,0:58:29.38,0:58:35.76,English,,0,0,0,,And here's another technique that can be used to again sort of get more parallelism going
Dialogue: 0,0:58:36.04,0:58:38.30,English,,0,0,0,,And I call this multiple accumulators
Dialogue: 0,0:58:38.82,0:58:41.70,English,,0,0,0,,The idea is let's a imagine that
Dialogue: 0,0:58:41.70,0:58:45.74,English,,0,0,0,,We have the odd-numbered elements and the even-numbered elements in the array
Dialogue: 0,0:58:46.36,0:58:52.88,English,,0,0,0,,And we can we can compute separate sums or products of those two sets of elements
Dialogue: 0,0:58:53.34,0:58:56.28,English,,0,0,0,,And then the very end combine them together
Dialogue: 0,0:58:56.60,0:59:00.53,English,,0,0,0,,So this is another form of and associativity transformation
Dialogue: 0,0:59:00.53,0:59:04.54,English,,0,0,0,,You were changing the order in which we combine things together
Dialogue: 0,0:59:05.08,0:59:08.14,English,,0,0,0,,It's just that we're doing it in the suit of odd-even manner
Dialogue: 0,0:59:08.14,0:59:15.78,English,,0,0,0,,Or in general every I do it by some by some parameter i
Dialogue: 0,0:59:17.92,0:59:21.58,English,,0,0,0,,It has the same issues that if it's integer arithmetic it's fine
Dialogue: 0,0:59:21.58,0:59:26.54,English,,0,0,0,,If it's floating-point there's a risk of of changing the behavior of the program
Dialogue: 0,0:59:27.78,0:59:32.40,English,,0,0,0,,But you'll see that again we get a cutting in half here and
Dialogue: 0,0:59:32.48,0:59:35.80,English,,0,0,0,,A little bit below one for integer addition
Dialogue: 0,0:59:39.04,0:59:41.98,English,,0,0,0,,And again we can think of it by looking at these pictures
Dialogue: 0,0:59:41.98,0:59:44.16,English,,0,0,0,,Of what are the what gets computed
Dialogue: 0,0:59:44.16,0:59:47.92,English,,0,0,0,,And you see what we're doing is we're computing here all the even numbers
Dialogue: 0,0:59:48.36,0:59:51.58,English,,0,0,0,,Even numbered elements being combined and here all the odd ones
Dialogue: 0,0:59:51.88,0:59:54.12,English,,0,0,0,,And the very end we're combining those together
Dialogue: 0,0:59:56.82,0:59:59.66,English,,0,0,0,,And so we can generalize this if we can
Dialogue: 0,1:00:00.24,1:00:04.00,English,,0,0,0,,Unroll by a factor of k of l
Dialogue: 0,1:00:04.24,1:00:07.32,English,,0,0,0,,And we can accumulate k results in parallel
Dialogue: 0,1:00:07.90,1:00:11.82,English,,0,0,0,,And we can use various values of l and k for it
Dialogue: 0,1:00:11.82,1:00:14.68,English,,0,0,0,,In general has to be a multiple of k
Dialogue: 0,1:00:16.36,1:00:21.78,English,,0,0,0,,And so you run it out and you can get for floating-point
Dialogue: 0,1:00:23.28,1:00:27.70,English,,0,0,0,,Why you can actually get it down almost to this throughput bounds of 0.5
Dialogue: 0,1:00:36.62,1:00:42.02,English,,0,0,0,,This is incorrect this is integer addition I should say in tradition
Dialogue: 0,1:00:42.70,1:00:45.92,English,,0,0,0,,You can again get it down to around 0.5
Dialogue: 0,1:00:46.64,1:00:53.48,English,,0,0,0,,And in general by sort of picking the best parameters
Dialogue: 0,1:00:53.48,1:00:57.88,English,,0,0,0,,I can get very close to the throughput bound of this processor
Dialogue: 0,1:00:58.36,1:01:04.14,English,,0,0,0,,So I've been able to take something remember it originally was  20 clock cycles than 10
Dialogue: 0,1:01:04.38,1:01:08.44,English,,0,0,0,,And now I'm getting it down to one or fewer clock cycles per element
Dialogue: 0,1:01:10.58,1:01:17.56,English,,0,0,0,,So now just as the final step is okay is that as good as it go actually no
Dialogue: 0,1:01:18.96,1:01:22.18,English,,0,0,0,,You remember when I talked about floating-point I mentioned
Dialogue: 0,1:01:22.18,1:01:25.34,English,,0,0,0,,That there's the special set of registers
Dialogue: 0,1:01:25.70,1:01:31.96,English,,0,0,0,,That are on x86 that we're called xmm registers on the sharp machines
Dialogue: 0,1:01:32.26,1:01:36.68,English,,0,0,0,,And now this has well this newer generation have something called ymm registers
Dialogue: 0,1:01:37.08,1:01:40.04,English,,0,0,0,,Which have the feature being twice as big as xmm registers
Dialogue: 0,1:01:40.90,1:01:51.10,English,,0,0,0,,So in particular these registers are are 32 bytes long
Dialogue: 0,1:01:51.76,1:01:57.38,English,,0,0,0,,And there's a new version coming out within a year or something they call avx-512
Dialogue: 0,1:01:57.86,1:02:03.92,English,,0,0,0,,Where the register is 512 bits so that's 256 bytes  long
Dialogue: 0,1:02:04.42,1:02:10.60,English,,0,0,0,,No it's of to 512 excuse me it's 64 bytes right
Dialogue: 0,1:02:11.04,1:02:13.36,English,,0,0,0,,64 bytes so it'll be twice as big as these
Dialogue: 0,1:02:14.08,1:02:17.24,English,,0,0,0,,And as I mentioned before you can think of these as a way of
Dialogue: 0,1:02:17.72,1:02:21.78,English,,0,0,0,,Operating on 32 individual characters
Dialogue: 0,1:02:22.30,1:02:24.52,English,,0,0,0,,Or I can treat them as floating point
Dialogue: 0,1:02:25.20,1:02:28.86,English,,0,0,0,,And we saw before that you nowadays the
Dialogue: 0,1:02:29.26,1:02:35.52,English,,0,0,0,,The regular floating point makes use of ceuta the low order  for 8 bytes of these read jester's
Dialogue: 0,1:02:36.64,1:02:40.16,English,,0,0,0,,But there's also instructions called vector addition
Dialogue: 0,1:02:41.22,1:02:50.76,English,,0,0,0,,Where one instruction has the effect of doing eight floating-point additions at once unload data
Dialogue: 0,1:02:51.02,1:02:55.34,English,,0,0,0,,And on double precision this counterpart does four of them at once of these
Dialogue: 0,1:02:56.78,1:03:02.98,English,,0,0,0,,And the that hardware is there it's just sitting there waiting to use and it seldom gets fired up
Dialogue: 0,1:03:03.60,1:03:05.58,English,,0,0,0,,To really make use of it
Dialogue: 0,1:03:06.00,1:03:09.68,English,,0,0,0,,But so that floating point multiplier that can do
Dialogue: 0,1:03:10.12,1:03:15.04,English,,0,0,0,,A floating point multiplication in three clock cycles and is fully pipeline
Dialogue: 0,1:03:16.19,1:03:24.32,English,,0,0,0,,You can actually do eight fighting point multiplications in parallel and pipelined in three clock cycles
Dialogue: 0,1:03:27.38,1:03:33.04,English,,0,0,0,,And as I mentioned the shark machines has an earlier version where the numbers are half of these
Dialogue: 0,1:03:33.04,1:03:37.49,English,,0,0,0,,So it can do for single precision or two double precision at once
Dialogue: 0,1:03:38.76,1:03:44.16,English,,0,0,0,,And if I write code that uses that what I call vector code
Dialogue: 0,1:03:44.70,1:03:51.16,English,,0,0,0,,Then you can see I can drop by a factor of about four across the board here
Dialogue: 0,1:03:51.86,1:03:54.82,English,,0,0,0,,And make it run much faster
Dialogue: 0,1:03:54.82,1:03:58.92,English,,0,0,0,,So this 0.06 is really 0.0625 right
Dialogue: 0,1:03:58.92,1:04:05.48,English,,0,0,0,,It's doing 16 operations per clock cycle on that
Dialogue: 0,1:04:10.06,1:04:14.46,English,,0,0,0,,And can't quite hit the vector throughput bound
Dialogue: 0,1:04:14.46,1:04:17.68,English,,0,0,0,,But in general making this thing run much faster
Dialogue: 0,1:04:18.10,1:04:20.54,English,,0,0,0,,And so the people really worry about
Dialogue: 0,1:04:20.54,1:04:27.16,English,,0,0,0,,And you can imagine these instructions were introduced for things like video processing image processing of sound
Dialogue: 0,1:04:27.46,1:04:31.98,English,,0,0,0,,Sort of signal processing where a performance really matters
Dialogue: 0,1:04:32.00,1:04:38.02,English,,0,0,0,,How fast you can display an image how fast you can rotate something
Dialogue: 0,1:04:38.02,1:04:41.06,English,,0,0,0,,You know how fast you can perform graphics makes a big difference
Dialogue: 0,1:04:41.74,1:04:48.60,English,,0,0,0,,In video games are one of the big drivers but even for sort of other operations you might do an image
Dialogue: 0,1:04:48.90,1:04:51.40,English,,0,0,0,,And so these instructions were really designed to do it
Dialogue: 0,1:04:51.40,1:04:54.10,English,,0,0,0,,And people write code for those kind of applications
Dialogue: 0,1:04:54.52,1:04:59.98,English,,0,0,0,,Get pretty good at writing code in a way that they can do this vector I what's called vectorizing
Dialogue: 0,1:05:00.58,1:05:05.82,English,,0,0,0,,And unfortunately so the intel compiler will actually automatically do some of this for you
Dialogue: 0,1:05:06.10,1:05:09.11,English,,0,0,0,,A gcc they attempted to implement it and
Dialogue: 0,1:05:09.11,1:05:11.96,English,,0,0,0,,It didn't work very well so I think they discontinued it
Dialogue: 0,1:05:12.58,1:05:15.64,English,,0,0,0,,It turns out there's a web aside
Dialogue: 0,1:05:16.90,1:05:21.44,English,,0,0,0,,So this is on the web from the books web page that describes
Dialogue: 0,1:05:21.44,1:05:23.52,English,,0,0,0,,How to do this programming if you're interested
Dialogue: 0,1:05:23.90,1:05:28.82,English,,0,0,0,,There's extensions to gcc that are very funky really weird stuff
Dialogue: 0,1:05:29.36,1:05:32.20,English,,0,0,0,,But you can write code
Dialogue: 0,1:05:32.72,1:05:37.12,English,,0,0,0,,That then will get compiled down to make use of these kind of instructions
Dialogue: 0,1:05:37.18,1:05:40.22,English,,0,0,0,,And that's how I did it and how I got these performance results
Dialogue: 0,1:05:43.48,1:05:46.76,English,,0,0,0,,Okay so that shows you if you really want to it
Dialogue: 0,1:05:47.00,1:05:50.38,English,,0,0,0,,But that's very machine specific that will only work on
Dialogue: 0,1:05:52.02,1:05:58.46,English,,0,0,0,,Well you have to you can actually tune it so it's easy to compile it   to go between different machines
Dialogue: 0,1:05:58.46,1:06:05.34,English,,0,0,0,,But it's still a fairly specific and very specific to gcc in fact
Dialogue: 0,1:06:05.92,1:06:09.48,English,,0,0,0,,So that sort of shows you though if you really want to push it what you can do
Dialogue: 0,1:06:10.48,1:06:13.16,English,,0,0,0,,Now let's uh get back to one of the thing
Dialogue: 0,1:06:13.56,1:06:20.04,English,,0,0,0,,I told you about how you can if you think of your program as a very long linear sequence of instructions
Dialogue: 0,1:06:20.72,1:06:26.96,English,,0,0,0,,Then the thing is trying to grab as many of those and pull them apart as fast as it can
Dialogue: 0,1:06:27.52,1:06:30.40,English,,0,0,0,,But of course you know your program is actually typically a loop
Dialogue: 0,1:06:30.78,1:06:32.69,English,,0,0,0,,And there aren't many instructions in that loop
Dialogue: 0,1:06:33.08,1:06:35.84,English,,0,0,0,,So how is it turning that into a linear sequence
Dialogue: 0,1:06:36.72,1:06:41.52,English,,0,0,0,,Well that relies on an idea of how do you handle branches
Dialogue: 0,1:06:42.30,1:06:48.38,English,,0,0,0,,So typically the program you know fetching ahead grabbing instructions
Dialogue: 0,1:06:48.38,1:06:53.92,English,,0,0,0,,And it will come to a branch instruction a conditional jump of some sort
Dialogue: 0,1:06:54.58,1:06:59.86,English,,0,0,0,,And there is a dilemma because in general this branch could either
Dialogue: 0,1:07:01.10,1:07:07.32,English,,0,0,0,,I'm sorry either be taken meaning it will go to the branch target
Dialogue: 0,1:07:07.80,1:07:13.70,English,,0,0,0,,Or it could do what's called fall through meaning it it the test fails and so it just continues execution
Dialogue: 0,1:07:14.14,1:07:19.32,English,,0,0,0,,And there's no way a priority to know what will happen these can often be data dependent
Dialogue: 0,1:07:22.66,1:07:27.14,English,,0,0,0,,Well and so the way this is handled on a modern processor is by doing
Dialogue: 0,1:07:27.14,1:07:30.64,English,,0,0,0,,What's known as branch prediction which is essentially just guess
Dialogue: 0,1:07:32.10,1:07:34.64,English,,0,0,0,,Which ways this branch going to go is going to be taken or
Dialogue: 0,1:07:35.10,1:07:39.14,English,,0,0,0,,Not and you predict and then you start executing along the predicted direction
Dialogue: 0,1:07:39.56,1:07:41.98,English,,0,0,0,,But do it in a way that if you make a mistake that
Dialogue: 0,1:07:42.52,1:07:45.94,English,,0,0,0,,You haven't caused your reparable harm to the program
Dialogue: 0,1:07:46.44,1:07:48.40,English,,0,0,0,,And we'll see what that means
Dialogue: 0,1:07:48.86,1:07:52.12,English,,0,0,0,,So what really happens then is up here there's a lot of logic
Dialogue: 0,1:07:52.12,1:07:55.60,English,,0,0,0,,That's trying to suck out instructions
Dialogue: 0,1:07:56.12,1:08:02.54,English,,0,0,0,,And then there's a branch unit that's being basically coming along later and saying
Dialogue: 0,1:08:02.94,1:08:07.00,English,,0,0,0,,Yeah you're okay you predicted that correctly so you can keep going
Dialogue: 0,1:08:07.20,1:08:10.70,English,,0,0,0,,Or it will throw up a flag and say oh wait a minute stop
Dialogue: 0,1:08:11.44,1:08:16.24,English,,0,0,0,,Your misprediction you miss predicted this branch way back 100 clock cycles ago
Dialogue: 0,1:08:16.32,1:08:17.64,English,,0,0,0,,It's not that long ago but
Dialogue: 0,1:08:18.30,1:08:21.80,English,,0,0,0,,Some number of clock cycles ago you've got to fix it
Dialogue: 0,1:08:22.44,1:08:28.10,English,,0,0,0,,And so so the hand-wave jumps then becomes more a case of of
Dialogue: 0,1:08:28.36,1:08:34.58,English,,0,0,0,,Guessing up here and then either confirming or  denying that guess down below
Dialogue: 0,1:08:40.58,1:08:45.60,English,,0,0,0,,So in general then if you it will predict it one way and begin executing
Dialogue: 0,1:08:46.26,1:08:50.28,English,,0,0,0,,So a mansion for example in a loop like I've shown you
Dialogue: 0,1:08:50.56,1:08:54.80,English,,0,0,0,,That you predict that the branch will be taken that you'll go back to the start of the loop again
Dialogue: 0,1:08:54.80,1:08:57.04,English,,0,0,0,,That's actually a pretty good guess
Dialogue: 0,1:08:57.38,1:09:00.36,English,,0,0,0,,It's a good guess extol you hit the end of the loop
Dialogue: 0,1:09:00.88,1:09:02.64,English,,0,0,0,,But let's just guess that way
Dialogue: 0,1:09:03.18,1:09:08.56,English,,0,0,0,,And so the program will just keep guessing that the branch will be taken
Dialogue: 0,1:09:09.02,1:09:16.28,English,,0,0,0,,And by that means by all those guesses basically create this long linear sequence of instructions
Dialogue: 0,1:09:16.66,1:09:19.68,English,,0,0,0,,That can be pulled in and executed
Dialogue: 0,1:09:21.88,1:09:27.60,English,,0,0,0,,And in general some of them will be fetched and some of them you'll actually have done
Dialogue: 0,1:09:28.20,1:09:31.06,English,,0,0,0,,The operations that are called for in the instruction
Dialogue: 0,1:09:33.56,1:09:40.50,English,,0,0,0,,And then what happens is if if the flag goes up they say no this was invalid
Dialogue: 0,1:09:41.22,1:09:45.66,English,,0,0,0,,Then what will happen is it will go back and cancel
Dialogue: 0,1:09:46.12,1:09:50.38,English,,0,0,0,,All the instructions that have been fetched and executed
Dialogue: 0,1:09:50.78,1:09:56.96,English,,0,0,0,,And the way it does that is you'll notice not all these instructions only modify registers
Dialogue: 0,1:09:57.66,1:10:00.66,English,,0,0,0,,And it has multiple copies of all the registers
Dialogue: 0,1:10:01.10,1:10:03.14,English,,0,0,0,,Going back these are the registers
Dialogue: 0,1:10:03.14,1:10:08.84,English,,0,0,0,,These are the values that I'm sure of these are sort of speculative values  appending updates to them
Dialogue: 0,1:10:09.26,1:10:14.56,English,,0,0,0,,And so when it comes time to cancel it just cancels out all those pending updates
Dialogue: 0,1:10:14.78,1:10:17.00,English,,0,0,0,,And goes back to values that it's certain of
Dialogue: 0,1:10:17.12,1:10:20.40,English,,0,0,0,,Question
Dialogue: 0,1:10:20.40,1:10:27.66,English,,0,0,0,,The there's a big block they call the register renaming unit which is sort of
Dialogue: 0,1:10:27.94,1:10:31.80,English,,0,0,0,,Multiple copies of of all the registers as they get accumulated
Dialogue: 0,1:10:31.80,1:10:42.00,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:42.00,1:10:45.94,English,,0,0,0,,It has many more will typically have several hundred reg of these
Dialogue: 0,1:10:46.26,1:10:50.72,English,,0,0,0,,Sort of virtual registers to keep pending copies to the actual registers
Dialogue: 0,1:10:50.72,1:10:52.56,English,,0,0,0,,[student speaking]
Dialogue: 0,1:10:52.56,1:10:56.80,English,,0,0,0,,What it does it stores you know here's the old value
Dialogue: 0,1:10:56.80,1:10:59.64,English,,0,0,0,,Here's the first update here's the second update here's the third
Dialogue: 0,1:11:01.60,1:11:05.74,English,,0,0,0,,And it keeps track of all that you can imagine why this is not a
Dialogue: 0,1:11:06.28,1:11:09.02,English,,0,0,0,,Something you learn in a one semester course right that
Dialogue: 0,1:11:09.46,1:11:13.24,English,,0,0,0,,To keep track of all those different things flying by and make sure that it works
Dialogue: 0,1:11:13.90,1:11:15.58,English,,0,0,0,,Is a pretty tricky business
Dialogue: 0,1:11:16.06,1:11:18.48,English,,0,0,0,,But the conceptually it's a pretty simple idea
Dialogue: 0,1:11:18.80,1:11:24.02,English,,0,0,0,,That it just races off does a lot of things based purely on speculation
Dialogue: 0,1:11:24.42,1:11:27.48,English,,0,0,0,,And then only if it makes a mistake it goes oh
Dialogue: 0,1:11:27.76,1:11:29.14,English,,0,0,0,,And it sort of rolls back
Dialogue: 0,1:11:29.94,1:11:32.62,English,,0,0,0,,To as if it had only executed up to a certain point
Dialogue: 0,1:11:33.04,1:11:34.60,English,,0,0,0,,And then it moves forward
Dialogue: 0,1:11:35.76,1:11:38.68,English,,0,0,0,,And starts in going the correct way
Dialogue: 0,1:11:39.58,1:11:46.14,English,,0,0,0,,So end up and so and it can get away with this it's very interesting tricky stuff
Dialogue: 0,1:11:46.48,1:11:48.80,English,,0,0,0,,But you remember we talked early in the course
Dialogue: 0,1:11:49.54,1:11:53.92,English,,0,0,0,,About the difference between using conditional moves and conditional jumps
Dialogue: 0,1:11:53.92,1:11:56.42,English,,0,0,0,,To implement conditional operations
Dialogue: 0,1:11:57.08,1:12:03.72,English,,0,0,0,,And conditional moves can take place totally within the structure of this pipeline
Dialogue: 0,1:12:04.36,1:12:07.92,English,,0,0,0,,But a conditional jump if it's an unpredictable branch
Dialogue: 0,1:12:08.32,1:12:13.14,English,,0,0,0,,The problem is it might go off executing  and make do a lot of wasted work
Dialogue: 0,1:12:13.14,1:12:16.52,English,,0,0,0,,But even worse than when it gets back and has to restart
Dialogue: 0,1:12:16.98,1:12:21.02,English,,0,0,0,,It takes a while to sort of fill up all the the buffers in the system
Dialogue: 0,1:12:21.02,1:12:23.28,English,,0,0,0,,And get the whole thing running at full steam ahead
Dialogue: 0,1:12:27.55,1:12:32.44,English,,0,0,0,,So that kind of finishes up then the the way I describe it is
Dialogue: 0,1:12:32.72,1:12:38.08,English,,0,0,0,,First of all don't do anything stupid even and stupid is probably it was too strong a word
Dialogue: 0,1:12:38.08,1:12:44.94,English,,0,0,0,,Don't do sort of keep in mind there's certain things that you should as a programmer be doing all the time
Dialogue: 0,1:12:45.48,1:12:47.20,English,,0,0,0,,And they're not obvious
Dialogue: 0,1:12:47.72,1:12:52.54,English,,0,0,0,,And then begin thinking about tuning and getting some instruction level parallelism
Dialogue: 0,1:12:53.22,1:12:58.24,English,,0,0,0,,And I describe it as for the machine but as I said pretty much all processors nowadays
Dialogue: 0,1:12:58.48,1:13:01.98,English,,0,0,0,,It's a class of machines and so these general techniques will work
Dialogue: 0,1:13:02.46,1:13:05.58,English,,0,0,0,,That those ideas of changing the associativity
Dialogue: 0,1:13:05.78,1:13:10.86,English,,0,0,0,,They'll work whether it's a you know the arm processor built into my cell phone
Dialogue: 0,1:13:10.86,1:13:15.90,English,,0,0,0,,Or the x86 processor built into your laptop  or one of the shark machines
Dialogue: 0,1:13:15.90,1:13:19.72,English,,0,0,0,,They all have the same general of implementation structures
Dialogue: 0,1:13:19.72,1:13:23.52,English,,0,0,0,,So these techniques will work across across all of them
Dialogue: 0,1:13:24.34,1:13:28.57,English,,0,0,0,,Okay that'll do us for today
hese techniques will work across across all of them
Dialogue: 0,1:13:24.34,1:13:28.57,English,,0,0,0,,okay that'll do us for today
