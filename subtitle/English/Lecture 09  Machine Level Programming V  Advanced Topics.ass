[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video File: ../../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.015625
Active Line: 4
Video Position: 793

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.82,English,,0,0,0,,This come this will be the last lecture on machine level programming
Dialogue: 0,0:00:05.42,0:00:09.94,English,,0,0,0,,We call it advanced topics but think of it more as miscellaneous topics
Dialogue: 0,0:00:10.70,0:00:16.00,English,,0,0,0,,And I think most to you of course you know that your bomb lab due tonight
Dialogue: 0,0:00:16.00,0:00:20.72,English,,0,0,0,,So you most year probably well into that or hopefully through it
Dialogue: 0,0:00:21.08,0:00:26.44,English,,0,0,0,,And then at midnight tonight the next web will come out which is called a tack lab
Dialogue: 0,0:00:26.96,0:00:28.98,English,,0,0,0,,And there is a recitation about that yesterday
Dialogue: 0,0:00:28.98,0:00:32.90,English,,0,0,0,,But this is a lab that's  a new to the course
Dialogue: 0,0:00:33.36,0:00:37.50,English,,0,0,0,,It's a similar to one that we used to use at this point in the course
Dialogue: 0,0:00:37.64,0:00:41.60,English,,0,0,0,,But it's been updated and changed in significant ways
Dialogue: 0,0:00:41.70,0:00:49.88,English,,0,0,0,,So we're actually when you have labs like we do in this course with this many students
Dialogue: 0,0:00:49.88,0:00:51.90,English,,0,0,0,,There's a lot of things that go can go wrong
Dialogue: 0,0:00:51.90,0:00:55.96,English,,0,0,0,,So we're going to keep a close eye on on how things are going
Dialogue: 0,0:00:55.96,0:00:59.70,English,,0,0,0,,But I'd encourage you you only have a week and a half to do this next lab
Dialogue: 0,0:01:00.10,0:01:05.10,English,,0,0,0,,To get started soon and partly by having some people start sooner
Dialogue: 0,0:01:05.10,0:01:07.88,English,,0,0,0,,You'll start breaking things for us that we can track down
Dialogue: 0,0:01:09.56,0:01:16.94,English,,0,0,0,,So today what we'll talk about is a couple like I said it's miscellaneous topics but important topics
Dialogue: 0,0:01:17.00,0:01:21.92,English,,0,0,0,,One is just sort of where what does the memory look like ah
Dialogue: 0,0:01:21.92,0:01:25.52,English,,0,0,0,,When you're running x86-64 programs
Dialogue: 0,0:01:26.00,0:01:31.34,English,,0,0,0,,The other is a very important topic on security vulnerability called buffer overflows
Dialogue: 0,0:01:31.86,0:01:37.44,English,,0,0,0,,And in fact at a collab will be precisely exploiting those security vulnerabilities
Dialogue: 0,0:01:37.96,0:01:43.02,English,,0,0,0,,And then we'll look at unions so far you've booked it arrays and structs and how they're organized
Dialogue: 0,0:01:43.72,0:01:45.90,English,,0,0,0,,And I want to compare that to unions
Dialogue: 0,0:01:47.88,0:01:53.82,English,,0,0,0,,So let's talk about memory  then as I said at the beginning early in the course
Dialogue: 0,0:01:54.26,0:01:57.68,English,,0,0,0,,Conceptually a memory is just a big array of bytes
Dialogue: 0,0:01:58.46,0:02:03.44,English,,0,0,0,,And that's the view of this the machine level programmer
Dialogue: 0,0:02:03.72,0:02:05.70,English,,0,0,0,,Even though it's not the actual implementation
Dialogue: 0,0:02:05.70,0:02:08.70,English,,0,0,0,,There's a whole part that we'll talk about later in the course
Dialogue: 0,0:02:09.58,0:02:11.84,English,,0,0,0,,Of this is called virtual memory
Dialogue: 0,0:02:12.92,0:02:16.14,English,,0,0,0,,This organization is very simple organization
Dialogue: 0,0:02:16.60,0:02:20.28,English,,0,0,0,,But the underlying implementation is this complex management of
Dialogue: 0,0:02:20.88,0:02:27.52,English,,0,0,0,,Various different memory types from disk memories to solid state disks
Dialogue: 0,0:02:28.00,0:02:32.60,English,,0,0,0,,And to what's called dram which stands for dynamic ram the
Dialogue: 0,0:02:32.80,0:02:35.88,English,,0,0,0,,When you buy memory for your processor its dram
Dialogue: 0,0:02:36.98,0:02:43.96,English,,0,0,0,,Um so as you know in x86-64 we're working with machines that nominally are
Dialogue: 0,0:02:44.78,0:02:48.27,English,,0,0,0,,Have addresses can be up to 64 bits long
Dialogue: 0,0:02:48.66,0:02:52.22,English,,0,0,0,,And if you work out the numbers remember I told you at the beginning of the course
Dialogue: 0,0:02:52.22,0:03:00.28,English,,0,0,0,,You can estimate how big a number like to the 64 is  by remembering that 1024
Dialogue: 0,0:03:00.82,0:03:03.22,English,,0,0,0,,And a thousand are very close to each other
Dialogue: 0,0:03:03.22,0:03:07.66,English,,0,0,0,,So 2^10 is roughly the same as 10^3
Dialogue: 0,0:03:08.52,0:03:11.48,English,,0,0,0,,So you take 64 and you.thank 60
Dialogue: 0,0:03:11.48,0:03:15.78,English,,0,0,0,,So how big is two to the sixty well that's six times ten
Dialogue: 0,0:03:17.44,0:03:21.04,English,,0,0,0,,And therefore it's six times three it's like ten to the eighteenth
Dialogue: 0,0:03:22.28,0:03:27.00,English,,0,0,0,,And then you add the four to that that's two to the fourth and 16
Dialogue: 0,0:03:27.00,0:03:30.58,English,,0,0,0,,So it's around 16 times 10 to the 18th fights
Dialogue: 0,0:03:31.64,0:03:40.26,English,,0,0,0,,So if you were to go off and look online on amazon for dram chips
Dialogue: 0,0:03:40.26,0:03:44.74,English,,0,0,0,,And try to buy that much memory you'd find you're spending a lot of money
Dialogue: 0,0:03:45.66,0:03:52.60,English,,0,0,0,,More than you I don't know the numbers but it would be a lot of memory money
Dialogue: 0,0:03:53.06,0:03:55.16,English,,0,0,0,,And so you basically can't do it nowadays
Dialogue: 0,0:03:56.12,0:04:00.48,English,,0,0,0,,Tend to the and so
Dialogue: 0,0:04:02.28,0:04:09.72,English,,0,0,0,,Right now the machines limit you to actually only 47 bits worth of address  in the address space
Dialogue: 0,0:04:10.54,0:04:19.28,English,,0,0,0,,I'll and so 2 to the 47th again work that out that's like 10 to the 12th times 256 times 10 to the 12th
Dialogue: 0,0:04:19.28,0:04:21.82,English,,0,0,0,,So it's 256 terabytes
Dialogue: 0,0:04:23.16,0:04:26.86,English,,0,0,0,,And as you know you can buy a disk drive now that has 8 air bites
Dialogue: 0,0:04:26.86,0:04:28.36,English,,0,0,0,,So it doesn't seem like that much
Dialogue: 0,0:04:28.36,0:04:37.54,English,,0,0,0,,But if you tried to buy that much dram again you'd have to have a pretty big credit-card limit
Dialogue: 0,0:04:38.12,0:04:45.70,English,,0,0,0,,And so even that's a huge number and modern super computer installations actually will have  almost that much memory
Dialogue: 0,0:04:45.70,0:04:51.76,English,,0,0,0,,But the point is that the hardware of today limits you to 47 bits worth of address
Dialogue: 0,0:04:52.56,0:04:58.18,English,,0,0,0,,But that's not really a real limitation in terms of of of actual machines
Dialogue: 0,0:04:58.32,0:05:03.12,English,,0,0,0,,And what will happen is memory prices get cheaper and the technology gets better
Dialogue: 0,0:05:03.46,0:05:08.10,English,,0,0,0,,They'll slowly start adding as succeeding generations of processors come along
Dialogue: 0,0:05:08.78,0:05:11.62,English,,0,0,0,,Let you have bigger and bigger range of addresses
Dialogue: 0,0:05:12.52,0:05:17.30,English,,0,0,0,,So all that is to say that's why
Dialogue: 0,0:05:19.58,0:05:23.84,English,,0,0,0,,This number shows up which is a seven	 followed by eleven fs
Dialogue: 0,0:05:27.76,0:05:32.68,English,,0,0,0,,I can tell I need to scribble some numbers you guys
Dialogue: 0,0:05:32.68,0:05:35.56,English,,0,0,0,,Aren't just saying numbers in the air is not working here
Dialogue: 0,0:05:36.88,0:05:49.88,English,,0,0,0,,So let's try
Dialogue: 0,0:05:50.20,0:05:53.96,English,,0,0,0,,Ok
Dialogue: 0,0:05:55.32,0:06:06.21,English,,0,0,0,,Okay so remember I said before to 264 is about equal to 16 times 10 to the 18th
Dialogue: 0,0:06:09.20,0:06:17.82,English,,0,0,0,,And 2 to the 47th is 128 times 10 to the 12th
Dialogue: 0,0:06:19.24,0:06:21.14,English,,0,0,0,,So it's 128 terabytes
Dialogue: 0,0:06:29.26,0:06:33.56,English,,0,0,0,,So what's the number after a terabyte you know 10 to the 15th
Dialogue: 0,0:06:36.78,0:06:40.74,English,,0,0,0,,How many but yes petabytes right
Dialogue: 0,0:06:44.82,0:06:48.58,English,,0,0,0,,And you know what 10v 18th is exha
Dialogue: 0,0:06:53.40,0:07:00.02,English,,0,0,0,,So just as a reference a company like google roughly
Dialogue: 0,0:07:00.46,0:07:04.10,English,,0,0,0,,It's probably it's total storage across the whole
Dialogue: 0,0:07:04.90,0:07:08.70,English,,0,0,0,,Enterprise is measured in some small number of x bytes
Dialogue: 0,0:07:09.80,0:07:18.00,English,,0,0,0,,And it every day is getting several petabytes I don't know the numbers are of course secret
Dialogue: 0,0:07:18.04,0:07:25.52,English,,0,0,0,,But maybe 10 petabytes or more per day of new data that it's ingesting into its system so
Dialogue: 0,0:07:26.02,0:07:30.54,English,,0,0,0,,These numbers are pretty huge but not just totally off the charts
Dialogue: 0,0:07:30.54,0:07:39.20,English,,0,0,0,,Do you know what 10 to the 21st is it's called a zettabyte  with two t's
Dialogue: 0,0:07:41.54,0:07:45.90,English,,0,0,0,,And it's estimated if you add up all the digital content in the world
Dialogue: 0,0:07:45.90,0:07:49.90,English,,0,0,0,,That gets created everybody's cell phone camera every video
Dialogue: 0,0:07:50.40,0:07:55.92,English,,0,0,0,,Taken by anyone anywhere  all year long is a couple of zettabytes a year
Dialogue: 0,0:07:55.96,0:08:02.30,English,,0,0,0,,So it'll be a while before we're really having to deal with that kind of memory
Dialogue: 0,0:08:03.18,0:08:10.36,English,,0,0,0,,So just just to give you an idea so 128 terabytes is the address limit on these systems
Dialogue: 0,0:08:10.70,0:08:17.52,English,,0,0,0,,And so that's why you have to have seven because you remember that's one two three
Dialogue: 0,0:08:18.22,0:08:26.10,English,,0,0,0,,And then there's f but there's 11 of them and this is one one one times 11
Dialogue: 0,0:08:26.10,0:08:31.32,English,,0,0,0,,So that's 44 ones and this is three ones
Dialogue: 0,0:08:33.44,0:08:36.44,English,,0,0,0,,And that's where you get 47
Dialogue: 0,0:08:37.58,0:08:41.86,English,,0,0,0,,And that's the address of the in Linux
Dialogue: 0,0:08:42.32,0:08:46.94,English,,0,0,0,,That's where they put the stack  is up at the very top of the address space
Dialogue: 0,0:08:47.14,0:08:53.58,English,,0,0,0,,And I should tell you this picture is not at all to scale it would be impossible to draw this picture to scale
Dialogue: 0,0:08:54.30,0:08:59.10,English,,0,0,0,,For example it shows that the stack starts way up at the top
Dialogue: 0,0:08:59.10,0:09:05.86,English,,0,0,0,,And remember stacks grow to smaller addresses when you're pushing and also we show the
Dialogue: 0,0:09:06.30,0:09:09.54,English,,0,0,0,,Them upside down just to make everything confusing
Dialogue: 0,0:09:10.08,0:09:17.01,English,,0,0,0,,So the the stack starts there and it grows towards lower addresses
Dialogue: 0,0:09:17.32,0:09:20.50,English,,0,0,0,,And on a typical system it will be limited to 8 megabytes
Dialogue: 0,0:09:20.78,0:09:23.98,English,,0,0,0,,And you can tell that on a Linux system at least
Dialogue: 0,0:09:25.38,0:09:28.78,English,,0,0,0,,With the the limit command
Dialogue: 0,0:09:30.06,0:09:38.30,English,,0,0,0,,Which used to be more interesting than it was is now because a lot of things are unlimited
Dialogue: 0,0:09:38.76,0:09:43.76,English,,0,0,0,,But you see it says the stack size is limited to 8192 k bytes or kilobytes
Dialogue: 0,0:09:43.76,0:09:46.12,English,,0,0,0,,So it's 8 megabytes
Dialogue: 0,0:09:49.96,0:10:00.77,English,,0,0,0,,And what that means is if you tried to access any memory  via the stack pointer
Dialogue: 0,0:10:01.60,0:10:09.10,English,,0,0,0,,That was outside of the range of this 8 megabyte range you'd get a segmentation fault
Dialogue: 0,0:10:10.40,0:10:17.74,English,,0,0,0,,And then down at the lower addresses what comes in what gets put into your program are the parts of the code
Dialogue: 0,0:10:17.74,0:10:20.60,English,,0,0,0,,That that come out of the executable file
Dialogue: 0,0:10:20.94,0:10:25.10,English,,0,0,0,,And so there's a section and we'll talk more when we talk about linking actually
Dialogue: 0,0:10:25.10,0:10:28.36,English,,0,0,0,,About the way out of the memory and the different regions of it
Dialogue: 0,0:10:28.82,0:10:36.80,English,,0,0,0,,But for some obscure reason they they call where the code is sitting the executable program  the text segment
Dialogue: 0,0:10:36.81,0:10:41.90,English,,0,0,0,,I don't know why that's true but it's the way it is and that's across many machines
Dialogue: 0,0:10:42.30,0:10:49.89,English,,0,0,0,,And then the data is first of all there'll be a section for the data that's allocated at the program begins
Dialogue: 0,0:10:49.89,0:10:55.54,English,,0,0,0,,So any global variables that you've declared will be in that section
Dialogue: 0,0:10:56.26,0:11:02.86,English,,0,0,0,,And then the heap is the part of memory that is x is allocated via call to malloc
Dialogue: 0,0:11:02.86,0:11:05.04,English,,0,0,0,,Or one of its related functions
Dialogue: 0,0:11:05.06,0:11:08.16,English,,0,0,0,,And so that varies dynamically as the program runs
Dialogue: 0,0:11:08.72,0:11:13.30,English,,0,0,0,,It starts off with a very small allocation and every time you call malloc
Dialogue: 0,0:11:14.08,0:11:19.96,English,,0,0,0,,If you're not freeing memory and so your memory requirements keep growing
Dialogue: 0,0:11:20.20,0:11:25.68,English,,0,0,0,,It will crease keep up moving up larger and larger addresses
Dialogue: 0,0:11:26.16,0:11:30.18,English,,0,0,0,,And then somewhere in the code - and this can vary by system is
Dialogue: 0,0:11:30.50,0:11:37.76,English,,0,0,0,,The code that gets brought in that represents the library functions things like printf and malloc itself
Dialogue: 0,0:11:38.28,0:11:40.98,English,,0,0,0,,Our own library code they're stored off on disk
Dialogue: 0,0:11:40.98,0:11:44.32,English,,0,0,0,,And they get brought in they get linked into your program
Dialogue: 0,0:11:44.32,0:11:48.16,English,,0,0,0,,When it first starts executing by a process known as dynamic linking
Dialogue: 0,0:11:48.32,0:11:51.74,English,,0,0,0,,Which we'll talk about later in the course too with the linking
Dialogue: 0,0:11:52.38,0:11:55.01,English,,0,0,0,,And what you'll find in general is that
Dialogue: 0,0:11:55.30,0:11:59.02,English,,0,0,0,,Allocations will tend to be either at these very low addresses
Dialogue: 0,0:11:59.38,0:12:03.74,English,,0,0,0,,Or these very high addresses as your program is running
Dialogue: 0,0:12:06.72,0:12:09.44,English,,0,0,0,,So just as an example here is some code
Dialogue: 0,0:12:09.84,0:12:15.08,English,,0,0,0,,Um that it's only value is to show you different  where things get located
Dialogue: 0,0:12:15.50,0:12:19.50,English,,0,0,0,,And so you'll see I allocated some a fairly large arrays here
Dialogue: 0,0:12:19.50,0:12:26.60,English,,0,0,0,,This one is there all cares but this is 2 to the 24th so it's 16
Dialogue: 0,0:12:27.20,0:12:31.10,English,,0,0,0,,A megabyte array and this one is 2<<31
Dialogue: 0,0:12:31.88,0:12:37.10,English,,0,0,0,,So it's 2 gigabytes worth of array
Dialogue: 0,0:12:37.10,0:12:43.84,English,,0,0,0,,I found that if I tried to allocate larger ones it the program wouldn't run
Dialogue: 0,0:12:44.82,0:12:51.92,English,,0,0,0,,And I also do some here's just a sort of global variable and here's a function
Dialogue: 0,0:12:52.90,0:12:56.94,English,,0,0,0,,And then there's a single function here with some local variable
Dialogue: 0,0:12:56.94,0:12:59.60,English,,0,0,0,,And that will be allocated somewhere on the stack
Dialogue: 0,0:13:00.38,0:13:05.72,English,,0,0,0,,And then there's several calls to milk some of which are for some very small chunks of memory
Dialogue: 0,0:13:06.04,0:13:08.94,English,,0,0,0,,And somewhere for some very large chunks of memory
Dialogue: 0,0:13:09.52,0:13:15.87,English,,0,0,0,,And so we can run this program and see what addresses pop out of it
Dialogue: 0,0:13:16.34,0:13:19.08,English,,0,0,0,,And what you'll see is the stack
Dialogue: 0,0:13:19.48,0:13:24.94,English,,0,0,0,,This local variable is somewhere up with an address in the range of the stack
Dialogue: 0,0:13:24.94,0:13:28.44,English,,0,0,0,,And you see the 7 and a couple fs and then it goes to something else
Dialogue: 0,0:13:29.40,0:13:35.54,English,,0,0,0,,And you'll see also interestingly enough that the code and then looking down at the bottom
Dialogue: 0,0:13:36.60,0:13:42.62,English,,0,0,0,,Of this yellow color is things get relegated to the text segment the main function
Dialogue: 0,0:13:42.94,0:13:46.50,English,,0,0,0,,And this function I called I declared called useless
Dialogue: 0,0:13:47.10,0:13:49.42,English,,0,0,0,,And then the predefined arrays
Dialogue: 0,0:13:50.58,0:13:55.16,English,,0,0,0,,That were in other words globally declared not declared by malloc
Dialogue: 0,0:13:55.16,0:14:02.18,English,,0,0,0,,They're declared as part of the program itself are down here in this data section
Dialogue: 0,0:14:02.75,0:14:08.52,English,,0,0,0,,And because it's a very large array, the huge array you actually get some fairly large addresses
Dialogue: 0,0:14:09.26,0:14:11.12,English,,0,0,0,,And then interestingly enough
Dialogue: 0,0:14:11.66,0:14:15.56,English,,0,0,0,,Or I don't know why it's interesting but for one reason or another
Dialogue: 0,0:14:16.46,0:14:22.02,English,,0,0,0,,It happen that the smaller chunks of memory allocations
Dialogue: 0,0:14:22.34,0:14:28.74,English,,0,0,0,,Are down here at addresses that are actually just a little bit above  the the pink section right
Dialogue: 0,0:14:29.06,0:14:32.30,English,,0,0,0,,And similarly the really big chunks of memory I a located
Dialogue: 0,0:14:32.48,0:14:38.62,English,,0,0,0,,Are way up here near the stack limit
Dialogue: 0,0:14:39.28,0:14:43.60,English,,0,0,0,,And they are
Dialogue: 0,0:14:43.68,0:14:47.94,English,,0,0,0,,And so they're there and in general what's happening is if I were to try and reference
Dialogue: 0,0:14:48.50,0:14:53.07,English,,0,0,0,,A memory address in this empty range I'd get a segmentation fault
Dialogue: 0,0:14:53.46,0:14:57.96,English,,0,0,0,,It's a valid address in terms of its bit of properties
Dialogue: 0,0:14:57.96,0:15:03.10,English,,0,0,0,,But it hasn't actually been set up and allocated by the memory the virtual memory allocator
Dialogue: 0,0:15:03.10,0:15:06.10,English,,0,0,0,,So at any given time the valid addresses
Dialogue: 0,0:15:06.46,0:15:12.00,English,,0,0,0,,Are just those in the lower portion or the upper portion of this address ranges
Dialogue: 0,0:15:12.24,0:15:14.16,English,,0,0,0,,And the middle is sort of no-man's land
Dialogue: 0,0:15:14.38,0:15:17.44,English,,0,0,0,,And then what happens is you keep allocating more with malloc
Dialogue: 0,0:15:17.86,0:15:22.46,English,,0,0,0,,And it will push the limits of what's addressable in toward it
Dialogue: 0,0:15:22.86,0:15:29.46,English,,0,0,0,,And in principle if you ever got too much of a memory request
Dialogue: 0,0:15:29.48,0:15:35.26,English,,0,0,0,,If these two would hit each other and you and malik would return zero at that point
Dialogue: 0,0:15:35.64,0:15:43.26,English,,0,0,0,,But it's highly unlikely given that you have 128 terabytes of memory address range here
Dialogue: 0,0:15:44.06,0:15:46.94,English,,0,0,0,,So that just and you've probably seen this when you're running
Dialogue: 0,0:15:47.48,0:15:50.50,English,,0,0,0,,You're looking at disassembled code with gdb
Dialogue: 0,0:15:50.50,0:15:56.76,English,,0,0,0,,You're seeing some addresses that are way up here with the 7 and some f so they're stack addresses
Dialogue: 0,0:15:57.20,0:15:58.82,English,,0,0,0,,And you see these fours
Dialogue: 0,0:15:59.56,0:16:03.90,English,,0,0,0,,You know a lot of zeros and some fours those tend to be where the code is going
Dialogue: 0,0:16:04.32,0:16:09.28,English,,0,0,0,,To question
Dialogue: 0,0:16:09.42,0:16:12.34,English,,0,0,0,,Why doesn't the heat proceed in one direction I actually don't know
Dialogue: 0,0:16:13.04,0:16:18.32,English,,0,0,0,,I'll just observe that it was had a strategy of putting big things here in small things here
Dialogue: 0,0:16:18.32,0:16:22.88,English,,0,0,0,,And it probably uses different slightly different management strategies for those two
Dialogue: 0,0:16:33.10,0:16:38.74,English,,0,0,0,,Okay so that I think you'll find that kind of useful to have some sense when you're looking at
Dialogue: 0,0:16:39.20,0:16:42.40,English,,0,0,0,,When you're running gdb it helps to just have some idea of
Dialogue: 0,0:16:42.40,0:16:45.20,English,,0,0,0,,What's going on when you're looking at these different addresses
Dialogue: 0,0:16:47.36,0:16:50.44,English,,0,0,0,,Okay now let's talk about buffer overflow
Dialogue: 0,0:16:50.92,0:16:55.34,English,,0,0,0,,And we'll start this you remember on the very first class
Dialogue: 0,0:16:55.34,0:16:58.48,English,,0,0,0,,And I think we might have reviewed this part way along
Dialogue: 0,0:16:58.80,0:17:04.78,English,,0,0,0,,We showed this example of some programs where if you do an out-of-bounds
Dialogue: 0,0:17:06.18,0:17:10.08,English,,0,0,0,,Reference and write a value that's out of bounds in particular
Dialogue: 0,0:17:10.96,0:17:14.60,English,,0,0,0,,I only have a array of two elements here
Dialogue: 0,0:17:15.00,0:17:18.20,English,,0,0,0,,But this function will take an arbitrary value of i
Dialogue: 0,0:17:18.54,0:17:23.04,English,,0,0,0,,And assign some magic number to ailment I of the array
Dialogue: 0,0:17:24.06,0:17:25.86,English,,0,0,0,,And it has the possibility of
Dialogue: 0,0:17:27.88,0:17:30.28,English,,0,0,0,,And we saw that when you do that
Dialogue: 0,0:17:30.38,0:17:33.24,English,,0,0,0,,If I gets too big it will first
Dialogue: 0,0:17:33.98,0:17:39.12,English,,0,0,0,,Corrupt the the double that stored is part of the struct
Dialogue: 0,0:17:39.52,0:17:42.42,English,,0,0,0,,And then when it gets bigger it seems to
Dialogue: 0,0:17:42.92,0:17:47.16,English,,0,0,0,,Not have any effect until it gets too big and then you start corrupting memory
Dialogue: 0,0:17:47.74,0:17:54.20,English,,0,0,0,,So the basic point is that it's very easy in a program  a C program in particular
Dialogue: 0,0:17:54.56,0:17:59.60,English,,0,0,0,,To a reference memory that's not part of the sort of intent of the program
Dialogue: 0,0:18:02.20,0:18:09.50,English,,0,0,0,,And this can happen in programs that aren't properly written that
Dialogue: 0,0:18:10.32,0:18:19.66,English,,0,0,0,,And it becomes a security vulnerability if there's some way for an outsider to overflow a buffer
Dialogue: 0,0:18:20.24,0:18:25.20,English,,0,0,0,,For example if there is some way for an outsider to give a larger value of I and ask that
Dialogue: 0,0:18:25.70,0:18:28.42,English,,0,0,0,,That value be stored there it could crash the program
Dialogue: 0,0:18:29.34,0:18:33.98,English,,0,0,0,,And so in general when you write in code you try to think about  can I trust this value
Dialogue: 0,0:18:33.98,0:18:39.84,English,,0,0,0,,This a value that's been computed by my program and I'm sure that it's within bounds
Dialogue: 0,0:18:40.20,0:18:43.36,English,,0,0,0,,Or is it something that's come from an external source
Dialogue: 0,0:18:43.36,0:18:48.16,English,,0,0,0,,And there is potentially that risk of being a vulnerability
Dialogue: 0,0:18:49.58,0:18:53.22,English,,0,0,0,,And so in particular there's a lot a huge class of errors
Dialogue: 0,0:18:53.22,0:18:57.68,English,,0,0,0,,That have to do with overflowing buffers where
Dialogue: 0,0:18:58.16,0:19:04.94,English,,0,0,0,,Where they're trying to store a string of some type that's been read from a message
Dialogue: 0,0:19:05.70,0:19:10.38,English,,0,0,0,,And without knowing in advance how big that string is
Dialogue: 0,0:19:10.38,0:19:14.90,English,,0,0,0,,It's possible that it will be too big for the buffer that's been allocated
Dialogue: 0,0:19:15.48,0:19:21.72,English,,0,0,0,,And so one of the culprits is there's a whole class of library functions that
Dialogue: 0,0:19:22.32,0:19:30.04,English,,0,0,0,,Let you store something a string somewhere without any kind of bounds checking even being possible
Dialogue: 0,0:19:30.73,0:19:34.70,English,,0,0,0,,So the sort of worst one is one called gets
Dialogue: 0,0:19:35.20,0:19:39.58,English,,0,0,0,,And the purpose of gets is normally it's used to read a string from
Dialogue: 0,0:19:40.18,0:19:46.00,English,,0,0,0,,An input from a terminal input something that somebody's typed into a terminal
Dialogue: 0,0:19:46.38,0:19:50.14,English,,0,0,0,,And so what it's doing is it's scanning this input string
Dialogue: 0,0:19:50.46,0:19:54.76,English,,0,0,0,,And looking for a character that represents the end of the line
Dialogue: 0,0:19:54.94,0:19:59.14,English,,0,0,0,,Which we write in of cea's is backslash n
Dialogue: 0,0:19:59.48,0:20:02.94,English,,0,0,0,,And it has a character code at hex of 0 a
Dialogue: 0,0:20:04.58,0:20:11.28,English,,0,0,0,,And so gets this is sort of an approximate version of what the code for gets looks like
Dialogue: 0,0:20:11.78,0:20:17.02,English,,0,0,0,,That and it's as an argument it's just given a destination of where to store the result
Dialogue: 0,0:20:17.48,0:20:20.76,English,,0,0,0,,And all it does is it reads one character at a time
Dialogue: 0,0:20:21.16,0:20:27.63,English,,0,0,0,,Looks for an end-of-file meaning that the input stream is closed  or an end-of-line
Dialogue: 0,0:20:27.66,0:20:34.80,English,,0,0,0,,But as long as it until it sees that it just keeps adding more things to the end of this buffer
Dialogue: 0,0:20:37.66,0:20:39.28,English,,0,0,0,,And so typically
Dialogue: 0,0:20:43.98,0:20:50.66,English,,0,0,0,,When somebody calls gets they'll pass it a pointer to some buffer that they've allocated
Dialogue: 0,0:20:51.36,0:20:56.00,English,,0,0,0,,But the function and it will just get us we'll just fill that buffer up
Dialogue: 0,0:20:56.80,0:21:00.76,English,,0,0,0,,But it can potentially just keep going there's nothing in the function
Dialogue: 0,0:21:00.96,0:21:03.44,English,,0,0,0,,There's not even an argument to the function
Dialogue: 0,0:21:03.90,0:21:08.28,English,,0,0,0,,That tells the function when when it has to stop
Dialogue: 0,0:21:08.56,0:21:10.26,English,,0,0,0,,When it's reached the limit of it
Dialogue: 0,0:21:10.58,0:21:13.30,English,,0,0,0,,So it was written it actually get us is
Dialogue: 0,0:21:13.30,0:21:17.62,English,,0,0,0,,If you try to compile code would get us it will flash up a big warning that says
Dialogue: 0,0:21:17.62,0:21:21.10,English,,0,0,0,,This is really an unsafe function you probably shouldn't even be using it
Dialogue: 0,0:21:21.50,0:21:28.74,English,,0,0,0,,Because it it has it was written in an era in the 1970s 
Dialogue: 0,0:21:28.74,0:21:31.40,English,,0,0,0,,Even be using it  the early unix distributions were coming out
Dialogue: 0,0:21:31.76,0:21:34.60,English,,0,0,0,,Where people just weren't worried about security vulnerabilities
Dialogue: 0,0:21:34.78,0:21:40.94,English,,0,0,0,,And they just assumed that if you allocated a big enough buffer
Dialogue: 0,0:21:41.32,0:21:46.44,English,,0,0,0,,That there's no reason why a string should be bigger than what you've allocated
Dialogue: 0,0:21:47.90,0:21:53.16,English,,0,0,0,,And that's actually true with other functions like strcpy
Dialogue: 0,0:21:53.68,0:21:58.80,English,,0,0,0,,You recall strcpy has two arguments
Dialogue: 0,0:21:59.40,0:22:02.86,English,,0,0,0,,Excuse me a destination and a source
Dialogue: 0,0:22:03.78,0:22:08.64,English,,0,0,0,,And its purpose is to copy the string at the source into the destination
Dialogue: 0,0:22:09.08,0:22:13.14,English,,0,0,0,,And the way it determines the end of the string and the source is when it hits a null character
Dialogue: 0,0:22:13.60,0:22:17.86,English,,0,0,0,,That just keeps copying one by one well until it hits it
Dialogue: 0,0:22:18.10,0:22:22.38,English,,0,0,0,,But it has no way of knowing there's nothing no information there about how much
Dialogue: 0,0:22:22.76,0:22:27.38,English,,0,0,0,,How big is the the buffer allocated at the destination
Dialogue: 0,0:22:27.70,0:22:29.66,English,,0,0,0,,And so it can easily overrun that
Dialogue: 0,0:22:29.92,0:22:36.66,English,,0,0,0,,That a similar one called stir cat which is used to concatenate two strings  copy amasian
Dialogue: 0,0:22:37.34,0:22:44.30,English,,0,0,0,,And the scanf functions also have possible in the format string
Dialogue: 0,0:22:44.30,0:22:46.06,English,,0,0,0,,You can give the %s
Dialogue: 0,0:22:46.82,0:22:52.84,English,,0,0,0,,A directive to the format string which says read in a string  and store it someplace
Dialogue: 0,0:22:53.56,0:22:56.74,English,,0,0,0,,And it doesn't say how long the string is limited to be
Dialogue: 0,0:22:56.74,0:23:00.52,English,,0,0,0,,And it doesn't say how much memory is available at the destination
Dialogue: 0,0:23:00.78,0:23:04.52,English,,0,0,0,,So again it can easily just write over that a buffer
Dialogue: 0,0:23:05.72,0:23:10.84,English,,0,0,0,,So these are real vulnerabilities and they we'll talk in a minute a little later about
Dialogue: 0,0:23:11.22,0:23:14.74,English,,0,0,0,,How you as a programmer can be a little smarter than this
Dialogue: 0,0:23:15.12,0:23:22.50,English,,0,0,0,,But in their suit of raw form as presented they have this vulnerability to them
Dialogue: 0,0:23:23.68,0:23:29.30,English,,0,0,0,,So let's look at an example of what this can what can happen there
Dialogue: 0,0:23:29.74,0:23:34.96,English,,0,0,0,,So imagine for example we want a to implement echo function
Dialogue: 0,0:23:34.96,0:23:40.02,English,,0,0,0,,So an echo function is one that you just type something in and it prints it back out
Dialogue: 0,0:23:40.02,0:23:43.80,English,,0,0,0,,It's very uninteresting function except it's very useful to demonstrate things
Dialogue: 0,0:23:44.58,0:23:49.32,English,,0,0,0,,So the idea is it has this little buffer it's only enough to hold four characters
Dialogue: 0,0:23:49.78,0:23:55.44,English,,0,0,0,,Because get us to read a string from the input and then it calls puts
Dialogue: 0,0:23:56.06,0:23:59.78,English,,0,0,0,,Which simply writes back out the output
Dialogue: 0,0:24:00.72,0:24:08.96,English,,0,0,0,,And
Dialogue: 0,0:24:09.38,0:24:14.06,English,,0,0,0,,And so let me just demo this not very interesting function
Dialogue: 0,0:24:21.14,0:24:24.98,English,,0,0,0,,So I call here buff demo-nsp
Dialogue: 0,0:24:26.74,0:24:31.04,English,,0,0,0,,Meaning as no stack protector we'll see in a minute what a stack protector is
Dialogue: 0,0:24:31.46,0:24:35.60,English,,0,0,0,,But you see if you type a reasonably strong small string
Dialogue: 0,0:24:41.92,0:24:47.08,English,,0,0,0,,Let's see what remember it can handle more than four
Dialogue: 0,0:24:48.04,0:24:50.98,English,,0,0,0,,Actually as written it can't handle more than three right
Dialogue: 0,0:24:50.98,0:24:55.26,English,,0,0,0,,Because there should be room for the null character - on terminator
Dialogue: 0,0:25:02.00,0:25:07.92,English,,0,0,0,,So it turns out with this particular one if I type in a string of 24 characters
Dialogue: 0,0:25:09.72,0:25:11.04,English,,0,0,0,,It'll be okay
Dialogue: 0,0:25:22.36,0:25:24.86,English,,0,0,0,,But if I type in a string of 24 characters
Dialogue: 0,0:25:27.52,0:25:30.02,English,,0,0,0,,It will hit a segmentation fault
Dialogue: 0,0:25:33.12,0:25:35.90,English,,0,0,0,,So where do those numbers 23 and 24 come in
Dialogue: 0,0:25:35.90,0:25:39.04,English,,0,0,0,,Well that's something we can learn by looking at the assembly code
Dialogue: 0,0:25:56.22,0:25:59.18,English,,0,0,0,,So here's and we'll go through this code
Dialogue: 0,0:26:00.08,0:26:04.70,English,,0,0,0,,So first of all this is the code for echo then
Dialogue: 0,0:26:05.58,0:26:09.18,English,,0,0,0,,And you see the echo calls gets and it calls puts
Dialogue: 0,0:26:13.34,0:26:19.56,English,,0,0,0,,And here's the part of the code where you can tell how much memory got allocated for the buffer
Dialogue: 0,0:26:20.06,0:26:29.34,English,,0,0,0,,And x18 is what in decimal and you
Dialogue: 0,0:26:34.04,0:26:34.98,English,,0,0,0,,24 right
Dialogue: 0,0:26:39.64,0:26:45.54,English,,0,0,0,,And just saw that the thing actually segfaults with a input string of 24
Dialogue: 0,0:26:45.54,0:26:46.60,English,,0,0,0,,So we'll see that in a minute
Dialogue: 0,0:26:47.50,0:26:55.28,English,,0,0,0,,But anyways you can see here that it's allocating on the stack a region of 24 bytes
Dialogue: 0,0:26:56.00,0:27:04.14,English,,0,0,0,,And it's copying that into rdi which is of course the argument forget us
Dialogue: 0,0:27:04.20,0:27:10.46,English,,0,0,0,,So get us is being called with a pointer to a buffer of size 24
Dialogue: 0,0:27:11.46,0:27:16.62,English,,0,0,0,,Of maximum 24 even though you saw the original declaration was just four four
Dialogue: 0,0:27:20.20,0:27:25.84,English,,0,0,0,,Um and then it calls gets and then get us does it thing i
Dialogue: 0,0:27:26.44,0:27:30.10,English,,0,0,0,,And just one last little bit to keep in mind is
Dialogue: 0,0:27:31.16,0:27:32.72,English,,0,0,0,,We'll get back to them
Dialogue: 0,0:27:33.14,0:27:36.10,English,,0,0,0,,Oh yes and remember echo
Dialogue: 0,0:27:38.36,0:27:42.74,English,,0,0,0,,I there's a function called call echo which is the thing that calls echo
Dialogue: 0,0:27:43.46,0:27:48.84,English,,0,0,0,,And just to keep in mind this red is the return address  for call echo
Dialogue: 0,0:27:49.94,0:27:51.88,English,,0,0,0,,And that's going to be important
Dialogue: 0,0:27:55.94,0:27:59.66,English,,0,0,0,,So what we see then is the memory way out is
Dialogue: 0,0:28:01.22,0:28:05.86,English,,0,0,0,,The buff is normally big enough for four characters
Dialogue: 0,0:28:06.58,0:28:10.60,English,,0,0,0,,There's a sort of 20 bytes of unused or wasted space here
Dialogue: 0,0:28:10.96,0:28:17.86,English,,0,0,0,,And then the actual return address which is the return address for back to call echo is stored on the stack
Dialogue: 0,0:28:23.56,0:28:28.80,English,,0,0,0,,So when this program int begins running when echo starts to run
Dialogue: 0,0:28:29.12,0:28:34.38,English,,0,0,0,,We'll find that this is the value on the stack for the return pointer
Dialogue: 0,0:28:35.98,0:28:43.04,English,,0,0,0,,And if we type in a string of up here of 23 characters
Dialogue: 0,0:28:43.88,0:28:50.22,English,,0,0,0,,You'll see that it uses up this entire buffer and remember a string is terminated with a 0 0
Dialogue: 0,0:28:51.10,0:28:57.40,English,,0,0,0,,But it still hasn't it's still within the region that was allocated on the stack for that
Dialogue: 0,0:28:57.48,0:29:01.60,English,,0,0,0,,So it just barely fits into the the stack
Dialogue: 0,0:29:02.18,0:29:06.20,English,,0,0,0,,And that's why we technically we overflowed the buffer
Dialogue: 0,0:29:06.20,0:29:10.40,English,,0,0,0,,But we didn't really cause any harm because there was this extra space available
Dialogue: 0,0:29:11.38,0:29:17.96,English,,0,0,0,,And so that's why I could type in that string of 23 characters and  and it worked fine
Dialogue: 0,0:29:18.96,0:29:31.24,English,,0,0,0,,But now if I type in this is an example showing actually 25 characters
Dialogue: 0,0:29:32.74,0:29:39.58,English,,0,0,0,,So once I go beyond the 23 characters plus the null character
Dialogue: 0,0:29:39.58,0:29:42.12,English,,0,0,0,,You'll see what I'm slowly starting to do is
Dialogue: 0,0:29:42.68,0:29:49.72,English,,0,0,0,,Is corrupt the the the byte representation of the return address
Dialogue: 0,0:29:50.38,0:29:52.64,English,,0,0,0,,And so what happens for example here
Dialogue: 0,0:29:53.00,0:29:57.94,English,,0,0,0,,Is that rather than trying to return back to the where call echo
Dialogue: 0,0:29:58.34,0:30:00.98,English,,0,0,0,,Was supposed to where it was supposed to go back to
Dialogue: 0,0:30:01.32,0:30:03.74,English,,0,0,0,,It goes back to some other part of your code
Dialogue: 0,0:30:04.20,0:30:08.08,English,,0,0,0,,That may or may not be a valid address or
Dialogue: 0,0:30:08.22,0:30:11.00,English,,0,0,0,,Might not have anything to do with the program you're trying to run
Dialogue: 0,0:30:12.56,0:30:16.56,English,,0,0,0,,So this example shows it and if I typed in the 24
Dialogue: 0,0:30:22.10,0:30:26.04,English,,0,0,0,,Let's see.before I got it to run
Dialogue: 0,0:30:26.04,0:30:29.94,English,,0,0,0,,Like this you know this thing depends on the what happens
Dialogue: 0,0:30:31.04,0:30:33.48,English,,0,0,0,,How the code happens to get compiled
Dialogue: 0,0:30:36.04,0:30:42.70,English,,0,0,0,,Oh yeah so okay so actually you see here
Dialogue: 0,0:30:43.90,0:30:49.12,English,,0,0,0,,This first string I typed is actually 24 characters long plus the null pointer
Dialogue: 0,0:30:49.80,0:30:54.12,English,,0,0,0,,So uh and we'll see why it didn't it should have crashed
Dialogue: 0,0:30:54.38,0:30:58.86,English,,0,0,0,,Because we actually overwrite wrote the low order byte of the return address
Dialogue: 0,0:30:59.68,0:31:02.10,English,,0,0,0,,Here we typed in this is 25 characters
Dialogue: 0,0:31:02.10,0:31:07.46,English,,0,0,0,,And so that's the one I just showed where it really whacked the two bytes of the return address
Dialogue: 0,0:31:08.02,0:31:10.22,English,,0,0,0,,So here we actually did overflow the buffer
Dialogue: 0,0:31:11.24,0:31:17.22,English,,0,0,0,,And let's try and figure out why that didn't harm the the program execution
Dialogue: 0,0:31:17.22,0:31:22.78,English,,0,0,0,,I see a question
Dialogue: 0,0:31:22.78,0:31:25.58,English,,0,0,0,,Yes it could have been various other things could have there's nothing
Dialogue: 0,0:31:26.26,0:31:28.68,English,,0,0,0,,It hit a segmentation fault
Dialogue: 0,0:31:28.98,0:31:33.14,English,,0,0,0,,Because it probably went to some weird part of the code and just started executing some random stuff
Dialogue: 0,0:31:33.48,0:31:35.14,English,,0,0,0,,And just got itself into trouble
Dialogue: 0,0:31:35.58,0:31:40.48,English,,0,0,0,,But that's the point is it's not predictable exactly what will happen when you do this
Dialogue: 0,0:31:52.40,0:31:56.10,English,,0,0,0,,So this is that the example of what actually happened the first time
Dialogue: 0,0:31:56.42,0:31:59.84,English,,0,0,0,,When I typed in a string that had 24 characters
Dialogue: 0,0:32:00.24,0:32:04.02,English,,0,0,0,,And so this null byte at the end actually corrupted the return address
Dialogue: 0,0:32:05.68,0:32:12.30,English,,0,0,0,,And so it was supposed to return back to this address 4006f6
Dialogue: 0,0:32:12.92,0:32:16.98,English,,0,0,0,,And instead it will return back to the address 400600
Dialogue: 0,0:32:18.04,0:32:21.64,English,,0,0,0,,Which happens to be in some other weird function that's there
Dialogue: 0,0:32:21.94,0:32:26.16,English,,0,0,0,,And it just sort of landed at some place here
Dialogue: 0,0:32:26.16,0:32:33.28,English,,0,0,0,,And it's doing various things but somehow it didn't really didn't crash the program
Dialogue: 0,0:32:33.28,0:32:38.62,English,,0,0,0,,And that's one of the frustrating things about this is that  things can go wrong in a program
Dialogue: 0,0:32:39.12,0:32:41.80,English,,0,0,0,,And they don't always cause a crash
Dialogue: 0,0:32:42.14,0:32:47.36,English,,0,0,0,,And so often a bug that's working there might be doing some weird stuff that you don't even know about
Dialogue: 0,0:32:51.44,0:32:56.90,English,,0,0,0,,So that's all a fine if it's just a way of crashing programs and
Dialogue: 0,0:32:57.26,0:33:01.54,English,,0,0,0,,I mean that's not great if it's controlling your pacemaker or something like that
Dialogue: 0,0:33:01.54,0:33:08.42,English,,0,0,0,,But if it's just a homework assignment it's like not a big deal so
Dialogue: 0,0:33:09.72,0:33:15.78,English,,0,0,0,,I'll but what actually and this is sort of only happened since
Dialogue: 0,0:33:16.00,0:33:22.22,English,,0,0,0,,Attacking became a normal activity which has only been the last 30 years
Dialogue: 0,0:33:22.62,0:33:27.18,English,,0,0,0,,Is that it gives an opportunity for a hacker or a attacker
Dialogue: 0,0:33:27.80,0:33:32.48,English,,0,0,0,,To inject code into the program and execute it
Dialogue: 0,0:33:32.48,0:33:35.52,English,,0,0,0,,And that's what's called a code injection attack
Dialogue: 0,0:33:36.34,0:33:43.18,English,,0,0,0,,And so that the general scheme of it is I have this buffer that I can fill up with whatever bytes I want
Dialogue: 0,0:33:43.52,0:33:47.68,English,,0,0,0,,By feeding them to get s or whatever function is doing this copying
Dialogue: 0,0:33:48.00,0:33:51.36,English,,0,0,0,,And what I can do then is set up and pass to it
Dialogue: 0,0:33:51.46,0:33:57.48,English,,0,0,0,,Some bytes of actually that encode an executable a little bit of executable code
Dialogue: 0,0:33:57.48,0:34:03.32,English,,0,0,0,,You've seen an object dump it's printing out these byte code representations of instructions
Dialogue: 0,0:34:03.32,0:34:09.24,English,,0,0,0,,So imagine you fed some of those bites into your string
Dialogue: 0,0:34:09.26,0:34:11.90,English,,0,0,0,,You encoded them in the string that you pass to get us
Dialogue: 0,0:34:13.04,0:34:20.56,English,,0,0,0,,And then you might have to add some more sort of padding characters
Dialogue: 0,0:34:20.56,0:34:22.56,English,,0,0,0,,That characters whose value doesn't matter
Dialogue: 0,0:34:23.03,0:34:30.14,English,,0,0,0,,In order to then get a number back into the position where the return pointer is supposed to be
Dialogue: 0,0:34:30.64,0:34:33.76,English,,0,0,0,,And so what's call that number b  it's going to be an address
Dialogue: 0,0:34:34.20,0:34:39.22,English,,0,0,0,,One of these ones with the you know that represents a stack location
Dialogue: 0,0:34:39.58,0:34:44.24,English,,0,0,0,,And that value b that is the the starting address of the buffer
Dialogue: 0,0:34:44.72,0:34:50.52,English,,0,0,0,,Which happens to be where your exploit code remember this is just executable instructions
Dialogue: 0,0:34:51.12,0:34:53.52,English,,0,0,0,,Of words stored here
Dialogue: 0,0:34:53.78,0:35:00.46,English,,0,0,0,,So now what will happen is when the program does its return here
Dialogue: 0,0:35:01.54,0:35:06.12,English,,0,0,0,,It was supposed to return back to wherever it got called from p
Dialogue: 0,0:35:11.18,0:35:14.58,English,,0,0,0,,This is a typo p calls q not the bar
Dialogue: 0,0:35:18.25,0:35:20.62,English,,0,0,0,,So it's supposed to return back to p
Dialogue: 0,0:35:21.46,0:35:26.66,English,,0,0,0,,And we're and the address the return address was stored here
Dialogue: 0,0:35:26.66,0:35:31.54,English,,0,0,0,,But now I've overwritten that return address  with this buffer position
Dialogue: 0,0:35:31.54,0:35:37.40,English,,0,0,0,,So what will happen is the the program counter will happily jump to this spot
Dialogue: 0,0:35:37.40,0:35:43.04,English,,0,0,0,,And see start executing whatever it encounters which are the instructions that you've inserted
Dialogue: 0,0:35:43.70,0:35:49.78,English,,0,0,0,,And by that means  then you can inject code into a machine potentially
Dialogue: 0,0:35:50.20,0:35:53.72,English,,0,0,0,,Somewhere else in the internet if you could set up a scheme like this
Dialogue: 0,0:35:53.72,0:35:58.28,English,,0,0,0,,That would feed these bytes into that machine
Dialogue: 0,0:35:58.54,0:36:01.06,English,,0,0,0,,And it would read it in with a function like gets
Dialogue: 0,0:36:01.44,0:36:05.28,English,,0,0,0,,And then it would try to do its return but it would start executing your code
Dialogue: 0,0:36:06.22,0:36:09.24,English,,0,0,0,,So that's a classic code injection attack
Dialogue: 0,0:36:09.54,0:36:14.36,English,,0,0,0,,And in fact in this lab that you're going to start to comes out at midnight
Dialogue: 0,0:36:14.68,0:36:20.34,English,,0,0,0,,It's called the attack lab because you're going to do this yourself
Dialogue: 0,0:36:21.22,0:36:26.80,English,,0,0,0,,For part of the lab and I think you'll find it pretty interesting
Dialogue: 0,0:36:31.64,0:36:35.20,English,,0,0,0,,So this used to be a huge problem  on programs
Dialogue: 0,0:36:35.20,0:36:46.44,English,,0,0,0,,-yes \n-so when you're trying to replace read how do you make sure that your new submitted read provides that exact line
Dialogue: 0,0:36:46.46,0:36:49.04,English,,0,0,0,,Well that's part of the cleverness of being a hacker
Dialogue: 0,0:36:49.70,0:36:51.92,English,,0,0,0,,You have to make sure it's in the right spot
Dialogue: 0,0:36:51.92,0:36:54.40,English,,0,0,0,,But it's that's actually one of the easier parts
Dialogue: 0,0:36:54.98,0:36:59.02,English,,0,0,0,,Because for example we did you know you have to know the binary code
Dialogue: 0,0:36:59.92,0:37:03.72,English,,0,0,0,,To be able to do this or be able to guess
Dialogue: 0,0:37:04.44,0:37:09.44,English,,0,0,0,,So for example in that previous one I could tell that it was allocating 24 bytes for that buffer
Dialogue: 0,0:37:10.20,0:37:15.58,English,,0,0,0,,And so if I just made sure that the length of my exploit code plus the padding is 24 bytes
Dialogue: 0,0:37:16.30,0:37:18.96,English,,0,0,0,,Then right after that comes the return address
Dialogue: 0,0:37:18.96,0:37:20.60,English,,0,0,0,,So that's actually pretty easy to do
Dialogue: 0,0:37:20.60,0:37:24.02,English,,0,0,0,,There was certainly how much memory program is that no you have to have access
Dialogue: 0,0:37:24.04,0:37:29.72,English,,0,0,0,,You have to what the reason why this works is
Dialogue: 0,0:37:30.84,0:37:35.90,English,,0,0,0,,It works if you have enough knowledge about the operating system that's running at the other end
Dialogue: 0,0:37:36.30,0:37:37.84,English,,0,0,0,,For example you know it's Linux
Dialogue: 0,0:37:38.18,0:37:44.10,English,,0,0,0,,You know that you can look at you know what gcc tends to allocate for
Dialogue: 0,0:37:44.10,0:37:47.40,English,,0,0,0,,It you somehow have access to information about the code itself
Dialogue: 0,0:37:48.18,0:37:50.14,English,,0,0,0,,Let's you do this
Dialogue: 0,0:37:56.48,0:37:59.14,English,,0,0,0,,Oh so anyways this used to be a huge problem
Dialogue: 0,0:37:59.16,0:38:05.32,English,,0,0,0,,And it started way back in 1988 the first internet attack with called the morris worm
Dialogue: 0,0:38:05.86,0:38:10.24,English,,0,0,0,,And it at the time the internet was not a very big place
Dialogue: 0,0:38:11.16,0:38:14.08,English,,0,0,0,,And it basically brought down a huge fraction of the machines
Dialogue: 0,0:38:14.48,0:38:17.00,English,,0,0,0,,That were on the internet at the time
Dialogue: 0,0:38:17.00,0:38:22.18,English,,0,0,0,,Interestingly enough cmu did not fall victim to this attack
Dialogue: 0,0:38:22.18,0:38:28.48,English,,0,0,0,,Because we'd patched already the vulnerabilities that this particular program exploited
Dialogue: 0,0:38:32.22,0:38:37.90,English,,0,0,0,,And that was the cause that the software engineering institute runs an organization called cert the
Dialogue: 0,0:38:37.90,0:38:39.96,English,,0,0,0,,Computer emergency response team
Dialogue: 0,0:38:40.34,0:38:46.76,English,,0,0,0,,And that team was set up in response to this attack the morris worm attack
Dialogue: 0,0:38:48.10,0:38:56.03,English,,0,0,0,,Will also see an interesting example  between two companies in in messaging services
Dialogue: 0,0:38:56.38,0:39:02.54,English,,0,0,0,,And many others it's been the sort of standard attack mechanism for many years
Dialogue: 0,0:39:03.06,0:39:09.36,English,,0,0,0,,And fortunately nowadays there's a few things that make the attacking a less likely to be successful
Dialogue: 0,0:39:09.86,0:39:12.22,English,,0,0,0,,And so it's not as huge a problem as it used to be
Dialogue: 0,0:39:12.52,0:39:17.04,English,,0,0,0,,But still it's a source of many vulnerabilities in programs
Dialogue: 0,0:39:18.90,0:39:22.58,English,,0,0,0,,So let's see I won't talk too much about this
Dialogue: 0,0:39:22.64,0:39:25.84,English,,0,0,0,,But it used to be in the original implementation of
Dialogue: 0,0:39:26.42,0:39:30.70,English,,0,0,0,,There's a command that most systems have now disabled that
Dialogue: 0,0:39:30.70,0:39:33.96,English,,0,0,0,,You could finger you could across to information about
Dialogue: 0,0:39:34.36,0:39:38.66,English,,0,0,0,,Somebody in some remote location it would send a message to that location
Dialogue: 0,0:39:39.48,0:39:41.28,English,,0,0,0,,And then it would reply back
Dialogue: 0,0:39:41.74,0:39:46.70,English,,0,0,0,,And it used get us the honor the actual original implementation called geddes
Dialogue: 0,0:39:47.24,0:39:51.40,English,,0,0,0,,To read the input string from that was being sent to it
Dialogue: 0,0:39:55.82,0:39:57.84,English,,0,0,0,,And then there is an interesting one
Dialogue: 0,0:39:57.84,0:40:01.26,English,,0,0,0,,You guys don't remember messaging instant messaging
Dialogue: 0,0:40:01.26,0:40:08.52,English,,0,0,0,,But before it used to be that people would talk to each other on their computers  by sending messages
Dialogue: 0,0:40:08.86,0:40:11.18,English,,0,0,0,,Sort of like you send text messages today
Dialogue: 0,0:40:11.70,0:40:14.56,English,,0,0,0,,But there is an interesting thing that
Dialogue: 0,0:40:15.78,0:40:19.00,English,,0,0,0,,There's a company still exists
Dialogue: 0,0:40:19.00,0:40:23.02,English,,0,0,0,,But it's a shadow of its former self called aol
Dialogue: 0,0:40:23.36,0:40:28.88,English,,0,0,0,,Which ran the most popular internet services and had the most popular instant messaging program
Dialogue: 0,0:40:29.38,0:40:32.36,English,,0,0,0,,And microsoft came out with its own client
Dialogue: 0,0:40:32.78,0:40:35.20,English,,0,0,0,,Its own program that you could run on your machine
Dialogue: 0,0:40:35.48,0:40:40.06,English,,0,0,0,,And communicate to other people on this a messaging system
Dialogue: 0,0:40:40.06,0:40:42.52,English,,0,0,0,,So the microsoft code was running on your machine
Dialogue: 0,0:40:42.90,0:40:49.74,English,,0,0,0,,But it would use the servers that were being run by aol  to manage this messaging traffic
Dialogue: 0,0:40:50.38,0:40:57.62,English,,0,0,0,,And the funny story was over the
Dialogue: 0,0:40:59.18,0:41:01.78,English,,0,0,0,,The this microsoft program would work fine
Dialogue: 0,0:41:02.54,0:41:08.94,English,,0,0,0,,You can communicate with your friends who had different messaging clients  and it all seemed compatible
Dialogue: 0,0:41:09.34,0:41:12.74,English,,0,0,0,,But then suddenly the people that were running the microsoft version of the software
Dialogue: 0,0:41:13.18,0:41:16.96,English,,0,0,0,,It wouldn't work and then microsoft people figured out how to patch it
Dialogue: 0,0:41:17.68,0:41:20.00,English,,0,0,0,,And then it would work for a while and then it wouldn't work
Dialogue: 0,0:41:20.00,0:41:24.64,English,,0,0,0,,And the way what was happening was aol was using a bug in its own code
Dialogue: 0,0:41:25.30,0:41:33.86,English,,0,0,0,,To be able to determine who's basically peek into the the machines on the client side
Dialogue: 0,0:41:34.44,0:41:39.90,English,,0,0,0,,And do a buffer overflow attack on your code that you're running on your machine
Dialogue: 0,0:41:40.22,0:41:44.70,English,,0,0,0,,And then basically peek around and see does this look like aol code
Dialogue: 0,0:41:44.70,0:41:46.95,English,,0,0,0,,Or is it something or is it some foreign code
Dialogue: 0,0:41:47.38,0:41:54.80,English,,0,0,0,,And so is basic be able to use its own security weakness to figure out this information
Dialogue: 0,0:41:56.28,0:42:01.90,English,,0,0,0,,And that got disclosed by a sort of funny message
Dialogue: 0,0:42:02.42,0:42:06.26,English,,0,0,0,,From somebody who called himself phil bucking
Dialogue: 0,0:42:07.02,0:42:12.36,English,,0,0,0,,And it was determined that this email originated from somewhere within microsoft
Dialogue: 0,0:42:15.86,0:42:21.52,English,,0,0,0,,So anyways that and you can read more about it in the book around the slide fun choice
Dialogue: 0,0:42:21.78,0:42:26.78,English,,0,0,0,,So in general in the security world you're supposed to distinguish between the idea of a worm and a virus
Dialogue: 0,0:42:26.78,0:42:28.70,English,,0,0,0,,Although people aren't very good at doing that
Dialogue: 0,0:42:29.06,0:42:35.58,English,,0,0,0,,So worm is a program that can run on its own and propagate itself from one place to the other replicated
Dialogue: 0,0:42:35.96,0:42:40.80,English,,0,0,0,,A virus is like a biological virus it doesn't live on its own
Dialogue: 0,0:42:40.90,0:42:45.78,English,,0,0,0,,It works by attacking a program and basically modifying that program's behavior
Dialogue: 0,0:42:51.30,0:42:56.72,English,,0,0,0,,So that gives you the basic idea of buffer overflows and you'll see it more first hand
Dialogue: 0,0:42:57.20,0:43:02.44,English,,0,0,0,,So let's look at it techniques that machines can use to avoid
Dialogue: 0,0:43:02.72,0:43:05.12,English,,0,0,0,,To make themself less vulnerable to these attacks
Dialogue: 0,0:43:05.60,0:43:11.20,English,,0,0,0,,Well first of all you the application or the cert the writer on the server-side
Dialogue: 0,0:43:11.58,0:43:13.38,English,,0,0,0,,Can write code that's more secure
Dialogue: 0,0:43:14.90,0:43:18.32,English,,0,0,0,,So for example what you're supposed to do instead of gets
Dialogue: 0,0:43:18.84,0:43:20.76,English,,0,0,0,,Is use a function called fgets
Dialogue: 0,0:43:21.28,0:43:26.18,English,,0,0,0,,And fgets has a property that it it passes a parameter
Dialogue: 0,0:43:26.48,0:43:31.40,English,,0,0,0,,Which is the maximum number of bytes that the program should read
Dialogue: 0,0:43:31.84,0:43:37.86,English,,0,0,0,,And if there's more bytes than that in the input it will just truncate the input
Dialogue: 0,0:43:38.62,0:43:43.40,English,,0,0,0,,So you're really supposed to use fgets and give a limit
Dialogue: 0,0:43:43.92,0:43:49.16,English,,0,0,0,,Similarly a strncpy there is a version of it called strncopy  where you can give a limit
Dialogue: 0,0:43:49.98,0:43:55.22,English,,0,0,0,,And with a scanf you're supposed to be careful about using the percent s
Dialogue: 0,0:43:55.62,0:43:59.28,English,,0,0,0,,There's even a terminology you can say percent give a number
Dialogue: 0,0:43:59.84,0:44:03.58,English,,0,0,0,,That's the maximum length of the string it should read
Dialogue: 0,0:44:03.58,0:44:09.39,English,,0,0,0,,So these various places you can protect your code  to make sure it won't overflow buffers
Dialogue: 0,0:44:09.80,0:44:15.00,English,,0,0,0,,Unfortunately a lot of code has been you'd call it hardening
Dialogue: 0,0:44:15.14,0:44:18.94,English,,0,0,0,,It's been people have gone through it and it's a lot of work
Dialogue: 0,0:44:19.04,0:44:23.64,English,,0,0,0,,Because there's a lot of places in programs where you're copying strings from one place to another
Dialogue: 0,0:44:24.14,0:44:31.56,English,,0,0,0,,And there are a lot of real subtleties like when you're converting from unicode to bytes and so forth
Dialogue: 0,0:44:31.56,0:44:34.68,English,,0,0,0,,That you're going back and forth between different character encodings
Dialogue: 0,0:44:35.20,0:44:42.70,English,,0,0,0,,But for the large part and there's tools that the code developers have created to help  track down these bugs
Dialogue: 0,0:44:43.24,0:44:47.72,English,,0,0,0,,So it's become a little bit safer out there but there's still vulnerabilities
Dialogue: 0,0:44:48.50,0:44:53.80,English,,0,0,0,,So then there's other parts where you just try to build in safeguards into the system
Dialogue: 0,0:44:54.22,0:44:59.38,English,,0,0,0,,That would make it much harder to do a buffer overflow exploit like I showed you
Dialogue: 0,0:45:00.04,0:45:03.20,English,,0,0,0,,And so one of them is called stack randomization
Dialogue: 0,0:45:03.68,0:45:05.64,English,,0,0,0,,Where it goes by a more general term
Dialogue: 0,0:45:09.34,0:45:12.06,English,,0,0,0,,That's abbreviated a slr
Dialogue: 0,0:45:12.86,0:45:25.04,English,,0,0,0,,Which stands for address space layout randomization
Dialogue: 0,0:45:25.50,0:45:29.04,English,,0,0,0,,And the idea of it is to make it so every time a program runs
Dialogue: 0,0:45:29.54,0:45:33.84,English,,0,0,0,,The addresses change  a little bit or a lot
Dialogue: 0,0:45:34.24,0:45:39.50,English,,0,0,0,,So that you can't reliably know where things are going to be in the code
Dialogue: 0,0:45:39.96,0:45:45.84,English,,0,0,0,,So imagine for example the and the way it's implemented is before
Dialogue: 0,0:45:46.10,0:45:49.52,English,,0,0,0,,In the sort of run-up of your program when it first starts up
Dialogue: 0,0:45:50.24,0:45:52.76,English,,0,0,0,,But before your main routine gets called
Dialogue: 0,0:45:53.92,0:45:58.72,English,,0,0,0,,It will just do a allocation on the stack of some random number of bytes of storage
Dialogue: 0,0:45:59.36,0:46:05.70,English,,0,0,0,,A fair amount like maybe a megabyte roughly of storage where the exact number is randomly chosen
Dialogue: 0,0:46:06.70,0:46:10.50,English,,0,0,0,,And what that means is that the the dress of the stack
Dialogue: 0,0:46:10.66,0:46:14.66,English,,0,0,0,,Of all the different positions of your ear
Dialogue: 0,0:46:15.26,0:46:20.04,English,,0,0,0,,All the local storage on the stack will shift up and down from one run to another
Dialogue: 0,0:46:20.92,0:46:22.62,English,,0,0,0,,And we can actually see that
Dialogue: 0,0:46:24.54,0:46:27.54,English,,0,0,0,,In this example I showed
Dialogue: 0,0:46:33.30,0:46:38.22,English,,0,0,0,,So I have a program here it's not a very interesting program I'll show you
Dialogue: 0,0:46:39.44,0:46:41.40,English,,0,0,0,,Except to demonstrate these ideas
Dialogue: 0,0:46:45.40,0:46:50.42,English,,0,0,0,,All it's doing is there's some code it's based on that one
Dialogue: 0,0:46:50.42,0:46:51.92,English,,0,0,0,,I already showed called locate
Dialogue: 0,0:46:51.92,0:46:54.72,English,,0,0,0,,But this one there's a global variable
Dialogue: 0,0:46:55.40,0:47:00.51,English,,0,0,0,,There's some functions there's something that gets allocated by malloc
Dialogue: 0,0:47:00.92,0:47:04.98,English,,0,0,0,,And there's something that is a local variable stored on the stack
Dialogue: 0,0:47:05.58,0:47:09.10,English,,0,0,0,,And so what I'll do is show addresses that are chosen
Dialogue: 0,0:47:09.46,0:47:15.66,English,,0,0,0,,The address of this variable then will be  a stack address a local of a local variable
Dialogue: 0,0:47:16.30,0:47:19.34,English,,0,0,0,,Global will be this one that gets allocated globally
Dialogue: 0,0:47:19.94,0:47:22.10,English,,0,0,0,,The heap is something allocated with malloc
Dialogue: 0,0:47:22.82,0:47:27.38,English,,0,0,0,,And then the this function useless will count as a code address
Dialogue: 0,0:47:29.08,0:47:30.32,English,,0,0,0,,And now when I run it
Dialogue: 0,0:47:34.56,0:47:39.62,English,,0,0,0,,You'll see from one run to another that if some of these stay the same and some of them change
Dialogue: 0,0:47:40.36,0:47:46.02,English,,0,0,0,,So in particular the global variable  is the same 60102c
Dialogue: 0,0:47:47.70,0:47:56.22,English,,0,0,0,,And the code is the same 0x400590 is the same every execution
Dialogue: 0,0:47:56.66,0:48:00.80,English,,0,0,0,,But you'll see this local variable it's on its a stack address
Dialogue: 0,0:48:01.50,0:48:07.34,English,,0,0,0,,But you see that the lower half dozen or so bytes are actually changing from one run to another
Dialogue: 0,0:48:07.84,0:48:12.88,English,,0,0,0,,1 2 3 4 5 so 5 bytes so that's
Dialogue: 0,0:48:15.92,0:48:17.68,English,,0,0,0,,What 5 hex digits I'm sorry
Dialogue: 0,0:48:17.68,0:48:20.10,English,,0,0,0,,So that's 2 to the 20th
Dialogue: 0,0:48:20.70,0:48:25.26,English,,0,0,0,,So roughly a megabyte of variation is going on in stack addresses there
Dialogue: 0,0:48:25.80,0:48:32.06,English,,0,0,0,,And similarly you'll see that the heap addresses are also varying from one to another
Dialogue: 0,0:48:32.26,0:48:33.76,English,,0,0,0,,From one execution to the other
Dialogue: 0,0:48:33.78,0:48:38.62,English,,0,0,0,,So malloc has built into it some amount of randomness to in its allocation
Dialogue: 0,0:48:39.34,0:48:43.38,English,,0,0,0,,So why is that ik you know what's the purpose of that well
Dialogue: 0,0:48:45.46,0:48:49.14,English,,0,0,0,,As I told you this code injection vulnerability
Dialogue: 0,0:48:51.42,0:48:57.30,English,,0,0,0,,Relies on the fact that you can you can load up this buffer with some executable code
Dialogue: 0,0:48:57.74,0:49:03.38,English,,0,0,0,,But somehow you have to know how to get to the start of that code
Dialogue: 0,0:49:04.00,0:49:08.32,English,,0,0,0,,And so this is relying the attack is relying on the fact
Dialogue: 0,0:49:08.32,0:49:13.28,English,,0,0,0,,That it can somehow predict what the this address of the buffer is
Dialogue: 0,0:49:14.36,0:49:18.04,English,,0,0,0,,And so that it can store it in the right part of the string
Dialogue: 0,0:49:18.16,0:49:22.98,English,,0,0,0,,Put it encode it in the right part of the string so it will show up where the return pointer is supposed to be
Dialogue: 0,0:49:24.36,0:49:26.52,English,,0,0,0,,And and have it jump to that location
Dialogue: 0,0:49:26.92,0:49:28.66,English,,0,0,0,,But now with this randomization
Dialogue: 0,0:49:29.26,0:49:33.24,English,,0,0,0,,This number is varying by quite a bit
Dialogue: 0,0:49:33.40,0:49:37.50,English,,0,0,0,,Sort of million over a range of a million or so values
Dialogue: 0,0:49:37.88,0:49:39.24,English,,0,0,0,,So there's no way in advance
Dialogue: 0,0:49:39.48,0:49:44.41,English,,0,0,0,,Even if I have an exact copy of the code not even had access to the system itself
Dialogue: 0,0:49:44.72,0:49:46.13,English,,0,0,0,,And could run it
Dialogue: 0,0:49:46.54,0:49:50.04,English,,0,0,0,,I can't predict from one run to the next where it's going to be
Dialogue: 0,0:49:50.68,0:49:54.82,English,,0,0,0,,So that gives it sort of thoughts this particular attack
Dialogue: 0,0:49:55.40,0:49:59.86,English,,0,0,0,,To to make it using this randomization
Dialogue: 0,0:50:03.14,0:50:07.24,English,,0,0,0,,Another idea that's fairly straightforward
Dialogue: 0,0:50:07.24,0:50:11.32,English,,0,0,0,,But it took a long time for the hardware people to implement this
Dialogue: 0,0:50:12.04,0:50:16.74,English,,0,0,0,,Is well why why is there supposed to be code on the stack
Dialogue: 0,0:50:16.74,0:50:21.10,English,,0,0,0,,In the first place isn't the code supposed to be located down in the text segment
Dialogue: 0,0:50:21.70,0:50:25.82,English,,0,0,0,,Where it can be sort of specially identified as being executable
Dialogue: 0,0:50:26.58,0:50:29.02,English,,0,0,0,,So in the original x86
Dialogue: 0,0:50:29.64,0:50:33.44,English,,0,0,0,,There's a one bit flag for each region of memory
Dialogue: 0,0:50:34.20,0:50:37.08,English,,0,0,0,,Saying is it actually - one bit flags
Dialogue: 0,0:50:37.62,0:50:40.04,English,,0,0,0,,One is can this be written to
Dialogue: 0,0:50:41.04,0:50:45.46,English,,0,0,0,,So that you can prevent over writes of things like string constants
Dialogue: 0,0:50:46.88,0:50:50.59,English,,0,0,0,,And so and then the other is am I can I read it
Dialogue: 0,0:50:51.32,0:50:53.46,English,,0,0,0,,And read means access those bytes and
Dialogue: 0,0:50:53.46,0:50:57.18,English,,0,0,0,,It was interpreted that readable and executable were the same thing
Dialogue: 0,0:50:57.66,0:51:01.30,English,,0,0,0,,I can read it I can execute it and that was the rules
Dialogue: 0,0:51:02.48,0:51:08.78,English,,0,0,0,,In a sort of last 10 years or so starting first with amd and then intel
Dialogue: 0,0:51:09.06,0:51:12.54,English,,0,0,0,,Have added a third bit that says is this executable or not
Dialogue: 0,0:51:13.02,0:51:18.16,English,,0,0,0,,Similarly to the permissions you have on a file on unix is it readable writable executable
Dialogue: 0,0:51:18.58,0:51:21.30,English,,0,0,0,,Those are three separate permission bits that are alone
Dialogue: 0,0:51:22.72,0:51:26.50,English,,0,0,0,,So by simply marking the stack is not executable
Dialogue: 0,0:51:26.84,0:51:29.22,English,,0,0,0,,It'll also fort this particular attack
Dialogue: 0,0:51:29.22,0:51:34.04,English,,0,0,0,,Because I have to be able to execute these bytes that I've injected into the system
Dialogue: 0,0:51:37.18,0:51:41.76,English,,0,0,0,,And then there's the final idea which is actually fairly effective -
Dialogue: 0,0:51:42.24,0:51:45.72,English,,0,0,0,,Which they call a canary  that they built into the stack
Dialogue: 0,0:51:45.72,0:51:49.20,English,,0,0,0,,And some of you actually encountered this code already and looking at your bombs
Dialogue: 0,0:51:49.20,0:51:51.34,English,,0,0,0,,Because we've been getting some questions about it
Dialogue: 0,0:51:52.52,0:51:55.32,English,,0,0,0,,So let me just give you an example here
Dialogue: 0,0:52:05.70,0:52:08.20,English,,0,0,0,,And this one's called buffdemo-sp
Dialogue: 0,0:52:08.20,0:52:11.28,English,,0,0,0,,Because it's been compiled with what they call stack protector
Dialogue: 0,0:52:17.54,0:52:22.56,English,,0,0,0,,And this one on now it's the same code as before it's dis compiled a little bit differently
Dialogue: 0,0:52:23.14,0:52:26.70,English,,0,0,0,,What you'll find is I can give a string of length eight
Dialogue: 0,0:52:27.08,0:52:28.58,English,,0,0,0,,And not have a problem
Dialogue: 0,0:52:29.04,0:52:32.38,English,,0,0,0,,But if I now have nine characters
Dialogue: 0,0:52:33.00,0:52:38.80,English,,0,0,0,,It will dump out with this very strange exit error message
Dialogue: 0,0:52:39.42,0:52:41.86,English,,0,0,0,,That is an indication
Dialogue: 0,0:52:43.96,0:52:49.78,English,,0,0,0,,That it's detected I attempt to smash the stack
Dialogue: 0,0:52:49.78,0:52:52.66,English,,0,0,0,,So buffer overflow is sometimes called stack smashing
Dialogue: 0,0:52:53.68,0:52:59.58,English,,0,0,0,,So it detected somehow that even though my code was still the same old crappy code from before
Dialogue: 0,0:53:00.70,0:53:03.96,English,,0,0,0,,Of a very small buffer allocation and no protection
Dialogue: 0,0:53:03.96,0:53:08.36,English,,0,0,0,,Somehow the the system protected me from myself
Dialogue: 0,0:53:10.30,0:53:15.66,English,,0,0,0,,And that's a by a relatively simple trick that's a fairly clever though
Dialogue: 0,0:53:17.40,0:53:19.62,English,,0,0,0,,What they call stack canary
Dialogue: 0,0:53:20.36,0:53:27.32,English,,0,0,0,,So that the term canary comes back from a back in the coal mining days of old
Dialogue: 0,0:53:27.68,0:53:33.38,English,,0,0,0,,Before they had very good ways of measuring things they take a bird down with them in a cage
Dialogue: 0,0:53:33.92,0:53:40.64,English,,0,0,0,,And a canary is a property that's very susceptible to dying
Dialogue: 0,0:53:42.06,0:53:44.96,English,,0,0,0,,If there's nothing if there's methane gas present
Dialogue: 0,0:53:44.96,0:53:48.84,English,,0,0,0,,So these miners would be down there working and they'd see their bird
Dialogue: 0,0:53:49.56,0:53:52.92,English,,0,0,0,,Keel over and say oh we got a problem here let's get out fast
Dialogue: 0,0:53:53.42,0:53:57.14,English,,0,0,0,,So that's why they call it a canary in a coal mine sometimes
Dialogue: 0,0:53:57.14,0:54:00.60,English,,0,0,0,,Some kind of warning signal that that something's not not right here
Dialogue: 0,0:54:01.82,0:54:08.28,English,,0,0,0,,And in general we see a gcc if you invoke it with a stack protector
Dialogue: 0,0:54:08.28,0:54:09.90,English,,0,0,0,,Nowadays that's the default
Dialogue: 0,0:54:10.82,0:54:15.48,English,,0,0,0,,So even without you saying anything this code will get built into it
Dialogue: 0,0:54:18.62,0:54:21.80,English,,0,0,0,,And so let's look at at what that canary code looks like
Dialogue: 0,0:54:21.80,0:54:24.84,English,,0,0,0,,And how it does its thing it's really pretty clever as I said
Dialogue: 0,0:54:25.24,0:54:29.24,English,,0,0,0,,And some of you have already observed this strange kind of memory reference
Dialogue: 0,0:54:29.34,0:54:34.46,English,,0,0,0,,In a register reference in the code and your boom labs
Dialogue: 0,0:54:34.46,0:54:39.08,English,,0,0,0,,Because it was compiled with this deck protecting enabled  because that's the default
Dialogue: 0,0:54:40.26,0:54:48.36,English,,0,0,0,,And so in particular what this code shows is it's allocating as before 24 bytes on the stack
Dialogue: 0,0:54:49.22,0:54:53.92,English,,0,0,0,,But now it's getting some number and we'll talk in a second what that means
Dialogue: 0,0:54:54.42,0:55:01.22,English,,0,0,0,,And storing it at position 8 offset from the stack pointer
Dialogue: 0,0:55:01.80,0:55:06.42,English,,0,0,0,,And then the rest of the code and then it zeros it out  that's not to worry
Dialogue: 0,0:55:06.64,0:55:12.36,English,,0,0,0,,And then it looks like the your previous code that it's passing a pointer to the stack
Dialogue: 0,0:55:13.14,0:55:15.82,English,,0,0,0,,Top of the stack as the argument to get us
Dialogue: 0,0:55:17.04,0:55:21.66,English,,0,0,0,,And get us it gets called and then put s gets called
Dialogue: 0,0:55:22.28,0:55:28.80,English,,0,0,0,,But now there's some more code here that is it involves this strange-looking register
Dialogue: 0,0:55:29.22,0:55:33.82,English,,0,0,0,,And then there's some kind of test and then if that test fails
Dialogue: 0,0:55:34.64,0:55:40.72,English,,0,0,0,,It will call this a code that you just saw printed out this error message
Dialogue: 0,0:55:42.68,0:55:44.76,English,,0,0,0,,So let's see what that all means
Dialogue: 0,0:55:45.00,0:55:51.30,English,,0,0,0,,What that means is that at offset 8 from the stack pointer
Dialogue: 0,0:55:51.30,0:55:54.70,English,,0,0,0,,It's putting in 8 bytes a value
Dialogue: 0,0:55:55.52,0:55:59.84,English,,0,0,0,,That it's retrieving from a special register
Dialogue: 0,0:55:59.84,0:56:07.84,English,,0,0,0,,So fs is a reference to a type of register that was created for the original 8086
Dialogue: 0,0:56:07.84,0:56:12.26,English,,0,0,0,,And is now completely obsolete but it's still there for backward compatibility mode
Dialogue: 0,0:56:12.78,0:56:18.64,English,,0,0,0,,But what it is it and I actually I looked and I've never fully been able to find the documentation on it
Dialogue: 0,0:56:19.16,0:56:21.90,English,,0,0,0,,It's able to read from a part of memory
Dialogue: 0,0:56:22.40,0:56:28.08,English,,0,0,0,,A set of values that you can't otherwise get to
Dialogue: 0,0:56:28.56,0:56:35.70,English,,0,0,0,,And so that's the khmer canary it's getting a somehow it's grabbing eight bytes from somewhere
Dialogue: 0,0:56:36.42,0:56:38.62,English,,0,0,0,,Storing it as this canary value
Dialogue: 0,0:56:40.08,0:56:43.82,English,,0,0,0,,And then if you give like a seven character input
Dialogue: 0,0:56:45.32,0:56:50.06,English,,0,0,0,,So you would affect the canary and so what happens when it returns from
Dialogue: 0,0:56:51.96,0:56:57.60,English,,0,0,0,,The two calls from gets and puts  before it exits
Dialogue: 0,0:56:57.60,0:57:05.12,English,,0,0,0,,What it's trying to detect is has anything as this buffer somehow overflowed
Dialogue: 0,0:57:05.50,0:57:09.90,English,,0,0,0,,And potentially at risk of of corrupting some other part of the stack
Dialogue: 0,0:57:10.52,0:57:16.14,English,,0,0,0,,So basically what it does is it retrieves back from the stack
Dialogue: 0,0:57:16.54,0:57:19.06,English,,0,0,0,,What is the current value of this canary
Dialogue: 0,0:57:19.62,0:57:26.50,English,,0,0,0,,And it's comparing it to what it should be  by retrieving that back from this special region
Dialogue: 0,0:57:26.94,0:57:29.94,English,,0,0,0,,And if they're equal it says fine
Dialogue: 0,0:57:30.34,0:57:35.54,English,,0,0,0,,But if they're not equal it's detecting this got corrupted so just like the canary in the coalmine
Dialogue: 0,0:57:35.96,0:57:40.94,English,,0,0,0,,If these bytes get corrupted in any form it's an indication that something went wrong
Dialogue: 0,0:57:42.42,0:57:48.52,English,,0,0,0,,Now that example shows that if I have a seven characters string
Dialogue: 0,0:57:48.88,0:57:51.34,English,,0,0,0,,Then I'm not going to corrupt the canary
Dialogue: 0,0:57:52.42,0:57:55.70,English,,0,0,0,,But you notice I just got away with an eight character string
Dialogue: 0,0:57:57.62,0:58:03.20,English,,0,0,0,,So let me just see what's going on here
Dialogue: 0,0:58:30.60,0:58:32.54,English,,0,0,0,,Okay I want a character e-string right
Dialogue: 0,0:58:35.30,0:58:36.60,English,,0,0,0,,Oh wait wait wait
Dialogue: 0,0:58:42.74,0:58:47.20,English,,0,0,0,,Ah sorry I have to look I don't have the code in front of me so I have to look at
Dialogue: 0,0:58:52.98,0:59:00.20,English,,0,0,0,,So anyways here's where it's subtracting 24 from the stack pointer
Dialogue: 0,0:59:00.76,0:59:04.80,English,,0,0,0,,And then the next instruction is retrieving this canary value
Dialogue: 0,0:59:04.80,0:59:09.88,English,,0,0,0,,So let's figure out what the canary is right now we are at
Dialogue: 0,0:59:16.25,0:59:20.00,English,,0,0,0,,72f so we're at the first instruction here
Dialogue: 0,0:59:25.84,0:59:39.48,English,,0,0,0,,Let's do another step
Dialogue: 0,0:59:40.06,0:59:41.74,English,,0,0,0,,So this is the canary
Dialogue: 0,0:59:44.46,0:59:48.96,English,,0,0,0,,And it's you'll see actually when from one run to another you get a different value of it
Dialogue: 0,0:59:49.04,0:59:52.82,English,,0,0,0,,So it's purposely put in there in a way that it's unpredictable
Dialogue: 0,0:59:53.42,0:59:56.94,English,,0,0,0,,The one thing you'll notice is that the lower bite is zeroes
Dialogue: 0,0:59:57.80,1:00:04.78,English,,0,0,0,,And so apparently they knew that it's so common to have suta off-by-one bugs with strings
Dialogue: 0,1:00:04.78,1:00:08.42,English,,0,0,0,,Where you don't allocate enough space for the null terminator
Dialogue: 0,1:00:08.82,1:00:10.46,English,,0,0,0,,That they said well rather
Dialogue: 0,1:00:10.94,1:00:16.08,English,,0,0,0,,Than having a canary that will detect that bite being corrupted we'll just sort of give that bite away
Dialogue: 0,1:00:16.96,1:00:21.76,English,,0,0,0,,And so that's why it's letting me type in eight characters
Dialogue: 0,1:00:21.84,1:00:26.28,English,,0,0,0,,And it's overriding this low order byte of the canary later on
Dialogue: 0,1:00:26.76,1:00:28.96,English,,0,0,0,,But that's not going to affect anything
Dialogue: 0,1:00:53.44,1:00:59.60,English,,0,0,0,,Strategic but let's give it a 9 characters 10 character string  a 9 character string
Dialogue: 0,1:01:52.17,1:01:54.78,English,,0,0,0,,All right charts mark
Dialogue: 0,1:01:55.12,1:02:01.14,English,,0,0,0,,Oh well I'm not finding it where I thought it would be
Dialogue: 0,1:02:01.34,1:02:08.58,English,,0,0,0,,Anyways oh this will crop this deck
Dialogue: 0,1:02:08.80,1:02:12.20,English,,0,0,0,,But what I showing you the main idea is the canaries some value
Dialogue: 0,1:02:12.20,1:02:15.18,English,,0,0,0,,That gets pulled out and it will vary from one time to the next
Dialogue: 0,1:02:16.00,1:02:20.72,English,,0,0,0,,And it's letting you get away with eight characters plus the null terminator
Dialogue: 0,1:02:20.92,1:02:23.90,English,,0,0,0,,But anything more and it will detect that corruption
Dialogue: 0,1:02:38.60,1:02:44.16,English,,0,0,0,,Okay so now we've seen three different protection well for one is write better code
Dialogue: 0,1:02:46.30,1:02:51.50,English,,0,0,0,,But there's three protections that are done by the system that have nothing to do with your code
Dialogue: 0,1:02:51.74,1:02:58.24,English,,0,0,0,,Right one is to randomize the stack position
Dialogue: 0,1:02:58.26,1:03:01.20,English,,0,0,0,,So it's harder to figure out where the start addresses are
Dialogue: 0,1:03:01.72,1:03:07.48,English,,0,0,0,,The second is to make the stack so it's not executable so you can't put code on that
Dialogue: 0,1:03:08.04,1:03:12.20,English,,0,0,0,,And then the third is to use a stack canary or other mechanisms to detect
Dialogue: 0,1:03:13.00,1:03:15.68,English,,0,0,0,,A potential buffer overflow at the source
Dialogue: 0,1:03:16.94,1:03:22.34,English,,0,0,0,,So now there's another attack that was developed in response to some of these
Dialogue: 0,1:03:25.00,1:03:30.02,English,,0,0,0,,That is still often successful it's called return I did programming
Dialogue: 0,1:03:30.42,1:03:33.26,English,,0,0,0,,And for your attack lab you're going to be doing these attacks too
Dialogue: 0,1:03:33.26,1:03:36.10,English,,0,0,0,,That's why the attack lab is different than the old lab
Dialogue: 0,1:03:36.10,1:03:41.22,English,,0,0,0,,Way of the old web justed code injection exploits now you're doing both code injection
Dialogue: 0,1:03:41.79,1:03:43.56,English,,0,0,0,,And return oriented programming
Dialogue: 0,1:03:44.38,1:03:51.12,English,,0,0,0,,So the idea this is if you are a hacker you're frustrated
Dialogue: 0,1:03:51.12,1:03:58.72,English,,0,0,0,,Because of these these three techniques stack randomization non-executable stack and canaries
Dialogue: 0,1:03:59.10,1:04:07.48,English,,0,0,0,,Well I can't fix the canary problem that actually the canary is a pretty secure technique
Dialogue: 0,1:04:07.58,1:04:12.28,English,,0,0,0,,There's very I've never seen anyone able to bypass a stet canary
Dialogue: 0,1:04:13.04,1:04:15.90,English,,0,0,0,,But the other two you can do it using this technique
Dialogue: 0,1:04:16.44,1:04:20.48,English,,0,0,0,,And the strategy is so we don't know where the stack is
Dialogue: 0,1:04:21.42,1:04:23.26,English,,0,0,0,,But we could still
Dialogue: 0,1:04:24.04,1:04:27.74,English,,0,0,0,,But we know where the code is because you saw in that example the code
Dialogue: 0,1:04:28.26,1:04:33.94,English,,0,0,0,,My layout randomization was shifting the stack positions in the heap positions
Dialogue: 0,1:04:34.54,1:04:40.34,English,,0,0,0,,But it wasn't changing either global variables or or the code itself
Dialogue: 0,1:04:41.32,1:04:50.04,English,,0,0,0,,So what if I can find some code that sort of already there in the existing part of the program
Dialogue: 0,1:04:50.60,1:04:55.30,English,,0,0,0,,And I'll use that instead of my own code that I've injected
Dialogue: 0,1:04:55.98,1:05:00.94,English,,0,0,0,,And of course in general you're not going to find exactly lying there the exact program
Dialogue: 0,1:05:00.94,1:05:05.76,English,,0,0,0,,You want to execute that will cause whatever harm you intend to do
Dialogue: 0,1:05:06.50,1:05:09.74,English,,0,0,0,,Because that's not usually compiled into most programs
Dialogue: 0,1:05:09.76,1:05:15.34,English,,0,0,0,,But if I could set a string together little segments of code
Dialogue: 0,1:05:15.90,1:05:22.54,English,,0,0,0,,And somehow put together a series of little sequences of code
Dialogue: 0,1:05:22.78,1:05:24.86,English,,0,0,0,,Maybe I can get something useful done
Dialogue: 0,1:05:25.54,1:05:28.38,English,,0,0,0,,And so that's the idea of this return oriented programming
Dialogue: 0,1:05:28.94,1:05:33.38,English,,0,0,0,,And the idea of it is to find what are known as gadgets
Dialogue: 0,1:05:34.28,1:05:40.52,English,,0,0,0,,And a gadget is a sequence of bytes  that are represent part of the executable program
Dialogue: 0,1:05:40.86,1:05:47.38,English,,0,0,0,,Where the last byte this is x86 talking here  has a hex value c3
Dialogue: 0,1:05:47.60,1:05:56.64,English,,0,0,0,,Which is how the ret instruction the return instruction is encoded  in x86 both ia-32 and x64
Dialogue: 0,1:05:59.04,1:06:01.32,English,,0,0,0,,And so as an example
Dialogue: 0,1:06:02.20,1:06:05.48,English,,0,0,0,,On the easy case is where there's some function
Dialogue: 0,1:06:07.00,1:06:12.96,English,,0,0,0,,And it implements some operation that I might find useful as an attacker to be able to do
Dialogue: 0,1:06:13.48,1:06:18.16,English,,0,0,0,,So for example this function is computing a times b plus C
Dialogue: 0,1:06:18.94,1:06:25.64,English,,0,0,0,,And if I look at just the last two instructions from there one of them is a la which is performing addition
Dialogue: 0,1:06:26.50,1:06:29.58,English,,0,0,0,,And the other is doing a return
Dialogue: 0,1:06:29.92,1:06:33.90,English,,0,0,0,,So I can think of this this good old five bunk byte chunk
Dialogue: 0,1:06:34.26,1:06:40.24,English,,0,0,0,,Is a way if I could get some data in registers r di and rdx
Dialogue: 0,1:06:40.92,1:06:44.34,English,,0,0,0,,Then I could compute their sum and stick it in %rax
Dialogue: 0,1:06:44.48,1:06:47.12,English,,0,0,0,,So imagine taking your program you're trying to execute
Dialogue: 0,1:06:47.46,1:06:49.40,English,,0,0,0,,And breaking it up into these good old fragments
Dialogue: 0,1:06:49.76,1:06:55.10,English,,0,0,0,,And you want to somehow find little block of code somewhere to implement each of these fragments
Dialogue: 0,1:06:55.96,1:07:00.52,English,,0,0,0,,And then the interesting part is because they each end in C 3 this return
Dialogue: 0,1:07:00.84,1:07:04.50,English,,0,0,0,,It has is it well let me get to that in it
Dialogue: 0,1:07:05.12,1:07:10.96,English,,0,0,0,,So that's sort of the obvious way that you pull out this is an addition which you'd expect
Dialogue: 0,1:07:10.96,1:07:13.04,English,,0,0,0,,Because that was in the original C code
Dialogue: 0,1:07:13.92,1:07:19.52,English,,0,0,0,,But here's an example of a gadget that has nothing to do with the original C code
Dialogue: 0,1:07:19.80,1:07:26.14,English,,0,0,0,,It just happens to match the bite pattern of of some existing code
Dialogue: 0,1:07:26.66,1:07:36.04,English,,0,0,0,,So this function seems to not do anything too terribly useful  from a hackers point of view
Dialogue: 0,1:07:36.70,1:07:39.46,English,,0,0,0,,But if you look at this particular byte sequence
Dialogue: 0,1:07:39.56,1:07:43.82,English,,0,0,0,,That happens to encode the instruction move q are %rax to %rdi
Dialogue: 0,1:07:44.56,1:07:46.44,English,,0,0,0,,And C 3 encodes repped
Dialogue: 0,1:07:47.14,1:07:51.68,English,,0,0,0,,So and you can see if this is at address for d9
Dialogue: 0,1:07:52.26,1:07:55.48,English,,0,0,0,,That's for da for db for dc
Dialogue: 0,1:07:55.50,1:08:00.06,English,,0,0,0,,So at address 4004dc
Dialogue: 0,1:08:00.48,1:08:06.84,English,,0,0,0,,If you could start executing here it would first do a move and then it would do a return
Dialogue: 0,1:08:07.62,1:08:13.66,English,,0,0,0,,So I'm sort of taking advantage of the fact in x86 it's this buy donated instruction sequence
Dialogue: 0,1:08:14.36,1:08:23.34,English,,0,0,0,,And if I sort of go off the aligned instructions I can often find useful things to do
Dialogue: 0,1:08:24.48,1:08:25.96,English,,0,0,0,,So that's what's called a gadget
Dialogue: 0,1:08:26.00,1:08:30.23,English,,0,0,0,,And you might ask well what's so special about having them end in a return
Dialogue: 0,1:08:30.86,1:08:36.06,English,,0,0,0,,Well imagine I could fill up my buffer instead of with executable code
Dialogue: 0,1:08:36.48,1:08:39.58,English,,0,0,0,,I could fill it up with a series of gadget addresses
Dialogue: 0,1:08:41.72,1:08:46.02,English,,0,0,0,,So each gadget then is some series of bytes where the final byte is c3
Dialogue: 0,1:08:49.92,1:08:52.34,English,,0,0,0,,And I'll actually position this
Dialogue: 0,1:08:53.10,1:08:56.18,English,,0,0,0,,And not the oppositionists at some place
Dialogue: 0,1:08:56.18,1:09:02.22,English,,0,0,0,,Where you're actually going to do the initial return instruction of from before
Dialogue: 0,1:09:02.32,1:09:08.84,English,,0,0,0,,So if I can somehow get the program to return execute a rest
Dialogue: 0,1:09:09.34,1:09:14.48,English,,0,0,0,,Right now what it will do is return will pick an address off of the stack
Dialogue: 0,1:09:15.08,1:09:18.02,English,,0,0,0,,Pop an address and begin executing
Dialogue: 0,1:09:18.02,1:09:20.14,English,,0,0,0,,So that will start this code executing
Dialogue: 0,1:09:20.50,1:09:23.58,English,,0,0,0,,And it will hit the c3 the ret instruction at the end
Dialogue: 0,1:09:24.24,1:09:29.18,English,,0,0,0,,Which will again take a address pop it off the stack and begin executing
Dialogue: 0,1:09:29.20,1:09:31.92,English,,0,0,0,,So we'll start executing the second gadget
Dialogue: 0,1:09:32.26,1:09:38.68,English,,0,0,0,,And so you'll see what will happen is we're effectively concatenating these pieces of code together
Dialogue: 0,1:09:38.98,1:09:44.24,English,,0,0,0,,Where it's using a rep to get from one part the end of one gadget to the start of the next
Dialogue: 0,1:09:44.82,1:09:47.40,English,,0,0,0,,And so that's why it's called return oriented programming
Dialogue: 0,1:09:47.88,1:09:52.64,English,,0,0,0,,It's a way to instead of sequencing programs using a program counter like you normally do
Dialogue: 0,1:09:53.16,1:09:59.42,English,,0,0,0,,Your sequencing programs using the sort of peculiar behavior of this particular x86
Dialogue: 0,1:10:00.68,1:10:04.62,English,,0,0,0,,How returns work and in that program
Dialogue: 0,1:10:04.84,1:10:09.80,English,,0,0,0,,And remember there's enough x86 out there that if I can find a way to attack them
Dialogue: 0,1:10:10.36,1:10:14.18,English,,0,0,0,,I'm in pretty I'm in a pretty good place
Dialogue: 0,1:10:15.50,1:10:19.32,English,,0,0,0,,It's also possible to attack other processors this way -
Dialogue: 0,1:10:19.32,1:10:22.12,English,,0,0,0,,It's just particularly nice on x86
Dialogue: 0,1:10:23.06,1:10:25.60,English,,0,0,0,,So that's the idea of return oriented programming
Dialogue: 0,1:10:25.60,1:10:33.24,English,,0,0,0,,And you'll do this yourself you'll find gadgets string them together to do different things in the attack way
Dialogue: 0,1:10:35.60,1:10:42.70,English,,0,0,0,,But I'll point out that this still doesn't so that
Dialogue: 0,1:10:43.40,1:10:52.16,English,,0,0,0,,This stack canary idea is still successful detecting a buffer overflows  fairly effectively
Dialogue: 0,1:10:52.16,1:10:54.82,English,,0,0,0,,So in your attack lab for example
Dialogue: 0,1:10:55.22,1:11:00.68,English,,0,0,0,,We've carefully compiled the code to make it vulnerable to these attacks
Dialogue: 0,1:11:01.62,1:11:05.16,English,,0,0,0,,Otherwise it would be a lot harder web
Dialogue: 0,1:11:05.78,1:11:12.34,English,,0,0,0,,Like if you could do this you could probably go into the dark world and be very successful
Dialogue: 0,1:11:15.34,1:11:21.48,English,,0,0,0,,So we're actually sort of exposing the vulnerability
Dialogue: 0,1:11:21.48,1:11:26.22,English,,0,0,0,,But in the the first part of the lab you're using code injection attacks
Dialogue: 0,1:11:26.22,1:11:31.78,English,,0,0,0,,So we've had to disable stack randomization and also make the stack x cutable
Dialogue: 0,1:11:32.26,1:11:39.32,English,,0,0,0,,So we had to sort of button the return rated programming  we reenable that
Dialogue: 0,1:11:39.50,1:11:44.62,English,,0,0,0,,So that the stack is not executable it keeps jumping around randomly
Dialogue: 0,1:11:45.22,1:11:47.62,English,,0,0,0,,But we've turned off the stack canary
Dialogue: 0,1:11:47.62,1:11:49.84,English,,0,0,0,,So you'll be able to overflow the buffer
Dialogue: 0,1:11:50.48,1:11:55.68,English,,0,0,0,,And put in your gadget addresses and build up attacks that way
Dialogue: 0,1:11:57.48,1:12:02.78,English,,0,0,0,,So I think you'll find by actually doing it you'll earn a lot more than you can by just hearing about it
Dialogue: 0,1:12:05.10,1:12:07.44,English,,0,0,0,,Oh you might ask why do we teach you this stuff right
Dialogue: 0,1:12:07.96,1:12:10.54,English,,0,0,0,,And if we supposed to teach you to be good and not evil
Dialogue: 0,1:12:11.12,1:12:17.86,English,,0,0,0,,Well there's a couple reasons one is you're going to learn a lot about machine program execution
Dialogue: 0,1:12:18.10,1:12:22.12,English,,0,0,0,,And how stacks work and how byte instructions are encoded and stuff like that
Dialogue: 0,1:12:22.64,1:12:28.42,English,,0,0,0,,You'll use the tools gdb object dump and all those even more than you did with the bomb lab
Dialogue: 0,1:12:28.42,1:12:34.72,English,,0,0,0,,So you'll learn a lot the other is we assume that you will work for forces of
Dialogue: 0,1:12:34.72,1:12:40.86,English,,0,0,0,,But to be a good person you also know what the bet have to know what the bad people do
Dialogue: 0,1:12:40.86,1:12:48.44,English,,0,0,0,,So part of it is to become more effective as a force for good
Dialogue: 0,1:12:51.44,1:12:54.80,English,,0,0,0,,Okay so the final thing to talk about today is unions
Dialogue: 0,1:12:55.58,1:13:02.00,English,,0,0,0,,And the observation about a union nc is the declaration of it looks a lot like a struct
Dialogue: 0,1:13:03.14,1:13:07.04,English,,0,0,0,,Where there's these different fields and they're named and they can have different types
Dialogue: 0,1:13:07.06,1:13:11.38,English,,0,0,0,,And there can be pointers to unions and all that stuff
Dialogue: 0,1:13:11.86,1:13:14.52,English,,0,0,0,,But they're actually totally different what they do
Dialogue: 0,1:13:15.08,1:13:21.22,English,,0,0,0,,You recall with a struct what happens is it allocates enough memory for all the fields to coexist
Dialogue: 0,1:13:22.30,1:13:28.32,English,,0,0,0,,And potentially adding padding bytes for what a union does is it
Dialogue: 0,1:13:29.20,1:13:33.40,English,,0,0,0,,Only k allocates enough storage for the maximum field in it
Dialogue: 0,1:13:33.74,1:13:37.20,English,,0,0,0,,And it assumes that you're only going to be using one of the possible fields
Dialogue: 0,1:13:37.76,1:13:43.60,English,,0,0,0,,And it will literally a store on top of it these fields get stored on top of each other
Dialogue: 0,1:13:43.60,1:13:49.50,English,,0,0,0,,So that if you try to use multiple fields you can mess things up
Dialogue: 0,1:13:50.18,1:13:52.88,English,,0,0,0,,And it's not for that purpose of doing multiple values
Dialogue: 0,1:13:52.88,1:13:57.66,English,,0,0,0,,It's for the purpose of for example if I know I'm only going to use one of these
Dialogue: 0,1:13:58.20,1:14:05.28,English,,0,0,0,,Or it's another also a way to create essentially an alias that will let you reference memory in different ways
Dialogue: 0,1:14:07.02,1:14:11.10,English,,0,0,0,,So for example in your data lab you are using
Dialogue: 0,1:14:12.44,1:14:18.16,English,,0,0,0,,You were manipulating the bit level representations of floating point numbers
Dialogue: 0,1:14:18.74,1:14:22.88,English,,0,0,0,,And in our code that would then convert that to an actual float
Dialogue: 0,1:14:23.22,1:14:24.66,English,,0,0,0,,We used a union
Dialogue: 0,1:14:25.20,1:14:33.32,English,,0,0,0,,Where the union is either to view this field of four bytes is an unsigned or is a float
Dialogue: 0,1:14:33.76,1:14:46.69,English,,0,0,0,,And so I can convert from unsigned to its float representation by just storing the unsigned value  in this union
Dialogue: 0,1:14:46.88,1:14:48.92,English,,0,0,0,,And retrieving it as if it were float
Dialogue: 0,1:14:49.36,1:14:53.64,English,,0,0,0,,And this is a fundamentally different operation than casting
Dialogue: 0,1:14:53.64,1:14:57.68,English,,0,0,0,,Because you recall when you take a unsigned value and you cast it to a float
Dialogue: 0,1:14:58.02,1:14:59.28,English,,0,0,0,,You actually change the bits
Dialogue: 0,1:14:59.32,1:15:07.27,English,,0,0,0,,You change it into the floating point number that's the closest a match to this particular number
Dialogue: 0,1:15:07.27,1:15:11.22,English,,0,0,0,,It would be the equivalent of the function you implemented float underscore u2f
Dialogue: 0,1:15:12.14,1:15:17.94,English,,0,0,0,,But this one actually doesn't change bits it just changes the numeric value changes quite a bit
Dialogue: 0,1:15:19.04,1:15:26.80,English,,0,0,0,,So it's a useful technique to do that to be able to override the the type system and get two bit representations
Dialogue: 0,1:15:28.78,1:15:32.54,English,,0,0,0,,And this actually turns out to be one of the places to where byte ordering
Dialogue: 0,1:15:32.54,1:15:35.62,English,,0,0,0,,Will show up in programs if you're not careful
Dialogue: 0,1:15:37.36,1:15:42.44,English,,0,0,0,,So in particular with this union I can view a block of eight bytes
Dialogue: 0,1:15:42.46,1:15:49.06,English,,0,0,0,,As either eight characters for shorts two ents or one long
Dialogue: 0,1:15:49.64,1:15:53.88,English,,0,0,0,,And on a 64-bit machine like is shown here where along is 64 bits
Dialogue: 0,1:15:54.54,1:16:03.32,English,,0,0,0,,You'll see that you're you're able to look at things as either as a the individual bites making it up
Dialogue: 0,1:16:04.00,1:16:07.44,English,,0,0,0,,Or some longer aggregation of those bites
Dialogue: 0,1:16:08.56,1:16:11.94,English,,0,0,0,,And you'll actually find that depending on what machine you run it on
Dialogue: 0,1:16:12.34,1:16:17.32,English,,0,0,0,,You'll get a different result because of the byte ordering of the different machines
Dialogue: 0,1:16:17.88,1:16:22.50,English,,0,0,0,,So this goes through it what happens when you run on different machines
Dialogue: 0,1:16:23.28,1:16:26.42,English,,0,0,0,,But you'll you'll notice in particular that
Dialogue: 0,1:16:27.92,1:16:31.28,English,,0,0,0,,On an i-32 machine a 32-bit machine
Dialogue: 0,1:16:33.62,1:16:38.92,English,,0,0,0,,It's coming off in in this byte pattern f3f2f1f0
Dialogue: 0,1:16:39.94,1:16:46.34,English,,0,0,0,,And on a sun back when they existed you'd get the opposite because of the byte ordering
Dialogue: 0,1:16:47.06,1:16:50.60,English,,0,0,0,,And now on an x86 64 where a
Dialogue: 0,1:16:51.20,1:16:57.60,English,,0,0,0,,Along is 64 bits you get eight bytes
Dialogue: 0,1:16:58.20,1:17:02.42,English,,0,0,0,,And you can also determine from this if you look carefully that it's in
Dialogue: 0,1:17:02.84,1:17:07.28,English,,0,0,0,,It's a little endian order because this is the we significant byte is f 0
Dialogue: 0,1:17:08.10,1:17:10.30,English,,0,0,0,,Which is the first byte f 0
Dialogue: 0,1:17:11.12,1:17:16.68,English,,0,0,0,,So it's also way to to get to the low level bytes
Dialogue: 0,1:17:16.74,1:17:23.06,English,,0,0,0,,But when you use this kind of thing you're sort of intentionally telling the  the C compiler
Dialogue: 0,1:17:23.62,1:17:27.76,English,,0,0,0,,Trust me I know what I'm doing you don't have to protect me from myself
Dialogue: 0,1:17:28.14,1:17:30.92,English,,0,0,0,,And so if you're not careful you can write code where
Dialogue: 0,1:17:30.92,1:17:33.40,English,,0,0,0,,Because of a byte ordering problem or something like that
Dialogue: 0,1:17:33.80,1:17:36.64,English,,0,0,0,,Won't run properly on some machines
Dialogue: 0,1:17:38.36,1:17:41.12,English,,0,0,0,,So just to summarize then we looked on it
Dialogue: 0,1:17:41.70,1:17:44.92,English,,0,0,0,,We've looked then at the three compound types in c
Dialogue: 0,1:17:44.92,1:17:48.80,English,,0,0,0,,The ways you can aggregate smaller types into larger ones
Dialogue: 0,1:17:48.80,1:17:54.56,English,,0,0,0,,You can make an array of identical elements indexed by a number the position
Dialogue: 0,1:17:54.90,1:18:00.76,English,,0,0,0,,And that usually turns into some kind of scaled computation to get to the particular place
Dialogue: 0,1:18:01.60,1:18:05.66,English,,0,0,0,,We've seen structures where it's a fixed number of fields
Dialogue: 0,1:18:06.16,1:18:09.82,English,,0,0,0,,But the fields can be of different type and the reference by their names
Dialogue: 0,1:18:10.20,1:18:14.92,English,,0,0,0,,And that usually turns into some type of displacement off of the original position
Dialogue: 0,1:18:15.58,1:18:21.76,English,,0,0,0,,And then a union is just a way of sort of piling up in one place
Dialogue: 0,1:18:21.91,1:18:24.48,English,,0,0,0,,Of what a number of different fields
Dialogue: 0,1:18:24.76,1:18:28.38,English,,0,0,0,,And so all it does is ellicott the maximum number of bytes
Dialogue: 0,1:18:28.72,1:18:33.14,English,,0,0,0,,For that and doesn't create enough space for them all to be there at the same time
Dialogue: 0,1:18:34.94,1:18:40.19,English,,0,0,0,,Okay that's it for today then [applause]
