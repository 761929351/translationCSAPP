[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 23  Concurrent Programming.mp4
Video File: ../../../../Desktop/csapp/Lecture 23  Concurrent Programming.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 106
Active Line: 114
Video Position: 18512

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.31,0:00:02.94,English,,0,0,0,,well good afternoon everybody welcome
Dialogue: 0,0:00:04.44,0:00:05.34,English,,0,0,0,,good to see you 
Dialogue: 0,0:00:08.98,0:00:13.74,English,,0,0,0,,so this week we're going to study how to incorporate concurrency into programs 
Dialogue: 0,0:00:13.80,0:00:22.46,English,,0,0,0,,now we've seen concurrency before in the form of processes exception handlers 
Dialogue: 0,0:00:23.24,0:00:25.50,English,,0,0,0,,and in the case of processes it was a Mac 
Dialogue: 0,0:00:25.56,0:00:32.06,English,,0,0,0,,we use we used processes as a mechanism to run multiple independent application programs 
Dialogue: 0,0:00:34.46,0:00:40.12,English,,0,0,0,,Now but you could concurrency also exists in application programs 
Dialogue: 0,0:00:40.64,0:00:44.40,English,,0,0,0,,now we've seen a little bit of this when we studied signal handlers 
Dialogue: 0,0:00:44.84,0:00:52.02,English,,0,0,0,,okay so a signal handler is that is a concurrent flow that runs concurrently with your with your main application program 
Dialogue: 0,0:00:53.06,0:00:54.16,English,,0,0,0,,okay and we've seen
Dialogue: 0,0:00:54.58,0:00:58.64,English,,0,0,0,, we've seen how some of the difficulties that can arise 
Dialogue: 0,0:01:00.60,0:01:03.14,English,,0,0,0,, when we introduce concurrency in our programs 
Dialogue: 0,0:01:08.04,0:01:11.32,English,,0,0,0,,so even with something like a signal handler which isn't doing very much
Dialogue: 0,0:01:12.88,0:01:19.88,English,,0,0,0,, it's very hard for us to reason about this kind of kind of thing we have to two concurrent flows running at the same time
Dialogue: 0,0:01:20.50,0:01:26.34,English,,0,0,0,, like there's our brains just tend to be kind of sequential we want to think about things happening one after the other 
Dialogue: 0,0:01:26.94,0:01:29.84,English,,0,0,0,,you know it is and it's much easier for us to reason about that 
Dialogue: 0,0:01:30.62,0:01:36.12,English,,0,0,0,,reasoning about multiple things happening at the same time really causes problems
Dialogue: 0,0:01:36.16,0:01:46.44,English,,0,0,0,,  and that the fundamental reason is that to really reason about say two independent two concurrent flows 
Dialogue: 0,0:01:47.24,0:01:50.50,English,,0,0,0,,we have to account for all of the possible interleavings of those flows 
Dialogue: 0,0:01:50.98,0:01:56.44,English,,0,0,0,,okay and that's where and that's that grows exponentially with the the with the number of flows 
Dialogue: 0,0:01:57.62,0:02:01.04,English,,0,0,0,, okay so you had you saw this with your signal handlers when you did shell lab 
Dialogue: 0,0:02:01.78,0:02:08.36,English,,0,0,0,,you had you had two concurrent flows the main program and your signal handler 
Dialogue: 0,0:02:08.86,0:02:13.32,English,,0,0,0,,both accessing a shared resource in the form of the jobs list 
Dialogue: 0,0:02:14.02,0:02:18.86,English,,0,0,0,,right and you had to be very careful to prevent an interleaving where
Dialogue: 0,0:02:19.46,0:02:24.48,English,,0,0,0,, that where that data structure was being referenced in an inconsistent state 
Dialogue: 0,0:02:26.46,0:02:33.44,English,,0,0,0,,So what we're going to do this week,and into next week is we're going to look at that kind of application level concurrency
Dialogue: 0,0:02:33.44,0:02:39.58,English,,0,0,0,,but in a more principled in a more principled way than we encountered with signal handlers
Dialogue: 0,0:02:45.70,0:02:54.62,English,,0,0,0,, so as soon as you have multiple flows accessing shared resources all kinds of bad things can happen in your program 
Dialogue: 0,0:02:54.64,0:03:04.68,English,,0,0,0,,and these have been...these bad things,these problems that occur been objects of study in computer science for decades
Dialogue: 0,0:03:05.42,0:03:08.32,English,,0,0,0,, but the kinds of things that can happen are our races
Dialogue: 0,0:03:08.92,0:03:11.60,English,,0,0,0,, which we've seen in when we did the shell lab 
Dialogue: 0,0:03:12.12,0:03:19.46,English,,0,0,0,,where the outcome whether good or bad outcome depends on some some arbitrary scheduling decision
Dialogue: 0,0:03:19.70,0:03:22.58,English,,0,0,0,, right in the case of you know one of the races we saw
Dialogue: 0,0:03:23.16,0:03:25.58,English,,0,0,0,, in the case of a shell was the case where that 
Dialogue: 0,0:03:26.02,0:03:28.70,English,,0,0,0,,a child just because of a scheduling decision by the kernel 
Dialogue: 0,0:03:29.20,0:03:34.64,English,,0,0,0,,runs and finishes before the parent has a chance to add that child to the job list 
Dialogue: 0,0:03:34.68,0:03:38.44,English,,0,0,0,,okay so that's that's a classic example of a race
Dialogue: 0,0:03:39.26,0:03:48.30,English,,0,0,0,,and similarly if you have two people that are trying to making accessing a reservation system on a bird for an airline
Dialogue: 0,0:03:48.64,0:03:54.00,English,,0,0,0,,who gets the if they both access at the same time who actually gets a seat
Dialogue: 0,0:03:54.44,0:04:00.00,English,,0,0,0,, just depends on those various scheduling decisions that are going on in the reservation system 
Dialogue: 0,0:04:01.78,0:04:05.80,English,,0,0,0,,another kind of a problem that occurs is deadlock 
Dialogue: 0,0:04:06.10,0:04:07.54,English,,0,0,0,,so a deadlock is a condition 
Dialogue: 0,0:04:08.62,0:04:13.94,English,,0,0,0,,that exists where you have multiple flows waiting for an event that will never occur 
Dialogue: 0,0:04:15.52,0:04:21.86,English,,0,0,0,,okay so using printf in a signal handler is an example of this kind of of this kind of problem
Dialogue: 0,0:04:22.04,0:04:24.68,English,,0,0,0,,introduces the potential for that kind of problem
Dialogue: 0,0:04:25.74,0:04:30.54,English,,0,0,0,,okay so in your main routine you execute a printf 
Dialogue: 0,0:04:32.50,0:04:34.82,English,,0,0,0,,and that printf acquires a lock 
Dialogue: 0,0:04:35.32,0:04:40.08,English,,0,0,0,,on some system resource I I think it's a terminal lock 
Dialogue: 0,0:04:42.02,0:04:44.40,English,,0,0,0,,and then after that that main printf 
Dialogue: 0,0:04:45.14,0:04:48.16,English,,0,0,0,,acquires that lock it gets interrupted by a signal handler 
Dialogue: 0,0:04:49.76,0:04:52.00,English,,0,0,0,,and now the signal handler if it does a printf 
Dialogue: 0,0:04:53.12,0:04:56.46,English,,0,0,0,,that printf will try to acquire that lock 
Dialogue: 0,0:04:56.96,0:05:00.54,English,,0,0,0,,but it won't be able to get it because the the printf and the main routine has it 
Dialogue: 0,0:05:01.80,0:05:04.34,English,,0,0,0,,so now your signal handler the printf and the signal handler
Dialogue: 0,0:05:04.82,0:05:08.76,English,,0,0,0,, is waiting for an event that will never occur it's waiting for that lock to be released 
Dialogue: 0,0:05:09.18,0:05:15.74,English,,0,0,0,,and it will never occur because the main the printf in the main routine can't release the lock 
Dialogue: 0,0:05:16.98,0:05:18.66,English,,0,0,0,,until the signal handler returns
Dialogue: 0,0:05:19.28,0:05:24.80,English,,0,0,0,,and the signal handler can't acquire the lock until the printf in the main routine  terminates 
Dialogue: 0,0:05:24.86,0:05:27.54,English,,0,0,0,,so that's that's a classic example of deadlock 
Dialogue: 0,0:05:28.06,0:05:37.08,English,,0,0,0,,another more from from real life imagine that imagine that you're all drivers follow the rules very precisely 
Dialogue: 0,0:05:37.56,0:05:41.76,English,,0,0,0,,and the rule for a four-way stop is that whoever gets there first
Dialogue: 0,0:05:42.52,0:05:45.56,English,,0,0,0,, gets to go first okay 
Dialogue: 0,0:05:46.62,0:05:51.36,English,,0,0,0,,so if four cars arrive at the intersection exactly the same time
Dialogue: 0,0:05:51.98,0:05:55.82,English,,0,0,0,, then you have a deadlock you have none of the drivers was first 
Dialogue: 0,0:05:56.18,0:05:58.04,English,,0,0,0,,so no but of the drivers goes
Dialogue: 0,0:05:58.32,0:06:02.50,English,,0,0,0,,and so they're all waiting for a condition  that will never occur 
Dialogue: 0,0:06:03.48,0:06:09.16,English,,0,0,0,,and then other classical things that can go wrong or things like liveness  starvation fairness of this 
Dialogue: 0,0:06:11.22,0:06:13.96,English,,0,0,0,,starvation occurs when you fail 
Dialogue: 0,0:06:14.24,0:06:19.44,English,,0,0,0,,you're trying to do something but you fail to make progress because somebody else keeps getting all the work
Dialogue: 0,0:06:20.22,0:06:27.24,English,,0,0,0,,right so if you were if you had two processes and the kernel always scheduled process A instead of process B
Dialogue: 0,0:06:28.22,0:06:34.90,English,,0,0,0,,process B that would be an example of process B being starved out because of a improper scheduling decision 
Dialogue: 0,0:06:35.30,0:06:40.18,English,,0,0,0,,and we then we would say that that that scheduling policy always schedule B is unfair 
Dialogue: 0,0:06:40.28,0:06:51.84,English,,0,0,0,,right so it doesn't have this property of fairness where every entity in the system gets sort of a reasonable chunk of the processor 
Dialogue: 0,0:06:54.38,0:06:55.70,English,,0,0,0,,so like I said I mean this
Dialogue: 0,0:06:56.20,0:07:01.16,English,,0,0,0,,concurrency has been studied for years it's a very it's a very deep difficult topic 
Dialogue: 0,0:07:01.22,0:07:06.16,English,,0,0,0,,because of this because of this sort of exponential explosion in the number of interleavings
Dialogue: 0,0:07:07.48,0:07:10.64,English,,0,0,0,, so we can't we're not going to cover all of them 
Dialogue: 0,0:07:10.86,0:07:13.78,English,,0,0,0,,but we will cover some so as you get a reasonable idea 
Dialogue: 0,0:07:16.14,0:07:18.46,English,,0,0,0,,of how to incorporate concurrency in your programs 
Dialogue: 0,0:07:19.54,0:07:23.38,English,,0,0,0,,now for for our study of application level concurrency 
Dialogue: 0,0:07:23.68,0:07:26.38,English,,0,0,0,,we're going to use servers as a motivating example 
Dialogue: 0,0:07:26.92,0:07:32.71,English,,0,0,0,,and and the reason is that you cannot write a correct server without using concurrency
Dialogue: 0,0:07:34.60,0:07:38.06,English,,0,0,0,,okay so it's a good it's a really good good motivation 
Dialogue: 0,0:07:39.98,0:07:41.02,English,,0,0,0,,and here's the reason
Dialogue: 0,0:07:41.82,0:07:44.68,English,,0,0,0,,so far we've looked at servers that are iterative
Dialogue: 0,0:07:45.22,0:07:49.26,English,,0,0,0,, okay so they only the only process requests from one client at a time
Dialogue: 0,0:07:50.04,0:07:55.62,English,,0,0,0,, and once they finish processing a request from a client then they go on to the next client 
Dialogue: 0,0:07:56.94,0:08:01.46,English,,0,0,0,,so they so like with our iterative echo server
Dialogue: 0,0:08:02.30,0:08:07.78,English,,0,0,0,, you can see the each each of these clients makes a connection request 
Dialogue: 0,0:08:09.74,0:08:13.68,English,,0,0,0,,then it writes a line of text to the server 
Dialogue: 0,0:08:14.08,0:08:16.62,English,,0,0,0,,and then it waits for the server to echo that back 
Dialogue: 0,0:08:17.12,0:08:20.72,English,,0,0,0,,and in this case this simple case it just then it just closes 
Dialogue: 0,0:08:21.92,0:08:25.34,English,,0,0,0,,okay and the server waits for a connection requests and accept 
Dialogue: 0,0:08:27.84,0:08:33.30,English,,0,0,0,,and then and then waits waits for and then once it accepts that connection requests
Dialogue: 0,0:08:33.98,0:08:40.68,English,,0,0,0,,it it reads and when waits for what waits for that client to to to write something to the connection 
Dialogue: 0,0:08:41.36,0:08:42.74,English,,0,0,0,,and then it echoes it back 
Dialogue: 0,0:08:44.78,0:08:48.86,English,,0,0,0,,and then it and then it waits for the next line 
Dialogue: 0,0:08:49.32,0:08:54.14,English,,0,0,0,,until the until the the client closes that that connection
Dialogue: 0,0:08:54.58,0:08:56.44,English,,0,0,0,, and then the server closes this connection 
Dialogue: 0,0:08:56.44,0:09:01.12,English,,0,0,0,,and then only them does it does it do another except to wait for the next connection request
Dialogue: 0,0:09:02.60,0:09:07.82,English,,0,0,0,,okay so in in in this example client two is also making a connection request 
Dialogue: 0,0:09:09.44,0:09:13.30,English,,0,0,0,, but it never it never runs it has to wait until 
Dialogue: 0,0:09:13.82,0:09:18.34,English,,0,0,0,,the server actually echoes back the response 
Dialogue: 0,0:09:19.56,0:09:22.02,English,,0,0,0,,now there's a there's a little subtlety here that
Dialogue: 0,0:09:23.96,0:09:27.02,English,,0,0,0,, in where exactly that this client Waits
Dialogue: 0,0:09:28.96,0:09:30.54,English,,0,0,0,, so the the semantics of connect 
Dialogue: 0,0:09:31.08,0:09:34.94,English,,0,0,0,,you would think that connect would block until the connection was established 
Dialogue: 0,0:09:35.66,0:09:37.38,English,,0,0,0,,but actually if you tried this out 
Dialogue: 0,0:09:37.92,0:09:45.82,English,,0,0,0,,it turns out that connect actually initiates the connection process inside the kernel but then it returns
Dialogue: 0,0:09:46.28,0:09:50.16,English,,0,0,0,, okay before the the connection has been established 
Dialogue: 0,0:09:51.98,0:09:53.06,English,,0,0,0,,and then it does a right 
Dialogue: 0,0:09:53.76,0:09:57.88,English,,0,0,0,,and that right also returns immediately
Dialogue: 0,0:09:57.96,0:10:06.44,English,,0,0,0,, so right so it doesn't it doesn't wait until the server reads that the  the string that was written
Dialogue: 0,0:10:07.32,0:10:11.56,English,,0,0,0,, and it doesn't block until it it calls the read function 
Dialogue: 0,0:10:12.06,0:10:16.44,English,,0,0,0,,wait waiting for the echoed response from the server and
Dialogue: 0,0:10:18.05,0:10:20.44,English,,0,0,0,,so it actually it it doesn't block until
Dialogue: 0,0:10:20.44,0:10:22.67,English,,0,0,0,,it hits this read and then it spends all
Dialogue: 0,0:10:22.67,0:10:25.06,English,,0,0,0,,it waits waits waits Waits and finally
Dialogue: 0,0:10:25.06,0:10:28.30,English,,0,0,0,,the server accepts the connection
Dialogue: 0,0:10:28.30,0:10:31.55,English,,0,0,0,,requests and then writes the writes the
Dialogue: 0,0:10:31.55,0:10:33.35,English,,0,0,0,,string echoes the string back to the
Dialogue: 0,0:10:33.35,0:10:40.30,English,,0,0,0,,client
Dialogue: 0,0:10:40.30,0:10:44.20,English,,0,0,0,,so the the call to connect actually
Dialogue: 0,0:10:44.20,0:10:48.23,English,,0,0,0,,returns immediately and it's it exploits
Dialogue: 0,0:10:48.23,0:10:49.51,English,,0,0,0,,this feature in the kernel that can
Dialogue: 0,0:10:49.51,0:10:51.52,English,,0,0,0,,queue up these connection requests okay
Dialogue: 0,0:10:51.52,0:10:54.62,English,,0,0,0,,so that the kernel now is going through
Dialogue: 0,0:10:54.62,0:10:56.06,English,,0,0,0,,all the process of setting up the
Dialogue: 0,0:10:56.06,0:10:58.25,English,,0,0,0,,connection but the application program
Dialogue: 0,0:10:58.25,0:11:02.72,English,,0,0,0,,continues and then the right the right
Dialogue: 0,0:11:02.72,0:11:04.82,English,,0,0,0,,inside the client doesn't block because
Dialogue: 0,0:11:04.82,0:11:08.42,English,,0,0,0,,the the the kernel can also queue up the
Dialogue: 0,0:11:08.42,0:11:10.07,English,,0,0,0,,data that's written so it'll little
Dialogue: 0,0:11:10.07,0:11:11.51,English,,0,0,0,,queue it up remember that it was written
Dialogue: 0,0:11:11.51,0:11:13.22,English,,0,0,0,,when the connection actually gets
Dialogue: 0,0:11:13.22,0:11:15.62,English,,0,0,0,,created then it'll it'll send that data
Dialogue: 0,0:11:15.62,0:11:19.43,English,,0,0,0,,along and but there's no way to avoid
Dialogue: 0,0:11:19.43,0:11:22.43,English,,0,0,0,,the the read from from blocking write a
Dialogue: 0,0:11:22.43,0:11:24.58,English,,0,0,0,,read can't return until it gets some
Dialogue: 0,0:11:24.58,0:11:30.29,English,,0,0,0,,data okay so read has to block okay now
Dialogue: 0,0:11:30.29,0:11:31.67,English,,0,0,0,,here's the fundamental flaw of an
Dialogue: 0,0:11:31.67,0:11:34.39,English,,0,0,0,,iterative server and the reason the
Dialogue: 0,0:11:34.39,0:11:37.16,English,,0,0,0,,reason why we have to write them using
Dialogue: 0,0:11:37.16,0:11:39.92,English,,0,0,0,,with with the concurrency okay so let's
Dialogue: 0,0:11:39.92,0:11:43.57,English,,0,0,0,,say in our echo server example we have a
Dialogue: 0,0:11:43.57,0:11:52.88,English,,0,0,0,,client that creates a connection or
Dialogue: 0,0:11:52.88,0:11:54.89,English,,0,0,0,,request a connection it's accepted in
Dialogue: 0,0:11:54.89,0:11:59.18,English,,0,0,0,,the server does the write the server
Dialogue: 0,0:11:59.18,0:12:03.79,English,,0,0,0,,echoes back one you know one string and
Dialogue: 0,0:12:03.79,0:12:08.39,English,,0,0,0,,then the client blocks again or instead
Dialogue: 0,0:12:08.39,0:12:10.43,English,,0,0,0,,of doing the next write or closing the
Dialogue: 0,0:12:10.43,0:12:16.64,English,,0,0,0,,connection the person it
Dialogue: 0,0:12:16.64,0:12:19.45,English,,0,0,0,,the the user goes out to lunch and never
Dialogue: 0,0:12:19.45,0:12:21.82,English,,0,0,0,,types in a string to the the echo client
Dialogue: 0,0:12:21.82,0:12:25.97,English,,0,0,0,,okay so at this point the server calls
Dialogue: 0,0:12:25.97,0:12:29.26,English,,0,0,0,,Reed and then it blocks waiting for this
Dialogue: 0,0:12:29.26,0:12:33.17,English,,0,0,0,,user to type in something and so that
Dialogue: 0,0:12:33.17,0:12:35.00,English,,0,0,0,,the client can send it to the server to
Dialogue: 0,0:12:35.00,0:12:38.60,English,,0,0,0,,be echoed but the user is gone gets hit
Dialogue: 0,0:12:38.60,0:12:42.74,English,,0,0,0,,by a truck who knows anyway so this
Dialogue: 0,0:12:42.74,0:12:46.43,English,,0,0,0,,never this Reed then blocks for an
Dialogue: 0,0:12:46.43,0:12:49.88,English,,0,0,0,,indeterminate amount of time right and
Dialogue: 0,0:12:49.88,0:12:53.30,English,,0,0,0,,while it's blocking client to which also
Dialogue: 0,0:12:53.30,0:12:59.48,English,,0,0,0,,wants service it has to block okay so
Dialogue: 0,0:12:59.48,0:13:01.83,English,,0,0,0,,now you you're in an untenable situation
Dialogue: 0,0:13:01.83,0:13:05.06,English,,0,0,0,,where one client has sort of totally
Dialogue: 0,0:13:05.06,0:13:07.31,English,,0,0,0,,affected all of the other clients in the
Dialogue: 0,0:13:07.31,0:13:08.95,English,,0,0,0,,system and none of the other clients can
Dialogue: 0,0:13:08.95,0:13:11.18,English,,0,0,0,,get service it's so if this were a web
Dialogue: 0,0:13:11.18,0:13:16.14,English,,0,0,0,,server if if one client for some reason
Dialogue: 0,0:13:16.14,0:13:19.61,English,,0,0,0,,blocked no other no other users would be
Dialogue: 0,0:13:19.61,0:13:22.25,English,,0,0,0,,able to use that that web service or
Dialogue: 0,0:13:22.25,0:13:24.82,English,,0,0,0,,look at pages on that that's site so
Dialogue: 0,0:13:24.82,0:13:29.30,English,,0,0,0,,obviously this we can't have this okay
Dialogue: 0,0:13:29.30,0:13:32.66,English,,0,0,0,,so the solution is to use is to write a
Dialogue: 0,0:13:32.66,0:13:34.67,English,,0,0,0,,concurrent server instead of an
Dialogue: 0,0:13:34.67,0:13:37.01,English,,0,0,0,,iterative server where we'll have a
Dialogue: 0,0:13:37.01,0:13:40.10,English,,0,0,0,,separate concurrent flow handle each
Dialogue: 0,0:13:40.10,0:13:44.66,English,,0,0,0,,clients request and interact with each
Dialogue: 0,0:13:44.66,0:13:48.35,English,,0,0,0,,client so now if one client for some
Dialogue: 0,0:13:48.35,0:13:51.52,English,,0,0,0,,reason is slow or misbehaves or blocks
Dialogue: 0,0:13:51.52,0:13:53.75,English,,0,0,0,,the system other clients won't be
Dialogue: 0,0:13:53.75,0:13:55.37,English,,0,0,0,,affected because those clients will be
Dialogue: 0,0:13:55.37,0:14:00.06,English,,0,0,0,,handled way by concurrent flows
Dialogue: 0,0:14:00.06,0:14:03.49,English,,0,0,0,,so there are several ways a number of
Dialogue: 0,0:14:03.49,0:14:09.73,English,,0,0,0,,ways to create these yes from multiple
Dialogue: 0,0:14:09.73,0:14:12.58,English,,0,0,0,,in class probably say four or five of
Dialogue: 0,0:14:12.58,0:14:16.41,English,,0,0,0,,their other clients contacted and put
Dialogue: 0,0:14:16.41,0:14:18.94,English,,0,0,0,,their rights over and queue of all those
Dialogue: 0,0:14:18.94,0:14:21.31,English,,0,0,0,,it actually could and in fact that's
Dialogue: 0,0:14:21.31,0:14:24.43,English,,0,0,0,,that's a form of concurrency okay so the
Dialogue: 0,0:14:24.43,0:14:26.35,English,,0,0,0,,question is could the because could the
Dialogue: 0,0:14:26.35,0:14:29.88,English,,0,0,0,,server queue up requests from from the
Dialogue: 0,0:14:29.88,0:14:34.54,English,,0,0,0,,from clients it could but it would you
Dialogue: 0,0:14:34.54,0:14:36.40,English,,0,0,0,,know I guess actually it would have to
Dialogue: 0,0:14:36.40,0:14:38.20,English,,0,0,0,,queue up it would somehow have to accept
Dialogue: 0,0:14:38.20,0:14:43.63,English,,0,0,0,,those connections right so that no so
Dialogue: 0,0:14:43.63,0:14:48.75,English,,0,0,0,,that wouldn't work so somehow you have
Dialogue: 0,0:14:48.75,0:14:52.30,English,,0,0,0,,since the since the accept calls are
Dialogue: 0,0:14:52.30,0:14:54.94,English,,0,0,0,,iterative sequential there's no way to
Dialogue: 0,0:14:54.94,0:14:57.21,English,,0,0,0,,get data from those those other clients
Dialogue: 0,0:14:57.21,0:15:00.73,English,,0,0,0,,okay but but actually what you're
Dialogue: 0,0:15:00.73,0:15:02.56,English,,0,0,0,,suggesting is very similar to something
Dialogue: 0,0:15:02.56,0:15:05.11,English,,0,0,0,,called an event-based server that that
Dialogue: 0,0:15:05.11,0:15:07.47,English,,0,0,0,,will which is one of the ways we can
Dialogue: 0,0:15:07.47,0:15:10.93,English,,0,0,0,,create concurrent flows so there's
Dialogue: 0,0:15:10.93,0:15:14.86,English,,0,0,0,,there's there's three ways to to create
Dialogue: 0,0:15:14.86,0:15:19.00,English,,0,0,0,,these concurrent flows one is to use
Dialogue: 0,0:15:19.00,0:15:21.00,English,,0,0,0,,processes okay like we've already seen
Dialogue: 0,0:15:21.00,0:15:25.18,English,,0,0,0,,okay so the kernel and so in this case
Dialogue: 0,0:15:25.18,0:15:26.92,English,,0,0,0,,the kernel handles all the the
Dialogue: 0,0:15:26.92,0:15:30.31,English,,0,0,0,,scheduling for us and interleaves it it
Dialogue: 0,0:15:30.31,0:15:33.48,English,,0,0,0,,interleaves the process execution
Dialogue: 0,0:15:33.48,0:15:36.34,English,,0,0,0,,automatically for us and then as we saw
Dialogue: 0,0:15:36.34,0:15:38.71,English,,0,0,0,,before each flow has its own private
Dialogue: 0,0:15:38.71,0:15:40.51,English,,0,0,0,,address space so that each flow is
Dialogue: 0,0:15:40.51,0:15:43.63,English,,0,0,0,,independent and scheduled by the kernel
Dialogue: 0,0:15:43.63,0:15:48.43,English,,0,0,0,,okay now there's a another another
Dialogue: 0,0:15:48.43,0:15:50.95,English,,0,0,0,,approach called event based where the
Dialogue: 0,0:15:50.95,0:15:53.41,English,,0,0,0,,programmer manually interleaves the
Dialogue: 0,0:15:53.41,0:15:55.75,English,,0,0,0,,flows okay so instead of relying on the
Dialogue: 0,0:15:55.75,0:15:58.21,English,,0,0,0,,kernel to interleave these different
Dialogue: 0,0:15:58.21,0:16:01.51,English,,0,0,0,,flows that the user the programmer
Dialogue: 0,0:16:01.51,0:16:04.96,English,,0,0,0,,creates this flows and then manually
Dialogue: 0,0:16:04.96,0:16:09.23,English,,0,0,0,,interleaves them okay
Dialogue: 0,0:16:09.23,0:16:12.07,English,,0,0,0,,and since it's one program all of the
Dialogue: 0,0:16:12.07,0:16:14.11,English,,0,0,0,,flows share the same address space right
Dialogue: 0,0:16:14.11,0:16:15.49,English,,0,0,0,,so they have access to all the same
Dialogue: 0,0:16:15.49,0:16:21.13,English,,0,0,0,,global data structures and they they do
Dialogue: 0,0:16:21.13,0:16:23.54,English,,0,0,0,,they do this inter interleaving using a
Dialogue: 0,0:16:23.54,0:16:25.81,English,,0,0,0,,technique called IO multiplexing you
Dialogue: 0,0:16:25.81,0:16:27.57,English,,0,0,0,,know I'll talk briefly about that but
Dialogue: 0,0:16:27.57,0:16:31.36,English,,0,0,0,,it's it's it's addressed much it much
Dialogue: 0,0:16:31.36,0:16:35.11,English,,0,0,0,,more detail in your book the the third
Dialogue: 0,0:16:35.11,0:16:36.64,English,,0,0,0,,approach which is kind of a hybrid of
Dialogue: 0,0:16:36.64,0:16:40.51,English,,0,0,0,,process based and event based is thread
Dialogue: 0,0:16:40.51,0:16:44.14,English,,0,0,0,,base so used each each each of these
Dialogue: 0,0:16:44.14,0:16:46.93,English,,0,0,0,,flows is is implemented using something
Dialogue: 0,0:16:46.93,0:16:52.83,English,,0,0,0,,called a thread the the kernel
Dialogue: 0,0:16:52.83,0:16:57.27,English,,0,0,0,,like like processes the kernel
Dialogue: 0,0:16:57.27,0:16:59.32,English,,0,0,0,,automatically interleaves these these
Dialogue: 0,0:16:59.32,0:17:03.10,English,,0,0,0,,different threads
Dialogue: 0,0:17:03.10,0:17:05.51,English,,0,0,0,,but unlike a process each each thread
Dialogue: 0,0:17:05.51,0:17:08.38,English,,0,0,0,,shares the same address space okay so
Dialogue: 0,0:17:08.38,0:17:10.76,English,,0,0,0,,each thread has access to all the global
Dialogue: 0,0:17:10.76,0:17:15.28,English,,0,0,0,,variables declared in the program so in
Dialogue: 0,0:17:15.28,0:17:17.75,English,,0,0,0,,so it's like process based and that the
Dialogue: 0,0:17:17.75,0:17:19.97,English,,0,0,0,,kernel automatic automatically schedules
Dialogue: 0,0:17:19.97,0:17:22.10,English,,0,0,0,,it for us but it's like event based in
Dialogue: 0,0:17:22.10,0:17:24.70,English,,0,0,0,,the sense that every flow shares the
Dialogue: 0,0:17:24.70,0:17:28.15,English,,0,0,0,,same address space okay so we'll look
Dialogue: 0,0:17:28.15,0:17:29.24,English,,0,0,0,,let's look at all three of these
Dialogue: 0,0:17:29.24,0:17:34.03,English,,0,0,0,,approaches in more detail so the first
Dialogue: 0,0:17:34.03,0:17:36.59,English,,0,0,0,,approach is to create these flows using
Dialogue: 0,0:17:36.59,0:17:42.32,English,,0,0,0,,processes so in this case this is our
Dialogue: 0,0:17:42.32,0:17:48.19,English,,0,0,0,,echo server example the the client
Dialogue: 0,0:17:48.19,0:17:52.70,English,,0,0,0,,requests a connection and then calls F
Dialogue: 0,0:17:52.70,0:17:55.90,English,,0,0,0,,get us to wait for the the user to type
Dialogue: 0,0:17:55.90,0:17:59.26,English,,0,0,0,,something in at the at the keyboard but
Dialogue: 0,0:17:59.26,0:18:02.65,English,,0,0,0,,the user is gone and so F guest F get us
Dialogue: 0,0:18:02.65,0:18:04.76,English,,0,0,0,,this client just blocks in the call to F
Dialogue: 0,0:18:04.76,0:18:09.38,English,,0,0,0,,get s so the server when it gets a
Dialogue: 0,0:18:09.38,0:18:12.50,English,,0,0,0,,request it accepts the connection
Dialogue: 0,0:18:12.50,0:18:14.80,English,,0,0,0,,requests and returns from the accept
Dialogue: 0,0:18:14.80,0:18:17.94,English,,0,0,0,,call
Dialogue: 0,0:18:17.94,0:18:20.52,English,,0,0,0,,and after it returns from the accept
Dialogue: 0,0:18:20.52,0:18:24.33,English,,0,0,0,,call it Forks a child and then that
Dialogue: 0,0:18:24.33,0:18:27.06,English,,0,0,0,,child interacts that child process now
Dialogue: 0,0:18:27.06,0:18:29.85,English,,0,0,0,,will be responsible for interacting with
Dialogue: 0,0:18:29.85,0:18:32.64,English,,0,0,0,,client number one so the child blocks
Dialogue: 0,0:18:32.64,0:18:36.42,English,,0,0,0,,waiting for data from client one which
Dialogue: 0,0:18:36.42,0:18:38.25,English,,0,0,0,,is never going to show up because the
Dialogue: 0,0:18:38.25,0:18:43.44,English,,0,0,0,,the user left okay but it that's okay
Dialogue: 0,0:18:43.44,0:18:46.86,English,,0,0,0,,because it doesn't stop the server the
Dialogue: 0,0:18:46.86,0:18:49.23,English,,0,0,0,,server after it Forks the child goes
Dialogue: 0,0:18:49.23,0:18:53.07,English,,0,0,0,,right back and calls accept and now
Dialogue: 0,0:18:53.07,0:18:55.44,English,,0,0,0,,accept can accept the connection request
Dialogue: 0,0:18:55.44,0:18:59.79,English,,0,0,0,,from from client to and fork off another
Dialogue: 0,0:18:59.79,0:19:03.51,English,,0,0,0,,a different child that can interact with
Dialogue: 0,0:19:03.51,0:19:06.53,English,,0,0,0,,with client two so that child will read
Dialogue: 0,0:19:06.53,0:19:09.42,English,,0,0,0,,waits for data to show up from the
Dialogue: 0,0:19:09.42,0:19:12.30,English,,0,0,0,,client and then it echoes it back and at
Dialogue: 0,0:19:12.30,0:19:15.12,English,,0,0,0,,some point then closes the this
Dialogue: 0,0:19:15.12,0:19:17.82,English,,0,0,0,,connection okay so you see that this
Dialogue: 0,0:19:17.82,0:19:19.80,English,,0,0,0,,misbehaving client number one now
Dialogue: 0,0:19:19.80,0:19:22.82,English,,0,0,0,,because we have concurrent flows
Dialogue: 0,0:19:22.82,0:19:26.19,English,,0,0,0,,interacting with all the clients this
Dialogue: 0,0:19:26.19,0:19:28.20,English,,0,0,0,,misbehaving client can't adversely
Dialogue: 0,0:19:28.20,0:19:30.51,English,,0,0,0,,affect other clients okay so now that's
Dialogue: 0,0:19:30.51,0:19:34.53,English,,0,0,0,,and this is this idea of creating
Dialogue: 0,0:19:34.53,0:19:36.54,English,,0,0,0,,concurrent flows to to interact with
Dialogue: 0,0:19:36.54,0:19:40.02,English,,0,0,0,,clients is is fundamental there you have
Dialogue: 0,0:19:40.02,0:19:42.75,English,,0,0,0,,to do this in order to to have a sort of
Dialogue: 0,0:19:42.75,0:19:47.16,English,,0,0,0,,a working server implementation alright
Dialogue: 0,0:19:47.16,0:19:48.81,English,,0,0,0,,so how would we actually program this
Dialogue: 0,0:19:48.81,0:19:53.91,English,,0,0,0,,process based concurrent server it's
Dialogue: 0,0:19:53.91,0:19:59.78,English,,0,0,0,,actually surprisingly compact right so
Dialogue: 0,0:19:59.78,0:20:03.90,English,,0,0,0,,we're going to pass in in art V we're
Dialogue: 0,0:20:03.90,0:20:05.79,English,,0,0,0,,going to pass in a port number that we
Dialogue: 0,0:20:05.79,0:20:09.51,English,,0,0,0,,want this server to listen on we've got
Dialogue: 0,0:20:09.51,0:20:11.61,English,,0,0,0,,a listening descriptor and a connected
Dialogue: 0,0:20:11.61,0:20:15.51,English,,0,0,0,,descriptor we've got and then we've got
Dialogue: 0,0:20:15.51,0:20:20.19,English,,0,0,0,,a length and a an address address field
Dialogue: 0,0:20:20.19,0:20:21.76,English,,0,0,0,,and
Dialogue: 0,0:20:21.76,0:20:24.55,English,,0,0,0,,the address is declared in a protocol
Dialogue: 0,0:20:24.55,0:20:27.01,English,,0,0,0,,independent way using this sock outer
Dialogue: 0,0:20:27.01,0:20:29.71,English,,0,0,0,,storage type which is guaranteed to be
Dialogue: 0,0:20:29.71,0:20:31.60,English,,0,0,0,,big enough as you saw last time it's
Dialogue: 0,0:20:31.60,0:20:34.03,English,,0,0,0,,guaranteed to be big enough to handle
Dialogue: 0,0:20:34.03,0:20:39.00,English,,0,0,0,,any type of address either ipv4 or ipv6
Dialogue: 0,0:20:39.00,0:20:41.74,English,,0,0,0,,okay so we install a sick child handler
Dialogue: 0,0:20:41.74,0:20:47.26,English,,0,0,0,,and then we use the the open listen FD a
Dialogue: 0,0:20:47.26,0:20:50.89,English,,0,0,0,,call from your from your textbook to
Dialogue: 0,0:20:50.89,0:20:54.37,English,,0,0,0,,create a listening descriptor on port
Dialogue: 0,0:20:54.37,0:20:56.47,English,,0,0,0,,the port that we pass in as the as the
Dialogue: 0,0:20:56.47,0:21:00.88,English,,0,0,0,,argument to this program and then the
Dialogue: 0,0:21:00.88,0:21:04.93,English,,0,0,0,,server goes into an into a loop and in
Dialogue: 0,0:21:04.93,0:21:11.29,English,,0,0,0,,each iteration it it gets the size of
Dialogue: 0,0:21:11.29,0:21:14.59,English,,0,0,0,,the socket or storage type and puts it
Dialogue: 0,0:21:14.59,0:21:19.30,English,,0,0,0,,into client client lend and then it
Dialogue: 0,0:21:19.30,0:21:24.94,English,,0,0,0,,calls it except with pointers to the to
Dialogue: 0,0:21:24.94,0:21:31.98,English,,0,0,0,,the clients address and client line
Dialogue: 0,0:21:31.98,0:21:34.30,English,,0,0,0,,using the listening descriptor that was
Dialogue: 0,0:21:34.30,0:21:37.96,English,,0,0,0,,returned by open listened FD the accept
Dialogue: 0,0:21:37.96,0:21:41.26,English,,0,0,0,,call after it gets a connection request
Dialogue: 0,0:21:41.26,0:21:43.36,English,,0,0,0,,it returns with the address of the
Dialogue: 0,0:21:43.36,0:21:48.37,English,,0,0,0,,client that made the that at the other
Dialogue: 0,0:21:48.37,0:21:51.43,English,,0,0,0,,end of the connection along with the the
Dialogue: 0,0:21:51.43,0:21:54.70,English,,0,0,0,,at the true length of that of that
Dialogue: 0,0:21:54.70,0:21:58.81,English,,0,0,0,,address so the case of ipv4 before for
Dialogue: 0,0:21:58.81,0:22:02.26,English,,0,0,0,,bytes and then the acceptor turns this
Dialogue: 0,0:22:02.26,0:22:07.72,English,,0,0,0,,this connected file descriptor that the
Dialogue: 0,0:22:07.72,0:22:13.12,English,,0,0,0,,then that that the the child that that
Dialogue: 0,0:22:13.12,0:22:14.89,English,,0,0,0,,it can use to to read and write and
Dialogue: 0,0:22:14.89,0:22:17.92,English,,0,0,0,,interact with that client so it creates
Dialogue: 0,0:22:17.92,0:22:21.61,English,,0,0,0,,say it Forks the child and then the
Dialogue: 0,0:22:21.61,0:22:23.83,English,,0,0,0,,child closes it's listening descriptor
Dialogue: 0,0:22:23.83,0:22:26.80,English,,0,0,0,,and then it calls the echo routine to
Dialogue: 0,0:22:26.80,0:22:30.40,English,,0,0,0,,interact with the to interact with the
Dialogue: 0,0:22:30.40,0:22:33.86,English,,0,0,0,,client and when the echo routine
Dialogue: 0,0:22:33.86,0:22:36.59,English,,0,0,0,,returns the client closes this connected
Dialogue: 0,0:22:36.59,0:22:39.79,English,,0,0,0,,descriptor and then exits and so this
Dialogue: 0,0:22:39.79,0:22:44.36,English,,0,0,0,,close isn't isn't absolutely necessary
Dialogue: 0,0:22:44.36,0:22:46.53,English,,0,0,0,,but we just did it to be careful okay
Dialogue: 0,0:22:46.53,0:22:50.62,English,,0,0,0,,now the parent and this is important
Dialogue: 0,0:22:50.62,0:22:53.02,English,,0,0,0,,closes the connected descriptor because
Dialogue: 0,0:22:53.02,0:22:54.79,English,,0,0,0,,it's not going to use that connected
Dialogue: 0,0:22:54.79,0:22:56.53,English,,0,0,0,,Scripture only the child's will use that
Dialogue: 0,0:22:56.53,0:22:59.21,English,,0,0,0,,connected descriptor so in order to
Dialogue: 0,0:22:59.21,0:23:00.98,English,,0,0,0,,avoid this memory leak it's very
Dialogue: 0,0:23:00.98,0:23:03.25,English,,0,0,0,,important for the child to to close this
Dialogue: 0,0:23:03.25,0:23:05.62,English,,0,0,0,,descriptor okay because remember this
Dialogue: 0,0:23:05.62,0:23:08.23,English,,0,0,0,,the server's running in an infinite loop
Dialogue: 0,0:23:08.23,0:23:11.96,English,,0,0,0,,i mediate in in theory it would never it
Dialogue: 0,0:23:11.96,0:23:16.87,English,,0,0,0,,would never terminate okay and then and
Dialogue: 0,0:23:16.87,0:23:23.09,English,,0,0,0,,then to avoid and to avoid a memory leak
Dialogue: 0,0:23:23.09,0:23:25.85,English,,0,0,0,,we have to in our handler we have to
Dialogue: 0,0:23:25.85,0:23:29.26,English,,0,0,0,,have a sick child handler that will will
Dialogue: 0,0:23:29.26,0:23:31.73,English,,0,0,0,,reap all of the children that have
Dialogue: 0,0:23:31.73,0:23:36.85,English,,0,0,0,,terminated okay so let's look a little
Dialogue: 0,0:23:36.85,0:23:39.16,English,,0,0,0,,more detail how this how this except
Dialogue: 0,0:23:39.16,0:23:43.70,English,,0,0,0,,works so you have a client with a client
Dialogue: 0,0:23:43.70,0:23:45.67,English,,0,0,0,,file descriptor and then you have a
Dialogue: 0,0:23:45.67,0:23:47.11,English,,0,0,0,,server that creates a listening
Dialogue: 0,0:23:47.11,0:23:49.90,English,,0,0,0,,descriptor so let's say that's you know
Dialogue: 0,0:23:49.90,0:23:51.52,English,,0,0,0,,descriptors are indexed by small
Dialogue: 0,0:23:51.52,0:23:54.88,English,,0,0,0,,integers so let's say that that index is
Dialogue: 0,0:23:54.88,0:23:59.80,English,,0,0,0,,three the description number is three so
Dialogue: 0,0:23:59.80,0:24:01.85,English,,0,0,0,,the server blocks and accept waiting for
Dialogue: 0,0:24:01.85,0:24:05.50,English,,0,0,0,,this connection request the client makes
Dialogue: 0,0:24:05.50,0:24:07.22,English,,0,0,0,,a connection request using the connect
Dialogue: 0,0:24:07.22,0:24:10.39,English,,0,0,0,,call
Dialogue: 0,0:24:10.39,0:24:13.57,English,,0,0,0,,okay the server accepts the connect call
Dialogue: 0,0:24:13.57,0:24:19.63,English,,0,0,0,,and then it creates a child and then the
Dialogue: 0,0:24:19.63,0:24:21.49,English,,0,0,0,,child interacts with the client using
Dialogue: 0,0:24:21.49,0:24:23.59,English,,0,0,0,,the the connected file descriptor that
Dialogue: 0,0:24:23.59,0:24:25.69,English,,0,0,0,,was returned from the accept so that
Dialogue: 0,0:24:25.69,0:24:28.75,English,,0,0,0,,would be say descriptive number four
Dialogue: 0,0:24:28.75,0:24:33.97,English,,0,0,0,,just be some different number okay so
Dialogue: 0,0:24:33.97,0:24:36.19,English,,0,0,0,,are the execution model we have for
Dialogue: 0,0:24:36.19,0:24:38.71,English,,0,0,0,,these process based servers is that we
Dialogue: 0,0:24:38.71,0:24:41.95,English,,0,0,0,,have this the server processor listening
Dialogue: 0,0:24:41.95,0:24:44.50,English,,0,0,0,,for connection requests one after the
Dialogue: 0,0:24:44.50,0:24:47.85,English,,0,0,0,,other from clients and then we have
Dialogue: 0,0:24:47.85,0:24:50.05,English,,0,0,0,,multiple clients interacting
Dialogue: 0,0:24:50.05,0:24:53.05,English,,0,0,0,,concurrently with with multiple children
Dialogue: 0,0:24:53.05,0:24:56.47,English,,0,0,0,,interacting concurrently with multiple
Dialogue: 0,0:24:56.47,0:25:01.06,English,,0,0,0,,clients okay since each of these each of
Dialogue: 0,0:25:01.06,0:25:02.92,English,,0,0,0,,these children are processes there's no
Dialogue: 0,0:25:02.92,0:25:07.99,English,,0,0,0,,shared state between them and both
Dialogue: 0,0:25:07.99,0:25:13.33,English,,0,0,0,,parent and child inherit the have they
Dialogue: 0,0:25:13.33,0:25:15.10,English,,0,0,0,,inherit the descriptor table so they
Dialogue: 0,0:25:15.10,0:25:17.92,English,,0,0,0,,have they both have copies of listen F T
Dialogue: 0,0:25:17.92,0:25:21.64,English,,0,0,0,,and and can end the listening descriptor
Dialogue: 0,0:25:21.64,0:25:25.18,English,,0,0,0,,in the connected descriptor okay and as
Dialogue: 0,0:25:25.18,0:25:27.25,English,,0,0,0,,we saw before the parent must close its
Dialogue: 0,0:25:27.25,0:25:29.62,English,,0,0,0,,it's copy of the connected file
Dialogue: 0,0:25:29.62,0:25:32.50,English,,0,0,0,,descriptor the child should close the
Dialogue: 0,0:25:32.50,0:25:35.17,English,,0,0,0,,listening descriptor but it's you know
Dialogue: 0,0:25:35.17,0:25:40.26,English,,0,0,0,,just to be just because it's not needed
Dialogue: 0,0:25:40.26,0:25:42.85,English,,0,0,0,,all right when you so these are actually
Dialogue: 0,0:25:42.85,0:25:45.13,English,,0,0,0,,pretty simple to create and there's just
Dialogue: 0,0:25:45.13,0:25:46.48,English,,0,0,0,,a couple of things you have to keep in
Dialogue: 0,0:25:46.48,0:25:49.00,English,,0,0,0,,mind when you when you build a process
Dialogue: 0,0:25:49.00,0:25:53.26,English,,0,0,0,,based server so firstly as we as with
Dialogue: 0,0:25:53.26,0:25:55.75,English,,0,0,0,,any any any process that creates
Dialogue: 0,0:25:55.75,0:26:00.22,English,,0,0,0,,children it has to reap these children
Dialogue: 0,0:26:00.22,0:26:02.64,English,,0,0,0,,that have terminated to avoid this
Dialogue: 0,0:26:02.64,0:26:05.86,English,,0,0,0,,memory leak the parent process has to
Dialogue: 0,0:26:05.86,0:26:07.51,English,,0,0,0,,close its copy of the connected file
Dialogue: 0,0:26:07.51,0:26:11.65,English,,0,0,0,,descriptor and there's a couple reasons
Dialogue: 0,0:26:11.65,0:26:15.82,English,,0,0,0,,it fact if it doesn't it will not only
Dialogue: 0,0:26:15.82,0:26:19.60,English,,0,0,0,,create a memory leak but that the
Dialogue: 0,0:26:19.60,0:26:21.70,English,,0,0,0,,the state associated with that
Dialogue: 0,0:26:21.70,0:26:24.42,English,,0,0,0,,descriptor will actually stay around
Dialogue: 0,0:26:24.42,0:26:26.41,English,,0,0,0,,forever because the the kernel won't
Dialogue: 0,0:26:26.41,0:26:30.58,English,,0,0,0,,close that connection so it as we saw
Dialogue: 0,0:26:30.58,0:26:33.97,English,,0,0,0,,when we looked at at file i/o this is
Dialogue: 0,0:26:33.97,0:26:35.83,English,,0,0,0,,just enough this is the same kind of
Dialogue: 0,0:26:35.83,0:26:39.22,English,,0,0,0,,file i/o we looked at before so the
Dialogue: 0,0:26:39.22,0:26:40.75,English,,0,0,0,,kernel keeps a reference count for each
Dialogue: 0,0:26:40.75,0:26:44.79,English,,0,0,0,,each socket that's open so after the
Dialogue: 0,0:26:44.79,0:26:47.04,English,,0,0,0,,fork now there's there's two there's a
Dialogue: 0,0:26:47.04,0:26:48.88,English,,0,0,0,,parent and the child which are accessing
Dialogue: 0,0:26:48.88,0:26:52.21,English,,0,0,0,,the file table associated with the
Dialogue: 0,0:26:52.21,0:26:55.90,English,,0,0,0,,connected file descriptor okay so that
Dialogue: 0,0:26:55.90,0:26:58.21,English,,0,0,0,,and the connection won't be closed until
Dialogue: 0,0:26:58.21,0:26:59.77,English,,0,0,0,,the reference count for that connected
Dialogue: 0,0:26:59.77,0:27:02.54,English,,0,0,0,,file description is zero right so the
Dialogue: 0,0:27:02.54,0:27:05.44,English,,0,0,0,,that file table entry won't be removed
Dialogue: 0,0:27:05.44,0:27:09.49,English,,0,0,0,,from the kernel until until there's only
Dialogue: 0,0:27:09.49,0:27:11.35,English,,0,0,0,,there until there's zero references to
Dialogue: 0,0:27:11.35,0:27:12.78,English,,0,0,0,,it okay
Dialogue: 0,0:27:12.78,0:27:16.84,English,,0,0,0,,so both the parent and the child have to
Dialogue: 0,0:27:16.84,0:27:21.76,English,,0,0,0,,close that that descriptor okay now the
Dialogue: 0,0:27:21.76,0:27:23.65,English,,0,0,0,,good thing about process based servers
Dialogue: 0,0:27:23.65,0:27:25.72,English,,0,0,0,,is that they they do the job for us that
Dialogue: 0,0:27:25.72,0:27:27.19,English,,0,0,0,,we asked them to do right we wanted them
Dialogue: 0,0:27:27.19,0:27:30.42,English,,0,0,0,,to handle to interact with multiple
Dialogue: 0,0:27:30.42,0:27:32.16,English,,0,0,0,,clients concurrently or have that
Dialogue: 0,0:27:32.16,0:27:34.90,English,,0,0,0,,ability there's a very clean sharing
Dialogue: 0,0:27:34.90,0:27:38.11,English,,0,0,0,,model right so there's private address
Dialogue: 0,0:27:38.11,0:27:41.32,English,,0,0,0,,spaces between the NE all of the
Dialogue: 0,0:27:41.32,0:27:44.83,English,,0,0,0,,children and the parent they shared they
Dialogue: 0,0:27:44.83,0:27:46.57,English,,0,0,0,,have separate descriptors but they share
Dialogue: 0,0:27:46.57,0:27:48.85,English,,0,0,0,,they have separate copies of the
Dialogue: 0,0:27:48.85,0:27:51.64,English,,0,0,0,,descriptor table but they share the same
Dialogue: 0,0:27:51.64,0:27:56.15,English,,0,0,0,,Open File table okay
Dialogue: 0,0:27:56.15,0:27:59.77,English,,0,0,0,,and there's so in some sense this is a
Dialogue: 0,0:27:59.77,0:28:01.90,English,,0,0,0,,simplest possible way to create a
Dialogue: 0,0:28:01.90,0:28:04.66,English,,0,0,0,,concurrent servers and if you can get
Dialogue: 0,0:28:04.66,0:28:06.91,English,,0,0,0,,get if you can get by with not sharing
Dialogue: 0,0:28:06.91,0:28:09.32,English,,0,0,0,,any global variables or sharing address
Dialogue: 0,0:28:09.32,0:28:13.49,English,,0,0,0,,basis then this is this is the way to go
Dialogue: 0,0:28:13.49,0:28:16.54,English,,0,0,0,,all right now the disadvantage is that
Dialogue: 0,0:28:16.54,0:28:18.47,English,,0,0,0,,there's additional overhead for
Dialogue: 0,0:28:18.47,0:28:20.60,English,,0,0,0,,processes even even with this
Dialogue: 0,0:28:20.60,0:28:23.23,English,,0,0,0,,copy-on-write trick that we saw for
Dialogue: 0,0:28:23.23,0:28:26.39,English,,0,0,0,,sharing the sharing the address space
Dialogue: 0,0:28:26.39,0:28:29.35,English,,0,0,0,,between the parent and the child still
Dialogue: 0,0:28:29.35,0:28:33.86,English,,0,0,0,,it's still non-trivial overhead and it's
Dialogue: 0,0:28:33.86,0:28:35.63,English,,0,0,0,,it's you have to actually do a lot of
Dialogue: 0,0:28:35.63,0:28:37.25,English,,0,0,0,,work if you want to share data between
Dialogue: 0,0:28:37.25,0:28:38.96,English,,0,0,0,,processes so like let's say you want to
Dialogue: 0,0:28:38.96,0:28:41.41,English,,0,0,0,,have some kind of a shared cache between
Dialogue: 0,0:28:41.41,0:28:44.38,English,,0,0,0,,multiple processes either have to use
Dialogue: 0,0:28:44.38,0:28:49.34,English,,0,0,0,,files okay on disk or if you want to
Dialogue: 0,0:28:49.34,0:28:52.54,English,,0,0,0,,share memory you have to use some kind
Dialogue: 0,0:28:52.54,0:28:54.50,English,,0,0,0,,of you have to use some kind of memory
Dialogue: 0,0:28:54.50,0:28:59.09,English,,0,0,0,,mapping or you have to use what's these
Dialogue: 0,0:28:59.09,0:29:01.19,English,,0,0,0,,inter process communication mechanisms
Dialogue: 0,0:29:01.19,0:29:03.83,English,,0,0,0,,which we haven't we haven't talked about
Dialogue: 0,0:29:03.83,0:29:06.52,English,,0,0,0,,but there's there's ways pipes are
Dialogue: 0,0:29:06.52,0:29:07.46,English,,0,0,0,,probably the ones you're most familiar
Dialogue: 0,0:29:07.46,0:29:12.23,English,,0,0,0,,with so a pipe allows one process to to
Dialogue: 0,0:29:12.23,0:29:16.52,English,,0,0,0,,send data to another process and there's
Dialogue: 0,0:29:16.52,0:29:19.46,English,,0,0,0,,ways to share memory between processes
Dialogue: 0,0:29:19.46,0:29:22.53,English,,0,0,0,,but they're they're cumbersome and
Dialogue: 0,0:29:22.53,0:29:26.02,English,,0,0,0,,require I have to be implemented with
Dialogue: 0,0:29:26.02,0:29:29.89,English,,0,0,0,,care okay now the second approach is is
Dialogue: 0,0:29:29.89,0:29:33.44,English,,0,0,0,,we call an event-based server so the
Dialogue: 0,0:29:33.44,0:29:38.14,English,,0,0,0,,idea here is that the server maintains a
Dialogue: 0,0:29:38.14,0:29:43.33,English,,0,0,0,,set of active connections so it it it
Dialogue: 0,0:29:43.33,0:29:46.54,English,,0,0,0,,has an array of of connected file
Dialogue: 0,0:29:46.54,0:29:48.85,English,,0,0,0,,descriptors from different clients okay
Dialogue: 0,0:29:48.85,0:29:51.28,English,,0,0,0,,and then it determines which of those
Dialogue: 0,0:29:51.28,0:29:52.97,English,,0,0,0,,and it also has a listening descriptor
Dialogue: 0,0:29:52.97,0:29:57.15,English,,0,0,0,,and then it determines which of those
Dialogue: 0,0:29:57.15,0:30:01.13,English,,0,0,0,,descriptors have pending input and it
Dialogue: 0,0:30:01.13,0:30:04.76,English,,0,0,0,,determines this using a system call
Dialogue: 0,0:30:04.76,0:30:07.03,English,,0,0,0,,called select or eople there's several
Dialogue: 0,0:30:07.03,0:30:08.64,English,,0,0,0,,ways to determine this
Dialogue: 0,0:30:08.64,0:30:12.71,English,,0,0,0,,but but basically using select or a poll
Dialogue: 0,0:30:12.71,0:30:15.27,English,,0,0,0,,you can determine which of a set of
Dialogue: 0,0:30:15.27,0:30:20.88,English,,0,0,0,,descriptors has pending input right and
Dialogue: 0,0:30:20.88,0:30:23.58,English,,0,0,0,,then this this and so the arrival of
Dialogue: 0,0:30:23.58,0:30:25.95,English,,0,0,0,,input at a descriptors is called an
Dialogue: 0,0:30:25.95,0:30:27.78,English,,0,0,0,,event because it changes the state of
Dialogue: 0,0:30:27.78,0:30:31.29,English,,0,0,0,,the descriptor okay so an event is
Dialogue: 0,0:30:31.29,0:30:33.60,English,,0,0,0,,always event in general is always some
Dialogue: 0,0:30:33.60,0:30:38.85,English,,0,0,0,,kind of state change so in this case
Dialogue: 0,0:30:38.85,0:30:42.69,English,,0,0,0,,when data arrives on a socket that's a
Dialogue: 0,0:30:42.69,0:30:46.23,English,,0,0,0,,change in the state so there was no data
Dialogue: 0,0:30:46.23,0:30:49.29,English,,0,0,0,,before the event after the event now
Dialogue: 0,0:30:49.29,0:30:54.87,English,,0,0,0,,there's data that the server can read so
Dialogue: 0,0:30:54.87,0:30:58.47,English,,0,0,0,,if if the listening descriptor has input
Dialogue: 0,0:30:58.47,0:31:00.69,English,,0,0,0,,then the server calls except to accept
Dialogue: 0,0:31:00.69,0:31:04.80,English,,0,0,0,,the connection and for all and then all
Dialogue: 0,0:31:04.80,0:31:06.69,English,,0,0,0,,connected descriptors that have pending
Dialogue: 0,0:31:06.69,0:31:09.33,English,,0,0,0,,inputs it services those it reads from
Dialogue: 0,0:31:09.33,0:31:16.26,English,,0,0,0,,those in some order okay now that the
Dialogue: 0,0:31:16.26,0:31:17.94,English,,0,0,0,,details for how to do this are described
Dialogue: 0,0:31:17.94,0:31:24.27,English,,0,0,0,,in the book but basically I mean the
Dialogue: 0,0:31:24.27,0:31:25.65,English,,0,0,0,,conceptually is pretty simple it's
Dialogue: 0,0:31:25.65,0:31:29.43,English,,0,0,0,,actually tricky to implement but the
Dialogue: 0,0:31:29.43,0:31:31.47,English,,0,0,0,,idea is that there's some set of active
Dialogue: 0,0:31:31.47,0:31:33.39,English,,0,0,0,,descriptors right there's some set of
Dialogue: 0,0:31:33.39,0:31:35.25,English,,0,0,0,,descriptors connected descriptors that
Dialogue: 0,0:31:35.25,0:31:39.99,English,,0,0,0,,you're using that are being used right
Dialogue: 0,0:31:39.99,0:31:44.88,English,,0,0,0,,now to to interact with a client there's
Dialogue: 0,0:31:44.88,0:31:47.93,English,,0,0,0,,some that are inactive so if descriptors
Dialogue: 0,0:31:47.93,0:31:50.25,English,,0,0,0,,descriptor was closed then it's it's
Dialogue: 0,0:31:50.25,0:31:54.24,English,,0,0,0,,it's no longer active right and then
Dialogue: 0,0:31:54.24,0:31:55.71,English,,0,0,0,,there's other descriptors that have
Dialogue: 0,0:31:55.71,0:31:57.30,English,,0,0,0,,never been used so we just have this
Dialogue: 0,0:31:57.30,0:32:01.77,English,,0,0,0,,array of descriptors and then and then
Dialogue: 0,0:32:01.77,0:32:04.97,English,,0,0,0,,we record there you know the the
Dialogue: 0,0:32:04.97,0:32:07.13,English,,0,0,0,,descriptor number for each of those
Dialogue: 0,0:32:07.13,0:32:16.34,English,,0,0,0,,connected for each of those descriptors
Dialogue: 0,0:32:16.34,0:32:19.45,English,,0,0,0,,and then using select or a poll or some
Dialogue: 0,0:32:19.45,0:32:21.66,English,,0,0,0,,other mechanism we somehow determine
Dialogue: 0,0:32:21.66,0:32:24.48,English,,0,0,0,,which of those active descriptors have
Dialogue: 0,0:32:24.48,0:32:27.42,English,,0,0,0,,input and then we service each of those
Dialogue: 0,0:32:27.42,0:32:30.12,English,,0,0,0,,in the case of listen FD by calling
Dialogue: 0,0:32:30.12,0:32:34.14,English,,0,0,0,,except in the case of these connected
Dialogue: 0,0:32:34.14,0:32:36.78,English,,0,0,0,,descriptors actually these are this
Dialogue: 0,0:32:36.78,0:32:41.20,English,,0,0,0,,should be con up D not client of D but
Dialogue: 0,0:32:41.20,0:32:42.30,English,,0,0,0,,in the case of these connected
Dialogue: 0,0:32:42.30,0:32:44.79,English,,0,0,0,,descriptors we we read the data from
Dialogue: 0,0:32:44.79,0:32:51.46,English,,0,0,0,,them and the when we when we read the
Dialogue: 0,0:32:51.46,0:32:54.12,English,,0,0,0,,data from each each descriptor we do
Dialogue: 0,0:32:54.12,0:33:00.15,English,,0,0,0,,some work okay so so data arrives that a
Dialogue: 0,0:33:00.15,0:33:02.71,English,,0,0,0,,descriptor and then we read that data
Dialogue: 0,0:33:02.71,0:33:06.21,English,,0,0,0,,and then we do some kind of work okay
Dialogue: 0,0:33:06.21,0:33:09.21,English,,0,0,0,,maybe in in the case of an echo server
Dialogue: 0,0:33:09.21,0:33:11.51,English,,0,0,0,,we echo it right back okay
Dialogue: 0,0:33:11.51,0:33:15.66,English,,0,0,0,,in the case of a web server we may if
Dialogue: 0,0:33:15.66,0:33:19.74,English,,0,0,0,,that data was HTTP request we might go
Dialogue: 0,0:33:19.74,0:33:22.14,English,,0,0,0,,and fetch a file from disk and return it
Dialogue: 0,0:33:22.14,0:33:26.91,English,,0,0,0,,okay but but in any case we we notice
Dialogue: 0,0:33:26.91,0:33:29.64,English,,0,0,0,,that the descriptor has some data we
Dialogue: 0,0:33:29.64,0:33:32.13,English,,0,0,0,,read that data and then we respond to it
Dialogue: 0,0:33:32.13,0:33:36.19,English,,0,0,0,,in some way okay so that response those
Dialogue: 0,0:33:36.19,0:33:40.67,English,,0,0,0,,multiple responses are concurrent flows
Dialogue: 0,0:33:40.67,0:33:44.32,English,,0,0,0,,okay the the we're interacting with that
Dialogue: 0,0:33:44.32,0:33:47.71,English,,0,0,0,,client we're interacting we're creating
Dialogue: 0,0:33:47.71,0:33:49.62,English,,0,0,0,,concurrent flows while concurrent flow
Dialogue: 0,0:33:49.62,0:33:53.95,English,,0,0,0,,for each each client and we're servicing
Dialogue: 0,0:33:53.95,0:33:56.34,English,,0,0,0,,those clients concurrently okay so even
Dialogue: 0,0:33:56.34,0:33:58.29,English,,0,0,0,,though it's a sequential program right
Dialogue: 0,0:33:58.29,0:34:00.27,English,,0,0,0,,we're not using fork or anything it's
Dialogue: 0,0:34:00.27,0:34:02.25,English,,0,0,0,,it's a it's just a sea program
Dialogue: 0,0:34:02.25,0:34:06.03,English,,0,0,0,,straightforward C program we're writing
Dialogue: 0,0:34:06.03,0:34:08.34,English,,0,0,0,,in such a way that we're creating our
Dialogue: 0,0:34:08.34,0:34:15.44,English,,0,0,0,,own concurrent flows
Dialogue: 0,0:34:15.44,0:34:18.54,English,,0,0,0,,so there's uh as with any any approach
Dialogue: 0,0:34:18.54,0:34:19.80,English,,0,0,0,,there's there's advantages and
Dialogue: 0,0:34:19.80,0:34:22.29,English,,0,0,0,,disadvantages so the a big advantage of
Dialogue: 0,0:34:22.29,0:34:24.42,English,,0,0,0,,event based servers is that it's just a
Dialogue: 0,0:34:24.42,0:34:27.66,English,,0,0,0,,sequoia it's one process with the st.
Dialogue: 0,0:34:27.66,0:34:29.16,English,,0,0,0,,with one address space
Dialogue: 0,0:34:29.16,0:34:30.60,English,,0,0,0,,right so it's very easy you can use
Dialogue: 0,0:34:30.60,0:34:33.27,English,,0,0,0,,conventional debugger gdb to step
Dialogue: 0,0:34:33.27,0:34:35.22,English,,0,0,0,,through you can see everything you have
Dialogue: 0,0:34:35.22,0:34:37.41,English,,0,0,0,,access to everything so in that sense
Dialogue: 0,0:34:37.41,0:34:41.96,English,,0,0,0,,they're much simpler to debug understand
Dialogue: 0,0:34:41.96,0:34:44.55,English,,0,0,0,,and then there's no process or thread
Dialogue: 0,0:34:44.55,0:34:48.89,English,,0,0,0,,control overhead so when we when we
Dialogue: 0,0:34:48.89,0:34:51.12,English,,0,0,0,,service a particular descriptor it's
Dialogue: 0,0:34:51.12,0:34:53.73,English,,0,0,0,,very it's there's very little overhead
Dialogue: 0,0:34:53.73,0:34:55.77,English,,0,0,0,,right we just the only overhead is sort
Dialogue: 0,0:34:55.77,0:34:57.96,English,,0,0,0,,of determining that that descriptor has
Dialogue: 0,0:34:57.96,0:35:03.84,English,,0,0,0,,input available okay and so because of
Dialogue: 0,0:35:03.84,0:35:07.95,English,,0,0,0,,that this is the high performance web
Dialogue: 0,0:35:07.95,0:35:11.67,English,,0,0,0,,servers like nodejs nginx tornado they
Dialogue: 0,0:35:11.67,0:35:14.39,English,,0,0,0,,all use this event based approach gates
Dialogue: 0,0:35:14.39,0:35:18.90,English,,0,0,0,,if you want to get over 10,000 10,000
Dialogue: 0,0:35:18.90,0:35:20.91,English,,0,0,0,,requests per second you have to go with
Dialogue: 0,0:35:20.91,0:35:23.70,English,,0,0,0,,something like this okay the
Dialogue: 0,0:35:23.70,0:35:26.79,English,,0,0,0,,disadvantage is it's much harder to more
Dialogue: 0,0:35:26.79,0:35:29.72,English,,0,0,0,,complexed it to code up then the other
Dialogue: 0,0:35:29.72,0:35:36.24,English,,0,0,0,,processor thread based designs and it's
Dialogue: 0,0:35:36.24,0:35:39.96,English,,0,0,0,,very difficult so one of the the hardest
Dialogue: 0,0:35:39.96,0:35:42.33,English,,0,0,0,,aspects aspects of the writing and event
Dialogue: 0,0:35:42.33,0:35:44.46,English,,0,0,0,,based server is that you have to figure
Dialogue: 0,0:35:44.46,0:35:46.26,English,,0,0,0,,out how much work you're going to do in
Dialogue: 0,0:35:46.26,0:35:50.04,English,,0,0,0,,response to an event okay so let me give
Dialogue: 0,0:35:50.04,0:35:51.78,English,,0,0,0,,you let's say that this server is a web
Dialogue: 0,0:35:51.78,0:35:56.22,English,,0,0,0,,server and you get input on on one of
Dialogue: 0,0:35:56.22,0:35:59.79,English,,0,0,0,,your connected file descriptor the
Dialogue: 0,0:35:59.79,0:36:02.19,English,,0,0,0,,simplest the simplest thing to do would
Dialogue: 0,0:36:02.19,0:36:05.99,English,,0,0,0,,be to then assume to read the entire
Dialogue: 0,0:36:05.99,0:36:10.20,English,,0,0,0,,HTTP request and not and not return
Dialogue: 0,0:36:10.20,0:36:12.62,English,,0,0,0,,until you've read the entire request
Dialogue: 0,0:36:12.62,0:36:15.99,English,,0,0,0,,okay so in that case the the amount of
Dialogue: 0,0:36:15.99,0:36:19.17,English,,0,0,0,,work that you do in response to an event
Dialogue: 0,0:36:19.17,0:36:21.54,English,,0,0,0,,is very coarse-grained there's a lot of
Dialogue: 0,0:36:21.54,0:36:23.31,English,,0,0,0,,instructions because we're going to read
Dialogue: 0,0:36:23.31,0:36:25.59,English,,0,0,0,,every single every single line in that
Dialogue: 0,0:36:25.59,0:36:26.59,English,,0,0,0,,HTTP
Dialogue: 0,0:36:26.59,0:36:30.22,English,,0,0,0,,request header but it's so that's course
Dialogue: 0,0:36:30.22,0:36:33.82,English,,0,0,0,,that's an example of coarse grain it's
Dialogue: 0,0:36:33.82,0:36:36.49,English,,0,0,0,,very simple because every time you get a
Dialogue: 0,0:36:36.49,0:36:38.11,English,,0,0,0,,request on a connected descriptor you
Dialogue: 0,0:36:38.11,0:36:40.16,English,,0,0,0,,just read the whole you just read the
Dialogue: 0,0:36:40.16,0:36:43.09,English,,0,0,0,,whole HTTP request and then send a
Dialogue: 0,0:36:43.09,0:36:44.07,English,,0,0,0,,response
Dialogue: 0,0:36:44.07,0:36:49.27,English,,0,0,0,,okay so there's on the other hand it's
Dialogue: 0,0:36:49.27,0:36:51.68,English,,0,0,0,,vulnerable because what if a client
Dialogue: 0,0:36:51.68,0:36:54.65,English,,0,0,0,,misbehaves and doesn't send the entire
Dialogue: 0,0:36:54.65,0:36:56.77,English,,0,0,0,,HTTP request what if it sends half of
Dialogue: 0,0:36:56.77,0:36:59.56,English,,0,0,0,,the requests so if you were doing to
Dialogue: 0,0:36:59.56,0:37:01.94,English,,0,0,0,,design an event based web server you
Dialogue: 0,0:37:01.94,0:37:03.70,English,,0,0,0,,probably wouldn't want to do that right
Dialogue: 0,0:37:03.70,0:37:07.67,English,,0,0,0,,because that a single client we would be
Dialogue: 0,0:37:07.67,0:37:09.82,English,,0,0,0,,back in the situation we were before
Dialogue: 0,0:37:09.82,0:37:12.07,English,,0,0,0,,where a single misbehaving client could
Dialogue: 0,0:37:12.07,0:37:14.69,English,,0,0,0,,sort of shut down the whole server so
Dialogue: 0,0:37:14.69,0:37:17.74,English,,0,0,0,,you might say well I'm going to I'm
Dialogue: 0,0:37:17.74,0:37:22.36,English,,0,0,0,,going to my unit of work that I do in
Dialogue: 0,0:37:22.36,0:37:25.46,English,,0,0,0,,response to a request will be to read a
Dialogue: 0,0:37:25.46,0:37:28.05,English,,0,0,0,,single line from the request
Dialogue: 0,0:37:28.05,0:37:30.68,English,,0,0,0,,okay so I'll read a single line and then
Dialogue: 0,0:37:30.68,0:37:34.51,English,,0,0,0,,I'll and then I'll return okay so every
Dialogue: 0,0:37:34.51,0:37:37.94,English,,0,0,0,,so now we're interleaving reading single
Dialogue: 0,0:37:37.94,0:37:40.47,English,,0,0,0,,lines and once I've read the entire
Dialogue: 0,0:37:40.47,0:37:42.92,English,,0,0,0,,request then out then I'll send the
Dialogue: 0,0:37:42.92,0:37:46.59,English,,0,0,0,,response so that's better right so a
Dialogue: 0,0:37:46.59,0:37:50.45,English,,0,0,0,,misbehaving client if it if it's sending
Dialogue: 0,0:37:50.45,0:37:53.85,English,,0,0,0,,like whole whole text lines at a time
Dialogue: 0,0:37:53.85,0:37:56.32,English,,0,0,0,,even if it stops halfway through we'll
Dialogue: 0,0:37:56.32,0:37:57.49,English,,0,0,0,,still be able to make progress in
Dialogue: 0,0:37:57.49,0:38:01.51,English,,0,0,0,,service other other clients so that's a
Dialogue: 0,0:38:01.51,0:38:03.65,English,,0,0,0,,finer grained approach it's better it's
Dialogue: 0,0:38:03.65,0:38:06.46,English,,0,0,0,,probably more robust than waiting for
Dialogue: 0,0:38:06.46,0:38:08.53,English,,0,0,0,,the whole the whole request but it's
Dialogue: 0,0:38:08.53,0:38:11.21,English,,0,0,0,,still vulnerable because the client
Dialogue: 0,0:38:11.21,0:38:14.45,English,,0,0,0,,could just send a partial line so now
Dialogue: 0,0:38:14.45,0:38:17.23,English,,0,0,0,,we're back so really the only way to
Dialogue: 0,0:38:17.23,0:38:20.69,English,,0,0,0,,write a robust event based web server is
Dialogue: 0,0:38:20.69,0:38:25.33,English,,0,0,0,,to be able to handle partial lines just
Dialogue: 0,0:38:25.33,0:38:28.36,English,,0,0,0,,read when there's data available on a on
Dialogue: 0,0:38:28.36,0:38:30.44,English,,0,0,0,,a on a descriptor you just read whatever
Dialogue: 0,0:38:30.44,0:38:32.93,English,,0,0,0,,data is available you remember how much
Dialogue: 0,0:38:32.93,0:38:35.15,English,,0,0,0,,you read if it's not a whole line you
Dialogue: 0,0:38:35.15,0:38:36.49,English,,0,0,0,,somehow have to remember that you have
Dialogue: 0,0:38:36.49,0:38:38.04,English,,0,0,0,,to buffer it remember it
Dialogue: 0,0:38:38.04,0:38:39.45,English,,0,0,0,,so now it's getting really complicated
Dialogue: 0,0:38:39.45,0:38:43.20,English,,0,0,0,,right but that's what you that's the
Dialogue: 0,0:38:43.20,0:38:45.03,English,,0,0,0,,price you pay for this for this low
Dialogue: 0,0:38:45.03,0:38:47.93,English,,0,0,0,,overhead sort of easier to debug kind of
Dialogue: 0,0:38:47.93,0:38:50.94,English,,0,0,0,,kind of model and then another
Dialogue: 0,0:38:50.94,0:38:52.86,English,,0,0,0,,disadvantage is that you can't since
Dialogue: 0,0:38:52.86,0:38:54.57,English,,0,0,0,,it's it's really a sequential program
Dialogue: 0,0:38:54.57,0:38:57.06,English,,0,0,0,,right it's one C program you can't take
Dialogue: 0,0:38:57.06,0:38:59.67,English,,0,0,0,,advantage of multiple cores so the only
Dialogue: 0,0:38:59.67,0:39:01.50,English,,0,0,0,,way to get sort of more performance out
Dialogue: 0,0:39:01.50,0:39:03.78,English,,0,0,0,,of something an event-based servers just
Dialogue: 0,0:39:03.78,0:39:06.77,English,,0,0,0,,to replicate copies of that that server
Dialogue: 0,0:39:06.77,0:39:09.84,English,,0,0,0,,but you can't make an individual server
Dialogue: 0,0:39:09.84,0:39:15.93,English,,0,0,0,,go faster by using multiple cores okay
Dialogue: 0,0:39:15.93,0:39:19.14,English,,0,0,0,,the third approach is to use threads to
Dialogue: 0,0:39:19.14,0:39:23.64,English,,0,0,0,,create these concurrent flows it's very
Dialogue: 0,0:39:23.64,0:39:26.61,English,,0,0,0,,similar to processes but there are some
Dialogue: 0,0:39:26.61,0:39:29.49,English,,0,0,0,,important differences so let's look
Dialogue: 0,0:39:29.49,0:39:35.46,English,,0,0,0,,first at what we mean by a thread so
Dialogue: 0,0:39:35.46,0:39:37.35,English,,0,0,0,,let's go back I'm going to let's go back
Dialogue: 0,0:39:37.35,0:39:41.31,English,,0,0,0,,in and look at the traditional view of a
Dialogue: 0,0:39:41.31,0:39:43.58,English,,0,0,0,,process so we think of a process as some
Dialogue: 0,0:39:43.58,0:39:46.83,English,,0,0,0,,context that's data structures in the
Dialogue: 0,0:39:46.83,0:39:49.17,English,,0,0,0,,kernel okay data that the kernel keeps
Dialogue: 0,0:39:49.17,0:39:52.08,English,,0,0,0,,about that process as well as this
Dialogue: 0,0:39:52.08,0:39:55.23,English,,0,0,0,,private address space which contains a
Dialogue: 0,0:39:55.23,0:39:59.36,English,,0,0,0,,stack code and data and then the stack
Dialogue: 0,0:39:59.36,0:40:03.24,English,,0,0,0,,okay and then as part of the and then
Dialogue: 0,0:40:03.24,0:40:06.36,English,,0,0,0,,the the process context consists of
Dialogue: 0,0:40:06.36,0:40:07.89,English,,0,0,0,,context that's associated with the
Dialogue: 0,0:40:07.89,0:40:10.20,English,,0,0,0,,program like the the registers condition
Dialogue: 0,0:40:10.20,0:40:13.59,English,,0,0,0,,codes program counter stack pointer okay
Dialogue: 0,0:40:13.59,0:40:16.68,English,,0,0,0,,and then it contains kernel context
Dialogue: 0,0:40:16.68,0:40:19.11,English,,0,0,0,,which is information in the kernel that
Dialogue: 0,0:40:19.11,0:40:22.65,English,,0,0,0,,the the kernel needs to to implement
Dialogue: 0,0:40:22.65,0:40:26.22,English,,0,0,0,,this idea of a process okay so all of
Dialogue: 0,0:40:26.22,0:40:27.45,English,,0,0,0,,this data is actually stored in the
Dialogue: 0,0:40:27.45,0:40:31.40,English,,0,0,0,,kernel but some of the data is is
Dialogue: 0,0:40:31.40,0:40:33.93,English,,0,0,0,,directly associated with the program and
Dialogue: 0,0:40:33.93,0:40:37.83,English,,0,0,0,,other other other data is sort of
Dialogue: 0,0:40:37.83,0:40:40.98,English,,0,0,0,,support data that the kernel needs to to
Dialogue: 0,0:40:40.98,0:40:43.26,English,,0,0,0,,implement processes
Dialogue: 0,0:40:43.26,0:40:46.16,English,,0,0,0,,okay so let's just take this picture and
Dialogue: 0,0:40:46.16,0:40:48.69,English,,0,0,0,,we're just going to just move things
Dialogue: 0,0:40:48.69,0:40:55.38,English,,0,0,0,,around a little bit so what I've done is
Dialogue: 0,0:40:55.38,0:40:59.46,English,,0,0,0,,I've taken the stack off of the this
Dialogue: 0,0:40:59.46,0:41:03.81,English,,0,0,0,,virtual address space and sort of pulled
Dialogue: 0,0:41:03.81,0:41:07.19,English,,0,0,0,,it out along with its stack pointer and
Dialogue: 0,0:41:07.19,0:41:12.33,English,,0,0,0,,the the contacts that's associated with
Dialogue: 0,0:41:12.33,0:41:15.27,English,,0,0,0,,the program so the data registers the
Dialogue: 0,0:41:15.27,0:41:17.82,English,,0,0,0,,condition codes the stack pointer the
Dialogue: 0,0:41:17.82,0:41:19.80,English,,0,0,0,,program counter okay and I've just
Dialogue: 0,0:41:19.80,0:41:22.80,English,,0,0,0,,renamed a thread context instead of
Dialogue: 0,0:41:22.80,0:41:25.07,English,,0,0,0,,program context but it's it's the same
Dialogue: 0,0:41:25.07,0:41:28.38,English,,0,0,0,,it's the same thing and then I'm going
Dialogue: 0,0:41:28.38,0:41:29.85,English,,0,0,0,,to call this this whole thing the
Dialogue: 0,0:41:29.85,0:41:33.48,English,,0,0,0,,combination of the of a stack and this
Dialogue: 0,0:41:33.48,0:41:35.22,English,,0,0,0,,thread context I'm gonna call that a
Dialogue: 0,0:41:35.22,0:41:39.89,English,,0,0,0,,thread
Dialogue: 0,0:41:39.89,0:41:43.97,English,,0,0,0,,and then everything else remains the
Dialogue: 0,0:41:43.97,0:41:46.10,English,,0,0,0,,same it's it's we have we still have our
Dialogue: 0,0:41:46.10,0:41:49.07,English,,0,0,0,,code and data and we have the kernel
Dialogue: 0,0:41:49.07,0:41:52.33,English,,0,0,0,,context
Dialogue: 0,0:41:52.33,0:41:54.95,English,,0,0,0,,okay now by by doing this sort of
Dialogue: 0,0:41:54.95,0:41:57.20,English,,0,0,0,,refactoring and just moving things
Dialogue: 0,0:41:57.20,0:41:57.86,English,,0,0,0,,around
Dialogue: 0,0:41:57.86,0:42:01.61,English,,0,0,0,,I can now imagine so this stack isn't
Dialogue: 0,0:42:01.61,0:42:05.03,English,,0,0,0,,very much right it's so there's that
Dialogue: 0,0:42:05.03,0:42:08.03,English,,0,0,0,,there's this there's the stack space and
Dialogue: 0,0:42:08.03,0:42:09.71,English,,0,0,0,,then there's a little bit of data here
Dialogue: 0,0:42:09.71,0:42:11.42,English,,0,0,0,,in the form of some registers and some
Dialogue: 0,0:42:11.42,0:42:13.52,English,,0,0,0,,things to be stored but in this is a
Dialogue: 0,0:42:13.52,0:42:17.90,English,,0,0,0,,fairly small amount of data now when I
Dialogue: 0,0:42:17.90,0:42:23.48,English,,0,0,0,,really like an think about there being
Dialogue: 0,0:42:23.48,0:42:25.67,English,,0,0,0,,multiple threads associated with the
Dialogue: 0,0:42:25.67,0:42:29.27,English,,0,0,0,,same process if I if I just keep
Dialogue: 0,0:42:29.27,0:42:32.09,English,,0,0,0,,different set of data thread context for
Dialogue: 0,0:42:32.09,0:42:35.03,English,,0,0,0,,each thread and then a private a
Dialogue: 0,0:42:35.03,0:42:37.40,English,,0,0,0,,separate portion of the stack that's
Dialogue: 0,0:42:37.40,0:42:41.24,English,,0,0,0,,associated with that thread so now each
Dialogue: 0,0:42:41.24,0:42:45.73,English,,0,0,0,,thread shares the same code and data
Dialogue: 0,0:42:45.73,0:42:49.61,English,,0,0,0,,same virtual address space has the same
Dialogue: 0,0:42:49.61,0:42:52.10,English,,0,0,0,,kernel context okay the same i/o
Dialogue: 0,0:42:52.10,0:42:58.85,English,,0,0,0,,structures but now it has it has its its
Dialogue: 0,0:42:58.85,0:43:03.02,English,,0,0,0,,own separate individual stack okay so
Dialogue: 0,0:43:03.02,0:43:05.69,English,,0,0,0,,local local variables things that you
Dialogue: 0,0:43:05.69,0:43:07.04,English,,0,0,0,,would store on a stack now would be
Dialogue: 0,0:43:07.04,0:43:10.31,English,,0,0,0,,would be private sort of independent and
Dialogue: 0,0:43:10.31,0:43:13.37,English,,0,0,0,,it has its own set of its own program
Dialogue: 0,0:43:13.37,0:43:15.86,English,,0,0,0,,counter its own stack pointer its own
Dialogue: 0,0:43:15.86,0:43:21.98,English,,0,0,0,,set of registers and condition codes
Dialogue: 0,0:43:21.98,0:43:25.20,English,,0,0,0,,and then the one difference is now is
Dialogue: 0,0:43:25.20,0:43:27.36,English,,0,0,0,,that each thread instead of there's
Dialogue: 0,0:43:27.36,0:43:29.28,English,,0,0,0,,still a process ID for this process
Dialogue: 0,0:43:29.28,0:43:30.83,English,,0,0,0,,that's pointed part of the kernel
Dialogue: 0,0:43:30.83,0:43:33.87,English,,0,0,0,,context but each thread now has its own
Dialogue: 0,0:43:33.87,0:43:38.66,English,,0,0,0,,thread ID as part of its thread context
Dialogue: 0,0:43:38.66,0:43:44.73,English,,0,0,0,,okay so now the kernel can just treat
Dialogue: 0,0:43:44.73,0:43:46.92,English,,0,0,0,,each of these as separate flows right
Dialogue: 0,0:43:46.92,0:43:48.48,English,,0,0,0,,there's a separate so it's just like a
Dialogue: 0,0:43:48.48,0:43:50.70,English,,0,0,0,,process now the kernel can remember
Dialogue: 0,0:43:50.70,0:43:53.58,English,,0,0,0,,where the each thread has its own
Dialogue: 0,0:43:53.58,0:43:56.88,English,,0,0,0,,program counter and but they're running
Dialogue: 0,0:43:56.88,0:43:59.67,English,,0,0,0,,code out of the same that code the same
Dialogue: 0,0:43:59.67,0:44:02.01,English,,0,0,0,,code section in the in the virtual
Dialogue: 0,0:44:02.01,0:44:04.55,English,,0,0,0,,address space so the sharing code
Dialogue: 0,0:44:04.55,0:44:06.99,English,,0,0,0,,sharing data but they have their own
Dialogue: 0,0:44:06.99,0:44:09.69,English,,0,0,0,,program counter so they can the kernel
Dialogue: 0,0:44:09.69,0:44:11.97,English,,0,0,0,,can provide can create each of these
Dialogue: 0,0:44:11.97,0:44:14.49,English,,0,0,0,,threads as a as a separate flow of
Dialogue: 0,0:44:14.49,0:44:16.80,English,,0,0,0,,control that it then schedules just like
Dialogue: 0,0:44:16.80,0:44:19.35,English,,0,0,0,,it does of a process or in a similar way
Dialogue: 0,0:44:19.35,0:44:22.17,English,,0,0,0,,that does is a process but the
Dialogue: 0,0:44:22.17,0:44:25.80,English,,0,0,0,,difference is the reason the reason that
Dialogue: 0,0:44:25.80,0:44:28.68,English,,0,0,0,,for threads in the first place is that
Dialogue: 0,0:44:28.68,0:44:30.84,English,,0,0,0,,when the colonel wants to contact switch
Dialogue: 0,0:44:30.84,0:44:34.14,English,,0,0,0,,from one thread to another there's not
Dialogue: 0,0:44:34.14,0:44:37.43,English,,0,0,0,,that much information that has to be
Dialogue: 0,0:44:37.43,0:44:39.81,English,,0,0,0,,saved and restored it's just a small
Dialogue: 0,0:44:39.81,0:44:42.63,English,,0,0,0,,amount of data so the kernel has to save
Dialogue: 0,0:44:42.63,0:44:45.93,English,,0,0,0,,this the data thread one context in some
Dialogue: 0,0:44:45.93,0:44:47.52,English,,0,0,0,,data structure some way and then restore
Dialogue: 0,0:44:47.52,0:44:50.85,English,,0,0,0,,the context for thread two but we're
Dialogue: 0,0:44:50.85,0:44:52.77,English,,0,0,0,,talking about a very low overhead kind
Dialogue: 0,0:44:52.77,0:44:54.51,English,,0,0,0,,of operation right it doesn't have to
Dialogue: 0,0:44:54.51,0:44:57.03,English,,0,0,0,,mess around with page tables virtual
Dialogue: 0,0:44:57.03,0:44:59.37,English,,0,0,0,,address space or any other of the
Dialogue: 0,0:44:59.37,0:45:05.56,English,,0,0,0,,process context
Dialogue: 0,0:45:05.56,0:45:09.20,English,,0,0,0,,so so threads are luck kind of like
Dialogue: 0,0:45:09.20,0:45:11.84,English,,0,0,0,,processes it but they're different in
Dialogue: 0,0:45:11.84,0:45:12.92,English,,0,0,0,,the sense that they share the same
Dialogue: 0,0:45:12.92,0:45:17.48,English,,0,0,0,,virtual address space and unlike
Dialogue: 0,0:45:17.48,0:45:21.01,English,,0,0,0,,processes which are created by fork
Dialogue: 0,0:45:21.01,0:45:24.46,English,,0,0,0,,which creates a strict process hierarchy
Dialogue: 0,0:45:24.46,0:45:27.80,English,,0,0,0,,threads are just pools you can think of
Dialogue: 0,0:45:27.80,0:45:30.47,English,,0,0,0,,threads as pools of concurrent flows
Dialogue: 0,0:45:30.47,0:45:35.89,English,,0,0,0,,that access the same code and data and
Dialogue: 0,0:45:35.89,0:45:38.21,English,,0,0,0,,then the current the kernel is
Dialogue: 0,0:45:38.21,0:45:39.86,English,,0,0,0,,responsible for scheduling those flows
Dialogue: 0,0:45:39.86,0:45:41.93,English,,0,0,0,,and if in a way that so each flow gets
Dialogue: 0,0:45:41.93,0:45:47.24,English,,0,0,0,,gets time on the processor so much like
Dialogue: 0,0:45:47.24,0:45:51.02,English,,0,0,0,,much like processes much like concurrent
Dialogue: 0,0:45:51.02,0:45:53.90,English,,0,0,0,,processes we say the two threads are
Dialogue: 0,0:45:53.90,0:45:57.02,English,,0,0,0,,concurrent if their flows overlap in
Dialogue: 0,0:45:57.02,0:45:58.64,English,,0,0,0,,time otherwise they're sequential so
Dialogue: 0,0:45:58.64,0:46:01.04,English,,0,0,0,,this is the exact same example that I
Dialogue: 0,0:46:01.04,0:46:02.63,English,,0,0,0,,showed you when we looked at processes
Dialogue: 0,0:46:02.63,0:46:04.58,English,,0,0,0,,so here you have instead of three
Dialogue: 0,0:46:04.58,0:46:07.01,English,,0,0,0,,processes we have three threads running
Dialogue: 0,0:46:07.01,0:46:10.46,English,,0,0,0,,it within the same process
Dialogue: 0,0:46:10.46,0:46:13.25,English,,0,0,0,,thread a runs for a little bit and then
Dialogue: 0,0:46:13.25,0:46:16.76,English,,0,0,0,,the kernel just decides to walk it out
Dialogue: 0,0:46:16.76,0:46:20.12,English,,0,0,0,,and and run thread B so then thread B
Dialogue: 0,0:46:20.12,0:46:22.07,English,,0,0,0,,runs for a little bit and then the
Dialogue: 0,0:46:22.07,0:46:24.35,English,,0,0,0,,kernel decides to give thread C some
Dialogue: 0,0:46:24.35,0:46:27.95,English,,0,0,0,,time so it it saves thread B's context
Dialogue: 0,0:46:27.95,0:46:32.36,English,,0,0,0,,restores thread C's context and sets the
Dialogue: 0,0:46:32.36,0:46:37.01,English,,0,0,0,,PC to the the PC value and thread C's
Dialogue: 0,0:46:37.01,0:46:40.10,English,,0,0,0,,context and so C runs and then the
Dialogue: 0,0:46:40.10,0:46:42.38,English,,0,0,0,,kernel decides to give a some time again
Dialogue: 0,0:46:42.38,0:46:47.86,English,,0,0,0,,so then a runs some more so because
Dialogue: 0,0:46:47.86,0:46:50.69,English,,0,0,0,,thread a and B overlap in time they're
Dialogue: 0,0:46:50.69,0:46:54.92,English,,0,0,0,,running concurrently B and C don't
Dialogue: 0,0:46:54.92,0:46:56.93,English,,0,0,0,,overlap in time so they they're not
Dialogue: 0,0:46:56.93,0:46:59.72,English,,0,0,0,,running concurrently but a and C are
Dialogue: 0,0:46:59.72,0:47:03.64,English,,0,0,0,,concurrent because they overlap in time
Dialogue: 0,0:47:03.64,0:47:07.88,English,,0,0,0,,and so you can you also have the option
Dialogue: 0,0:47:07.88,0:47:10.19,English,,0,0,0,,if there's multi multiple cores than
Dialogue: 0,0:47:10.19,0:47:12.05,English,,0,0,0,,multiple threat a thread can run on each
Dialogue: 0,0:47:12.05,0:47:13.82,English,,0,0,0,,core so then you can have true
Dialogue: 0,0:47:13.82,0:47:14.94,English,,0,0,0,,parallelism
Dialogue: 0,0:47:14.94,0:47:21.05,English,,0,0,0,,okay
Dialogue: 0,0:47:21.05,0:47:24.65,English,,0,0,0,,okay so like I said threads and
Dialogue: 0,0:47:24.65,0:47:29.33,English,,0,0,0,,processes are similar ideas but in the
Dialogue: 0,0:47:29.33,0:47:33.97,English,,0,0,0,,sense that they they each stage kinase
Dialogue: 0,0:47:33.97,0:47:36.74,English,,0,0,0,,and process corresponds to some kind of
Dialogue: 0,0:47:36.74,0:47:40.52,English,,0,0,0,,logical flow and they can run
Dialogue: 0,0:47:40.52,0:47:42.91,English,,0,0,0,,concurrently with with other flows and
Dialogue: 0,0:47:42.91,0:47:45.98,English,,0,0,0,,each is scheduled and contact switched
Dialogue: 0,0:47:45.98,0:47:49.73,English,,0,0,0,,by the kernel okay but they're different
Dialogue: 0,0:47:49.73,0:47:52.51,English,,0,0,0,,because threads share all code and data
Dialogue: 0,0:47:52.51,0:47:57.20,English,,0,0,0,,except their local stacks okay and in
Dialogue: 0,0:47:57.20,0:48:00.05,English,,0,0,0,,fact those local stacks although they're
Dialogue: 0,0:48:00.05,0:48:03.02,English,,0,0,0,,each thread has its own it's it's really
Dialogue: 0,0:48:03.02,0:48:08.36,English,,0,0,0,,just sharing the same stack and so it's
Dialogue: 0,0:48:08.36,0:48:09.86,English,,0,0,0,,really the same portion of the virtual
Dialogue: 0,0:48:09.86,0:48:12.26,English,,0,0,0,,address space it's just that each each
Dialogue: 0,0:48:12.26,0:48:14.99,English,,0,0,0,,thread is assigned its own part of that
Dialogue: 0,0:48:14.99,0:48:17.64,English,,0,0,0,,stack okay so even though threads have
Dialogue: 0,0:48:17.64,0:48:21.17,English,,0,0,0,,their own individual stacks since it's
Dialogue: 0,0:48:21.17,0:48:22.55,English,,0,0,0,,all part of the same virtual address
Dialogue: 0,0:48:22.55,0:48:25.43,English,,0,0,0,,space a thread can access the the stack
Dialogue: 0,0:48:25.43,0:48:28.14,English,,0,0,0,,of any other thread if it's and that's
Dialogue: 0,0:48:28.14,0:48:29.84,English,,0,0,0,,not a good thing to do but it's possible
Dialogue: 0,0:48:29.84,0:48:32.51,English,,0,0,0,,okay
Dialogue: 0,0:48:32.51,0:48:34.85,English,,0,0,0,,so processes don't share any of the
Dialogue: 0,0:48:34.85,0:48:37.07,English,,0,0,0,,state right they they have their own
Dialogue: 0,0:48:37.07,0:48:39.65,English,,0,0,0,,private address spaces and threads are
Dialogue: 0,0:48:39.65,0:48:46.40,English,,0,0,0,,less expensive than processes the it's
Dialogue: 0,0:48:46.40,0:48:48.35,English,,0,0,0,,it's cheaper to create them and the main
Dialogue: 0,0:48:48.35,0:48:50.42,English,,0,0,0,,reason is that there's just less context
Dialogue: 0,0:48:50.42,0:48:52.14,English,,0,0,0,,associated with the thread than there is
Dialogue: 0,0:48:52.14,0:48:55.04,English,,0,0,0,,as a process and so on our system when
Dialogue: 0,0:48:55.04,0:48:59.36,English,,0,0,0,,we measure a bunch of we just create in
Dialogue: 0,0:48:59.36,0:49:02.90,English,,0,0,0,,and wait for a bunch of creative process
Dialogue: 0,0:49:02.90,0:49:04.22,English,,0,0,0,,wait for word process over and over
Dialogue: 0,0:49:04.22,0:49:07.14,English,,0,0,0,,again and measure the time turns out to
Dialogue: 0,0:49:07.14,0:49:09.63,English,,0,0,0,,be about twenty thousand cycles to
Dialogue: 0,0:49:09.63,0:49:12.68,English,,0,0,0,,create and reap a process about ten
Dialogue: 0,0:49:12.68,0:49:14.96,English,,0,0,0,,thousand cycles to create an reapeth
Dialogue: 0,0:49:14.96,0:49:19.69,English,,0,0,0,,thread so that the kernel provides
Dialogue: 0,0:49:19.69,0:49:22.46,English,,0,0,0,,threads to us using an interface called
Dialogue: 0,0:49:22.46,0:49:25.94,English,,0,0,0,,the P threads POSIX threads so this is a
Dialogue: 0,0:49:25.94,0:49:29.72,English,,0,0,0,,fairly recent standard that all all
Dialogue: 0,0:49:29.72,0:49:31.39,English,,0,0,0,,Linux
Dialogue: 0,0:49:31.39,0:49:36.13,English,,0,0,0,,UNIX systems and and Windows Macintosh
Dialogue: 0,0:49:36.13,0:49:39.42,English,,0,0,0,,so every this is a sort of standard
Dialogue: 0,0:49:39.42,0:49:46.21,English,,0,0,0,,POSIX standard for for manipulating
Dialogue: 0,0:49:46.21,0:49:48.70,English,,0,0,0,,threads and so you can do things like
Dialogue: 0,0:49:48.70,0:49:51.91,English,,0,0,0,,create and reap threads so there's this
Dialogue: 0,0:49:51.91,0:49:55.05,English,,0,0,0,,is sort of sort of like fork and this is
Dialogue: 0,0:49:55.05,0:49:58.24,English,,0,0,0,,sort of like weight but not not quite
Dialogue: 0,0:49:58.24,0:50:02.76,English,,0,0,0,,because it doesn't create there's no
Dialogue: 0,0:50:02.76,0:50:05.04,English,,0,0,0,,hierarchy associated with these you can
Dialogue: 0,0:50:05.04,0:50:07.69,English,,0,0,0,,you could just like get pit you can
Dialogue: 0,0:50:07.69,0:50:11.98,English,,0,0,0,,retain there's a function to to get your
Dialogue: 0,0:50:11.98,0:50:15.13,English,,0,0,0,,thread ID you can kill threads so one
Dialogue: 0,0:50:15.13,0:50:18.91,English,,0,0,0,,thread can kill another thread a thread
Dialogue: 0,0:50:18.91,0:50:21.06,English,,0,0,0,,there's a there's a function to exit a
Dialogue: 0,0:50:21.06,0:50:25.66,English,,0,0,0,,thread the normal exit system call
Dialogue: 0,0:50:25.66,0:50:29.07,English,,0,0,0,,terminates all the threads and return is
Dialogue: 0,0:50:29.07,0:50:31.53,English,,0,0,0,,similar to P thread exit in the sense
Dialogue: 0,0:50:31.53,0:50:33.36,English,,0,0,0,,that just terminates the current thread
Dialogue: 0,0:50:33.36,0:50:36.78,English,,0,0,0,,the thread that that calls it and then
Dialogue: 0,0:50:36.78,0:50:38.98,English,,0,0,0,,there's ways to access synchronize
Dialogue: 0,0:50:38.98,0:50:41.14,English,,0,0,0,,access to shared variables which which
Dialogue: 0,0:50:41.14,0:50:46.38,English,,0,0,0,,we'll look at on Thursday more detail
Dialogue: 0,0:50:46.38,0:50:49.63,English,,0,0,0,,okay so here's the the pthreads hello
Dialogue: 0,0:50:49.63,0:50:53.41,English,,0,0,0,,world program you know your K in our
Dialogue: 0,0:50:53.41,0:50:56.35,English,,0,0,0,,book the the C the C reference manual
Dialogue: 0,0:50:56.35,0:51:00.01,English,,0,0,0,,the the very first the very first thing
Dialogue: 0,0:51:00.01,0:51:01.39,English,,0,0,0,,that it does is it shows you how to
Dialogue: 0,0:51:01.39,0:51:03.28,English,,0,0,0,,write the simplest possible C program
Dialogue: 0,0:51:03.28,0:51:05.92,English,,0,0,0,,called so the famous hello world program
Dialogue: 0,0:51:05.92,0:51:07.99,English,,0,0,0,,so that goes all the way back to like
Dialogue: 0,0:51:07.99,0:51:10.54,English,,0,0,0,,1978 when K in our book was first
Dialogue: 0,0:51:10.54,0:51:13.66,English,,0,0,0,,written but that's that's caught on and
Dialogue: 0,0:51:13.66,0:51:17.65,English,,0,0,0,,and whenever we like learn a new
Dialogue: 0,0:51:17.65,0:51:20.05,English,,0,0,0,,language or we learn a new concept we
Dialogue: 0,0:51:20.05,0:51:21.82,English,,0,0,0,,always write the hello world program for
Dialogue: 0,0:51:21.82,0:51:24.07,English,,0,0,0,,that concept so the hello world program
Dialogue: 0,0:51:24.07,0:51:27.88,English,,0,0,0,,for threads this is this is a simplest
Dialogue: 0,0:51:27.88,0:51:29.74,English,,0,0,0,,threads program that I can think of so I
Dialogue: 0,0:51:29.74,0:51:31.96,English,,0,0,0,,call it the hello world program for
Dialogue: 0,0:51:31.96,0:51:37.51,English,,0,0,0,,threads so this program defines a
Dialogue: 0,0:51:37.51,0:51:42.40,English,,0,0,0,,function so court by in POSIX a thread
Dialogue: 0,0:51:42.40,0:51:45.79,English,,0,0,0,,is actually executed by executing the
Dialogue: 0,0:51:45.79,0:51:48.16,English,,0,0,0,,the code and a function called the
Dialogue: 0,0:51:48.16,0:51:54.12,English,,0,0,0,,thread routine okay and POSIX imposes
Dialogue: 0,0:51:54.12,0:51:56.56,English,,0,0,0,,this thread routine takes a generic
Dialogue: 0,0:51:56.56,0:51:58.18,English,,0,0,0,,pointer as an argument
Dialogue: 0,0:51:58.18,0:52:00.82,English,,0,0,0,,optional generic pointer and it returns
Dialogue: 0,0:52:00.82,0:52:03.52,English,,0,0,0,,a generic pointer okay so anytime if you
Dialogue: 0,0:52:03.52,0:52:05.11,English,,0,0,0,,want to pass anything to a thread you
Dialogue: 0,0:52:05.11,0:52:08.80,English,,0,0,0,,somehow got to pack up all that data
Dialogue: 0,0:52:08.80,0:52:12.07,English,,0,0,0,,into a single object then you can take
Dialogue: 0,0:52:12.07,0:52:15.88,English,,0,0,0,,an address up but it's it you can see
Dialogue: 0,0:52:15.88,0:52:20.66,English,,0,0,0,,that this is extremely general-purpose
Dialogue: 0,0:52:20.66,0:52:25.31,English,,0,0,0,,so our hello world program creates a
Dialogue: 0,0:52:25.31,0:52:29.93,English,,0,0,0,,thread by calling pthread create and we
Dialogue: 0,0:52:29.93,0:52:31.85,English,,0,0,0,,say instead of a child we call this a
Dialogue: 0,0:52:31.85,0:52:35.39,English,,0,0,0,,peer thread okay so that there's no
Dialogue: 0,0:52:35.39,0:52:37.93,English,,0,0,0,,parent-child relationship any any
Dialogue: 0,0:52:37.93,0:52:41.09,English,,0,0,0,,threads can threads can reap other
Dialogue: 0,0:52:41.09,0:52:44.90,English,,0,0,0,,threads whether they created those
Dialogue: 0,0:52:44.90,0:52:47.06,English,,0,0,0,,threads or not okay so you don't have
Dialogue: 0,0:52:47.06,0:52:51.08,English,,0,0,0,,the strict parent-child hierarchy Pizza
Dialogue: 0,0:52:51.08,0:52:57.23,English,,0,0,0,,create creates a thread that executes
Dialogue: 0,0:52:57.23,0:52:59.30,English,,0,0,0,,the thread routine in this third
Dialogue: 0,0:52:59.30,0:53:03.74,English,,0,0,0,,argument and returns the thread idea of
Dialogue: 0,0:53:03.74,0:53:06.26,English,,0,0,0,,that thread in the address and the
Dialogue: 0,0:53:06.26,0:53:10.12,English,,0,0,0,,integer pointed at by the first argument
Dialogue: 0,0:53:10.12,0:53:15.71,English,,0,0,0,,the second argument is set up there's
Dialogue: 0,0:53:15.71,0:53:17.60,English,,0,0,0,,there's ways to set attributes of
Dialogue: 0,0:53:17.60,0:53:21.44,English,,0,0,0,,threads that are beyond the scope of
Dialogue: 0,0:53:21.44,0:53:23.99,English,,0,0,0,,this course and will always just have
Dialogue: 0,0:53:23.99,0:53:29.27,English,,0,0,0,,those no and then that this fourth
Dialogue: 0,0:53:29.27,0:53:31.70,English,,0,0,0,,argument is the optional argument that
Dialogue: 0,0:53:31.70,0:53:33.20,English,,0,0,0,,you want to pass to your thread routine
Dialogue: 0,0:53:33.20,0:53:36.20,English,,0,0,0,,okay so in this case we're saying call
Dialogue: 0,0:53:36.20,0:53:39.26,English,,0,0,0,,the thread routine that's that's called
Dialogue: 0,0:53:39.26,0:53:44.60,English,,0,0,0,,thread with no arguments and then our
Dialogue: 0,0:53:44.60,0:53:46.76,English,,0,0,0,,thread routine just prints out hello
Dialogue: 0,0:53:46.76,0:53:49.97,English,,0,0,0,,world and then it returns in this case
Dialogue: 0,0:53:49.97,0:53:51.71,English,,0,0,0,,it doesn't return anything so it returns
Dialogue: 0,0:53:51.71,0:53:54.23,English,,0,0,0,,no but if we wanted to return something
Dialogue: 0,0:53:54.23,0:53:59.12,English,,0,0,0,,to the to the calling program we could
Dialogue: 0,0:53:59.12,0:54:01.07,English,,0,0,0,,have returned something a pointer to
Dialogue: 0,0:54:01.07,0:54:10.55,English,,0,0,0,,some generic object okay
Dialogue: 0,0:54:10.55,0:54:12.90,English,,0,0,0,,okay so the thread ID the thread
Dialogue: 0,0:54:12.90,0:54:14.46,English,,0,0,0,,attributes are null that the thread
Dialogue: 0,0:54:14.46,0:54:16.86,English,,0,0,0,,routine the thread arguments are void
Dialogue: 0,0:54:16.86,0:54:23.19,English,,0,0,0,,star P and the return value is a void
Dialogue: 0,0:54:23.19,0:54:25.41,English,,0,0,0,,double so it's a pointer to the pointer
Dialogue: 0,0:54:25.41,0:54:29.61,English,,0,0,0,,that you want to return okay all right
Dialogue: 0,0:54:29.61,0:54:30.96,English,,0,0,0,,so let's look at what happens when we
Dialogue: 0,0:54:30.96,0:54:34.40,English,,0,0,0,,execute hello world so the main thread
Dialogue: 0,0:54:34.40,0:54:39.06,English,,0,0,0,,runs for a while then it calls pthread
Dialogue: 0,0:54:39.06,0:54:43.44,English,,0,0,0,,create which creates the pure thread
Dialogue: 0,0:54:43.44,0:54:45.39,English,,0,0,0,,which now is a concurrent flow that's
Dialogue: 0,0:54:45.39,0:54:48.41,English,,0,0,0,,running once once the pthread create
Dialogue: 0,0:54:48.41,0:54:51.81,English,,0,0,0,,returns then we're running two
Dialogue: 0,0:54:51.81,0:54:53.37,English,,0,0,0,,concurrent flows or running the main
Dialogue: 0,0:54:53.37,0:54:56.76,English,,0,0,0,,thread and we're running the the peer
Dialogue: 0,0:54:56.76,0:55:01.59,English,,0,0,0,,thread
Dialogue: 0,0:55:01.59,0:55:03.45,English,,0,0,0,,and so in this case our hello world
Dialogue: 0,0:55:03.45,0:55:07.02,English,,0,0,0,,waits for the peer thread to finish by
Dialogue: 0,0:55:07.02,0:55:11.82,English,,0,0,0,,calling P thread join the peer-to-peer
Dialogue: 0,0:55:11.82,0:55:15.93,English,,0,0,0,,thread after the calls it's printf it
Dialogue: 0,0:55:15.93,0:55:20.24,English,,0,0,0,,returns no which terminates the thread
Dialogue: 0,0:55:20.24,0:55:24.35,English,,0,0,0,,at that point the P thread join returns
Dialogue: 0,0:55:24.35,0:55:31.47,English,,0,0,0,,and the main thread continues okay so
Dialogue: 0,0:55:31.47,0:55:36.39,English,,0,0,0,,using using these create this create
Dialogue: 0,0:55:36.39,0:55:38.37,English,,0,0,0,,function how would we write a thread
Dialogue: 0,0:55:38.37,0:55:41.49,English,,0,0,0,,based concurrent echo server and again
Dialogue: 0,0:55:41.49,0:55:43.05,English,,0,0,0,,it's very similar to the way we did it
Dialogue: 0,0:55:43.05,0:55:50.34,English,,0,0,0,,with the process based design so we call
Dialogue: 0,0:55:50.34,0:55:52.98,English,,0,0,0,,we acquire a listening descriptor by
Dialogue: 0,0:55:52.98,0:55:56.06,English,,0,0,0,,calling our au s-- open listen FD
Dialogue: 0,0:55:56.06,0:55:59.76,English,,0,0,0,,function just as before and then inside
Dialogue: 0,0:55:59.76,0:56:05.31,English,,0,0,0,,this infinite server loop we we get the
Dialogue: 0,0:56:05.31,0:56:09.27,English,,0,0,0,,size of the we get the size of the
Dialogue: 0,0:56:09.27,0:56:13.53,English,,0,0,0,,client adder struct so which is which is
Dialogue: 0,0:56:13.53,0:56:16.74,English,,0,0,0,,going to be a large enough to fit any
Dialogue: 0,0:56:16.74,0:56:22.05,English,,0,0,0,,address and then we we malloc space for
Dialogue: 0,0:56:22.05,0:56:23.73,English,,0,0,0,,the connected file descriptor so we're
Dialogue: 0,0:56:23.73,0:56:27.98,English,,0,0,0,,making a one integer sized portion of
Dialogue: 0,0:56:27.98,0:56:30.72,English,,0,0,0,,dynamic storage for this connected
Dialogue: 0,0:56:30.72,0:56:33.39,English,,0,0,0,,descriptor that were that we're going to
Dialogue: 0,0:56:33.39,0:56:36.83,English,,0,0,0,,get back from accept and we're going to
Dialogue: 0,0:56:36.83,0:56:39.24,English,,0,0,0,,this is actually really important to
Dialogue: 0,0:56:39.24,0:56:42.09,English,,0,0,0,,avoid a nasty race condition they'll
Dialogue: 0,0:56:42.09,0:56:46.14,English,,0,0,0,,show you in a second so now we call
Dialogue: 0,0:56:46.14,0:56:50.43,English,,0,0,0,,except with our listening descriptor and
Dialogue: 0,0:56:50.43,0:56:52.02,English,,0,0,0,,client address and client length just
Dialogue: 0,0:56:52.02,0:56:56.70,English,,0,0,0,,like before and except returns the
Dialogue: 0,0:56:56.70,0:56:59.70,English,,0,0,0,,connected descriptor and then we
Dialogue: 0,0:56:59.70,0:57:03.09,English,,0,0,0,,dereference this connected descriptor
Dialogue: 0,0:57:03.09,0:57:06.45,English,,0,0,0,,pointer and so and store that the value
Dialogue: 0,0:57:06.45,0:57:08.52,English,,0,0,0,,returned by except in this in this
Dialogue: 0,0:57:08.52,0:57:10.79,English,,0,0,0,,location in the heap
Dialogue: 0,0:57:10.79,0:57:15.32,English,,0,0,0,,and then we call pthread create by
Dialogue: 0,0:57:15.32,0:57:17.03,English,,0,0,0,,giving it the name of our thread routine
Dialogue: 0,0:57:17.03,0:57:19.15,English,,0,0,0,,which in this case is just simply a
Dialogue: 0,0:57:19.15,0:57:21.71,English,,0,0,0,,function we defined in our program
Dialogue: 0,0:57:21.71,0:57:25.73,English,,0,0,0,,called thread and the pointer to the
Dialogue: 0,0:57:25.73,0:57:29.99,English,,0,0,0,,connected file descriptor okay now our
Dialogue: 0,0:57:29.99,0:57:32.45,English,,0,0,0,,client which our client which our thread
Dialogue: 0,0:57:32.45,0:57:33.98,English,,0,0,0,,routine then will use to interact with
Dialogue: 0,0:57:33.98,0:57:39.10,English,,0,0,0,,the client okay so the thread routine
Dialogue: 0,0:57:39.10,0:57:42.38,English,,0,0,0,,dereferences the argument a member is a
Dialogue: 0,0:57:42.38,0:57:44.24,English,,0,0,0,,pointer to a connected file descriptor
Dialogue: 0,0:57:44.24,0:57:48.05,English,,0,0,0,,so it dereferences that pointer to get
Dialogue: 0,0:57:48.05,0:57:50.87,English,,0,0,0,,the to get the actual integer connected
Dialogue: 0,0:57:50.87,0:57:56.03,English,,0,0,0,,descriptor and then it detaches the
Dialogue: 0,0:57:56.03,0:58:02.84,English,,0,0,0,,thread so by default threads Threat
Dialogue: 0,0:58:02.84,0:58:04.94,English,,0,0,0,,threads run an independent and attached
Dialogue: 0,0:58:04.94,0:58:08.03,English,,0,0,0,,mode so they can be you know they can be
Dialogue: 0,0:58:08.03,0:58:09.98,English,,0,0,0,,joined by other threads and they can be
Dialogue: 0,0:58:09.98,0:58:15.95,English,,0,0,0,,killed by other threads but by default
Dialogue: 0,0:58:15.95,0:58:18.35,English,,0,0,0,,if it's similar
Dialogue: 0,0:58:18.35,0:58:20.63,English,,0,0,0,,when threads are running in sort of
Dialogue: 0,0:58:20.63,0:58:32.24,English,,0,0,0,,unattached mode detail or undetected by
Dialogue: 0,0:58:32.24,0:58:35.30,English,,0,0,0,,a join function to to acquire those
Dialogue: 0,0:58:35.30,0:58:40.70,English,,0,0,0,,resources but if we detach a thread then
Dialogue: 0,0:58:40.70,0:58:42.50,English,,0,0,0,,it can't be it can't be joined by any
Dialogue: 0,0:58:42.50,0:58:44.15,English,,0,0,0,,threads but when it dies the kernel will
Dialogue: 0,0:58:44.15,0:58:50.06,English,,0,0,0,,automatically restore the the resources
Dialogue: 0,0:58:50.06,0:58:52.40,English,,0,0,0,,associated with that thread so in this
Dialogue: 0,0:58:52.40,0:58:54.29,English,,0,0,0,,case we're going to just detach this
Dialogue: 0,0:58:54.29,0:58:56.74,English,,0,0,0,,thread so we're not to worry about
Dialogue: 0,0:58:56.74,0:59:01.79,English,,0,0,0,,reaping it when it when it finishes and
Dialogue: 0,0:59:01.79,0:59:04.21,English,,0,0,0,,then we're going to free this this
Dialogue: 0,0:59:04.21,0:59:06.53,English,,0,0,0,,memory that was malloc so this is
Dialogue: 0,0:59:06.53,0:59:08.09,English,,0,0,0,,important we have to free this memory
Dialogue: 0,0:59:08.09,0:59:10.63,English,,0,0,0,,that was malloc by the the main thread
Dialogue: 0,0:59:10.63,0:59:16.07,English,,0,0,0,,in order to avoid a memory leak and then
Dialogue: 0,0:59:16.07,0:59:18.47,English,,0,0,0,,we we call our echo function so we
Dialogue: 0,0:59:18.47,0:59:20.87,English,,0,0,0,,interact with the the echo client until
Dialogue: 0,0:59:20.87,0:59:23.48,English,,0,0,0,,the echo clients finished
Dialogue: 0,0:59:23.48,0:59:25.82,English,,0,0,0,,and then we close this descriptor again
Dialogue: 0,0:59:25.82,0:59:34.99,English,,0,0,0,,to avoid a potentially fatal memory leak
Dialogue: 0,0:59:34.99,0:59:37.79,English,,0,0,0,,so this thread based education model is
Dialogue: 0,0:59:37.79,0:59:40.01,English,,0,0,0,,very similar to the execution model that
Dialogue: 0,0:59:40.01,0:59:43.31,English,,0,0,0,,we saw with with processes so we have a
Dialogue: 0,0:59:43.31,0:59:46.40,English,,0,0,0,,list of a main thread that's listening
Dialogue: 0,0:59:46.40,0:59:48.44,English,,0,0,0,,for connection requests they were
Dialogue: 0,0:59:48.44,0:59:50.56,English,,0,0,0,,waiting for connection requests via
Dialogue: 0,0:59:50.56,0:59:56.24,English,,0,0,0,,accept and then we have for each client
Dialogue: 0,0:59:56.24,0:59:58.46,English,,0,0,0,,we have a peer thread that interacts
Dialogue: 0,0:59:58.46,1:00:01.40,English,,0,0,0,,with that client using the connected
Dialogue: 0,1:00:01.40,1:00:03.32,English,,0,0,0,,descriptor that was passed in when we
Dialogue: 0,1:00:03.32,1:00:07.90,English,,0,0,0,,created the thread and then each thread
Dialogue: 0,1:00:07.90,1:00:10.82,English,,0,0,0,,has its own since it has its own stack
Dialogue: 0,1:00:10.82,1:00:14.96,English,,0,0,0,,it has it has separate space for its
Dialogue: 0,1:00:14.96,1:00:18.01,English,,0,0,0,,local variables and this is really the
Dialogue: 0,1:00:18.01,1:00:20.42,English,,0,0,0,,powerful thing about threads now we can
Dialogue: 0,1:00:20.42,1:00:24.11,English,,0,0,0,,with these things they by declaring
Dialogue: 0,1:00:24.11,1:00:28.52,English,,0,0,0,,these local variables we can we can
Dialogue: 0,1:00:28.52,1:00:30.56,English,,0,0,0,,create threads that won't interact with
Dialogue: 0,1:00:30.56,1:00:32.45,English,,0,0,0,,each other it won't and can run
Dialogue: 0,1:00:32.45,1:00:36.99,English,,0,0,0,,independently yes
Dialogue: 0,1:00:36.99,1:00:42.26,English,,0,0,0,,drunky cash
Dialogue: 0,1:00:42.26,1:00:44.69,English,,0,0,0,,I guess yeah the question is is there
Dialogue: 0,1:00:44.69,1:00:45.89,English,,0,0,0,,any time you wouldn't want to run
Dialogue: 0,1:00:45.89,1:00:50.09,English,,0,0,0,,detached so when you run detached you
Dialogue: 0,1:00:50.09,1:00:52.25,English,,0,0,0,,give up the the power to kill other
Dialogue: 0,1:00:52.25,1:00:56.15,English,,0,0,0,,threads so so I don't know if you it's
Dialogue: 0,1:00:56.15,1:00:57.62,English,,0,0,0,,hard to it's hard to come up with good
Dialogue: 0,1:00:57.62,1:01:00.83,English,,0,0,0,,example right that but if you wanted the
Dialogue: 0,1:01:00.83,1:01:03.47,English,,0,0,0,,ability to to be able to terminate other
Dialogue: 0,1:01:03.47,1:01:07.25,English,,0,0,0,,threads you know maybe if you had maybe
Dialogue: 0,1:01:07.25,1:01:08.87,English,,0,0,0,,if you if you were running a pool of
Dialogue: 0,1:01:08.87,1:01:15.71,English,,0,0,0,,like worker threads and at some point at
Dialogue: 0,1:01:15.71,1:01:18.80,English,,0,0,0,,some point if I mean I guess you can
Dialogue: 0,1:01:18.80,1:01:21.05,English,,0,0,0,,imagine a scenario where suppose you're
Dialogue: 0,1:01:21.05,1:01:22.52,English,,0,0,0,,running a pool of worker threads you
Dialogue: 0,1:01:22.52,1:01:24.05,English,,0,0,0,,give them all jobs to do the first one
Dialogue: 0,1:01:24.05,1:01:26.66,English,,0,0,0,,that finishes you take the result and
Dialogue: 0,1:01:26.66,1:01:28.13,English,,0,0,0,,you don't need the results from the
Dialogue: 0,1:01:28.13,1:01:30.32,English,,0,0,0,,other threads so you might you might
Dialogue: 0,1:01:30.32,1:01:34.15,English,,0,0,0,,just want to kill those threads but it's
Dialogue: 0,1:01:34.15,1:01:37.25,English,,0,0,0,,yeah it's hard it's hard to come up with
Dialogue: 0,1:01:37.25,1:01:46.36,English,,0,0,0,,a really compelling reason
Dialogue: 0,1:01:46.36,1:01:48.44,English,,0,0,0,,okay so there's a few things to think
Dialogue: 0,1:01:48.44,1:01:49.82,English,,0,0,0,,about when you're when you're writing
Dialogue: 0,1:01:49.82,1:01:51.62,English,,0,0,0,,thread based servers so the first is
Dialogue: 0,1:01:51.62,1:01:54.11,English,,0,0,0,,that yet you need to run detach to avoid
Dialogue: 0,1:01:54.11,1:01:58.28,English,,0,0,0,,potential memory leaks I'm sorry I
Dialogue: 0,1:01:58.28,1:02:00.14,English,,0,0,0,,forgot this word so it the opposite of
Dialogue: 0,1:02:00.14,1:02:03.14,English,,0,0,0,,detached is joinable and so joinable
Dialogue: 0,1:02:03.14,1:02:04.97,English,,0,0,0,,threads like I mentioned can be reaped
Dialogue: 0,1:02:04.97,1:02:08.33,English,,0,0,0,,and killed by other threads detached
Dialogue: 0,1:02:08.33,1:02:11.24,English,,0,0,0,,threads cannot and their resources are
Dialogue: 0,1:02:11.24,1:02:14.96,English,,0,0,0,,automatically claimed on termination so
Dialogue: 0,1:02:14.96,1:02:17.15,English,,0,0,0,,the default states joinable and you have
Dialogue: 0,1:02:17.15,1:02:19.82,English,,0,0,0,,to use this detach function call to make
Dialogue: 0,1:02:19.82,1:02:24.74,English,,0,0,0,,to make the thread detached the biggest
Dialogue: 0,1:02:24.74,1:02:26.33,English,,0,0,0,,the biggest issue with threads though
Dialogue: 0,1:02:26.33,1:02:28.43,English,,0,0,0,,like the beautiful thing about threads
Dialogue: 0,1:02:28.43,1:02:29.99,English,,0,0,0,,is that you're sharing the same global
Dialogue: 0,1:02:29.99,1:02:33.05,English,,0,0,0,,address space so it's very easy to share
Dialogue: 0,1:02:33.05,1:02:34.64,English,,0,0,0,,data structures you know if you had
Dialogue: 0,1:02:34.64,1:02:36.92,English,,0,0,0,,multiple threads if you had a web server
Dialogue: 0,1:02:36.92,1:02:38.96,English,,0,0,0,,a concurrent web server that was built
Dialogue: 0,1:02:38.96,1:02:41.39,English,,0,0,0,,with multiple threads be very easy to
Dialogue: 0,1:02:41.39,1:02:44.15,English,,0,0,0,,implement a cache that all the threads
Dialogue: 0,1:02:44.15,1:02:45.98,English,,0,0,0,,could could use right because they're
Dialogue: 0,1:02:45.98,1:02:47.60,English,,0,0,0,,all sharing that same virtual address
Dialogue: 0,1:02:47.60,1:02:51.02,English,,0,0,0,,space but the thing that makes threads
Dialogue: 0,1:02:51.02,1:02:53.96,English,,0,0,0,,so nice this ease the ease with which
Dialogue: 0,1:02:53.96,1:02:56.72,English,,0,0,0,,you can share resources is also the
Dialogue: 0,1:02:56.72,1:02:58.16,English,,0,0,0,,thing that makes them very tricky to
Dialogue: 0,1:02:58.16,1:03:00.32,English,,0,0,0,,deal with so as soon as just like we saw
Dialogue: 0,1:03:00.32,1:03:05.54,English,,0,0,0,,with our shell lab handlers you know as
Dialogue: 0,1:03:05.54,1:03:06.77,English,,0,0,0,,soon as you're as soon as you have
Dialogue: 0,1:03:06.77,1:03:08.24,English,,0,0,0,,multiple flows accessing shared
Dialogue: 0,1:03:08.24,1:03:10.61,English,,0,0,0,,resources you have to be very careful
Dialogue: 0,1:03:10.61,1:03:15.29,English,,0,0,0,,it's very easy to make mistakes and it's
Dialogue: 0,1:03:15.29,1:03:18.50,English,,0,0,0,,it's very it's very easy to or it's
Dialogue: 0,1:03:18.50,1:03:21.47,English,,0,0,0,,possible to to share resources in
Dialogue: 0,1:03:21.47,1:03:24.98,English,,0,0,0,,unexpected and unintended ways for
Dialogue: 0,1:03:24.98,1:03:29.27,English,,0,0,0,,example if if one if one thread passes
Dialogue: 0,1:03:29.27,1:03:32.72,English,,0,0,0,,the address of a local variable on its
Dialogue: 0,1:03:32.72,1:03:35.18,English,,0,0,0,,stack to another thread then now that
Dialogue: 0,1:03:35.18,1:03:38.69,English,,0,0,0,,that the called thread now has access to
Dialogue: 0,1:03:38.69,1:03:40.52,English,,0,0,0,,the callers thread and there's nothing
Dialogue: 0,1:03:40.52,1:03:44.84,English,,0,0,0,,to prevent that that that called thread
Dialogue: 0,1:03:44.84,1:03:48.20,English,,0,0,0,,from manipulating local variables on the
Dialogue: 0,1:03:48.20,1:03:50.39,English,,0,0,0,,caller stack you know that would be a
Dialogue: 0,1:03:50.39,1:03:53.12,English,,0,0,0,,very bad thing to do but it's possible
Dialogue: 0,1:03:53.12,1:03:55.85,English,,0,0,0,,you might you might forget you know you
Dialogue: 0,1:03:55.85,1:03:56.96,English,,0,0,0,,might you might forget
Dialogue: 0,1:03:56.96,1:03:58.94,English,,0,0,0,,that the variable you're passing is a
Dialogue: 0,1:03:58.94,1:04:06.24,English,,0,0,0,,local variable no not a not a global
Dialogue: 0,1:04:06.24,1:04:12.54,English,,0,0,0,,okay and a really bad mistake in our in
Dialogue: 0,1:04:12.54,1:04:17.44,English,,0,0,0,,our hello in our echo server example you
Dialogue: 0,1:04:17.44,1:04:19.02,English,,0,0,0,,notice we were very careful to malloc
Dialogue: 0,1:04:19.02,1:04:26.68,English,,0,0,0,,space for this for this connected file
Dialogue: 0,1:04:26.68,1:04:29.77,English,,0,0,0,,descriptor that we passed into that the
Dialogue: 0,1:04:29.77,1:04:32.47,English,,0,0,0,,peer thread that we are creating would
Dialogue: 0,1:04:32.47,1:04:35.61,English,,0,0,0,,have been much easier just to pass the
Dialogue: 0,1:04:35.61,1:04:37.66,English,,0,0,0,,address of the connected file descriptor
Dialogue: 0,1:04:37.66,1:04:41.58,English,,0,0,0,,into our peer thread be much easier but
Dialogue: 0,1:04:41.58,1:04:49.97,English,,0,0,0,,it would also be wrong
Dialogue: 0,1:04:49.97,1:04:57.73,English,,0,0,0,,can you see why
Dialogue: 0,1:04:57.73,1:04:59.95,English,,0,0,0,,okay let's say right here when we call
Dialogue: 0,1:04:59.95,1:05:02.77,English,,0,0,0,,pthread create instead of passing a
Dialogue: 0,1:05:02.77,1:05:06.10,English,,0,0,0,,pointer to a separately allocated region
Dialogue: 0,1:05:06.10,1:05:08.44,English,,0,0,0,,of the heap instead of doing that we
Dialogue: 0,1:05:08.44,1:05:10.09,English,,0,0,0,,just pass the address of the connected
Dialogue: 0,1:05:10.09,1:05:18.16,English,,0,0,0,,file descriptor same thing right okay
Dialogue: 0,1:05:18.16,1:05:21.79,English,,0,0,0,,and then in our thread routine we
Dialogue: 0,1:05:21.79,1:05:25.93,English,,0,0,0,,dereference that pointer to to get the
Dialogue: 0,1:05:25.93,1:05:28.93,English,,0,0,0,,connected file descriptor okay if we
Dialogue: 0,1:05:28.93,1:05:30.46,English,,0,0,0,,just pass the address of the connected
Dialogue: 0,1:05:30.46,1:05:33.55,English,,0,0,0,,file descriptor this is real it's really
Dialogue: 0,1:05:33.55,1:05:45.19,English,,0,0,0,,bad can you see why yes it does okay
Dialogue: 0,1:05:45.19,1:05:47.74,English,,0,0,0,,that's true and why is that bad I mean
Dialogue: 0,1:05:47.74,1:05:58.07,English,,0,0,0,,just
Dialogue: 0,1:05:58.07,1:06:02.28,English,,0,0,0,,that's yeah that's right so what what
Dialogue: 0,1:06:02.28,1:06:04.74,English,,0,0,0,,this is assuming this entered this
Dialogue: 0,1:06:04.74,1:06:06.96,English,,0,0,0,,bypassing the address of this connected
Dialogue: 0,1:06:06.96,1:06:11.57,English,,0,0,0,,file descriptor we're introducing a race
Dialogue: 0,1:06:11.57,1:06:14.28,English,,0,0,0,,okay in the race what we're assuming
Dialogue: 0,1:06:14.28,1:06:20.04,English,,0,0,0,,that the peer thread will be able to
Dialogue: 0,1:06:20.04,1:06:25.83,English,,0,0,0,,dereference that pointer before the main
Dialogue: 0,1:06:25.83,1:06:27.90,English,,0,0,0,,thread goes back up and gets a new
Dialogue: 0,1:06:27.90,1:06:33.00,English,,0,0,0,,connected file descriptor right so what
Dialogue: 0,1:06:33.00,1:06:35.67,English,,0,0,0,,happens what happens right we can't in a
Dialogue: 0,1:06:35.67,1:06:37.02,English,,0,0,0,,concurrent system we can't make any
Dialogue: 0,1:06:37.02,1:06:38.76,English,,0,0,0,,assumptions about how the kernel is
Dialogue: 0,1:06:38.76,1:06:40.44,English,,0,0,0,,going to schedule things right we saw
Dialogue: 0,1:06:40.44,1:06:44.07,English,,0,0,0,,the same thing with processes so what
Dialogue: 0,1:06:44.07,1:06:48.72,English,,0,0,0,,happens if after pthread create the main
Dialogue: 0,1:06:48.72,1:06:52.25,English,,0,0,0,,thread runs instead of the peer thread
Dialogue: 0,1:06:52.25,1:06:55.68,English,,0,0,0,,okay so we've passed the we've passed
Dialogue: 0,1:06:55.68,1:06:58.02,English,,0,0,0,,the address of the connected file
Dialogue: 0,1:06:58.02,1:07:02.01,English,,0,0,0,,descriptor for this client that that we
Dialogue: 0,1:07:02.01,1:07:03.51,English,,0,0,0,,accepted the connection requests from
Dialogue: 0,1:07:03.51,1:07:08.37,English,,0,0,0,,and then before the before the peer
Dialogue: 0,1:07:08.37,1:07:12.21,English,,0,0,0,,thread can dereference that argument we
Dialogue: 0,1:07:12.21,1:07:19.04,English,,0,0,0,,get a new connected file descriptor okay
Dialogue: 0,1:07:19.04,1:07:22.52,English,,0,0,0,,and now the child runs and it
Dialogue: 0,1:07:22.52,1:07:26.47,English,,0,0,0,,dereferences that that descriptor but
Dialogue: 0,1:07:26.47,1:07:30.58,English,,0,0,0,,what it gets now is the descriptor
Dialogue: 0,1:07:30.58,1:07:33.23,English,,0,0,0,,that's that's corresponding to the
Dialogue: 0,1:07:33.23,1:07:35.69,English,,0,0,0,,second the second child not the first
Dialogue: 0,1:07:35.69,1:07:40.70,English,,0,0,0,,child so now we have two threads talking
Dialogue: 0,1:07:40.70,1:07:42.50,English,,0,0,0,,to the same client using the same
Dialogue: 0,1:07:42.50,1:07:50.03,English,,0,0,0,,descriptor
Dialogue: 0,1:07:50.03,1:07:55.28,English,,0,0,0,,so do you see them hope so it's very
Dialogue: 0,1:07:55.28,1:07:56.93,English,,0,0,0,,tricky this is like a real subtle this
Dialogue: 0,1:07:56.93,1:07:59.39,English,,0,0,0,,is an example of sort of subtle errors
Dialogue: 0,1:07:59.39,1:08:02.03,English,,0,0,0,,that you can introduce because of this
Dialogue: 0,1:08:02.03,1:08:09.02,English,,0,0,0,,unintended sharing and it's cause the
Dialogue: 0,1:08:09.02,1:08:10.88,English,,0,0,0,,root cause is as you correctly pointed
Dialogue: 0,1:08:10.88,1:08:13.49,English,,0,0,0,,out is that they're both sharing the
Dialogue: 0,1:08:13.49,1:08:20.41,English,,0,0,0,,same memory on on the caller stack yes
Dialogue: 0,1:08:20.41,1:08:23.29,English,,0,0,0,,in this case of what you could do
Dialogue: 0,1:08:23.29,1:08:24.83,English,,0,0,0,,there's another there's another thing
Dialogue: 0,1:08:24.83,1:08:27.74,English,,0,0,0,,you could do you could just pass the
Dialogue: 0,1:08:27.74,1:08:29.10,English,,0,0,0,,descriptor itself
Dialogue: 0,1:08:29.10,1:08:32.12,English,,0,0,0,,okay avoid so you could just cast the
Dialogue: 0,1:08:32.12,1:08:34.97,English,,0,0,0,,descriptor to a generic pointer and just
Dialogue: 0,1:08:34.97,1:08:37.40,English,,0,0,0,,pass that and that that's just kind of
Dialogue: 0,1:08:37.40,1:08:40.15,English,,0,0,0,,yucky though that that would work
Dialogue: 0,1:08:40.15,1:08:43.58,English,,0,0,0,,because instead of dereferencing it the
Dialogue: 0,1:08:43.58,1:08:49.30,English,,0,0,0,,child would would just use it directly
Dialogue: 0,1:08:49.30,1:09:00.46,English,,0,0,0,,okay so good that's good
Dialogue: 0,1:09:00.46,1:09:07.62,English,,0,0,0,,okay the so the so the really good
Dialogue: 0,1:09:07.62,1:09:09.56,English,,0,0,0,,things with with threads is ease of
Dialogue: 0,1:09:09.56,1:09:11.25,English,,0,0,0,,sharing but that that sharing also
Dialogue: 0,1:09:11.25,1:09:15.39,English,,0,0,0,,introduces can introduce introduces
Dialogue: 0,1:09:15.39,1:09:17.64,English,,0,0,0,,complications in fact that's we're going
Dialogue: 0,1:09:17.64,1:09:21.48,English,,0,0,0,,to look at ways to sort of control the
Dialogue: 0,1:09:21.48,1:09:27.98,English,,0,0,0,,the sharing so that so that we do so
Dialogue: 0,1:09:27.98,1:09:29.79,English,,0,0,0,,that we don't get unintended unintended
Dialogue: 0,1:09:29.79,1:09:38.48,English,,0,0,0,,sharing okay so to summarize the the
Dialogue: 0,1:09:38.48,1:09:40.73,English,,0,0,0,,approaches to concurrency that that
Dialogue: 0,1:09:40.73,1:09:43.23,English,,0,0,0,,we've looked at we have process based
Dialogue: 0,1:09:43.23,1:09:46.68,English,,0,0,0,,concurrency so it's hard to share
Dialogue: 0,1:09:46.68,1:09:49.41,English,,0,0,0,,resources but it's easy to avoid
Dialogue: 0,1:09:49.41,1:09:51.54,English,,0,0,0,,unintended sharing so in some ways it's
Dialogue: 0,1:09:51.54,1:09:54.51,English,,0,0,0,,safer and easier to program event based
Dialogue: 0,1:09:54.51,1:09:57.51,English,,0,0,0,,so it's it's very low-level very tedious
Dialogue: 0,1:09:57.51,1:10:00.21,English,,0,0,0,,you have to be very careful about how
Dialogue: 0,1:10:00.21,1:10:03.60,English,,0,0,0,,you the granularity of the work that you
Dialogue: 0,1:10:03.60,1:10:08.91,English,,0,0,0,,do in response to events but you have
Dialogue: 0,1:10:08.91,1:10:10.86,English,,0,0,0,,total control over scheduling so you can
Dialogue: 0,1:10:10.86,1:10:13.32,English,,0,0,0,,decide which which descriptors you're
Dialogue: 0,1:10:13.32,1:10:15.81,English,,0,0,0,,going to service and in which order it
Dialogue: 0,1:10:15.81,1:10:18.12,English,,0,0,0,,sits since there's a single flow of
Dialogue: 0,1:10:18.12,1:10:22.61,English,,0,0,0,,control you can debug it with a debugger
Dialogue: 0,1:10:22.61,1:10:25.14,English,,0,0,0,,but it doesn't make use of multi-core so
Dialogue: 0,1:10:25.14,1:10:26.98,English,,0,0,0,,there's a handful of trade-offs there
Dialogue: 0,1:10:26.98,1:10:30.90,English,,0,0,0,,and with thread based systems it's very
Dialogue: 0,1:10:30.90,1:10:33.84,English,,0,0,0,,easy to share resources but that that
Dialogue: 0,1:10:33.84,1:10:36.35,English,,0,0,0,,sharing can create problems of its own
Dialogue: 0,1:10:36.35,1:10:39.51,English,,0,0,0,,it's fairly efficient compared to two
Dialogue: 0,1:10:39.51,1:10:41.76,English,,0,0,0,,processors you don't have much control
Dialogue: 0,1:10:41.76,1:10:44.40,English,,0,0,0,,over the scheduling so just like we saw
Dialogue: 0,1:10:44.40,1:10:46.32,English,,0,0,0,,you're not you can't really control
Dialogue: 0,1:10:46.32,1:10:49.20,English,,0,0,0,,which which threads get executed in
Dialogue: 0,1:10:49.20,1:10:52.14,English,,0,0,0,,which order and it can be difficult to
Dialogue: 0,1:10:52.14,1:10:56.98,English,,0,0,0,,debug because there can be races that
Dialogue: 0,1:10:56.98,1:10:59.88,English,,0,0,0,,occur very rarely very infrequently and
Dialogue: 0,1:10:59.88,1:11:03.98,English,,0,0,0,,so the probability of sort of creating
Dialogue: 0,1:11:03.98,1:11:05.58,English,,0,0,0,,one of those race conditions is is
Dialogue: 0,1:11:05.58,1:11:09.32,English,,0,0,0,,difficult
Dialogue: 0,1:11:09.32,1:11:13.08,English,,0,0,0,,okay so that's it for today tomorrow
Dialogue: 0,1:11:13.08,1:11:15.42,English,,0,0,0,,we'll look at thread based servers in
Dialogue: 0,1:11:15.42,1:11:18.42,English,,0,0,0,,more detail and how to write thread
Dialogue: 0,1:11:18.42,1:11:22.69,English,,0,0,0,,based systems efficiently and correctly
