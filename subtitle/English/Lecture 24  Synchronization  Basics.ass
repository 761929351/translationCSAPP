[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 635
Active Line: 643
Video Position: 101393

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.90,0:00:04.74,English,,0,0,0,,All right well good afternoon everybody good to see you welcome
Dialogue: 0,0:00:06.54,0:00:09.10,English,,0,0,0,,Welcome to all those students watching on video as well
Dialogue: 0,0:00:11.68,0:00:17.18,English,,0,0,0,,Before we start we were talking about joinable and detached threads
Dialogue: 0,0:00:17.36,0:00:23.96,English,,0,0,0,,And you asked the question about why you would ever want to have threads running in non detached mode
Dialogue: 0,0:00:24.00,0:00:27.12,English,,0,0,0,,You know why you'd ever run in want to have him running joinable
Dialogue: 0,0:00:27.74,0:00:32.04,English,,0,0,0,,And I didn't give you a very good answer so I want to try to to answer that for you better
Dialogue: 0,0:00:33.86,0:00:39.64,English,,0,0,0,,Turns out there's an important class of sort of parallel programming
Dialogue: 0,0:00:40.02,0:00:43.60,English,,0,0,0,,There's an important parallel programming model called fork and join
Dialogue: 0,0:00:44.38,0:00:47.84,English,,0,0,0,,Where program consists of a series of phases
Dialogue: 0,0:00:50.56,0:00:56.56,English,,0,0,0,,In each phase you have a worker or a master sorry
Dialogue: 0,0:00:57.66,0:01:00.54,English,,0,0,0,,And it creates a bunch of worker threads
Dialogue: 0,0:01:05.90,0:01:10.12,English,,0,0,0,,And then each of those worker threads solve some part of the problem for that phase
Dialogue: 0,0:01:10.48,0:01:15.02,English,,0,0,0,,Like some maybe you take your data structure and you break it up into chunks
Dialogue: 0,0:01:15.04,0:01:19.82,English,,0,0,0,,And then each thread updates the its own chunk of that data structure
Dialogue: 0,0:01:21.54,0:01:28.20,English,,0,0,0,,But for whatever reason the master then has to wait for the worker threads to finish before it can go on to the next phase
Dialogue: 0,0:01:28.94,0:01:32.10,English,,0,0,0,,So it does join, so this is called the fork
Dialogue: 0,0:01:33.26,0:01:35.60,English,,0,0,0,,And then it waits for all the threads to finish
Dialogue: 0,0:01:37.32,0:01:40.00,English,,0,0,0,,By doing a join okay so this is called
Dialogue: 0,0:01:41.20,0:01:43.50,English,,0,0,0,,This is called the fork and this is called the join
Dialogue: 0,0:01:44.32,0:01:47.26,English,,0,0,0,,And only when all of the threads have finished
Dialogue: 0,0:01:47.96,0:01:51.28,English,,0,0,0,,Can it go and do the next do the next phase
Dialogue: 0,0:01:56.12,0:02:00.40,English,,0,0,0,,Okay so this model is really important in things like scientific computing where
Dialogue: 0,0:02:01.22,0:02:06.76,English,,0,0,0,,You might...you're simulating some domain,you're simulating nature
Dialogue: 0,0:02:07.40,0:02:10.76,English,,0,0,0,,So you represent that as some domain like maybe you're simulating
Dialogue: 0,0:02:11.36,0:02:15.04,English,,0,0,0,,How heat flows over a plate you know metal plate
Dialogue: 0,0:02:15.90,0:02:20.20,English,,0,0,0,,And so you might have these workers
Dialogue: 0,0:02:21.30,0:02:24.04,English,,0,0,0,,You might partition the domain amongst a set of those workers
Dialogue: 0,0:02:24.84,0:02:27.90,English,,0,0,0,,And then each one of these phases is a time step
Dialogue: 0,0:02:28.94,0:02:34.24,English,,0,0,0,,And then so once all the workers have finished a time step then they can advance to the next time step
Dialogue: 0,0:02:36.30,0:02:39.00,English,,0,0,0,,And so sorry I don't know why,I didn't think of it
Dialogue: 0,0:02:39.52,0:02:41.76,English,,0,0,0,,That's a that's an important reason why you'd want this
Dialogue: 0,0:02:44.04,0:02:45.16,English,,0,0,0,,Okay so we saw
Dialogue: 0,0:02:46.36,0:02:50.30,English,,0,0,0,,We've seen the threaded programs are nice
Dialogue: 0,0:02:50.30,0:02:53.04,English,,0,0,0,,Because you they you can share all the global variables
Dialogue: 0,0:02:55.02,0:02:58.54,English,,0,0,0,,But this the sharing can have unintended consequences
Dialogue: 0,0:02:59.36,0:03:02.98,English,,0,0,0,,So somehow we need a mechanism where we can control
Dialogue: 0,0:03:02.98,0:03:07.08,English,,0,0,0,,How the flows of each individual thread are interleaved
Dialogue: 0,0:03:08.28,0:03:12.52,English,,0,0,0,,So that bad things don't happen when we share data structures
Dialogue: 0,0:03:12.78,0:03:17.74,English,,0,0,0,,Okay so this this process of controlling the interleaving is called synchronization
Dialogue: 0,0:03:17.74,0:03:24.68,English,,0,0,0,,So we're going to look at techniques that you can use to write correct threaded programs by properly synchronizing them
Dialogue: 0,0:03:27.28,0:03:29.56,English,,0,0,0,,Now first though we need to have a clear idea
Dialogue: 0,0:03:30.10,0:03:34.78,English,,0,0,0,,So sharing is the issue right if we have threads that aren't sharing any resources
Dialogue: 0,0:03:35.90,0:03:37.08,English,,0,0,0,,Then there's no problem right
Dialogue: 0,0:03:37.16,0:03:42.02,English,,0,0,0,,That we saw this when we looked at it processes there's no shared data structures with processes
Dialogue: 0,0:03:42.72,0:03:49.28,English,,0,0,0,,So we process these just run independently we don't really care how they're interleaved note no worries okay
Dialogue: 0,0:03:49.80,0:03:54.14,English,,0,0,0,,But as soon as they introduce sharing then we have to be careful
Dialogue: 0,0:03:56.24,0:04:00.58,English,,0,0,0,,Okay so to understand how to synchronize threads we first need to have a clear idea
Dialogue: 0,0:04:01.02,0:04:05.20,English,,0,0,0,,Of what we mean by sharing in in threaded C programs
Dialogue: 0,0:04:06.54,0:04:13.96,English,,0,0,0,,So the answer is not as simple as global variables are shared and stack variables are not shared
Dialogue: 0,0:04:18.70,0:04:23.66,English,,0,0,0,,Okay so with instead what we x is shared
Dialogue: 0,0:04:23.66,0:04:28.50,English,,0,0,0,,If only multiple threads reference some instance so that that variable x
Dialogue: 0,0:04:29.51,0:04:34.00,English,,0,0,0,,All right so if only one thread is accessing a particular variable
Dialogue: 0,0:04:35.64,0:04:37.06,English,,0,0,0,,Then it's not shared
Dialogue: 0,0:04:38.26,0:04:38.76,English,,0,0,0,,Okay so...
Dialogue: 0,0:04:40.32,0:04:45.24,English,,0,0,0,,In order to know exactly what we mean by shared we need to answer three questions
Dialogue: 0,0:04:46.00,0:04:48.70,English,,0,0,0,,Okay first what is the memory model for threads
Dialogue: 0,0:04:50.06,0:04:53.38,English,,0,0,0,,Okay second how are instances of variables mapped to memory
Dialogue: 0,0:04:55.24,0:05:00.35,English,,0,0,0,,And then third how many threads might be referencing those the instances of those variables
Dialogue: 0,0:05:00.64,0:05:03.84,English,,0,0,0,,Okay so we'll look at each of those now in turn each of those three questions
Dialogue: 0,0:05:05.62,0:05:07.48,English,,0,0,0,,Okay so first is that the memory model
Dialogue: 0,0:05:10.32,0:05:15.23,English,,0,0,0,,The conceptual model is a little bit different from the operational model the way it really works
Dialogue: 0,0:05:15.56,0:05:16.78,English,,0,0,0,,Okay so conceptually
Dialogue: 0,0:05:17.42,0:05:21.40,English,,0,0,0,,We have multiple threads that run in the context of a single process
Dialogue: 0,0:05:22.38,0:05:26.90,English,,0,0,0,,Okay and some of that context is shared and some of its not shared
Dialogue: 0,0:05:27.02,0:05:35.30,English,,0,0,0,,So each thread has its own separate thread id,stack,stack pointer,program counter,condition codes,general-purpose registers
Dialogue: 0,0:05:36.60,0:05:43.78,English,,0,0,0,,And then they all share the remaining process context which is data structures that the kernel maintains
Dialogue: 0,0:05:44.34,0:05:53.74,English,,0,0,0,,For the threads the virtual data structures to support the virtual memory system open files install signal handlers and so forth
Dialogue: 0,0:05:55.24,0:05:59.24,English,,0,0,0,,So that's the conceptual model and that if that were really enforced
Dialogue: 0,0:05:59.26,0:06:01.36,English,,0,0,0,,It would be nice it would make things simpler for us
Dialogue: 0,0:06:01.42,0:06:05.60,English,,0,0,0,,But unfortunately in real life this model is not strictly enforced
Dialogue: 0,0:06:07.30,0:06:13.00,English,,0,0,0,,Now although register values are really separate right the kernel maintains separate context for all the registers
Dialogue: 0,0:06:13.02,0:06:14.42,English,,0,0,0,,So that part is good
Dialogue: 0,0:06:15.72,0:06:21.64,English,,0,0,0,,But since the threads share the address space,a thread can access the the memory the stack
Dialogue: 0,0:06:21.90,0:06:24.86,English,,0,0,0,,One thread can access the stack of an another thread
Dialogue: 0,0:06:25.18,0:06:32.76,English,,0,0,0,,Okay so although conceptually these stacks are separate and distinct and in private they're really not
Dialogue: 0,0:06:36.56,0:06:38.18,English,,0,0,0,,And so this can create some problems
Dialogue: 0,0:06:38.18,0:06:42.28,English,,0,0,0,,So here's an example of that we'll come back to later
Dialogue: 0,0:06:42.96,0:06:47.88,English,,0,0,0,,Of how this one thread can access the stack of another thread
Dialogue: 0,0:06:48.54,0:06:51.54,English,,0,0,0,,So here we're defining a global variable called pointer
Dialogue: 0,0:06:52.62,0:06:54.10,English,,0,0,0,,Which is a char **
Dialogue: 0,0:06:55.26,0:07:01.62,English,,0,0,0,,And then in the main routine on were declaring a local variable called messages which contains
Dialogue: 0,0:07:02.32,0:07:05.30,English,,0,0,0,,It's a two element array which contains a couple strings
Dialogue: 0,0:07:07.20,0:07:11.18,English,,0,0,0,,Which these will be printed out by the threads that we're going to create
Dialogue: 0,0:07:12.22,0:07:17.28,English,,0,0,0,,And then we assign the global pointer to the address of the array messages
Dialogue: 0,0:07:17.92,0:07:21.16,English,,0,0,0,,Okay so now pointer points to messages
Dialogue: 0,0:07:22.66,0:07:25.56,English,,0,0,0,,And then we create in a loop we create two threads
Dialogue: 0,0:07:27.66,0:07:30.76,English,,0,0,0,,Each of which executes this routine called thread
Dialogue: 0,0:07:31.64,0:07:34.24,English,,0,0,0,,And and we're passing an argument
Dialogue: 0,0:07:35.00,0:07:41.94,English,,0,0,0,,So the Pthreads will assign a thread id but in this case we're going to assign our own local thread id
Dialogue: 0,0:07:42.16,0:07:43.58,English,,0,0,0,,By passing this loop index
Dialogue: 0,0:07:44.32,0:07:47.66,English,,0,0,0,,Okay so this is an example we talked about this last time
Dialogue: 0,0:07:49.24,0:07:51.76,English,,0,0,0,,It's kind of...it's this is perfectly okay there's no race
Dialogue: 0,0:07:52.38,0:07:58.82,English,,0,0,0,,But it's a little weird because we're going to take this index i and cast it to a generic pointer
Dialogue: 0,0:08:03.22,0:08:07.02,English,,0,0,0,,Okay and then after we create these threads then we'll exit the main thread
Dialogue: 0,0:08:09.44,0:08:17.08,English,,0,0,0,,Now each the thread routine dereferences its argument to get the local the local thread id
Dialogue: 0,0:08:17.96,0:08:21.40,English,,0,0,0,,And then it declares a static variable count
Dialogue: 0,0:08:21.42,0:08:25.68,English,,0,0,0,,That we're going to use to count how many times this thread routine is called inside of a thread
Dialogue: 0,0:08:27.38,0:08:33.66,English,,0,0,0,,And then it just prints a simple message from identifying that giving the local thread id
Dialogue: 0,0:08:35.04,0:08:40.42,English,,0,0,0,,And then the message indexed by myid
Dialogue: 0,0:08:40.90,0:08:42.90,English,,0,0,0,,So pointer points to messages
Dialogue: 0,0:08:43.00,0:08:46.40,English,,0,0,0,,So thread zero will print "hello from foo"
Dialogue: 0,0:08:47.32,0:08:50.44,English,,0,0,0,,And thread 1 will print "hello from bar"
Dialogue: 0,0:08:51.86,0:08:55.92,English,,0,0,0,,And then we increment the pre increment the counter variable
Dialogue: 0,0:08:58.80,0:08:59.46,English,,0,0,0,,Okay so
Dialogue: 0,0:09:02.36,0:09:07.62,English,,0,0,0,,Although it doesn't you would it looks like we're accessing this global variable pointer
Dialogue: 0,0:09:08.02,0:09:14.46,English,,0,0,0,,But since that was assigned to be the address of the local variable on the main thread stack
Dialogue: 0,0:09:15.10,0:09:23.26,English,,0,0,0,,We've got this these peer threads accessing local variables on the main thread stack okay
Dialogue: 0,0:09:23.36,0:09:28.22,English,,0,0,0,,So that I just this is not it you never want to do this as a very bad practice
Dialogue: 0,0:09:28.22,0:09:30.96,English,,0,0,0,,But I...it's a kind of thing that can happen sometimes
Dialogue: 0,0:09:33.84,0:09:39.28,English,,0,0,0,,By accident you know if you forget that pointer actually was assigned to you know some stack address
Dialogue: 0,0:09:41.08,0:09:46.60,English,,0,0,0,,Okay so the second question that is how do we map variable instances to memory
Dialogue: 0,0:09:47.10,0:09:50.16,English,,0,0,0,,Now we looked at this when we studied linking
Dialogue: 0,0:09:50.16,0:09:54.78,English,,0,0,0,,But let's just review this quickly again to make sure that it's clear to you
Dialogue: 0,0:09:56.80,0:10:01.38,English,,0,0,0,,So global variables are variables that are referenced outside of a function
Dialogue: 0,0:10:03.00,0:10:08.08,English,,0,0,0,,And virtual memory the linker when it does symbol resolution make sure that
Dialogue: 0,0:10:08.08,0:10:12.50,English,,0,0,0,,There's exactly one instance of every global variable in virtual memory
Dialogue: 0,0:10:16.50,0:10:20.14,English,,0,0,0,,Now local variables are declared on the stack inside of a function
Dialogue: 0,0:10:23.26,0:10:24.94,English,,0,0,0,,Without the static attribute
Dialogue: 0,0:10:26.28,0:10:32.46,English,,0,0,0,,And so in this case each the stack for each thread will contain one instance of that local variable
Dialogue: 0,0:10:37.60,0:10:37.94,English,,0,0,0,,Now
Dialogue: 0,0:10:39.30,0:10:42.70,English,,0,0,0,,If variables are declared inside of a function with the static attribute
Dialogue: 0,0:10:44.28,0:10:49.06,English,,0,0,0,,Then the scope of that variable is limited to that function meaning no other function can access it
Dialogue: 0,0:10:50.56,0:10:55.66,English,,0,0,0,,But that static variable is stored along with all the other local variables
Dialogue: 0,0:10:55.70,0:11:04.14,English,,0,0,0,,So there's any static variable declared inside of a function has exactly one instance in memory
Dialogue: 0,0:11:04.96,0:11:10.66,English,,0,0,0,,And if you were to have say multiple functions that declared (the same) a static variable with the same name
Dialogue: 0,0:11:11.30,0:11:14.44,English,,0,0,0,,The compiler would disambiguate those somehow
Dialogue: 0,0:11:14.44,0:11:17.24,English,,0,0,0,,It would append some kind of unique
Dialogue: 0,0:11:19.10,0:11:20.80,English,,0,0,0,,It would somehow make that name unique
Dialogue: 0,0:11:24.48,0:11:30.14,English,,0,0,0,,Okay so what recall how all these different types of variable instances are mapped into memory
Dialogue: 0,0:11:31.86,0:11:35.38,English,,0,0,0,,Okay pointer is a global variable
Dialogue: 0,0:11:35.38,0:11:40.16,English,,0,0,0,,So there's one instance of pointer in the address space
Dialogue: 0,0:11:42.72,0:11:45.56,English,,0,0,0,,And it's stored in the data segment
Dialogue: 0,0:11:50.54,0:11:57.40,English,,0,0,0,,i and messages are examples of local variables to main
Dialogue: 0,0:11:58.44,0:12:05.12,English,,0,0,0,,So there's one instance of these stored on the stack of main stack
Dialogue: 0,0:12:06.22,0:12:12.08,English,,0,0,0,,And we'll denote those with this notation we'll say variable i
Dialogue: 0,0:12:12.70,0:12:17.04,English,,0,0,0,,i.m means variable i is stored on main stack
Dialogue: 0,0:12:18.32,0:12:20.78,English,,0,0,0,,And messages is stored on the stack of main
Dialogue: 0,0:12:23.52,0:12:28.86,English,,0,0,0,,Okay now myid is a local variable defined in this thread routine
Dialogue: 0,0:12:30.34,0:12:32.48,English,,0,0,0,,And so there's actually since there's two of these threads
Dialogue: 0,0:12:32.74,0:12:39.62,English,,0,0,0,,There's there's now there are in memory there's there's two instances of myid one for each stack
Dialogue: 0,0:12:40.54,0:12:43.38,English,,0,0,0,,Okay associated with the stack associated with each thread
Dialogue: 0,0:12:45.28,0:12:49.52,English,,0,0,0,,So myid.p0 is stored on peer thread 0's stack
Dialogue: 0,0:12:50.26,0:12:54.64,English,,0,0,0,,And myid.p1 is stored on peer thread 1's stack
Dialogue: 0,0:12:59.20,0:13:07.68,English,,0,0,0,,Ok and now this counter variable the static counter variable has just exactly one instance in virtual memory
Dialogue: 0,0:13:07.98,0:13:13.02,English,,0,0,0,,And it sits in the data segment along with the other global variables like like pointer
Dialogue: 0,0:13:17.34,0:13:18.62,English,,0,0,0,,Okay now so the question is
Dialogue: 0,0:13:20.78,0:13:23.24,English,,0,0,0,,Which of these variables are shared and which are not
Dialogue: 0,0:13:25.66,0:13:26.32,English,,0,0,0,,Okay so we can
Dialogue: 0,0:13:28.50,0:13:36.88,English,,0,0,0,,Remember what we said is it's shared if more than one thread is accessing an instance of that variable
Dialogue: 0,0:13:38.98,0:13:42.82,English,,0,0,0,,Okay so let's just list all the different variables
Dialogue: 0,0:13:44.20,0:13:48.62,English,,0,0,0,,And then let's look at each of these threads and see if it's referenced by that thread
Dialogue: 0,0:13:50.26,0:13:52.66,English,,0,0,0,,Okay so what about,what about pointer
Dialogue: 0,0:13:54.80,0:13:59.45,English,,0,0,0,,Right there's just it's referenced by the main thread right
Dialogue: 0,0:14:00.80,0:14:02.80,English,,0,0,0,,And what about peer threads zero
Dialogue: 0,0:14:07.38,0:14:10.20,English,,0,0,0,,Yeah it's referenced by peer thread zero right here
Dialogue: 0,0:14:12.88,0:14:14.14,English,,0,0,0,,Right here
Dialogue: 0,0:14:15.80,0:14:17.56,English,,0,0,0,,And similarly for peer thread one
Dialogue: 0,0:14:18.64,0:14:21.72,English,,0,0,0,,Okay so pointer is referenced by all three threads
Dialogue: 0,0:14:25.02,0:14:25.90,English,,0,0,0,,Now what about count
Dialogue: 0,0:14:29.32,0:14:31.78,English,,0,0,0,,Counts not referenced by the main thread
Dialogue: 0,0:14:32.96,0:14:36.00,English,,0,0,0,,But it is referenced by the two peer threads
Dialogue: 0,0:14:38.44,0:14:40.16,English,,0,0,0,,Now what about i in main
Dialogue: 0,0:14:42.62,0:14:44.28,English,,0,0,0,,That's referenced by main of course
Dialogue: 0,0:14:44.30,0:14:49.04,English,,0,0,0,,But not by but not by either of the two threads
Dialogue: 0,0:14:50.74,0:14:52.84,English,,0,0,0,,Now we're about messages, the messages array
Dialogue: 0,0:14:54.62,0:14:57.92,English,,0,0,0,,Okay so that's accessed by main
Dialogue: 0,0:14:58.74,0:15:00.92,English,,0,0,0,,And indirectly through pointer
Dialogue: 0,0:15:01.52,0:15:05.56,English,,0,0,0,,It's referenced by each of these two peer threads
Dialogue: 0,0:15:07.66,0:15:12.24,English,,0,0,0,,Now what about myid defined in peer thread zero
Dialogue: 0,0:15:14.20,0:15:16.54,English,,0,0,0,,Okay so that's referenced that's a local variable
Dialogue: 0,0:15:16.54,0:15:21.06,English,,0,0,0,,So it's only referenced by peer thread zero right it's not referenced by either the other threads
Dialogue: 0,0:15:21.08,0:15:29.00,English,,0,0,0,,And similarly for myid and in peer threat one
Dialogue: 0,0:15:33.12,0:15:36.32,English,,0,0,0,,Okay so given that definition then
Dialogue: 0,0:15:37.60,0:15:39.90,English,,0,0,0,,Which of these variables is shared
Dialogue: 0,0:15:42.28,0:15:44.74,English,,0,0,0,,So it's really straightforward with yeah
Dialogue: 0,0:15:50.56,0:15:55.88,English,,0,0,0,,Okay so the question is discount count as a share variable and answer is yes
Dialogue: 0,0:15:56.70,0:15:59.10,English,,0,0,0,,Because it's declared static
Dialogue: 0,0:15:59.86,0:16:03.66,English,,0,0,0,,It's there's one instance of it in virtual memory
Dialogue: 0,0:16:04.94,0:16:08.82,English,,0,0,0,,And each of the threads references that instance
Dialogue: 0,0:16:09.40,0:16:13.12,English,,0,0,0,,Okay so it's shared,it's really like a global variable
Dialogue: 0,0:16:13.76,0:16:16.86,English,,0,0,0,,It's just a scope is limited to the...
Dialogue: 0,0:16:18.30,0:16:22.98,English,,0,0,0,,It stored the same way a global variable is but its scope is limited to the function that it's defined in
Dialogue: 0,0:16:24.48,0:16:27.26,English,,0,0,0,,Okay so to determine if each one of these is whether
Dialogue: 0,0:16:27.48,0:16:30.14,English,,0,0,0,,Which of these variables are shared in which one's not we just
Dialogue: 0,0:16:30.66,0:16:39.00,English,,0,0,0,,We just look go across and for any variable with its shared by more than,more than one thread then it's shared
Dialogue: 0,0:16:39.68,0:16:40.78,English,,0,0,0,,So pointer shared
Dialogue: 0,0:16:44.98,0:16:48.38,English,,0,0,0,,So pointer is shared count is not shared
Dialogue: 0,0:16:50.92,0:16:56.10,English,,0,0,0,,Oh no count is shared because it's it's referenced by peer thread zero and peer thread one
Dialogue: 0,0:16:58.42,0:17:01.62,English,,0,0,0,,I's not shared because it's only referenced by main
Dialogue: 0,0:17:02.98,0:17:03.38,English,,0,0,0,,So
Dialogue: 0,0:17:07.94,0:17:11.76,English,,0,0,0,,Messages is access referenced by all three threads so it's shared
Dialogue: 0,0:17:12.78,0:17:18.60,English,,0,0,0,,But myid is not shared because it's only referenced by exactly one thread
Dialogue: 0,0:17:19.02,0:17:28.22,English,,0,0,0,,Okay so pointer count and messages are the shared variables in this program and the others are run share
Dialogue: 0,0:17:28.66,0:17:28.86,English,,0,0,0,,Yes
Dialogue: 0,0:17:29.32,0:17:35.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:17:35.74,0:17:37.86,English,,0,0,0,,So declared my ideas static
Dialogue: 0,0:17:38.82,0:17:41.92,English,,0,0,0,,With the second process of overridden it yeah that would be a race
Dialogue: 0,0:17:43.44,0:17:47.44,English,,0,0,0,,Okay so that would...we just depend on which thread executed first
Dialogue: 0,0:17:48.16,0:17:50.32,English,,0,0,0,,So you would really wouldn't want to do that
Dialogue: 0,0:17:55.38,0:18:00.26,English,,0,0,0,,Okay so we have a very clear notion now of what we mean by sharing
Dialogue: 0,0:18:08.32,0:18:12.64,English,,0,0,0,,So these being able to share variables like this in this ways is very handy
Dialogue: 0,0:18:14.12,0:18:16.54,English,,0,0,0,,But you can run into some really nasty problems
Dialogue: 0,0:18:17.76,0:18:20.88,English,,0,0,0,,That are very surprising,so let me show you an example
Dialogue: 0,0:18:23.28,0:18:24.34,English,,0,0,0,,This is a program
Dialogue: 0,0:18:25.72,0:18:29.72,English,,0,0,0,,Called bad count so obviously there's something wrong with this I'm giving you a little clue
Dialogue: 0,0:18:31.28,0:18:39.58,English,,0,0,0,,But what we want to do is we want to create a bunch of threads or a number of threads
Dialogue: 0,0:18:40.46,0:18:44.18,English,,0,0,0,,And each of those threads will increment a global variable called count
Dialogue: 0,0:18:45.00,0:18:47.04,English,,0,0,0,,Some number of times the same number of times
Dialogue: 0,0:18:49.26,0:18:55.02,English,,0,0,0,,Okay so we pass in the number of iterations as the first argument
Dialogue: 0,0:18:56.16,0:18:59.54,English,,0,0,0,,And here's our well here's our global globally shared variable
Dialogue: 0,0:19:02.02,0:19:03.84,English,,0,0,0,,And you remember what volatile means
Dialogue: 0,0:19:04.92,0:19:06.10,English,,0,0,0,,Everybody remember what that means
Dialogue: 0,0:19:07.68,0:19:10.30,English,,0,0,0,,So what is volatile,what is volatile tell the compiler
Dialogue: 0,0:19:10.98,0:19:11.48,English,,0,0,0,,Yes
Dialogue: 0,0:19:11.60,0:19:22.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:24.72,0:19:32.92,English,,0,0,0,,It actually you're on in the right direction actually tells,it tells the compiler never to put that variable in a register
Dialogue: 0,0:19:33.72,0:19:38.96,English,,0,0,0,,Okay so it always read that value from memory or store it to memory and
Dialogue: 0,0:19:39.54,0:19:44.64,English,,0,0,0,,You do that because of exactly the kind of possibility that you mentioned
Dialogue: 0,0:19:46.90,0:19:50.60,English,,0,0,0,,So in this case we have
Dialogue: 0,0:19:50.98,0:19:55.88,English,,0,0,0,,We create two threads by with two distinct calls to two pthread create
Dialogue: 0,0:19:57.42,0:20:02.76,English,,0,0,0,,Each of these threads will run the the thread routine called thread
Dialogue: 0,0:20:03.36,0:20:08.50,English,,0,0,0,,And it will pass and as an argument the address of the number of iterations that it should
Dialogue: 0,0:20:09.34,0:20:10.18,English,,0,0,0,,That it should iterate
Dialogue: 0,0:20:11.66,0:20:15.56,English,,0,0,0,,Now you remember when we were looking when we were passing connected file descriptors
Dialogue: 0,0:20:16.76,0:20:18.70,English,,0,0,0,,If we pass an address that was a race
Dialogue: 0,0:20:20.10,0:20:22.86,English,,0,0,0,,Okay but in this case there's no race this is fine
Dialogue: 0,0:20:22.86,0:20:25.88,English,,0,0,0,,It's fine just to pass the address of number of iterations
Dialogue: 0,0:20:26.46,0:20:32.52,English,,0,0,0,,So why is it okay in this case but it wasn't okay when we were passing the connected file descriptor
Dialogue: 0,0:20:32.88,0:20:35.28,English,,0,0,0,,That we got from acceptant to our thread routine
Dialogue: 0,0:20:49.06,0:20:51.98,English,,0,0,0,,Yes
Dialogue: 0,0:20:52.00,0:20:54.40,English,,0,0,0,,Exactly because the thread doesn't modify the value
Dialogue: 0,0:20:54.60,0:21:01.82,English,,0,0,0,,And that the problem we had before was that our main thread was modifying that connected descriptor on the next call to accept
Dialogue: 0,0:21:02.56,0:21:04.76,English,,0,0,0,,But here it's just a read-only variable so we're okay
Dialogue: 0,0:21:06.58,0:21:08.90,English,,0,0,0,,But you see the how tricky the reasoning can get right there's
Dialogue: 0,0:21:09.46,0:21:13.78,English,,0,0,0,,You can't do pattern matching to determine whether you've got races or not races
Dialogue: 0,0:21:14.40,0:21:16.02,English,,0,0,0,,Right so you can't just say well
Dialogue: 0,0:21:16.52,0:21:23.24,English,,0,0,0,,It's always bad to pass the address of some variable to a thread routine
Dialogue: 0,0:21:23.78,0:21:25.72,English,,0,0,0,,Okay because it's not it just depends on the context
Dialogue: 0,0:21:27.37,0:21:31.40,English,,0,0,0,,Okay so in this case we're passing the number of iterations and to each thread and
Dialogue: 0,0:21:33.52,0:21:36.88,English,,0,0,0,,Then we're waiting for each of those threads to finish
Dialogue: 0,0:21:36.90,0:21:43.26,English,,0,0,0,,So this is an example of why you need why you might want to have a non detached thread
Dialogue: 0,0:21:43.30,0:21:43.98,English,,0,0,0,,Because you can't
Dialogue: 0,0:21:46.62,0:21:50.16,English,,0,0,0,,We want when we check when we check the value of count
Dialogue: 0,0:21:50.16,0:21:54.18,English,,0,0,0,,We have to make sure that every thread is finished before we check whether we got the right value or not
Dialogue: 0,0:21:55.28,0:21:56.96,English,,0,0,0,,Okay so we wait for each thread to finish
Dialogue: 0,0:21:58.00,0:22:03.10,English,,0,0,0,,And now since we've created two threads each of which is incrementing count editors time
Dialogue: 0,0:22:04.10,0:22:07.06,English,,0,0,0,,We expect count to be equal to two times and niters
Dialogue: 0,0:22:07.06,0:22:10.44,English,,0,0,0,,And if it's not we print my favorite error message
Dialogue: 0,0:22:11.90,0:22:19.04,English,,0,0,0,,Otherwise we with the value of count,otherwise we print OK also with the value of count
Dialogue: 0,0:22:20.68,0:22:22.64,English,,0,0,0,,Okay so now what's going on in the thread routine
Dialogue: 0,0:22:23.78,0:22:24.54,English,,0,0,0,,Very simple
Dialogue: 0,0:22:26.32,0:22:33.46,English,,0,0,0,,It dereferences the argument that was passed in and stores it in the local copy of entities
Dialogue: 0,0:22:34.84,0:22:36.44,English,,0,0,0,,And then it loop senators time
Dialogue: 0,0:22:37.42,0:22:39.04,English,,0,0,0,,In can increments count each time
Dialogue: 0,0:22:40.20,0:22:41.22,English,,0,0,0,,So and then returns
Dialogue: 0,0:22:42.38,0:22:45.32,English,,0,0,0,,So this is very innocuous what could go wrong
Dialogue: 0,0:22:47.64,0:22:53.22,English,,0,0,0,,And since this is threading,since this is concurrent concurrent programming,especially since it's threaded programming
Dialogue: 0,0:22:53.56,0:22:56.98,English,,0,0,0,,What there's the odd lots of subtle things can go wrong
Dialogue: 0,0:22:56.98,0:23:00.30,English,,0,0,0,,So it turns out this program has a really serious bug
Dialogue: 0,0:23:01.52,0:23:03.48,English,,0,0,0,,Okay because when we run it
Dialogue: 0,0:23:06.24,0:23:08.40,English,,0,0,0,,When we run it on a Linux box
Dialogue: 0,0:23:08.96,0:23:12.80,English,,0,0,0,,Sometimes if we call it with an argument of ten thousand
Dialogue: 0,0:23:13.40,0:23:17.90,English,,0,0,0,,Sometimes we get the correct answer 2*10,000 or 20,000
Dialogue: 0,0:23:18.54,0:23:19.66,English,,0,0,0,,But then the next time we run it
Dialogue: 0,0:23:20.36,0:23:23.76,English,,0,0,0,,We get some weird number 13051
Dialogue: 0,0:23:25.18,0:23:25.94,English,,0,0,0,,Completely wrong
Dialogue: 0,0:23:27.28,0:23:30.18,English,,0,0,0,,And so what the hack is going on here
Dialogue: 0,0:23:32.74,0:23:35.90,English,,0,0,0,,Okay so to understand that we have to look at the assembly language
Dialogue: 0,0:23:37.60,0:23:39.64,English,,0,0,0,,For this counter loop so that
Dialogue: 0,0:23:41.06,0:23:45.94,English,,0,0,0,,We want to...we need to look at the the assembly language for this counter loop in the thread routine
Dialogue: 0,0:23:48.22,0:23:50.34,English,,0,0,0,,So we'll break it up into three chunks that
Dialogue: 0,0:23:51.12,0:23:53.90,English,,0,0,0,,The first chunk is sort of getting ready for the loop
Dialogue: 0,0:23:54.26,0:24:01.60,English,,0,0,0,,We'll call that the head and we'll denote it as H(i)  for thread i
Dialogue: 0,0:24:04.94,0:24:12.84,English,,0,0,0,,And then we'll isolate on these three instructions that are directly related to incrementing count
Dialogue: 0,0:24:14.08,0:24:16.22,English,,0,0,0,,Okay so you see the first instruction moves
Dialogue: 0,0:24:16.66,0:24:22.50,English,,0,0,0,,It loads the global of the value and global variable count into register %rdx
Dialogue: 0,0:24:24.14,0:24:25.72,English,,0,0,0,,So will denote that as L(i)
Dialogue: 0,0:24:27.54,0:24:30.18,English,,0,0,0,,Next it increments %rdx
Dialogue: 0,0:24:31.52,0:24:35.98,English,,0,0,0,,And we'll denote that U(i) for update so it updates %rdx
Dialogue: 0,0:24:37.14,0:24:42.92,English,,0,0,0,,And then it stores the value the updated value of %rdx into count
Dialogue: 0,0:24:43.42,0:24:48.06,English,,0,0,0,,Okay so into the location associated with the global variable count
Dialogue: 0,0:24:50.00,0:24:50.44,English,,0,0,0,,And
Dialogue: 0,0:24:53.32,0:24:58.94,English,,0,0,0,,And then the rest of...the rest of this loop is getting ready for the to do the next iteration
Dialogue: 0,0:24:59.70,0:25:02.32,English,,0,0,0,,It's not directly related to incrementing count
Dialogue: 0,0:25:02.32,0:25:06.38,English,,0,0,0,,So we'll just sort of group this all together and refer to it as T(i) for tail
Dialogue: 0,0:25:07.68,0:25:07.86,English,,0,0,0,,Okay
Dialogue: 0,0:25:13.60,0:25:17.56,English,,0,0,0,,Now let's look at...let's look at...
Dialogue: 0,0:25:18.22,0:25:21.94,English,,0,0,0,,How this how these two threads might be executed
Dialogue: 0,0:25:22.12,0:25:27.38,English,,0,0,0,,And remember in general we can't assume that there's any specific interleaving
Dialogue: 0,0:25:27.40,0:25:30.08,English,,0,0,0,,So any interleaving of these two threads is possible
Dialogue: 0,0:25:30.18,0:25:33.32,English,,0,0,0,,No matter how remote it might seem
Dialogue: 0,0:25:34.90,0:25:38.80,English,,0,0,0,,So let's look at one example let's say we're executing on a single core
Dialogue: 0,0:25:38.80,0:25:40.98,English,,0,0,0,,So we're only going to do one instruction at a time
Dialogue: 0,0:25:43.00,0:25:43.54,English,,0,0,0,,And
Dialogue: 0,0:25:45.84,0:25:50.36,English,,0,0,0,,In this column will show which thread is executing so either thread 1 or thread 2
Dialogue: 0,0:25:53.28,0:25:56.42,English,,0,0,0,,And then we'll to know which instruction in that thread is executing
Dialogue: 0,0:25:57.90,0:26:00.28,English,,0,0,0,,Either H,L,U,S or T
Dialogue: 0,0:26:02.02,0:26:07.20,English,,0,0,0,,And then this column shows the value of %rdx for thread number 1
Dialogue: 0,0:26:08.34,0:26:11.46,English,,0,0,0,,And this column shows the value of %rdx for thread number 2
Dialogue: 0,0:26:11.66,0:26:19.28,English,,0,0,0,,Right since that the kernel keeps separate copies of all the general-purpose registers the for each thread these can be different
Dialogue: 0,0:26:22.60,0:26:25.56,English,,0,0,0,,Okay and then this last column shows the value of count in memory
Dialogue: 0,0:26:27.90,0:26:30.82,English,,0,0,0,,So let's start executing
Dialogue: 0,0:26:30.92,0:26:33.06,English,,0,0,0,,So initially count is equal to 0
Dialogue: 0,0:26:34.16,0:26:38.90,English,,0,0,0,,And thread one gets the kernel schedules thread 1
Dialogue: 0,0:26:38.92,0:26:41.94,English,,0,0,0,,So it executes say H(1) that has no impact on count
Dialogue: 0,0:26:43.34,0:26:47.20,English,,0,0,0,,Then thread 1 loads the value of count into its copy of %rdx
Dialogue: 0,0:26:48.52,0:26:49.34,English,,0,0,0,,Updates it
Dialogue: 0,0:26:50.74,0:26:58.90,English,,0,0,0,,So now %rdx is equal to 1 and then stores that value in %rdx back to count so now count is equal to 1
Dialogue: 0,0:27:00.84,0:27:04.20,English,,0,0,0,,Now at this point the kernel decides to schedule thread 2
Dialogue: 0,0:27:04.90,0:27:10.76,English,,0,0,0,,So thread 2 begins executing and when it begins executing value of count is 1
Dialogue: 0,0:27:11.86,0:27:14.20,English,,0,0,0,,So it executes H(i)
Dialogue: 0,0:27:16.26,0:27:22.62,English,,0,0,0,,Then it loads count into thread 2 copy of %rdx
Dialogue: 0,0:27:23.32,0:27:28.08,English,,0,0,0,,So now %rdx equals 1,updates it,now it's equal to 2
Dialogue: 0,0:27:28.68,0:27:31.40,English,,0,0,0,,And then stores that value back to count
Dialogue: 0,0:27:33.20,0:27:41.44,English,,0,0,0,,The kernel then decides oh and then it finishes executing the tail instruction
Dialogue: 0,0:27:42.44,0:27:44.36,English,,0,0,0,,And let's say we're just doing one iteration of this
Dialogue: 0,0:27:45.64,0:27:51.22,English,,0,0,0,,And then at this point the kernel decides to schedule thread 1 since thread 2 is finished so
Dialogue: 0,0:27:51.86,0:27:55.38,English,,0,0,0,,Thread 1 executes the remaining statement that it has to execute
Dialogue: 0,0:27:57.06,0:27:58.82,English,,0,0,0,,And at this point both threads have finished
Dialogue: 0,0:28:00.50,0:28:03.84,English,,0,0,0,,And count is equal to 2 which is the value we would expect
Dialogue: 0,0:28:04.18,0:28:06.74,English,,0,0,0,,Ok so this so this is ok
Dialogue: 0,0:28:07.38,0:28:11.60,English,,0,0,0,,And notice how...so this is actually this is an inner leaving that works
Dialogue: 0,0:28:11.88,0:28:13.08,English,,0,0,0,,Ok we get the correct value
Dialogue: 0,0:28:14.12,0:28:16.02,English,,0,0,0,,And notice how I...
Dialogue: 0,0:28:19.08,0:28:23.14,English,,0,0,0,,I grouped the 3 instructions that are actually involved in updating count together
Dialogue: 0,0:28:24.66,0:28:29.76,English,,0,0,0,,And it will call that,we'll call those 3 instructions a critical section and I've color-coded them
Dialogue: 0,0:28:29.78,0:28:32.02,English,,0,0,0,,So you can easily keep track of them
Dialogue: 0,0:28:34.08,0:28:39.10,English,,0,0,0,,Alright let's look...now let's look at another another interleaving which is feasible right
Dialogue: 0,0:28:40.24,0:28:43.04,English,,0,0,0,,But in this case it results in the wrong value
Dialogue: 0,0:28:44.98,0:28:47.98,English,,0,0,0,,Ok so here we start with thread 1 again
Dialogue: 0,0:28:50.16,0:28:55.52,English,,0,0,0,,It loads it's the value of count into its copy of %rdx updates it
Dialogue: 0,0:28:56.14,0:28:57.62,English,,0,0,0,,But then before it can store it
Dialogue: 0,0:28:59.08,0:29:01.44,English,,0,0,0,,The kernel decides to schedule thread 2
Dialogue: 0,0:29:02.46,0:29:04.84,English,,0,0,0,,So thread 2 begins x executing
Dialogue: 0,0:29:05.86,0:29:09.28,English,,0,0,0,,It loads count into its copy of %rdx too
Dialogue: 0,0:29:10.18,0:29:14.24,English,,0,0,0,,And notice count is still 0 right it's 1
Dialogue: 0,0:29:15.84,0:29:19.64,English,,0,0,0,,In the value of in thread 1 in the %rdx
Dialogue: 0,0:29:20.12,0:29:24.02,English,,0,0,0,,The copy of %rdx and thread 1 but it hasn't been updated in memory so
Dialogue: 0,0:29:24.98,0:29:29.92,English,,0,0,0,,When thread 2 loads its value of count
Dialogue: 0,0:29:29.92,0:29:33.44,English,,0,0,0,,Now it's copy and %rdx is 0
Dialogue: 0,0:29:34.60,0:29:39.72,English,,0,0,0,,Now at this point the kernel reschedules thread 1 to execute so thread 1 does it store
Dialogue: 0,0:29:40.88,0:29:43.98,English,,0,0,0,,Of its copy of %rdx into count
Dialogue: 0,0:29:44.96,0:29:48.16,English,,0,0,0,,And then finishes executing it the tail instruction
Dialogue: 0,0:29:49.44,0:29:54.72,English,,0,0,0,,The colonel reschedules thread 2 which picks up where it left off it updates
Dialogue: 0,0:29:55.90,0:29:58.36,English,,0,0,0,,Its copy of count
Dialogue: 0,0:29:58.46,0:30:01.60,English,,0,0,0,,So now %rdx goes from 0 to 1
Dialogue: 0,0:30:03.18,0:30:06.12,English,,0,0,0,,And then it stores that value into count
Dialogue: 0,0:30:06.80,0:30:10.44,English,,0,0,0,,So all we've done is we've overwritten count out a value 1
Dialogue: 0,0:30:11.06,0:30:12.80,English,,0,0,0,,And we've overwritten it with a value of 1
Dialogue: 0,0:30:13.82,0:30:17.72,English,,0,0,0,,So when we finish execution of these two threads count has the wrong value
Dialogue: 0,0:30:20.58,0:30:21.18,English,,0,0,0,,Okay in the
Dialogue: 0,0:30:22.58,0:30:27.96,English,,0,0,0,,That then the general like,the general thing to notice is you see how these critical sections have been interleaved
Dialogue: 0,0:30:28.64,0:30:30.72,English,,0,0,0,,Right in this case
Dialogue: 0,0:30:32.14,0:30:37.60,English,,0,0,0,,This is the first the critical section for thread 1 executed before the critical section for thread 2
Dialogue: 0,0:30:39.52,0:30:42.88,English,,0,0,0,,Okay but in this case the two critical sections interleaved okay
Dialogue: 0,0:30:46.24,0:30:48.30,English,,0,0,0,,So let's see another example of that
Dialogue: 0,0:30:48.70,0:30:50.78,English,,0,0,0,,So here you can see that these are interleaved so
Dialogue: 0,0:30:53.60,0:30:55.10,English,,0,0,0,,Probably suggest there might be a problem.Yes!
Dialogue: 0,0:30:55.12,0:31:00.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:00.68,0:31:01.98,English,,0,0,0,,So I'm sorry excuse me
Dialogue: 0,0:31:02.04,0:31:11.32,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:11.34,0:31:13.72,English,,0,0,0,,Well no okay so the question is would would
Dialogue: 0,0:31:14.90,0:31:15.60,English,,0,0,0,,I or count count
Dialogue: 0,0:31:22.10,0:31:26.10,English,,0,0,0,,If we...okay it is defined as volatile
Dialogue: 0,0:31:28.52,0:31:37.68,English,,0,0,0,,Yeah so that that's why...I mean there's actually and the compiler could have compiled this code in different ways right
Dialogue: 0,0:31:38.10,0:31:42.96,English,,0,0,0,,There is actually an increment instruction that you will increment a variable in memory
Dialogue: 0,0:31:43.16,0:31:44.36,English,,0,0,0,,So you could have done
Dialogue: 0,0:31:45.60,0:31:47.10,English,,0,0,0,,The compiler could have generated this
Dialogue: 0,0:31:47.36,0:31:51.10,English,,0,0,0,,This 3 instruction sequence is one instruction and then we wouldn't have this problem
Dialogue: 0,0:31:51.64,0:31:52.62,English,,0,0,0,,But the problem is that
Dialogue: 0,0:31:53.68,0:31:59.86,English,,0,0,0,,It's loading into register then incrementing and then saving
Dialogue: 0,0:31:59.88,0:32:01.78,English,,0,0,0,,So that the problem comes about because
Dialogue: 0,0:32:02.26,0:32:02.64,English,,0,0,0,,We can
Dialogue: 0,0:32:05.08,0:32:10.02,English,,0,0,0,,This thread can be interrupted before it finishes this three-step sequence
Dialogue: 0,0:32:10.02,0:32:12.20,English,,0,0,0,,This load modify store sequence
Dialogue: 0,0:32:12.98,0:32:13.28,English,,0,0,0,,Yes
Dialogue: 0,0:32:13.66,0:32:21.36,English,,0,0,0,,[student speaking]
Dialogue: 0,0:32:21.36,0:32:24.86,English,,0,0,0,,It would wait yeah so it that's right yeah I guess I wasn't clear it
Dialogue: 0,0:32:25.63,0:32:28.66,English,,0,0,0,,It prevents it from being stored permanently in a register right so
Dialogue: 0,0:32:29.42,0:32:34.24,English,,0,0,0,,It may have to be loaded into a register but then it'll be written back
Dialogue: 0,0:32:36.02,0:32:39.52,English,,0,0,0,,Okay whereas the the compiler would have the option like we've seen it with local variables
Dialogue: 0,0:32:40.16,0:32:43.44,English,,0,0,0,,Right the compiler just it never allocates stack space
Dialogue: 0,0:32:43.44,0:32:45.88,English,,0,0,0,,It just keeps that local variable in a register all the time
Dialogue: 0,0:32:46.12,0:32:50.02,English,,0,0,0,,Okay so this prevent the volatile attribute prevents the compiler from doing that
Dialogue: 0,0:32:55.58,0:32:57.19,English,,0,0,0,,Okay so let's look at another example
Dialogue: 0,0:32:58.20,0:33:00.58,English,,0,0,0,,So here thread 1 starts
Dialogue: 0,0:33:01.08,0:33:04.24,English,,0,0,0,,It loads count into %rdx
Dialogue: 0,0:33:05.08,0:33:06.28,English,,0,0,0,,Then thread 2 starts
Dialogue: 0,0:33:07.36,0:33:11.44,English,,0,0,0,,And it loads a count which is still 0 into %rdx(2)
Dialogue: 0,0:33:12.18,0:33:15.80,English,,0,0,0,,Updates it and then stores it so now count equal to 1
Dialogue: 0,0:33:16.38,0:33:25.56,English,,0,0,0,,When thread 1 resumes it updates its value of count and %rdx and stores that back to count
Dialogue: 0,0:33:25.92,0:33:28.22,English,,0,0,0,,And so again we have the same problem
Dialogue: 0,0:33:30.58,0:33:31.34,English,,0,0,0,,Okay so the...
Dialogue: 0,0:33:32.52,0:33:36.22,English,,0,0,0,,The problem here is that we're interleaving these these critical sections
Dialogue: 0,0:33:36.92,0:33:39.62,English,,0,0,0,,And you can understand why this is bad
Dialogue: 0,0:33:40.74,0:33:43.60,English,,0,0,0,,With a nice or graphical technique called a progress graph
Dialogue: 0,0:33:48.38,0:33:49.96,English,,0,0,0,,So in a progress graph
Dialogue: 0,0:33:52.60,0:33:56.20,English,,0,0,0,,If we have 4n threads it's an n dimensional cartesian grid
Dialogue: 0,0:33:57.98,0:34:03.88,English,,0,0,0,,That characterizes the execution state space of a concurrent threaded program
Dialogue: 0,0:34:05.06,0:34:07.58,English,,0,0,0,,So in this case each here we have two threads
Dialogue: 0,0:34:07.60,0:34:12.06,English,,0,0,0,,So it's a 2d coordinate system
Dialogue: 0,0:34:13.04,0:34:18.36,English,,0,0,0,,So each axis represents the progress the execution progress of some threads
Dialogue: 0,0:34:18.44,0:34:22.52,English,,0,0,0,,So the x axis here is thread 1
Dialogue: 0,0:34:23.08,0:34:25.72,English,,0,0,0,,And the y axis corresponds to thread 2
Dialogue: 0,0:34:27.40,0:34:32.16,English,,0,0,0,,And then each one of these edges corresponds to the execution of an instruction
Dialogue: 0,0:34:32.88,0:34:35.34,English,,0,0,0,,Ok so we start out in an initial state
Dialogue: 0,0:34:36.12,0:34:38.50,English,,0,0,0,,And then the first thing we execute is H(1)
Dialogue: 0,0:34:39.70,0:34:42.21,English,,0,0,0,,So that's represented by this ACK here
Dialogue: 0,0:34:43.18,0:34:47.64,English,,0,0,0,,So this position this point right here represents the state where
Dialogue: 0,0:34:48.26,0:34:52.94,English,,0,0,0,,We've executed H,we finished executing H(1) in thread 1
Dialogue: 0,0:34:52.94,0:34:56.18,English,,0,0,0,,But we haven't yet executed any instructions in thread 2
Dialogue: 0,0:34:57.56,0:35:00.30,English,,0,0,0,,Ok so in general each one of these points represents
Dialogue: 0,0:35:01.98,0:35:05.08,English,,0,0,0,,Sort of the current progress of the program or the execution state
Dialogue: 0,0:35:06.06,0:35:11.02,English,,0,0,0,,So for example this state right here represents the state where thread 1
Dialogue: 0,0:35:11.34,0:35:13.60,English,,0,0,0,,Has completed a completed L1
Dialogue: 0,0:35:14.24,0:35:17.16,English,,0,0,0,,And thread 2 is completed S(2)
Dialogue: 0,0:35:22.30,0:35:28.16,English,,0,0,0,,And now the execution of a program is modeled as a transition from one state to the other
Dialogue: 0,0:35:28.78,0:35:33.66,English,,0,0,0,,And there's some,so from this and there's constraints on how
Dialogue: 0,0:35:34.82,0:35:39.00,English,,0,0,0,,On how these states can advance so
Dialogue: 0,0:35:39.74,0:35:41.62,English,,0,0,0,,From this state(L1, S2)
Dialogue: 0,0:35:42.56,0:35:50.10,English,,0,0,0,,Obviously time can't go backwards right so we can't go backwards like in this direction to the left and we can't go down
Dialogue: 0,0:35:50.78,0:35:53.48,English,,0,0,0,,Okay so we can only go to the right and up
Dialogue: 0,0:35:54.56,0:35:56.96,English,,0,0,0,,And since we're assuming that each instruction executes
Dialogue: 0,0:35:57.58,0:36:00.18,English,,0,0,0,,There's only one instruction executing at a time
Dialogue: 0,0:36:00.58,0:36:03.12,English,,0,0,0,,We can't go diagonally that would be two instructions
Dialogue: 0,0:36:03.62,0:36:05.26,English,,0,0,0,,All right so from (L1,S2)
Dialogue: 0,0:36:05.90,0:36:08.08,English,,0,0,0,,The next execution state is either
Dialogue: 0,0:36:09.46,0:36:15.26,English,,0,0,0,,Here if thread one execute or here if thread of thread to execute
Dialogue: 0,0:36:17.54,0:36:20.28,English,,0,0,0,,Okay so you can put all these together to form a trajectory
Dialogue: 0,0:36:20.92,0:36:24.02,English,,0,0,0,,Which characterizes one execution of the program
Dialogue: 0,0:36:25.86,0:36:32.76,English,,0,0,0,,Right and any feasible set of transitions from one state to the next corresponds to a feasible trajectory
Dialogue: 0,0:36:34.46,0:36:50.60,English,,0,0,0,,So for example H(1),L(1),U(1),H(2),L(2),S(1),T(1),U(2),S(2),T(2)
Dialogue: 0,0:36:51.42,0:36:52.58,English,,0,0,0,,That's a feasible
Dialogue: 0,0:36:55.20,0:36:56.52,English,,0,0,0,,That's a feasible trajectory
Dialogue: 0,0:36:57.58,0:37:06.38,English,,0,0,0,,And it's one possible it represents one possible execution or so one set of inter leavings for this program
Dialogue: 0,0:37:10.42,0:37:16.82,English,,0,0,0,,Now these L these three instructions L,U and S that operate on that manipulate count
Dialogue: 0,0:37:17.40,0:37:20.66,English,,0,0,0,,Form what we call a critical section with respect to count
Dialogue: 0,0:37:25.18,0:37:29.20,English,,0,0,0,,And the idea is that instructions inside
Dialogue: 0,0:37:29.54,0:37:36.50,English,,0,0,0,,These critical sections this with receivership with respect to the same global variable shouldn't be interleaved
Dialogue: 0,0:37:38.28,0:37:43.70,English,,0,0,0,,So we can capture this geometrically by taking the intersection of these critical sections
Dialogue: 0,0:37:44.48,0:37:47.18,English,,0,0,0,,To form what we call an unsafe region
Dialogue: 0,0:37:48.90,0:37:53.10,English,,0,0,0,,So in this an unsafe region is...
Dialogue: 0,0:37:53.66,0:38:01.66,English,,0,0,0,,The points within an unsafe region are those points in an execution where the critical sections are being or interleaved
Dialogue: 0,0:38:03.26,0:38:07.32,English,,0,0,0,,Okay so for this particular example there's four points within the unsafe region
Dialogue: 0,0:38:08.24,0:38:10.72,English,,0,0,0,,And if a trajectory ever touches one of those points
Dialogue: 0,0:38:10.72,0:38:13.70,English,,0,0,0,,Then we've interleaved critical section and we're going to get the wrong answer
Dialogue: 0,0:38:17.12,0:38:19.90,English,,0,0,0,,Okay so the idea is to try to stay out of these unsafe regions
Dialogue: 0,0:38:25.28,0:38:28.40,English,,0,0,0,,And if we do we say that trajectory is safe so
Dialogue: 0,0:38:29.50,0:38:31.96,English,,0,0,0,,Here's an example of a trajectory that's safe
Dialogue: 0,0:38:33.20,0:38:37.04,English,,0,0,0,,Now this is okay,right this point right here is not in the unsafe region
Dialogue: 0,0:38:37.82,0:38:40.62,English,,0,0,0,,Because we haven't executed we only executed H(1) here
Dialogue: 0,0:38:41.16,0:38:43.42,English,,0,0,0,,Remember a point corresponds to
Dialogue: 0,0:38:43.88,0:38:48.82,English,,0,0,0,,And it's the instruction that we've completed that instruction
Dialogue: 0,0:38:51.10,0:38:51.86,English,,0,0,0,,So then
Dialogue: 0,0:38:53.12,0:38:55.08,English,,0,0,0,,So here we're skirting the unsafe region
Dialogue: 0,0:38:55.08,0:38:58.88,English,,0,0,0,,But it's still okay,so this is a safe trajectory we'll get the right answer for this one
Dialogue: 0,0:39:00.00,0:39:00.82,English,,0,0,0,,However
Dialogue: 0,0:39:03.58,0:39:05.52,English,,0,0,0,,This trajectory is unsafe because it
Dialogue: 0,0:39:07.82,0:39:11.10,English,,0,0,0,,It enters the unsafe region at this point here
Dialogue: 0,0:39:12.66,0:39:20.40,English,,0,0,0,,And even though it quickly exited the there's an interleaving there that creates a potential for a correct answer
Dialogue: 0,0:39:27.54,0:39:31.50,English,,0,0,0,,Okay so the question is how do we guarantee a safe trajectory
Dialogue: 0,0:39:31.58,0:39:33.98,English,,0,0,0,,And this is the this is what we call synchronization
Dialogue: 0,0:39:34.00,0:39:39.67,English,,0,0,0,,So somehow we want to sort of configure the kernel
Dialogue: 0,0:39:40.58,0:39:43.10,English,,0,0,0,,So that'll never schedule an unsafe trajectory
Dialogue: 0,0:39:45.86,0:39:46.78,English,,0,0,0,,So how do we do that
Dialogue: 0,0:39:47.88,0:39:50.20,English,,0,0,0,,So somehow
Dialogue: 0,0:39:51.52,0:39:54.98,English,,0,0,0,,We we have to synchronize the execution of those threads
Dialogue: 0,0:39:55.66,0:40:02.44,English,,0,0,0,,And another way to think of this is that we need to guarantee mutually exclusive access to the critical sections
Dialogue: 0,0:40:03.22,0:40:10.48,English,,0,0,0,,All right so once the kernel begins,once the thread starts executing the first instruction is critical section
Dialogue: 0,0:40:10.88,0:40:16.14,English,,0,0,0,,We don't want it to be interrupted by another thread that has a similar critical section
Dialogue: 0,0:40:16.32,0:40:17.76,English,,0,0,0,,Okay we don't want it to be interrupted
Dialogue: 0,0:40:18.14,0:40:22.22,English,,0,0,0,,We don't want...one critical section with respect to a certain global variable
Dialogue: 0,0:40:23.16,0:40:29.36,English,,0,0,0,,To be interrupted by another thread that has all right that's currently within that same critical section okay
Dialogue: 0,0:40:30.62,0:40:31.50,English,,0,0,0,,Sorry yes question
Dialogue: 0,0:40:31.50,0:40:45.08,English,,0,0,0,,Seems unlikely for me that
Dialogue: 0,0:40:45.08,0:40:48.44,English,,0,0,0,,Okay so the question is how likely is it that you get a correct trajectory
Dialogue: 0,0:40:48.48,0:40:51.02,English,,0,0,0,,And it happens right you can run it sometimes you do
Dialogue: 0,0:40:51.54,0:40:55.20,English,,0,0,0,,It just depends usually it's wrong sometimes it's right
Dialogue: 0,0:40:57.96,0:41:03.92,English,,0,0,0,,And it just depends on how the kernel scheduled it and you can't assume any particular scheduling
Dialogue: 0,0:41:04.80,0:41:09.86,English,,0,0,0,,Right so if you say, if you want to claim that you would never get the right answer
Dialogue: 0,0:41:10.48,0:41:15.04,English,,0,0,0,,Then you're assuming that the kernel is always going to schedule the unsafe trajectory but
Dialogue: 0,0:41:15.68,0:41:18.72,English,,0,0,0,,You can't assume that in fact it doesn't sometimes you just get lucky
Dialogue: 0,0:41:23.70,0:41:29.96,English,,0,0,0,,And it turns out you have to call this function with a pretty big number in order to trip it up
Dialogue: 0,0:41:32.06,0:41:33.92,English,,0,0,0,,So the it makes sense right
Dialogue: 0,0:41:34.92,0:41:39.14,English,,0,0,0,,If usually what the kernel does is that
Dialogue: 0,0:41:40.30,0:41:42.28,English,,0,0,0,,I we can only schedule
Dialogue: 0,0:41:43.12,0:41:47.48,English,,0,0,0,,We can only reschedule a thread you know swap it out and schedule another thread in
Dialogue: 0,0:41:47.96,0:41:52.92,English,,0,0,0,,When there's some exception okay so that that passes control back to the kernel
Dialogue: 0,0:41:54.70,0:41:59.76,English,,0,0,0,,So these exceptions are in two forms either calling system making system calls
Dialogue: 0,0:41:59.96,0:42:03.38,English,,0,0,0,,So that'll trap into the kernel so that's a form of exception
Dialogue: 0,0:42:03.86,0:42:09.50,English,,0,0,0,,Or the timer interrupts goes off which transfers control back to the kernel
Dialogue: 0,0:42:10.36,0:42:14.88,English,,0,0,0,,So the timer is going off on intervals of like milliseconds
Dialogue: 0,0:42:16.44,0:42:20.76,English,,0,0,0,,Right so if we're just doing one iteration it in each thread
Dialogue: 0,0:42:20.94,0:42:26.10,English,,0,0,0,,When a thread gets executed the chances are very low that the timer is going to go off
Dialogue: 0,0:42:27.14,0:42:30.56,English,,0,0,0,,While that thread is executing you know it's its little loop
Dialogue: 0,0:42:32.86,0:42:35.12,English,,0,0,0,,But as we...and we're not making any system calls
Dialogue: 0,0:42:35.28,0:42:42.30,English,,0,0,0,,Right so there's nothing that, there's nothing...we're not passing control back into the kernel ourselves
Dialogue: 0,0:42:43.14,0:42:47.68,English,,0,0,0,,So the only way the kernel is going to get access is if the timer interrupts goes off
Dialogue: 0,0:42:48.86,0:42:51.28,English,,0,0,0,,So if we're doing a very small number of iterations
Dialogue: 0,0:42:52.22,0:42:57.00,English,,0,0,0,,The probability that you know say here's the timer interval it's going off at intervals like this
Dialogue: 0,0:42:58.10,0:43:01.86,English,,0,0,0,,Here this the probability we'd have to
Dialogue: 0,0:43:02.60,0:43:08.94,English,,0,0,0,,That's thread would have to been scheduled right before a timer interrupts will go off or to interrupt that one or two iterations
Dialogue: 0,0:43:09.86,0:43:11.36,English,,0,0,0,,So it turns out we have to schedule
Dialogue: 0,0:43:12.12,0:43:16.70,English,,0,0,0,,We have to call this function with a lot of within interrupts being fairly large
Dialogue: 0,0:43:17.28,0:43:22.52,English,,0,0,0,,So that the probability of the timer interrupts going off during that
Dialogue: 0,0:43:23.34,0:43:28.60,English,,0,0,0,,During that during that loop but gets increasingly large,that makes sense
Dialogue: 0,0:43:36.16,0:43:39.26,English,,0,0,0,,So the classic solution from this comes from the early 1960s
Dialogue: 0,0:43:39.26,0:43:46.38,English,,0,0,0,,One of the most famous computer scientists is a dutchman named as Edsger Dijkstra
Dialogue: 0,0:43:47.38,0:43:53.38,English,,0,0,0,,And he came up with the classical first solution to this problem which is what we're going to look at
Dialogue: 0,0:43:54.18,0:43:57.60,English,,0,0,0,,Okay and it's still the first it's it's fundamental and very general purpose
Dialogue: 0,0:43:57.60,0:44:01.76,English,,0,0,0,,And there's been many iterations and variations on this idea
Dialogue: 0,0:44:02.74,0:44:08.00,English,,0,0,0,,But semaphores were the first and classic solution which we'll look at
Dialogue: 0,0:44:11.38,0:44:17.58,English,,0,0,0,,Okay so a semaphore is a non-negative global integer
Dialogue: 0,0:44:17.68,0:44:24.14,English,,0,0,0,,That's used as a synchronization variable by to kernel functions called P and V
Dialogue: 0,0:44:27.12,0:44:28.98,English,,0,0,0,,Our two system calls called P and V
Dialogue: 0,0:44:32.38,0:44:36.60,English,,0,0,0,,These P and V are correspond to the dutch words
Dialogue: 0,0:44:38.74,0:44:43.72,English,,0,0,0,,But we just call them P and V right you just have to learn what they do
Dialogue: 0,0:44:46.74,0:44:51.06,English,,0,0,0,,So each of these takes as an argument a semaphore
Dialogue: 0,0:44:52.84,0:44:56.82,English,,0,0,0,,And the P operation has the following semantics
Dialogue: 0,0:44:58.28,0:45:00.54,English,,0,0,0,,If s is nonzero
Dialogue: 0,0:45:02.30,0:45:04.96,English,,0,0,0,,Then decrement it by 1 and return immediately
Dialogue: 0,0:45:07.68,0:45:10.60,English,,0,0,0,,And this test if it that it's nonzero
Dialogue: 0,0:45:11.38,0:45:13.16,English,,0,0,0,,And the decrement occur atomically
Dialogue: 0,0:45:13.92,0:45:15.54,English,,0,0,0,,Okay so they'll never be interrupted
Dialogue: 0,0:45:20.28,0:45:21.96,English,,0,0,0,,However if s is zero
Dialogue: 0,0:45:24.10,0:45:25.58,English,,0,0,0,,Then suspend this thread
Dialogue: 0,0:45:26.84,0:45:29.40,English,,0,0,0,,Until s becomes nonzero
Dialogue: 0,0:45:31.10,0:45:34.26,English,,0,0,0,,And that thread then is restarted by a V operation
Dialogue: 0,0:45:36.94,0:45:41.86,English,,0,0,0,,Okay so if p if the semaphore is zero,P just blocks
Dialogue: 0,0:45:42.32,0:45:46.74,English,,0,0,0,,It just gets suspended until it gets restarted by a V operation
Dialogue: 0,0:45:48.10,0:45:49.44,English,,0,0,0,,And then after it restarts
Dialogue: 0,0:45:50.18,0:45:57.20,English,,0,0,0,,The P operation now can decrement s by one and return control to the caller
Dialogue: 0,0:46:03.26,0:46:06.00,English,,0,0,0,,Okay the V operation just increments s by one
Dialogue: 0,0:46:06.92,0:46:13.60,English,,0,0,0,,And this increment unlike that count++ that we looked at just looked at this that increment occurs atomically
Dialogue: 0,0:46:14.60,0:46:16.12,English,,0,0,0,,Okay so it can never be interrupted
Dialogue: 0,0:46:18.02,0:46:19.98,English,,0,0,0,,And then after it increments s
Dialogue: 0,0:46:21.06,0:46:24.84,English,,0,0,0,,It checks to see if there's any threads that are blocked in a P operation
Dialogue: 0,0:46:25.26,0:46:30.66,English,,0,0,0,,So you can think of the kernel just keeps a queue of threads that are blocked in a P operation
Dialogue: 0,0:46:31.40,0:46:37.38,English,,0,0,0,,And the V operation after it increments s it checks that queue for any threads that were blocked
Dialogue: 0,0:46:38.50,0:46:41.44,English,,0,0,0,,Because when they did the P operation the semaphore was zero
Dialogue: 0,0:46:43.06,0:46:47.32,English,,0,0,0,,And then it restarts exactly one of those threads in some indeterminate order
Dialogue: 0,0:46:47.44,0:46:50.68,English,,0,0,0,,Okay in some order that you can't,you can't assume
Dialogue: 0,0:46:51.10,0:46:54.90,English,,0,0,0,,It just picks one using some selection algorithm
Dialogue: 0,0:46:56.38,0:47:05.64,English,,0,0,0,,And it and then it it it unblocks the suspended  the suspended process
Dialogue: 0,0:47:07.88,0:47:11.16,English,,0,0,0,,Okay which then completes its P operation by decrementing yes
Dialogue: 0,0:47:17.62,0:47:22.68,English,,0,0,0,,Okay this seems like really simple but it can be kind of hard to get your head around the first time you see it
Dialogue: 0,0:47:23.62,0:47:26.64,English,,0,0,0,,So are there any questions about P and V
Dialogue: 0,0:47:34.72,0:47:41.62,English,,0,0,0,,Okay so that the key idea that these definitions of P and V
Dialogue: 0,0:47:42.40,0:47:46.08,English,,0,0,0,,Is that it imposes an invariant on the semaphores
Dialogue: 0,0:47:46.84,0:47:50.68,English,,0,0,0,,Called the semaphore invariant which is s which is that for a semaphore s
Dialogue: 0,0:47:52.66,0:47:55.10,English,,0,0,0,,Being operated on by P and V operations
Dialogue: 0,0:47:55.64,0:47:57.52,English,,0,0,0,,s is always greater than or equal to zero
Dialogue: 0,0:48:01.12,0:48:02.66,English,,0,0,0,,And that doesn't seem very exciting
Dialogue: 0,0:48:03.82,0:48:11.40,English,,0,0,0,,But it turns out this is a very useful property that will allow us to enforce mutual exclusion on these critical sections
Dialogue: 0,0:48:13.64,0:48:18.24,English,,0,0,0,,So the P and V operations are provided by P threads
Dialogue: 0,0:48:19.24,0:48:21.28,English,,0,0,0,,In the form of three functions
Dialogue: 0,0:48:21.42,0:48:25.50,English,,0,0,0,,There's a sem_init functions which initializes the semaphore to some value
Dialogue: 0,0:48:26.22,0:48:31.92,English,,0,0,0,,Okay so semaphore is can be initialized to any value greater than or equal to zero
Dialogue: 0,0:48:34.04,0:48:39.86,English,,0,0,0,,sem_wait is the P operation and sem_post is the V operation
Dialogue: 0,0:48:41.88,0:48:44.38,English,,0,0,0,,Okay and because I'm old-school
Dialogue: 0,0:48:45.38,0:48:51.48,English,,0,0,0,,I provide wrapper functions for those in your cssapp.h file called P and V
Dialogue: 0,0:48:52.72,0:48:53.86,English,,0,0,0,,Okay it's also more compact to
Dialogue: 0,0:49:00.20,0:49:07.02,English,,0,0,0,,Okay so recall a buggy program called badcnt.c
Dialogue: 0,0:49:07.80,0:49:11.76,English,,0,0,0,,Which was giving us the wrong answers for count
Dialogue: 0,0:49:13.30,0:49:15.82,English,,0,0,0,,So how do we use semaphores to fix this program
Dialogue: 0,0:49:18.92,0:49:21.46,English,,0,0,0,,So the basic idea is to create a semaphore
Dialogue: 0,0:49:22.20,0:49:23.86,English,,0,0,0,,Which is initialized to 1
Dialogue: 0,0:49:25.70,0:49:29.80,English,,0,0,0,,And so by definition we'll call any semaphore which is initialized to 1
Dialogue: 0,0:49:29.82,0:49:33.36,English,,0,0,0,,That's used for to provide mutual exclusion we'll call that a mutex
Dialogue: 0,0:49:34.98,0:49:38.06,English,,0,0,0,,Okay and this goes back to the early Dijkstra papers
Dialogue: 0,0:49:39.62,0:49:47.62,English,,0,0,0,,So we'll associate a unique mutex initialize to 1 for each shared variable in our program
Dialogue: 0,0:49:48.98,0:49:53.80,English,,0,0,0,,So in this case count,we have count,so we have one shared variable that we're concerned about
Dialogue: 0,0:49:54.42,0:49:57.76,English,,0,0,0,,So we'll create one new text that will call mutex
Dialogue: 0,0:49:59.00,0:50:03.48,English,,0,0,0,,And then you surround the critical section with respect to count
Dialogue: 0,0:50:04.20,0:50:10.94,English,,0,0,0,,With P, you call P then you execute the critical section and then you call V
Dialogue: 0,0:50:15.44,0:50:19.20,English,,0,0,0,,Now there's some terminology we'll use when we talk about semaphores
Dialogue: 0,0:50:20.08,0:50:25.26,English,,0,0,0,,So a binary semaphore is the semaphore whose value is always 0 1
Dialogue: 0,0:50:25.72,0:50:31.08,English,,0,0,0,,And then a mutex is this sort is a binary semaphore that's being used to for mutual exclusion
Dialogue: 0,0:50:33.42,0:50:35.44,English,,0,0,0,,The P operation is called locking the mutex
Dialogue: 0,0:50:37.74,0:50:41.32,English,,0,0,0,,Will refer to a V is sometimes unlocking or releasing the mutex
Dialogue: 0,0:50:42.52,0:50:50.38,English,,0,0,0,,And if a process is holding the mutex then that means it's been locked but not released
Dialogue: 0,0:50:53.26,0:50:56.80,English,,0,0,0,,So mutexes and binary semaphore s are always initialized to 1
Dialogue: 0,0:50:57.20,0:51:02.98,English,,0,0,0,,Accounting semaphore and the mutex is used for mutual exclusion
Dialogue: 0,0:51:03.00,0:51:06.58,English,,0,0,0,,But you can also use semaphores to count sort of events in the system
Dialogue: 0,0:51:07.80,0:51:15.98,English,,0,0,0,,And often times for those accounting semaphores have sort of non values that are greater than 1
Dialogue: 0,0:51:19.74,0:51:21.30,English,,0,0,0,,Okay so for mutual exclusion
Dialogue: 0,0:51:23.66,0:51:28.94,English,,0,0,0,,We'll to fix our program we create a new program called goodcnt.c
Dialogue: 0,0:51:30.46,0:51:32.70,English,,0,0,0,,And here we initialize a mutex
Dialogue: 0,0:51:33.72,0:51:36.40,English,,0,0,0,,Or we create a mutex and initialize it to 1
Dialogue: 0,0:51:38.72,0:51:43.88,English,,0,0,0,,And then we surround the critical section which is the 3 assembly language instructions
Dialogue: 0,0:51:44.36,0:51:47.68,English,,0,0,0,,Embodied that implement this cnt++ instruction
Dialogue: 0,0:51:48.42,0:51:51.36,English,,0,0,0,,We surround it with a P followed by it by a V
Dialogue: 0,0:51:54.28,0:51:57.24,English,,0,0,0,,And if we do that we always get the right answer
Dialogue: 0,0:52:00.52,0:52:03.46,English,,0,0,0,,But you know P&V are system calls
Dialogue: 0,0:52:03.99,0:52:05.46,English,,0,0,0,,So there's overhead associated with these
Dialogue: 0,0:52:05.46,0:52:06.28,English,,0,0,0,,So they're not free
Dialogue: 0,0:52:06.48,0:52:11.84,English,,0,0,0,,In fact they're orders of magnitude this program runs two orders of magnitude slower than the incorrect buggy version
Dialogue: 0,0:52:13.56,0:52:15.60,English,,0,0,0,,All right so so why do these mutex work
Dialogue: 0,0:52:19.98,0:52:26.34,English,,0,0,0,,So here we've got a progress graph now where we've decorated a program with P and V operations
Dialogue: 0,0:52:26.34,0:52:33.86,English,,0,0,0,,So we put the P before the critical section we execute the critical section and then we call V
Dialogue: 0,0:52:35.96,0:52:39.22,English,,0,0,0,,And now if you were to look you remember P and V,P increments
Dialogue: 0,0:52:40.52,0:52:44.72,English,,0,0,0,,The sum of P decrement the semaphore V increments of semaphore
Dialogue: 0,0:52:45.68,0:52:53.54,English,,0,0,0,,So if you were just to look at the value of that semaphore for every point  in the execution state space
Dialogue: 0,0:52:54.90,0:52:57.94,English,,0,0,0,,You'd get these,you'd get these values
Dialogue: 0,0:52:57.96,0:53:03.12,English,,0,0,0,,So here we initialize the semaphore at the origin we initialized it to 1
Dialogue: 0,0:53:03.14,0:53:10.16,English,,0,0,0,,So the value of a semaphore at the origin is 1
Dialogue: 0,0:53:11.38,0:53:13.10,English,,0,0,0,,And let's say we just move along
Dialogue: 0,0:53:13.12,0:53:14.78,English,,0,0,0,,So we're just executing thread 1
Dialogue: 0,0:53:14.78,0:53:17.18,English,,0,0,0,,So after H(1) the semaphore is 1
Dialogue: 0,0:53:19.02,0:53:25.04,English,,0,0,0,,We do the P the semaphore is 1,so P just decrement sit and it proceeds
Dialogue: 0,0:53:25.50,0:53:28.76,English,,0,0,0,,So now the semaphore value becomes 0
Dialogue: 0,0:53:29.56,0:53:33.02,English,,0,0,0,,And it remains zero until we execute the V
Dialogue: 0,0:53:33.72,0:53:35.60,English,,0,0,0,,And when we finished executing the V
Dialogue: 0,0:53:36.44,0:53:38.38,English,,0,0,0,,The semaphore now is 1 again
Dialogue: 0,0:53:40.10,0:53:42.10,English,,0,0,0,,Okay so if we go through a similar reasoning
Dialogue: 0,0:53:42.90,0:53:48.18,English,,0,0,0,,If we look at the trajectory to get to any point in this state space
Dialogue: 0,0:53:48.22,0:53:52.34,English,,0,0,0,,So let's say this point right here
Dialogue: 0,0:53:54.86,0:54:02.78,English,,0,0,0,,So to get there we could execute thread 1 up to this point  finish the L(1)
Dialogue: 0,0:54:04.10,0:54:06.02,English,,0,0,0,,And then execute H(2)
Dialogue: 0,0:54:07.38,0:54:10.68,English,,0,0,0,,And then do the at this point the semaphore is 0
Dialogue: 0,0:54:13.00,0:54:17.04,English,,0,0,0,,And then P decrements the semaphore so now it's -1
Dialogue: 0,0:54:17.86,0:54:20.38,English,,0,0,0,,But that's impossible that can't happen
Dialogue: 0,0:54:21.04,0:54:25.62,English,,0,0,0,,Because P blocks, remember if the semaphore is 0 P blocks
Dialogue: 0,0:54:26.36,0:54:27.28,English,,0,0,0,,It doesn't decrement
Dialogue: 0,0:54:28.40,0:54:35.70,English,,0,0,0,,It okay so the semantics of the P operation prohibits this transition
Dialogue: 0,0:54:36.34,0:54:43.06,English,,0,0,0,,It prohibits this transition to the state where the semaphore is zero to a state where it would be -1
Dialogue: 0,0:54:46.78,0:54:53.82,English,,0,0,0,,And so it creates what we call a forbidden region so these points in the state space
Dialogue: 0,0:54:54.84,0:55:01.20,English,,0,0,0,,Where the semaphore would have a value of -1 are are infeasible
Dialogue: 0,0:55:01.92,0:55:06.30,English,,0,0,0,,That can never be reached by the definition of P and V
Dialogue: 0,0:55:07.92,0:55:13.34,English,,0,0,0,,Ok so this forms a forbidden region around the unsafe region
Dialogue: 0,0:55:13.88,0:55:20.92,English,,0,0,0,,And in doing so provides mutually exclusive access to the critical sections in each thread
Dialogue: 0,0:55:22.04,0:55:22.58,English,,0,0,0,,Okay so if
Dialogue: 0,0:55:25.50,0:55:33.10,English,,0,0,0,,So this is the fundamental reason why P(s) and V(s)  can be used to provide mutually exclusive access
Dialogue: 0,0:55:36.96,0:55:37.98,English,,0,0,0,,So many questions on this
Dialogue: 0,0:55:41.20,0:55:43.60,English,,0,0,0,,I explained it so clearly that there's no questions
Dialogue: 0,0:55:48.50,0:55:54.02,English,,0,0,0,,All right good well you get to go...you get to leave early then work on your malloc lab
Dialogue: 0,0:55:54.86,0:55:55.52,English,,0,0,0,,So
Dialogue: 0,0:55:57.56,0:55:58.80,English,,0,0,0,,All right so
Dialogue: 0,0:55:59.64,0:56:04.04,English,,0,0,0,,We'll see you Monday we're going to look at sort of some advanced topics
Dialogue: 0,0:56:04.06,0:56:06.92,English,,0,0,0,,This was like, first introduction to synchronization
Dialogue: 0,0:56:07.36,0:56:12.10,English,,0,0,0,,On Tuesday we'll look at more advanced topics in synchronization in ways
Dialogue: 0,0:56:12.20,0:56:13.96,English,,0,0,0,,Ways that you can use semaphores for to
Dialogue: 0,0:56:14.50,0:56:19.20,English,,0,0,0,,Provide other more interests other interesting kinds of synchronization for your programs
Dialogue: 0,0:56:19.76,0:56:20.54,English,,0,0,0,,Okay
