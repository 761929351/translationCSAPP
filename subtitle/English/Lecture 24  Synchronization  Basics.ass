[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Audio File: ../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video File: ../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 640
Active Line: 650
Video Position: 101415

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.90,0:00:04.74,csapp,,0,0,0,, all right well good afternoon everybody good to see you welcome
Dialogue: 0,0:00:06.54,0:00:09.10,csapp,,0,0,0,, welcome to all those students watching on video as well
Dialogue: 0,0:00:11.68,0:00:17.18,csapp,,0,0,0,, before we start we were talking about joinable and detached threads
Dialogue: 0,0:00:17.36,0:00:23.96,csapp,,0,0,0,,and you asked the question about why you would ever want to have threads running in non detached mode
Dialogue: 0,0:00:24.00,0:00:27.12,csapp,,0,0,0,, you know why you'd ever run in want to have him running joinable
Dialogue: 0,0:00:27.74,0:00:32.04,csapp,,0,0,0,,and I didn't give you a very good answer so I want to try to to answer that for you better 
Dialogue: 0,0:00:33.86,0:00:39.64,csapp,,0,0,0,,turns out there's an important class of sort of parallel programming 
Dialogue: 0,0:00:40.02,0:00:43.60,csapp,,0,0,0,,there's a there's an important parallel programming model called fork and join 
Dialogue: 0,0:00:44.38,0:00:47.84,csapp,,0,0,0,,where program consists of a series of phases
Dialogue: 0,0:00:50.56,0:00:56.56,csapp,,0,0,0,, in each phase in each phase you have a worker or a master sorry 
Dialogue: 0,0:00:57.66,0:01:00.54,csapp,,0,0,0,,and it creates a bunch of worker threads 
Dialogue: 0,0:01:05.90,0:01:10.12,csapp,,0,0,0,,and then each of those worker threads solve some part of the problem for that phase 
Dialogue: 0,0:01:10.48,0:01:15.02,csapp,,0,0,0,,like some maybe you take your data structure and you break it up into chunks 
Dialogue: 0,0:01:15.04,0:01:19.82,csapp,,0,0,0,,and then each thread updates the its own chunk of that data structure 
Dialogue: 0,0:01:21.54,0:01:28.20,csapp,,0,0,0,,but for whatever reason the the master then has to wait for the worker threads to finish before it can go on to the next phase
Dialogue: 0,0:01:28.94,0:01:32.10,csapp,,0,0,0,, so it it does adjourn so this is called the fork
Dialogue: 0,0:01:33.26,0:01:35.60,csapp,,0,0,0,, and then it waits for all the threads to finish 
Dialogue: 0,0:01:37.32,0:01:40.00,csapp,,0,0,0,, by doing a join okay so this is called 
Dialogue: 0,0:01:41.20,0:01:43.50,csapp,,0,0,0,,this is called the fork and this is called the join 
Dialogue: 0,0:01:44.32,0:01:47.26,csapp,,0,0,0,,and only when all of the threads have finished 
Dialogue: 0,0:01:47.96,0:01:51.28,csapp,,0,0,0,,can it go and do the next do the next phase
Dialogue: 0,0:01:56.12,0:02:00.40,csapp,,0,0,0,,okay so this this model is really important in things like scientific computing where 
Dialogue: 0,0:02:01.22,0:02:06.76,csapp,,0,0,0,,you might you're simulating some domain you're simulating nature 
Dialogue: 0,0:02:07.40,0:02:10.76,csapp,,0,0,0,,so you represent that as some domain like maybe you're simulating 
Dialogue: 0,0:02:11.36,0:02:15.04,csapp,,0,0,0,,how heat flows over a plate you know metal plate 
Dialogue: 0,0:02:15.90,0:02:20.20,csapp,,0,0,0,,and so you might might have these workers 
Dialogue: 0,0:02:21.30,0:02:24.04,csapp,,0,0,0,, you might partition the domain amongst a set of those workers 
Dialogue: 0,0:02:24.84,0:02:27.90,csapp,,0,0,0,,and then each one of these phases is a time step
Dialogue: 0,0:02:28.94,0:02:34.24,csapp,,0,0,0,,and then so once once all the workers have finished a time step then they can advance to the next time step 
Dialogue: 0,0:02:36.30,0:02:39.00,csapp,,0,0,0,,and so sorry I don't know why I didn't think of it
Dialogue: 0,0:02:39.52,0:02:41.76,csapp,,0,0,0,, that's a that's an important reason why you'd want this 
Dialogue: 0,0:02:44.04,0:02:45.16,csapp,,0,0,0,,okay so we saw 
Dialogue: 0,0:02:46.36,0:02:50.30,csapp,,0,0,0,,we've seen the threaded threaded programs are are nice 
Dialogue: 0,0:02:50.30,0:02:53.04,csapp,,0,0,0,,because you they you can share all the global variables 
Dialogue: 0,0:02:55.02,0:02:58.54,csapp,,0,0,0,,but this the sharing can can have unintended consequences 
Dialogue: 0,0:02:59.36,0:03:02.98,csapp,,0,0,0,,so somehow we need a mechanism where we can control 
Dialogue: 0,0:03:02.98,0:03:07.08,csapp,,0,0,0,,how the flows of each individual thread are interleaved 
Dialogue: 0,0:03:08.28,0:03:12.52,csapp,,0,0,0,,so that bad things don't happen when we share data structures
Dialogue: 0,0:03:12.78,0:03:17.74,csapp,,0,0,0,,okay so this this process of controlling the the interleaving is called synchronization 
Dialogue: 0,0:03:17.74,0:03:24.68,csapp,,0,0,0,,so we're going to look at techniques that you can use to write correct threaded programs by properly synchronizing them 
Dialogue: 0,0:03:27.28,0:03:29.56,csapp,,0,0,0,,now first though we need to have a clear idea 
Dialogue: 0,0:03:30.10,0:03:34.78,csapp,,0,0,0,,so sharing is the issue right if we have threads that aren't sharing any resources 
Dialogue: 0,0:03:35.90,0:03:37.08,csapp,,0,0,0,,then there's no problem right 
Dialogue: 0,0:03:37.16,0:03:42.02,csapp,,0,0,0,,that we saw this when we looked at it processes there's no shared data structures with processes 
Dialogue: 0,0:03:42.72,0:03:49.28,csapp,,0,0,0,,so we process these just run independently we don't really care how they're interleaved note no worries okay
Dialogue: 0,0:03:49.80,0:03:54.14,csapp,,0,0,0,,but as soon as they introduce sharing then then we have to be careful 
Dialogue: 0,0:03:56.24,0:04:00.58,csapp,,0,0,0,, okay so to understand how to synchronize threads we first need to have a clear idea
Dialogue: 0,0:04:01.02,0:04:05.20,csapp,,0,0,0,, of of what we mean by sharing in in threaded C programs 
Dialogue: 0,0:04:06.54,0:04:13.96,csapp,,0,0,0,,so the the answer is not as simple as global variables are shared and stack variables are not shared 
Dialogue: 0,0:04:18.70,0:04:23.66,csapp,,0,0,0,,okay so with instead what we X is shared 
Dialogue: 0,0:04:23.66,0:04:28.50,csapp,,0,0,0,,if and only if multiple threads reference some instance so that that variable X  all right 
Dialogue: 0,0:04:29.51,0:04:34.00,csapp,,0,0,0,,so if only one thread is accessing a particular variable 
Dialogue: 0,0:04:35.64,0:04:37.06,csapp,,0,0,0,,then it's it's not shared 
Dialogue: 0,0:04:38.26,0:04:38.76,csapp,,0,0,0,,okay so 
Dialogue: 0,0:04:40.32,0:04:45.24,csapp,,0,0,0,,in order to know exactly what we mean by shared we need to answer three questions 
Dialogue: 0,0:04:46.00,0:04:48.70,csapp,,0,0,0,, okay first what is the memory model for threads 
Dialogue: 0,0:04:50.06,0:04:53.38,csapp,,0,0,0,,okay second how are instances of variables mapped to memory 
Dialogue: 0,0:04:55.24,0:05:00.35,csapp,,0,0,0,,and then and then third how many threads might be referencing those the instances of those variables
Dialogue: 0,0:05:00.64,0:05:03.84,csapp,,0,0,0,,okay so we'll look at each of those now in turn each of those three questions
Dialogue: 0,0:05:05.62,0:05:07.48,csapp,,0,0,0,,okay so first is that the memory model
Dialogue: 0,0:05:10.32,0:05:15.23,csapp,,0,0,0,,the conceptual model is a little bit different from the the operational model the way it really works
Dialogue: 0,0:05:15.56,0:05:16.78,csapp,,0,0,0,,okay so conceptually 
Dialogue: 0,0:05:17.42,0:05:21.40,csapp,,0,0,0,,we have multiple threads that run in the context of a single process 
Dialogue: 0,0:05:22.38,0:05:26.90,csapp,,0,0,0,,okay and some of that context is shared and some of its not shared 
Dialogue: 0,0:05:27.02,0:05:35.30,csapp,,0,0,0,,so each thread has its own separate thread ID,stack,stack pointer,program counter,condition codes,general-purpose registers 
Dialogue: 0,0:05:36.60,0:05:43.78,csapp,,0,0,0,,and then they all share the remaining process context which is data structures that the kernel maintains 
Dialogue: 0,0:05:44.34,0:05:53.74,csapp,,0,0,0,,for the threads the virtual data structures to support the virtual memory system open files install signal handlers  and so forth 
Dialogue: 0,0:05:55.24,0:05:59.24,csapp,,0,0,0,,so that's the conceptual model and if that were that if that were really enforced 
Dialogue: 0,0:05:59.26,0:06:01.36,csapp,,0,0,0,,it would be nice it would make things simpler for us
Dialogue: 0,0:06:01.42,0:06:05.60,csapp,,0,0,0,,but unfortunately in real life this model is not strictly enforced
Dialogue: 0,0:06:07.30,0:06:13.00,csapp,,0,0,0,,now although register values are really separate right the kernel maintains separate context for the all the registers 
Dialogue: 0,0:06:13.02,0:06:14.42,csapp,,0,0,0,,so that that part is good 
Dialogue: 0,0:06:15.72,0:06:18.46,csapp,,0,0,0,,but since the threads share the the address space 
Dialogue: 0,0:06:18.58,0:06:24.88,csapp,,0,0,0,,a thread can access the the memory the stack one thread can access the stack of an another thread 
Dialogue: 0,0:06:25.18,0:06:30.38,csapp,,0,0,0,,okay so although conceptually these stacks are separate and distinct and 
Dialogue: 0,0:06:30.94,0:06:32.76,csapp,,0,0,0,,in private they're really not 
Dialogue: 0,0:06:36.56,0:06:38.18,csapp,,0,0,0,,and so this can create some problems
Dialogue: 0,0:06:38.18,0:06:42.28,csapp,,0,0,0,, so here's an example of that we'll come back to later
Dialogue: 0,0:06:42.96,0:06:47.88,csapp,,0,0,0,,of how this one thread can access the stack of another thread 
Dialogue: 0,0:06:48.54,0:06:51.54,csapp,,0,0,0,,so here we're defining a global variable called pointer 
Dialogue: 0,0:06:52.62,0:06:54.10,csapp,,0,0,0,,which is a char **
Dialogue: 0,0:06:55.26,0:07:01.62,csapp,,0,0,0,,and then in the main routine on were declaring a local variable called messages which contains 
Dialogue: 0,0:07:02.32,0:07:05.30,csapp,,0,0,0,,it's a two element array which contains a couple strings 
Dialogue: 0,0:07:07.20,0:07:11.18,csapp,,0,0,0,,which these will be printed out by by the threads that we're going to create 
Dialogue: 0,0:07:12.22,0:07:17.28,csapp,,0,0,0,,and then we assign the global pointer to the vet to the address of the array messages 
Dialogue: 0,0:07:17.92,0:07:21.16,csapp,,0,0,0,,okay so now pointer points to messages 
Dialogue: 0,0:07:22.66,0:07:25.56,csapp,,0,0,0,,and then we create in a loop we create two threads 
Dialogue: 0,0:07:27.66,0:07:30.76,csapp,,0,0,0,,each of which executes this routine called thread 
Dialogue: 0,0:07:31.64,0:07:34.24,csapp,,0,0,0,,and and we're passing an argument
Dialogue: 0,0:07:35.00,0:07:41.94,csapp,,0,0,0,,so the P threads will assign a thread ID but in this case we're going to assign our own local thread ID 
Dialogue: 0,0:07:42.16,0:07:43.58,csapp,,0,0,0,, by passing this loop index
Dialogue: 0,0:07:44.32,0:07:47.66,csapp,,0,0,0,, okay so this is an example we talked about this last time
Dialogue: 0,0:07:49.24,0:07:51.76,csapp,,0,0,0,, it's it's kind of it's this is perfectly okay there's no race 
Dialogue: 0,0:07:52.38,0:07:58.82,csapp,,0,0,0,, but it's it's a little weird because we're going to take this index  I and cast it to a generic pointer
Dialogue: 0,0:08:03.22,0:08:07.02,csapp,,0,0,0,,okay and then after we create these threads then we'll exit the main thread 
Dialogue: 0,0:08:09.44,0:08:17.08,csapp,,0,0,0,,now each the thread routine dereferences its argument  to get the local the local thread ID 
Dialogue: 0,0:08:17.96,0:08:21.40,csapp,,0,0,0,,and then it it declares a static variable count 
Dialogue: 0,0:08:21.42,0:08:25.68,csapp,,0,0,0,,that we're going to use to count how many times this thread routine is called inside of a thread 
Dialogue: 0,0:08:27.38,0:08:33.66,csapp,,0,0,0,,and then it just prints a simple message from identifying that giving the local thread ID 
Dialogue: 0,0:08:35.04,0:08:40.42,csapp,,0,0,0,, and then the message indexed by myid
Dialogue: 0,0:08:40.90,0:08:42.90,csapp,,0,0,0,,so pointer points to messages 
Dialogue: 0,0:08:43.00,0:08:46.40,csapp,,0,0,0,,so thread zero will print hello from foo 
Dialogue: 0,0:08:47.32,0:08:50.44,csapp,,0,0,0,,and thread 1 will print hello from bar 
Dialogue: 0,0:08:51.86,0:08:55.92,csapp,,0,0,0,,and then and then we increment the pre increment the counter variable
Dialogue: 0,0:08:58.80,0:08:59.46,csapp,,0,0,0,,okay so 
Dialogue: 0,0:09:02.36,0:09:07.62,csapp,,0,0,0,,although it doesn't you wouldn't you would it looks like we're accessing this global variable pointer 
Dialogue: 0,0:09:08.02,0:09:14.46,csapp,,0,0,0,,but since that was assigned to be the address of the local variable on the main the main thread stack 
Dialogue: 0,0:09:15.10,0:09:23.72,csapp,,0,0,0,, we've got this these peer threads accessing local variables on the main thread stack okay 
Dialogue: 0,0:09:25.04,0:09:28.22,csapp,,0,0,0,,so that I just this is not it you never want to do this as a very bad practice 
Dialogue: 0,0:09:28.22,0:09:30.96,csapp,,0,0,0,,but I it's a kind of thing that can happen sometimes 
Dialogue: 0,0:09:33.84,0:09:39.28,csapp,,0,0,0,,by accident you know if you forget that pointer actually was assigned to you know some-some stack address 
Dialogue: 0,0:09:41.08,0:09:46.60,csapp,,0,0,0,,okay so that so the second question that is how do we map variable instances to memory
Dialogue: 0,0:09:47.10,0:09:50.16,csapp,,0,0,0,,now we looked at this when we when we studied linking 
Dialogue: 0,0:09:50.16,0:09:54.78,csapp,,0,0,0,,but let's let's just review this quickly again to make sure that it's clear to you 
Dialogue: 0,0:09:56.80,0:10:01.38,csapp,,0,0,0,,so global variables are variables that are referenced outside of a function 
Dialogue: 0,0:10:03.00,0:10:08.08,csapp,,0,0,0,,and virtual memory the linker when it does symbol resolution make sure that 
Dialogue: 0,0:10:08.08,0:10:12.50,csapp,,0,0,0,,there's exactly one instance of every global variable in virtual memory
Dialogue: 0,0:10:16.50,0:10:20.14,csapp,,0,0,0,,now local variables are declared on the stack inside of a function 
Dialogue: 0,0:10:23.26,0:10:24.94,csapp,,0,0,0,,without the static attribute 
Dialogue: 0,0:10:26.28,0:10:32.46,csapp,,0,0,0,,and so in this case each the stack for each thread will contain one instance of that local variable
Dialogue: 0,0:10:37.60,0:10:37.94,csapp,,0,0,0,,now 
Dialogue: 0,0:10:39.30,0:10:42.70,csapp,,0,0,0,,if variables are declared inside of a function with the static attribute
Dialogue: 0,0:10:44.28,0:10:49.06,csapp,,0,0,0,,then the scope of that variable is limited to that function meaning no other function can access it 
Dialogue: 0,0:10:50.56,0:10:55.66,csapp,,0,0,0,,but that static variable is stored along with all the other local variables 
Dialogue: 0,0:10:55.70,0:11:04.14,csapp,,0,0,0,,so there's any static variable declared inside of a function has exactly one instance in in memory 
Dialogue: 0,0:11:04.96,0:11:10.66,csapp,,0,0,0,,and if you were to have say multiple functions that declared the same a static variable with the same name 
Dialogue: 0,0:11:11.30,0:11:14.44,csapp,,0,0,0,,the compiler would would disambiguate those somehow 
Dialogue: 0,0:11:14.44,0:11:17.24,csapp,,0,0,0,,it would it would append some kind of unique
Dialogue: 0,0:11:19.10,0:11:20.80,csapp,,0,0,0,, it would somehow make that name unique 
Dialogue: 0,0:11:24.48,0:11:30.14,csapp,,0,0,0,,okay so what recall how all these different types of variable instances are mapped into memory
Dialogue: 0,0:11:31.86,0:11:35.38,csapp,,0,0,0,,okay pointer is a global variable 
Dialogue: 0,0:11:35.38,0:11:40.16,csapp,,0,0,0,,so there's one instance of pointer in the address space 
Dialogue: 0,0:11:42.72,0:11:45.56,csapp,,0,0,0,,and it's stored in the in the data segment
Dialogue: 0,0:11:50.54,0:11:57.40,csapp,,0,0,0,,I I and messages are examples of local variables to Maine 
Dialogue: 0,0:11:58.44,0:12:05.12,csapp,,0,0,0,,so there's one instance of these stored on the stack of Maine stack 
Dialogue: 0,0:12:06.22,0:12:12.08,csapp,,0,0,0,,and we'll denote those with this notation we'll say variable i
Dialogue: 0,0:12:12.70,0:12:17.04,csapp,,0,0,0,,  I dot M means variable I is stored on main stack 
Dialogue: 0,0:12:18.32,0:12:20.78,csapp,,0,0,0,,and messages is stored on the stack of Maine 
Dialogue: 0,0:12:23.52,0:12:28.86,csapp,,0,0,0,,okay now myid is a local variable declared defined in this thread routine 
Dialogue: 0,0:12:30.34,0:12:32.48,csapp,,0,0,0,,and so there's actually since there's two of these threads
Dialogue: 0,0:12:32.74,0:12:39.62,csapp,,0,0,0,, there's there's now there are in memory there's there's two instances of myid one  one for each stack 
Dialogue: 0,0:12:40.54,0:12:43.38,csapp,,0,0,0,,okay associated with the stack associated with each thread 
Dialogue: 0,0:12:45.28,0:12:49.52,csapp,,0,0,0,,so myid.p0 is stored on peer thread 0's stack
Dialogue: 0,0:12:50.26,0:12:54.64,csapp,,0,0,0,,and myid.p1 is stored on peer thread 1's stack 
Dialogue: 0,0:12:59.20,0:13:07.68,csapp,,0,0,0,,ok and now this counter variable the static counter variable has just exactly one instance in in virtual memory 
Dialogue: 0,0:13:07.98,0:13:13.02,csapp,,0,0,0,,and it sits in the data segment along with the other global variables like like pointer 
Dialogue: 0,0:13:17.34,0:13:18.62,csapp,,0,0,0,,okay now so the question is 
Dialogue: 0,0:13:20.78,0:13:23.24,csapp,,0,0,0,,which of these variables are shared and which are not 
Dialogue: 0,0:13:25.66,0:13:26.32,csapp,,0,0,0,,okay so we can 
Dialogue: 0,0:13:28.50,0:13:36.88,csapp,,0,0,0,,remember what we said is it's shared if if more than one thread  is accessing an instance of that variable 
Dialogue: 0,0:13:38.98,0:13:42.82,csapp,,0,0,0,,okay so let's let's just list all the different variables 
Dialogue: 0,0:13:44.20,0:13:48.62,csapp,,0,0,0,,and then let's look at each of these threads and see if it's referenced by that thread 
Dialogue: 0,0:13:50.26,0:13:52.66,csapp,,0,0,0,,okay so what about what about pointer 
Dialogue: 0,0:13:54.80,0:13:59.45,csapp,,0,0,0,,right there's just it's referenced by the main thread right
Dialogue: 0,0:14:00.80,0:14:02.80,csapp,,0,0,0,,and what about Pierre threads zero
Dialogue: 0,0:14:07.38,0:14:10.20,csapp,,0,0,0,,yeah it's referenced by peer thread zero right here 
Dialogue: 0,0:14:12.88,0:14:14.14,csapp,,0,0,0,,right here 
Dialogue: 0,0:14:15.80,0:14:17.56,csapp,,0,0,0,,and similarly for pthread and one 
Dialogue: 0,0:14:18.64,0:14:21.72,csapp,,0,0,0,,okay so so pointer is referenced by all three threads
Dialogue: 0,0:14:25.02,0:14:25.90,csapp,,0,0,0,,now what about count 
Dialogue: 0,0:14:29.32,0:14:31.78,csapp,,0,0,0,,counts not referenced by the main thread 
Dialogue: 0,0:14:32.96,0:14:36.00,csapp,,0,0,0,,but it is referenced by the two peer threads 
Dialogue: 0,0:14:38.44,0:14:40.16,csapp,,0,0,0,,now what about I in main 
Dialogue: 0,0:14:42.62,0:14:44.28,csapp,,0,0,0,,that's referenced by main of course 
Dialogue: 0,0:14:44.30,0:14:49.04,csapp,,0,0,0,,but not by but not by either of the two threads 
Dialogue: 0,0:14:50.74,0:14:52.84,csapp,,0,0,0,,now we're about messages the messages array 
Dialogue: 0,0:14:54.62,0:14:57.92,csapp,,0,0,0,,okay so that's that's accessed by my main 
Dialogue: 0,0:14:58.74,0:15:00.92,csapp,,0,0,0,,and indirectly through pointer
Dialogue: 0,0:15:01.52,0:15:05.56,csapp,,0,0,0,, it's referenced by each of these  two peer threads
Dialogue: 0,0:15:07.66,0:15:12.24,csapp,,0,0,0,, now what about my ID defined in in peer thread zero 
Dialogue: 0,0:15:14.20,0:15:16.54,csapp,,0,0,0,,okay so that's referenced that's a local variable 
Dialogue: 0,0:15:16.54,0:15:21.06,csapp,,0,0,0,,so it's only referenced by peer thread zero right it's not referenced by either the other threads 
Dialogue: 0,0:15:21.08,0:15:29.00,csapp,,0,0,0,,and similarly for for my ID and in peer threat one
Dialogue: 0,0:15:33.12,0:15:36.32,csapp,,0,0,0,,okay so given given that definition then
Dialogue: 0,0:15:37.60,0:15:39.90,csapp,,0,0,0,,which of these variables is shared 
Dialogue: 0,0:15:42.28,0:15:44.74,csapp,,0,0,0,,so it's it's really straightforward with yeah 
Dialogue: 0,0:15:50.56,0:15:55.88,csapp,,0,0,0,,okay so the question is discount count as a share variable and answer is yes 
Dialogue: 0,0:15:56.70,0:15:59.10,csapp,,0,0,0,,because because it's declared static
Dialogue: 0,0:15:59.86,0:16:03.66,csapp,,0,0,0,,it's there's one instance of it in in in virtual memory 
Dialogue: 0,0:16:04.94,0:16:08.82,csapp,,0,0,0,,and each of the threads references that instance 
Dialogue: 0,0:16:09.40,0:16:13.12,csapp,,0,0,0,,okay so it's it's shared it's really like a global variable 
Dialogue: 0,0:16:13.76,0:16:16.86,csapp,,0,0,0,,it's just a scope is limited to the the 
Dialogue: 0,0:16:18.30,0:16:22.98,csapp,,0,0,0,,it stored the same way a global variable is but its scope is limited to the function that it's defined in 
Dialogue: 0,0:16:24.48,0:16:27.26,csapp,,0,0,0,,okay so to determine if each one of these is whether
Dialogue: 0,0:16:27.48,0:16:30.14,csapp,,0,0,0,, which which of these variables are shared in which one's not we just 
Dialogue: 0,0:16:30.66,0:16:35.86,csapp,,0,0,0,,we just look go across and for any any variable with its shared by more than
Dialogue: 0,0:16:36.80,0:16:39.00,csapp,,0,0,0,,more than one thread then it's shared 
Dialogue: 0,0:16:39.68,0:16:40.78,csapp,,0,0,0,,so pointer shared 
Dialogue: 0,0:16:44.98,0:16:48.38,csapp,,0,0,0,,so pointer is shared count is not shared
Dialogue: 0,0:16:50.92,0:16:56.10,csapp,,0,0,0,,oh no no count is shared because it's it's referenced by peer thread zero and peer thread one
Dialogue: 0,0:16:58.42,0:17:01.62,csapp,,0,0,0,, i's not shared because it's only referenced by by main 
Dialogue: 0,0:17:02.98,0:17:03.38,csapp,,0,0,0,,so
Dialogue: 0,0:17:07.94,0:17:11.76,csapp,,0,0,0,,messages is access referenced by all three threads so it's shared
Dialogue: 0,0:17:12.78,0:17:18.60,csapp,,0,0,0,, but my ID is is not shared because it's only referenced by exactly one thread 
Dialogue: 0,0:17:19.02,0:17:28.22,csapp,,0,0,0,,okay so so pointer count and messages are the shared variables in this program and the others are run share 
Dialogue: 0,0:17:28.66,0:17:28.86,csapp,,0,0,0,,yes 
Dialogue: 0,0:17:29.32,0:17:35.74,csapp,,0,0,0,,would like the second process and over s
Dialogue: 0,0:17:35.74,0:17:37.86,csapp,,0,0,0,,o she declared my ideas static 
Dialogue: 0,0:17:38.82,0:17:41.92,csapp,,0,0,0,,with the second process of overridden it yeah that would be a race 
Dialogue: 0,0:17:43.44,0:17:47.44,csapp,,0,0,0,,okay so that would we just depend on which which thread executed first 
Dialogue: 0,0:17:48.16,0:17:50.32,csapp,,0,0,0,,so you would really wouldn't want to do that
Dialogue: 0,0:17:55.38,0:18:00.26,csapp,,0,0,0,,okay so so we have a very clear notion now of what we mean by sharing
Dialogue: 0,0:18:08.32,0:18:12.64,csapp,,0,0,0,,so these being able to share variables like this in this ways is very handy 
Dialogue: 0,0:18:14.12,0:18:16.54,csapp,,0,0,0,,but you can run into some really nasty problems 
Dialogue: 0,0:18:17.76,0:18:20.88,csapp,,0,0,0,,that are very surprising so let me show you an example
Dialogue: 0,0:18:23.28,0:18:24.34,csapp,,0,0,0,, this is a program
Dialogue: 0,0:18:25.72,0:18:29.72,csapp,,0,0,0,,called bad count so obviously there's something wrong with this I'm giving you a little clue 
Dialogue: 0,0:18:31.28,0:18:39.58,csapp,,0,0,0,,but what we want to do is we want to create we want to create a bunch of threads or a number of threads
Dialogue: 0,0:18:40.46,0:18:44.18,csapp,,0,0,0,,and each of those threads will increment a global variable called count 
Dialogue: 0,0:18:45.00,0:18:47.04,csapp,,0,0,0,,some number of times the same number of times
Dialogue: 0,0:18:49.26,0:18:55.02,csapp,,0,0,0,,okay so so we pass in the number of iterations as the first argument 
Dialogue: 0,0:18:56.16,0:18:59.54,csapp,,0,0,0,,and here's our well here's our global globally shared variable
Dialogue: 0,0:19:02.02,0:19:03.84,csapp,,0,0,0,, and you remember what volatile means 
Dialogue: 0,0:19:04.92,0:19:06.10,csapp,,0,0,0,,everybody remember what that means 
Dialogue: 0,0:19:07.68,0:19:10.30,csapp,,0,0,0,,so what is volatile what is volatile tell the compiler 
Dialogue: 0,0:19:10.98,0:19:11.48,csapp,,0,0,0,,yes
Dialogue: 0,0:19:11.60,0:19:22.66,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:19:24.72,0:19:32.92,csapp,,0,0,0,,it actually you you're on in the right direction actually tells it tells the compiler never to put that variable in a register 
Dialogue: 0,0:19:33.72,0:19:38.96,csapp,,0,0,0,,okay so it always it will always read that value from memory or store it to memory and 
Dialogue: 0,0:19:39.54,0:19:44.64,csapp,,0,0,0,,you do that because of exactly the kind of possibility that you mentioned 
Dialogue: 0,0:19:46.90,0:19:52.52,csapp,,0,0,0,,so so in this in this case we have 
Dialogue: 0,0:19:53.12,0:19:55.88,csapp,,0,0,0,,we create two threads but with two distinct calls to two pthread create 
Dialogue: 0,0:19:57.42,0:20:02.76,csapp,,0,0,0,,each of these threads will will run the the thread routine called thread 
Dialogue: 0,0:20:03.36,0:20:08.50,csapp,,0,0,0,,and it will pass and as an argument the address of the number of iterations that it should 
Dialogue: 0,0:20:09.34,0:20:10.18,csapp,,0,0,0,, that it should iterate
Dialogue: 0,0:20:11.66,0:20:15.56,csapp,,0,0,0,, now you remember when we were looking when we were passing connected file descriptors
Dialogue: 0,0:20:16.76,0:20:18.70,csapp,,0,0,0,,  if if we pass an address that was a race
Dialogue: 0,0:20:20.10,0:20:22.86,csapp,,0,0,0,, okay but in this case there's no race this is fine
Dialogue: 0,0:20:22.86,0:20:25.88,csapp,,0,0,0,,  it's fine just to pass the address of number of iterations 
Dialogue: 0,0:20:26.46,0:20:32.52,csapp,,0,0,0,,so why is it okay in this case but it wasn't okay when we were passing the connected file descriptor
Dialogue: 0,0:20:32.88,0:20:35.28,csapp,,0,0,0,,that we got from acceptant to our thread routine
Dialogue: 0,0:20:49.06,0:20:51.98,csapp,,0,0,0,,yes 
Dialogue: 0,0:20:52.00,0:20:54.40,csapp,,0,0,0,,exactly because the thread doesn't modify the value 
Dialogue: 0,0:20:54.60,0:21:01.82,csapp,,0,0,0,,and that the problem we had before was that our main thread was modifying that connected descriptor on on the next call to accept
Dialogue: 0,0:21:02.56,0:21:04.76,csapp,,0,0,0,, but here it's just a read-only variable so we're okay
Dialogue: 0,0:21:06.58,0:21:08.90,csapp,,0,0,0,,but you see the how tricky the reasoning can get right there's
Dialogue: 0,0:21:09.46,0:21:13.78,csapp,,0,0,0,, you can't do pattern matching to determine whether you've got races or not races 
Dialogue: 0,0:21:14.40,0:21:16.02,csapp,,0,0,0,,right so you can't just say well
Dialogue: 0,0:21:16.52,0:21:23.24,csapp,,0,0,0,, it's always bad to pass the address of some variable to a to a thread routine 
Dialogue: 0,0:21:23.78,0:21:25.72,csapp,,0,0,0,,okay because it's not it just depends on the context 
Dialogue: 0,0:21:27.37,0:21:31.40,csapp,,0,0,0,,okay so in this case we're passing the number of iterations and to each thread and
Dialogue: 0,0:21:33.52,0:21:36.88,csapp,,0,0,0,,then we're waiting for each of those threads to finish 
Dialogue: 0,0:21:36.90,0:21:43.26,csapp,,0,0,0,,so this is an example of why you need why you might want to have a non detached thread 
Dialogue: 0,0:21:43.30,0:21:43.98,csapp,,0,0,0,,because you can't 
Dialogue: 0,0:21:46.62,0:21:50.16,csapp,,0,0,0,,we want when we check when we check the value of count 
Dialogue: 0,0:21:50.16,0:21:54.18,csapp,,0,0,0,,we have to make sure that every thread is finished before we check whether we got the right value or not 
Dialogue: 0,0:21:55.28,0:21:56.96,csapp,,0,0,0,,okay so we wait for each thread to finish 
Dialogue: 0,0:21:58.00,0:22:03.10,csapp,,0,0,0,,and now since we've created two threads each of which is incrementing count Editors time 
Dialogue: 0,0:22:04.10,0:22:07.06,csapp,,0,0,0,,we expect count to be equal to two times and ITER's 
Dialogue: 0,0:22:07.06,0:22:10.44,csapp,,0,0,0,,and if it's not we print my favorite error message 
Dialogue: 0,0:22:11.90,0:22:19.04,csapp,,0,0,0,,otherwise we with with the value of count otherwise we print okay  also with the value of count
Dialogue: 0,0:22:20.68,0:22:22.64,csapp,,0,0,0,, okay so now what's going on in the thread routine 
Dialogue: 0,0:22:23.78,0:22:24.54,csapp,,0,0,0,,very simple 
Dialogue: 0,0:22:26.32,0:22:28.10,csapp,,0,0,0,,it dereferences the 
Dialogue: 0,0:22:29.36,0:22:33.46,csapp,,0,0,0,,the the argument that was passed in and stores it in the local copy of entities
Dialogue: 0,0:22:34.84,0:22:36.44,csapp,,0,0,0,,  and then it loop senators time 
Dialogue: 0,0:22:37.42,0:22:39.04,csapp,,0,0,0,,in can increments count each time 
Dialogue: 0,0:22:40.20,0:22:41.22,csapp,,0,0,0,,so and then returns 
Dialogue: 0,0:22:42.38,0:22:45.32,csapp,,0,0,0,,so this is very innocuous what could go wrong 
Dialogue: 0,0:22:47.64,0:22:53.22,csapp,,0,0,0,,and since this is threading since this is concurrent concurrent programming especially since it's threaded programming 
Dialogue: 0,0:22:53.56,0:22:56.98,csapp,,0,0,0,,what there's the odd lots of subtle things can go wrong
Dialogue: 0,0:22:56.98,0:23:00.30,csapp,,0,0,0,, so it turns out this program has a really serious bug
Dialogue: 0,0:23:01.52,0:23:03.48,csapp,,0,0,0,,okay because when we run it 
Dialogue: 0,0:23:06.24,0:23:08.40,csapp,,0,0,0,,when we run it on a Linux box 
Dialogue: 0,0:23:08.96,0:23:12.80,csapp,,0,0,0,,sometimes if we call it with an argument of ten thousand sometimes 
Dialogue: 0,0:23:13.40,0:23:17.90,csapp,,0,0,0,,we get the correct answer  two times ten thousand or twenty thousand
Dialogue: 0,0:23:18.54,0:23:19.66,csapp,,0,0,0,,but then the next time we run it 
Dialogue: 0,0:23:20.36,0:23:23.76,csapp,,0,0,0,,we get some weird number 13051
Dialogue: 0,0:23:25.18,0:23:25.94,csapp,,0,0,0,,completely wrong 
Dialogue: 0,0:23:27.28,0:23:30.18,csapp,,0,0,0,,and so what what the heck is going on here 
Dialogue: 0,0:23:32.74,0:23:35.90,csapp,,0,0,0,,okay so to understand that we have to look at the assembly language
Dialogue: 0,0:23:37.60,0:23:39.64,csapp,,0,0,0,,for this counter loop so that 
Dialogue: 0,0:23:41.06,0:23:45.94,csapp,,0,0,0,,we want to we we need to look at the the  December language for this counter loop in the thread routine 
Dialogue: 0,0:23:48.22,0:23:50.34,csapp,,0,0,0,,so we'll break it up into three chunks that
Dialogue: 0,0:23:51.12,0:23:53.90,csapp,,0,0,0,, the the first chunk is sort of getting ready for the loop 
Dialogue: 0,0:23:54.26,0:24:01.60,csapp,,0,0,0,, we'll call that the head and we'll denote we'll denote it as H of I  for thread I
Dialogue: 0,0:24:04.94,0:24:12.84,csapp,,0,0,0,,and then we'll we'll we'll isolate on these three instructions that are directly related to incrementing count
Dialogue: 0,0:24:14.08,0:24:16.22,csapp,,0,0,0,,okay so you see the first instruction moves 
Dialogue: 0,0:24:16.66,0:24:22.50,csapp,,0,0,0,,it loads the global of the value and global variable count into register RDX 
Dialogue: 0,0:24:24.14,0:24:25.72,csapp,,0,0,0,,so will denote that as L of I 
Dialogue: 0,0:24:27.54,0:24:30.18,csapp,,0,0,0,,next it increments RDX 
Dialogue: 0,0:24:31.52,0:24:35.98,csapp,,0,0,0,,and we'll denote that U of I for update so it updates RDX 
Dialogue: 0,0:24:37.14,0:24:42.92,csapp,,0,0,0,,and then it stores the value the updated value of RDX into count
Dialogue: 0,0:24:43.42,0:24:48.06,csapp,,0,0,0,,okay so into the location associated with the loke the global variable count
Dialogue: 0,0:24:50.00,0:24:50.44,csapp,,0,0,0,,and 
Dialogue: 0,0:24:53.32,0:24:58.94,csapp,,0,0,0,,and then the rest of the the rest of this loop is getting ready for the to do the next iteration
Dialogue: 0,0:24:59.70,0:25:02.32,csapp,,0,0,0,, it's not directly related to incrementing count 
Dialogue: 0,0:25:02.32,0:25:06.38,csapp,,0,0,0,,so we'll just sort of group this all together and refer to it as T of I for tail
Dialogue: 0,0:25:07.68,0:25:07.86,csapp,,0,0,0,, okay
Dialogue: 0,0:25:13.60,0:25:17.56,csapp,,0,0,0,,now let's look at let's look at 
Dialogue: 0,0:25:18.22,0:25:21.94,csapp,,0,0,0,,how this how these two threads might be might be executed 
Dialogue: 0,0:25:22.12,0:25:27.38,csapp,,0,0,0,,and remember in general we can't assume that there's any specific interleaving 
Dialogue: 0,0:25:27.40,0:25:30.08,csapp,,0,0,0,,so any interleaving of these two threads is possible 
Dialogue: 0,0:25:30.18,0:25:33.32,csapp,,0,0,0,,no matter how remote it might seem 
Dialogue: 0,0:25:34.90,0:25:38.80,csapp,,0,0,0,,so let's look at one example let's say we're executing on a single core 
Dialogue: 0,0:25:38.80,0:25:40.98,csapp,,0,0,0,, so we're only going to do one instruction at a time 
Dialogue: 0,0:25:43.00,0:25:43.54,csapp,,0,0,0,,and
Dialogue: 0,0:25:45.84,0:25:50.36,csapp,,0,0,0,, in this column will show which thread is executing so either thread 1 or thread 2 
Dialogue: 0,0:25:53.28,0:25:56.42,csapp,,0,0,0,,and then we'll to know which instruction in that thread is executing
Dialogue: 0,0:25:57.90,0:26:00.28,csapp,,0,0,0,, either H lus or T
Dialogue: 0,0:26:02.02,0:26:07.20,csapp,,0,0,0,,and then this column shows the value of RDX for thread number 1 
Dialogue: 0,0:26:08.34,0:26:13.22,csapp,,0,0,0,,and this column shows the value of RDX for thread number 2 right 
Dialogue: 0,0:26:13.78,0:26:19.28,csapp,,0,0,0,,and since that the kernel keeps separate copies of all the general-purpose registers the for each each thread these can be different 
Dialogue: 0,0:26:22.60,0:26:25.56,csapp,,0,0,0,,okay and then this last column shows the value of count in memory
Dialogue: 0,0:26:27.90,0:26:33.04,csapp,,0,0,0,, so let's start executing so initially count is equal to 0 
Dialogue: 0,0:26:34.16,0:26:38.90,csapp,,0,0,0,, and thread one gets the kernel schedules thread thread 1 
Dialogue: 0,0:26:38.92,0:26:41.94,csapp,,0,0,0,,so it executes say CH 1 that has no impact on on count
Dialogue: 0,0:26:43.34,0:26:47.20,csapp,,0,0,0,,then thread 1 loads the value of count into its copy of RDX 
Dialogue: 0,0:26:48.52,0:26:49.34,csapp,,0,0,0,,updates it 
Dialogue: 0,0:26:50.74,0:26:58.90,csapp,,0,0,0,,so now %rdx is equal to 1 and then stores that value in %rdx back to count so now count is equal to 1
Dialogue: 0,0:27:00.84,0:27:04.20,csapp,,0,0,0,,now at this point the kernel decides to schedule thread to 
Dialogue: 0,0:27:04.90,0:27:10.76,csapp,,0,0,0,,sew thread two  begins executing and when it begins executing value of count is 1 
Dialogue: 0,0:27:11.86,0:27:14.20,csapp,,0,0,0,,so it executes H of I 
Dialogue: 0,0:27:16.26,0:27:22.62,csapp,,0,0,0,,then it loads count into the art into thread 2's copy of RDX 
Dialogue: 0,0:27:23.32,0:27:28.08,csapp,,0,0,0,,so now our DX equals 1 updates it 
Dialogue: 0,0:27:28.68,0:27:31.40,csapp,,0,0,0,,now it's equal to 2 and then stores that value back to count
Dialogue: 0,0:27:33.20,0:27:37.36,csapp,,0,0,0,, the kernel then decides oh and then
Dialogue: 0,0:27:37.84,0:27:41.44,csapp,,0,0,0,, and then it finishes executing the tail instruction 
Dialogue: 0,0:27:42.44,0:27:44.36,csapp,,0,0,0,,and let's say we're just doing one iteration of this
Dialogue: 0,0:27:45.64,0:27:51.22,csapp,,0,0,0,, and then at this point the kernel decides to schedule thread one since thread two is finished so
Dialogue: 0,0:27:51.86,0:27:55.38,csapp,,0,0,0,,  thread 1 1 executes the remaining statement that it has to execute 
Dialogue: 0,0:27:57.06,0:27:58.82,csapp,,0,0,0,,and at this point both threads have finished
Dialogue: 0,0:28:00.50,0:28:03.84,csapp,,0,0,0,, and count is equal to 2 which is the value we would expect 
Dialogue: 0,0:28:04.18,0:28:06.74,csapp,,0,0,0,,ok so this so this is ok 
Dialogue: 0,0:28:07.38,0:28:11.60,csapp,,0,0,0,,and notice how so this is actually this is an inner leaving that works 
Dialogue: 0,0:28:11.88,0:28:13.08,csapp,,0,0,0,,ok we get the correct value 
Dialogue: 0,0:28:14.12,0:28:16.02,csapp,,0,0,0,,and notice how I did 
Dialogue: 0,0:28:19.08,0:28:23.14,csapp,,0,0,0,,it grouped the 3 instructions that are actually involved in updating count together 
Dialogue: 0,0:28:24.66,0:28:29.76,csapp,,0,0,0,,and it will call that we'll call those 3 instructions a critical section and I've color-coded them 
Dialogue: 0,0:28:29.78,0:28:32.02,csapp,,0,0,0,,so you can easily keep track of them 
Dialogue: 0,0:28:34.08,0:28:39.10,csapp,,0,0,0,,alright let's look now let's look at another another interleaving which is feasible right 
Dialogue: 0,0:28:40.24,0:28:43.04,csapp,,0,0,0,, but in this case it results in the wrong value 
Dialogue: 0,0:28:44.98,0:28:47.98,csapp,,0,0,0,,ok so here we start with thread 1 again 
Dialogue: 0,0:28:50.16,0:28:55.52,csapp,,0,0,0,,it loads it's the value of count into its copy of RDX updates it 
Dialogue: 0,0:28:56.14,0:28:57.62,csapp,,0,0,0,,but then before it can store it 
Dialogue: 0,0:28:59.08,0:29:01.44,csapp,,0,0,0,,the kernel decides to schedule thread - 
Dialogue: 0,0:29:02.46,0:29:04.84,csapp,,0,0,0,,so thread 2 begins X executing
Dialogue: 0,0:29:05.86,0:29:09.28,csapp,,0,0,0,, it loads count into its copy of RDX - 
Dialogue: 0,0:29:10.18,0:29:14.24,csapp,,0,0,0,,and notice count is still 0 right it's it's 1
Dialogue: 0,0:29:15.84,0:29:19.64,csapp,,0,0,0,, in the value of in thread one in the RDX 
Dialogue: 0,0:29:20.12,0:29:24.02,csapp,,0,0,0,,the copy of RDX and thread 1 but it hasn't been updated in memory so 
Dialogue: 0,0:29:24.98,0:29:29.92,csapp,,0,0,0,,when when when thread 2 loads its value of count 
Dialogue: 0,0:29:29.92,0:29:33.44,csapp,,0,0,0,,now it's copy and RDX is 0 
Dialogue: 0,0:29:34.60,0:29:39.72,csapp,,0,0,0,,now at this point the kernel reschedules thread 1 to execute so thread 1 does it store 
Dialogue: 0,0:29:40.88,0:29:43.98,csapp,,0,0,0,,of its copy of RDX into count 
Dialogue: 0,0:29:44.96,0:29:48.16,csapp,,0,0,0,,and then finishes executing it the tale instruction
Dialogue: 0,0:29:49.44,0:29:54.72,csapp,,0,0,0,, the colonel reschedules thread - which picks up where it left off it updates 
Dialogue: 0,0:29:55.90,0:29:58.36,csapp,,0,0,0,,its copy of of count
Dialogue: 0,0:29:58.46,0:30:01.60,csapp,,0,0,0,,so now RDX goes from 0 to 1
Dialogue: 0,0:30:03.18,0:30:06.12,csapp,,0,0,0,, and then it stores that value into count 
Dialogue: 0,0:30:06.80,0:30:10.44,csapp,,0,0,0,,so all we've done is we've overwritten count out a value 1 
Dialogue: 0,0:30:11.06,0:30:12.80,csapp,,0,0,0,,and we've overwritten it with a value of 1
Dialogue: 0,0:30:13.82,0:30:17.72,csapp,,0,0,0,, so when we finish execution of these two threads count has the wrong value 
Dialogue: 0,0:30:20.58,0:30:21.18,csapp,,0,0,0,,okay in the 
Dialogue: 0,0:30:22.58,0:30:27.96,csapp,,0,0,0,,that then the general like the general thing to notice is you see how these critical sections have been interleaved
Dialogue: 0,0:30:28.64,0:30:30.72,csapp,,0,0,0,, right in this in this case
Dialogue: 0,0:30:32.14,0:30:37.60,csapp,,0,0,0,, this is the first the critical section for thread 1 executed before the the critical section for thread 2 
Dialogue: 0,0:30:39.52,0:30:42.88,csapp,,0,0,0,,okay but in this case the two critical sections interleaved okay
Dialogue: 0,0:30:46.24,0:30:48.30,csapp,,0,0,0,,so let's see another example of that 
Dialogue: 0,0:30:48.70,0:30:50.78,csapp,,0,0,0,,so here you can see that these are interleaved so 
Dialogue: 0,0:30:51.44,0:30:55.10,csapp,,0,0,0,,probably suggest there might be a problem yes 
Dialogue: 0,0:30:55.12,0:31:00.68,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:31:00.68,0:31:01.98,csapp,,0,0,0,,so I'm sorry excuse me
Dialogue: 0,0:31:02.04,0:31:11.32,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:31:11.34,0:31:13.72,csapp,,0,0,0,,well no okay so the question is would would 
Dialogue: 0,0:31:14.90,0:31:15.60,csapp,,0,0,0,,I or count count 
Dialogue: 0,0:31:22.10,0:31:26.10,csapp,,0,0,0,,if we okay it is defined as volatile it didn't I 
Dialogue: 0,0:31:28.52,0:31:37.68,csapp,,0,0,0,,yeah so that that's why I mean there's actually and the compiler could have compiled this code in different ways right
Dialogue: 0,0:31:38.10,0:31:42.96,csapp,,0,0,0,, there is actually an increment instruction that you will increment a variable in memory 
Dialogue: 0,0:31:43.16,0:31:44.36,csapp,,0,0,0,,so you could have done
Dialogue: 0,0:31:45.60,0:31:51.06,csapp,,0,0,0,, the compiler could have generated this this 3 instruction sequence is one instruction and then we wouldn't have this problem 
Dialogue: 0,0:31:51.64,0:31:52.62,csapp,,0,0,0,,but the problem is that
Dialogue: 0,0:31:53.68,0:31:59.86,csapp,,0,0,0,,it's it's it's loading into register then incrementing and then saving
Dialogue: 0,0:31:59.88,0:32:01.78,csapp,,0,0,0,, so that the problem comes about because 
Dialogue: 0,0:32:02.26,0:32:02.64,csapp,,0,0,0,,we can
Dialogue: 0,0:32:05.08,0:32:10.02,csapp,,0,0,0,, this this thread can be interrupted before it finishes this three-step sequence 
Dialogue: 0,0:32:10.02,0:32:12.20,csapp,,0,0,0,,this load modify store sequence
Dialogue: 0,0:32:13.02,0:32:21.36,csapp,,0,0,0,,yes
Dialogue: 0,0:32:21.36,0:32:24.86,csapp,,0,0,0,,it would wait yeah so it that's right yeah I guess I wasn't clear it 
Dialogue: 0,0:32:25.63,0:32:28.66,csapp,,0,0,0,,it prevents it from being stored permanently in a register right so
Dialogue: 0,0:32:29.42,0:32:34.24,csapp,,0,0,0,, it it if it's it may have to be loaded into a register but then it'll be written back
Dialogue: 0,0:32:36.02,0:32:39.52,csapp,,0,0,0,,okay whereas the the compiler would have the option like we've seen it with local variables
Dialogue: 0,0:32:40.16,0:32:43.44,csapp,,0,0,0,, right the compiler just it never allocates stack space 
Dialogue: 0,0:32:43.44,0:32:45.88,csapp,,0,0,0,,it just keeps that local variable in a register all the time 
Dialogue: 0,0:32:46.12,0:32:50.02,csapp,,0,0,0,,okay so this prevent the volatile attribute prevents the compiler from doing that 
Dialogue: 0,0:32:55.58,0:32:57.19,csapp,,0,0,0,,okay so let's look at another example
Dialogue: 0,0:32:58.20,0:33:00.58,csapp,,0,0,0,,so here thread one starts 
Dialogue: 0,0:33:01.08,0:33:04.24,csapp,,0,0,0,,it loads it loads count into RDX 
Dialogue: 0,0:33:05.08,0:33:06.28,csapp,,0,0,0,,then thread two starts 
Dialogue: 0,0:33:07.36,0:33:11.44,csapp,,0,0,0,,and it loads a count which is still 0 into RDX 2 
Dialogue: 0,0:33:12.18,0:33:15.80,csapp,,0,0,0,,updates it and then stores it so now count equal to 1 
Dialogue: 0,0:33:16.38,0:33:25.56,csapp,,0,0,0,,when thread 1 resumes it updates its value of count and RDX and stores that back to count 
Dialogue: 0,0:33:25.92,0:33:28.22,csapp,,0,0,0,,and so again we have we have the same problem 
Dialogue: 0,0:33:30.58,0:33:31.34,csapp,,0,0,0,,okay so the 
Dialogue: 0,0:33:32.52,0:33:36.22,csapp,,0,0,0,,the problem here is that we're interleaving these these critical sections
Dialogue: 0,0:33:36.92,0:33:39.62,csapp,,0,0,0,, and you can understand why this is bad 
Dialogue: 0,0:33:40.74,0:33:43.60,csapp,,0,0,0,,with a nice or graphical technique called a progress graph
Dialogue: 0,0:33:48.38,0:33:49.96,csapp,,0,0,0,,so in a progress graph 
Dialogue: 0,0:33:52.60,0:33:56.20,csapp,,0,0,0,,if we have 4n threads it's an N dimensional Cartesian grid
Dialogue: 0,0:33:57.98,0:34:03.88,csapp,,0,0,0,, that characterizes the execution state space of a concurrent threaded program 
Dialogue: 0,0:34:05.06,0:34:07.58,csapp,,0,0,0,,so in this case each here we have two threads 
Dialogue: 0,0:34:07.60,0:34:12.06,csapp,,0,0,0,,so it's a it's a it's a it's a 2d coordinate system 
Dialogue: 0,0:34:13.04,0:34:18.36,csapp,,0,0,0,,so each each axis represents the progress the execution progress of some threads 
Dialogue: 0,0:34:18.44,0:34:22.52,csapp,,0,0,0,,so the x axis here is thread 1
Dialogue: 0,0:34:23.08,0:34:25.72,csapp,,0,0,0,, and the y axis corresponds to thread 2 
Dialogue: 0,0:34:27.40,0:34:32.16,csapp,,0,0,0,, and then each one of these edges corresponds to the execution of an instruction 
Dialogue: 0,0:34:32.88,0:34:35.34,csapp,,0,0,0,,ok so we start out in an initial state 
Dialogue: 0,0:34:36.12,0:34:38.50,csapp,,0,0,0,,and then the first thing we execute is h1
Dialogue: 0,0:34:39.70,0:34:42.21,csapp,,0,0,0,, so that's represented by this this arc here
Dialogue: 0,0:34:43.18,0:34:47.64,csapp,,0,0,0,,so this this position this point right here represents the state where
Dialogue: 0,0:34:48.26,0:34:52.94,csapp,,0,0,0,, we've executed H we finished executing h1 in thread 1 
Dialogue: 0,0:34:52.94,0:34:56.18,csapp,,0,0,0,, but we haven't yet executed any instructions in thread 2 
Dialogue: 0,0:34:57.56,0:35:00.30,csapp,,0,0,0,,ok so in general each one of these points represents 
Dialogue: 0,0:35:01.98,0:35:05.08,csapp,,0,0,0,,sort of the current progress of the program or the execution State 
Dialogue: 0,0:35:06.06,0:35:11.02,csapp,,0,0,0,,so for example this this state right here represents the state where thread 1 
Dialogue: 0,0:35:11.34,0:35:13.60,csapp,,0,0,0,,has completed a completed l1 
Dialogue: 0,0:35:14.24,0:35:17.16,csapp,,0,0,0,,and thread 2 is completed s2
Dialogue: 0,0:35:22.30,0:35:29.46,csapp,,0,0,0,,and now the execution of a program is modeled as a transition from one state to the other  and there's some 
Dialogue: 0,0:35:30.42,0:35:33.66,csapp,,0,0,0,,so from from this and there's there's constraints on how 
Dialogue: 0,0:35:34.82,0:35:39.00,csapp,,0,0,0,,on how these these states can advance so
Dialogue: 0,0:35:39.74,0:35:41.62,csapp,,0,0,0,, from this state(L1,S2)
Dialogue: 0,0:35:42.56,0:35:44.92,csapp,,0,0,0,,Y obviously time can't go backwards right so we can't 
Dialogue: 0,0:35:45.38,0:35:50.10,csapp,,0,0,0,,we can't go backwards like in this direction to the left and we can't go down 
Dialogue: 0,0:35:50.78,0:35:53.48,csapp,,0,0,0,,okay so we can only go to the right and up 
Dialogue: 0,0:35:54.56,0:35:56.96,csapp,,0,0,0,,and since we're assuming that each instruction executes
Dialogue: 0,0:35:57.58,0:36:00.18,csapp,,0,0,0,,there's only one instruction executing at a time 
Dialogue: 0,0:36:00.58,0:36:03.12,csapp,,0,0,0,,we can't go diagonally that would be two instructions 
Dialogue: 0,0:36:03.62,0:36:05.26,csapp,,0,0,0,,all right so from (L1,S2)
Dialogue: 0,0:36:05.90,0:36:08.08,csapp,,0,0,0,,the next execution state is either 
Dialogue: 0,0:36:09.46,0:36:15.26,csapp,,0,0,0,,here if thread one execute or here if thread of thread to execute 
Dialogue: 0,0:36:17.54,0:36:20.28,csapp,,0,0,0,,okay so you can put all these together to form a trajectory 
Dialogue: 0,0:36:20.92,0:36:24.02,csapp,,0,0,0,,which characterizes one execution of the program 
Dialogue: 0,0:36:25.86,0:36:32.76,csapp,,0,0,0,,right and any feasible set of transitions from one state to the next corresponds to a feasible trajectory
Dialogue: 0,0:36:34.46,0:36:50.60,csapp,,0,0,0,, so so for example H1,L1,U1,H2,L2,S1,T1,U2,S2,T2
Dialogue: 0,0:36:51.42,0:36:52.58,csapp,,0,0,0,,that's a feasible 
Dialogue: 0,0:36:55.20,0:36:56.52,csapp,,0,0,0,,that's a feasible trajectory 
Dialogue: 0,0:36:57.58,0:37:06.38,csapp,,0,0,0,,and it's one possible it represents one possible execution or so one set of inter leavings for this program
Dialogue: 0,0:37:10.42,0:37:16.82,csapp,,0,0,0,,now these L these three these three instructions l U and s that operate on that manipulate count
Dialogue: 0,0:37:17.40,0:37:20.66,csapp,,0,0,0,, form what we call a critical section with respect to count
Dialogue: 0,0:37:25.18,0:37:29.20,csapp,,0,0,0,,and the idea is that instructions inside
Dialogue: 0,0:37:29.54,0:37:36.50,csapp,,0,0,0,,these critical sections this with receivership with respect to the same global variable shouldn't be interleaved
Dialogue: 0,0:37:38.28,0:37:43.70,csapp,,0,0,0,,so we can capture this geometrically by taking the intersection of these critical sections
Dialogue: 0,0:37:44.48,0:37:47.18,csapp,,0,0,0,, to form what we call an unsafe region 
Dialogue: 0,0:37:48.90,0:37:53.10,csapp,,0,0,0,, so in this an unsafe region is is is
Dialogue: 0,0:37:53.66,0:37:58.78,csapp,,0,0,0,,  the points within an unsafe  region are those those points in an execution where the 
Dialogue: 0,0:37:59.36,0:38:01.66,csapp,,0,0,0,, critical sections are being or interleaved 
Dialogue: 0,0:38:03.26,0:38:07.32,csapp,,0,0,0,,okay so for this particular example there's four points within the unsafe region 
Dialogue: 0,0:38:08.24,0:38:10.72,csapp,,0,0,0,,and if a trajectory ever touches one of those points 
Dialogue: 0,0:38:10.72,0:38:13.70,csapp,,0,0,0,,then we've interleaved critical section and we're going to get the wrong answer 
Dialogue: 0,0:38:17.12,0:38:19.90,csapp,,0,0,0,,okay so the idea is to try to stay out of these unsafe regions 
Dialogue: 0,0:38:25.28,0:38:28.40,csapp,,0,0,0,,and if we do we say that that trajectory is safe so 
Dialogue: 0,0:38:29.50,0:38:31.96,csapp,,0,0,0,, here's an example of a trajectory that's safe 
Dialogue: 0,0:38:33.20,0:38:37.04,csapp,,0,0,0,,now this is okay right this point right here is not in the unsafe region 
Dialogue: 0,0:38:37.82,0:38:40.62,csapp,,0,0,0,,because we haven't executed we only executed h1 here
Dialogue: 0,0:38:41.16,0:38:43.42,csapp,,0,0,0,,remember a point corresponds to 
Dialogue: 0,0:38:43.88,0:38:48.82,csapp,,0,0,0,,and it's the instruction that we've completed that instruction 
Dialogue: 0,0:38:51.10,0:38:51.86,csapp,,0,0,0,,so then 
Dialogue: 0,0:38:53.12,0:38:55.08,csapp,,0,0,0,,so here we're skirting the unsafe region 
Dialogue: 0,0:38:55.08,0:38:58.88,csapp,,0,0,0,,but it's still okay so this is a safe trajectory we'll get the right answer for this one
Dialogue: 0,0:39:00.00,0:39:00.82,csapp,,0,0,0,,however 
Dialogue: 0,0:39:03.58,0:39:05.52,csapp,,0,0,0,,this trajectory is unsafe because it 
Dialogue: 0,0:39:07.82,0:39:11.10,csapp,,0,0,0,,it enters the unsafe region at this point here 
Dialogue: 0,0:39:12.66,0:39:20.40,csapp,,0,0,0,,and even though it quickly exited the there's an interleaving there that creates a potential for a correct answer
Dialogue: 0,0:39:27.54,0:39:31.50,csapp,,0,0,0,,okay so the question is how do we guarantee a safe trajectory 
Dialogue: 0,0:39:31.58,0:39:33.98,csapp,,0,0,0,,and this is the this is what we call synchronization
Dialogue: 0,0:39:34.00,0:39:39.67,csapp,,0,0,0,,so somehow we want to we want to sort of configure the kernel
Dialogue: 0,0:39:40.58,0:39:43.10,csapp,,0,0,0,,so that'll never schedule an unsafe trajectory 
Dialogue: 0,0:39:45.86,0:39:46.78,csapp,,0,0,0,,so how do we do that
Dialogue: 0,0:39:47.88,0:39:50.20,csapp,,0,0,0,,so somehow 
Dialogue: 0,0:39:51.52,0:39:54.98,csapp,,0,0,0,,we we have to synchronize the execution of those threads 
Dialogue: 0,0:39:55.66,0:40:02.44,csapp,,0,0,0,,and another way to think of this is that we we we need to guarantee mutually exclusive access to the critical sections
Dialogue: 0,0:40:03.22,0:40:10.48,csapp,,0,0,0,, all right so once once the kernel begins once the thread starts executing the first instruction is critical section 
Dialogue: 0,0:40:10.88,0:40:16.14,csapp,,0,0,0,,we we don't want it to be interrupted by another thread that has a similar critical section 
Dialogue: 0,0:40:16.32,0:40:17.76,csapp,,0,0,0,,okay we don't want it  to be interrupted 
Dialogue: 0,0:40:18.14,0:40:22.22,csapp,,0,0,0,,we don't want one one critical section with respect to a certain global variable
Dialogue: 0,0:40:23.16,0:40:29.36,csapp,,0,0,0,, to be interrupted by another thread that has all right that's currently within that same critical section okay
Dialogue: 0,0:40:30.62,0:40:31.50,csapp,,0,0,0,, sorry yes question 
Dialogue: 0,0:40:31.50,0:40:45.08,csapp,,0,0,0,,seems unlikely for me that
Dialogue: 0,0:40:45.08,0:40:48.44,csapp,,0,0,0,,it okay so the question is how likely is it that you get a correct trajectory 
Dialogue: 0,0:40:48.48,0:40:51.02,csapp,,0,0,0,, and it happens right you can run it sometimes you do
Dialogue: 0,0:40:51.54,0:40:55.20,csapp,,0,0,0,, it just depends usually it's wrong sometimes it's right
Dialogue: 0,0:40:57.96,0:41:03.92,csapp,,0,0,0,, and it just depends it just depends on how the kernel scheduled it and you can't assume any particular scheduling 
Dialogue: 0,0:41:04.80,0:41:09.86,csapp,,0,0,0,,right so if you say if you want to if you want to claim that you would never get the right answer 
Dialogue: 0,0:41:10.48,0:41:15.04,csapp,,0,0,0,,then you're assuming that the kernel is always going to schedule the unsafe trajectory but 
Dialogue: 0,0:41:15.68,0:41:18.72,csapp,,0,0,0,,you can't assume that in fact it doesn't sometimes you just get lucky
Dialogue: 0,0:41:23.70,0:41:29.96,csapp,,0,0,0,,and it turns out you have to you have to call this function with a pretty big number in order to trip it up
Dialogue: 0,0:41:32.06,0:41:33.92,csapp,,0,0,0,, if so the it makes sense right
Dialogue: 0,0:41:34.92,0:41:39.14,csapp,,0,0,0,, if usually what what what the kernel does is that
Dialogue: 0,0:41:40.30,0:41:42.28,csapp,,0,0,0,, I we can only schedule
Dialogue: 0,0:41:43.12,0:41:47.48,csapp,,0,0,0,,we can only reschedule a thread you know swap it out and schedule another thread in 
Dialogue: 0,0:41:47.96,0:41:52.92,csapp,,0,0,0,,when there's some exception okay so that that passes control back to the kernel 
Dialogue: 0,0:41:54.70,0:41:59.76,csapp,,0,0,0,,so these exceptions are in two forms either  calling system making system calls 
Dialogue: 0,0:41:59.96,0:42:03.38,csapp,,0,0,0,,so that'll that'll trap into the kernel so that's a form of exception 
Dialogue: 0,0:42:03.86,0:42:09.50,csapp,,0,0,0,,or the timer interrupts goes off which transfers control back to the back to the kernel 
Dialogue: 0,0:42:10.36,0:42:14.88,csapp,,0,0,0,,so the timer the timer is going off on intervals of like milliseconds 
Dialogue: 0,0:42:16.44,0:42:20.76,csapp,,0,0,0,,right so if we're just doing one iteration it in each thread
Dialogue: 0,0:42:20.94,0:42:26.10,csapp,,0,0,0,,when a thread gets executed the chances are very low that the timer is going to go off 
Dialogue: 0,0:42:27.14,0:42:30.56,csapp,,0,0,0,,while that thread is executing you know it's its little loop
Dialogue: 0,0:42:32.86,0:42:35.12,csapp,,0,0,0,, but as we and we're not making any system calls
Dialogue: 0,0:42:35.28,0:42:42.30,csapp,,0,0,0,,right so there's there's nothing that will there's nothing we're not we're not passing control back into the kernel ourselves 
Dialogue: 0,0:42:43.14,0:42:47.68,csapp,,0,0,0,, so the only way the kernel is going to get access  is if the timer interrupts goes off 
Dialogue: 0,0:42:48.86,0:42:51.28,csapp,,0,0,0,,so if we're doing a very small number of iterations 
Dialogue: 0,0:42:52.22,0:42:57.00,csapp,,0,0,0,,the the probability that you know say here's the timer interval it's going off at intervals like this 
Dialogue: 0,0:42:58.10,0:43:01.86,csapp,,0,0,0,,here this the the probability we'd have to 
Dialogue: 0,0:43:02.60,0:43:08.94,csapp,,0,0,0,,that's thread would have to been scheduled right before a timer interrupts will go off or to interrupt that one or two iterations
Dialogue: 0,0:43:09.86,0:43:11.36,csapp,,0,0,0,,so it turns out we have to schedule 
Dialogue: 0,0:43:12.12,0:43:16.70,csapp,,0,0,0,,we have to call this function with a lot of within ITER's being fairly large 
Dialogue: 0,0:43:17.28,0:43:22.52,csapp,,0,0,0,,so that the the probability of the timer interrupts going off during that
Dialogue: 0,0:43:23.34,0:43:27.26,csapp,,0,0,0,, during that during that loop but gets increasingly large 
Dialogue: 0,0:43:28.10,0:43:28.60,csapp,,0,0,0,,that makes sense
Dialogue: 0,0:43:36.16,0:43:41.04,csapp,,0,0,0,,so the classic solution from this comes from the early 1960s one of the most famous computer scientists 
Dialogue: 0,0:43:42.98,0:43:46.38,csapp,,0,0,0,,is a Dutchman named as edgeguard Edsger Dijkstra 
Dialogue: 0,0:43:47.38,0:43:53.38,csapp,,0,0,0,,and he came up with the the classical first solution to this problem which is what we're going to look at 
Dialogue: 0,0:43:54.18,0:43:57.60,csapp,,0,0,0,,okay and it's it's it's still the first it's it's fundamental and very general purpose 
Dialogue: 0,0:43:57.60,0:44:01.76,csapp,,0,0,0,,and there's there's been many iterations and variations on this idea
Dialogue: 0,0:44:02.74,0:44:08.00,csapp,,0,0,0,, but semaphores were the first and classic solution which we'll look at
Dialogue: 0,0:44:11.38,0:44:15.32,csapp,,0,0,0,,okay so a semaphore is that is a non-global
Dialogue: 0,0:44:16.32,0:44:21.14,csapp,,0,0,0,, integer that's used as a synchronization variable by two 
Dialogue: 0,0:44:21.84,0:44:24.14,csapp,,0,0,0,,to kernel functions called P and V 
Dialogue: 0,0:44:27.12,0:44:28.98,csapp,,0,0,0,,our two system calls called P and V 
Dialogue: 0,0:44:32.38,0:44:36.60,csapp,,0,0,0,,these P and V are correspond to the Dutch words
Dialogue: 0,0:44:38.74,0:44:43.72,csapp,,0,0,0,, but we just you just we just call them P and V right you just have to learn what what they do 
Dialogue: 0,0:44:46.74,0:44:51.06,csapp,,0,0,0,,so each of these takes as an argument a semaphore 
Dialogue: 0,0:44:52.84,0:44:56.82,csapp,,0,0,0,,and the P operation has the following semantics 
Dialogue: 0,0:44:58.28,0:45:00.54,csapp,,0,0,0,,if if s is non zero 
Dialogue: 0,0:45:02.30,0:45:04.96,csapp,,0,0,0,,then decrement it by 1 and return immediately 
Dialogue: 0,0:45:07.68,0:45:10.60,csapp,,0,0,0,,and this test if it that it's non zero 
Dialogue: 0,0:45:11.38,0:45:13.16,csapp,,0,0,0,,and the decrement occur atomically 
Dialogue: 0,0:45:13.92,0:45:15.54,csapp,,0,0,0,,okay so so they'll never be interrupted
Dialogue: 0,0:45:20.28,0:45:21.96,csapp,,0,0,0,,however if s is zero 
Dialogue: 0,0:45:24.10,0:45:25.58,csapp,,0,0,0,,then suspend this thread 
Dialogue: 0,0:45:26.84,0:45:29.40,csapp,,0,0,0,,until s becomes non zero 
Dialogue: 0,0:45:31.10,0:45:34.26,csapp,,0,0,0,,and that thread then is restarted by a V operation 
Dialogue: 0,0:45:36.94,0:45:41.86,csapp,,0,0,0,,okay so if if P if the semaphore is zero  P just blocks
Dialogue: 0,0:45:42.32,0:45:46.74,csapp,,0,0,0,,  it just gets suspended until it gets restarted by a V operation 
Dialogue: 0,0:45:48.10,0:45:49.44,csapp,,0,0,0,,and then after it restarts 
Dialogue: 0,0:45:50.18,0:45:57.20,csapp,,0,0,0,,the P operation now can decrement s by one and return control to the caller
Dialogue: 0,0:46:03.26,0:46:06.00,csapp,,0,0,0,,okay the V operation just increments s by one 
Dialogue: 0,0:46:06.92,0:46:08.54,csapp,,0,0,0,,and this increment unlike that count 
Dialogue: 0,0:46:09.62,0:46:13.60,csapp,,0,0,0,,plus plus that we looked at just looked at this that increment occurs atomically 
Dialogue: 0,0:46:14.60,0:46:16.12,csapp,,0,0,0,,okay so it can never be interrupted 
Dialogue: 0,0:46:18.02,0:46:19.98,csapp,,0,0,0,,and then after it increments s 
Dialogue: 0,0:46:21.06,0:46:24.84,csapp,,0,0,0,,it checks to see if there's any any threads that are blocked in a pea operation 
Dialogue: 0,0:46:25.26,0:46:28.92,csapp,,0,0,0,,so you can think of the kernel just keeps a queue of threads 
Dialogue: 0,0:46:28.92,0:46:30.66,csapp,,0,0,0,,that are blocked in a pea operation 
Dialogue: 0,0:46:31.40,0:46:37.38,csapp,,0,0,0,,and the V operation after it increments s it checks that queue for any any threads that were blocked 
Dialogue: 0,0:46:38.50,0:46:41.44,csapp,,0,0,0,,because when they did the pea operation the semaphore was zero
Dialogue: 0,0:46:43.06,0:46:47.32,csapp,,0,0,0,,and then it restarts exactly one of those threads in some indeterminate order
Dialogue: 0,0:46:47.44,0:46:48.96,csapp,,0,0,0,, okay in some order that you can't
Dialogue: 0,0:46:49.72,0:46:54.90,csapp,,0,0,0,,you can't assume it just picks one using some some selection algorithm 
Dialogue: 0,0:46:56.38,0:47:05.64,csapp,,0,0,0,,and it and then it it it unblocks the suspended  the suspended process 
Dialogue: 0,0:47:07.88,0:47:11.16,csapp,,0,0,0,,okay which then completes its pea operation by decrementing yes
Dialogue: 0,0:47:17.62,0:47:22.68,csapp,,0,0,0,,okay this seems like really simple but it can be kind of hard to get your head around the first time you see it
Dialogue: 0,0:47:23.62,0:47:26.64,csapp,,0,0,0,, so are there any questions about P and V
Dialogue: 0,0:47:34.72,0:47:41.62,csapp,,0,0,0,,okay so that the key idea that these definitions of P and V 
Dialogue: 0,0:47:42.40,0:47:46.08,csapp,,0,0,0,,is that it imposes an invariant on the semaphores
Dialogue: 0,0:47:46.84,0:47:50.68,csapp,,0,0,0,,called the semaphore invariant which is s which is that for a semaphore s 
Dialogue: 0,0:47:52.66,0:47:55.10,csapp,,0,0,0,,being operated on by P and V operations 
Dialogue: 0,0:47:55.64,0:47:57.52,csapp,,0,0,0,,S is always greater than or equal to zero
Dialogue: 0,0:48:01.12,0:48:02.66,csapp,,0,0,0,,okay and that doesn't seem very exciting
Dialogue: 0,0:48:03.82,0:48:11.40,csapp,,0,0,0,,but it turns out this is a very useful property that will allow us to enforce mutual mutual exclusion  on these critical sections 
Dialogue: 0,0:48:13.64,0:48:18.24,csapp,,0,0,0,,so the P and V operations are are provided by P threads
Dialogue: 0,0:48:19.24,0:48:21.28,csapp,,0,0,0,,in the form of three functions 
Dialogue: 0,0:48:21.42,0:48:25.50,csapp,,0,0,0,,there's a Semin it functions which initializes the semaphore to some value
Dialogue: 0,0:48:26.22,0:48:31.92,csapp,,0,0,0,,okay so semaphore is can be initialized to any any value greater than or equal to zero 
Dialogue: 0,0:48:34.04,0:48:39.86,csapp,,0,0,0,,some weight is the P operation and some post is the V operation 
Dialogue: 0,0:48:41.88,0:48:44.38,csapp,,0,0,0,,okay and because I'm old-school 
Dialogue: 0,0:48:45.38,0:48:51.48,csapp,,0,0,0,,I provide wrapper functions for those in the in your cssapp.h file called P and V
Dialogue: 0,0:48:52.72,0:48:53.86,csapp,,0,0,0,,okay it's also more compact to
Dialogue: 0,0:49:00.20,0:49:07.02,csapp,,0,0,0,,okay so recall our recall our buggy program called bad count dot C 
Dialogue: 0,0:49:07.80,0:49:11.76,csapp,,0,0,0,,which was giving us the wrong answers for count 
Dialogue: 0,0:49:13.30,0:49:15.82,csapp,,0,0,0,,so how do we use semaphores to fix this program 
Dialogue: 0,0:49:18.92,0:49:21.46,csapp,,0,0,0,, so the basic idea is to create a semaphore 
Dialogue: 0,0:49:22.20,0:49:23.86,csapp,,0,0,0,,which is initialized to 1 
Dialogue: 0,0:49:25.70,0:49:29.80,csapp,,0,0,0,,and so by definition we'll call any semaphore which is initialized to 1
Dialogue: 0,0:49:29.82,0:49:33.36,csapp,,0,0,0,,that's used for to provide mutual exclusion we'll call that a mutex 
Dialogue: 0,0:49:34.98,0:49:38.06,csapp,,0,0,0,,okay and this goes back to the early Dijkstra papers 
Dialogue: 0,0:49:39.62,0:49:47.62,csapp,,0,0,0,,so we'll associate a unique mutex initialize to 1   for each shared variable in our program
Dialogue: 0,0:49:48.98,0:49:53.80,csapp,,0,0,0,, ok so in this case count we have count so we have one shared variable that we're concerned about 
Dialogue: 0,0:49:54.42,0:49:57.76,csapp,,0,0,0,, so we'll we'll create one new text that will call mutex 
Dialogue: 0,0:49:59.00,0:50:03.48,csapp,,0,0,0,,and then you surround the critical section with respect to count 
Dialogue: 0,0:50:04.20,0:50:10.94,csapp,,0,0,0,,with a p/e you call P then you execute the critical section and then you call V
Dialogue: 0,0:50:15.44,0:50:19.20,csapp,,0,0,0,,now there's some there's some terminology we'll use when we talk about semaphores 
Dialogue: 0,0:50:20.08,0:50:25.26,csapp,,0,0,0,,so a binary semaphore is is the semaphore whose value is always 0 1
Dialogue: 0,0:50:25.72,0:50:31.08,csapp,,0,0,0,,and then a mutex is this sort is a binary semaphore that's being used to for mutual exclusion 
Dialogue: 0,0:50:33.42,0:50:35.44,csapp,,0,0,0,,the P operation is called locking
Dialogue: 0,0:50:37.74,0:50:41.32,csapp,,0,0,0,,  the mutex will refer to a V is sometimes unlocking or releasing the mutex 
Dialogue: 0,0:50:42.52,0:50:50.38,csapp,,0,0,0,,and if a process is holding the mutex then that means it's been locked but not  not not released 
Dialogue: 0,0:50:53.26,0:50:58.54,csapp,,0,0,0,,so mutexes and binary semaphore s are always initialized to 1 accounting semaphore 
Dialogue: 0,0:50:59.52,0:51:02.98,csapp,,0,0,0,,and the mutex is used for mutual excuse exclusion 
Dialogue: 0,0:51:03.00,0:51:06.58,csapp,,0,0,0,,but you can also use semaphores to count sort of events in the system 
Dialogue: 0,0:51:07.80,0:51:15.98,csapp,,0,0,0,,and often times for those accounting semaphores have sort of non non values that are greater than 1
Dialogue: 0,0:51:19.74,0:51:21.30,csapp,,0,0,0,,okay so for mutual exclusion 
Dialogue: 0,0:51:23.66,0:51:28.94,csapp,,0,0,0,,we'll to fix our program we create a new program called good count dot c 
Dialogue: 0,0:51:30.46,0:51:32.70,csapp,,0,0,0,,and here we initialize a mutex 
Dialogue: 0,0:51:33.72,0:51:36.40,csapp,,0,0,0,,or we create a mutex and initialize it to 1 
Dialogue: 0,0:51:38.72,0:51:43.88,csapp,,0,0,0,,and then we surround the the critical section which is the 3 assembly language instructions
Dialogue: 0,0:51:44.36,0:51:47.68,csapp,,0,0,0,,embodied that implement this count plus plus instruction
Dialogue: 0,0:51:48.42,0:51:51.36,csapp,,0,0,0,, we surround it with a P followed by it by a V 
Dialogue: 0,0:51:54.28,0:51:57.24,csapp,,0,0,0,,and if we do that we always get the right answer
Dialogue: 0,0:52:00.52,0:52:03.46,csapp,,0,0,0,,but you know P&V our system calls
Dialogue: 0,0:52:03.99,0:52:05.46,csapp,,0,0,0,, so there's overhead associated with these
Dialogue: 0,0:52:05.48,0:52:11.84,csapp,,0,0,0,,so they're not free in fact they're orders of magnitude this program runs two orders of magnitude slower than the incorrect buggy version 
Dialogue: 0,0:52:13.56,0:52:15.60,csapp,,0,0,0,,all right so so why do these mutexes work 
Dialogue: 0,0:52:19.98,0:52:22.34,csapp,,0,0,0,,so here we've got a progress graph now where we've
Dialogue: 0,0:52:23.32,0:52:26.34,csapp,,0,0,0,,we've decorated our program with P and V operations 
Dialogue: 0,0:52:26.34,0:52:33.86,csapp,,0,0,0,,so we put the P before the critical section we execute  the critical section  and then we call V
Dialogue: 0,0:52:35.96,0:52:39.22,csapp,,0,0,0,,  and now if you were to look you remember P and V P increments
Dialogue: 0,0:52:40.52,0:52:44.72,csapp,,0,0,0,, the sum of P decrement the semaphore V increments of samba4
Dialogue: 0,0:52:45.68,0:52:53.54,csapp,,0,0,0,,so if you were just to look at the value of that semaphore for every point  in the execution state space
Dialogue: 0,0:52:54.90,0:52:57.94,csapp,,0,0,0,, you'd get these you'd get these values 
Dialogue: 0,0:52:57.96,0:53:03.12,csapp,,0,0,0,,so here we initialize the semaphore at the origin we initialized it to 1 
Dialogue: 0,0:53:03.14,0:53:10.16,csapp,,0,0,0,,so the the value of of our semaphore  at the origin is 1
Dialogue: 0,0:53:11.38,0:53:13.10,csapp,,0,0,0,,and let's say we just move along 
Dialogue: 0,0:53:13.12,0:53:14.78,csapp,,0,0,0,,so we're just executing thread 1 
Dialogue: 0,0:53:14.78,0:53:17.18,csapp,,0,0,0,,so after H 1 the semaphore is 1 
Dialogue: 0,0:53:19.02,0:53:25.04,csapp,,0,0,0,,we do the P the semaphore is 1 so P just decrement sit and it proceeds 
Dialogue: 0,0:53:25.50,0:53:28.76,csapp,,0,0,0,,so now the semaphore value becomes 0 
Dialogue: 0,0:53:29.56,0:53:33.02,csapp,,0,0,0,,and it remains zero until we execute the V 
Dialogue: 0,0:53:33.72,0:53:35.60,csapp,,0,0,0,,and when we finished executing the V 
Dialogue: 0,0:53:36.44,0:53:38.38,csapp,,0,0,0,,the semaphore now is is 1 again 
Dialogue: 0,0:53:40.10,0:53:42.10,csapp,,0,0,0,,okay so if we go through a similar reasoning
Dialogue: 0,0:53:42.90,0:53:48.18,csapp,,0,0,0,, if we look at the trajectory to get to any point  in this state space 
Dialogue: 0,0:53:48.22,0:53:52.34,csapp,,0,0,0,,so let's say let's say this point right here 
Dialogue: 0,0:53:54.86,0:54:02.78,csapp,,0,0,0,,so to get there we could we could execute thread 1 up to this point  finish the L 1 
Dialogue: 0,0:54:04.10,0:54:06.02,csapp,,0,0,0,,and then execute h 2 
Dialogue: 0,0:54:07.38,0:54:10.68,csapp,,0,0,0,,and then do the at this point the semaphore is 0
Dialogue: 0,0:54:13.00,0:54:17.04,csapp,,0,0,0,,and then P decrements the semaphore so now it's minus one
Dialogue: 0,0:54:17.86,0:54:20.38,csapp,,0,0,0,, but that's that's impossible that can't happen 
Dialogue: 0,0:54:21.04,0:54:25.62,csapp,,0,0,0,,because P plus remember if if the semaphore is 0 P blocks
Dialogue: 0,0:54:26.36,0:54:27.28,csapp,,0,0,0,, it doesn't decrement 
Dialogue: 0,0:54:28.40,0:54:35.70,csapp,,0,0,0,, it okay so the semantics of the P operation prohibits this  this this transition 
Dialogue: 0,0:54:36.34,0:54:43.06,csapp,,0,0,0,,it prohibits this transition to the state where the semaphore is zero to a state where it would be -1
Dialogue: 0,0:54:46.78,0:54:53.82,csapp,,0,0,0,, and so it creates it creates what we call a forbidden region so these  these points in the state space 
Dialogue: 0,0:54:54.84,0:55:01.20,csapp,,0,0,0,,where the the semaphore would have a value of -1 are are infeasible
Dialogue: 0,0:55:01.92,0:55:06.30,csapp,,0,0,0,, that can never be reached by the definition of of P and V
Dialogue: 0,0:55:07.92,0:55:13.34,csapp,,0,0,0,, ok so this this forms a forbidden region around the unsafe region
Dialogue: 0,0:55:13.88,0:55:20.92,csapp,,0,0,0,, and in doing so provides mutually exclusive access to the to the critical sections in each thread 
Dialogue: 0,0:55:22.04,0:55:22.58,csapp,,0,0,0,,okay so if 
Dialogue: 0,0:55:25.50,0:55:33.10,csapp,,0,0,0,,so this this is the fundamental reason why P's and Vees  can be used to provide mutually exclusive access
Dialogue: 0,0:55:36.96,0:55:37.98,csapp,,0,0,0,,so many questions on this
Dialogue: 0,0:55:41.20,0:55:43.60,csapp,,0,0,0,, I explained it so clearly that there's no questions
Dialogue: 0,0:55:48.50,0:55:54.02,csapp,,0,0,0,,all right good well you get to go you get to get to leave early then   work on your Mallik lab 
Dialogue: 0,0:55:54.86,0:55:55.52,csapp,,0,0,0,,so 
Dialogue: 0,0:55:57.56,0:55:58.80,csapp,,0,0,0,,all right so 
Dialogue: 0,0:55:59.64,0:56:04.04,csapp,,0,0,0,,we'll see you Monday we're going to look at sort of some advanced topics 
Dialogue: 0,0:56:04.06,0:56:06.92,csapp,,0,0,0,,this was like her first introduction to synchronization 
Dialogue: 0,0:56:07.36,0:56:12.10,csapp,,0,0,0,,on Tuesday we'll look at more advanced topics in synchronization in ways 
Dialogue: 0,0:56:12.20,0:56:13.96,csapp,,0,0,0,,ways that you can use semaphores for to 
Dialogue: 0,0:56:14.50,0:56:19.20,csapp,,0,0,0,,provide other other more interests other interesting kinds of synchronization for your programs 
Dialogue: 0,0:56:19.76,0:56:20.54,csapp,,0,0,0,,okay
