[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video File: ../../../Desktop/csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 731
Active Line: 739
Video Position: 127739

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.44,csapp,,0,0,0,,大家下午好\Ngood afternoon everybody
Dialogue: 0,0:00:02.24,0:00:03.90,csapp,,0,0,0,,welcome good to see you as always
Dialogue: 0,0:00:06.08,0:00:12.46,csapp,,0,0,0,,today we're going to learn about a important concept in computer science called virtual memory
Dialogue: 0,0:00:18.86,0:00:23.43,csapp,,0,0,0,,so consider a system that uses physical addressing
Dialogue: 0,0:00:23.43,0:00:27.08,csapp,,0,0,0,,right we've always our idea about memory so far has been that it's a a
Dialogue: 0,0:00:27.62,0:00:31.34,csapp,,0,0,0,,contiguous array of physical physical bytes
Dialogue: 0,0:00:31.90,0:00:37.08,csapp,,0,0,0,,that we can access just by giving some an offset called an address
Dialogue: 0,0:00:38.38,0:00:41.12,csapp,,0,0,0,,so in a system that uses physical addressing
Dialogue: 0,0:00:43.34,0:00:46.91,csapp,,0,0,0,,the CPU executes like say a move instruction
Dialogue: 0,0:00:47.54,0:00:50.74,csapp,,0,0,0,,which generates an effective address the physical address
Dialogue: 0,0:00:51.12,0:00:55.42,csapp,,0,0,0,, and this address is actually the offset of a byte in in main memory so
Dialogue: 0,0:00:56.22,0:01:00.22,csapp,,0,0,0,, you know here the CPU has generated a physical address of 4
Dialogue: 0,0:01:01.86,0:01:04.06,csapp,,0,0,0,,since that address to the to the memory
Dialogue: 0,0:01:05.72,0:01:13.20,csapp,,0,0,0,,and then the memory fetches the the word from at that address and then sends it back to the to the CPU
Dialogue: 0,0:01:15.84,0:01:20.40,csapp,,0,0,0,,now this is in fact the way that very simple microcontrollers work
Dialogue: 0,0:01:20.96,0:01:27.56,csapp,,0,0,0,, but it's not the way most systems work including your your phones, your desktops,your servers
Dialogue: 0,0:01:28.60,0:01:33.44,csapp,,0,0,0,,these systems instead virtualize this this main memory
Dialogue: 0,0:01:34.88,0:01:39.90,csapp,,0,0,0,,now the idea of virtualization is a very important one in computer science and it
Dialogue: 0,0:01:40.48,0:01:45.24,csapp,,0,0,0,,and it expands a lot of it applies to a lot of areas of computer systems
Dialogue: 0,0:01:46.10,0:01:48.48,csapp,,0,0,0,,now when you virtualize a resource
Dialogue: 0,0:01:49.26,0:01:54.76,csapp,,0,0,0,,you you present the user of that resource with some different kind of view of that resource
Dialogue: 0,0:01:56.30,0:02:01.42,csapp,,0,0,0,,you present typically some kind of an abstraction or some kind of a different view of the resource
Dialogue: 0,0:02:03.20,0:02:07.16,csapp,,0,0,0,, and you do it by interposing on accesses to that resource
Dialogue: 0,0:02:08.46,0:02:11.64,csapp,,0,0,0,,so in all cases there's some resource and you want to virtualize it
Dialogue: 0,0:02:12.48,0:02:17.58,csapp,,0,0,0,,and you do that by cepting or interposing on the accesses to that resource
Dialogue: 0,0:02:18.94,0:02:25.00,csapp,,0,0,0,,okay and then once you we saw this when we created wrapper functions for like malloc
Dialogue: 0,0:02:25.00,0:02:26.62,csapp,,0,0,0,,I will showing you inter positioning
Dialogue: 0,0:02:27.14,0:02:30.44,csapp,,0,0,0,,the same technique is used to virtualize a resource
Dialogue: 0,0:02:31.18,0:02:35.94,csapp,,0,0,0,, and and once you've intercepted that access then you can deal with it any way you want
Dialogue: 0,0:02:35.94,0:02:42.70,csapp,,0,0,0,,so that's how you have sort of full power to change a person to change the view of that resource okay
Dialogue: 0,0:02:43.86,0:02:46.62,csapp,,0,0,0,, so a good example you saw this when we looked at disks
Dialogue: 0,0:02:48.28,0:02:54.10,csapp,,0,0,0,,and you know physically disk consists of cylinders tracks sectors platters surfaces
Dialogue: 0,0:02:55.38,0:02:59.58,csapp,,0,0,0,,and and to access a particular sector on one of those disks
Dialogue: 0,0:02:59.58,0:03:03.40,csapp,,0,0,0,,you have to specify the cylinder and the track and the surface
Dialogue: 0,0:03:04.98,0:03:09.06,csapp,,0,0,0,,okay but we saw that the view that disk controller is present is actually different
Dialogue: 0,0:03:09.06,0:03:11.96,csapp,,0,0,0,, it's a virtualized view of the disk
Dialogue: 0,0:03:12.54,0:03:18.68,csapp,,0,0,0,, and the controller instead presents to the kernel a view of the disk as a series of a sequence of logical blocks
Dialogue: 0,0:03:21.04,0:03:27.48,csapp,,0,0,0,,and it presents that view by intercepting the requests from the seat from the kernel for i/o
Dialogue: 0,0:03:28.24,0:03:34.58,csapp,,0,0,0,,and changing those logical block numbers that that that the kernel sends into the actual physical address
Dialogue: 0,0:03:34.76,0:03:43.72,csapp,,0,0,0,,ok so that's a very very important example of virtualization in a system
Dialogue: 0,0:03:44.08,0:03:52.96,csapp,,0,0,0,, now the the memory is is that is a very is it is a crucial resource in the system
Dialogue: 0,0:03:52.96,0:03:57.94,csapp,,0,0,0,,and what we found is that it's it's useful to virtualize that that memory resource
Dialogue: 0,0:03:59.76,0:04:01.14,csapp,,0,0,0,,okay and the way this is done
Dialogue: 0,0:04:02.40,0:04:08.50,csapp,,0,0,0,,remember before we virtually the disk by having the disk controller intercept request
Dialogue: 0,0:04:09.44,0:04:12.00,csapp,,0,0,0,, in the case of the the main memory resource
Dialogue: 0,0:04:13.26,0:04:18.90,csapp,,0,0,0,,the requests are actually intercepted by a piece of hardware called the MMU the memory management unit
Dialogue: 0,0:04:19.98,0:04:24.16,csapp,,0,0,0,,so the way this works is that the CPU executes an instruction
Dialogue: 0,0:04:24.86,0:04:28.26,csapp,,0,0,0,, say it's a move instruction that generates some effect of address
Dialogue: 0,0:04:29.30,0:04:31.04,csapp,,0,0,0,,so this is actually a virtual address
Dialogue: 0,0:04:32.36,0:04:36.53,csapp,,0,0,0,,it's the CPU sends that address to the MMU
Dialogue: 0,0:04:37.38,0:04:42.10,csapp,,0,0,0,,which goes through a process called address translation which will will study later today
Dialogue: 0,0:04:42.92,0:04:48.86,csapp,,0,0,0,,and it converts that virtual address in this case 4100 into a physical address
Dialogue: 0,0:04:49.52,0:04:55.82,csapp,,0,0,0,,4 which actually corresponds to the address of that the data object that we want
Dialogue: 0,0:04:56.74,0:05:01.28,csapp,,0,0,0,,ok so once the MMU translates the virtual address to a physical address
Dialogue: 0,0:05:02.94,0:05:06.16,csapp,,0,0,0,, then the memory will return the the word at that at that address
Dialogue: 0,0:05:08.90,0:05:11.14,csapp,,0,0,0,, so this
Dialogue: 0,0:05:12.24,0:05:14.24,csapp,,0,0,0,,might wonder why in the world would you want to do this
Dialogue: 0,0:05:14.24,0:05:19.36,csapp,,0,0,0,,well it turns out there's all kinds of good reasons to virtualize the the address space
Dialogue: 0,0:05:20.14,0:05:22.74,csapp,,0,0,0,, and so before I can explain those to you I
Dialogue: 0,0:05:22.86,0:05:27.66,csapp,,0,0,0,,let me just define a few a few toff you terms
Dialogue: 0,0:05:28.90,0:05:32.26,csapp,,0,0,0,,so an address space is a set of addresses
Dialogue: 0,0:05:32.50,0:05:34.56,csapp,,0,0,0,,ok so an address spaces is a set
Dialogue: 0,0:05:35.58,0:05:39.74,csapp,,0,0,0,,not of not of data bytes but of the addresses of those bytes
Dialogue: 0,0:05:40.64,0:05:48.88,csapp,,0,0,0,,and a linear address space is a content is a contiguous set of contiguous non-negative integers
Dialogue: 0,0:05:49.68,0:05:53.28,csapp,,0,0,0,,okay so just 0,1,2,3,4 and so on
Dialogue: 0,0:05:54.60,0:06:01.52,csapp,,0,0,0,, the virtual address space is a set of N=2^n virtual addresses a linear it's a linear address space
Dialogue: 0,0:06:02.48,0:06:07.70,csapp,,0,0,0,,and the physical address space is a set of M=2^m physical addresses ok
Dialogue: 0,0:06:10.22,0:06:19.36,csapp,,0,0,0,,and so typically the virtual address space is is is usually much larger than the physical address space
Dialogue: 0,0:06:19.54,0:06:24.68,csapp,,0,0,0,,okay the physical address space corresponds to the amount of DRAM that you actually have in the system
Dialogue: 0,0:06:25.34,0:06:31.52,csapp,,0,0,0,,the virtual address space is the same for all all processes running on that system
Dialogue: 0,0:06:35.30,0:06:38.14,csapp,,0,0,0,,okay now why why do we want to implement virtual memory
Dialogue: 0,0:06:38.14,0:06:43.48,csapp,,0,0,0,,why do this why do I do this level of indirection with the MMU
Dialogue: 0,0:06:44.54,0:06:46.68,csapp,,0,0,0,,well there's really three big reasons so
Dialogue: 0,0:06:47.02,0:06:56.00,csapp,,0,0,0,, the first is that virtual memory uses the uses the DRAM as a cache for the actual data stored on disk
Dialogue: 0,0:06:56.82,0:07:03.14,csapp,,0,0,0,,okay so you can think of virtual memory as it as a DRAM cache for data stored on the disk
Dialogue: 0,0:07:03.66,0:07:08.58,csapp,,0,0,0,, and this allows us to to use the memory much more efficiently
Dialogue: 0,0:07:09.04,0:07:12.20,csapp,,0,0,0,, because we only need to cache items that are frequently used
Dialogue: 0,0:07:12.20,0:07:17.02,csapp,,0,0,0,,right just the same idea that we learned when we we talked about caches and locality
Dialogue: 0,0:07:19.06,0:07:23.46,csapp,,0,0,0,,so that's one thing we can use we can use the memory much more efficiently by only using
Dialogue: 0,0:07:24.04,0:07:30.50,csapp,,0,0,0,, the portions of the virtual address space by only actually storing the portions of the virtual address space in the physical memory
Dialogue: 0,0:07:32.26,0:07:35.16,csapp,,0,0,0,, okay the second thing is it greatly simplifies memory management
Dialogue: 0,0:07:35.96,0:07:40.48,csapp,,0,0,0,,so we saw it every process has the same the same view right
Dialogue: 0,0:07:40.48,0:07:44.18,csapp,,0,0,0,, there's code loaded at code and data are always loaded at the same address
Dialogue: 0,0:07:44.78,0:07:48.44,csapp,,0,0,0,, the stack is at the top of the user visible address space
Dialogue: 0,0:07:49.50,0:07:54.62,csapp,,0,0,0,,so every process has the same similar-looking virtual address space
Dialogue: 0,0:07:56.00,0:08:02.10,csapp,,0,0,0,,but in actual in actuality that the the memory that corresponds to those
Dialogue: 0,0:08:02.12,0:08:06.16,csapp,,0,0,0,, those addresses is actually scattered all over main memory
Dialogue: 0,0:08:06.90,0:08:14.46,csapp,,0,0,0,,okay so that's a really important important benefit of virtual memory and
Dialogue: 0,0:08:15.88,0:08:18.56,csapp,,0,0,0,,then finally it allows us to protect accesses
Dialogue: 0,0:08:18.66,0:08:23.28,csapp,,0,0,0,, so remember we had to
Dialogue: 0,0:08:24.02,0:08:28.24,csapp,,0,0,0,,a process we saw that a process provides the separate address space that's
Dialogue: 0,0:08:28.92,0:08:32.06,csapp,,0,0,0,,that's protected from accesses by other processes
Dialogue: 0,0:08:32.54,0:08:39.02,csapp,,0,0,0,,okay so virtual memory allows us to create these these separate protected private address spaces
Dialogue: 0,0:08:40.02,0:08:43.68,csapp,,0,0,0,,okay and so what we'll do today we'll look in more detail at these three ideas
Dialogue: 0,0:08:44.40,0:08:49.36,csapp,,0,0,0,,and then we'll and then we'll go into the specifics of address translation
Dialogue: 0,0:08:49.36,0:08:54.02,csapp,,0,0,0,,so I'm going to for the first the first part of this lecture
Dialogue: 0,0:08:54.02,0:08:57.88,csapp,,0,0,0,,we're going to talk about address translation just in kind of high-level terms
Dialogue: 0,0:08:58.40,0:09:02.46,csapp,,0,0,0,, but then we'll go into the details at the end you can see how it how it really works
Dialogue: 0,0:09:03.24,0:09:05.78,csapp,,0,0,0,,okay so let's look at VM as a tool for caching
Dialogue: 0,0:09:07.00,0:09:13.28,csapp,,0,0,0,,so conceptually you can think of the your virtual memory  as a sequence of bytes stored on disk
Dialogue: 0,0:09:15.82,0:09:24.54,csapp,,0,0,0,,and then the contents of that of the the contents of that virtual memory stored on disk are cached in DRAM
Dialogue: 0,0:09:25.28,0:09:33.70,csapp,,0,0,0,,okay so think of the the DRAM is a cache for this array of contiguous bytes stored on the disk
Dialogue: 0,0:09:35.18,0:09:38.44,csapp,,0,0,0,, and just like any cache the data is broken up into blocks
Dialogue: 0,0:09:40.62,0:09:46.22,csapp,,0,0,0,,okay and then we have so here we have the and those blocks for virtual memory systems are called pages
Dialogue: 0,0:09:47.30,0:09:52.10,csapp,,0,0,0,, they're typically typically larger than much larger than the cache blocks
Dialogue: 0,0:09:52.64,0:09:53.64,csapp,,0,0,0,, that we that we study done
Dialogue: 0,0:09:54.46,0:09:58.28,csapp,,0,0,0,,so for K bytes typically instead of the 64 bytes
Dialogue: 0,0:09:58.58,0:10:01.36,csapp,,0,0,0,, like that we that we learned about in when we studied cache memories
Dialogue: 0,0:10:02.64,0:10:08.30,csapp,,0,0,0,,so this virtual memory conceptually you can think of it as as being a sequence of pages stored on the disk
Dialogue: 0,0:10:09.44,0:10:10.88,csapp,,0,0,0,,so called virtual pages
Dialogue: 0,0:10:11.66,0:10:18.86,csapp,,0,0,0,,and each of these pages will identify with a number so here's virtual page 0 virtual page 1
Dialogue: 0,0:10:20.00,0:10:25.66,csapp,,0,0,0,,and then a subset of those pages are stored in in the physical memory in the physical DRAM memory
Dialogue: 0,0:10:27.08,0:10:29.46,csapp,,0,0,0,, and then there's some mapping function
Dialogue: 0,0:10:30.00,0:10:33.20,csapp,,0,0,0,, that tells us which pages have been cached 
Dialogue: 0,0:10:33.90,0:10:36.38,csapp,,0,0,0,,ok so in this case I've just shown a snapshot
Dialogue: 0,0:10:36.88,0:10:41.44,csapp,,0,0,0,,where we have three virtual pages cached somewhere in DRAM 
Dialogue: 0,0:10:42.50,0:10:49.60,csapp,,0,0,0,,okay and there's no relation between the virtual page number and the the physical page number that it's mapped to 
Dialogue: 0,0:10:51.44,0:10:55.52,csapp,,0,0,0,,some of these pages are are not cached so they're at they're still stored on disk 
Dialogue: 0,0:10:56.54,0:11:00.62,csapp,,0,0,0,,so in this case VP2 is still stored on disk 
Dialogue: 0,0:11:00.94,0:11:05.08,csapp,,0,0,0,,and there's some pages which aren't even allocated so they're they don't exist on the disk
Dialogue: 0,0:11:05.36,0:11:06.42,csapp,,0,0,0,,yet it's a way to think of that 
Dialogue: 0,0:11:06.94,0:11:08.56,csapp,,0,0,0,,right because we really wouldn't want to store 
Dialogue: 0,0:11:09.06,0:11:13.24,csapp,,0,0,0,,every single page in address space with that's to the size to the 48th 
Dialogue: 0,0:11:13.68,0:11:17.00,csapp,,0,0,0,, we really wouldn't want to store all those those on disk 
Dialogue: 0,0:11:18.50,0:11:21.60,csapp,,0,0,0,,so most of the address space is unallocated
Dialogue: 0,0:11:28.44,0:11:32.98,csapp,,0,0,0,, ok so we can just think of this so this this DRAM is just a cache
Dialogue: 0,0:11:33.62,0:11:36.22,csapp,,0,0,0,,but it has a much different organization
Dialogue: 0,0:11:36.44,0:11:38.34,csapp,,0,0,0,,than the cache memories we studied earlier
Dialogue: 0,0:11:38.72,0:11:43.80,csapp,,0,0,0,, and the difference is driven by that the enormous miss penalty  when you go from
Dialogue: 0,0:11:44.62,0:11:52.26,csapp,,0,0,0,, if you have a cache and DRAM the the Miss penalty would to fetch a data item from the disk is huge 
Dialogue: 0,0:11:53.90,0:12:00.08,csapp,,0,0,0,,so the the design of this virtual memory cache is totally driven by this enormous miss penalty
Dialogue: 0,0:12:01.48,0:12:04.14,csapp,,0,0,0,, and so as a result that blocks are larger 
Dialogue: 0,0:12:04.16,0:12:07.46,csapp,,0,0,0,,so remember we talked about that the block size is kind of a trade-off
Dialogue: 0,0:12:08.18,0:12:16.50,csapp,,0,0,0,, between sort of useful getting used being able to usefully amortize the cost of fetching that block 
Dialogue: 0,0:12:17.12,0:12:22.38,csapp,,0,0,0,,versus sort of consuming too much of this scarce cache space right 
Dialogue: 0,0:12:22.40,0:12:27.54,csapp,,0,0,0,,so in this case our cache memories were 64 byte blocks
Dialogue: 0,0:12:28.94,0:12:36.12,csapp,,0,0,0,,virtual most virtual memory systems have like 4K byte blocks with with an option to increase to 4 megabytes 
Dialogue: 0,0:12:36.66,0:12:38.56,csapp,,0,0,0,,in the case of x86
Dialogue: 0,0:12:40.86,0:12:44.40,csapp,,0,0,0,,and now this cash and other consequence of the enormous missed penalty is that
Dialogue: 0,0:12:46.48,0:12:49.68,csapp,,0,0,0,,you really want to have as large associativity as you can 
Dialogue: 0,0:12:49.78,0:12:54.60,csapp,,0,0,0,,remember we saw with direct mapped cache --is that were subject to to these conflict misses 
Dialogue: 0,0:12:54.98,0:12:58.16,csapp,,0,0,0,,and and if you if you increase the associativity of the cache 
Dialogue: 0,0:12:58.16,0:13:01.32,csapp,,0,0,0,,you reduce the the probability of those conflict misses 
Dialogue: 0,0:13:01.84,0:13:07.44,csapp,,0,0,0,,but you never completely eliminate them until you have a fully associative cache with just one set 
Dialogue: 0,0:13:08.04,0:13:12.12,csapp,,0,0,0,,okay so in a virtual memory in a virtual memory cache 
Dialogue: 0,0:13:14.08,0:13:19.28,csapp,,0,0,0,,it's fully associative there's one set and each virtual page can go anywhere in the cache 
Dialogue: 0,0:13:22.14,0:13:25.52,csapp,,0,0,0,,okay so this requires a really complicated mapping function 
Dialogue: 0,0:13:25.52,0:13:30.46,csapp,,0,0,0,,somehow we're going to have to keep track of where all these cached pages are 
Dialogue: 0,0:13:32.24,0:13:36.48,csapp,,0,0,0,,and we can't really do a search that would be that would be way too inexpensive 
Dialogue: 0,0:13:36.52,0:13:41.68,csapp,,0,0,0,,so you remember when we with a cache memory the hardware actually did a search within the set
Dialogue: 0,0:13:42.32,0:13:47.30,csapp,,0,0,0,, a parallel search to to to find try to find a cache line 
Dialogue: 0,0:13:48.26,0:13:51.70,csapp,,0,0,0,,but with a software cache like this that that's not feasible
Dialogue: 0,0:13:52.40,0:13:57.38,csapp,,0,0,0,,all right so somehow we're going to have to remember where these cached blocks are in this very large set 
Dialogue: 0,0:13:59.68,0:14:02.88,csapp,,0,0,0,,and again because it's so expensive if you make a mistake
Dialogue: 0,0:14:03.84,0:14:07.86,csapp,,0,0,0,, when you're trying to identify a victim victim page
Dialogue: 0,0:14:08.68,0:14:13.92,csapp,,0,0,0,, if you make a mistake and you evict a page that then is referenced again in the near future 
Dialogue: 0,0:14:14.30,0:14:16.42,csapp,,0,0,0,,you pay a big price for it okay 
Dialogue: 0,0:14:17.10,0:14:22.88,csapp,,0,0,0,,so virtual memory caches have much more sophisticated replacement algorithms than like simple LRU that 
Dialogue: 0,0:14:22.94,0:14:24.44,csapp,,0,0,0,,that we saw with cache memories
Dialogue: 0,0:14:25.30,0:14:28.88,csapp,,0,0,0,, now they're these replacement algorithms are outside of the scope of this course 
Dialogue: 0,0:14:29.06,0:14:31.00,csapp,,0,0,0,,you'll you'll you'll learn about them and when you take os 
Dialogue: 0,0:14:32.34,0:14:37.68,csapp,,0,0,0,,but because it's in software we can we can afford to do very expensive replacement algorithms 
Dialogue: 0,0:14:39.64,0:14:46.67,csapp,,0,0,0,,and we can take a long fairly relatively long time to execute the code for those algorithms
Dialogue: 0,0:14:47.32,0:14:57.06,csapp,,0,0,0,,because any time we spend figuring out a victim block will be much less than the cost of making a mistake
Dialogue: 0,0:14:57.44,0:15:02.58,csapp,,0,0,0,,and paying the the access time the miss time the miss penalty to to disk 
Dialogue: 0,0:15:03.54,0:15:09.92,csapp,,0,0,0,,and then also as a result of virtual memory systems never use right through  just  it takes to one 
Dialogue: 0,0:15:10.62,0:15:17.12,csapp,,0,0,0,,right so they always use right back and they try to defer writing anything back to the disk as long as possible
Dialogue: 0,0:15:19.74,0:15:21.64,csapp,,0,0,0,, alright now how do we keep track 
Dialogue: 0,0:15:21.64,0:15:26.36,csapp,,0,0,0,,somehow we have to keep track of this complicated cache and DRAM
Dialogue: 0,0:15:27.02,0:15:32.52,csapp,,0,0,0,,and the the data structure that keeps track of the location of the virtual pages
Dialogue: 0,0:15:33.06,0:15:35.82,csapp,,0,0,0,, in in memory is called the page table
Dialogue: 0,0:15:37.14,0:15:40.26,csapp,,0,0,0,, now a page table is just a data structure in memory
Dialogue: 0,0:15:41.02,0:15:44.92,csapp,,0,0,0,, that the kernel maintains for as part of each process context
Dialogue: 0,0:15:45.26,0:15:47.42,csapp,,0,0,0,, okay so every process has its own page table 
Dialogue: 0,0:15:48.48,0:15:54.70,csapp,,0,0,0,,and it's just a it's an array of so called page table entries or PTEs
Dialogue: 0,0:15:57.32,0:16:04.80,csapp,,0,0,0,, where PTEk contains the physical address of physical page K in DRAM okay
Dialogue: 0,0:16:09.60,0:16:13.70,csapp,,0,0,0,,so here's how it works there's there's this page table in DRAM 
Dialogue: 0,0:16:14.90,0:16:18.04,csapp,,0,0,0,,there's virtual pages stored on disk
Dialogue: 0,0:16:22.08,0:16:26.38,csapp,,0,0,0,, and then there's their stuff and then there's physical 
Dialogue: 0,0:16:26.38,0:16:30.60,csapp,,0,0,0,,there's virtual pages stored in various physical pages in DRAM 
Dialogue: 0,0:16:31.76,0:16:35.00,csapp,,0,0,0,,and then the page table keeps track of where those are stored
Dialogue: 0,0:16:35.48,0:16:41.86,csapp,,0,0,0,, so here we have a case this PTE 1 corresponds to virtual page 1 
Dialogue: 0,0:16:43.18,0:16:48.60,csapp,,0,0,0,,and in this case it says that virtual page 1 is mapped into physical page 0 
Dialogue: 0,0:16:50.12,0:16:55.30,csapp,,0,0,0,,virtual page 2 is mapped into physical page 1 and so on 
Dialogue: 0,0:16:57.30,0:17:05.72,csapp,,0,0,0,,ok now some of these the pages that aren't in memory are stored on disks the allocated pages 
Dialogue: 0,0:17:06.72,0:17:12.80,csapp,,0,0,0,,and so for those pages the page table entry contains a pointer to the location of that that page on disk
Dialogue: 0,0:17:13.26,0:17:17.94,csapp,,0,0,0,, so think of it as a logical block number where that page can be found on the disk 
Dialogue: 0,0:17:18.44,0:17:20.22,csapp,,0,0,0,,and then some of the pages are
Dialogue: 0,0:17:21.48,0:17:27.14,csapp,,0,0,0,,not allocated so there's there's a null null entry in the page table
Dialogue: 0,0:17:31.38,0:17:35.68,csapp,,0,0,0,,now a page hit so this is just a cache right so we have hits and misses 
Dialogue: 0,0:17:36.46,0:17:42.20,csapp,,0,0,0,,so a page hit occurs when there's a reference to a word and vert in the virtual address space
Dialogue: 0,0:17:42.90,0:17:46.70,csapp,,0,0,0,, that's contained in a page that's cached in the DRAM 
Dialogue: 0,0:17:48.94,0:17:55.20,csapp,,0,0,0,,okay so let's say that we have you know the CPU execute this and move instruction it generates a virtual address 
Dialogue: 0,0:17:56.78,0:17:57.96,csapp,,0,0,0,,the MMU
Dialogue: 0,0:17:59.44,0:18:07.08,csapp,,0,0,0,,looks up in the page table and let's say this virtual address is somewhere within virtual page two okay
Dialogue: 0,0:18:09.32,0:18:14.94,csapp,,0,0,0,,okay so that the MMU looks up the page table entry number two
Dialogue: 0,0:18:16.06,0:18:23.52,csapp,,0,0,0,,and it fought it extracts the physical address of that of that virtual page 2
Dialogue: 0,0:18:25.68,0:18:27.26,csapp,,0,0,0,,okay so that's a here so in this case
Dialogue: 0,0:18:30.16,0:18:35.24,csapp,,0,0,0,, in this case the the page is in memory it's cached in memory
Dialogue: 0,0:18:35.70,0:18:37.08,csapp,,0,0,0,, and so we have a hit
Dialogue: 0,0:18:37.54,0:18:48.12,csapp,,0,0,0,,and now the the memory can can return that can return that physical address to the MMU 
Dialogue: 0,0:18:52.46,0:19:00.94,csapp,,0,0,0,,now a miss is a reference to a word that's not cashed in in in physical memory
Dialogue: 0,0:19:00.94,0:19:08.42,csapp,,0,0,0,, so in this case virtual page 0 1 2 3 is not cached in DRAM 
Dialogue: 0,0:19:08.42,0:19:10.40,csapp,,0,0,0,,it's stored it's stored on the disk 
Dialogue: 0,0:19:13.58,0:19:18.40,csapp,,0,0,0,,so now that triggers a an exception ok page fault exception
Dialogue: 0,0:19:19.12,0:19:21.34,csapp,,0,0,0,, in the hardware the hardware triggers the exception 
Dialogue: 0,0:19:21.66,0:19:27.66,csapp,,0,0,0,,and that causes the transfer of control to a chunk of code in the kernel called the page fault handler
Dialogue: 0,0:19:28.84,0:19:35.54,csapp,,0,0,0,, which then selects a victim to be evicted in this case  virtual page 4
Dialogue: 0,0:19:37.20,0:19:41.12,csapp,,0,0,0,,and it fetches virtual page 3 from the disk 
Dialogue: 0,0:19:43.46,0:19:47.68,csapp,,0,0,0,,loads it up into memory and if and then changes 
Dialogue: 0,0:19:47.96,0:19:54.80,csapp,,0,0,0,,and and then updates this page table entry to reflect the fact that virtual page 4 is now stored on disk 
Dialogue: 0,0:19:55.72,0:20:01.64,csapp,,0,0,0,,and if virtual page 4 had been modified at any time it would have to write the contents of it that to disk as well 
Dialogue: 0,0:20:06.04,0:20:12.52,csapp,,0,0,0,,so once the once the handler is copied virtual page three into memory 
Dialogue: 0,0:20:13.40,0:20:17.95,csapp,,0,0,0,,the instruction that caused the page fault now can be re executed
Dialogue: 0,0:20:18.82,0:20:25.30,csapp,,0,0,0,,okay so once the so when the page fault handler in the kernel returns it returns to the faulting instruction
Dialogue: 0,0:20:25.72,0:20:26.90,csapp,,0,0,0,, which then reacts Acutes 
Dialogue: 0,0:20:28.20,0:20:35.84,csapp,,0,0,0,,and now that page is when the MMU checks that the PTE corresponding to that page
Dialogue: 0,0:20:36.38,0:20:38.26,csapp,,0,0,0,, it finds that it's indeed cache so
Dialogue: 0,0:20:38.56,0:20:43.04,csapp,,0,0,0,, so now the instruction can continue and we can fetch that 
Dialogue: 0,0:20:44.80,0:20:49.30,csapp,,0,0,0,,whatever whatever word at that virtual address from from the DRAM
Dialogue: 0,0:20:54.58,0:20:57.08,csapp,,0,0,0,,okay now we can we can allocate a new page of memories
Dialogue: 0,0:20:57.08,0:21:03.98,csapp,,0,0,0,, so in this example virtual page 0,1,2,3,4,5  is not allocated
Dialogue: 0,0:21:06.48,0:21:12.04,csapp,,0,0,0,, so if you need to let's say you do malloc of a very large chunk of virtual address space
Dialogue: 0,0:21:12.62,0:21:17.54,csapp,,0,0,0,, if if those pages if one of those pages hasn't been allocated yet then the kernel actually
Dialogue: 0,0:21:18.26,0:21:24.16,csapp,,0,0,0,,or the malloc function actually has to create allocate that memory by calling a function called s break 
Dialogue: 0,0:21:25.38,0:21:29.26,csapp,,0,0,0,,okay and then what s break does is actually allocates
Dialogue: 0,0:21:29.74,0:21:37.92,csapp,,0,0,0,,this this page and records where it's loaded now would probably actually put it up into 
Dialogue: 0,0:21:40.30,0:21:45.87,csapp,,0,0,0,,now I guess it wouldn't actually show up in that in the DRAM cache until it was that page was touched
Dialogue: 0,0:21:46.48,0:21:51.22,csapp,,0,0,0,,okay so just allocating space just changes this page table entry 
Dialogue: 0,0:21:51.74,0:21:56.22,csapp,,0,0,0,,and then when that page is actually touched then it'll be brought into the cache 
Dialogue: 0,0:21:58.18,0:22:02.72,csapp,,0,0,0,,so I don't know about you but the first time I learned about this I was
Dialogue: 0,0:22:02.82,0:22:08.52,csapp,,0,0,0,, I was pretty appalled it just seemed like the most inefficient terrible idea right 
Dialogue: 0,0:22:09.00,0:22:17.94,csapp,,0,0,0,,how in the world can you afford to on every single every single instruction  that that uses memory 
Dialogue: 0,0:22:18.48,0:22:22.22,csapp,,0,0,0,,do all this copying back and forth and looking up in tables
Dialogue: 0,0:22:22.64,0:22:24.08,csapp,,0,0,0,,and it just seems like an awful idea
Dialogue: 0,0:22:24.64,0:22:26.52,csapp,,0,0,0,,but once again locality saves us 
Dialogue: 0,0:22:27.02,0:22:31.48,csapp,,0,0,0,,okay and it it actually works because programs have locality 
Dialogue: 0,0:22:32.44,0:22:35.70,csapp,,0,0,0,,okay and it it's actually fairly efficient 
Dialogue: 0,0:22:36.92,0:22:43.34,csapp,,0,0,0,,and the reason is that at any point of time programs tend to access a set of pages called the working set 
Dialogue: 0,0:22:43.88,0:22:51.04,csapp,,0,0,0,,okay just by locality right by by temporal locality by the principle of temporal locality and spatial locality
Dialogue: 0,0:22:51.74,0:22:56.88,csapp,,0,0,0,, you tend to sort of reuse the same things reuse nearby things okay 
Dialogue: 0,0:22:57.14,0:23:02.42,csapp,,0,0,0,,and so if that working set is less than the main memory size 
Dialogue: 0,0:23:02.42,0:23:06.70,csapp,,0,0,0,,then all of the pages in the current were that will fit in memory and then things will be great 
Dialogue: 0,0:23:09.50,0:23:14.92,csapp,,0,0,0,,okay but if the some of the working set sizes for for every process right our systems running multiple processes
Dialogue: 0,0:23:15.40,0:23:17.20,csapp,,0,0,0,, if it exceeds the main memory size
Dialogue: 0,0:23:18.10,0:23:21.30,csapp,,0,0,0,, then you have this this meltdown where processes are 
Dialogue: 0,0:23:22.32,0:23:25.56,csapp,,0,0,0,,thrashing each other and causing pages to be copied back and forth 
Dialogue: 0,0:23:26.26,0:23:31.08,csapp,,0,0,0,,so you never ever know process ever gets it's working set fully into into memory okay 
Dialogue: 0,0:23:33.58,0:23:36.50,csapp,,0,0,0,,okay and we'll look at a technique when we look at address translation
Dialogue: 0,0:23:36.50,0:23:40.62,csapp,,0,0,0,, we'll look at a little hardware cache called a translation lookaside buffer 
Dialogue: 0,0:23:41.00,0:23:44.92,csapp,,0,0,0,,that that further exploits the locality property of programs 
Dialogue: 0,0:23:46.58,0:23:49.34,csapp,,0,0,0,,okay so that's virtual memory is a tool for caching 
Dialogue: 0,0:23:49.84,0:23:53.00,csapp,,0,0,0,,it's also a member of tool for memory management and
Dialogue: 0,0:23:53.20,0:23:57.32,csapp,,0,0,0,,it greatly simplifies all kinds of aspects of memory management for the kernel 
Dialogue: 0,0:23:59.72,0:24:04.38,csapp,,0,0,0,,so the key idea is that each process has its own virtual address space
Dialogue: 0,0:24:05.60,0:24:11.30,csapp,,0,0,0,, the kernel the kernel implements this by giving each process its own separate page table
Dialogue: 0,0:24:11.92,0:24:15.62,csapp,,0,0,0,, in the context of that process so it's it's just a data structure in the kernel 
Dialogue: 0,0:24:15.96,0:24:18.74,csapp,,0,0,0,,that the process key that the kernel keeps for that process
Dialogue: 0,0:24:22.54,0:24:29.84,csapp,,0,0,0,, and the the page table for each process Maps the virtual address space for that process 
Dialogue: 0,0:24:32.40,0:24:39.18,csapp,,0,0,0,,now what's interesting so you have that these these pages contiguous pages in the virtual address space
Dialogue: 0,0:24:39.54,0:24:44.08,csapp,,0,0,0,,  can be mapped anywhere in the in the in the DRAM in the physical address space
Dialogue: 0,0:24:44.78,0:24:47.62,csapp,,0,0,0,, so and they can be scattered all over the place 
Dialogue: 0,0:24:48.48,0:24:55.30,csapp,,0,0,0,,and different virtual pages and different processes can be mapped to different physical pages 
Dialogue: 0,0:24:55.30,0:24:59.38,csapp,,0,0,0,,so here we have virtual page one which is mapped to physical page two 
Dialogue: 0,0:25:00.44,0:25:06.02,csapp,,0,0,0,,in process one but in process two virtual page one is mapped to physical page eight 
Dialogue: 0,0:25:06.92,0:25:14.50,csapp,,0,0,0,,okay so in this way we can present a view to two each to the programmer and to the tools 
Dialogue: 0,0:25:15.66,0:25:20.54,csapp,,0,0,0,,that each process has a very similar address space virtual address space 
Dialogue: 0,0:25:20.54,0:25:23.46,csapp,,0,0,0,,same size address space code and data start at the same place
Dialogue: 0,0:25:24.42,0:25:28.48,csapp,,0,0,0,,but then the actual pages that that process used can be scattered in memory
Dialogue: 0,0:25:30.30,0:25:33.48,csapp,,0,0,0,,okay and then it gives us the most efficient way to use the memory 
Dialogue: 0,0:25:35.74,0:25:41.52,csapp,,0,0,0,,if we didn't have this mechanism think about how would you keep track let's say you had 50 processes running 
Dialogue: 0,0:25:41.82,0:25:43.68,csapp,,0,0,0,,on the machine at any point in time 
Dialogue: 0,0:25:43.84,0:25:50.36,csapp,,0,0,0,,how in the world would you keep track of where all of the the data  those processes were using 
Dialogue: 0,0:25:51.58,0:25:57.92,csapp,,0,0,0,,well one technique that you could imagine in fact it was used in the in the bad old days but before virtual memory 
Dialogue: 0,0:25:58.52,0:26:03.46,csapp,,0,0,0,,one thing you can imagine is that just give every process its own chunk of the physical address space 
Dialogue: 0,0:26:03.98,0:26:06.46,csapp,,0,0,0,,just take your physical address space partition it 
Dialogue: 0,0:26:07.08,0:26:11.18,csapp,,0,0,0,,and then each process gets loads and runs and it's its own part of the address space
Dialogue: 0,0:26:12.42,0:26:14.84,csapp,,0,0,0,, well this has all kinds of problems right I mean you could 
Dialogue: 0,0:26:15.56,0:26:17.88,csapp,,0,0,0,,if you what do you do if you add a process
Dialogue: 0,0:26:19.66,0:26:23.20,csapp,,0,0,0,, so you really can't partition the address space you really have to sort of say well 
Dialogue: 0,0:26:23.70,0:26:25.64,csapp,,0,0,0,,each process gets some little chunk 
Dialogue: 0,0:26:25.88,0:26:30.14,csapp,,0,0,0,,and I'm going to reserve some of the address space in case there's new processes that need memory
Dialogue: 0,0:26:31.94,0:26:34.38,csapp,,0,0,0,, another problem is that now you have to write your programs
Dialogue: 0,0:26:35.14,0:26:37.56,csapp,,0,0,0,,you can't just link your program ahead of time 
Dialogue: 0,0:26:38.40,0:26:42.06,csapp,,0,0,0,, because it has to be relocated when it's loaded right
Dialogue: 0,0:26:42.06,0:26:48.06,csapp,,0,0,0,, because you don't you know a process you don't know where in the memory it's going to go it's going to get some chunk 
Dialogue: 0,0:26:49.12,0:26:52.28,csapp,,0,0,0,,so you have to either relocate all the the references
Dialogue: 0,0:26:53.52,0:26:57.10,csapp,,0,0,0,,that the references to global symbols at when it's actually loaded 
Dialogue: 0,0:26:58.42,0:27:03.20,csapp,,0,0,0,,or you have to create a system where all of the instructions are relative 
Dialogue: 0,0:27:03.46,0:27:10.78,csapp,,0,0,0,,so there's there's no absolute addresses all addresses are relative to say the start of the program something like that 
Dialogue: 0,0:27:11.79,0:27:14.22,csapp,,0,0,0,,so anyway all of these things are just terribly complicated 
Dialogue: 0,0:27:15.24,0:27:20.04,csapp,,0,0,0,,and they're all solved beautifully by virtual memory
Dialogue: 0,0:27:26.14,0:27:31.78,csapp,,0,0,0,,so the each virtual page can be mapped to any physical page so that really helps simplify things
Dialogue: 0,0:27:32.56,0:27:38.48,csapp,,0,0,0,, and even at different times the same virtual page can be stored in different physical pages at different times
Dialogue: 0,0:27:38.90,0:27:42.58,csapp,,0,0,0,,all right so if a page for it for a while it might be cached in one physical page
Dialogue: 0,0:27:43.00,0:27:48.48,csapp,,0,0,0,, then it gets swapped out and the next time it's referenced it can get cached in a different physical page if
Dialogue: 0,0:27:49.12,0:27:51.48,csapp,,0,0,0,,that if it's no longer available right so it provides
Dialogue: 0,0:27:51.88,0:27:56.12,csapp,,0,0,0,, so the most flexible scheduling freedom 
Dialogue: 0,0:27:58.56,0:28:01.82,csapp,,0,0,0,,in the way that we in the way that we manage the memory
Dialogue: 0,0:28:03.04,0:28:05.54,csapp,,0,0,0,, and it also provides this really neat capability
Dialogue: 0,0:28:05.96,0:28:08.90,csapp,,0,0,0,, where you can map virtual pages to the same physical page 
Dialogue: 0,0:28:09.72,0:28:18.40,csapp,,0,0,0,,so there's this is a very simple straightforward way for multiple processes to share certain code or data
Dialogue: 0,0:28:19.64,0:28:27.48,csapp,,0,0,0,,okay and what what you do is you just that the page table entry in these different processes 
Dialogue: 0,0:28:27.52,0:28:29.56,csapp,,0,0,0,,just points to the same physical page 
Dialogue: 0,0:28:29.56,0:28:34.52,csapp,,0,0,0,,so in this case virtual page 2 points to physical page 6
Dialogue: 0,0:28:34.58,0:28:39.74,csapp,,0,0,0,, in each of in each of the page tables for process 1 and process 2 
Dialogue: 0,0:28:41.04,0:28:44.02,csapp,,0,0,0,,so this is how shared libraries are implemented
Dialogue: 0,0:28:44.62,0:28:48.70,csapp,,0,0,0,, right so Lipsy is the same code for every process running on the system
Dialogue: 0,0:28:49.66,0:28:54.26,csapp,,0,0,0,, so Lipsy just needs to be loaded once into physical into physical memory
Dialogue: 0,0:28:54.96,0:28:59.76,csapp,,0,0,0,,and then processes that want to access functions and data in Lib C just map 
Dialogue: 0,0:29:00.42,0:29:05.28,csapp,,0,0,0,,the pages in their virtual address space to the physical pages where Lib C is actually loaded 
Dialogue: 0,0:29:06.34,0:29:09.44,csapp,,0,0,0,,ok so now there's only one copy of Lib C everywhere in the system
Dialogue: 0,0:29:09.92,0:29:12.10,csapp,,0,0,0,, but every process thinks it's got its own copy
Dialogue: 0,0:29:16.88,0:29:23.12,csapp,,0,0,0,,now this this virtual memory for met
Dialogue: 0,0:29:23.40,0:29:29.04,csapp,,0,0,0,,using virtual memory to help simplify memory management greatly simplifies linking and loading 
Dialogue: 0,0:29:30.16,0:29:33.84,csapp,,0,0,0,,ok for the reasons I mentioned before linkers now can assume that every 
Dialogue: 0,0:29:34.66,0:29:37.70,csapp,,0,0,0,,every program is going to be loaded at exactly the same place 
Dialogue: 0,0:29:37.88,0:29:40.40,csapp,,0,0,0,,so the linker knows ahead of time where everything is going to be 
Dialogue: 0,0:29:41.28,0:29:45.72,csapp,,0,0,0,,and then it can resolve it can relocate all those references accordingly 
Dialogue: 0,0:29:49.46,0:29:53.60,csapp,,0,0,0,,now it really makes loading as simple 
Dialogue: 0,0:29:55.90,0:29:58.08,csapp,,0,0,0,,so what so execve the loader
Dialogue: 0,0:30:00.62,0:30:05.40,csapp,,0,0,0,, if you want to load a program now execve looks at the elf binary the executable binary
Dialogue: 0,0:30:06.50,0:30:12.80,csapp,,0,0,0,, ok it sees how it identifies how big the code and the data sections in that binary are 
Dialogue: 0,0:30:14.04,0:30:18.70,csapp,,0,0,0,,it allocates virtual memory starting at a fixed address for the code and data ok
Dialogue: 0,0:30:21.04,0:30:24.38,csapp,,0,0,0,,it creates PTEs for them and marks each of them is invalid 
Dialogue: 0,0:30:26.14,0:30:31.62,csapp,,0,0,0,,ok so each each PTE contains a valid mapping 
Dialogue: 0,0:30:31.62,0:30:37.06,csapp,,0,0,0,,so each PTE that's mapped to code and data contains a valid physical page number 
Dialogue: 0,0:30:38.04,0:30:42.88,csapp,,0,0,0,,but then the it does this trick of setting the valid bit to 0 
Dialogue: 0,0:30:45.46,0:30:50.70,csapp,,0,0,0,,so when the when the MMU X encounters a PTE whose valid bit is 0
Dialogue: 0,0:30:51.66,0:30:52.96,csapp,,0,0,0,,it triggers a page fault 
Dialogue: 0,0:30:53.30,0:30:57.36,csapp,,0,0,0,,right it looks as though that page is not has not been initialized yet 
Dialogue: 0,0:30:57.50,0:31:03.88,csapp,,0,0,0,, so it's kind of a trick right and then that triggers a page fault  to the kernel
Dialogue: 0,0:31:06.02,0:31:16.32,csapp,,0,0,0,, and then the kernel will then can then copy that that page into into physical memory 
Dialogue: 0,0:31:17.14,0:31:23.86,csapp,,0,0,0,,ok so this the the loading actually programs and data aren't actually they're not low loaded
Dialogue: 0,0:31:24.40,0:31:26.36,csapp,,0,0,0,,you know they're not just like copied into memory 
Dialogue: 0,0:31:27.16,0:31:32.52,csapp,,0,0,0,,it happens as a result of of page faults it happens as a result of misses 
Dialogue: 0,0:31:34.76,0:31:39.44,csapp,,0,0,0,,when and it's deferred to until a bite in that page is accessed 
Dialogue: 0,0:31:40.26,0:31:42.02,csapp,,0,0,0,,okay so this is called demand paging okay 
Dialogue: 0,0:31:43.26,0:31:46.30,csapp,,0,0,0,,but it's really just like any any of the other caches we've looked at right 
Dialogue: 0,0:31:46.30,0:31:53.36,csapp,,0,0,0,,you don't you don't load a block into the cache until a word within that block is is accessed okay 
Dialogue: 0,0:31:55.98,0:32:00.96,csapp,,0,0,0,,so so loading actually so loading is actually this is a very efficient mechanism right because 
Dialogue: 0,0:32:01.54,0:32:08.42,csapp,,0,0,0,,you may have a program that contains a huge say a huge array a large array 
Dialogue: 0,0:32:08.90,0:32:11.32,csapp,,0,0,0,,but you're only accessing a portion of that array
Dialogue: 0,0:32:12.70,0:32:18.90,csapp,,0,0,0,, so that that entire array won't actually be be allocated the pages will only come into DRAM
Dialogue: 0,0:32:19.60,0:32:22.04,csapp,,0,0,0,, when they're when a word within that page is touched
Dialogue: 0,0:32:23.02,0:32:26.20,csapp,,0,0,0,, so if you're only accessing a portion of this extremely large array 
Dialogue: 0,0:32:27.24,0:32:31.60,csapp,,0,0,0,,only the data that you access gets gets loaded and used 
Dialogue: 0,0:32:32.02,0:32:38.44,csapp,,0,0,0,,so it's a it's a very very smart mechanism and extremely helpful for
Dialogue: 0,0:32:38.60,0:32:41.54,csapp,,0,0,0,, for allowing us to use this precious memory resource
Dialogue: 0,0:32:43.58,0:32:54.66,csapp,,0,0,0,,okay so the third the third motivation for virtual memory  is that it helps us protect portions of memory
Dialogue: 0,0:32:55.84,0:32:58.72,csapp,,0,0,0,, so you recall that our processes
Dialogue: 0,0:32:59.32,0:33:04.56,csapp,,0,0,0,,you know portions of our virtual address space or read-only like the the code section
Dialogue: 0,0:33:06.60,0:33:10.86,csapp,,0,0,0,, okay and there are other portions of the address space that can only be executed by the kernel 
Dialogue: 0,0:33:13.38,0:33:14.30,csapp,,0,0,0,,okay so on 
Dialogue: 0,0:33:17.96,0:33:24.34,csapp,,0,0,0,,on systems like x86-64,it's it's a 64-bit system 
Dialogue: 0,0:33:24.46,0:33:27.46,csapp,,0,0,0,,so the pointers and addresses or 64 bits 
Dialogue: 0,0:33:28.56,0:33:32.16,csapp,,0,0,0,,but in actuality the real virtual address space is 48 bits 
Dialogue: 0,0:33:33.28,0:33:35.40,csapp,,0,0,0,,okay so it's it's only it's 2^48
Dialogue: 0,0:33:36.44,0:33:42.85,csapp,,0,0,0,,and then the the high-order bits after bit 48 are either all zeros or all ones
Dialogue: 0,0:33:43.70,0:33:51.14,csapp,,0,0,0,,okay so and that's so that's just the that's the that sort of Intel's rule
Dialogue: 0,0:33:51.40,0:33:58.58,csapp,,0,0,0,,okay for and so the the addresses where the high order bits are all ones are reserved for the kernel
Dialogue: 0,0:33:58.80,0:34:01.18,csapp,,0,0,0,, the kernels code and the kernels data 
Dialogue: 0,0:34:02.58,0:34:05.78,csapp,,0,0,0,,okay the addresses were all the bits are zero or reserved for user code 
Dialogue: 0,0:34:06.66,0:34:11.98,csapp,,0,0,0,,okay so so any reference any address that contains all ones in those higher order bits
Dialogue: 0,0:34:12.62,0:34:16.38,csapp,,0,0,0,, is by definition either code or data in the kernel
Dialogue: 0,0:34:17.24,0:34:22.48,csapp,,0,0,0,, and so you can you can add bits to the PTE
Dialogue: 0,0:34:23.20,0:34:28.66,csapp,,0,0,0,,that specify whether certain virtual pages can be accessed by user code 
Dialogue: 0,0:34:28.66,0:34:33.18,csapp,,0,0,0,,or if they have to be accessed by the by the kernel so this so-called supervisor mode 
Dialogue: 0,0:34:33.62,0:34:41.38,csapp,,0,0,0,,and you can also add bits that control whether that that page can be read written or executed 
Dialogue: 0,0:34:42.12,0:34:49.44,csapp,,0,0,0,,okay so this this executes bit is new with x86-64 it didn't exist in 32-bit x86 systems
Dialogue: 0,0:34:50.50,0:34:57.04,csapp,,0,0,0,,and this is the technique that's used now to try to prevent against 
Dialogue: 0,0:34:58.04,0:35:00.48,csapp,,0,0,0,,attack lab code injection style attacks 
Dialogue: 0,0:35:01.00,0:35:02.30,csapp,,0,0,0,,because it makes it impossible 
Dialogue: 0,0:35:02.64,0:35:09.30,csapp,,0,0,0,,if this bit is set you can't load instructions from from any any byte within that page 
Dialogue: 0,0:35:10.86,0:35:14.92,csapp,,0,0,0,,and so in fact it was it was this the introduction of this execute bit
Dialogue: 0,0:35:14.92,0:35:20.12,csapp,,0,0,0,, that's or led to things like return-oriented programming attacks like you did in your attack lab
Dialogue: 0,0:35:22.88,0:35:30.12,csapp,,0,0,0,,okay so this by just the simple technique of adding adding bits to the PTE
Dialogue: 0,0:35:30.72,0:35:33.82,csapp,,0,0,0,,we provide a way attic way to to protect 
Dialogue: 0,0:35:34.36,0:35:40.70,csapp,,0,0,0,,different parts of our virtual address space from unauthorized accesses 
Dialogue: 0,0:35:41.60,0:35:44.84,csapp,,0,0,0,,and then the the MMU actually checks these bits on each access
Dialogue: 0,0:35:44.88,0:35:49.50,csapp,,0,0,0,, and if there's if there's a problem you know if if you're trying to do a right and the right 
Dialogue: 0,0:35:50.84,0:35:56.48,csapp,,0,0,0,,the right that's not enabled then it throws an exception which then the kernel the colonel deals with 
Dialogue: 0,0:36:00.42,0:36:05.44,csapp,,0,0,0,,ok so so far I've been talking about address translation it kind of high-level high-level terms
Dialogue: 0,0:36:05.44,0:36:08.66,csapp,,0,0,0,,so let's let's get down to details and see how it really works
Dialogue: 0,0:36:10.86,0:36:17.88,csapp,,0,0,0,,okay so we're given a virtual address of n elements physical address of M elements
Dialogue: 0,0:36:19.70,0:36:23.93,csapp,,0,0,0,, like I said before n is usually larger than M but it doesn't have to be
Dialogue: 0,0:36:25.64,0:36:29.62,csapp,,0,0,0,,okay it's perfectly there's no reason m M could be much larger than n 
Dialogue: 0,0:36:30.76,0:36:34.06,csapp,,0,0,0,,and there it's typically not but but it could be
Dialogue: 0,0:36:35.52,0:36:40.84,csapp,,0,0,0,,and so given these two address spaces we have a map function that takes that maps from V to P 
Dialogue: 0,0:36:41.30,0:36:45.78,csapp,,0,0,0,,with an optional empty set or with an additional empty set 
Dialogue: 0,0:36:46.80,0:36:51.28,csapp,,0,0,0,,and so for virtual address a map a is equal to a prime
Dialogue: 0,0:36:51.72,0:36:55.76,csapp,,0,0,0,, if the data at virtual address a is a physical address a prime 
Dialogue: 0,0:36:55.78,0:36:59.70,csapp,,0,0,0,,okay so I mean that's just what we it's just a little more formal way to say 
Dialogue: 0,0:36:59.84,0:37:03.48,csapp,,0,0,0,,what we've been talking about before with our diagrams 
Dialogue: 0,0:37:04.60,0:37:09.96,csapp,,0,0,0,,and then map a is the empty set if the data at virtual address a is not in physical memory 
Dialogue: 0,0:37:13.92,0:37:20.12,csapp,,0,0,0,,okay so just for a summary I'm going to put up a list of all the symbols we're going to be using in address translation 
Dialogue: 0,0:37:20.48,0:37:25.32,csapp,,0,0,0,,but this is just for summary this is just for reference if you're using the slides later on 
Dialogue: 0,0:37:28.76,0:37:31.62,csapp,,0,0,0,,okay so here's how address translation where the page table works 
Dialogue: 0,0:37:34.84,0:37:36.44,csapp,,0,0,0,,so we're given some virtual address 
Dialogue: 0,0:37:38.48,0:37:40.10,csapp,,0,0,0,,that consists of n bits
Dialogue: 0,0:37:42.80,0:37:48.52,csapp,,0,0,0,,and we have blocks that consists of whose size can be represented with P bits 
Dialogue: 0,0:37:53.42,0:37:55.02,csapp,,0,0,0,,okay so think about this now there 
Dialogue: 0,0:37:56.48,0:38:01.32,csapp,,0,0,0,,so this is very similar to what we looked at when we did caching you know the address bits for a cache 
Dialogue: 0,0:38:02.46,0:38:06.82,csapp,,0,0,0,,so these first P bits correspond to the page offset 
Dialogue: 0,0:38:06.82,0:38:10.42,csapp,,0,0,0,,so this is analogous to the blocks offsets that we saw with caches 
Dialogue: 0,0:38:13.92,0:38:18.12,csapp,,0,0,0,,and then the remaining bits correspond to the the virtual page number
Dialogue: 0,0:38:19.06,0:38:23.62,csapp,,0,0,0,, this is so member this is fully associative right so there's only one set 
Dialogue: 0,0:38:24.20,0:38:28.86,csapp,,0,0,0,,so in a fully associative cache everything after the block offset is tagged 
Dialogue: 0,0:38:29.30,0:38:34.68,csapp,,0,0,0,,so think of this as like a tag this is the this is what uniquely identifies this block 
Dialogue: 0,0:38:36.88,0:38:41.00,csapp,,0,0,0,,and we in virtual memory parlance we refer to it as a virtual page number 
Dialogue: 0,0:38:43.16,0:38:49.34,csapp,,0,0,0,,now the page table the beginning of the page table is pointed to by this page table based register 
Dialogue: 0,0:38:49.36,0:38:53.70,csapp,,0,0,0,,on intel systems  that's it's called cr3 control register 3 
Dialogue: 0,0:38:54.60,0:39:00.43,csapp,,0,0,0,,but this reg this register contains the physical address of the page table in memory ok
Dialogue: 0,0:39:01.34,0:39:02.44,csapp,,0,0,0,,the beginning of that 
Dialogue: 0,0:39:04.50,0:39:10.62,csapp,,0,0,0,,and so when the when the CPU presents a virtual page a virtual address to the MMU 
Dialogue: 0,0:39:11.98,0:39:14.28,csapp,,0,0,0,,it it takes the virtual page number 
Dialogue: 0,0:39:15.16,0:39:18.38,csapp,,0,0,0,,and uses that as an index into the page table 
Dialogue: 0,0:39:20.98,0:39:28.68,csapp,,0,0,0,,ok and then it and then it into and that identifies a page table entry which contains if this is mapped into memory 
Dialogue: 0,0:39:29.02,0:39:33.24,csapp,,0,0,0,,I contains the physical address of the of the corresponding physical page 
Dialogue: 0,0:39:36.48,0:39:40.60,csapp,,0,0,0,,ok so the whole purpose of address translation is to come up you're given a virtual address 
Dialogue: 0,0:39:41.44,0:39:43.86,csapp,,0,0,0,,and you want to come up with a corresponding physical address 
Dialogue: 0,0:39:46.42,0:39:54.00,csapp,,0,0,0,,ok so the physical address the physical the physical page number portion of the physical address comes out of the page table entry 
Dialogue: 0,0:39:55.52,0:39:59.54,csapp,,0,0,0,,and this is interesting the the physical page offset portion of the physical address 
Dialogue: 0,0:40:00.36,0:40:04.58,csapp,,0,0,0,,comes out of the virtual page offset and it those bits are identical
Dialogue: 0,0:40:06.44,0:40:11.94,csapp,,0,0,0,,okay so now you should you should convince yourself that this is true right the 
Dialogue: 0,0:40:12.94,0:40:18.80,csapp,,0,0,0,,the the offset in a virtual block is going to be the same as the offset in a physical block 
Dialogue: 0,0:40:19.26,0:40:20.66,csapp,,0,0,0,,they're the same size blocks 
Dialogue: 0,0:40:26.00,0:40:28.50,csapp,,0,0,0,,and and you can also see why this virtual page number 
Dialogue: 0,0:40:29.74,0:40:35.66,csapp,,0,0,0,,it identifies the the that the page number in the in the page table 
Dialogue: 0,0:40:36.56,0:40:40.78,csapp,,0,0,0,,so imagine so imagine a virtual address that's all zeros 
Dialogue: 0,0:40:42.60,0:40:46.40,csapp,,0,0,0,,okay all zeros so it's virtual address zero 
Dialogue: 0,0:40:47.84,0:40:52.10,csapp,,0,0,0,,and now that that will have a virtual page number of zero
Dialogue: 0,0:40:53.76,0:40:56.40,csapp,,0,0,0,, and the byte at that address will be at offset zero
Dialogue: 0,0:40:58.80,0:41:01.32,csapp,,0,0,0,,okay now increment by one virtual address one 
Dialogue: 0,0:41:02.58,0:41:07.54,csapp,,0,0,0,,so that will be in an offset of 1 and it will be in the same virtual page of zero 
Dialogue: 0,0:41:08.12,0:41:13.18,csapp,,0,0,0,,right now keep incrementing until all of the all of the bits in the virtual page offset are ones 
Dialogue: 0,0:41:14.22,0:41:16.38,csapp,,0,0,0,,and the virtual page numbers is zero 
Dialogue: 0,0:41:16.50,0:41:20.88,csapp,,0,0,0,,okay so this is the last byte in in that virtual page zero 
Dialogue: 0,0:41:21.84,0:41:23.42,csapp,,0,0,0,,now increment one more time
Dialogue: 0,0:41:26.16,0:41:30.90,csapp,,0,0,0,,the one bit carries over to the virtual page number so now now we go to the next virtual page
Dialogue: 0,0:41:31.86,0:41:34.24,csapp,,0,0,0,, and it's at an offset of zero okay so 
Dialogue: 0,0:41:35.30,0:41:39.38,csapp,,0,0,0,,so can you see it's it's it's sort of sort of obvious when you think about it like that 
Dialogue: 0,0:41:40.30,0:41:46.86,csapp,,0,0,0,,you know why we can just take these these bits after the virtual page offset and use them to uniquely identify 
Dialogue: 0,0:41:47.14,0:41:50.20,csapp,,0,0,0,,what virtual page were we're working with 
Dialogue: 0,0:41:51.44,0:41:56.32,csapp,,0,0,0,,okay so let's see how I let's see how it works in this system in more detail 
Dialogue: 0,0:41:57.48,0:42:02.40,csapp,,0,0,0,,so our system our CPU sends a virtual address to the MMU as a result of executing 
Dialogue: 0,0:42:02.64,0:42:08.78,csapp,,0,0,0,,a move instruction or call or return or any kind of control transfer
Dialogue: 0,0:42:09.50,0:42:10.70,csapp,,0,0,0,, the MMU 
Dialogue: 0,0:42:13.62,0:42:19.64,csapp,,0,0,0,,looks up the the PTE so it fetches the PTE from the page cable stored in memory 
Dialogue: 0,0:42:20.04,0:42:25.52,csapp,,0,0,0,,so this is actually going off the chip onto memory into this PTE stored in memory 
Dialogue: 0,0:42:26.50,0:42:34.50,csapp,,0,0,0,,it gets the it fetches the PTE extracts the and uses that PTE to construct the physical address
Dialogue: 0,0:42:35.90,0:42:40.88,csapp,,0,0,0,, okay and then it it sends that physical address to the cache and memory system
Dialogue: 0,0:42:41.34,0:42:44.98,csapp,,0,0,0,, which eventually results in the data being returned back to the CPU 
Dialogue: 0,0:42:46.10,0:42:50.30,csapp,,0,0,0,,okay so even for a hit we still have memory references 
Dialogue: 0,0:42:50.72,0:42:53.58,csapp,,0,0,0,,right because we have to fetch that that page table entry
Dialogue: 0,0:42:57.86,0:43:02.22,csapp,,0,0,0,,now miss is in this parlance is called a page fault 
Dialogue: 0,0:43:02.96,0:43:08.94,csapp,,0,0,0,,so in this case the same thing happens as before that the CPU sends the virtual address to the MMU
Dialogue: 0,0:43:09.44,0:43:12.86,csapp,,0,0,0,,the MMU fetches that the PTE for memory
Dialogue: 0,0:43:13.40,0:43:16.54,csapp,,0,0,0,, but then when it looks then when the MMU looks at the PTE
Dialogue: 0,0:43:16.78,0:43:22.14,csapp,,0,0,0,, it sees that there's either an invalid valid bit or a zero valid bit or the
Dialogue: 0,0:43:23.54,0:43:26.56,csapp,,0,0,0,, the it's indicated that the data stored on disk 
Dialogue: 0,0:43:30.10,0:43:35.90,csapp,,0,0,0,,and so in that case it the MMU triggers a page fault exception 
Dialogue: 0,0:43:36.62,0:43:39.14,csapp,,0,0,0,,which transfers control to this page fault handler 
Dialogue: 0,0:43:40.94,0:43:43.40,csapp,,0,0,0,,the handler identifies a victim and 
Dialogue: 0,0:43:44.66,0:43:47.80,csapp,,0,0,0,,if it's been modified copies it out to disk
Dialogue: 0,0:43:50.12,0:43:55.94,csapp,,0,0,0,, then it fetches the new page from disk into into memory and up through the cache hierarchy 
Dialogue: 0,0:43:57.54,0:44:00.96,csapp,,0,0,0,,ok and then it did
Dialogue: 0,0:44:01.42,0:44:07.00,csapp,,0,0,0,, and then it causes that the then the handler returns to the to the process 
Dialogue: 0,0:44:08.80,0:44:11.32,csapp,,0,0,0,,and when a handler for a fault returns
Dialogue: 0,0:44:11.70,0:44:14.96,csapp,,0,0,0,, it causes the the faulting instruction to re execute 
Dialogue: 0,0:44:15.00,0:44:21.56,csapp,,0,0,0,,so now the  the move instruction that that faulted is re-execute but this time there's a page hit
Dialogue: 0,0:44:27.78,0:44:32.46,csapp,,0,0,0,,now you may you may be interested how how the cash is integrated into all of this
Dialogue: 0,0:44:34.00,0:44:39.66,csapp,,0,0,0,,so the MMU send fetches page table entries
Dialogue: 0,0:44:40.20,0:44:43.14,csapp,,0,0,0,, so it passes page table addresses to the cash
Dialogue: 0,0:44:44.08,0:44:46.24,csapp,,0,0,0,,if those missed those go to memory 
Dialogue: 0,0:44:48.16,0:44:51.92,csapp,,0,0,0,,the memory returns those page table entries to the cache 
Dialogue: 0,0:44:52.80,0:44:55.88,csapp,,0,0,0,,and then ultimately to the to the MMU 
Dialogue: 0,0:44:56.66,0:45:02.26,csapp,,0,0,0,,the MMU constructs that physical address and then its sense that physical address to the cache 
Dialogue: 0,0:45:02.36,0:45:07.66,csapp,,0,0,0,,right so so with caching the way we've been caching is done using physical addresses
Dialogue: 0,0:45:10.52,0:45:15.70,csapp,,0,0,0,,okay in this case it's also possible to construct caches that work with virtual addresses but yes
Dialogue: 0,0:45:15.70,0:45:25.08,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:45:25.18,0:45:27.30,csapp,,0,0,0,,yeah so it will get into that 
Dialogue: 0,0:45:27.30,0:45:32.24,csapp,,0,0,0,,okay so the question is how is how is the virtual address space implemented on disk 
Dialogue: 0,0:45:33.16,0:45:39.86,csapp,,0,0,0,,and it when it actually does a much more efficient thing than the the sort of a abstract model that I described
Dialogue: 0,0:45:40.38,0:45:44.92,csapp,,0,0,0,,so most pages there's an option when you allocate a new virtual memory page 
Dialogue: 0,0:45:45.44,0:45:47.94,csapp,,0,0,0,,you can allocate it so that it's all zeros
Dialogue: 0,0:45:49.58,0:45:54.32,csapp,,0,0,0,,okay so there's a special you can say I want this I want to allocate a page of all zeros 
Dialogue: 0,0:45:54.82,0:45:57.50,csapp,,0,0,0,,in that case you know that page doesn't need to ever get stored on disk
Dialogue: 0,0:45:57.94,0:46:02.58,csapp,,0,0,0,,right it's just the memory it's as though it was created on disk and then loaded into memory 
Dialogue: 0,0:46:03.28,0:46:07.57,csapp,,0,0,0,,so those pages that are all zeros don't don't exist on disk
Dialogue: 0,0:46:08.50,0:46:10.80,csapp,,0,0,0,,you know when pages are modified
Dialogue: 0,0:46:13.72,0:46:21.70,csapp,,0,0,0,, it's a little more pages can be mapped to particular files for example when we load  an elf binary
Dialogue: 0,0:46:22.64,0:46:27.70,csapp,,0,0,0,, the pages that correspond to the code are actually mapped to the to the bytes in the binary
Dialogue: 0,0:46:28.73,0:46:30.60,csapp,,0,0,0,,that contain the code 
Dialogue: 0,0:46:31.66,0:46:35.36,csapp,,0,0,0,,so that when you miss on that page it fed it brings in those code pages 
Dialogue: 0,0:46:35.86,0:46:41.58,csapp,,0,0,0,,okay so so pages can be mapped to user level files on disk 
Dialogue: 0,0:46:42.64,0:46:45.53,csapp,,0,0,0,,or not they can be anonymous and not mapped
Dialogue: 0,0:46:46.50,0:46:53.70,csapp,,0,0,0,, so if if they're mapped to user level if they're mapped to user level files and you write to a page
Dialogue: 0,0:46:54.02,0:47:00.04,csapp,,0,0,0,, then it will get written back to that to the page that it's mapped to
Dialogue: 0,0:47:00.58,0:47:07.70,csapp,,0,0,0,, if it's not mapped to any page it's stored in this area called the swap area or the swap file okay yes
Dialogue: 0,0:47:07.70,0:47:18.98,csapp,,0,0,0,,[student speaking] rage from this
Dialogue: 0,0:47:18.98,0:47:23.28,csapp,,0,0,0,,oh yeah so the question is when you load a page from disk into memory 
Dialogue: 0,0:47:23.28,0:47:26.92,csapp,,0,0,0,,does it also get cached in the cache memory hierarchy and the answer is yes
Dialogue: 0,0:47:27.66,0:47:29.18,csapp,,0,0,0,,so if you load an entire page 
Dialogue: 0,0:47:29.92,0:47:33.68,csapp,,0,0,0,,that page will be broken up into blocks 64 byte blocks 
Dialogue: 0,0:47:34.28,0:47:37.32,csapp,,0,0,0,, and and and load it into the cache 
Dialogue: 0,0:47:37.94,0:47:41.90,csapp,,0,0,0,, so everything everything everything that you fetch from the cache goes through 
Dialogue: 0,0:47:42.40,0:47:45.64,csapp,,0,0,0,,the from the memory goes through the cache the cache hierarchy
Dialogue: 0,0:47:52.92,0:48:01.02,csapp,,0,0,0,, okay so I claim that virtual memory works 
Dialogue: 0,0:48:01.94,0:48:05.48,csapp,,0,0,0,,because of locality and that's true but if we still had to fetch
Dialogue: 0,0:48:06.46,0:48:08.92,csapp,,0,0,0,, if every time we had a myth we still had to go to memory
Dialogue: 0,0:48:09.22,0:48:10.66,csapp,,0,0,0,, it would be too inefficient
Dialogue: 0,0:48:11.74,0:48:20.20,csapp,,0,0,0,,okay so the the MMU speeds up this translation process by caching page table entries 
Dialogue: 0,0:48:21.18,0:48:27.02,csapp,,0,0,0,,in a in a hardware cache within the MMU called the translation lookaside buffer or TLB 
Dialogue: 0,0:48:28.34,0:48:35.08,csapp,,0,0,0,,so the TLB is a hardware cache that caches is PTEs page table entries 
Dialogue: 0,0:48:37.06,0:48:40.90,csapp,,0,0,0,,and it contains like it contains a cache of the most recently 
Dialogue: 0,0:48:41.58,0:48:47.22,csapp,,0,0,0,,you know it's just like any other cache so it contains a cache of the most recently used page table entries 
Dialogue: 0,0:48:49.20,0:48:57.74,csapp,,0,0,0,,and so the the MMU remember the the unique part of a virtual address that defines a virtual page  is the virtual page number bits 
Dialogue: 0,0:48:58.86,0:49:09.10,csapp,,0,0,0,, okay so the the the TLB uses the the VPN portion of the virtual address  to to to access it 
Dialogue: 0,0:49:09.54,0:49:15.98,csapp,,0,0,0,,and so that just like any other set it has a set index a set of set index bits which are just determined by how many 
Dialogue: 0,0:49:16.28,0:49:19.98,csapp,,0,0,0,,how many entries that or how many sets that the TLB has 
Dialogue: 0,0:49:21.62,0:49:30.26,csapp,,0,0,0,,and it has a tag with for the remaining bits to disambiguate any and to disambiguate any cash lines or PTEs
Dialogue: 0,0:49:30.82,0:49:32.18,csapp,,0,0,0,,the map to the same set
Dialogue: 0,0:49:33.78,0:49:40.64,csapp,,0,0,0,, okay so the the VPN or the TLB I TLB index maps to this particular set 
Dialogue: 0,0:49:42.18,0:49:50.38,csapp,,0,0,0,,and then and then it uses the the TLB uses the TLB LBT bits to
Dialogue: 0,0:49:52.12,0:49:59.20,csapp,,0,0,0,,to disambiguate and determine if the the PT II that it's looking for is it is really stored in the cache 
Dialogue: 0,0:50:00.90,0:50:02.50,csapp,,0,0,0,, okay so the way this works is 
Dialogue: 0,0:50:03.68,0:50:06.74,csapp,,0,0,0,,CPU generates a virtual address it goes through the MMU
Dialogue: 0,0:50:07.06,0:50:12.66,csapp,,0,0,0,, the MMU instead of looking in memory and directly going to the page table entry 
Dialogue: 0,0:50:13.56,0:50:17.24,csapp,,0,0,0,,it first asks the TLB if it has that it sends it the VPN 
Dialogue: 0,0:50:17.44,0:50:21.38,csapp,,0,0,0,,and so do you have this virtual page the Pte for this virtual page 
Dialogue: 0,0:50:22.76,0:50:25.08,csapp,,0,0,0,,and if it does the TLB returns a hit 
Dialogue: 0,0:50:25.32,0:50:30.72,csapp,,0,0,0,, and it returns that page table entry which the MMU can then use to construct the physical address
Dialogue: 0,0:50:31.26,0:50:34.24,csapp,,0,0,0,, to send to the the cache and memory system 
Dialogue: 0,0:50:35.10,0:50:37.66,csapp,,0,0,0,,eventually I result in that the data being sent back
Dialogue: 0,0:50:39.82,0:50:46.00,csapp,,0,0,0,,now when you have a Miss then there's this one the MMU checks with the TLB for the PTE
Dialogue: 0,0:50:46.64,0:50:50.88,csapp,,0,0,0,, it misses so then the MMU has to go to memory just like before okay so this is 
Dialogue: 0,0:50:51.92,0:50:59.66,csapp,,0,0,0,,and then everything is the same the memory returns the PTE to the MMU which stashes it in the TLB 
Dialogue: 0,0:51:00.88,0:51:04.04,csapp,,0,0,0,,and just like before if there's if there's no room in the 
Dialogue: 0,0:51:07.14,0:51:13.98,csapp,,0,0,0,,if yeah if a PTE has been modified then it has to be written back out okay just just like any other cache
Dialogue: 0,0:51:15.78,0:51:20.58,csapp,,0,0,0,,and eventually the MMU uses that to construct a physical address and then the data gets sent back
Dialogue: 0,0:51:24.16,0:51:28.44,csapp,,0,0,0,,okay if you've been paying attention unlike a couple people
Dialogue: 0,0:51:31.76,0:51:33.12,csapp,,0,0,0,, if you've been paying attention 
Dialogue: 0,0:51:34.14,0:51:37.60,csapp,,0,0,0,,you're going to be very concerned about the size of these page tables 
Dialogue: 0,0:51:38.20,0:51:40.68,csapp,,0,0,0,,right that I mean 
Dialogue: 0,0:51:41.90,0:51:46.76,csapp,,0,0,0,,we've got 4Kbytes suppose we have 4k by pages 
Dialogue: 0,0:51:47.58,0:51:52.76,csapp,,0,0,0,,and our effective address space is 48 bits like it is with an x86-64 system 
Dialogue: 0,0:51:54.38,0:51:58.36,csapp,,0,0,0,,then and we have an 8 byte page table entry
Dialogue: 0,0:51:59.70,0:52:03.60,csapp,,0,0,0,,we need a page table 512 gigabytes 
Dialogue: 0,0:52:04.84,0:52:08.54,csapp,,0,0,0,,okay the address space 2^48 bytes
Dialogue: 0,0:52:10.48,0:52:13.94,csapp,,0,0,0,,divided by 2^-12 bytes per page
Dialogue: 0,0:52:14.22,0:52:17.00,csapp,,0,0,0,,okay so that's the number of page table entries that we need 
Dialogue: 0,0:52:17.42,0:52:20.00,csapp,,0,0,0,,and then the size of each page table entry is 8 bytes 
Dialogue: 0,0:52:21.67,0:52:27.66,csapp,,0,0,0,,so we need almost a terabyte of of DRAM just to hold the page table right so 
Dialogue: 0,0:52:28.56,0:52:29.92,csapp,,0,0,0,,so then obviously it's not going to work
Dialogue: 0,0:52:31.32,0:52:34.98,csapp,,0,0,0,,and it's obviously not how their page tables are really implemented 
Dialogue: 0,0:52:35.82,0:52:39.54,csapp,,0,0,0,,so the solution is to to use a hierarchy of page tables 
Dialogue: 0,0:52:41.26,0:52:44.92,csapp,,0,0,0,,so in it so we if we have a two level page table 
Dialogue: 0,0:52:46.12,0:52:50.64,csapp,,0,0,0,,the there's a top of first level page table called the level 1 table 
Dialogue: 0,0:52:51.00,0:52:54.12,csapp,,0,0,0,,which is always in memory ok it's never never page down 
Dialogue: 0,0:52:55.00,0:53:00.54,csapp,,0,0,0,,and then and then there's a suit a sequence of level 2 page tables and they're all the same size 
Dialogue: 0,0:53:03.66,0:53:09.18,csapp,,0,0,0,,right and the the first level 1 table points to the beginning of the first level 2 table 
Dialogue: 0,0:53:09.68,0:53:12.86,csapp,,0,0,0,,so it contains a physical address that points to the base
Dialogue: 0,0:53:14.18,0:53:20.32,csapp,,0,0,0,,the second level 1 table points to the second level 2 table and so on okay
Dialogue: 0,0:53:23.82,0:53:28.76,csapp,,0,0,0,,so if we have this kind of system remember most of the virtual address space is unused 
Dialogue: 0,0:53:30.60,0:53:36.28,csapp,,0,0,0,,right so if we have this kind of system we can we can avoid creating many unnecessary page tables
Dialogue: 0,0:53:38.24,0:53:40.38,csapp,,0,0,0,,okay so imagine if we have a two level hierarchy 
Dialogue: 0,0:53:42.30,0:53:46.92,csapp,,0,0,0,,so let's look at our virtual address space in this example
Dialogue: 0,0:53:47.64,0:53:52.48,csapp,,0,0,0,, and what I've allocated two K pages for code and data for this program
Dialogue: 0,0:53:53.74,0:53:57.32,csapp,,0,0,0,, and then there's their 6k unallocated pages 
Dialogue: 0,0:53:58.66,0:54:02.64,csapp,,0,0,0,,and then the stack then there's a page that's allocated for the stack 
Dialogue: 0,0:54:05.08,0:54:11.00,csapp,,0,0,0,,I'm sorry there's there's a thousand 24 pages allocated for the stack 
Dialogue: 0,0:54:11.56,0:54:18.00,csapp,,0,0,0,,most of which are I'm sorry there's a region of memory that
Dialogue: 0,0:54:18.88,0:54:22.86,csapp,,0,0,0,, that's the size of a thousand 24 pages
Dialogue: 0,0:54:22.86,0:54:28.90,csapp,,0,0,0,, but most of them are unallocated and I've only allocated one for the top of this for the top of the stack
Dialogue: 0,0:54:30.46,0:54:33.62,csapp,,0,0,0,, okay so given this layout for my my process 
Dialogue: 0,0:54:35.48,0:54:38.50,csapp,,0,0,0,,I only only need three level to page tables 
Dialogue: 0,0:54:39.36,0:54:44.92,csapp,,0,0,0,,okay the first the the first page table covers this region of my code and data 
Dialogue: 0,0:54:45.86,0:54:47.94,csapp,,0,0,0,,the first thousand 24 pages 
Dialogue: 0,0:54:48.86,0:54:53.54,csapp,,0,0,0,,the next page table covers the remaining thousand 24 pages 
Dialogue: 0,0:54:54.38,0:54:59.66,csapp,,0,0,0,,okay so these two these two level two page tables cover all of the code and data 
Dialogue: 0,0:55:02.06,0:55:05.98,csapp,,0,0,0,,okay and similarly the what I need for my stack I just need one page table 
Dialogue: 0,0:55:06.76,0:55:11.27,csapp,,0,0,0,,and it only has one one valid PTE it's the very last one
Dialogue: 0,0:55:12.10,0:55:17.12,csapp,,0,0,0,,okay and then I have a single level one table that points to the three level two tables 
Dialogue: 0,0:55:18.18,0:55:22.80,csapp,,0,0,0,,okay so I've with with four page tables I've covered the entire virtual address space 
Dialogue: 0,0:55:24.80,0:55:34.22,csapp,,0,0,0,,now the way that the way that the MMU uses these multiple page tables to do address translation  is as follows
Dialogue: 0,0:55:35.38,0:55:40.42,csapp,,0,0,0,,we again we have a virtual page offset which consists of the first p beds 
Dialogue: 0,0:55:41.98,0:55:47.52,csapp,,0,0,0,, and then the VPN the remaining bits give the VPN 
Dialogue: 0,0:55:48.68,0:55:53.73,csapp,,0,0,0,,for a K level page table are broken up into K sub VPNs
Dialogue: 0,0:55:55.40,0:55:57.88,csapp,,0,0,0,,okay and each each is the same size 
Dialogue: 0,0:56:00.28,0:56:06.72,csapp,,0,0,0,,and so now in this system the upper VPN one which consists of the uppermost bits of the VPN 
Dialogue: 0,0:56:07.82,0:56:11.02,csapp,,0,0,0,,are an offset into the the level 1 table 
Dialogue: 0,0:56:11.58,0:56:15.56,csapp,,0,0,0,,which is as before is pointed to by the page table base register
Dialogue: 0,0:56:16.44,0:56:21.58,csapp,,0,0,0,,okay so VP you want VP 1 is the index into the level 1 page table 
Dialogue: 0,0:56:22.56,0:56:25.92,csapp,,0,0,0,,remember the level 1 page table points to the address of the level 2
Dialogue: 0,0:56:26.66,0:56:29.58,csapp,,0,0,0,, that are an entry a PTE in the level 1 table 
Dialogue: 0,0:56:30.04,0:56:33.62,csapp,,0,0,0,,points to the address of some level 2 page table 
Dialogue: 0,0:56:34.04,0:56:37.40,csapp,,0,0,0,,or it contains the address of some level 2 page table 
Dialogue: 0,0:56:39.26,0:56:42.34,csapp,,0,0,0,,so that points to the base of this level 2 page table 
Dialogue: 0,0:56:42.34,0:56:49.06,csapp,,0,0,0,,and then the VPN 2 bits are used as an index into that level 2 table right and so on 
Dialogue: 0,0:56:50.64,0:56:58.06,csapp,,0,0,0,,ok so eventually you get at the a PTE and the level k-1  table
Dialogue: 0,0:56:58.38,0:57:01.08,csapp,,0,0,0,, points to the beginning of the level K page table 
Dialogue: 0,0:57:01.72,0:57:06.58,csapp,,0,0,0,,and VPN K points to an offset within that table 
Dialogue: 0,0:57:07.32,0:57:12.06,csapp,,0,0,0,,which finally contains the physical address of the page that we want to access 
Dialogue: 0,0:57:13.06,0:57:19.80,csapp,,0,0,0,,okay and then that physical address is used to form the the PPN portion of the physical address 
Dialogue: 0,0:57:20.30,0:57:26.44,csapp,,0,0,0,,and just like before the virtual page offset is just copied directly unchanged to the physical page offset 
Dialogue: 0,0:57:29.36,0:57:30.46,csapp,,0,0,0,,so is that clear to everybody
Dialogue: 0,0:57:31.08,0:57:31.78,csapp,,0,0,0,,yes question
Dialogue: 0,0:57:31.78,0:57:41.66,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:57:41.66,0:57:44.36,csapp,,0,0,0,, let's see is it always a power of two yes 
Dialogue: 0,0:57:44.72,0:57:49.02,csapp,,0,0,0,,at least and it's defined by the the architecture so for Intel it's a four level system
Dialogue: 0,0:57:50.06,0:57:55.64,csapp,,0,0,0,, now why would it be and then the quick could it will it always be less than six
Dialogue: 0,0:58:03.94,0:58:06.42,csapp,,0,0,0,, Oh give us a 64-bit system yeah 
Dialogue: 0,0:58:06.74,0:58:11.58,csapp,,0,0,0,,yeah there's only the the block size is fixed 
Dialogue: 0,0:58:12.40,0:58:16.46,csapp,,0,0,0,,right so that there's 12 bits here 2^12 is 4k
Dialogue: 0,0:58:17.34,0:58:22.08,csapp,,0,0,0,,so the remaining it's that you actually have 48 bits to play with 
Dialogue: 0,0:58:24.74,0:58:32.66,csapp,,0,0,0,,so the remaining 48 bits could that's right so if it was 4 if it was 8  it would be 6 so you're right
Dialogue: 0,0:58:34.06,0:58:38.60,csapp,,0,0,0,,in this scheme it could be at most 6 turns out in practice it's it's set at 4
Dialogue: 0,0:58:40.12,0:58:41.48,csapp,,0,0,0,,and there was a question over here
Dialogue: 0,0:58:41.50,0:58:50.42,csapp,,0,0,0,,the head of the CUA having the one
Dialogue: 0,0:58:50.44,0:58:52.34,csapp,,0,0,0,,have it like this multi-level system oh
Dialogue: 0,0:58:52.88,0:58:54.86,csapp,,0,0,0,,okay so the question 
Dialogue: 0,0:58:59.08,0:59:00.86,csapp,,0,0,0,,is yeah the question is how does it save you space
Dialogue: 0,0:59:01.30,0:59:07.70,csapp,,0,0,0,,so the reason it saves you space is you go back to this other figure maybe I didn't explain this well enough
Dialogue: 0,0:59:16.96,0:59:20.18,csapp,,0,0,0,,so you see this
Dialogue: 0,0:59:25.64,0:59:31.04,csapp,,0,0,0,, if we okay so let's say we wanted to map this virtual address space with a single page table
Dialogue: 0,0:59:32.36,0:59:35.54,csapp,,0,0,0,, we would need a PTE for every page within that address
Dialogue: 0,0:59:36.34,0:59:37.62,csapp,,0,0,0,, whether it was used or not 
Dialogue: 0,0:59:39.76,0:59:47.56,csapp,,0,0,0,,okay it goes back if we had a 48-bit address space
Dialogue: 0,0:59:49.12,0:59:57.08,csapp,,0,0,0,, we'd need enough we need a page table entry  for each each page virtual page in that address space
Dialogue: 0,1:00:00.82,1:00:08.50,csapp,,0,0,0,,okay whether that page was used or not so let me think about it 2^48 is a X several several exabytes 
Dialogue: 0,1:00:10.44,1:00:14.72,csapp,,0,0,0,,we need a page table that would have an entry for each virtual page 
Dialogue: 0,1:00:15.28,1:00:17.20,csapp,,0,0,0,,in that to the 48th bit address space 
Dialogue: 0,1:00:18.48,1:00:22.36,csapp,,0,0,0,,and most of those pages by far the vast majority would never ever be used 
Dialogue: 0,1:00:23.58,1:00:25.16,csapp,,0,0,0,,okay so that's where the waste comes in 
Dialogue: 0,1:00:26.40,1:00:32.22,csapp,,0,0,0,,okay so here with a multi-level page system with this multi-level scheme 
Dialogue: 0,1:00:32.96,1:00:37.92,csapp,,0,0,0,,you only need to generate in this case these level two  if it's a two-level system 
Dialogue: 0,1:00:38.36,1:00:45.76,csapp,,0,0,0,,you only need to generate level two page tables enough level two pages to cover the portion of the virtual address space that you're actually using 
Dialogue: 0,1:00:46.34,1:00:50.96,csapp,,0,0,0,,okay and that portion of the virtual address space that you're not using at this gap right here 
Dialogue: 0,1:00:51.96,1:00:53.92,csapp,,0,0,0,,there's there's no need to have a page table is
Dialogue: 0,1:00:57.65,1:01:04.04,csapp,,0,0,0,,is that clear?that that's a really good important question but you look unconvinced
Dialogue: 0,1:01:04.08,1:01:14.00,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:01:14.02,1:01:17.82,csapp,,0,0,0,,well yeah yeah you still need you still need a page table that has 
Dialogue: 0,1:01:22.70,1:01:27.22,csapp,,0,0,0,,let's see in this case there's four K bite pages for bite PTE
Dialogue: 0,1:01:27.24,1:01:31.86,csapp,,0,0,0,,so there's 1K you have 1K PTEs
Dialogue: 0,1:01:32.44,1:01:39.62,csapp,,0,0,0,,in this so you still need you still need a level 1 page table that has 1k PTEs
Dialogue: 0,1:01:40.18,1:01:42.16,csapp,,0,0,0,,but those are only 8 bytes right I mean
Dialogue: 0,1:01:43.92,1:01:46.28,csapp,,0,0,0,,so you still need to you still need to have space 
Dialogue: 0,1:01:46.38,1:01:51.94,csapp,,0,0,0,,because you don't know you know you're not sure which of these which reason of the address space you're going to need to cover 
Dialogue: 0,1:01:53.02,1:01:54.52,csapp,,0,0,0,,ok and it's the same thing for 
Dialogue: 0,1:01:55.78,1:02:00.00,csapp,,0,0,0,,here in this case in these first two PTEs these first two level 2 page tables
Dialogue: 0,1:02:02.06,1:02:05.40,csapp,,0,0,0,, they're their portion of the address space was actually all being used 
Dialogue: 0,1:02:06.02,1:02:13.44,csapp,,0,0,0,,right so each one of these PTEs at level 2 had to be allocated had to be initialized and used
Dialogue: 0,1:02:14.22,1:02:18.78,csapp,,0,0,0,,right but in this in this portion of the address space that contain the stack
Dialogue: 0,1:02:19.80,1:02:25.48,csapp,,0,0,0,,this third this third level 2 page table has most most of its PTEs or no 
Dialogue: 0,1:02:28.62,1:02:31.08,csapp,,0,0,0,,you still have to allocate space for them but they're there no 
Dialogue: 0,1:02:35.68,1:02:40.24,csapp,,0,0,0,,ok that's a really good question it's important that I hope that's clear
Dialogue: 0,1:02:44.10,1:02:47.74,csapp,,0,0,0,,any other questions will we go on 
Dialogue: 0,1:02:51.38,1:02:52.76,csapp,,0,0,0,,sorry oh okay question 
Dialogue: 0,1:02:52.86,1:03:06.46,csapp,,0,0,0,,page entry level the page table it just looked at part of the address
Dialogue: 0,1:03:06.46,1:03:07.28,csapp,,0,0,0,,exactly just
Dialogue: 0,1:03:08.32,1:03:12.16,csapp,,0,0,0,, just like here the MMU members doing all of this this is all hardware logic 
Dialogue: 0,1:03:13.76,1:03:20.16,csapp,,0,0,0,,so it and and the art the the number of page tables levels is defined by the architecture okay
Dialogue: 0,1:03:21.98,1:03:27.74,csapp,,0,0,0,, so the MMU takes the virtual address that's presented to it 
Dialogue: 0,1:03:29.12,1:03:37.02,csapp,,0,0,0,,and it it uses a portion a subset of those bits to access each each page table okay
Dialogue: 0,1:03:38.88,1:03:43.52,csapp,,0,0,0,, so it's just like did I answer your question okay so it's just like before that 
Dialogue: 0,1:03:44.54,1:03:53.80,csapp,,0,0,0,,the level K VPN K is used to compute an index into the level K page table yes
Dialogue: 0,1:03:53.80,1:04:04.40,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:04:04.40,1:04:08.28,csapp,,0,0,0,,okay the question is why are the indices arranged right to left on which diagram
Dialogue: 0,1:04:08.28,1:04:13.16,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:04:13.18,1:04:16.66,csapp,,0,0,0,,oh these are the bits this is the least significant bit it's always bit zero
Dialogue: 0,1:04:17.84,1:04:20.08,csapp,,0,0,0,,yeah that's a good question so the question was why do these 
Dialogue: 0,1:04:20.94,1:04:25.52,csapp,,0,0,0,,in this diagram why are these these bits labeled right to left starting at zero 
Dialogue: 0,1:04:26.10,1:04:29.82,csapp,,0,0,0,, and the answer is is that we're indicating the bit position 
Dialogue: 0,1:04:30.42,1:04:35.88,csapp,,0,0,0,,so zero is the least significant bit and n-1 is the most significant bit 
Dialogue: 0,1:04:37.98,1:04:47.58,csapp,,0,0,0,,yes question
Dialogue: 0,1:04:47.58,1:04:51.98,csapp,,0,0,0,,yeah so the question is what's the overhead involved in these when you have these multiple levels 
Dialogue: 0,1:04:52.38,1:04:54.94,csapp,,0,0,0,,now are you talking about overhead - 
Dialogue: 0,1:04:54.96,1:05:03.58,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:05:03.58,1:05:09.06,csapp,,0,0,0,,yeah well so there's clearly if you don't get TLB hits 
Dialogue: 0,1:05:10.52,1:05:11.93,csapp,,0,0,0,,it would be a lot of overhead
Dialogue: 0,1:05:12.60,1:05:17.88,csapp,,0,0,0,,because it would be you would be fetching PTEs from multiple page tables for memory 
Dialogue: 0,1:05:19.22,1:05:24.06,csapp,,0,0,0,,so that but because of locality the chances are almost the 
Dialogue: 0,1:05:24.38,1:05:27.52,csapp,,0,0,0,, the chances this level one table covers the entire address space 
Dialogue: 0,1:05:28.08,1:05:31.84,csapp,,0,0,0,, so it's always going to be in the in the PTE in the in the TLB 
Dialogue: 0,1:05:32.64,1:05:38.88,csapp,,0,0,0,,these the level these the these level two tables are covering a huge swath of the address space 
Dialogue: 0,1:05:39.66,1:05:43.70,csapp,,0,0,0,,so chances are they're going to be in the TLB - right so 
Dialogue: 0,1:05:44.42,1:05:49.24,csapp,,0,0,0,,so as long as your program has reasonable locality
Dialogue: 0,1:05:49.70,1:05:55.24,csapp,,0,0,0,, most of the most of these most of these lookups are going to hit in the TLB 
Dialogue: 0,1:05:56.30,1:06:03.16,csapp,,0,0,0,,okay so it turns out that the overhead with reasonably written programs is  is it's it's negligible 
Dialogue: 0,1:06:03.86,1:06:09.72,csapp,,0,0,0,,in but that's a very it's a very important consideration and 
Dialogue: 0,1:06:10.62,1:06:16.10,csapp,,0,0,0,,you know maybe that's maybe that speaks against increasing at some point if you had too many page tables 
Dialogue: 0,1:06:16.94,1:06:20.62,csapp,,0,0,0,,you might you might increase the probability of misses in the TLB 
Dialogue: 0,1:06:20.62,1:06:24.42,csapp,,0,0,0,,so it's probably something they very carefully considered 
Dialogue: 0,1:06:27.78,1:06:29.78,csapp,,0,0,0,,okay any other questions yeah
Dialogue: 0,1:06:29.90,1:06:39.94,csapp,,0,0,0,,yeah so if we use segmentation plus paging so it is the addresses page table the recommended linear address of our real 
Dialogue: 0,1:06:39.96,1:06:45.24,csapp,,0,0,0,, homeboy the question was how does segmentation fit into this and 
Dialogue: 0,1:06:46.56,1:06:50.08,csapp,,0,0,0,,we're not going to go there
Dialogue: 0,1:06:50.48,1:06:53.20,csapp,,0,0,0,, so in in earlier Intel systems 
Dialogue: 0,1:06:56.08,1:07:01.60,csapp,,0,0,0,,such as the actually the first Intel system I programs it was a 286 
Dialogue: 0,1:07:03.00,1:07:06.65,csapp,,0,0,0,,so the 286 no is neat it was the 8086
Dialogue: 0,1:07:07.28,1:07:11.00,csapp,,0,0,0,,anyway earlier in earlier Intel systems had 16-bit addresses 
Dialogue: 0,1:07:11.82,1:07:13.02,csapp,,0,0,0,,which is tiny right
Dialogue: 0,1:07:13.04,1:07:16.38,csapp,,0,0,0,,it's only 2^16 for your address space 
Dialogue: 0,1:07:17.12,1:07:22.41,csapp,,0,0,0,,and so as a hack to try to increase the effective size of the of
Dialogue: 0,1:07:23.10,1:07:26.74,csapp,,0,0,0,,this address space the introduced the notion of segmentation 
Dialogue: 0,1:07:27.90,1:07:31.78,csapp,,0,0,0,,and so there were four segments 4-bit 
Dialogue: 0,1:07:32.64,1:07:38.40,csapp,,0,0,0,,there was a register segment registers that contain four four bits that could be applied to the address 
Dialogue: 0,1:07:39.36,1:07:45.64,csapp,,0,0,0,,so an address was the the combination of the segment knows more than
Dialogue: 0,1:07:49.16,1:07:51.56,csapp,,0,0,0,,yeah you need the segment formed 
Dialogue: 0,1:07:52.46,1:07:56.76,csapp,,0,0,0,,the address then was a combination of the the segment bits plus the address 
Dialogue: 0,1:07:57.48,1:08:00.70,csapp,,0,0,0,,so you could use the segment bits to create an offset 
Dialogue: 0,1:08:01.12,1:08:05.62,csapp,,0,0,0,,so it was a - it wasn't effectively a - 2 xx xx bit address space 
Dialogue: 0,1:08:06.22,1:08:11.56,csapp,,0,0,0,,but you can only address you can only access it in 2^16 chunks right so the
Dialogue: 0,1:08:12.74,1:08:22.50,csapp,,0,0,0,, the segment would would determine an offset into into the sum and offset into the  that this 20-bit address space 
Dialogue: 0,1:08:22.50,1:08:25.98,csapp,,0,0,0,,and then from that you could address 16 bits 
Dialogue: 0,1:08:27.20,1:08:33.16,csapp,,0,0,0,,so it was this very unsatisfying devilishly hard to program  thing because 
Dialogue: 0,1:08:33.82,1:08:36.50,csapp,,0,0,0,,you can only access 16 bit chunks at a time 
Dialogue: 0,1:08:37.94,1:08:46.72,csapp,,0,0,0,,so anyway we're not going to a few years later they came to their senses and just created a real virtual memory system with with linear drill spaces
Dialogue: 0,1:08:50.54,1:08:54.30,csapp,,0,0,0,, but you know really there
Dialogue: 0,1:09:02.20,1:09:03.62,csapp,,0,0,0,,yeah I don't know we're just did 
Dialogue: 0,1:09:06.66,1:09:11.40,csapp,,0,0,0,,I'm not even sure if if they do address translation on those actually 
Dialogue: 0,1:09:11.58,1:09:14.08,csapp,,0,0,0,,so I'm not sure but you really don't want to go there 
Dialogue: 0,1:09:14.88,1:09:17.98,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:09:18.02,1:09:21.71,csapp,,0,0,0,,yeah oh it does it does so the question is it doesn't exist anymore
Dialogue: 0,1:09:22.08,1:09:28.88,csapp,,0,0,0,,everything Intel's been incredibly good about maintaining backward compatibility
Dialogue: 0,1:09:29.74,1:09:31.90,csapp,,0,0,0,,so so that stuff's all in there 
Dialogue: 0,1:09:33.88,1:09:39.14,csapp,,0,0,0,,but there's a mode bit when you when you boot your system up you set a bit that says I want a linear address space 
Dialogue: 0,1:09:43.38,1:09:56.28,csapp,,0,0,0,,okay any other question
Dialogue: 0,1:09:56.46,1:09:58.52,csapp,,0,0,0,,oh no VPN to is the offset 
Dialogue: 0,1:10:01.54,1:10:07.48,csapp,,0,0,0,,okay so the question is why do we care about VPN2 since that it points to the level 2 table
Dialogue: 0,1:10:08.00,1:10:15.68,csapp,,0,0,0,, so what what what gives you the beginning of the level 2 table is the PTE entry in the level 1 table 
Dialogue: 0,1:10:17.28,1:10:22.06,csapp,,0,0,0,,okay so the the level 1 table points to the beginning of that level to pay table 
Dialogue: 0,1:10:22.68,1:10:27.58,csapp,,0,0,0,,and VPN to gives you the offset into that the level 2 table 
Dialogue: 0,1:10:28.58,1:10:32.34,csapp,,0,0,0,,so the it finds the address by taking the the base address
Dialogue: 0,1:10:33.10,1:10:35.64,csapp,,0,0,0,,and then VPN 2 times the PTE sighs
Dialogue: 0,1:10:39.28,1:10:41.80,csapp,,0,0,0,,okay good good any other questions
Dialogue: 0,1:10:49.82,1:10:52.96,csapp,,0,0,0,,okay well that'll do it for today 
Dialogue: 0,1:10:54.02,1:10:57.16,csapp,,0,0,0,,next week or on Thursday we'll look at 
Dialogue: 0,1:10:57.94,1:11:03.78,csapp,,0,0,0,,how how virtual memory is implemented in real systems and and in Linux
