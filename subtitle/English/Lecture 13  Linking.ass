[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Library/Application Support/Aegisub/autosave/../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video File: ../../../Library/Application Support/Aegisub/autosave/../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 835
Active Line: 846
Video Position: 146515

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.34,csapp,,0,0,0,,welcome good to see you
Dialogue: 0,0:00:04.60,0:00:09.52,csapp,,0,0,0,,today we're going to begin a transitioning from
Dialogue: 0,0:00:10.28,0:00:13.04,csapp,,0,0,0,,how our programs interact with hardware to
Dialogue: 0,0:00:13.50,0:00:17.04,csapp,,0,0,0,,to how they interact with software in particular system software
Dialogue: 0,0:00:17.70,0:00:23.38,csapp,,0,0,0,,and we're going to start that investigation by by studying and learning about a process called linking
Dialogue: 0,0:00:25.12,0:00:30.98,csapp,,0,0,0,,which is how the system builds builds your programs ok
Dialogue: 0,0:00:33.26,0:00:35.92,csapp,,0,0,0,, so we're going to study the the process of linking
Dialogue: 0,0:00:35.92,0:00:40.86,csapp,,0,0,0,,and then I'm going to show you a really cool technique called library inter positioning
Dialogue: 0,0:00:42.16,0:00:51.08,csapp,,0,0,0,,which it which allows you to use linking to actually intercept on function calls in in libraries like the standard c library
Dialogue: 0,0:00:51.66,0:00:56.38,csapp,,0,0,0,,so it's a very very powerful and interesting technique and it's all enabled by by linking
Dialogue: 0,0:00:58.28,0:01:01.36,csapp,,0,0,0,,so let's start with a simple program
Dialogue: 0,0:01:02.54,0:01:07.84,csapp,,0,0,0,,this program consists of two modules a main.c and sum.c
Dialogue: 0,0:01:09.06,0:01:14.90,csapp,,0,0,0,,sum.C takes as an array as an argument and a length N
Dialogue: 0,0:01:15.54,0:01:21.60,csapp,,0,0,0,,and then it sums up the elements of that array and returns the sum  back to the caller
Dialogue: 0,0:01:23.48,0:01:26.21,csapp,,0,0,0,,main.c calls the sum function
Dialogue: 0,0:01:26.76,0:01:29.54,csapp,,0,0,0,,using and passes it a two element array of intz
Dialogue: 0,0:01:31.20,0:01:35.78,csapp,,0,0,0,,and then returns that and then returns the value received from some
Dialogue: 0,0:01:37.74,0:01:43.54,csapp,,0,0,0,,yeah we that that's kind of an odd thing to do to return your your exit status like that
Dialogue: 0,0:01:43.54,0:01:47.76,csapp,,0,0,0,,but we just did it so that the compiler wouldn't optimize away all of our code
Dialogue: 0,0:01:49.22,0:01:52.94,csapp,,0,0,0,, I know let's look at what happens if when we want to compile those those two modules
Dialogue: 0,0:01:55.44,0:01:58.74,csapp,,0,0,0,,for each of main.c and sum.c
Dialogue: 0,0:01:59.52,0:02:08.66,csapp,,0,0,0,,the GCC calls a series of translators on that on those modules on those .c files
Dialogue: 0,0:02:09.38,0:02:11.68,csapp,,0,0,0,,first calls the C preprocessor CPP
Dialogue: 0,0:02:14.30,0:02:18.82,csapp,,0,0,0,,then it calls the the compiler the actual compiler which is cc1
Dialogue: 0,0:02:20.90,0:02:26.96,csapp,,0,0,0,,the compiler generates assembly which is then translated by the assembler AS
Dialogue: 0,0:02:27.72,0:02:32.60,csapp,,0,0,0,,and resulting in a .o file called main.o
Dialogue: 0,0:02:33.26,0:02:36.24,csapp,,0,0,0,,similar things happens first for sum.c
Dialogue: 0,0:02:37.34,0:02:43.88,csapp,,0,0,0,,so after after the after these three translators work on the code
Dialogue: 0,0:02:44.36,0:02:47.14,csapp,,0,0,0,,we have two object files two .o files
Dialogue: 0,0:02:48.86,0:02:51.54,csapp,,0,0,0,,the linker takes those those .o files
Dialogue: 0,0:02:52.18,0:02:57.18,csapp,,0,0,0,,and put some links them together
Dialogue: 0,0:02:57.30,0:03:03.02,csapp,,0,0,0,, sort of smashes them together to form a single executable called that
Dialogue: 0,0:03:03.36,0:03:09.24,csapp,,0,0,0,,we can then run then we can then load and run on the system
Dialogue: 0,0:03:11.36,0:03:15.42,csapp,,0,0,0,,so the main.c and sum.c they are called source files
Dialogue: 0,0:03:15.94,0:03:19.90,csapp,,0,0,0,, these .o files are our object files that
Dialogue: 0,0:03:20.60,0:03:22.28,csapp,,0,0,0,, we are separately compiled
Dialogue: 0,0:03:23.18,0:03:27.50,csapp,,0,0,0,,but and we call them relocatable object files because they can be combined together
Dialogue: 0,0:03:28.12,0:03:33.32,csapp,,0,0,0,, to form the fully linked executable object file
Dialogue: 0,0:03:36.06,0:03:42.56,csapp,,0,0,0,,so why do we do it like this you know why why do we allow this so-called separate compilation
Dialogue: 0,0:03:42.62,0:03:48.50,csapp,,0,0,0,,you know why don't we just have like one big you know one big file that with all of our code in it
Dialogue: 0,0:03:49.02,0:03:55.57,csapp,,0,0,0,,well there's a couple reasons the first is is modularity so by by allowing you to break your code into smaller pieces
Dialogue: 0,0:03:55.96,0:03:58.96,csapp,,0,0,0,,you can put related functions into separate source files
Dialogue: 0,0:03:59.30,0:04:01.58,csapp,,0,0,0,,you can define libraries of functions
Dialogue: 0,0:04:02.74,0:04:11.60,csapp,,0,0,0,,so it's just it's just good technique and it allows you to kind of break your code up into nice to nice modular pieces
Dialogue: 0,0:04:13.54,0:04:15.10,csapp,,0,0,0,, the other reason is efficiency
Dialogue: 0,0:04:18.68,0:04:21.92,csapp,,0,0,0,,so if if we if we've broken up our program into multiple chunks
Dialogue: 0,0:04:22.66,0:04:28.54,csapp,,0,0,0,, if we change and if we if we only need to change one of the chunks
Dialogue: 0,0:04:29.26,0:04:33.06,csapp,,0,0,0,,we don't have to recompile the all the other all the other modules
Dialogue: 0,0:04:33.28,0:04:38.50,csapp,,0,0,0,,right we can just recompile the one module that we changed and then link them all together again
Dialogue: 0,0:04:38.58,0:04:44.26,csapp,,0,0,0,,right so it's it's efficient in time it's also efficient in space
Dialogue: 0,0:04:44.26,0:04:51.64,csapp,,0,0,0,,because you can take all of say all of the functions in the standard c library you could put them all together
Dialogue: 0,0:04:52.14,0:04:57.86,csapp,,0,0,0,,but then the only functions that you actually get compiled and linked into your program are the ones that you actually call
Dialogue: 0,0:04:58.68,0:05:01.62,csapp,,0,0,0,,ok so you can you can save space
Dialogue: 0,0:05:01.62,0:05:08.14,csapp,,0,0,0,,you don't you know normally you use only a small subset of the standard C functions and
Dialogue: 0,0:05:08.80,0:05:13.16,csapp,,0,0,0,,so you there's no there's no point in linking all of those functions into your code if you don't need them
Dialogue: 0,0:05:15.08,0:05:16.66,csapp,,0,0,0,,alright so what do linkers do
Dialogue: 0,0:05:18.02,0:05:21.78,csapp,,0,0,0,, well there's two main there's two main tasks that a linker performs
Dialogue: 0,0:05:23.28,0:05:25.82,csapp,,0,0,0,,the first is called simple resolution
Dialogue: 0,0:05:27.16,0:05:30.16,csapp,,0,0,0,,so programs define and reference symbols
Dialogue: 0,0:05:30.44,0:05:37.10,csapp,,0,0,0,,okay that what the linker refers to as symbols and these are global variables and functions
Dialogue: 0,0:05:37.62,0:05:44.40,csapp,,0,0,0,,okay in the names and those those objects they're referred to as a symbol
Dialogue: 0,0:05:44.46,0:05:52.28,csapp,,0,0,0,,so here we're declaring we're defining a symbol called swap
Dialogue: 0,0:05:53.66,0:05:59.42,csapp,,0,0,0,, here we're referring when we call swap we're referring to that symbol
Dialogue: 0,0:05:59.44,0:06:01.30,csapp,,0,0,0,,okay that's a reference to the symbol
Dialogue: 0,0:06:03.30,0:06:07.20,csapp,,0,0,0,,and here we're defining a pointer to an int called XP
Dialogue: 0,0:06:08.30,0:06:13.02,csapp,,0,0,0,,so we're defining XP and we're initializing it to the address of X
Dialogue: 0,0:06:13.02,0:06:15.52,csapp,,0,0,0,,so we're referring that's a reference to X
Dialogue: 0,0:06:18.00,0:06:24.24,csapp,,0,0,0,,okay so the symbol definitions are stored in the object file by the assembler
Dialogue: 0,0:06:25.32,0:06:28.52,csapp,,0,0,0,, in a symbol table which is an array of structs
Dialogue: 0,0:06:29.12,0:06:32.19,csapp,,0,0,0,,where each truck contains information about the symbol
Dialogue: 0,0:06:32.58,0:06:37.54,csapp,,0,0,0,,like the name of the symbol its size and where it's located
Dialogue: 0,0:06:40.54,0:06:46.78,csapp,,0,0,0,,now what we mean by symbol resolution is that during the linker plinking process
Dialogue: 0,0:06:47.58,0:06:54.94,csapp,,0,0,0,,the linker associates each symbol reference with exactly one symbol definition
Dialogue: 0,0:06:57.68,0:06:59.42,csapp,,0,0,0,,okay so it's possible in multiple
Dialogue: 0,0:07:00.64,0:07:04.16,csapp,,0,0,0,,you know why is this an issue well it's possible like in multiple modules
Dialogue: 0,0:07:04.16,0:07:06.84,csapp,,0,0,0,,you may declare a global variable with the same name
Dialogue: 0,0:07:07.80,0:07:13.76,csapp,,0,0,0,, the linker has to decide which one of those definitions  to use for all subsequent references
Dialogue: 0,0:07:16.70,0:07:21.74,csapp,,0,0,0,,now once once the linker is associated a unique object
Dialogue: 0,0:07:21.74,0:07:25.44,csapp,,0,0,0,,with each a unique symbol definition with each reference
Dialogue: 0,0:07:26.84,0:07:29.22,csapp,,0,0,0,,then it does the second step which is relocation
Dialogue: 0,0:07:29.78,0:07:33.32,csapp,,0,0,0,,and during relocation it merges all of the modules together
Dialogue: 0,0:07:33.70,0:07:41.18,csapp,,0,0,0,,into a single into a single executable object  module that can be directly loaded
Dialogue: 0,0:07:41.40,0:07:42.98,csapp,,0,0,0,,and executed on the system
Dialogue: 0,0:07:43.98,0:07:47.34,csapp,,0,0,0,,so when it when it when it does this merging
Dialogue: 0,0:07:50.16,0:07:57.04,csapp,,0,0,0,,it has to it has to figure out where each each symbol each function and each variable is going to be stored
Dialogue: 0,0:07:57.92,0:07:59.16,csapp,,0,0,0,,okay and this is called relocation
Dialogue: 0,0:07:59.16,0:08:06.78,csapp,,0,0,0,,because initially functions are just stored at some offset in their in their object module
Dialogue: 0,0:08:07.36,0:08:13.26,csapp,,0,0,0,,right because that the linker doesn't know where those functions are actually going to be eventually a loaded into memory
Dialogue: 0,0:08:14.04,0:08:26.08,csapp,,0,0,0,,so before before relocation the address of a function in the object module is just its offset  in the in the module  and similarly for data
Dialogue: 0,0:08:26.62,0:08:31.38,csapp,,0,0,0,,during the relocation step the the linker decides on
Dialogue: 0,0:08:31.56,0:08:38.76,csapp,,0,0,0,,where each symbol is going to be ultimately located in memory one at X when the program executes
Dialogue: 0,0:08:39.54,0:08:45.48,csapp,,0,0,0,, and it binds that that those absolute memory locations to the to the symbol
Dialogue: 0,0:08:45.98,0:08:49.74,csapp,,0,0,0,,and then and then it goes and looks at all the references to those symbols
Dialogue: 0,0:08:50.46,0:08:54.74,csapp,,0,0,0,,and it updates those references so that they now they point to the correct address
Dialogue: 0,0:08:55.54,0:08:57.72,csapp,,0,0,0,, okay so figure out where stuff is going to go
Dialogue: 0,0:08:58.88,0:09:03.78,csapp,,0,0,0,, for each definition figure out where it's going to go and for each reference then update that reference
Dialogue: 0,0:09:03.78,0:09:06.14,csapp,,0,0,0,,so it now points to the right spot
Dialogue: 0,0:09:09.90,0:09:14.54,csapp,,0,0,0,,so let's look at what what these how these steps work in more detail
Dialogue: 0,0:09:14.92,0:09:18.22,csapp,,0,0,0,,before that we need to we need to define a few things
Dialogue: 0,0:09:19.80,0:09:23.34,csapp,,0,0,0,,so there's there's three kinds of object modules that I've alluded to
Dialogue: 0,0:09:24.18,0:09:29.72,csapp,,0,0,0,,  there's the dot o file which is a relocatable object module this is the output of the assembler
Dialogue: 0,0:09:30.50,0:09:32.42,csapp,,0,0,0,,okay and it's it's not it's a
Dialogue: 0,0:09:32.42,0:09:35.36,csapp,,0,0,0,,binary file but it's it's not in any
Dialogue: 0,0:09:35.36,0:09:38.87,csapp,,0,0,0,,form that can be directly loaded into
Dialogue: 0,0:09:38.87,0:09:41.63,csapp,,0,0,0,,memory it needs to be manipulated by the
Dialogue: 0,0:09:41.63,0:09:43.78,csapp,,0,0,0,,linker before it can be actually used
Dialogue: 0,0:09:43.78,0:09:46.67,csapp,,0,0,0,,there's the executable object file which
Dialogue: 0,0:09:46.67,0:09:50.42,csapp,,0,0,0,,is generated by the linker these are
Dialogue: 0,0:09:50.42,0:09:52.78,csapp,,0,0,0,,called a dot out files sometimes
Dialogue: 0,0:09:52.78,0:09:54.80,csapp,,0,0,0,,historically the very first Linux
Dialogue: 0,0:09:54.80,0:09:57.68,csapp,,0,0,0,,systems the executable this sort of the
Dialogue: 0,0:09:57.68,0:10:00.11,csapp,,0,0,0,,default name that they the developers of
Dialogue: 0,0:10:00.11,0:10:02.87,csapp,,0,0,0,,UNIX used the default name for their
Dialogue: 0,0:10:02.87,0:10:06.23,csapp,,0,0,0,,executables was a dot out so that's just
Dialogue: 0,0:10:06.23,0:10:08.84,csapp,,0,0,0,,sort of a historical reason that it's
Dialogue: 0,0:10:08.84,0:10:11.12,csapp,,0,0,0,,it's it's called a dot out and then
Dialogue: 0,0:10:11.12,0:10:13.73,csapp,,0,0,0,,there's another type of object file
Dialogue: 0,0:10:13.73,0:10:16.10,csapp,,0,0,0,,called a shared object file or dot iso
Dialogue: 0,0:10:16.10,0:10:21.47,csapp,,0,0,0,,file which is a sort of modern a modern
Dialogue: 0,0:10:21.47,0:10:24.41,csapp,,0,0,0,,technique for creating shared libraries
Dialogue: 0,0:10:24.41,0:10:26.66,csapp,,0,0,0,,and we'll look at those we'll look at
Dialogue: 0,0:10:26.66,0:10:28.33,csapp,,0,0,0,,those later today
Dialogue: 0,0:10:29.14,0:10:34.50,csapp,,0,0,0,,now object modules come in a standard format called elf format 
Dialogue: 0,0:10:35.92,0:10:41.12,csapp,,0,0,0,,and it's it's a unified format for .o files for executables and for .so files 
Dialogue: 0,0:10:41.12,0:10:45.34,csapp,,0,0,0,,they all use the same format the same general format 
Dialogue: 0,0:10:48.26,0:10:52.68,csapp,,0,0,0,,so this while these these elf binaries are
Dialogue: 0,0:10:53.48,0:10:55.58,csapp,,0,0,0,, their binaries they're very structured 
Dialogue: 0,0:10:56.02,0:10:58.14,csapp,,0,0,0,,ok and they're broken up into sections 
Dialogue: 0,0:10:58.94,0:11:02.86,csapp,,0,0,0,,the at the beginning is the is a header 
Dialogue: 0,0:11:03.50,0:11:08.02,csapp,,0,0,0,,that defines things like the size of the word the byte ordering
Dialogue: 0,0:11:08.46,0:11:12.46,csapp,,0,0,0,, whether it's a .o n a .out or a .so 
Dialogue: 0,0:11:12.90,0:11:19.12,csapp,,0,0,0,,so it just provides some sort of general information about this about this binary
Dialogue: 0,0:11:19.76,0:11:22.56,csapp,,0,0,0,, and then there's what's a so called segment header table which 
Dialogue: 0,0:11:23.28,0:11:28.16,csapp,,0,0,0,,is it only it's only defined for the executable object files 
Dialogue: 0,0:11:28.50,0:11:32.40,csapp,,0,0,0,,and it indicates where all the different segments of the code 
Dialogue: 0,0:11:32.82,0:11:38.87,csapp,,0,0,0,,are going to go in in memory so where does your stack go where do your shared libraries go
Dialogue: 0,0:11:38.87,0:11:42.96,csapp,,0,0,0,,where does your that you're initialized and uninitialized data 
Dialogue: 0,0:11:43.74,0:11:51.62,csapp,,0,0,0,,where does your code go right so all these all these various sections are defined in the segment header table 
Dialogue: 0,0:11:52.60,0:11:59.60,csapp,,0,0,0,,and then there's the code itself which is is called the dot text section for sort of arcane historical reasons 
Dialogue: 0,0:11:59.78,0:12:02.16,csapp,,0,0,0,,so dot text is always code 
Dialogue: 0,0:12:03.96,0:12:08.26,csapp,,0,0,0,,and then that's followed by read-only data 
Dialogue: 0,0:12:08.42,0:12:11.14,csapp,,0,0,0,,such as the jump tables in switch statements 
Dialogue: 0,0:12:12.52,0:12:17.82,csapp,,0,0,0,,so text and read only the dot text and dot ro data have the property that they're
Dialogue: 0,0:12:18.08,0:12:20.02,csapp,,0,0,0,, they're both read-only you don't write to them 
Dialogue: 0,0:12:21.90,0:12:24.78,csapp,,0,0,0,,then that's followed by the data section
Dialogue: 0,0:12:24.96,0:12:29.98,csapp,,0,0,0,,which is contains space for all of your initialized global variables 
Dialogue: 0,0:12:31.06,0:12:33.44,csapp,,0,0,0,,and then there's a section called BSS 
Dialogue: 0,0:12:33.56,0:12:41.36,csapp,,0,0,0,, which contain which defines the uninitialized global variables 
Dialogue: 0,0:12:42.78,0:12:46.82,csapp,,0,0,0,,now this doesn't actually take up any space because they're uninitialized droids 
Dialogue: 0,0:12:48.10,0:12:50.76,csapp,,0,0,0,,ok but there there are entries in the symbol table for them 
Dialogue: 0,0:12:51.34,0:12:57.30,csapp,,0,0,0,,and in it at when this program gets loaded these variables are going to need
Dialogue: 0,0:12:58.54,0:13:00.86,csapp,,0,0,0,, they're actually going to have to have space allocated for them
Dialogue: 0,0:13:01.70,0:13:08.26,csapp,,0,0,0,,BSS is another one of those sort of arcane names that cope goes all the way back to the 60s
Dialogue: 0,0:13:08.78,0:13:11.94,csapp,,0,0,0,, for there was an idea of instruction called the block started by symbol
Dialogue: 0,0:13:12.42,0:13:16.22,csapp,,0,0,0,, I think a better way to remember what it means is better safe space 
Dialogue: 0,0:13:16.66,0:13:21.66,csapp,,0,0,0,,ok so you can if you have a separate section for the uninitialized variable since uninitialized 
Dialogue: 0,0:13:22.16,0:13:29.46,csapp,,0,0,0,,you don't have to you know they don't have to consume any room in the in the .o file 
Dialogue: 0,0:13:32.78,0:13:35.54,csapp,,0,0,0,,ok there's also a section for the symbol table 
Dialogue: 0,0:13:37.42,0:13:44.56,csapp,,0,0,0,,this contained like I said it's an array of structs for procedures global variables
Dialogue: 0,0:13:47.72,0:13:50.80,csapp,,0,0,0,,and anything defined with the static attribute 
Dialogue: 0,0:13:53.02,0:13:57.68,csapp,,0,0,0,,and each one of these each one of these symbols gets an entry in the symbol table 
Dialogue: 0,0:13:59.18,0:14:04.56,csapp,,0,0,0,,and then there's two two sections called them that contain relocation info so this is the notes
Dialogue: 0,0:14:06.62,0:14:08.70,csapp,,0,0,0,,when that when the linker went and identified
Dialogue: 0,0:14:09.06,0:14:13.82,csapp,,0,0,0,, all the references to symbols it put a little note to say I'm going to have to remember to fix this 
Dialogue: 0,0:14:14.66,0:14:21.16,csapp,,0,0,0,,the reference to this symbol up when I when I actually create the the executable 
Dialogue: 0,0:14:21.84,0:14:25.26,csapp,,0,0,0,,so a relocation entry is just like a note that the linker or
Dialogue: 0,0:14:25.80,0:14:31.74,csapp,,0,0,0,, that it's a note that the assembler makes to the linker to say hey you're going to have to fix up this this reference 
Dialogue: 0,0:14:31.74,0:14:38.16,csapp,,0,0,0,, because I don't know I don't know where this symbol is actually going to be stored in memory when it's when it's loaded 
Dialogue: 0,0:14:41.56,0:14:43.72,csapp,,0,0,0,, okay and then there's a debug section  that contains 
Dialogue: 0,0:14:45.32,0:14:54.22,csapp,,0,0,0,,information that relates line numbers to in the source code to line numbers in the machine code 
Dialogue: 0,0:14:55.10,0:14:59.40,csapp,,0,0,0,,okay and so this is called debug and this is what you get when you compile with dash G 
Dialogue: 0,0:14:59.98,0:15:06.04,csapp,,0,0,0,,and then there's a header table that that tells you where all these different sections start 
Dialogue: 0,0:15:08.20,0:15:11.34,csapp,,0,0,0,,now to a linker there's there's three different kinds of symbols 
Dialogue: 0,0:15:12.58,0:15:17.00,csapp,,0,0,0,,global symbols are defined in some module m 
Dialogue: 0,0:15:17.50,0:15:20.82,csapp,,0,0,0,,and they can and they can be used by other modules 
Dialogue: 0,0:15:21.08,0:15:27.14,csapp,,0,0,0,,right so I mean did you notice when we if we have a program that consists of multiple modules 
Dialogue: 0,0:15:27.56,0:15:30.66,csapp,,0,0,0,,and we compile each one of those modules into a dot o file
Dialogue: 0,0:15:32.18,0:15:37.42,csapp,,0,0,0,, will be calling functions that aren't defined that are defined by other modules right 
Dialogue: 0,0:15:38.94,0:15:44.64,csapp,,0,0,0,,okay so those but there's no error though that the compiler doesn't doesn't throw an error 
Dialogue: 0,0:15:44.64,0:15:48.44,csapp,,0,0,0,,because it's assuming that those are defined in other modules and
Dialogue: 0,0:15:49.10,0:15:53.32,csapp,,0,0,0,,  it assumes the linker will be able to find them in and determine the address 
Dialogue: 0,0:15:54.40,0:15:59.18,csapp,,0,0,0,,so anything that's defined with that any global either
Dialogue: 0,0:15:59.98,0:16:04.06,csapp,,0,0,0,,either global variable or function name
Dialogue: 0,0:16:04.46,0:16:08.82,csapp,,0,0,0,,that's defined without the static attribute is a is a global symbol 
Dialogue: 0,0:16:10.92,0:16:14.92,csapp,,0,0,0,,okay now and then external symbols are kind of the flip side of that 
Dialogue: 0,0:16:15.08,0:16:19.12,csapp,,0,0,0,,external symbols are symbols that are referenced by some module
Dialogue: 0,0:16:19.44,0:16:21.54,csapp,,0,0,0,, but defined in some other module 
Dialogue: 0,0:16:21.78,0:16:28.54,csapp,,0,0,0,,okay so in our in our in our little running example when when main .c code
Dialogue: 0,0:16:29.00,0:16:32.66,csapp,,0,0,0,,called the function some it was referencing an external symbol 
Dialogue: 0,0:16:34.20,0:16:42.58,csapp,,0,0,0,,okay and then there's there's local symbols and these are symbols that are defined and referenced within a module 
Dialogue: 0,0:16:43.48,0:16:48.12,csapp,,0,0,0,,okay and those you create that this is not this is different from local variables
Dialogue: 0,0:16:48.12,0:16:56.52,csapp,,0,0,0,,okay the linker you know local see variables are managed by the compiler on the stack 
Dialogue: 0,0:16:57.08,0:17:01.38,csapp,,0,0,0,, linker has no idea about local local see variables 
Dialogue: 0,0:17:01.90,0:17:04.32,csapp,,0,0,0,,okay in this context when we talk about a local symbol 
Dialogue: 0,0:17:04.92,0:17:10.32,csapp,,0,0,0,,what we're talking about is is either is a global a global variable 
Dialogue: 0,0:17:10.50,0:17:13.58,csapp,,0,0,0,,or function declared with the static attribute 
Dialogue: 0,0:17:14.94,0:17:17.26,csapp,,0,0,0,,whose that can only be referenced from within that module 
Dialogue: 0,0:17:17.26,0:17:24.02,csapp,,0,0,0,,so we say that the scope the scope of the a function or global variable defined with the static
Dialogue: 0,0:17:24.52,0:17:27.86,csapp,,0,0,0,,attribute is limited to the module that it was defined in
Dialogue: 0,0:17:30.06,0:17:33.78,csapp,,0,0,0,, okay so this is in C this is how we do abstraction 
Dialogue: 0,0:17:34.90,0:17:38.24,csapp,,0,0,0,,and this is how we can create sort of private functions that 
Dialogue: 0,0:17:39.36,0:17:44.38,csapp,,0,0,0,,and pup private functions that can't be called from from outside that module 
Dialogue: 0,0:17:45.82,0:17:49.44,csapp,,0,0,0,,okay so for instance if we want to make a library and see 
Dialogue: 0,0:17:50.10,0:17:53.16,csapp,,0,0,0,,of functions we want to make a collection of functions that 
Dialogue: 0,0:17:53.61,0:17:57.94,csapp,,0,0,0,,other programs can then call it link into their program and call 
Dialogue: 0,0:17:58.86,0:18:07.52,csapp,,0,0,0,,the functions that we want to make visible to to other programs are defined without the static attribute 
Dialogue: 0,0:18:08.38,0:18:12.10,csapp,,0,0,0,,and the functions that we want to have private and just be internal 
Dialogue: 0,0:18:12.76,0:18:15.36,csapp,,0,0,0,,we declare what the static attribute okay
Dialogue: 0,0:18:16.00,0:18:20.50,csapp,,0,0,0,,and that way we get abstraction and we get hiding information hiding 
Dialogue: 0,0:18:20.98,0:18:26.86,csapp,,0,0,0,,and we're only exposing data and functions that that we want that we want to expose 
Dialogue: 0,0:18:29.60,0:18:33.36,csapp,,0,0,0,,all right so let's look in detail how the symbol resolution step works 
Dialogue: 0,0:18:34.02,0:18:38.36,csapp,,0,0,0,,we recall our example our example program 
Dialogue: 0,0:18:41.26,0:18:44.40,csapp,,0,0,0,,so here we're referencing a global called array
Dialogue: 0,0:18:45.94,0:18:50.26,csapp,,0,0,0,,that's defined within main.c 
Dialogue: 0,0:18:54.20,0:18:56.60,csapp,,0,0,0,,here when we here we're defining main 
Dialogue: 0,0:18:57.78,0:18:59.36,csapp,,0,0,0,,a global called main 
Dialogue: 0,0:19:04.28,0:19:06.46,csapp,,0,0,0,,here we're referencing a global called sum 
Dialogue: 0,0:19:06.78,0:19:08.90,csapp,,0,0,0,,that's defined in sum.c 
Dialogue: 0,0:19:11.10,0:19:17.34,csapp,,0,0,0,,and val is a local c variable on the stack and linker knows nothing about that okay 
Dialogue: 0,0:19:20.00,0:19:23.58,csapp,,0,0,0,,now an or doesn't know anything about IRS which are also local variables
Dialogue: 0,0:19:25.76,0:19:30.56,csapp,,0,0,0,,now let's just let's make sure that we understand the difference 
Dialogue: 0,0:19:30.58,0:19:36.88,csapp,,0,0,0,,between local static c variables versus local non static c variables so
Dialogue: 0,0:19:39.74,0:19:44.12,csapp,,0,0,0,, here we're defining a local static variable called int 
Dialogue: 0,0:19:45.16,0:19:46.84,csapp,,0,0,0,,within this function f 
Dialogue: 0,0:19:48.46,0:19:53.40,csapp,,0,0,0,,now because it's local its scope is limited to this function 
Dialogue: 0,0:19:53.40,0:19:58.88,csapp,,0,0,0,,so this variable X can only be referenced within function f 
Dialogue: 0,0:20:01.06,0:20:07.10,csapp,,0,0,0,, and similarly for this definition of X and function G 
Dialogue: 0,0:20:07.98,0:20:11.08,csapp,,0,0,0,,can only be referenced by by function G 
Dialogue: 0,0:20:11.58,0:20:17.08,csapp,,0,0,0,,now what's but because it's declared with the static attribute it's not stored on the stack 
Dialogue: 0,0:20:17.78,0:20:22.18,csapp,,0,0,0,,it's actually stored in in the in dot data just like a global would be
Dialogue: 0,0:20:22.36,0:20:29.20,csapp,,0,0,0,,so it's it's like a global in the sense that it's actually stored in dot data rather than the stack 
Dialogue: 0,0:20:29.86,0:20:35.48,csapp,,0,0,0,,but it's like a local see variable in the sense that its scope is limited just to the function that it's defined in 
Dialogue: 0,0:20:36.48,0:20:43.48,csapp,,0,0,0,,okay so what what the compiler will do it'll allocate space for each definition of X 
Dialogue: 0,0:20:43.50,0:20:49.58,csapp,,0,0,0,,so this and it'll give it some name to disambiguate it so maybe it will call this one X dot one 
Dialogue: 0,0:20:49.98,0:20:51.82,csapp,,0,0,0,,and maybe this one X dot two 
Dialogue: 0,0:20:52.80,0:20:57.54,csapp,,0,0,0,,so these symbols are allocated in dot data because
Dialogue: 0,0:20:57.94,0:21:04.18,csapp,,0,0,0,, because they're initialized and they get symbol table entries just like just like any other symbol
Dialogue: 0,0:21:08.00,0:21:11.16,csapp,,0,0,0,,okay so I said that during symbol resolution 
Dialogue: 0,0:21:11.56,0:21:20.32,csapp,,0,0,0,,the linker associates each reference each symbol reference to exactly one unique symbol definition 
Dialogue: 0,0:21:21.58,0:21:25.72,csapp,,0,0,0,,now how does it do that if there's multiple symbol definitions across all the modules
Dialogue: 0,0:21:27.64,0:21:35.32,csapp,,0,0,0,, so to understand this well will will will define symbols as being either strong or weak 
Dialogue: 0,0:21:35.78,0:21:43.86,csapp,,0,0,0,,so strong symbols are either procedures or function function names or initialize global variables 
Dialogue: 0,0:21:44.66,0:21:47.22,csapp,,0,0,0,,weak symbols or uninitialized global variables 
Dialogue: 0,0:21:49.18,0:21:54.62,csapp,,0,0,0,,okay so int foo here is a strong symbol 
Dialogue: 0,0:21:54.62,0:21:59.70,csapp,,0,0,0,,because it's initialized we're initializing it p1 is strong by definition
Dialogue: 0,0:22:00.74,0:22:08.44,csapp,,0,0,0,, foo is is weak in p2.c this this definition of foo is weak 
Dialogue: 0,0:22:09.06,0:22:12.78,csapp,,0,0,0,,because it's uninitialized and the definition of p2 is strong 
Dialogue: 0,0:22:13.64,0:22:17.74,csapp,,0,0,0,,okay so that the rules that the the linker uses are the following
Dialogue: 0,0:22:19.34,0:22:22.34,csapp,,0,0,0,,multiple strong symbols not allowed so that's an error 
Dialogue: 0,0:22:24.14,0:22:30.34,csapp,,0,0,0,,okay so that means that if we if across multiple modules we declare a function with the same name
Dialogue: 0,0:22:30.54,0:22:32.72,csapp,,0,0,0,,the linker will throw an error that's not allowed
Dialogue: 0,0:22:34.44,0:22:42.72,csapp,,0,0,0,, given a strong symbol and multiple weak symbols if the linker will always choose the the strong symbol 
Dialogue: 0,0:22:44.00,0:22:47.28,csapp,,0,0,0,,now remember if we initialize a global variable 
Dialogue: 0,0:22:50.94,0:22:56.18,csapp,,0,0,0,,and we if we declare a an initialized global variable across multiple modules that's an error 
Dialogue: 0,0:22:56.18,0:22:58.70,csapp,,0,0,0,,because those are strong symbols okay by rule one
Dialogue: 0,0:22:59.02,0:23:03.90,csapp,,0,0,0,,but if we have one strong symbol and multiple weak symbols all with the same name 
Dialogue: 0,0:23:04.52,0:23:06.92,csapp,,0,0,0,,then the compiler will choose the strong symbol 
Dialogue: 0,0:23:08.48,0:23:12.88,csapp,,0,0,0,,okay and it will associate all references to that symbol will go to that strong symbol 
Dialogue: 0,0:23:14.38,0:23:17.70,csapp,,0,0,0,,and if there's multiple weak symbols then it just picks an arbitrary one 
Dialogue: 0,0:23:18.02,0:23:25.07,csapp,,0,0,0,,and this this is we'll see can be problematic now you can override with this GCC flag called no common 
Dialogue: 0,0:23:25.74,0:23:29.94,csapp,,0,0,0,,and if you if you declare your function with this no common argument 
Dialogue: 0,0:23:30.32,0:23:35.40,csapp,,0,0,0,,then multiple weak symbols will throw an error in a linker 
Dialogue: 0,0:23:36.46,0:23:39.24,csapp,,0,0,0,,all right so why do we care about all this stuff well it turns out
Dialogue: 0,0:23:39.80,0:23:44.10,csapp,,0,0,0,, if you're not aware of this stuff you can you can run into some really serious problems
Dialogue: 0,0:23:44.12,0:23:47.40,csapp,,0,0,0,, that are just perplexing and confounding right so 
Dialogue: 0,0:23:47.90,0:23:50.68,csapp,,0,0,0,,linker linker errors are like the worst kind 
Dialogue: 0,0:23:51.10,0:23:55.78,csapp,,0,0,0,,they're the hardest kind of debug because people aren't usually aware of what's going on inside their linkers 
Dialogue: 0,0:23:57.64,0:24:02.26,csapp,,0,0,0,,and usually it's only like the very best programmers that really understand 
Dialogue: 0,0:24:03.36,0:24:07.78,csapp,,0,0,0,,you know how these linkers work and what kind of errors they can throw and how to debug them 
Dialogue: 0,0:24:08.36,0:24:13.80,csapp,,0,0,0,,so let me show you some examples of of these these kind of errors 
Dialogue: 0,0:24:15.58,0:24:19.34,csapp,,0,0,0,,all right so we have a program we've word we have two modules 
Dialogue: 0,0:24:19.34,0:24:22.96,csapp,,0,0,0,,so each of these rectangles corresponds to a module 
Dialogue: 0,0:24:23.84,0:24:26.58,csapp,,0,0,0,,and we're defining p1 in each module so
Dialogue: 0,0:24:28.54,0:24:31.28,csapp,,0,0,0,, that's too strong symbols that's an error 
Dialogue: 0,0:24:34.38,0:24:39.62,csapp,,0,0,0,,okay now here we've we're defining p1 and p2
Dialogue: 0,0:24:39.64,0:24:47.08,csapp,,0,0,0,,so we're okay but now we've got two week symbols both are integers variables called X 
Dialogue: 0,0:24:48.92,0:24:53.62,csapp,,0,0,0,,so and if these modules are referencing X the linker will just pick
Dialogue: 0,0:24:54.36,0:24:58.12,csapp,,0,0,0,,it will just pick one of these to serve as the definition 
Dialogue: 0,0:24:59.72,0:25:02.40,csapp,,0,0,0,,but is is this really what you want 
Dialogue: 0,0:25:03.60,0:25:09.38,csapp,,0,0,0,,now in this case it doesn't really hurt anything because X is declared in both modules as an int
Dialogue: 0,0:25:10.12,0:25:15.06,csapp,,0,0,0,,all right so it'll just be it'll just be some integer sized variable
Dialogue: 0,0:25:15.72,0:25:19.22,csapp,,0,0,0,, that and it'll be it'll be somewhere 
Dialogue: 0,0:25:20.04,0:25:24.14,csapp,,0,0,0,,and but it doesn't really matter which which one the linker chooses 
Dialogue: 0,0:25:25.52,0:25:31.14,csapp,,0,0,0,,but we start to get into trouble if if we declare these weak symbols  with different types 
Dialogue: 0,0:25:34.02,0:25:40.26,csapp,,0,0,0,,so here we've declared an int X in one module and a double X in another module 
Dialogue: 0,0:25:42.32,0:25:50.28,csapp,,0,0,0,,so if we write to X if the linker just arbitrarily chooses this  this symbol definition to use 
Dialogue: 0,0:25:51.54,0:25:57.48,csapp,,0,0,0,,now this is a symbol that of length 8 of size 8 
Dialogue: 0,0:26:00.36,0:26:05.72,csapp,,0,0,0,,if we anywhere in this program if we if the linker chooses that then anywhere in the program
Dialogue: 0,0:26:06.30,0:26:14.70,csapp,,0,0,0,, those references to those references to X will be to this double word  this double word 
Dialogue: 0,0:26:16.38,0:26:21.08,csapp,,0,0,0,,even even in this module if we reference X it'll be an 8-byte right 
Dialogue: 0,0:26:21.10,0:26:25.06,csapp,,0,0,0,,so it will overwrite Y with the
Dialogue: 0,0:26:29.16,0:26:38.80,csapp,,0,0,0,,hi order excuse me 
Dialogue: 0,0:26:38.84,0:26:43.20,csapp,,0,0,0,,oh no it's completely it's just committal just pick one
Dialogue: 0,0:26:43.72,0:26:48.48,csapp,,0,0,0,,arbitrarily and you don't know I mean it
Dialogue: 0,0:26:53.44,0:26:59.30,csapp,,0,0,0,,alright here's now this is here's a problem we've defined a strong symbol X
Dialogue: 0,0:26:59.82,0:27:02.98,csapp,,0,0,0,,because we've initializes so the linker will always 
Dialogue: 0,0:27:04.84,0:27:13.58,csapp,,0,0,0,,will associate all references to X to this integer sized this integer sized symbol
Dialogue: 0,0:27:16.70,0:27:30.32,csapp,,0,0,0,, so if we write
Dialogue: 0,0:27:30.52,0:27:34.14,csapp,,0,0,0,,oh yeah right so so rights to X here
Dialogue: 0,0:27:36.14,0:27:40.68,csapp,,0,0,0,,this will be a double in this module but it will overwrite Y in this module 
Dialogue: 0,0:27:40.94,0:27:48.36,csapp,,0,0,0,,so that's really nasty
Dialogue: 0,0:27:48.76,0:27:51.60,csapp,,0,0,0,,and here we were defining a strong symbol X 
Dialogue: 0,0:27:52.40,0:28:00.90,csapp,,0,0,0,,so references to X in the second module will always get it will refer to this initialized variable which might not 
Dialogue: 0,0:28:01.68,0:28:04.42,csapp,,0,0,0,,so it might not be what you want right 
Dialogue: 0,0:28:06.12,0:28:10.14,csapp,,0,0,0,,you may you may be assuming that it's uninitialized in your code
Dialogue: 0,0:28:12.22,0:28:16.46,csapp,,0,0,0,,okay and then you get the the ultimate nightmare scenario is suppose 
Dialogue: 0,0:28:17.06,0:28:21.62,csapp,,0,0,0,,you know because we're following a standard ABI we can compile our code with multiple compilers 
Dialogue: 0,0:28:22.20,0:28:24.80,csapp,,0,0,0,,and this actually happens in some oh yes questions
Dialogue: 0,0:28:25.06,0:28:34.74,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:28:34.76,0:28:36.54,csapp,,0,0,0,, oh yeah actually you're right
Dialogue: 0,0:28:37.40,0:28:41.58,csapp,,0,0,0,, it will it will still take preference and and you'll be writing a for by quantity 
Dialogue: 0,0:28:41.58,0:28:45.02,csapp,,0,0,0,,which is is what you want so that slides not quite right  
Dialogue: 0,0:28:45.50,0:28:55.50,csapp,,0,0,0,,so oh yeah what is the point of doing the static versus non static 
Dialogue: 0,0:28:55.50,0:29:02.26,csapp,,0,0,0,,if it's always being referenced just locally in constantly what is the point of declaring  it's time
Dialogue: 0,0:29:02.60,0:29:05.56,csapp,,0,0,0,,-is it it stores it in like \n-no no no it's
Dialogue: 0,0:29:06.86,0:29:11.42,csapp,,0,0,0,,if you reference up if you reference a a variable 
Dialogue: 0,0:29:12.84,0:29:15.46,csapp,,0,0,0,,that's you mean so a variable is defined in your module 
Dialogue: 0,0:29:16.04,0:29:22.70,csapp,,0,0,0,,and then you...with the static...right 
Dialogue: 0,0:29:24.06,0:29:26.54,csapp,,0,0,0,,oh they're both they're both local 
Dialogue: 0,0:29:26.98,0:29:31.30,csapp,,0,0,0,,so you do this if you want to value two to retain 
Dialogue: 0,0:29:31.96,0:29:36.86,csapp,,0,0,0,,from if you want if you want that variable to retain value from invocation to invocation 
Dialogue: 0,0:29:38.32,0:29:42.62,csapp,,0,0,0,,so suppose you it's usually a bad idea as we'll see when we study threads 
Dialogue: 0,0:29:42.62,0:29:44.90,csapp,,0,0,0,,because it makes your code non thread safe 
Dialogue: 0,0:29:45.62,0:29:49.40,csapp,,0,0,0,,but like early like random number generators
Dialogue: 0,0:29:50.18,0:29:53.28,csapp,,0,0,0,,would it would compute a pseudo-random number 
Dialogue: 0,0:29:53.78,0:29:55.84,csapp,,0,0,0,,and then it would store it in a static variable 
Dialogue: 0,0:29:56.28,0:30:01.30,csapp,,0,0,0,,and then use that as the the starting value for the next the next time you call that function  
Dialogue: 0,0:30:01.74,0:30:06.70,csapp,,0,0,0,,so whenever you want values to to persist across function invocation to reduce static 
Dialogue: 0,0:30:07.26,0:30:25.04,csapp,,0,0,0,,yes something really crash
Dialogue: 0,0:30:25.04,0:30:26.20,csapp,,0,0,0,,well wait a minute let me 
Dialogue: 0,0:30:27.50,0:30:34.04,csapp,,0,0,0,,let me get this straight rights to X and P 2 will actually correspond to the memory 
Dialogue: 0,0:30:34.30,0:30:40.78,csapp,,0,0,0,,look that it will actually go to the memory location I'm sorry I I need to amend that
Dialogue: 0,0:30:41.74,0:30:47.60,csapp,,0,0,0,,so rights to X in P 2 will be 8 bytes
Dialogue: 0,0:30:47.64,0:30:51.32,csapp,,0,0,0,,because the compiler you know the compiler knows that it's a double 
Dialogue: 0,0:30:52.70,0:30:59.84,csapp,,0,0,0,,but it'll go to a memory location that's I that's only 4 bytes 
Dialogue: 0,0:31:00.54,0:31:03.32,csapp,,0,0,0,,because X because the linker chose the strong symbol 
Dialogue: 0,0:31:04.46,0:31:08.34,csapp,,0,0,0,,okay so so the rights to X and P 2 will actually overwrite Y 
Dialogue: 0,0:31:12.88,0:31:23.12,csapp,,0,0,0,,ok I'm sorry yes question
Dialogue: 0,0:31:23.18,0:31:25.08,csapp,,0,0,0,,that's just usually the way it happens
Dialogue: 0,0:31:25.70,0:31:33.42,csapp,,0,0,0,,you know 
Dialogue: 0,0:31:33.46,0:31:38.46,csapp,,0,0,0,,no no no global variables go in in data they don't go on the stack 
Dialogue: 0,0:31:39.36,0:31:41.80,csapp,,0,0,0,,but usually if you define local variables in a function 
Dialogue: 0,0:31:42.26,0:31:46.38,csapp,,0,0,0,, it will put them it will allocate them one after the other on them on the stack 
Dialogue: 0,0:31:49.68,0:31:55.66,csapp,,0,0,0,,okay all right so all this discussion about 
Dialogue: 0,0:31:57.52,0:32:01.38,csapp,,0,0,0,,these these weird strong weak symbol rules that the linker have
Dialogue: 0,0:32:01.38,0:32:04.92,csapp,,0,0,0,, it's another reason to avoid global variables if you can 
Dialogue: 0,0:32:07.32,0:32:12.40,csapp,,0,0,0,,now if if you if you need to declare a global  see if you can declare it static 
Dialogue: 0,0:32:12.40,0:32:16.08,csapp,,0,0,0,,because that'll limited scope to the the module that it's declared in 
Dialogue: 0,0:32:16.34,0:32:18.10,csapp,,0,0,0,,so that's a good idea if you can do it 
Dialogue: 0,0:32:18.88,0:32:21.24,csapp,,0,0,0,,and if you define a global variable initialize it 
Dialogue: 0,0:32:22.90,0:32:28.22,csapp,,0,0,0,,so that you'll you'll you'll find you'll discover if you have multiple 
Dialogue: 0,0:32:28.48,0:32:31.26,csapp,,0,0,0,,initialize global symbols with the same name in your code 
Dialogue: 0,0:32:32.46,0:32:35.90,csapp,,0,0,0,,and then if you want to it's always good practice
Dialogue: 0,0:32:35.90,0:32:41.70,csapp,,0,0,0,, if you're referencing an external variable to tell the compiler about it by using the X turn attribute 
Dialogue: 0,0:32:44.94,0:32:46.29,csapp,,0,0,0,,all right
Dialogue: 0,0:32:46.74,0:32:53.48,csapp,,0,0,0,,so now at this point the linker has associated every symbol reference  with some simple definition 
Dialogue: 0,0:32:54.70,0:32:59.56,csapp,,0,0,0,,now it has to take all those object relocatable object files and smush them together 
Dialogue: 0,0:32:59.80,0:33:03.84,csapp,,0,0,0,,and create like one one big executable 
Dialogue: 0,0:33:04.92,0:33:08.54,csapp,,0,0,0,,so suppose with our example a little running example 
Dialogue: 0,0:33:09.72,0:33:18.32,csapp,,0,0,0,,each main.o and sum.o contain a code and initialize data 
Dialogue: 0,0:33:19.08,0:33:22.96,csapp,,0,0,0,,sum.o doesn't have any initialize data it just has code 
Dialogue: 0,0:33:23.62,0:33:28.34,csapp,,0,0,0,,and then there's their system code that actually runs before and after your program so 
Dialogue: 0,0:33:29.88,0:33:35.46,csapp,,0,0,0,,when when your program run it actually starts executing a startup code from  from lib see 
Dialogue: 0,0:33:36.12,0:33:44.46,csapp,,0,0,0,,that that sort of initializes things and then the last thing that it does is it calls main  and passes it arcs RC and RV 
Dialogue: 0,0:33:46.18,0:33:48.38,csapp,,0,0,0,,okay and then when you're when your program exits
Dialogue: 0,0:33:49.78,0:33:55.00,csapp,,0,0,0,, well that's a cyst call but if your program if your main function routine does a return 
Dialogue: 0,0:33:55.46,0:33:59.54,csapp,,0,0,0,,then it returns back to that startup code which then doesn't exit okay 
Dialogue: 0,0:34:00.52,0:34:07.62,csapp,,0,0,0,,so so this is just and so this this consists of of text and data as well 
Dialogue: 0,0:34:09.10,0:34:13.16,csapp,,0,0,0,,and so when we when the linker relocates these these object files 
Dialogue: 0,0:34:15.28,0:34:20.84,csapp,,0,0,0,,it takes all of the the code the text sections from each of the modules
Dialogue: 0,0:34:21.80,0:34:29.96,csapp,,0,0,0,,and puts them together contiguously init in the dot text section for the executable object file 
Dialogue: 0,0:34:30.30,0:34:34.42,csapp,,0,0,0,,ok so it just puts them together in some order that it determines 
Dialogue: 0,0:34:34.76,0:34:40.40,csapp,,0,0,0,,and it creates a combined dot text section in the executable 
Dialogue: 0,0:34:40.82,0:34:46.18,csapp,,0,0,0,,that contains all of the system code and the all of the all of the code defined in the modules
Dialogue: 0,0:34:46.84,0:34:51.24,csapp,,0,0,0,, and then it does the same thing with the data takes all the all the dot data 
Dialogue: 0,0:34:51.96,0:34:55.92,csapp,,0,0,0,,sections from the various object files and puts them together
Dialogue: 0,0:34:56.42,0:35:00.62,csapp,,0,0,0,, in in one combined data section in the executable 
Dialogue: 0,0:35:02.52,0:35:07.32,csapp,,0,0,0,,and it also emerges the symbol tables and in the debug information as well 
Dialogue: 0,0:35:09.14,0:35:15.12,csapp,,0,0,0,,now when it just the act the act of sort of 
Dialogue: 0,0:35:15.64,0:35:19.98,csapp,,0,0,0,,relocating these these object files requires the linker
Dialogue: 0,0:35:20.56,0:35:23.54,csapp,,0,0,0,,to figure out where it's going to actually store these 
Dialogue: 0,0:35:24.42,0:35:31.24,csapp,,0,0,0,,these these different these different symbols when the system gets when this program gets loaded 
Dialogue: 0,0:35:31.26,0:35:36.00,csapp,,0,0,0,,so it it has to pick an address for main that 
Dialogue: 0,0:35:37.30,0:35:41.14,csapp,,0,0,0,,that function will start at some absolute address
Dialogue: 0,0:35:41.22,0:35:46.42,csapp,,0,0,0,, it's going to have it's going to do the same for swap so for all the all the data arrays right
Dialogue: 0,0:35:51.16,0:35:54.94,csapp,,0,0,0,,and but the problem is is that when this code is
Dialogue: 0,0:35:55.16,0:36:00.16,csapp,,0,0,0,, is is compiled the compiler doesn't know what addresses the linker is going to pick 
Dialogue: 0,0:36:02.40,0:36:09.10,csapp,,0,0,0,,so the so the compiler creates these these reminders to the linker called relocation entries 
Dialogue: 0,0:36:09.10,0:36:13.84,csapp,,0,0,0,,which which are then stored in the relocation sections of the the object file 
Dialogue: 0,0:36:14.94,0:36:20.22,csapp,,0,0,0,,and these these relocation entries are instructions to the linker that's something
Dialogue: 0,0:36:21.62,0:36:24.88,csapp,,0,0,0,, that there's a reference to a symbol that's going to have to be patched up 
Dialogue: 0,0:36:25.48,0:36:30.98,csapp,,0,0,0,,when the the code is actually relocated and merged into the executable
Dialogue: 0,0:36:32.42,0:36:36.24,csapp,,0,0,0,,so let's look at a couple of these a couple of examples so in 
Dialogue: 0,0:36:37.04,0:36:44.38,csapp,,0,0,0,,our in our main.c module there was a reference to this  to this global symbol called array
Dialogue: 0,0:36:46.58,0:36:52.06,csapp,,0,0,0,,okay and then there was also a reference to this this this global symbol sum which is the function 
Dialogue: 0,0:36:53.54,0:36:57.32,csapp,,0,0,0,,so the the compiler creates two relocation entries
Dialogue: 0,0:36:57.90,0:37:00.84,csapp,,0,0,0,,the first one for the reference to the array a 
Dialogue: 0,0:37:01.58,0:37:06.30,csapp,,0,0,0,,so here we're moving remember EDI is the first argument 
Dialogue: 0,0:37:07.00,0:37:12.18,csapp,,0,0,0,,so remember our sum function takes the address of the of array 
Dialogue: 0,0:37:12.68,0:37:15.50,csapp,,0,0,0,,of the input array as its it's argument 
Dialogue: 0,0:37:16.92,0:37:27.00,csapp,,0,0,0,,so this move we're moving the address of the array into EDI for the first argument
Dialogue: 0,0:37:27.92,0:37:30.36,csapp,,0,0,0,, but the compiler doesn't know what that address is going to be 
Dialogue: 0,0:37:31.24,0:37:34.56,csapp,,0,0,0,,right so it just it just it just
Dialogue: 0,0:37:35.84,0:37:42.58,csapp,,0,0,0,,it just moves in it an immediate value of 0 into EDI temporarily right so you can see this is all zeros 
Dialogue: 0,0:37:43.96,0:37:50.02,csapp,,0,0,0,,the bf is the move instruction and then there's allsey rows in for now 
Dialogue: 0,0:37:51.82,0:37:57.92,csapp,,0,0,0,,and then it places this relocation entry in the in the relocation section of Maemo 
Dialogue: 0,0:37:58.64,0:38:03.44,csapp,,0,0,0,,and it it says it says to the linker at addre at offset a 
Dialogue: 0,0:38:04.96,0:38:09.58,csapp,,0,0,0,,so these let me remind you these are our main.o
Dialogue: 0,0:38:10.52,0:38:13.90,csapp,,0,0,0,, module only contains one one function 
Dialogue: 0,0:38:14.92,0:38:19.78,csapp,,0,0,0,,so that function starts that offsets zero in the in the code section 
Dialogue: 0,0:38:19.92,0:38:22.96,csapp,,0,0,0,,of the module in the dot text section of the module
Dialogue: 0,0:38:23.90,0:38:28.84,csapp,,0,0,0,, if there were other functions in this module they would they would follow immediately after 
Dialogue: 0,0:38:29.48,0:38:36.98,csapp,,0,0,0,,ok and it so you can see what what the compiler is it's just all it's just generating offsets of these instructions
Dialogue: 0,0:38:37.62,0:38:39.92,csapp,,0,0,0,,from the beginning of the dot text section 
Dialogue: 0,0:38:41.02,0:38:46.50,csapp,,0,0,0,,and it it includes this relocation entry which says  to the linker hey 
Dialogue: 0,0:38:46.98,0:38:54.38,csapp,,0,0,0,,when you're relocating main.o add offset a in this dot text section
Dialogue: 0,0:38:55.48,0:39:03.36,csapp,,0,0,0,,you've got a reference a 32 a reference to an array in the form of a 32-bit address 
Dialogue: 0,0:39:04.52,0:39:11.40,csapp,,0,0,0,,ok so that so eventually the linker is going to have to patch up these 
Dialogue: 0,0:39:12.28,0:39:15.04,csapp,,0,0,0,,so this is address 9 this is address a 
Dialogue: 0,0:39:15.04,0:39:18.30,csapp,,0,0,0,,it's going to have to patch up the four bytes starting at address a
Dialogue: 0,0:39:19.82,0:39:24.76,csapp,,0,0,0,,with the absolute address of the symbol array
Dialogue: 0,0:39:28.58,0:39:33.46,csapp,,0,0,0,,and then similarly the reference to the reference to
Dialogue: 0,0:39:35.68,0:39:38.70,csapp,,0,0,0,, this the reference to this function some 
Dialogue: 0,0:39:39.72,0:39:42.20,csapp,,0,0,0,,the compiler has no idea where some 
Dialogue: 0,0:39:42.66,0:39:46.74,csapp,,0,0,0,,actually will end up it doesn't even know what module it's in or even if it's
Dialogue: 0,0:39:47.08,0:39:49.24,csapp,,0,0,0,, even if it is defined in a module 
Dialogue: 0,0:39:49.94,0:39:55.48,csapp,,0,0,0,,so in this case it just it does a call with all zeros 
Dialogue: 0,0:39:58.14,0:40:01.72,csapp,,0,0,0,,and then it adds this relocation entry that says to the linker 
Dialogue: 0,0:40:03.10,0:40:13.88,csapp,,0,0,0,,at offset F you've got a four byte pc-relative reference  to a function
Dialogue: 0,0:40:14.76,0:40:16.16,csapp,,0,0,0,,to assemble called sum 
Dialogue: 0,0:40:17.78,0:40:23.66,csapp,,0,0,0,,and then it this is sort of a arcane detail that but and it includes 
Dialogue: 0,0:40:24.24,0:40:27.96,csapp,,0,0,0,,there's an option to include a bias in the in the offset 
Dialogue: 0,0:40:28.66,0:40:36.26,csapp,,0,0,0,,and since we're using since calls are since calls are always resolved using pc-relative addressing 
Dialogue: 0,0:40:36.78,0:40:43.18,csapp,,0,0,0,,the value that's going to be placed here at these four bytes that offset F
Dialogue: 0,0:40:43.70,0:40:48.40,csapp,,0,0,0,, is going to be an offset from the current or I p value or program or counter value 
Dialogue: 0,0:40:49.44,0:40:53.66,csapp,,0,0,0,,and since the program counter always points to the nest get next instruction
Dialogue: 0,0:40:55.66,0:40:59.18,csapp,,0,0,0,, it includes this which is four bytes away it includes this 
Dialogue: 0,0:40:59.54,0:41:01.40,csapp,,0,0,0,,this offset of minus four 
Dialogue: 0,0:41:02.96,0:41:11.22,csapp,,0,0,0,,so if it sits I I talked about it in detail in the book if you really want to know  how this works
Dialogue: 0,0:41:11.32,0:41:17.98,csapp,,0,0,0,,but just the point here is that there's enough information for the linker to actually fill in the right address 
Dialogue: 0,0:41:18.98,0:41:21.34,csapp,,0,0,0,,so now if we look at the relocated text section
Dialogue: 0,0:41:21.34,0:41:27.64,csapp,,0,0,0,, so if we if we compile this code into an executable and then we use object on to to disassemble it
Dialogue: 0,0:41:28.52,0:41:34.36,csapp,,0,0,0,, then what you see is this this reference here
Dialogue: 0,0:41:34.36,0:41:38.58,csapp,,0,0,0,,where we move the address of the address of a into EDI 
Dialogue: 0,0:41:39.96,0:41:50.20,csapp,,0,0,0,,those four bytes which were original zero have now been updated with the the actual address of array in in memory at runtime
Dialogue: 0,0:41:50.70,0:41:57.60,csapp,,0,0,0,, okay so the linkers decided that the array is going to go at address 0x601018 
Dialogue: 0,0:41:58.46,0:42:06.54,csapp,,0,0,0,,and then it's it's actually patched that the four bytes in the cup in the in the move instruction with that absolute address
Dialogue: 0,0:42:08.90,0:42:12.28,csapp,,0,0,0,,and the call to sum is is it's also been updated 
Dialogue: 0,0:42:13.18,0:42:15.02,csapp,,0,0,0,,but this one's interesting right that 
Dialogue: 0,0:42:15.46,0:42:22.04,csapp,,0,0,0,,so the the address it's been updated with the PC relative address of five
Dialogue: 0,0:42:23.42,0:42:25.42,csapp,,0,0,0,, okay so when this program runs 
Dialogue: 0,0:42:27.34,0:42:28.98,csapp,,0,0,0,,this call instruction 
Dialogue: 0,0:42:30.54,0:42:39.68,csapp,,0,0,0,,what it will do when it when it determines when it computes the absolute address of of the function sum
Dialogue: 0,0:42:40.84,0:42:49.10,csapp,,0,0,0,,it will take
Dialogue: 0,0:42:49.26,0:43:00.36,csapp,,0,0,0,,it will take the the current value of the program counter which is the next instruction so 0x4004e3
Dialogue: 0,0:43:01.44,0:43:07.42,csapp,,0,0,0,,and it will add to it whatever whatever value is in this immediate field 
Dialogue: 0,0:43:08.16,0:43:13.84,csapp,,0,0,0,,okay which is a two scomp you interpret it as a two's complement integer so it can go
Dialogue: 0,0:43:14.76,0:43:18.22,csapp,,0,0,0,,it can be relative you can go - or or +
Dialogue: 0,0:43:18.88,0:43:28.44,csapp,,0,0,0,,in this case it's saying that the function that you want to call is that is is at 4004e3 + 5
Dialogue: 0,0:43:29.54,0:43:34.66,csapp,,0,0,0,,which is 4004e8 which is the address of some 
Dialogue: 0,0:43:35.80,0:43:40.38,csapp,,0,0,0,,okay and so the linker the linker does that the compiler has all the smarts 
Dialogue: 0,0:43:40.38,0:43:43.46,csapp,,0,0,0,,the compiler computed the relocation entry 
Dialogue: 0,0:43:43.70,0:43:49.02,csapp,,0,0,0,,the linker is just blindly going through each of those relocation entries and just doing what it's told 
Dialogue: 0,0:43:50.44,0:43:58.74,csapp,,0,0,0,,okay but the net result is that now all of these these references have been patched up with with valid absolute addresses
Dialogue: 0,0:44:04.90,0:44:08.34,csapp,,0,0,0,,now once the linkers created a an object file
Dialogue: 0,0:44:10.20,0:44:13.92,csapp,,0,0,0,, that object file can be loaded the code and data 
Dialogue: 0,0:44:13.92,0:44:18.80,csapp,,0,0,0,,and that object file can be loaded directly into memory with with no further modification 
Dialogue: 0,0:44:20.32,0:44:29.72,csapp,,0,0,0,, ok so the if you look at all of the read-only sections in the executable
Dialogue: 0,0:44:30.62,0:44:33.60,csapp,,0,0,0,,  so there's this init section which 
Dialogue: 0,0:44:35.40,0:44:41.18,csapp,,0,0,0,,we're not to worry about that that all the code is in the dot text and things like jump tables are in our Oh data 
Dialogue: 0,0:44:43.58,0:44:48.18,csapp,,0,0,0,,all of this data can be loaded directly into memory as is 
Dialogue: 0,0:44:49.64,0:44:53.90,csapp,,0,0,0,,okay so these bytes can just be copied directly into into memory
Dialogue: 0,0:44:54.82,0:44:58.78,csapp,,0,0,0,, and that that forms the so called a read-only code segment 
Dialogue: 0,0:45:02.44,0:45:10.60,csapp,,0,0,0,,the the data in the .data and BSS X sections can also be copied directly into into memory 
Dialogue: 0,0:45:13.40,0:45:19.86,csapp,,0,0,0,,and in the case of the variables and data they'll be initialized to a value that's stored in the symbol table
Dialogue: 0,0:45:22.96,0:45:27.34,csapp,,0,0,0,, so we're drawing our our memory here 
Dialogue: 0,0:45:27.34,0:45:36.34,csapp,,0,0,0,,this is the this is the the memory address space that every Linux program sees 
Dialogue: 0,0:45:37.56,0:45:46.02,csapp,,0,0,0,,and we're drawing addresses starting from 0 and going up increasing as we grow up 
Dialogue: 0,0:45:47.62,0:45:58.04,csapp,,0,0,0,,and every program is loaded at this the same address  0x400000 
Dialogue: 0,0:45:59.76,0:46:06.36,csapp,,0,0,0,,and so the the code comes directly from the object file the data comes directly from the object file 
Dialogue: 0,0:46:07.04,0:46:09.68,csapp,,0,0,0,,and then that's followed by a runtime heap
Dialogue: 0,0:46:10.18,0:46:12.50,csapp,,0,0,0,, which is created and managed by malloc 
Dialogue: 0,0:46:13.14,0:46:16.38,csapp,,0,0,0,,so when you need dynamic dynamically need to allocate memory 
Dialogue: 0,0:46:16.42,0:46:22.22,csapp,,0,0,0,,like using malloc that memory comes out of this heap 
Dialogue: 0,0:46:22.30,0:46:26.94,csapp,,0,0,0,,which starts immediately following the the data segment and grows upwards
Dialogue: 0,0:46:29.42,0:46:35.42,csapp,,0,0,0,,  the stack is at the very top of the the visible 
Dialogue: 0,0:46:36.26,0:46:39.20,csapp,,0,0,0,, memory that's available to application programs
Dialogue: 0,0:46:40.02,0:46:46.94,csapp,,0,0,0,, the memory above that is is restricted to the kernel 
Dialogue: 0,0:46:47.62,0:46:51.92,csapp,,0,0,0,,okay so if you try to access those memory locations you'll get a seg fault 
Dialogue: 0,0:46:54.00,0:46:58.72,csapp,,0,0,0,,and then the stack as we know grows down so this is managed and created a run time
Dialogue: 0,0:46:59.50,0:47:03.88,csapp,,0,0,0,,and then there's this region somewhere in this huge gap between the stack and the heap
Dialogue: 0,0:47:05.54,0:47:14.74,csapp,,0,0,0,, there's a region for shared libraries so the dot Esso files all get loaded into this this memory mapped region for shared libraries 
Dialogue: 0,0:47:17.90,0:47:21.84,csapp,,0,0,0,,now that the top of the heap is indicated by this global variable
Dialogue: 0,0:47:23.12,0:47:26.52,csapp,,0,0,0,,  maintained by the kernel called break BRK  
Dialogue: 0,0:47:27.38,0:47:33.60,csapp,,0,0,0,,and the the top of the stack as we know is is maintained by the general purpose register RSP
Dialogue: 0,0:47:34.58,0:47:38.00,csapp,,0,0,0,, now there's a little bit of a this is a little bit of a simplification
Dialogue: 0,0:47:38.00,0:47:42.64,csapp,,0,0,0,, if you actually look at the addresses returned by malloc
Dialogue: 0,0:47:43.44,0:47:46.34,csapp,,0,0,0,,there's actually a there's actually two heaps 
Dialogue: 0,0:47:46.34,0:47:50.88,csapp,,0,0,0,,there's a heap up here and in the high memory that grows down 
Dialogue: 0,0:47:51.16,0:47:54.20,csapp,,0,0,0,,that's used for large objects very large 
Dialogue: 0,0:47:54.64,0:48:01.72,csapp,,0,0,0,,you know if you mount like a whole bunch of space and then the heap that grows up is  is reserved for smaller smaller objects
Dialogue: 0,0:48:03.26,0:48:04.60,csapp,,0,0,0,, so I'm not really sure why they do this
Dialogue: 0,0:48:04.62,0:48:11.02,csapp,,0,0,0,, I think it allows them to have separate allocation algorithms for large objects and small objects
Dialogue: 0,0:48:19.32,0:48:25.04,csapp,,0,0,0,,okay so one of the one of the real advantages of linking is that allows us to create libraries of things 
Dialogue: 0,0:48:26.26,0:48:29.12,csapp,,0,0,0,,so it's always something we want to do as programmers we always 
Dialogue: 0,0:48:30.92,0:48:36.72,csapp,,0,0,0,,we always want to create abstractions and then present those abstractions to to users 
Dialogue: 0,0:48:37.42,0:48:40.48,csapp,,0,0,0,, right and we do that by creating libraries defining an API 
Dialogue: 0,0:48:40.48,0:48:50.76,csapp,,0,0,0,,yes 
Dialogue: 0,0:48:53.20,0:48:56.54,csapp,,0,0,0,,I think it just is no no it 
Dialogue: 0,0:48:59.02,0:49:04.92,csapp,,0,0,0,,actually that's a good question I the things I've done it just grows until it runs out of memory right there
Dialogue: 0,0:49:06.22,0:49:10.06,csapp,,0,0,0,,so I don't think actually that's a really good question I mean I've
Dialogue: 0,0:49:10.79,0:49:14.66,csapp,,0,0,0,, I've done those experiments and it it eventually reaches some limit 
Dialogue: 0,0:49:21.38,0:49:24.96,csapp,,0,0,0,,yeah I don't I don't know it's a very large number 
Dialogue: 0,0:49:29.34,0:49:36.18,csapp,,0,0,0,,but I so you know as programmers we always want to abstract define api's
Dialogue: 0,0:49:36.50,0:49:42.30,csapp,,0,0,0,,implement package up those api's and make them available to to other programmers 
Dialogue: 0,0:49:44.78,0:49:50.24,csapp,,0,0,0,,so how can we actually do that how can we make commonly used functions available to other programmers
Dialogue: 0,0:49:50.56,0:49:55.94,csapp,,0,0,0,,well one thing given what we've learned so far you could just take all the functions
Dialogue: 0,0:49:56.52,0:50:00.30,csapp,,0,0,0,, and put them all in a single big C file right 
Dialogue: 0,0:50:01.08,0:50:07.74,csapp,,0,0,0,,and then programmers would just link that C file into their into their programs if they want to use them right 
Dialogue: 0,0:50:08.48,0:50:13.20,csapp,,0,0,0,,another option would be to take that might get kind of unwieldy if it's a big library right 
Dialogue: 0,0:50:13.42,0:50:16.30,csapp,,0,0,0,,lipsi has hundreds and hundreds of functions 
Dialogue: 0,0:50:17.44,0:50:21.50,csapp,,0,0,0,,so another option would might be to just take each function put it in a separate file 
Dialogue: 0,0:50:22.20,0:50:25.56,csapp,,0,0,0,,and then compile them all together and compile and link them all together
Dialogue: 0,0:50:27.22,0:50:33.48,csapp,,0,0,0,,so this is more space and time efficient than then our first option 
Dialogue: 0,0:50:34.72,0:50:37.50,csapp,,0,0,0,,but it seems like it would be burdensome on the programmer because
Dialogue: 0,0:50:38.18,0:50:42.70,csapp,,0,0,0,, the program would have to know where all the all these functions were and put them in make files
Dialogue: 0,0:50:42.70,0:50:50.56,csapp,,0,0,0,, it'd just be a lot of you know this you could end up with a ridiculously large  command line to GCC
Dialogue: 0,0:50:52.80,0:50:57.96,csapp,,0,0,0,,so that the one solution to this problem is that 
Dialogue: 0,0:50:58.24,0:51:03.82,csapp,,0,0,0,,the first solution that the developers of Unix came up with us 
Dialogue: 0,0:51:04.10,0:51:05.54,csapp,,0,0,0,,something called a static library 
Dialogue: 0,0:51:06.44,0:51:11.58,csapp,,0,0,0,,so the the idea where the static library is that you create this archive  called a dot a file 
Dialogue: 0,0:51:12.50,0:51:19.18,csapp,,0,0,0,,which is  it's just a collection of .o file where each .o file contains a function
Dialogue: 0,0:51:19.46,0:51:25.65,csapp,,0,0,0,, ok so you take all the functions in your library you use option two to create a bunch of .o files 
Dialogue: 0,0:51:26.30,0:51:31.26,csapp,,0,0,0,,and then you use a program called an archive or AR  to take those .o files
Dialogue: 0,0:51:31.82,0:51:37.30,csapp,,0,0,0,, put them together in a all together in a big file called an archive
Dialogue: 0,0:51:37.94,0:51:44.14,csapp,,0,0,0,, out with a with a table of contents at the beginning that tells you the offset of each one of the .o files 
Dialogue: 0,0:51:44.54,0:51:49.92,csapp,,0,0,0,,ok so an archive is just this concatenated collection of .o files 
Dialogue: 0,0:51:53.12,0:51:57.64,csapp,,0,0,0,,and then and then you link you pass that archive to the to the linker
Dialogue: 0,0:51:58.06,0:52:03.62,csapp,,0,0,0,,and it only takes the .o files that are actually referenced   and links them into the code  
Dialogue: 0,0:52:03.74,0:52:07.42,csapp,,0,0,0,,right so it's a more efficient way you can have a huge archive
Dialogue: 0,0:52:07.78,0:52:10.26,csapp,,0,0,0,, but like Lib.c but if you only call printf 
Dialogue: 0,0:52:11.32,0:52:13.88,csapp,,0,0,0,, the only dot o file you get is printf .o
Dialogue: 0,0:52:15.50,0:52:17.90,csapp,,0,0,0,, okay so the way this works is 
Dialogue: 0,0:52:18.80,0:52:19.96,csapp,,0,0,0,,as before we take
Dialogue: 0,0:52:24.76,0:52:28.00,csapp,,0,0,0,,now we take all the functions we want to put in our library
Dialogue: 0,0:52:29.40,0:52:32.48,csapp,,0,0,0,, we run them through our translators to get .o files 
Dialogue: 0,0:52:33.30,0:52:37.14,csapp,,0,0,0,,we pass those to the archiver to get a the archive 
Dialogue: 0,0:52:37.14,0:52:40.74,csapp,,0,0,0,,so in this case Lib CA 
Dialogue: 0,0:52:42.02,0:52:46.16,csapp,,0,0,0,,and which has this code for printf that we might want to use 
Dialogue: 0,0:52:47.32,0:52:52.42,csapp,,0,0,0,,right and so we can we can we can recreate that archive anytime we want 
Dialogue: 0,0:52:52.42,0:52:55.62,csapp,,0,0,0,,so if one of these functions changes like say printf changes 
Dialogue: 0,0:52:56.10,0:53:03.51,csapp,,0,0,0,,you just rearchive the dot recompile printf and then re archive all of the .o files
Dialogue: 0,0:53:04.40,0:53:07.30,csapp,,0,0,0,,so in Libc it's it's about 1500 object files 
Dialogue: 0,0:53:07.36,0:53:14.42,csapp,,0,0,0,,and it's archived things like printf scanf simple integer math  and there's also a math library 
Dialogue: 0,0:53:15.84,0:53:20.92,csapp,,0,0,0,,which has you know several hundred common functions for things like
Dialogue: 0,0:53:21.66,0:53:26.50,csapp,,0,0,0,, floating point math sine cosine tangent etc 
Dialogue: 0,0:53:27.98,0:53:34.40,csapp,,0,0,0,,these libraries the convention is that a library always is prefixed with Lib with Li B and then a
Dialogue: 0,0:53:35.06,0:53:38.72,csapp,,0,0,0,,nd then sort of new some indication of what it what it does
Dialogue: 0,0:53:42.64,0:53:45.46,csapp,,0,0,0,,so now let's see how linking with these static libraries would work 
Dialogue: 0,0:53:45.52,0:53:47.84,csapp,,0,0,0,,so I've created a little example here 
Dialogue: 0,0:53:50.36,0:53:53.38,csapp,,0,0,0,,I've created a library called libvector.a
Dialogue: 0,0:53:54.40,0:53:57.38,csapp,,0,0,0,,and it consists of functions that manipulate vectors 
Dialogue: 0,0:53:57.82,0:54:00.68,csapp,,0,0,0,,and this is a real simple library it just adds 
Dialogue: 0,0:54:00.90,0:54:07.56,csapp,,0,0,0,,there's a function to add two vectors x and y together and and return the result in Z
Dialogue: 0,0:54:10.10,0:54:16.00,csapp,,0,0,0,,and then another similar function that will do pairwise multiplication of two vectors so 
Dialogue: 0,0:54:16.44,0:54:20.46,csapp,,0,0,0,,x[i]*y[i] equals z[i]
Dialogue: 0,0:54:22.06,0:54:28.94,csapp,,0,0,0,,now I compile these two programs and pack I want to package them into an archive called lib vector a 
Dialogue: 0,0:54:29.70,0:54:34.46,csapp,,0,0,0,,and then in my in my main program I'm going to call one of those functions advic
Dialogue: 0,0:54:35.12,0:54:38.08,csapp,,0,0,0,, to add these two vectors x and y together
Dialogue: 0,0:54:43.28,0:54:46.26,csapp,,0,0,0,,so now what happens when we compile this this program 
Dialogue: 0,0:54:47.82,0:54:56.36,csapp,,0,0,0,,we've already we've constructed the archive lib dr. a  from addvec.o and multvec.o 
Dialogue: 0,0:54:57.80,0:55:05.90,csapp,,0,0,0,,and we pass that archive to the linker along with our main 2.0 relocatable object file 
Dialogue: 0,0:55:07.68,0:55:10.42,csapp,,0,0,0,,and we also pass it libc.a 
Dialogue: 0,0:55:10.80,0:55:14.10,csapp,,0,0,0,,which has the definition of which contains printf.o
Dialogue: 0,0:55:14.96,0:55:17.10,csapp,,0,0,0,,and anything else that printf.o my call
Dialogue: 0,0:55:19.08,0:55:26.99,csapp,,0,0,0,,so these three the linker detects the reference to advic the function addvec
Dialogue: 0,0:55:26.99,0:55:32.11,csapp,,0,0,0,,and so it just pulls addvec.o out and and ignores the rest
Dialogue: 0,0:55:32.78,0:55:36.66,csapp,,0,0,0,,similarly for printf.o and then it compiles all those 
Dialogue: 0,0:55:36.96,0:55:43.32,csapp,,0,0,0,,main main.o addvec.o and printf.o all together into this fully linked executable 
Dialogue: 0,0:55:43.78,0:55:47.10,csapp,,0,0,0,,called prog to see for compiled time 
Dialogue: 0,0:55:48.84,0:55:54.79,csapp,,0,0,0,,so we're doing this we're doing this link we're doing this this linking at compile time
Dialogue: 0,0:55:55.28,0:55:57.28,csapp,,0,0,0,,when we call a GCC now 
Dialogue: 0,0:55:59.06,0:56:05.12,csapp,,0,0,0,,what the linker does when it's when it's using static libraries
Dialogue: 0,0:56:07.88,0:56:12.28,csapp,,0,0,0,, it scans all the dot o files and dot a files in order on the command line 
Dialogue: 0,0:56:12.32,0:56:21.02,csapp,,0,0,0,,so you're just typing GCC and then a list of dot o files and davay files in some order 
Dialogue: 0,0:56:23.08,0:56:29.14,csapp,,0,0,0,,so so during the scan it keeps a list of the current unresolved references right 
Dialogue: 0,0:56:30.18,0:56:35.10,csapp,,0,0,0,,so if let's say let's say it looks at main dot o first and there's a reference to printf
Dialogue: 0,0:56:36.58,0:56:41.10,csapp,,0,0,0,, that's an unresolved reference because print is not not defined in main.o 
Dialogue: 0,0:56:41.10,0:56:43.40,csapp,,0,0,0,,so that goes in a list of undefined references
Dialogue: 0,0:56:44.72,0:56:51.68,csapp,,0,0,0,,and at some point or another as as each new .o file or .a file is encountered
Dialogue: 0,0:56:52.22,0:57:01.36,csapp,,0,0,0,, the linker tries to resolve its list of Unruh of references with the symbols that are defined in that .o file or ,a file 
Dialogue: 0,0:57:03.14,0:57:06.90,csapp,,0,0,0,,and then if there's any entries in the list at the end of the scan then there's  error 
Dialogue: 0,0:57:07.42,0:57:13.48,csapp,,0,0,0,,okay so that the key here is that the linker will try to resolve these references from left to right on the command line 
Dialogue: 0,0:57:14.16,0:57:18.76,csapp,,0,0,0,,and so this is another sort of important thing for you to know as programmers 
Dialogue: 0,0:57:18.76,0:57:25.22,csapp,,0,0,0,,because the order that you that you put your files on the command line actually makes a difference
Dialogue: 0,0:57:25.58,0:57:31.36,csapp,,0,0,0,, okay so you can get sort of weird baffling linker errors if you if you use the wrong order 
Dialogue: 0,0:57:32.20,0:57:34.08,csapp,,0,0,0,,so for instance suppose we've got
Dialogue: 0,0:57:36.78,0:57:40.12,csapp,,0,0,0,, a function an object module called Lib test 
Dialogue: 0,0:57:41.04,0:57:48.24,csapp,,0,0,0,, that calls a function that's defined in in lmine.a 
Dialogue: 0,0:57:49.24,0:57:54.84,csapp,,0,0,0,,okay so these - else - big L period that that says to look for 
Dialogue: 0,0:57:56.82,0:58:02.88,csapp,,0,0,0,,to look for a library files in the current directory
Dialogue: 0,0:58:02.88,0:58:07.80,csapp,,0,0,0,, that's what the dot look there first and then look in the normal places that you look
Dialogue: 0,0:58:09.04,0:58:14.72,csapp,,0,0,0,,and the the -l that's a it's like an abbreviation 
Dialogue: 0,0:58:15.20,0:58:20.14,csapp,,0,0,0,,we could replace this with just the fully spelled out lib mind ed 
Dialogue: 0,0:58:20.98,0:58:23.84,csapp,,0,0,0,,okay but you'll see this this  -l used a lot 
Dialogue: 0,0:58:24.68,0:58:30.94,csapp,,0,0,0,,so so Lib test calls a function that's declared in in Lib mind.a 
Dialogue: 0,0:58:32.00,0:58:37.28,csapp,,0,0,0,,so the linker looks at it looks at the unresolved symbols in libtest.o 
Dialogue: 0,0:58:38.08,0:58:41.28,csapp,,0,0,0,, and it detects that there's this unresolved function let's say it's called foo 
Dialogue: 0,0:58:42.34,0:58:44.90,csapp,,0,0,0,,I know it's it's called Lib fun 
Dialogue: 0,0:58:46.20,0:58:54.38,csapp,,0,0,0,,so and it puts it on the list and then it goes on to the next command line entry  and that's live mine.a 
Dialogue: 0,0:58:54.78,0:58:58.92,csapp,,0,0,0,,and in there it finds it finds this symbol of libfun
Dialogue: 0,0:58:59.64,0:59:08.10,csapp,,0,0,0,, and it it resolves the reference to that - Lib phone - the actual address the relocated address
Dialogue: 0,0:59:09.14,0:59:15.04,csapp,,0,0,0,,now if we switch the order and we put lmine on a first followed by libtest.o
Dialogue: 0,0:59:15.84,0:59:18.60,csapp,,0,0,0,,well there's there's no unresolved references in this library
Dialogue: 0,0:59:18.60,0:59:21.46,csapp,,0,0,0,, right it's just the collection of function definitions 
Dialogue: 0,0:59:23.26,0:59:27.96,csapp,,0,0,0,, so it there's no unresolved references so the linker looks at that that's all good 
Dialogue: 0,0:59:28.26,0:59:33.10,csapp,,0,0,0,,and then it looks at lib toss zero and now there's an unresolved reference to two libfun 
Dialogue: 0,0:59:33.72,0:59:36.32,csapp,,0,0,0,,but we're out of we're at the end of the command line
Dialogue: 0,0:59:37.18,0:59:38.46,csapp,,0,0,0,,so that's a linker error 
Dialogue: 0,0:59:39.64,0:59:44.40,csapp,,0,0,0,,so you get this you get this really cryptic error message 
Dialogue: 0,0:59:45.56,0:59:50.24,csapp,,0,0,0,, and if you didn't know about this ordering rule you wouldn't have any idea how to debug
Dialogue: 0,0:59:53.32,0:59:56.88,csapp,,0,0,0,, it okay so the static libraries are kind of the old fashioned solution that 
Dialogue: 0,0:59:56.88,1:00:02.04,csapp,,0,0,0,,the modern solution is to use dynamic libraries or shared shared libraries 
Dialogue: 0,1:00:04.14,1:00:08.42,csapp,,0,0,0,,so the reason the reason there's this sort of newer form of libraries
Dialogue: 0,1:00:08.46,1:00:11.74,csapp,,0,0,0,, that static libraries have some some disadvantages 
Dialogue: 0,1:00:12.48,1:00:17.18,csapp,,0,0,0,,so every if you compile with static libraries 
Dialogue: 0,1:00:17.20,1:00:20.14,csapp,,0,0,0,,then every every function that uses printf 
Dialogue: 0,1:00:20.14,1:00:24.34,csapp,,0,0,0,, which or every program that uses printf has to have a copy of printf
Dialogue: 0,1:00:25.98,1:00:29.12,csapp,,0,0,0,, okay but almost every every program uses printf right 
Dialogue: 0,1:00:29.14,1:00:35.14,csapp,,0,0,0,,so there's a shared shared libraries allow provide a mechanism where there can just be one 
Dialogue: 0,1:00:35.78,1:00:43.32,csapp,,0,0,0,,wherever there's just one instance of a shared library  member like like printf 
Dialogue: 0,1:00:44.22,1:00:47.96,csapp,,0,0,0,,and every program running on the system will share that one copy
Dialogue: 0,1:00:54.76,1:00:59.96,csapp,,0,0,0,,so that's the that's sort of the big big disadvantage is this potential duplication 
Dialogue: 0,1:01:01.80,1:01:08.42,csapp,,0,0,0,,so shared libraries are different in the sense that they contain
Dialogue: 0,1:01:11.34,1:01:17.14,csapp,,0,0,0,,code and data that are linked and loaded into the program not when it's not when it's compiled
Dialogue: 0,1:01:17.72,1:01:21.46,csapp,,0,0,0,, and linked and into a executable object file
Dialogue: 0,1:01:21.80,1:01:25.98,csapp,,0,0,0,, but actually when the program is loaded into the system
Dialogue: 0,1:01:25.98,1:01:31.50,csapp,,0,0,0,, so linking of references to shared library objects is deferred 
Dialogue: 0,1:01:32.20,1:01:35.54,csapp,,0,0,0,,until the program is actually loaded into into memory 
Dialogue: 0,1:01:35.78,1:01:39.28,csapp,,0,0,0,,until the executable object file is actually loaded into memory 
Dialogue: 0,1:01:40.28,1:01:42.86,csapp,,0,0,0,,and this can either and it can even happen 
Dialogue: 0,1:01:43.36,1:01:49.82,csapp,,0,0,0,,it can happen when the program is actually loaded into memory but it can also happen at runtime anytime at runtime 
Dialogue: 0,1:01:50.50,1:01:52.76,csapp,,0,0,0,,so you can be you can be running a program 
Dialogue: 0,1:01:53.20,1:01:59.86,csapp,,0,0,0,,and that program can arbitrarily decide to load a function that's declared in a shared library 
Dialogue: 0,1:02:00.32,1:02:01.78,csapp,,0,0,0,,okay and I'll show you that it's really cool 
Dialogue: 0,1:02:04.12,1:02:06.68,csapp,,0,0,0,,now these things are often called they're called shared libraries 
Dialogue: 0,1:02:06.68,1:02:10.54,csapp,,0,0,0,,they're called dynamic link libraries like in Windows they're called DLLs 
Dialogue: 0,1:02:11.42,1:02:14.46,csapp,,0,0,0,,.iso files they're all referenced the same thing
Dialogue: 0,1:02:21.36,1:02:27.32,csapp,,0,0,0,, okay so that this like I said you can the the dynamic linking can occur when the program's loaded or 
Dialogue: 0,1:02:27.88,1:02:30.20,csapp,,0,0,0,,after it's loaded and actually running 
Dialogue: 0,1:02:32.28,1:02:37.66,csapp,,0,0,0,,and there's this sort of big deal that shared library routines can be shared by multiple processes 
Dialogue: 0,1:02:37.88,1:02:40.46,csapp,,0,0,0,,and we'll look at this this will make sense when we look at virtual memories 
Dialogue: 0,1:02:40.46,1:02:42.36,csapp,,0,0,0,,so don't don't worry about that now 
Dialogue: 0,1:02:43.28,1:02:45.26,csapp,,0,0,0,,but but here's how the process works
Dialogue: 0,1:02:49.68,1:02:54.02,csapp,,0,0,0,,so we've first we have to create instead of creating an archive 
Dialogue: 0,1:02:54.78,1:02:59.88,csapp,,0,0,0,,we create a shared library so our live vector routines
Dialogue: 0,1:03:02.22,1:03:08.88,csapp,,0,0,0,, instead of creating an archive a file we create a shared a .so file
Dialogue: 0,1:03:09.46,1:03:13.08,csapp,,0,0,0,,using the using the shared argument to GCC 
Dialogue: 0,1:03:13.98,1:03:17.52,csapp,,0,0,0,,so we take our two input functions a addvec and multvec
Dialogue: 0,1:03:18.28,1:03:25.72,csapp,,0,0,0,,and share it says to create and we're telling GCC to create a shared library  and place it in libvector.so 
Dialogue: 0,1:03:27.04,1:03:36.74,csapp,,0,0,0,,okay and so and there's also that the the C the C developers have created a punctured library called libc.so
Dialogue: 0,1:03:36.76,1:03:41.40,csapp,,0,0,0,,that contains printf and on it and other standard library functions
Dialogue: 0,1:03:43.46,1:03:47.88,csapp,,0,0,0,, so we take our program main2 this is the same program that calls advic 
Dialogue: 0,1:03:48.76,1:03:51.88,csapp,,0,0,0,,and we compile it into main2.o 
Dialogue: 0,1:03:52.30,1:03:57.24,csapp,,0,0,0,,and we pass main2.0 and  these .so files to the linker
Dialogue: 0,1:03:59.72,1:04:07.96,csapp,,0,0,0,,now the linker doesn't at this point it doesn't actually copy let's say we're using advic or printf 
Dialogue: 0,1:04:08.36,1:04:14.14,csapp,,0,0,0,,it doesn't actually copy those functions or do anything with them  in the executable
Dialogue: 0,1:04:14.14,1:04:18.44,csapp,,0,0,0,, it just makes a note in the symbol table that those functions will need to be the
Dialogue: 0,1:04:20.28,1:04:24.70,csapp,,0,0,0,,references to those functions will need to be resolved  when the program is loaded 
Dialogue: 0,1:04:25.22,1:04:31.02,csapp,,0,0,0,,okay so it it puts in a relocation entry that says fix this up when you load the program 
Dialogue: 0,1:04:32.16,1:04:35.44,csapp,,0,0,0,,so it's partially linked but it's not fully linked 
Dialogue: 0,1:04:35.44,1:04:41.94,csapp,,0,0,0,,you can't take that you can't take a program you can't take a executable file 
Dialogue: 0,1:04:42.24,1:04:45.56,csapp,,0,0,0,,that was dynamically linked and loaded directly 
Dialogue: 0,1:04:47.42,1:04:54.02,csapp,,0,0,0,,what you what you do is the loader which is the execve system call
Dialogue: 0,1:04:54.50,1:04:58.50,csapp,,0,0,0,,and we'll learn more about that but just this is just a cyst call that loads
Dialogue: 0,1:04:59.04,1:05:02.12,csapp,,0,0,0,,loads executables into memory and runs them 
Dialogue: 0,1:05:03.84,1:05:06.38,csapp,,0,0,0,,the loader takes the executable 
Dialogue: 0,1:05:07.06,1:05:12.42,csapp,,0,0,0,,and then it takes the the shared .so files
Dialogue: 0,1:05:13.04,1:05:19.72,csapp,,0,0,0,, that this program needs k it also made when the linker also made a note of which .so files  it needs 
Dialogue: 0,1:05:22.26,1:05:27.50,csapp,,0,0,0,,so the loader calls the dynamic linker which takes those .so files 
Dialogue: 0,1:05:27.86,1:05:33.18,csapp,,0,0,0,,and then actually resolves all the references to any on any unresolved reference 
Dialogue: 0,1:05:33.70,1:05:41.52,csapp,,0,0,0,,okay so the the address of addvwc the addvec and printf functions isn't determined until 
Dialogue: 0,1:05:42.14,1:05:49.32,csapp,,0,0,0,,the program is loaded and by that and it isn't determined by the dynamic linker until the program is loaded
Dialogue: 0,1:05:50.46,1:05:55.02,csapp,,0,0,0,, so that the dynamic linker does it goes through a similar process that the static linker did 
Dialogue: 0,1:05:55.32,1:05:59.82,csapp,,0,0,0,,sort of fixing up references to add back at references to to printf 
Dialogue: 0,1:06:00.46,1:06:08.42,csapp,,0,0,0,,and then at that point the binary the binary is in it is in a form that can be executed directly 
Dialogue: 0,1:06:08.56,1:06:26.98,csapp,,0,0,0,,so question yes what if you look the part where did like where is that like if you include violence and use anger and greed zero actually
Dialogue: 0,1:06:26.98,1:06:29.64,csapp,,0,0,0,,if okay the question is what happens if you include a file
Dialogue: 0,1:06:30.50,1:06:34.28,csapp,,0,0,0,, so includes are handled by the C preprocessor
Dialogue: 0,1:06:34.94,1:06:40.78,csapp,,0,0,0,, so they're gone they're long gone by the time the by the time the linker gets around to it
Dialogue: 0,1:06:41.28,1:06:45.82,csapp,,0,0,0,,okay so the C preprocessor just takes sharp sign define sharp sign include 
Dialogue: 0,1:06:46.70,1:06:51.44,csapp,,0,0,0,,and and interprets those and outputs another C program 
Dialogue: 0,1:06:51.98,1:06:59.18,csapp,,0,0,0,,so if you if you include a file the C preprocessor just takes that file and just expands it 
Dialogue: 0,1:06:59.90,1:07:05.36,csapp,,0,0,0,,and the output C program contains an expanded version of all the files that you include it
Dialogue: 0,1:07:11.38,1:07:16.82,csapp,,0,0,0,,okay now what's really cool is that you can also do this dynamic linking at runtime
Dialogue: 0,1:07:17.34,1:07:20.84,csapp,,0,0,0,,so what I showed you before we're doing it at load time
Dialogue: 0,1:07:21.78,1:07:27.39,csapp,,0,0,0,, but you can also arbitrarily decide to to load link and
Dialogue: 0,1:07:27.39,1:07:34.68,csapp,,0,0,0,,call a function from a shared from a from any function defined in a .so file 
Dialogue: 0,1:07:35.94,1:07:41.36,csapp,,0,0,0,,and the way you do it is there's a there's an interface called the dl open
Dialogue: 0,1:07:41.84,1:07:44.90,csapp,,0,0,0,,that's in Lib C that allows you to do this
Dialogue: 0,1:07:45.76,1:07:52.58,csapp,,0,0,0,,this and so let's say we want to this is this is our main program and just like before we want to call addvec 
Dialogue: 0,1:07:53.28,1:07:57.24,csapp,,0,0,0,,okay but addvec now is defined in it in a .so file 
Dialogue: 0,1:07:57.92,1:08:00.98,csapp,,0,0,0,, the exact same .so file that we generated before
Dialogue: 0,1:08:02.32,1:08:08.72,csapp,,0,0,0,, when we compile so we'll call this dll.c when we compile this program ddl.c
Dialogue: 0,1:08:10.52,1:08:18.92,csapp,,0,0,0,,we have no we have no idea that it's going to call a function from from Lib.so
Dialogue: 0,1:08:19.38,1:08:23.84,csapp,,0,0,0,,we just compile it as though a standalone C C program
Dialogue: 0,1:08:24.72,1:08:29.32,csapp,,0,0,0,, within this program though we declare a pointer a function pointer called addvec 
Dialogue: 0,1:08:30.10,1:08:32.64,csapp,,0,0,0,,and we give the prototype for this function
Dialogue: 0,1:08:32.70,1:08:39.14,csapp,,0,0,0,,it's pointers city so it's a two input arrays the output array on the size 
Dialogue: 0,1:08:41.28,1:08:46.00,csapp,,0,0,0,,and then first we dynamically load the shared library that contains the function we want 
Dialogue: 0,1:08:47.24,1:08:55.32,csapp,,0,0,0,,so we call dlopen and we say load up this this .so file into memory 
Dialogue: 0,1:08:55.42,1:08:57.50,csapp,,0,0,0,,so that I can call a function 
Dialogue: 0,1:08:57.96,1:09:02.20,csapp,,0,0,0,,but don't resolve you know don't worry don't worry about the
Dialogue: 0,1:09:02.20,1:09:06.28,csapp,,0,0,0,,resolving the references to it functions until I actually tell you too
Dialogue: 0,1:09:07.24,1:09:09.00,csapp,,0,0,0,, that's the lazy part 
Dialogue: 0,1:09:10.50,1:09:13.74,csapp,,0,0,0,,and so what what this deal open returns a handle
Dialogue: 0,1:09:14.40,1:09:18.06,csapp,,0,0,0,, that that then you use in subsequent calls okay 
Dialogue: 0,1:09:19.08,1:09:24.98,csapp,,0,0,0,,so if we don't if the handle is null there was some kind of error like maybe maybe this data so file does exist 
Dialogue: 0,1:09:27.76,1:09:34.32,csapp,,0,0,0,, so once we've opened that .so file then we use dlsym with the handle so this
Dialogue: 0,1:09:34.94,1:09:41.62,csapp,,0,0,0,, and then we we give it as we pass as a string the name of the function that we want to invoke 
Dialogue: 0,1:09:43.26,1:09:47.90,csapp,,0,0,0,,and we get what we get back from dlsym as a pointer to that function 
Dialogue: 0,1:09:48.90,1:09:53.96,csapp,,0,0,0,,and then we can we can use that function just like any other function so we can use that function pointer 
Dialogue: 0,1:09:54.24,1:09:57.44,csapp,,0,0,0,,and we call it just as though it were a statically defined function 
Dialogue: 0,1:09:58.86,1:10:01.88,csapp,,0,0,0,,so you can see this is real very powerful technique
Dialogue: 0,1:10:08.50,1:10:14.86,csapp,,0,0,0,,okay so looks let's finish the the last little bits of the class
Dialogue: 0,1:10:14.86,1:10:21.02,csapp,,0,0,0,, I want to show you it to try to convince you that linking is is actually interesting which is kind of a hard sell sometime 
Dialogue: 0,1:10:21.04,1:10:33.80,csapp,,0,0,0,,yes question...yes...no it's that's how you know
Dialogue: 0,1:10:34.18,1:10:37.72,csapp,,0,0,0,,no you just it's it's declared as a function pointer 
Dialogue: 0,1:10:37.72,1:10:43.46,csapp,,0,0,0,,and you then you just you just you just use the name of the function you don't have to dereference it
Dialogue: 0,1:10:45.42,1:10:52.90,csapp,,0,0,0,,or you just you call it you call the function by just using that that that function pointer name okay
Dialogue: 0,1:10:53.42,1:10:54.38,csapp,,0,0,0,, just like I did
Dialogue: 0,1:10:59.98,1:11:03.22,csapp,,0,0,0,,if you dereference it I just get back a pointer value 
Dialogue: 0,1:11:04.08,1:11:07.80,csapp,,0,0,0,,you get back the address of that function 
Dialogue: 0,1:11:09.70,1:11:15.64,csapp,,0,0,0,,all right so it's kind of a hard sell to that to convince you that linking is is interesting 
Dialogue: 0,1:11:15.64,1:11:16.80,csapp,,0,0,0,,but I'm going to try 
Dialogue: 0,1:11:17.30,1:11:22.52,csapp,,0,0,0,,ok so there's there's this powerful technique called inner library inter positioning 
Dialogue: 0,1:11:23.24,1:11:27.88,csapp,,0,0,0,,and the goal is to intercept function calls from from libraries 
Dialogue: 0,1:11:28.64,1:11:32.60,csapp,,0,0,0,,and do something intercept them for for some reason 
Dialogue: 0,1:11:33.30,1:11:37.24,csapp,,0,0,0,,right so what we typically want to do is intercept a function call
Dialogue: 0,1:11:38.12,1:11:42.04,csapp,,0,0,0,,  maybe record some to some statistics or do some error checking
Dialogue: 0,1:11:42.56,1:11:45.94,csapp,,0,0,0,, and then call the real function as intended
Dialogue: 0,1:11:46.04,1:11:50.16,csapp,,0,0,0,, right so so the idea is we're going to create wrappers 
Dialogue: 0,1:11:52.00,1:12:00.18,csapp,,0,0,0,,and when the program when a program calls a function what we're going to do is we're going to execute its wrapper instead
Dialogue: 0,1:12:01.88,1:12:04.30,csapp,,0,0,0,,okay and we're going to do it without changing any of the source
Dialogue: 0,1:12:09.68,1:12:13.34,csapp,,0,0,0,,now there's a lot of reasons there's a lot of applications for this
Dialogue: 0,1:12:13.94,1:12:21.10,csapp,,0,0,0,, that the neatest one that that I know is that these Facebook engineers 
Dialogue: 0,1:12:21.56,1:12:25.30,csapp,,0,0,0,,so we're trying to deal with this year-long bug in the Facebook iPhone app 
Dialogue: 0,1:12:26.10,1:12:28.20,csapp,,0,0,0,,and nobody could figure out what was going on 
Dialogue: 0,1:12:29.28,1:12:31.86,csapp,,0,0,0,,and they figured it out using library inter positioning 
Dialogue: 0,1:12:32.28,1:12:37.40,csapp,,0,0,0,,they figured out that there was something in the network stack writing to the wrong location 
Dialogue: 0,1:12:37.40,1:12:43.26,csapp,,0,0,0,,they figured it out by intercepting all the calls from their Facebook app  that did rights 
Dialogue: 0,1:12:43.90,1:12:47.04,csapp,,0,0,0,,so things like write write to the EP right 
Dialogue: 0,1:12:47.96,1:12:51.02,csapp,,0,0,0,,so they just they intercepted all those calls and then they were able to
Dialogue: 0,1:12:51.02,1:12:54.06,csapp,,0,0,0,,to when they looked at the arguments and how those functions were being called
Dialogue: 0,1:12:54.26,1:12:55.94,csapp,,0,0,0,,they determine the air 
Dialogue: 0,1:13:00.04,1:13:02.54,csapp,,0,0,0,,you can also use it for monitoring and profiling like 
Dialogue: 0,1:13:02.54,1:13:07.80,csapp,,0,0,0,,so if you want to know like how many times different functions get called you can you can do you can interpose 
Dialogue: 0,1:13:08.34,1:13:12.64,csapp,,0,0,0,,we use it for for generating address traces 
Dialogue: 0,1:13:12.70,1:13:17.46,csapp,,0,0,0,,so you're malloc when you do your malloc lab later in the semester
Dialogue: 0,1:13:17.80,1:13:22.76,csapp,,0,0,0,, you're going to be evaluating your malloc using a traces 
Dialogue: 0,1:13:22.76,1:13:27.36,csapp,,0,0,0,,that we generated from real programs using this inter positioning technique  
Dialogue: 0,1:13:27.62,1:13:34.08,csapp,,0,0,0,,right so we we enter post on all the malloc and free calls in like Netscape
Dialogue: 0,1:13:35.62,1:13:39.18,csapp,,0,0,0,, and then we just recorded what addresses and and sizes 
Dialogue: 0,1:13:39.64,1:13:44.88,csapp,,0,0,0,,Malik was was returning and what what blocks free was freeing up 
Dialogue: 0,1:13:45.30,1:13:51.84,csapp,,0,0,0,,and we just created a trace of those and and then so let me show you how you would do this 
Dialogue: 0,1:13:54.00,1:13:56.24,csapp,,0,0,0,,so the idea let's say we have this main program
Dialogue: 0,1:13:56.26,1:13:59.54,csapp,,0,0,0,, and the idea is to trace all the malloc and free calls 
Dialogue: 0,1:13:59.54,1:14:02.38,csapp,,0,0,0,,so there's one malloc call and there's one free call 
Dialogue: 0,1:14:03.16,1:14:07.18,csapp,,0,0,0,,and we want to know what these addresses are and we want to know what these sizes are 
Dialogue: 0,1:14:08.48,1:14:12.50,csapp,,0,0,0,,so we can do this at either compile time link time or run time 
Dialogue: 0,1:14:13.80,1:14:15.20,csapp,,0,0,0,,to do it at compile time 
Dialogue: 0,1:14:16.02,1:14:19.90,csapp,,0,0,0,,we first write wrapper functions called my malloc and my free 
Dialogue: 0,1:14:20.44,1:14:23.52,csapp,,0,0,0,,where my malloc call most the real malloc function 
Dialogue: 0,1:14:24.08,1:14:30.82,csapp,,0,0,0,,and then it prints out the the size that it was called and the the address that malloc returned 
Dialogue: 0,1:14:31.40,1:14:35.60,csapp,,0,0,0,,okay so this when we run our program it will it will print out these all these addresses
Dialogue: 0,1:14:35.60,1:14:37.36,csapp,,0,0,0,, and it does the same thing for free 
Dialogue: 0,1:14:38.18,1:14:41.46,csapp,,0,0,0,,and then here's the trick in malloc.h
Dialogue: 0,1:14:42.26,1:14:49.20,csapp,,0,0,0,, we we define malloc to be my malloc  okay and free to be my free 
Dialogue: 0,1:14:49.52,1:14:53.34,csapp,,0,0,0,,and then we give the prototype for it so the compiler doesn't get confused 
Dialogue: 0,1:14:54.14,1:14:58.10,csapp,,0,0,0,,and then we can PI might we compile my malloc C into a .o file 
Dialogue: 0,1:14:59.22,1:15:03.54,csapp,,0,0,0,,and then we call week then we complete we call our program
Dialogue: 0,1:15:03.54,1:15:10.74,csapp,,0,0,0,, which is is our main program int dot C for inner positioning 
Dialogue: 0,1:15:11.72,1:15:13.70,csapp,,0,0,0,,and we call that and here's the trick 
Dialogue: 0,1:15:14.58,1:15:18.14,csapp,,0,0,0,,we call it with the - cap I argument 
Dialogue: 0,1:15:18.74,1:15:22.22,csapp,,0,0,0,,and we say look for any include files in the current directory
Dialogue: 0,1:15:22.56,1:15:29.94,csapp,,0,0,0,, okay so this was similar to that el - cap el argument 
Dialogue: 0,1:15:30.90,1:15:35.12,csapp,,0,0,0,,but because we tell GCC to look in the current directory first 
Dialogue: 0,1:15:35.80,1:15:38.20,csapp,,0,0,0,,so this is sort of where the inner positioning happens
Dialogue: 0,1:15:38.68,1:15:44.60,csapp,,0,0,0,,this because when it does that it's going to it's going to find a 
Dialogue: 0,1:15:45.82,1:15:48.28,csapp,,0,0,0,,it's going to find a library called malloc.h
Dialogue: 0,1:15:49.44,1:15:51.54,csapp,,0,0,0,,I mean .h file called malloc.h
Dialogue: 0,1:15:52.02,1:15:57.26,csapp,,0,0,0,,and so all the calls to malloc will be translated by the C preprocessor to my malloc
Dialogue: 0,1:15:58.76,1:16:04.90,csapp,,0,0,0,, so when we run this it prints out the the trip malloc and free trace 
Dialogue: 0,1:16:07.86,1:16:09.60,csapp,,0,0,0,,now we can also do this at link time 
Dialogue: 0,1:16:09.60,1:16:14.38,csapp,,0,0,0,,so we can tell C in order to do this we had to get access to the 
Dialogue: 0,1:16:15.14,1:16:19.24,csapp,,0,0,0,,we had to compile the program we didn't have to change it but we had to compile it 
Dialogue: 0,1:16:19.94,1:16:27.08,csapp,,0,0,0,,we can use link time at our positioning if to avoid that that that compilation 
Dialogue: 0,1:16:28.40,1:16:34.10,csapp,,0,0,0,,so the way this works we define our wrapper functions with this special name underscore underscore wrap malloc
Dialogue: 0,1:16:35.20,1:16:38.96,csapp,,0,0,0,,and this calls the real malloc function and then prints out the information 
Dialogue: 0,1:16:41.14,1:16:51.16,csapp,,0,0,0,,and then at link time then we do the inter positioning by calling the linker with this special -WL  argument 
Dialogue: 0,1:16:52.14,1:16:57.72,csapp,,0,0,0,,and so what this does the the -wl flag to GCC says hey 
Dialogue: 0,1:16:58.34,1:17:05.00,csapp,,0,0,0,,take what follows the argument that follows replace all the commas with spaces 
Dialogue: 0,1:17:05.00,1:17:07.50,csapp,,0,0,0,,and then invoke the linker with this argument 
Dialogue: 0,1:17:07.72,1:17:11.40,csapp,,0,0,0,,okay so what we're doing is passing a linker arguments to the linker
Dialogue: 0,1:17:12.28,1:17:15.54,csapp,,0,0,0,,and this - - wrap argument to the linker
Dialogue: 0,1:17:16.44,1:17:23.76,csapp,,0,0,0,,it tells the linker to resolve all references to Malik as underscore underscore wrap Malik 
Dialogue: 0,1:17:24.80,1:17:30.86,csapp,,0,0,0,,and all references to underscore real Malik - should be resolved as Malik 
Dialogue: 0,1:17:32.68,1:17:37.74,csapp,,0,0,0,,okay so anywhere in the program what we call Malik it'll be resolved to underscore underscore wrap Malik 
Dialogue: 0,1:17:38.24,1:17:41.92,csapp,,0,0,0,,and it will invoke our wrapper and then the wrapper calls real Malik
Dialogue: 0,1:17:42.54,1:17:50.70,csapp,,0,0,0,, which which by because of this flag resolves to the the actual Malik routine 
Dialogue: 0,1:17:53.16,1:17:55.98,csapp,,0,0,0,,now here you can also in the really the really amazing thing
Dialogue: 0,1:17:56.02,1:18:01.06,csapp,,0,0,0,, is you can also do this inter positioning it load timer and run time  when the program is loaded
Dialogue: 0,1:18:01.08,1:18:05.52,csapp,,0,0,0,, so you don't even need access to the dot o files all you need is access to the executable
Dialogue: 0,1:18:06.66,1:18:09.50,csapp,,0,0,0,, right and for every program we have access to the executable 
Dialogue: 0,1:18:10.17,1:18:12.40,csapp,,0,0,0,,so think about that we can take any program
Dialogue: 0,1:18:13.08,1:18:17.24,csapp,,0,0,0,,and we can interpose on its library calls at runtime 
Dialogue: 0,1:18:18.58,1:18:26.15,csapp,,0,0,0,,so the way we do this is we write the wrapper function now uses the dlsym call that we saw before
Dialogue: 0,1:18:27.62,1:18:32.10,csapp,,0,0,0,,and we call it with this special function the special argument called next 
Dialogue: 0,1:18:33.70,1:18:39.08,csapp,,0,0,0,,and we silver and what this is saying is get the address of the real malloc
Dialogue: 0,1:18:40.26,1:18:43.98,csapp,,0,0,0,, okay so and we're going to we're going to trick the linker into looking first
Dialogue: 0,1:18:44.70,1:18:47.90,csapp,,0,0,0,, to our our implementation of malloc
Dialogue: 0,1:18:48.60,1:18:55.00,csapp,,0,0,0,,but here we want the real one so we're telling it to get to look in the next place its next place that it would normally look 
Dialogue: 0,1:18:55.78,1:18:59.52,csapp,,0,0,0,, and and and fetch the the address of malloc
Dialogue: 0,1:18:59.52,1:19:04.02,csapp,,0,0,0,, so the result is a pointer a function pointer called mallocp
Dialogue: 0,1:19:04.64,1:19:09.58,csapp,,0,0,0,, and then we can just call that function to get to call the Lipsy Malik
Dialogue: 0,1:19:09.92,1:19:12.28,csapp,,0,0,0,,and then print out the the data 
Dialogue: 0,1:19:12.94,1:19:19.50,csapp,,0,0,0,,okay we do the same thing for free.st. we use dlsym in exactly the same way for free 
Dialogue: 0,1:19:20.68,1:19:25.22,csapp,,0,0,0,,and then the inter positioning now happens when the program is loaded
Dialogue: 0,1:19:26.56,1:19:31.92,csapp,,0,0,0,, so notice we built this our main program now in tar for run time inter positioning 
Dialogue: 0,1:19:32.82,1:19:40.28,csapp,,0,0,0,, we built it I'm sorry we created our .so file mymalloc.so  using the shared argument
Dialogue: 0,1:19:41.56,1:19:43.92,csapp,,0,0,0,,and then and then we we compiled int 
Dialogue: 0,1:19:44.82,1:19:48.24,csapp,,0,0,0,,int.c into this executable called intr
Dialogue: 0,1:19:48.24,1:19:51.66,csapp,,0,0,0,, but notice there's no mention of mymalloc.so anywhere 
Dialogue: 0,1:19:54.42,1:19:57.76,csapp,,0,0,0,,and now the inner positioning happens when we actually run the program
Dialogue: 0,1:19:58.68,1:20:13.06,csapp,,0,0,0,, and we do it we we affect the the inner positioning by setting an environment variable  called LD-preload  to mymalloc.so 
Dialogue: 0,1:20:13.42,1:20:17.82,csapp,,0,0,0,,and so what this is a environment variable that tells the dynamic linker
Dialogue: 0,1:20:18.60,1:20:26.20,csapp,,0,0,0,, to look first in the the value it looked first in the the value of LD preload is a list of locations
Dialogue: 0,1:20:26.62,1:20:29.64,csapp,,0,0,0,, look first in those locations when to resolve references
Dialogue: 0,1:20:29.98,1:20:33.90,csapp,,0,0,0,, and only only later look in the normal system places
Dialogue: 0,1:20:34.86,1:20:38.95,csapp,,0,0,0,,so we're saying to look in mymalloc.so unresolved references first 
Dialogue: 0,1:20:39.46,1:20:44.44,csapp,,0,0,0,,and then and then we're invoking so this is in bash this is how you initialize an environment variable 
Dialogue: 0,1:20:44.68,1:20:50.54,csapp,,0,0,0,,so we're initializing it to mymalloc.so and then we're loading and running the program 
Dialogue: 0,1:20:51.86,1:21:00.08,csapp,,0,0,0,,and so the LD so all the references to malloc get turned into the references to the wrapper function
Dialogue: 0,1:21:01.34,1:21:05.34,csapp,,0,0,0,,the malloc function that we defined in in our program okay 
Dialogue: 0,1:21:07.74,1:21:12.46,csapp,,0,0,0,,so that's uh so that's it so that that inter positioning is a really cool technique 
Dialogue: 0,1:21:12.60,1:21:15.86,csapp,,0,0,0,,and it's only it's only possible because of linkers so
Dialogue: 0,1:21:17.46,1:21:23.86,csapp,,0,0,0,,alright so good we'll see you on on Thursday and good luck with your cache labs
