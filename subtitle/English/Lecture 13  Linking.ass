[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video File: ../../../../Desktop/csapp/Lecture 13  Linking.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 7
Active Line: 16
Video Position: 3106

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.34,English,,0,0,0,,Welcome good to see you
Dialogue: 0,0:00:04.60,0:00:09.52,English,,0,0,0,,Today we're going to begin a transitioning from
Dialogue: 0,0:00:10.28,0:00:17.04,English,,0,0,0,,How a programs interact with hardware to how they interact with software in particular system software
Dialogue: 0,0:00:17.70,0:00:23.38,English,,0,0,0,,And we're going to start that investigation by studying and learning about a process called linking
Dialogue: 0,0:00:25.12,0:00:30.98,English,,0,0,0,,Which is how the system builds your programs ok
Dialogue: 0,0:00:33.26,0:00:35.92,English,,0,0,0,,So we're going to study the process of linking
Dialogue: 0,0:00:35.92,0:00:40.86,English,,0,0,0,,And then I'm going to show you a really cool technique called library inter positioning
Dialogue: 0,0:00:42.16,0:00:51.08,English,,0,0,0,,Which allows you to use linking to actually intercept on function calls in libraries like the standard C library
Dialogue: 0,0:00:51.66,0:00:56.38,English,,0,0,0,,So it's a very powerful and interesting technique and it's all enabled by by linking
Dialogue: 0,0:00:58.28,0:01:01.36,English,,0,0,0,,So let's start with a simple program
Dialogue: 0,0:01:02.54,0:01:07.84,English,,0,0,0,,This program consists of two modules a main.c and sum.c
Dialogue: 0,0:01:09.06,0:01:14.90,English,,0,0,0,,sum.c takes as an array as an argument and a length n
Dialogue: 0,0:01:15.54,0:01:21.60,English,,0,0,0,,And then it sums up the elements of that array and returns the sum  back to the caller
Dialogue: 0,0:01:23.48,0:01:26.21,English,,0,0,0,,main.c calls the sum function
Dialogue: 0,0:01:26.76,0:01:29.54,English,,0,0,0,,Using and passes it a two element array of ints
Dialogue: 0,0:01:31.20,0:01:35.78,English,,0,0,0,,And then returns the value received from some
Dialogue: 0,0:01:37.74,0:01:43.54,English,,0,0,0,,Yeah we that that's kind of an odd thing to do to return your your exit status like that
Dialogue: 0,0:01:43.54,0:01:47.76,English,,0,0,0,,But we just did it so that the compiler wouldn't optimize away all of our code
Dialogue: 0,0:01:49.22,0:01:52.94,English,,0,0,0,,I know let's look at what happens if when we want to compile those those two modules
Dialogue: 0,0:01:55.44,0:01:58.74,English,,0,0,0,,For each of main.c and sum.c
Dialogue: 0,0:01:59.52,0:02:08.66,English,,0,0,0,,The GCC calls a series of translators on that on those modules on those .c files
Dialogue: 0,0:02:09.38,0:02:11.68,English,,0,0,0,,First calls the C preprocessor cpp
Dialogue: 0,0:02:14.30,0:02:18.82,English,,0,0,0,,Then it calls the the compiler the actual compiler which is cc1
Dialogue: 0,0:02:20.90,0:02:26.96,English,,0,0,0,,The compiler generates assembly which is then translated by the assembler as
Dialogue: 0,0:02:27.72,0:02:32.60,English,,0,0,0,,And resulting in a .o file called main.o
Dialogue: 0,0:02:33.26,0:02:36.24,English,,0,0,0,,Similar things happens first for sum.c
Dialogue: 0,0:02:37.34,0:02:43.88,English,,0,0,0,,So after after the after these three translators work on the code
Dialogue: 0,0:02:44.36,0:02:47.14,English,,0,0,0,,We have two object files two .o files
Dialogue: 0,0:02:48.86,0:02:51.54,English,,0,0,0,,The linker takes those those .o files
Dialogue: 0,0:02:52.18,0:02:57.18,English,,0,0,0,,And put some links them together
Dialogue: 0,0:02:57.30,0:03:03.02,English,,0,0,0,,Sort of smashes them together to form a single executable called that
Dialogue: 0,0:03:03.36,0:03:09.24,English,,0,0,0,,We can then run then we can then load and run on the system
Dialogue: 0,0:03:11.36,0:03:15.42,English,,0,0,0,,So the main.c and sum.c they are called source files
Dialogue: 0,0:03:15.94,0:03:19.90,English,,0,0,0,,These .o files are our object files that
Dialogue: 0,0:03:20.60,0:03:22.28,English,,0,0,0,,We are separately compiled
Dialogue: 0,0:03:23.18,0:03:27.50,English,,0,0,0,,But and we call them relocatable object files because they can be combined together
Dialogue: 0,0:03:28.12,0:03:33.32,English,,0,0,0,,To form the fully linked executable object file
Dialogue: 0,0:03:36.06,0:03:42.56,English,,0,0,0,,So why do we do it like this you know why why do we allow this so-called separate compilation
Dialogue: 0,0:03:42.62,0:03:48.50,English,,0,0,0,,You know why don't we just have like one big you know one big file that with all of our code in it
Dialogue: 0,0:03:49.02,0:03:55.57,English,,0,0,0,,Well there's a couple reasons the first is is modularity so by by allowing you to break your code into smaller pieces
Dialogue: 0,0:03:55.96,0:03:58.96,English,,0,0,0,,You can put related functions into separate source files
Dialogue: 0,0:03:59.30,0:04:01.58,English,,0,0,0,,You can define libraries of functions
Dialogue: 0,0:04:02.74,0:04:11.60,English,,0,0,0,,So it's just it's just good technique and it allows you to kind of break your code up into nice to nice modular pieces
Dialogue: 0,0:04:13.54,0:04:15.10,English,,0,0,0,,The other reason is efficiency
Dialogue: 0,0:04:18.68,0:04:21.92,English,,0,0,0,,So if if we if we've broken up our program into multiple chunks
Dialogue: 0,0:04:22.66,0:04:28.54,English,,0,0,0,,If we change and if we if we only need to change one of the chunks
Dialogue: 0,0:04:29.26,0:04:33.06,English,,0,0,0,,We don't have to recompile the all the other all the other modules
Dialogue: 0,0:04:33.28,0:04:38.50,English,,0,0,0,,Right we can just recompile the one module that we changed and then link them all together again
Dialogue: 0,0:04:38.58,0:04:44.26,English,,0,0,0,,Right so it's it's efficient in time it's also efficient in space
Dialogue: 0,0:04:44.26,0:04:51.64,English,,0,0,0,,Because you can take all of say all of the functions in the standard C library you could put them all together
Dialogue: 0,0:04:52.14,0:04:57.86,English,,0,0,0,,But then the only functions that you actually get compiled and linked into your program are the ones that you actually call
Dialogue: 0,0:04:58.68,0:05:01.62,English,,0,0,0,,Ok so you can you can save space
Dialogue: 0,0:05:01.62,0:05:08.14,English,,0,0,0,,You don't you know normally you use only a small subset of the standard C functions and
Dialogue: 0,0:05:08.80,0:05:13.16,English,,0,0,0,,So you there's no there's no point in linking all of those functions into your code if you don't need them
Dialogue: 0,0:05:15.08,0:05:16.66,English,,0,0,0,,Alright so what do linkers do
Dialogue: 0,0:05:18.02,0:05:21.78,English,,0,0,0,,Well there's two main there's two main tasks that a linker performs
Dialogue: 0,0:05:23.28,0:05:25.82,English,,0,0,0,,The first is called simple resolution
Dialogue: 0,0:05:27.16,0:05:30.16,English,,0,0,0,,So programs define and reference symbols
Dialogue: 0,0:05:30.44,0:05:37.10,English,,0,0,0,,Okay that what the linker refers to as symbols and these are global variables and functions
Dialogue: 0,0:05:37.62,0:05:44.40,English,,0,0,0,,Okay in the names and those those objects they're referred to as a symbol
Dialogue: 0,0:05:44.46,0:05:52.28,English,,0,0,0,,So here we're declaring we're defining a symbol called swap
Dialogue: 0,0:05:53.66,0:05:59.42,English,,0,0,0,,Here we're referring when we call swap we're referring to that symbol
Dialogue: 0,0:05:59.44,0:06:01.30,English,,0,0,0,,Okay that's a reference to the symbol
Dialogue: 0,0:06:03.30,0:06:07.20,English,,0,0,0,,And here we're defining a pointer to an int called xp
Dialogue: 0,0:06:08.30,0:06:13.02,English,,0,0,0,,So we're defining xp and we're initializing it to the address of x
Dialogue: 0,0:06:13.02,0:06:15.52,English,,0,0,0,,So we're referring that's a reference to x
Dialogue: 0,0:06:18.00,0:06:24.24,English,,0,0,0,,Okay so the symbol definitions are stored in the object file by the assembler
Dialogue: 0,0:06:25.32,0:06:28.52,English,,0,0,0,,In a symbol table which is an array of structs
Dialogue: 0,0:06:29.12,0:06:32.19,English,,0,0,0,,Where each truck contains information about the symbol
Dialogue: 0,0:06:32.58,0:06:37.54,English,,0,0,0,,Like the name of the symbol its size and where it's located
Dialogue: 0,0:06:40.54,0:06:46.78,English,,0,0,0,,Now what we mean by symbol resolution is that during the linker plinking process
Dialogue: 0,0:06:47.58,0:06:54.94,English,,0,0,0,,The linker associates each symbol reference with exactly one symbol definition
Dialogue: 0,0:06:57.68,0:06:59.42,English,,0,0,0,,Okay so it's possible in multiple
Dialogue: 0,0:07:00.64,0:07:04.16,English,,0,0,0,,You know why is this an issue well it's possible like in multiple modules
Dialogue: 0,0:07:04.16,0:07:06.84,English,,0,0,0,,You may declare a global variable with the same name
Dialogue: 0,0:07:07.80,0:07:13.76,English,,0,0,0,,The linker has to decide which one of those definitions  to use for all subsequent references
Dialogue: 0,0:07:16.70,0:07:21.74,English,,0,0,0,,Now once once the linker is associated a unique object
Dialogue: 0,0:07:21.74,0:07:25.44,English,,0,0,0,,With each a unique symbol definition with each reference
Dialogue: 0,0:07:26.84,0:07:29.22,English,,0,0,0,,Then it does the second step which is relocation
Dialogue: 0,0:07:29.78,0:07:33.32,English,,0,0,0,,And during relocation it merges all of the modules together
Dialogue: 0,0:07:33.70,0:07:41.18,English,,0,0,0,,Into a single into a single executable object  module that can be directly loaded
Dialogue: 0,0:07:41.40,0:07:42.98,English,,0,0,0,,And executed on the system
Dialogue: 0,0:07:43.98,0:07:47.34,English,,0,0,0,,So when it when it when it does this merging
Dialogue: 0,0:07:50.16,0:07:57.04,English,,0,0,0,,It has to it has to figure out where each each symbol each function and each variable is going to be stored
Dialogue: 0,0:07:57.92,0:07:59.16,English,,0,0,0,,Okay and this is called relocation
Dialogue: 0,0:07:59.16,0:08:06.78,English,,0,0,0,,Because initially functions are just stored at some offset in their in their object module
Dialogue: 0,0:08:07.36,0:08:13.26,English,,0,0,0,,Right because that the linker doesn't know where those functions are actually going to be eventually a loaded into memory
Dialogue: 0,0:08:14.04,0:08:26.08,English,,0,0,0,,So before before relocation the address of a function in the object module is just its offset  in the in the module  and similarly for data
Dialogue: 0,0:08:26.62,0:08:31.38,English,,0,0,0,,During the relocation step the the linker decides on
Dialogue: 0,0:08:31.56,0:08:38.76,English,,0,0,0,,Where each symbol is going to be ultimately located in memory one at x when the program executes
Dialogue: 0,0:08:39.54,0:08:45.48,English,,0,0,0,,And it binds that that those absolute memory locations to the to the symbol
Dialogue: 0,0:08:45.98,0:08:49.74,English,,0,0,0,,And then and then it goes and looks at all the references to those symbols
Dialogue: 0,0:08:50.46,0:08:54.74,English,,0,0,0,,And it updates those references so that they now they point to the correct address
Dialogue: 0,0:08:55.54,0:08:57.72,English,,0,0,0,,Okay so figure out where stuff is going to go
Dialogue: 0,0:08:58.88,0:09:03.78,English,,0,0,0,,For each definition figure out where it's going to go and for each reference then update that reference
Dialogue: 0,0:09:03.78,0:09:06.14,English,,0,0,0,,So it now points to the right spot
Dialogue: 0,0:09:09.90,0:09:14.54,English,,0,0,0,,So let's look at what what these how these steps work in more detail
Dialogue: 0,0:09:14.92,0:09:18.22,English,,0,0,0,,Before that we need to we need to define a few things
Dialogue: 0,0:09:19.80,0:09:23.34,English,,0,0,0,,So there's there's three kinds of object modules that I've alluded to
Dialogue: 0,0:09:24.18,0:09:29.72,English,,0,0,0,,There's the dot o file which is a relocatable object module this is the output of the assembler
Dialogue: 0,0:09:30.50,0:09:32.42,English,,0,0,0,,Okay and it's it's not it's a
Dialogue: 0,0:09:32.42,0:09:35.36,English,,0,0,0,,Binary file but it's it's not in any
Dialogue: 0,0:09:35.36,0:09:38.87,English,,0,0,0,,Form that can be directly loaded into
Dialogue: 0,0:09:38.87,0:09:41.63,English,,0,0,0,,Memory it needs to be manipulated by the
Dialogue: 0,0:09:41.63,0:09:43.78,English,,0,0,0,,Linker before it can be actually used
Dialogue: 0,0:09:43.78,0:09:46.67,English,,0,0,0,,There's the executable object file which
Dialogue: 0,0:09:46.67,0:09:50.42,English,,0,0,0,,Is generated by the linker these are
Dialogue: 0,0:09:50.42,0:09:52.78,English,,0,0,0,,Called a dot out files sometimes
Dialogue: 0,0:09:52.78,0:09:54.80,English,,0,0,0,,Historically the very first Linux
Dialogue: 0,0:09:54.80,0:09:57.68,English,,0,0,0,,Systems the executable this sort of the
Dialogue: 0,0:09:57.68,0:10:00.11,English,,0,0,0,,Default name that they the developers of
Dialogue: 0,0:10:00.11,0:10:02.87,English,,0,0,0,,Unix used the default name for their
Dialogue: 0,0:10:02.87,0:10:06.23,English,,0,0,0,,Executables was a dot out so that's just
Dialogue: 0,0:10:06.23,0:10:08.84,English,,0,0,0,,Sort of a historical reason that it's
Dialogue: 0,0:10:08.84,0:10:11.12,English,,0,0,0,,It's it's called a dot out and then
Dialogue: 0,0:10:11.12,0:10:13.73,English,,0,0,0,,There's another type of object file
Dialogue: 0,0:10:13.73,0:10:16.10,English,,0,0,0,,Called a shared object file or dot iso
Dialogue: 0,0:10:16.10,0:10:21.47,English,,0,0,0,,File which is a sort of modern a modern
Dialogue: 0,0:10:21.47,0:10:24.41,English,,0,0,0,,Technique for creating shared libraries
Dialogue: 0,0:10:24.41,0:10:26.66,English,,0,0,0,,And we'll look at those we'll look at
Dialogue: 0,0:10:26.66,0:10:28.33,English,,0,0,0,,Those later today
Dialogue: 0,0:10:29.14,0:10:34.50,English,,0,0,0,,Now object modules come in a standard format called elf format
Dialogue: 0,0:10:35.92,0:10:41.12,English,,0,0,0,,And it's it's a unified format for .o files for executables and for .so files
Dialogue: 0,0:10:41.12,0:10:45.34,English,,0,0,0,,They all use the same format the same general format
Dialogue: 0,0:10:48.26,0:10:52.68,English,,0,0,0,,So this while these these elf binaries are
Dialogue: 0,0:10:53.48,0:10:55.58,English,,0,0,0,,Their binaries they're very structured
Dialogue: 0,0:10:56.02,0:10:58.14,English,,0,0,0,,Ok and they're broken up into sections
Dialogue: 0,0:10:58.94,0:11:02.86,English,,0,0,0,,The at the beginning is the is a header
Dialogue: 0,0:11:03.50,0:11:08.02,English,,0,0,0,,That defines things like the size of the word the byte ordering
Dialogue: 0,0:11:08.46,0:11:12.46,English,,0,0,0,,Whether it's a .o n a .out or a .so
Dialogue: 0,0:11:12.90,0:11:19.12,English,,0,0,0,,So it just provides some sort of general information about this about this binary
Dialogue: 0,0:11:19.76,0:11:22.56,English,,0,0,0,,And then there's what's a so called segment header table which
Dialogue: 0,0:11:23.28,0:11:28.16,English,,0,0,0,,Is it only it's only defined for the executable object files
Dialogue: 0,0:11:28.50,0:11:32.40,English,,0,0,0,,And it indicates where all the different segments of the code
Dialogue: 0,0:11:32.82,0:11:38.87,English,,0,0,0,,Are going to go in in memory so where does your stack go where do your shared libraries go
Dialogue: 0,0:11:38.87,0:11:42.96,English,,0,0,0,,Where does your that you're initialized and uninitialized data
Dialogue: 0,0:11:43.74,0:11:51.62,English,,0,0,0,,Where does your code go right so all these all these various sections are defined in the segment header table
Dialogue: 0,0:11:52.60,0:11:59.60,English,,0,0,0,,And then there's the code itself which is is called the dot text section for sort of arcane historical reasons
Dialogue: 0,0:11:59.78,0:12:02.16,English,,0,0,0,,So dot text is always code
Dialogue: 0,0:12:03.96,0:12:08.26,English,,0,0,0,,And then that's followed by read-only data
Dialogue: 0,0:12:08.42,0:12:11.14,English,,0,0,0,,Such as the jump tables in switch statements
Dialogue: 0,0:12:12.52,0:12:17.82,English,,0,0,0,,So text and read only the dot text and dot ro data have the property that they're
Dialogue: 0,0:12:18.08,0:12:20.02,English,,0,0,0,,They're both read-only you don't write to them
Dialogue: 0,0:12:21.90,0:12:24.78,English,,0,0,0,,Then that's followed by the data section
Dialogue: 0,0:12:24.96,0:12:29.98,English,,0,0,0,,Which is contains space for all of your initialized global variables
Dialogue: 0,0:12:31.06,0:12:33.44,English,,0,0,0,,And then there's a section called bss
Dialogue: 0,0:12:33.56,0:12:41.36,English,,0,0,0,,Which contain which defines the uninitialized global variables
Dialogue: 0,0:12:42.78,0:12:46.82,English,,0,0,0,,Now this doesn't actually take up any space because they're uninitialized droids
Dialogue: 0,0:12:48.10,0:12:50.76,English,,0,0,0,,Ok but there there are entries in the symbol table for them
Dialogue: 0,0:12:51.34,0:12:57.30,English,,0,0,0,,And in it at when this program gets loaded these variables are going to need
Dialogue: 0,0:12:58.54,0:13:00.86,English,,0,0,0,,They're actually going to have to have space allocated for them
Dialogue: 0,0:13:01.70,0:13:08.26,English,,0,0,0,,Bss is another one of those sort of arcane names that cope goes all the way back to the 60s
Dialogue: 0,0:13:08.78,0:13:11.94,English,,0,0,0,,For there was an idea of instruction called the block started by symbol
Dialogue: 0,0:13:12.42,0:13:16.22,English,,0,0,0,,I think a better way to remember what it means is better safe space
Dialogue: 0,0:13:16.66,0:13:21.66,English,,0,0,0,,Ok so you can if you have a separate section for the uninitialized variable since uninitialized
Dialogue: 0,0:13:22.16,0:13:29.46,English,,0,0,0,,You don't have to you know they don't have to consume any room in the in the .o file
Dialogue: 0,0:13:32.78,0:13:35.54,English,,0,0,0,,Ok there's also a section for the symbol table
Dialogue: 0,0:13:37.42,0:13:44.56,English,,0,0,0,,This contained like I said it's an array of structs for procedures global variables
Dialogue: 0,0:13:47.72,0:13:50.80,English,,0,0,0,,And anything defined with the static attribute
Dialogue: 0,0:13:53.02,0:13:57.68,English,,0,0,0,,And each one of these each one of these symbols gets an entry in the symbol table
Dialogue: 0,0:13:59.18,0:14:04.56,English,,0,0,0,,And then there's two two sections called them that contain relocation info so this is the notes
Dialogue: 0,0:14:06.62,0:14:08.70,English,,0,0,0,,When that when the linker went and identified
Dialogue: 0,0:14:09.06,0:14:13.82,English,,0,0,0,,All the references to symbols it put a little note to say I'm going to have to remember to fix this
Dialogue: 0,0:14:14.66,0:14:21.16,English,,0,0,0,,The reference to this symbol up when I when I actually create the the executable
Dialogue: 0,0:14:21.84,0:14:25.26,English,,0,0,0,,So a relocation entry is just like a note that the linker or
Dialogue: 0,0:14:25.80,0:14:31.74,English,,0,0,0,,That it's a note that the assembler makes to the linker to say hey you're going to have to fix up this this reference
Dialogue: 0,0:14:31.74,0:14:38.16,English,,0,0,0,,Because I don't know I don't know where this symbol is actually going to be stored in memory when it's when it's loaded
Dialogue: 0,0:14:41.56,0:14:43.72,English,,0,0,0,,Okay and then there's a debug section  that contains
Dialogue: 0,0:14:45.32,0:14:54.22,English,,0,0,0,,Information that relates line numbers to in the source code to line numbers in the machine code
Dialogue: 0,0:14:55.10,0:14:59.40,English,,0,0,0,,Okay and so this is called debug and this is what you get when you compile with dash g
Dialogue: 0,0:14:59.98,0:15:06.04,English,,0,0,0,,And then there's a header table that that tells you where all these different sections start
Dialogue: 0,0:15:08.20,0:15:11.34,English,,0,0,0,,Now to a linker there's there's three different kinds of symbols
Dialogue: 0,0:15:12.58,0:15:17.00,English,,0,0,0,,Global symbols are defined in some module m
Dialogue: 0,0:15:17.50,0:15:20.82,English,,0,0,0,,And they can and they can be used by other modules
Dialogue: 0,0:15:21.08,0:15:27.14,English,,0,0,0,,Right so I mean did you notice when we if we have a program that consists of multiple modules
Dialogue: 0,0:15:27.56,0:15:30.66,English,,0,0,0,,And we compile each one of those modules into a dot o file
Dialogue: 0,0:15:32.18,0:15:37.42,English,,0,0,0,,Will be calling functions that aren't defined that are defined by other modules right
Dialogue: 0,0:15:38.94,0:15:44.64,English,,0,0,0,,Okay so those but there's no error though that the compiler doesn't doesn't throw an error
Dialogue: 0,0:15:44.64,0:15:48.44,English,,0,0,0,,Because it's assuming that those are defined in other modules and
Dialogue: 0,0:15:49.10,0:15:53.32,English,,0,0,0,,It assumes the linker will be able to find them in and determine the address
Dialogue: 0,0:15:54.40,0:15:59.18,English,,0,0,0,,So anything that's defined with that any global either
Dialogue: 0,0:15:59.98,0:16:04.06,English,,0,0,0,,Either global variable or function name
Dialogue: 0,0:16:04.46,0:16:08.82,English,,0,0,0,,That's defined without the static attribute is a is a global symbol
Dialogue: 0,0:16:10.92,0:16:14.92,English,,0,0,0,,Okay now and then external symbols are kind of the flip side of that
Dialogue: 0,0:16:15.08,0:16:19.12,English,,0,0,0,,External symbols are symbols that are referenced by some module
Dialogue: 0,0:16:19.44,0:16:21.54,English,,0,0,0,,But defined in some other module
Dialogue: 0,0:16:21.78,0:16:28.54,English,,0,0,0,,Okay so in our in our in our little running example when when main .c code
Dialogue: 0,0:16:29.00,0:16:32.66,English,,0,0,0,,Called the function some it was referencing an external symbol
Dialogue: 0,0:16:34.20,0:16:42.58,English,,0,0,0,,Okay and then there's there's local symbols and these are symbols that are defined and referenced within a module
Dialogue: 0,0:16:43.48,0:16:48.12,English,,0,0,0,,Okay and those you create that this is not this is different from local variables
Dialogue: 0,0:16:48.12,0:16:56.52,English,,0,0,0,,Okay the linker you know local see variables are managed by the compiler on the stack
Dialogue: 0,0:16:57.08,0:17:01.38,English,,0,0,0,,Linker has no idea about local local see variables
Dialogue: 0,0:17:01.90,0:17:04.32,English,,0,0,0,,Okay in this context when we talk about a local symbol
Dialogue: 0,0:17:04.92,0:17:10.32,English,,0,0,0,,What we're talking about is is either is a global a global variable
Dialogue: 0,0:17:10.50,0:17:13.58,English,,0,0,0,,Or function declared with the static attribute
Dialogue: 0,0:17:14.94,0:17:17.26,English,,0,0,0,,Whose that can only be referenced from within that module
Dialogue: 0,0:17:17.26,0:17:24.02,English,,0,0,0,,So we say that the scope the scope of the a function or global variable defined with the static
Dialogue: 0,0:17:24.52,0:17:27.86,English,,0,0,0,,Attribute is limited to the module that it was defined in
Dialogue: 0,0:17:30.06,0:17:33.78,English,,0,0,0,,Okay so this is in C this is how we do abstraction
Dialogue: 0,0:17:34.90,0:17:38.24,English,,0,0,0,,And this is how we can create sort of private functions that
Dialogue: 0,0:17:39.36,0:17:44.38,English,,0,0,0,,And pup private functions that can't be called from from outside that module
Dialogue: 0,0:17:45.82,0:17:49.44,English,,0,0,0,,Okay so for instance if we want to make a library and see
Dialogue: 0,0:17:50.10,0:17:53.16,English,,0,0,0,,Of functions we want to make a collection of functions that
Dialogue: 0,0:17:53.61,0:17:57.94,English,,0,0,0,,Other programs can then call it link into their program and call
Dialogue: 0,0:17:58.86,0:18:07.52,English,,0,0,0,,The functions that we want to make visible to to other programs are defined without the static attribute
Dialogue: 0,0:18:08.38,0:18:12.10,English,,0,0,0,,And the functions that we want to have private and just be internal
Dialogue: 0,0:18:12.76,0:18:15.36,English,,0,0,0,,We declare what the static attribute okay
Dialogue: 0,0:18:16.00,0:18:20.50,English,,0,0,0,,And that way we get abstraction and we get hiding information hiding
Dialogue: 0,0:18:20.98,0:18:26.86,English,,0,0,0,,And we're only exposing data and functions that that we want that we want to expose
Dialogue: 0,0:18:29.60,0:18:33.36,English,,0,0,0,,All right so let's look in detail how the symbol resolution step works
Dialogue: 0,0:18:34.02,0:18:38.36,English,,0,0,0,,We recall our example our example program
Dialogue: 0,0:18:41.26,0:18:44.40,English,,0,0,0,,So here we're referencing a global called array
Dialogue: 0,0:18:45.94,0:18:50.26,English,,0,0,0,,That's defined within main.c
Dialogue: 0,0:18:54.20,0:18:56.60,English,,0,0,0,,Here when we here we're defining main
Dialogue: 0,0:18:57.78,0:18:59.36,English,,0,0,0,,A global called main
Dialogue: 0,0:19:04.28,0:19:06.46,English,,0,0,0,,Here we're referencing a global called sum
Dialogue: 0,0:19:06.78,0:19:08.90,English,,0,0,0,,That's defined in sum.c
Dialogue: 0,0:19:11.10,0:19:17.34,English,,0,0,0,,And val is a local C variable on the stack and linker knows nothing about that okay
Dialogue: 0,0:19:20.00,0:19:23.58,English,,0,0,0,,Now an or doesn't know anything about irs which are also local variables
Dialogue: 0,0:19:25.76,0:19:30.56,English,,0,0,0,,Now let's just let's make sure that we understand the difference
Dialogue: 0,0:19:30.58,0:19:36.88,English,,0,0,0,,Between local static C variables versus local non static C variables so
Dialogue: 0,0:19:39.74,0:19:44.12,English,,0,0,0,,Here we're defining a local static variable called int
Dialogue: 0,0:19:45.16,0:19:46.84,English,,0,0,0,,Within this function f
Dialogue: 0,0:19:48.46,0:19:53.40,English,,0,0,0,,Now because it's local its scope is limited to this function
Dialogue: 0,0:19:53.40,0:19:58.88,English,,0,0,0,,So this variable x can only be referenced within function f
Dialogue: 0,0:20:01.06,0:20:07.10,English,,0,0,0,,And similarly for this definition of x and function g
Dialogue: 0,0:20:07.98,0:20:11.08,English,,0,0,0,,Can only be referenced by by function g
Dialogue: 0,0:20:11.58,0:20:17.08,English,,0,0,0,,Now what's but because it's declared with the static attribute it's not stored on the stack
Dialogue: 0,0:20:17.78,0:20:22.18,English,,0,0,0,,It's actually stored in in the in dot data just like a global would be
Dialogue: 0,0:20:22.36,0:20:29.20,English,,0,0,0,,So it's it's like a global in the sense that it's actually stored in dot data rather than the stack
Dialogue: 0,0:20:29.86,0:20:35.48,English,,0,0,0,,But it's like a local see variable in the sense that its scope is limited just to the function that it's defined in
Dialogue: 0,0:20:36.48,0:20:43.48,English,,0,0,0,,Okay so what what the compiler will do it'll allocate space for each definition of x
Dialogue: 0,0:20:43.50,0:20:49.58,English,,0,0,0,,So this and it'll give it some name to disambiguate it so maybe it will call this one x dot one
Dialogue: 0,0:20:49.98,0:20:51.82,English,,0,0,0,,And maybe this one x dot two
Dialogue: 0,0:20:52.80,0:20:57.54,English,,0,0,0,,So these symbols are allocated in dot data because
Dialogue: 0,0:20:57.94,0:21:04.18,English,,0,0,0,,Because they're initialized and they get symbol table entries just like just like any other symbol
Dialogue: 0,0:21:08.00,0:21:11.16,English,,0,0,0,,Okay so I said that during symbol resolution
Dialogue: 0,0:21:11.56,0:21:20.32,English,,0,0,0,,The linker associates each reference each symbol reference to exactly one unique symbol definition
Dialogue: 0,0:21:21.58,0:21:25.72,English,,0,0,0,,Now how does it do that if there's multiple symbol definitions across all the modules
Dialogue: 0,0:21:27.64,0:21:35.32,English,,0,0,0,,So to understand this well will will will define symbols as being either strong or weak
Dialogue: 0,0:21:35.78,0:21:43.86,English,,0,0,0,,So strong symbols are either procedures or function function names or initialize global variables
Dialogue: 0,0:21:44.66,0:21:47.22,English,,0,0,0,,Weak symbols or uninitialized global variables
Dialogue: 0,0:21:49.18,0:21:54.62,English,,0,0,0,,Okay so int foo here is a strong symbol
Dialogue: 0,0:21:54.62,0:21:59.70,English,,0,0,0,,Because it's initialized we're initializing it p1 is strong by definition
Dialogue: 0,0:22:00.74,0:22:08.44,English,,0,0,0,,Foo is is weak in p2.c this this definition of foo is weak
Dialogue: 0,0:22:09.06,0:22:12.78,English,,0,0,0,,Because it's uninitialized and the definition of p2 is strong
Dialogue: 0,0:22:13.64,0:22:17.74,English,,0,0,0,,Okay so that the rules that the the linker uses are the following
Dialogue: 0,0:22:19.34,0:22:22.34,English,,0,0,0,,Multiple strong symbols not allowed so that's an error
Dialogue: 0,0:22:24.14,0:22:30.34,English,,0,0,0,,Okay so that means that if we if across multiple modules we declare a function with the same name
Dialogue: 0,0:22:30.54,0:22:32.72,English,,0,0,0,,The linker will throw an error that's not allowed
Dialogue: 0,0:22:34.44,0:22:42.72,English,,0,0,0,,Given a strong symbol and multiple weak symbols if the linker will always choose the the strong symbol
Dialogue: 0,0:22:44.00,0:22:47.28,English,,0,0,0,,Now remember if we initialize a global variable
Dialogue: 0,0:22:50.94,0:22:56.18,English,,0,0,0,,And we if we declare a an initialized global variable across multiple modules that's an error
Dialogue: 0,0:22:56.18,0:22:58.70,English,,0,0,0,,Because those are strong symbols okay by rule one
Dialogue: 0,0:22:59.02,0:23:03.90,English,,0,0,0,,But if we have one strong symbol and multiple weak symbols all with the same name
Dialogue: 0,0:23:04.52,0:23:06.92,English,,0,0,0,,Then the compiler will choose the strong symbol
Dialogue: 0,0:23:08.48,0:23:12.88,English,,0,0,0,,Okay and it will associate all references to that symbol will go to that strong symbol
Dialogue: 0,0:23:14.38,0:23:17.70,English,,0,0,0,,And if there's multiple weak symbols then it just picks an arbitrary one
Dialogue: 0,0:23:18.02,0:23:25.07,English,,0,0,0,,And this this is we'll see can be problematic now you can override with this GCC flag called no common
Dialogue: 0,0:23:25.74,0:23:29.94,English,,0,0,0,,And if you if you declare your function with this no common argument
Dialogue: 0,0:23:30.32,0:23:35.40,English,,0,0,0,,Then multiple weak symbols will throw an error in a linker
Dialogue: 0,0:23:36.46,0:23:39.24,English,,0,0,0,,All right so why do we care about all this stuff well it turns out
Dialogue: 0,0:23:39.80,0:23:44.10,English,,0,0,0,,If you're not aware of this stuff you can you can run into some really serious problems
Dialogue: 0,0:23:44.12,0:23:47.40,English,,0,0,0,,That are just perplexing and confounding right so
Dialogue: 0,0:23:47.90,0:23:50.68,English,,0,0,0,,Linker linker errors are like the worst kind
Dialogue: 0,0:23:51.10,0:23:55.78,English,,0,0,0,,They're the hardest kind of debug because people aren't usually aware of what's going on inside their linkers
Dialogue: 0,0:23:57.64,0:24:02.26,English,,0,0,0,,And usually it's only like the very best programmers that really understand
Dialogue: 0,0:24:03.36,0:24:07.78,English,,0,0,0,,You know how these linkers work and what kind of errors they can throw and how to debug them
Dialogue: 0,0:24:08.36,0:24:13.80,English,,0,0,0,,So let me show you some examples of of these these kind of errors
Dialogue: 0,0:24:15.58,0:24:19.34,English,,0,0,0,,All right so we have a program we've word we have two modules
Dialogue: 0,0:24:19.34,0:24:22.96,English,,0,0,0,,So each of these rectangles corresponds to a module
Dialogue: 0,0:24:23.84,0:24:26.58,English,,0,0,0,,And we're defining p1 in each module so
Dialogue: 0,0:24:28.54,0:24:31.28,English,,0,0,0,,That's too strong symbols that's an error
Dialogue: 0,0:24:34.38,0:24:39.62,English,,0,0,0,,Okay now here we've we're defining p1 and p2
Dialogue: 0,0:24:39.64,0:24:47.08,English,,0,0,0,,So we're okay but now we've got two week symbols both are integers variables called x
Dialogue: 0,0:24:48.92,0:24:53.62,English,,0,0,0,,So and if these modules are referencing x the linker will just pick
Dialogue: 0,0:24:54.36,0:24:58.12,English,,0,0,0,,It will just pick one of these to serve as the definition
Dialogue: 0,0:24:59.72,0:25:02.40,English,,0,0,0,,But is is this really what you want
Dialogue: 0,0:25:03.60,0:25:09.38,English,,0,0,0,,Now in this case it doesn't really hurt anything because x is declared in both modules as an int
Dialogue: 0,0:25:10.12,0:25:15.06,English,,0,0,0,,All right so it'll just be it'll just be some integer sized variable
Dialogue: 0,0:25:15.72,0:25:19.22,English,,0,0,0,,That and it'll be it'll be somewhere
Dialogue: 0,0:25:20.04,0:25:24.14,English,,0,0,0,,And but it doesn't really matter which which one the linker chooses
Dialogue: 0,0:25:25.52,0:25:31.14,English,,0,0,0,,But we start to get into trouble if if we declare these weak symbols  with different types
Dialogue: 0,0:25:34.02,0:25:40.26,English,,0,0,0,,So here we've declared an int x in one module and a double x in another module
Dialogue: 0,0:25:42.32,0:25:50.28,English,,0,0,0,,So if we write to x if the linker just arbitrarily chooses this  this symbol definition to use
Dialogue: 0,0:25:51.54,0:25:57.48,English,,0,0,0,,Now this is a symbol that of length 8 of size 8
Dialogue: 0,0:26:00.36,0:26:05.72,English,,0,0,0,,If we anywhere in this program if we if the linker chooses that then anywhere in the program
Dialogue: 0,0:26:06.30,0:26:14.70,English,,0,0,0,,Those references to those references to x will be to this double word  this double word
Dialogue: 0,0:26:16.38,0:26:21.08,English,,0,0,0,,Even even in this module if we reference x it'll be an 8-byte right
Dialogue: 0,0:26:21.10,0:26:25.06,English,,0,0,0,,So it will overwrite y with the
Dialogue: 0,0:26:29.16,0:26:38.80,English,,0,0,0,,Hi order excuse me
Dialogue: 0,0:26:38.84,0:26:43.20,English,,0,0,0,,Oh no it's completely it's just committal just pick one
Dialogue: 0,0:26:43.72,0:26:48.48,English,,0,0,0,,Arbitrarily and you don't know I mean it
Dialogue: 0,0:26:53.44,0:26:59.30,English,,0,0,0,,Alright here's now this is here's a problem we've defined a strong symbol x
Dialogue: 0,0:26:59.82,0:27:02.98,English,,0,0,0,,Because we've initializes so the linker will always
Dialogue: 0,0:27:04.84,0:27:13.58,English,,0,0,0,,Will associate all references to x to this integer sized this integer sized symbol
Dialogue: 0,0:27:16.70,0:27:30.32,English,,0,0,0,,So if we write
Dialogue: 0,0:27:30.52,0:27:34.14,English,,0,0,0,,Oh yeah right so so rights to x here
Dialogue: 0,0:27:36.14,0:27:40.68,English,,0,0,0,,This will be a double in this module but it will overwrite y in this module
Dialogue: 0,0:27:40.94,0:27:48.36,English,,0,0,0,,So that's really nasty
Dialogue: 0,0:27:48.76,0:27:51.60,English,,0,0,0,,And here we were defining a strong symbol x
Dialogue: 0,0:27:52.40,0:28:00.90,English,,0,0,0,,So references to x in the second module will always get it will refer to this initialized variable which might not
Dialogue: 0,0:28:01.68,0:28:04.42,English,,0,0,0,,So it might not be what you want right
Dialogue: 0,0:28:06.12,0:28:10.14,English,,0,0,0,,You may you may be assuming that it's uninitialized in your code
Dialogue: 0,0:28:12.22,0:28:16.46,English,,0,0,0,,Okay and then you get the the ultimate nightmare scenario is suppose
Dialogue: 0,0:28:17.06,0:28:21.62,English,,0,0,0,,You know because we're following a standard abi we can compile our code with multiple compilers
Dialogue: 0,0:28:22.20,0:28:24.80,English,,0,0,0,,And this actually happens in some oh yes questions
Dialogue: 0,0:28:25.06,0:28:34.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:28:34.76,0:28:36.54,English,,0,0,0,,Oh yeah actually you're right
Dialogue: 0,0:28:37.40,0:28:41.58,English,,0,0,0,,It will it will still take preference and and you'll be writing a for by quantity
Dialogue: 0,0:28:41.58,0:28:45.02,English,,0,0,0,,Which is is what you want so that slides not quite right
Dialogue: 0,0:28:45.50,0:28:55.50,English,,0,0,0,,So oh yeah what is the point of doing the static versus non static
Dialogue: 0,0:28:55.50,0:29:02.26,English,,0,0,0,,If it's always being referenced just locally in constantly what is the point of declaring  it's time
Dialogue: 0,0:29:02.60,0:29:05.56,English,,0,0,0,,-is it it stores it in like \n-no no no it's
Dialogue: 0,0:29:06.86,0:29:11.42,English,,0,0,0,,If you reference up if you reference a a variable
Dialogue: 0,0:29:12.84,0:29:15.46,English,,0,0,0,,That's you mean so a variable is defined in your module
Dialogue: 0,0:29:16.04,0:29:22.70,English,,0,0,0,,And then you...with the static...right
Dialogue: 0,0:29:24.06,0:29:26.54,English,,0,0,0,,Oh they're both they're both local
Dialogue: 0,0:29:26.98,0:29:31.30,English,,0,0,0,,So you do this if you want to value two to retain
Dialogue: 0,0:29:31.96,0:29:36.86,English,,0,0,0,,From if you want if you want that variable to retain value from invocation to invocation
Dialogue: 0,0:29:38.32,0:29:42.62,English,,0,0,0,,So suppose you it's usually a bad idea as we'll see when we study threads
Dialogue: 0,0:29:42.62,0:29:44.90,English,,0,0,0,,Because it makes your code non thread safe
Dialogue: 0,0:29:45.62,0:29:49.40,English,,0,0,0,,But like early like random number generators
Dialogue: 0,0:29:50.18,0:29:53.28,English,,0,0,0,,Would it would compute a pseudo-random number
Dialogue: 0,0:29:53.78,0:29:55.84,English,,0,0,0,,And then it would store it in a static variable
Dialogue: 0,0:29:56.28,0:30:01.30,English,,0,0,0,,And then use that as the the starting value for the next the next time you call that function
Dialogue: 0,0:30:01.74,0:30:06.70,English,,0,0,0,,So whenever you want values to to persist across function invocation to reduce static
Dialogue: 0,0:30:07.26,0:30:25.04,English,,0,0,0,,Yes something really crash
Dialogue: 0,0:30:25.04,0:30:26.20,English,,0,0,0,,Well wait a minute let me
Dialogue: 0,0:30:27.50,0:30:34.04,English,,0,0,0,,Let me get this straight rights to x and p 2 will actually correspond to the memory
Dialogue: 0,0:30:34.30,0:30:40.78,English,,0,0,0,,Look that it will actually go to the memory location I'm sorry I i need to amend that
Dialogue: 0,0:30:41.74,0:30:47.60,English,,0,0,0,,So rights to x in p 2 will be 8 bytes
Dialogue: 0,0:30:47.64,0:30:51.32,English,,0,0,0,,Because the compiler you know the compiler knows that it's a double
Dialogue: 0,0:30:52.70,0:30:59.84,English,,0,0,0,,But it'll go to a memory location that's I that's only 4 bytes
Dialogue: 0,0:31:00.54,0:31:03.32,English,,0,0,0,,Because x because the linker chose the strong symbol
Dialogue: 0,0:31:04.46,0:31:08.34,English,,0,0,0,,Okay so so the rights to x and p 2 will actually overwrite y
Dialogue: 0,0:31:12.88,0:31:23.12,English,,0,0,0,,Ok I'm sorry yes question
Dialogue: 0,0:31:23.18,0:31:25.08,English,,0,0,0,,That's just usually the way it happens
Dialogue: 0,0:31:25.70,0:31:33.42,English,,0,0,0,,You know
Dialogue: 0,0:31:33.46,0:31:38.46,English,,0,0,0,,No no no global variables go in in data they don't go on the stack
Dialogue: 0,0:31:39.36,0:31:41.80,English,,0,0,0,,But usually if you define local variables in a function
Dialogue: 0,0:31:42.26,0:31:46.38,English,,0,0,0,,It will put them it will allocate them one after the other on them on the stack
Dialogue: 0,0:31:49.68,0:31:55.66,English,,0,0,0,,Okay all right so all this discussion about
Dialogue: 0,0:31:57.52,0:32:01.38,English,,0,0,0,,These these weird strong weak symbol rules that the linker have
Dialogue: 0,0:32:01.38,0:32:04.92,English,,0,0,0,,It's another reason to avoid global variables if you can
Dialogue: 0,0:32:07.32,0:32:12.40,English,,0,0,0,,Now if if you if you need to declare a global  see if you can declare it static
Dialogue: 0,0:32:12.40,0:32:16.08,English,,0,0,0,,Because that'll limited scope to the the module that it's declared in
Dialogue: 0,0:32:16.34,0:32:18.10,English,,0,0,0,,So that's a good idea if you can do it
Dialogue: 0,0:32:18.88,0:32:21.24,English,,0,0,0,,And if you define a global variable initialize it
Dialogue: 0,0:32:22.90,0:32:28.22,English,,0,0,0,,So that you'll you'll you'll find you'll discover if you have multiple
Dialogue: 0,0:32:28.48,0:32:31.26,English,,0,0,0,,Initialize global symbols with the same name in your code
Dialogue: 0,0:32:32.46,0:32:35.90,English,,0,0,0,,And then if you want to it's always good practice
Dialogue: 0,0:32:35.90,0:32:41.70,English,,0,0,0,,If you're referencing an external variable to tell the compiler about it by using the x turn attribute
Dialogue: 0,0:32:44.94,0:32:46.29,English,,0,0,0,,All right
Dialogue: 0,0:32:46.74,0:32:53.48,English,,0,0,0,,So now at this point the linker has associated every symbol reference  with some simple definition
Dialogue: 0,0:32:54.70,0:32:59.56,English,,0,0,0,,Now it has to take all those object relocatable object files and smush them together
Dialogue: 0,0:32:59.80,0:33:03.84,English,,0,0,0,,And create like one one big executable
Dialogue: 0,0:33:04.92,0:33:08.54,English,,0,0,0,,So suppose with our example a little running example
Dialogue: 0,0:33:09.72,0:33:18.32,English,,0,0,0,,Each main.o and sum.o contain a code and initialize data
Dialogue: 0,0:33:19.08,0:33:22.96,English,,0,0,0,,Sum.o doesn't have any initialize data it just has code
Dialogue: 0,0:33:23.62,0:33:28.34,English,,0,0,0,,And then there's their system code that actually runs before and after your program so
Dialogue: 0,0:33:29.88,0:33:35.46,English,,0,0,0,,When when your program run it actually starts executing a startup code from  from lib see
Dialogue: 0,0:33:36.12,0:33:44.46,English,,0,0,0,,That that sort of initializes things and then the last thing that it does is it calls main  and passes it arcs rc and rv
Dialogue: 0,0:33:46.18,0:33:48.38,English,,0,0,0,,Okay and then when you're when your program exits
Dialogue: 0,0:33:49.78,0:33:55.00,English,,0,0,0,,Well that's a cyst call but if your program if your main function routine does a return
Dialogue: 0,0:33:55.46,0:33:59.54,English,,0,0,0,,Then it returns back to that startup code which then doesn't exit okay
Dialogue: 0,0:34:00.52,0:34:07.62,English,,0,0,0,,So so this is just and so this this consists of of text and data as well
Dialogue: 0,0:34:09.10,0:34:13.16,English,,0,0,0,,And so when we when the linker relocates these these object files
Dialogue: 0,0:34:15.28,0:34:20.84,English,,0,0,0,,It takes all of the the code the text sections from each of the modules
Dialogue: 0,0:34:21.80,0:34:29.96,English,,0,0,0,,And puts them together contiguously init in the dot text section for the executable object file
Dialogue: 0,0:34:30.30,0:34:34.42,English,,0,0,0,,Ok so it just puts them together in some order that it determines
Dialogue: 0,0:34:34.76,0:34:40.40,English,,0,0,0,,And it creates a combined dot text section in the executable
Dialogue: 0,0:34:40.82,0:34:46.18,English,,0,0,0,,That contains all of the system code and the all of the all of the code defined in the modules
Dialogue: 0,0:34:46.84,0:34:51.24,English,,0,0,0,,And then it does the same thing with the data takes all the all the dot data
Dialogue: 0,0:34:51.96,0:34:55.92,English,,0,0,0,,Sections from the various object files and puts them together
Dialogue: 0,0:34:56.42,0:35:00.62,English,,0,0,0,,In in one combined data section in the executable
Dialogue: 0,0:35:02.52,0:35:07.32,English,,0,0,0,,And it also emerges the symbol tables and in the debug information as well
Dialogue: 0,0:35:09.14,0:35:15.12,English,,0,0,0,,Now when it just the act the act of sort of
Dialogue: 0,0:35:15.64,0:35:19.98,English,,0,0,0,,Relocating these these object files requires the linker
Dialogue: 0,0:35:20.56,0:35:23.54,English,,0,0,0,,To figure out where it's going to actually store these
Dialogue: 0,0:35:24.42,0:35:31.24,English,,0,0,0,,These these different these different symbols when the system gets when this program gets loaded
Dialogue: 0,0:35:31.26,0:35:36.00,English,,0,0,0,,So it it has to pick an address for main that
Dialogue: 0,0:35:37.30,0:35:41.14,English,,0,0,0,,That function will start at some absolute address
Dialogue: 0,0:35:41.22,0:35:46.42,English,,0,0,0,,It's going to have it's going to do the same for swap so for all the all the data arrays right
Dialogue: 0,0:35:51.16,0:35:54.94,English,,0,0,0,,And but the problem is is that when this code is
Dialogue: 0,0:35:55.16,0:36:00.16,English,,0,0,0,,Is is compiled the compiler doesn't know what addresses the linker is going to pick
Dialogue: 0,0:36:02.40,0:36:09.10,English,,0,0,0,,So the so the compiler creates these these reminders to the linker called relocation entries
Dialogue: 0,0:36:09.10,0:36:13.84,English,,0,0,0,,Which which are then stored in the relocation sections of the the object file
Dialogue: 0,0:36:14.94,0:36:20.22,English,,0,0,0,,And these these relocation entries are instructions to the linker that's something
Dialogue: 0,0:36:21.62,0:36:24.88,English,,0,0,0,,That there's a reference to a symbol that's going to have to be patched up
Dialogue: 0,0:36:25.48,0:36:30.98,English,,0,0,0,,When the the code is actually relocated and merged into the executable
Dialogue: 0,0:36:32.42,0:36:36.24,English,,0,0,0,,So let's look at a couple of these a couple of examples so in
Dialogue: 0,0:36:37.04,0:36:44.38,English,,0,0,0,,Our in our main.c module there was a reference to this  to this global symbol called array
Dialogue: 0,0:36:46.58,0:36:52.06,English,,0,0,0,,Okay and then there was also a reference to this this this global symbol sum which is the function
Dialogue: 0,0:36:53.54,0:36:57.32,English,,0,0,0,,So the the compiler creates two relocation entries
Dialogue: 0,0:36:57.90,0:37:00.84,English,,0,0,0,,The first one for the reference to the array a
Dialogue: 0,0:37:01.58,0:37:06.30,English,,0,0,0,,So here we're moving remember edi is the first argument
Dialogue: 0,0:37:07.00,0:37:12.18,English,,0,0,0,,So remember our sum function takes the address of the of array
Dialogue: 0,0:37:12.68,0:37:15.50,English,,0,0,0,,Of the input array as its it's argument
Dialogue: 0,0:37:16.92,0:37:27.00,English,,0,0,0,,So this move we're moving the address of the array into edi for the first argument
Dialogue: 0,0:37:27.92,0:37:30.36,English,,0,0,0,,But the compiler doesn't know what that address is going to be
Dialogue: 0,0:37:31.24,0:37:34.56,English,,0,0,0,,Right so it just it just it just
Dialogue: 0,0:37:35.84,0:37:42.58,English,,0,0,0,,It just moves in it an immediate value of 0 into edi temporarily right so you can see this is all zeros
Dialogue: 0,0:37:43.96,0:37:50.02,English,,0,0,0,,The bf is the move instruction and then there's allsey rows in for now
Dialogue: 0,0:37:51.82,0:37:57.92,English,,0,0,0,,And then it places this relocation entry in the in the relocation section of maemo
Dialogue: 0,0:37:58.64,0:38:03.44,English,,0,0,0,,And it it says it says to the linker at addre at offset a
Dialogue: 0,0:38:04.96,0:38:09.58,English,,0,0,0,,So these let me remind you these are our main.o
Dialogue: 0,0:38:10.52,0:38:13.90,English,,0,0,0,,Module only contains one one function
Dialogue: 0,0:38:14.92,0:38:19.78,English,,0,0,0,,So that function starts that offsets zero in the in the code section
Dialogue: 0,0:38:19.92,0:38:22.96,English,,0,0,0,,Of the module in the dot text section of the module
Dialogue: 0,0:38:23.90,0:38:28.84,English,,0,0,0,,If there were other functions in this module they would they would follow immediately after
Dialogue: 0,0:38:29.48,0:38:36.98,English,,0,0,0,,Ok and it so you can see what what the compiler is it's just all it's just generating offsets of these instructions
Dialogue: 0,0:38:37.62,0:38:39.92,English,,0,0,0,,From the beginning of the dot text section
Dialogue: 0,0:38:41.02,0:38:46.50,English,,0,0,0,,And it it includes this relocation entry which says  to the linker hey
Dialogue: 0,0:38:46.98,0:38:54.38,English,,0,0,0,,When you're relocating main.o add offset a in this dot text section
Dialogue: 0,0:38:55.48,0:39:03.36,English,,0,0,0,,You've got a reference a 32 a reference to an array in the form of a 32-bit address
Dialogue: 0,0:39:04.52,0:39:11.40,English,,0,0,0,,Ok so that so eventually the linker is going to have to patch up these
Dialogue: 0,0:39:12.28,0:39:15.04,English,,0,0,0,,So this is address 9 this is address a
Dialogue: 0,0:39:15.04,0:39:18.30,English,,0,0,0,,It's going to have to patch up the four bytes starting at address a
Dialogue: 0,0:39:19.82,0:39:24.76,English,,0,0,0,,With the absolute address of the symbol array
Dialogue: 0,0:39:28.58,0:39:33.46,English,,0,0,0,,And then similarly the reference to the reference to
Dialogue: 0,0:39:35.68,0:39:38.70,English,,0,0,0,,This the reference to this function some
Dialogue: 0,0:39:39.72,0:39:42.20,English,,0,0,0,,The compiler has no idea where some
Dialogue: 0,0:39:42.66,0:39:46.74,English,,0,0,0,,Actually will end up it doesn't even know what module it's in or even if it's
Dialogue: 0,0:39:47.08,0:39:49.24,English,,0,0,0,,Even if it is defined in a module
Dialogue: 0,0:39:49.94,0:39:55.48,English,,0,0,0,,So in this case it just it does a call with all zeros
Dialogue: 0,0:39:58.14,0:40:01.72,English,,0,0,0,,And then it adds this relocation entry that says to the linker
Dialogue: 0,0:40:03.10,0:40:13.88,English,,0,0,0,,At offset f you've got a four byte pc-relative reference  to a function
Dialogue: 0,0:40:14.76,0:40:16.16,English,,0,0,0,,To assemble called sum
Dialogue: 0,0:40:17.78,0:40:23.66,English,,0,0,0,,And then it this is sort of a arcane detail that but and it includes
Dialogue: 0,0:40:24.24,0:40:27.96,English,,0,0,0,,There's an option to include a bias in the in the offset
Dialogue: 0,0:40:28.66,0:40:36.26,English,,0,0,0,,And since we're using since calls are since calls are always resolved using pc-relative addressing
Dialogue: 0,0:40:36.78,0:40:43.18,English,,0,0,0,,The value that's going to be placed here at these four bytes that offset f
Dialogue: 0,0:40:43.70,0:40:48.40,English,,0,0,0,,Is going to be an offset from the current or I p value or program or counter value
Dialogue: 0,0:40:49.44,0:40:53.66,English,,0,0,0,,And since the program counter always points to the nest get next instruction
Dialogue: 0,0:40:55.66,0:40:59.18,English,,0,0,0,,It includes this which is four bytes away it includes this
Dialogue: 0,0:40:59.54,0:41:01.40,English,,0,0,0,,This offset of minus four
Dialogue: 0,0:41:02.96,0:41:11.22,English,,0,0,0,,So if it sits I i talked about it in detail in the book if you really want to know  how this works
Dialogue: 0,0:41:11.32,0:41:17.98,English,,0,0,0,,But just the point here is that there's enough information for the linker to actually fill in the right address
Dialogue: 0,0:41:18.98,0:41:21.34,English,,0,0,0,,So now if we look at the relocated text section
Dialogue: 0,0:41:21.34,0:41:27.64,English,,0,0,0,,So if we if we compile this code into an executable and then we use object on to to disassemble it
Dialogue: 0,0:41:28.52,0:41:34.36,English,,0,0,0,,Then what you see is this this reference here
Dialogue: 0,0:41:34.36,0:41:38.58,English,,0,0,0,,Where we move the address of the address of a into edi
Dialogue: 0,0:41:39.96,0:41:50.20,English,,0,0,0,,Those four bytes which were original zero have now been updated with the the actual address of array in in memory at runtime
Dialogue: 0,0:41:50.70,0:41:57.60,English,,0,0,0,,Okay so the linkers decided that the array is going to go at address 0x601018
Dialogue: 0,0:41:58.46,0:42:06.54,English,,0,0,0,,And then it's it's actually patched that the four bytes in the cup in the in the move instruction with that absolute address
Dialogue: 0,0:42:08.90,0:42:12.28,English,,0,0,0,,And the call to sum is is it's also been updated
Dialogue: 0,0:42:13.18,0:42:15.02,English,,0,0,0,,But this one's interesting right that
Dialogue: 0,0:42:15.46,0:42:22.04,English,,0,0,0,,So the the address it's been updated with the pc relative address of five
Dialogue: 0,0:42:23.42,0:42:25.42,English,,0,0,0,,Okay so when this program runs
Dialogue: 0,0:42:27.34,0:42:28.98,English,,0,0,0,,This call instruction
Dialogue: 0,0:42:30.54,0:42:39.68,English,,0,0,0,,What it will do when it when it determines when it computes the absolute address of of the function sum
Dialogue: 0,0:42:40.84,0:42:49.10,English,,0,0,0,,It will take
Dialogue: 0,0:42:49.26,0:43:00.36,English,,0,0,0,,It will take the the current value of the program counter which is the next instruction so 0x4004e3
Dialogue: 0,0:43:01.44,0:43:07.42,English,,0,0,0,,And it will add to it whatever whatever value is in this immediate field
Dialogue: 0,0:43:08.16,0:43:13.84,English,,0,0,0,,Okay which is a two scomp you interpret it as a two's complement integer so it can go
Dialogue: 0,0:43:14.76,0:43:18.22,English,,0,0,0,,It can be relative you can go - or or +
Dialogue: 0,0:43:18.88,0:43:28.44,English,,0,0,0,,In this case it's saying that the function that you want to call is that is is at 4004e3 + 5
Dialogue: 0,0:43:29.54,0:43:34.66,English,,0,0,0,,Which is 4004e8 which is the address of some
Dialogue: 0,0:43:35.80,0:43:40.38,English,,0,0,0,,Okay and so the linker the linker does that the compiler has all the smarts
Dialogue: 0,0:43:40.38,0:43:43.46,English,,0,0,0,,The compiler computed the relocation entry
Dialogue: 0,0:43:43.70,0:43:49.02,English,,0,0,0,,The linker is just blindly going through each of those relocation entries and just doing what it's told
Dialogue: 0,0:43:50.44,0:43:58.74,English,,0,0,0,,Okay but the net result is that now all of these these references have been patched up with with valid absolute addresses
Dialogue: 0,0:44:04.90,0:44:08.34,English,,0,0,0,,Now once the linkers created a an object file
Dialogue: 0,0:44:10.20,0:44:13.92,English,,0,0,0,,That object file can be loaded the code and data
Dialogue: 0,0:44:13.92,0:44:18.80,English,,0,0,0,,And that object file can be loaded directly into memory with with no further modification
Dialogue: 0,0:44:20.32,0:44:29.72,English,,0,0,0,,Ok so the if you look at all of the read-only sections in the executable
Dialogue: 0,0:44:30.62,0:44:33.60,English,,0,0,0,,So there's this init section which
Dialogue: 0,0:44:35.40,0:44:41.18,English,,0,0,0,,We're not to worry about that that all the code is in the dot text and things like jump tables are in our oh data
Dialogue: 0,0:44:43.58,0:44:48.18,English,,0,0,0,,All of this data can be loaded directly into memory as is
Dialogue: 0,0:44:49.64,0:44:53.90,English,,0,0,0,,Okay so these bytes can just be copied directly into into memory
Dialogue: 0,0:44:54.82,0:44:58.78,English,,0,0,0,,And that that forms the so called a read-only code segment
Dialogue: 0,0:45:02.44,0:45:10.60,English,,0,0,0,,The the data in the .data and bss x sections can also be copied directly into into memory
Dialogue: 0,0:45:13.40,0:45:19.86,English,,0,0,0,,And in the case of the variables and data they'll be initialized to a value that's stored in the symbol table
Dialogue: 0,0:45:22.96,0:45:27.34,English,,0,0,0,,So we're drawing our our memory here
Dialogue: 0,0:45:27.34,0:45:36.34,English,,0,0,0,,This is the this is the the memory address space that every Linux program sees
Dialogue: 0,0:45:37.56,0:45:46.02,English,,0,0,0,,And we're drawing addresses starting from 0 and going up increasing as we grow up
Dialogue: 0,0:45:47.62,0:45:58.04,English,,0,0,0,,And every program is loaded at this the same address  0x400000
Dialogue: 0,0:45:59.76,0:46:06.36,English,,0,0,0,,And so the the code comes directly from the object file the data comes directly from the object file
Dialogue: 0,0:46:07.04,0:46:09.68,English,,0,0,0,,And then that's followed by a runtime heap
Dialogue: 0,0:46:10.18,0:46:12.50,English,,0,0,0,,Which is created and managed by malloc
Dialogue: 0,0:46:13.14,0:46:16.38,English,,0,0,0,,So when you need dynamic dynamically need to allocate memory
Dialogue: 0,0:46:16.42,0:46:22.22,English,,0,0,0,,Like using malloc that memory comes out of this heap
Dialogue: 0,0:46:22.30,0:46:26.94,English,,0,0,0,,Which starts immediately following the the data segment and grows upwards
Dialogue: 0,0:46:29.42,0:46:35.42,English,,0,0,0,,The stack is at the very top of the the visible
Dialogue: 0,0:46:36.26,0:46:39.20,English,,0,0,0,,Memory that's available to application programs
Dialogue: 0,0:46:40.02,0:46:46.94,English,,0,0,0,,The memory above that is is restricted to the kernel
Dialogue: 0,0:46:47.62,0:46:51.92,English,,0,0,0,,Okay so if you try to access those memory locations you'll get a seg fault
Dialogue: 0,0:46:54.00,0:46:58.72,English,,0,0,0,,And then the stack as we know grows down so this is managed and created a run time
Dialogue: 0,0:46:59.50,0:47:03.88,English,,0,0,0,,And then there's this region somewhere in this huge gap between the stack and the heap
Dialogue: 0,0:47:05.54,0:47:14.74,English,,0,0,0,,There's a region for shared libraries so the dot esso files all get loaded into this this memory mapped region for shared libraries
Dialogue: 0,0:47:17.90,0:47:21.84,English,,0,0,0,,Now that the top of the heap is indicated by this global variable
Dialogue: 0,0:47:23.12,0:47:26.52,English,,0,0,0,,Maintained by the kernel called break brk
Dialogue: 0,0:47:27.38,0:47:33.60,English,,0,0,0,,And the the top of the stack as we know is is maintained by the general purpose register rsp
Dialogue: 0,0:47:34.58,0:47:38.00,English,,0,0,0,,Now there's a little bit of a this is a little bit of a simplification
Dialogue: 0,0:47:38.00,0:47:42.64,English,,0,0,0,,If you actually look at the addresses returned by malloc
Dialogue: 0,0:47:43.44,0:47:46.34,English,,0,0,0,,There's actually a there's actually two heaps
Dialogue: 0,0:47:46.34,0:47:50.88,English,,0,0,0,,There's a heap up here and in the high memory that grows down
Dialogue: 0,0:47:51.16,0:47:54.20,English,,0,0,0,,That's used for large objects very large
Dialogue: 0,0:47:54.64,0:48:01.72,English,,0,0,0,,You know if you mount like a whole bunch of space and then the heap that grows up is  is reserved for smaller smaller objects
Dialogue: 0,0:48:03.26,0:48:04.60,English,,0,0,0,,So I'm not really sure why they do this
Dialogue: 0,0:48:04.62,0:48:11.02,English,,0,0,0,,I think it allows them to have separate allocation algorithms for large objects and small objects
Dialogue: 0,0:48:19.32,0:48:25.04,English,,0,0,0,,Okay so one of the one of the real advantages of linking is that allows us to create libraries of things
Dialogue: 0,0:48:26.26,0:48:29.12,English,,0,0,0,,So it's always something we want to do as programmers we always
Dialogue: 0,0:48:30.92,0:48:36.72,English,,0,0,0,,We always want to create abstractions and then present those abstractions to to users
Dialogue: 0,0:48:37.42,0:48:40.48,English,,0,0,0,,Right and we do that by creating libraries defining an api
Dialogue: 0,0:48:40.48,0:48:50.76,English,,0,0,0,,Yes
Dialogue: 0,0:48:53.20,0:48:56.54,English,,0,0,0,,I think it just is no no it
Dialogue: 0,0:48:59.02,0:49:04.92,English,,0,0,0,,Actually that's a good question I the things I've done it just grows until it runs out of memory right there
Dialogue: 0,0:49:06.22,0:49:10.06,English,,0,0,0,,So I don't think actually that's a really good question I mean I've
Dialogue: 0,0:49:10.79,0:49:14.66,English,,0,0,0,,I've done those experiments and it it eventually reaches some limit
Dialogue: 0,0:49:21.38,0:49:24.96,English,,0,0,0,,Yeah I don't I don't know it's a very large number
Dialogue: 0,0:49:29.34,0:49:36.18,English,,0,0,0,,But I so you know as programmers we always want to abstract define api's
Dialogue: 0,0:49:36.50,0:49:42.30,English,,0,0,0,,Implement package up those api's and make them available to to other programmers
Dialogue: 0,0:49:44.78,0:49:50.24,English,,0,0,0,,So how can we actually do that how can we make commonly used functions available to other programmers
Dialogue: 0,0:49:50.56,0:49:55.94,English,,0,0,0,,Well one thing given what we've learned so far you could just take all the functions
Dialogue: 0,0:49:56.52,0:50:00.30,English,,0,0,0,,And put them all in a single big C file right
Dialogue: 0,0:50:01.08,0:50:07.74,English,,0,0,0,,And then programmers would just link that C file into their into their programs if they want to use them right
Dialogue: 0,0:50:08.48,0:50:13.20,English,,0,0,0,,Another option would be to take that might get kind of unwieldy if it's a big library right
Dialogue: 0,0:50:13.42,0:50:16.30,English,,0,0,0,,Lipsi has hundreds and hundreds of functions
Dialogue: 0,0:50:17.44,0:50:21.50,English,,0,0,0,,So another option would might be to just take each function put it in a separate file
Dialogue: 0,0:50:22.20,0:50:25.56,English,,0,0,0,,And then compile them all together and compile and link them all together
Dialogue: 0,0:50:27.22,0:50:33.48,English,,0,0,0,,So this is more space and time efficient than then our first option
Dialogue: 0,0:50:34.72,0:50:37.50,English,,0,0,0,,But it seems like it would be burdensome on the programmer because
Dialogue: 0,0:50:38.18,0:50:42.70,English,,0,0,0,,The program would have to know where all the all these functions were and put them in make files
Dialogue: 0,0:50:42.70,0:50:50.56,English,,0,0,0,,It'd just be a lot of you know this you could end up with a ridiculously large  command line to GCC
Dialogue: 0,0:50:52.80,0:50:57.96,English,,0,0,0,,So that the one solution to this problem is that
Dialogue: 0,0:50:58.24,0:51:03.82,English,,0,0,0,,The first solution that the developers of Unix came up with us
Dialogue: 0,0:51:04.10,0:51:05.54,English,,0,0,0,,Something called a static library
Dialogue: 0,0:51:06.44,0:51:11.58,English,,0,0,0,,So the the idea where the static library is that you create this archive  called a dot a file
Dialogue: 0,0:51:12.50,0:51:19.18,English,,0,0,0,,Which is  it's just a collection of .o file where each .o file contains a function
Dialogue: 0,0:51:19.46,0:51:25.65,English,,0,0,0,,Ok so you take all the functions in your library you use option two to create a bunch of .o files
Dialogue: 0,0:51:26.30,0:51:31.26,English,,0,0,0,,And then you use a program called an archive or ar  to take those .o files
Dialogue: 0,0:51:31.82,0:51:37.30,English,,0,0,0,,Put them together in a all together in a big file called an archive
Dialogue: 0,0:51:37.94,0:51:44.14,English,,0,0,0,,Out with a with a table of contents at the beginning that tells you the offset of each one of the .o files
Dialogue: 0,0:51:44.54,0:51:49.92,English,,0,0,0,,Ok so an archive is just this concatenated collection of .o files
Dialogue: 0,0:51:53.12,0:51:57.64,English,,0,0,0,,And then and then you link you pass that archive to the to the linker
Dialogue: 0,0:51:58.06,0:52:03.62,English,,0,0,0,,And it only takes the .o files that are actually referenced   and links them into the code
Dialogue: 0,0:52:03.74,0:52:07.42,English,,0,0,0,,Right so it's a more efficient way you can have a huge archive
Dialogue: 0,0:52:07.78,0:52:10.26,English,,0,0,0,,But like lib.c but if you only call printf
Dialogue: 0,0:52:11.32,0:52:13.88,English,,0,0,0,,The only dot o file you get is printf .o
Dialogue: 0,0:52:15.50,0:52:17.90,English,,0,0,0,,Okay so the way this works is
Dialogue: 0,0:52:18.80,0:52:19.96,English,,0,0,0,,As before we take
Dialogue: 0,0:52:24.76,0:52:28.00,English,,0,0,0,,Now we take all the functions we want to put in our library
Dialogue: 0,0:52:29.40,0:52:32.48,English,,0,0,0,,We run them through our translators to get .o files
Dialogue: 0,0:52:33.30,0:52:37.14,English,,0,0,0,,We pass those to the archiver to get a the archive
Dialogue: 0,0:52:37.14,0:52:40.74,English,,0,0,0,,So in this case lib ca
Dialogue: 0,0:52:42.02,0:52:46.16,English,,0,0,0,,And which has this code for printf that we might want to use
Dialogue: 0,0:52:47.32,0:52:52.42,English,,0,0,0,,Right and so we can we can we can recreate that archive anytime we want
Dialogue: 0,0:52:52.42,0:52:55.62,English,,0,0,0,,So if one of these functions changes like say printf changes
Dialogue: 0,0:52:56.10,0:53:03.51,English,,0,0,0,,You just rearchive the dot recompile printf and then re archive all of the .o files
Dialogue: 0,0:53:04.40,0:53:07.30,English,,0,0,0,,So in libc it's it's about 1500 object files
Dialogue: 0,0:53:07.36,0:53:14.42,English,,0,0,0,,And it's archived things like printf scanf simple integer math  and there's also a math library
Dialogue: 0,0:53:15.84,0:53:20.92,English,,0,0,0,,Which has you know several hundred common functions for things like
Dialogue: 0,0:53:21.66,0:53:26.50,English,,0,0,0,,Floating point math sine cosine tangent etc
Dialogue: 0,0:53:27.98,0:53:34.40,English,,0,0,0,,These libraries the convention is that a library always is prefixed with lib with li b and then a
Dialogue: 0,0:53:35.06,0:53:38.72,English,,0,0,0,,Nd then sort of new some indication of what it what it does
Dialogue: 0,0:53:42.64,0:53:45.46,English,,0,0,0,,So now let's see how linking with these static libraries would work
Dialogue: 0,0:53:45.52,0:53:47.84,English,,0,0,0,,So I've created a little example here
Dialogue: 0,0:53:50.36,0:53:53.38,English,,0,0,0,,I've created a library called libvector.a
Dialogue: 0,0:53:54.40,0:53:57.38,English,,0,0,0,,And it consists of functions that manipulate vectors
Dialogue: 0,0:53:57.82,0:54:00.68,English,,0,0,0,,And this is a real simple library it just adds
Dialogue: 0,0:54:00.90,0:54:07.56,English,,0,0,0,,There's a function to add two vectors x and y together and and return the result in z
Dialogue: 0,0:54:10.10,0:54:16.00,English,,0,0,0,,And then another similar function that will do pairwise multiplication of two vectors so
Dialogue: 0,0:54:16.44,0:54:20.46,English,,0,0,0,,X[i]*y[i] equals z[i]
Dialogue: 0,0:54:22.06,0:54:28.94,English,,0,0,0,,Now I compile these two programs and pack I want to package them into an archive called lib vector a
Dialogue: 0,0:54:29.70,0:54:34.46,English,,0,0,0,,And then in my in my main program I'm going to call one of those functions advic
Dialogue: 0,0:54:35.12,0:54:38.08,English,,0,0,0,,To add these two vectors x and y together
Dialogue: 0,0:54:43.28,0:54:46.26,English,,0,0,0,,So now what happens when we compile this this program
Dialogue: 0,0:54:47.82,0:54:56.36,English,,0,0,0,,We've already we've constructed the archive lib dr. a  from addvec.o and multvec.o
Dialogue: 0,0:54:57.80,0:55:05.90,English,,0,0,0,,And we pass that archive to the linker along with our main 2.0 relocatable object file
Dialogue: 0,0:55:07.68,0:55:10.42,English,,0,0,0,,And we also pass it libc.a
Dialogue: 0,0:55:10.80,0:55:14.10,English,,0,0,0,,Which has the definition of which contains printf.o
Dialogue: 0,0:55:14.96,0:55:17.10,English,,0,0,0,,And anything else that printf.o my call
Dialogue: 0,0:55:19.08,0:55:26.99,English,,0,0,0,,So these three the linker detects the reference to advic the function addvec
Dialogue: 0,0:55:26.99,0:55:32.11,English,,0,0,0,,And so it just pulls addvec.o out and and ignores the rest
Dialogue: 0,0:55:32.78,0:55:36.66,English,,0,0,0,,Similarly for printf.o and then it compiles all those
Dialogue: 0,0:55:36.96,0:55:43.32,English,,0,0,0,,Main main.o addvec.o and printf.o all together into this fully linked executable
Dialogue: 0,0:55:43.78,0:55:47.10,English,,0,0,0,,Called prog to see for compiled time
Dialogue: 0,0:55:48.84,0:55:54.79,English,,0,0,0,,So we're doing this we're doing this link we're doing this this linking at compile time
Dialogue: 0,0:55:55.28,0:55:57.28,English,,0,0,0,,When we call a GCC now
Dialogue: 0,0:55:59.06,0:56:05.12,English,,0,0,0,,What the linker does when it's when it's using static libraries
Dialogue: 0,0:56:07.88,0:56:12.28,English,,0,0,0,,It scans all the dot o files and dot a files in order on the command line
Dialogue: 0,0:56:12.32,0:56:21.02,English,,0,0,0,,So you're just typing GCC and then a list of dot o files and davay files in some order
Dialogue: 0,0:56:23.08,0:56:29.14,English,,0,0,0,,So so during the scan it keeps a list of the current unresolved references right
Dialogue: 0,0:56:30.18,0:56:35.10,English,,0,0,0,,So if let's say let's say it looks at main dot o first and there's a reference to printf
Dialogue: 0,0:56:36.58,0:56:41.10,English,,0,0,0,,That's an unresolved reference because print is not not defined in main.o
Dialogue: 0,0:56:41.10,0:56:43.40,English,,0,0,0,,So that goes in a list of undefined references
Dialogue: 0,0:56:44.72,0:56:51.68,English,,0,0,0,,And at some point or another as as each new .o file or .a file is encountered
Dialogue: 0,0:56:52.22,0:57:01.36,English,,0,0,0,,The linker tries to resolve its list of unruh of references with the symbols that are defined in that .o file or ,a file
Dialogue: 0,0:57:03.14,0:57:06.90,English,,0,0,0,,And then if there's any entries in the list at the end of the scan then there's  error
Dialogue: 0,0:57:07.42,0:57:13.48,English,,0,0,0,,Okay so that the key here is that the linker will try to resolve these references from left to right on the command line
Dialogue: 0,0:57:14.16,0:57:18.76,English,,0,0,0,,And so this is another sort of important thing for you to know as programmers
Dialogue: 0,0:57:18.76,0:57:25.22,English,,0,0,0,,Because the order that you that you put your files on the command line actually makes a difference
Dialogue: 0,0:57:25.58,0:57:31.36,English,,0,0,0,,Okay so you can get sort of weird baffling linker errors if you if you use the wrong order
Dialogue: 0,0:57:32.20,0:57:34.08,English,,0,0,0,,So for instance suppose we've got
Dialogue: 0,0:57:36.78,0:57:40.12,English,,0,0,0,,A function an object module called lib test
Dialogue: 0,0:57:41.04,0:57:48.24,English,,0,0,0,,That calls a function that's defined in in lmine.a
Dialogue: 0,0:57:49.24,0:57:54.84,English,,0,0,0,,Okay so these - else - big l period that that says to look for
Dialogue: 0,0:57:56.82,0:58:02.88,English,,0,0,0,,To look for a library files in the current directory
Dialogue: 0,0:58:02.88,0:58:07.80,English,,0,0,0,,That's what the dot look there first and then look in the normal places that you look
Dialogue: 0,0:58:09.04,0:58:14.72,English,,0,0,0,,And the the -l that's a it's like an abbreviation
Dialogue: 0,0:58:15.20,0:58:20.14,English,,0,0,0,,We could replace this with just the fully spelled out lib mind ed
Dialogue: 0,0:58:20.98,0:58:23.84,English,,0,0,0,,Okay but you'll see this this  -l used a lot
Dialogue: 0,0:58:24.68,0:58:30.94,English,,0,0,0,,So so lib test calls a function that's declared in in lib mind.a
Dialogue: 0,0:58:32.00,0:58:37.28,English,,0,0,0,,So the linker looks at it looks at the unresolved symbols in libtest.o
Dialogue: 0,0:58:38.08,0:58:41.28,English,,0,0,0,,And it detects that there's this unresolved function let's say it's called foo
Dialogue: 0,0:58:42.34,0:58:44.90,English,,0,0,0,,I know it's it's called lib fun
Dialogue: 0,0:58:46.20,0:58:54.38,English,,0,0,0,,So and it puts it on the list and then it goes on to the next command line entry  and that's live mine.a
Dialogue: 0,0:58:54.78,0:58:58.92,English,,0,0,0,,And in there it finds it finds this symbol of libfun
Dialogue: 0,0:58:59.64,0:59:08.10,English,,0,0,0,,And it it resolves the reference to that - lib phone - the actual address the relocated address
Dialogue: 0,0:59:09.14,0:59:15.04,English,,0,0,0,,Now if we switch the order and we put lmine on a first followed by libtest.o
Dialogue: 0,0:59:15.84,0:59:18.60,English,,0,0,0,,Well there's there's no unresolved references in this library
Dialogue: 0,0:59:18.60,0:59:21.46,English,,0,0,0,,Right it's just the collection of function definitions
Dialogue: 0,0:59:23.26,0:59:27.96,English,,0,0,0,,So it there's no unresolved references so the linker looks at that that's all good
Dialogue: 0,0:59:28.26,0:59:33.10,English,,0,0,0,,And then it looks at lib toss zero and now there's an unresolved reference to two libfun
Dialogue: 0,0:59:33.72,0:59:36.32,English,,0,0,0,,But we're out of we're at the end of the command line
Dialogue: 0,0:59:37.18,0:59:38.46,English,,0,0,0,,So that's a linker error
Dialogue: 0,0:59:39.64,0:59:44.40,English,,0,0,0,,So you get this you get this really cryptic error message
Dialogue: 0,0:59:45.56,0:59:50.24,English,,0,0,0,,And if you didn't know about this ordering rule you wouldn't have any idea how to debug
Dialogue: 0,0:59:53.32,0:59:56.88,English,,0,0,0,,It okay so the static libraries are kind of the old fashioned solution that
Dialogue: 0,0:59:56.88,1:00:02.04,English,,0,0,0,,The modern solution is to use dynamic libraries or shared shared libraries
Dialogue: 0,1:00:04.14,1:00:08.42,English,,0,0,0,,So the reason the reason there's this sort of newer form of libraries
Dialogue: 0,1:00:08.46,1:00:11.74,English,,0,0,0,,That static libraries have some some disadvantages
Dialogue: 0,1:00:12.48,1:00:17.18,English,,0,0,0,,So every if you compile with static libraries
Dialogue: 0,1:00:17.20,1:00:20.14,English,,0,0,0,,Then every every function that uses printf
Dialogue: 0,1:00:20.14,1:00:24.34,English,,0,0,0,,Which or every program that uses printf has to have a copy of printf
Dialogue: 0,1:00:25.98,1:00:29.12,English,,0,0,0,,Okay but almost every every program uses printf right
Dialogue: 0,1:00:29.14,1:00:35.14,English,,0,0,0,,So there's a shared shared libraries allow provide a mechanism where there can just be one
Dialogue: 0,1:00:35.78,1:00:43.32,English,,0,0,0,,Wherever there's just one instance of a shared library  member like like printf
Dialogue: 0,1:00:44.22,1:00:47.96,English,,0,0,0,,And every program running on the system will share that one copy
Dialogue: 0,1:00:54.76,1:00:59.96,English,,0,0,0,,So that's the that's sort of the big big disadvantage is this potential duplication
Dialogue: 0,1:01:01.80,1:01:08.42,English,,0,0,0,,So shared libraries are different in the sense that they contain
Dialogue: 0,1:01:11.34,1:01:17.14,English,,0,0,0,,Code and data that are linked and loaded into the program not when it's not when it's compiled
Dialogue: 0,1:01:17.72,1:01:21.46,English,,0,0,0,,And linked and into a executable object file
Dialogue: 0,1:01:21.80,1:01:25.98,English,,0,0,0,,But actually when the program is loaded into the system
Dialogue: 0,1:01:25.98,1:01:31.50,English,,0,0,0,,So linking of references to shared library objects is deferred
Dialogue: 0,1:01:32.20,1:01:35.54,English,,0,0,0,,Until the program is actually loaded into into memory
Dialogue: 0,1:01:35.78,1:01:39.28,English,,0,0,0,,Until the executable object file is actually loaded into memory
Dialogue: 0,1:01:40.28,1:01:42.86,English,,0,0,0,,And this can either and it can even happen
Dialogue: 0,1:01:43.36,1:01:49.82,English,,0,0,0,,It can happen when the program is actually loaded into memory but it can also happen at runtime anytime at runtime
Dialogue: 0,1:01:50.50,1:01:52.76,English,,0,0,0,,So you can be you can be running a program
Dialogue: 0,1:01:53.20,1:01:59.86,English,,0,0,0,,And that program can arbitrarily decide to load a function that's declared in a shared library
Dialogue: 0,1:02:00.32,1:02:01.78,English,,0,0,0,,Okay and I'll show you that it's really cool
Dialogue: 0,1:02:04.12,1:02:06.68,English,,0,0,0,,Now these things are often called they're called shared libraries
Dialogue: 0,1:02:06.68,1:02:10.54,English,,0,0,0,,They're called dynamic link libraries like in windows they're called dlls
Dialogue: 0,1:02:11.42,1:02:14.46,English,,0,0,0,,.iso files they're all referenced the same thing
Dialogue: 0,1:02:21.36,1:02:27.32,English,,0,0,0,,Okay so that this like I said you can the the dynamic linking can occur when the program's loaded or
Dialogue: 0,1:02:27.88,1:02:30.20,English,,0,0,0,,After it's loaded and actually running
Dialogue: 0,1:02:32.28,1:02:37.66,English,,0,0,0,,And there's this sort of big deal that shared library routines can be shared by multiple processes
Dialogue: 0,1:02:37.88,1:02:40.46,English,,0,0,0,,And we'll look at this this will make sense when we look at virtual memories
Dialogue: 0,1:02:40.46,1:02:42.36,English,,0,0,0,,So don't don't worry about that now
Dialogue: 0,1:02:43.28,1:02:45.26,English,,0,0,0,,But but here's how the process works
Dialogue: 0,1:02:49.68,1:02:54.02,English,,0,0,0,,So we've first we have to create instead of creating an archive
Dialogue: 0,1:02:54.78,1:02:59.88,English,,0,0,0,,We create a shared library so our live vector routines
Dialogue: 0,1:03:02.22,1:03:08.88,English,,0,0,0,,Instead of creating an archive a file we create a shared a .so file
Dialogue: 0,1:03:09.46,1:03:13.08,English,,0,0,0,,Using the using the shared argument to GCC
Dialogue: 0,1:03:13.98,1:03:17.52,English,,0,0,0,,So we take our two input functions a addvec and multvec
Dialogue: 0,1:03:18.28,1:03:25.72,English,,0,0,0,,And share it says to create and we're telling GCC to create a shared library  and place it in libvector.so
Dialogue: 0,1:03:27.04,1:03:36.74,English,,0,0,0,,Okay and so and there's also that the the C the C developers have created a punctured library called libc.so
Dialogue: 0,1:03:36.76,1:03:41.40,English,,0,0,0,,That contains printf and on it and other standard library functions
Dialogue: 0,1:03:43.46,1:03:47.88,English,,0,0,0,,So we take our program main2 this is the same program that calls advic
Dialogue: 0,1:03:48.76,1:03:51.88,English,,0,0,0,,And we compile it into main2.o
Dialogue: 0,1:03:52.30,1:03:57.24,English,,0,0,0,,And we pass main2.0 and  these .so files to the linker
Dialogue: 0,1:03:59.72,1:04:07.96,English,,0,0,0,,Now the linker doesn't at this point it doesn't actually copy let's say we're using advic or printf
Dialogue: 0,1:04:08.36,1:04:14.14,English,,0,0,0,,It doesn't actually copy those functions or do anything with them  in the executable
Dialogue: 0,1:04:14.14,1:04:18.44,English,,0,0,0,,It just makes a note in the symbol table that those functions will need to be the
Dialogue: 0,1:04:20.28,1:04:24.70,English,,0,0,0,,References to those functions will need to be resolved  when the program is loaded
Dialogue: 0,1:04:25.22,1:04:31.02,English,,0,0,0,,Okay so it it puts in a relocation entry that says fix this up when you load the program
Dialogue: 0,1:04:32.16,1:04:35.44,English,,0,0,0,,So it's partially linked but it's not fully linked
Dialogue: 0,1:04:35.44,1:04:41.94,English,,0,0,0,,You can't take that you can't take a program you can't take a executable file
Dialogue: 0,1:04:42.24,1:04:45.56,English,,0,0,0,,That was dynamically linked and loaded directly
Dialogue: 0,1:04:47.42,1:04:54.02,English,,0,0,0,,What you what you do is the loader which is the execve system call
Dialogue: 0,1:04:54.50,1:04:58.50,English,,0,0,0,,And we'll learn more about that but just this is just a cyst call that loads
Dialogue: 0,1:04:59.04,1:05:02.12,English,,0,0,0,,Loads executables into memory and runs them
Dialogue: 0,1:05:03.84,1:05:06.38,English,,0,0,0,,The loader takes the executable
Dialogue: 0,1:05:07.06,1:05:12.42,English,,0,0,0,,And then it takes the the shared .so files
Dialogue: 0,1:05:13.04,1:05:19.72,English,,0,0,0,,That this program needs k it also made when the linker also made a note of which .so files  it needs
Dialogue: 0,1:05:22.26,1:05:27.50,English,,0,0,0,,So the loader calls the dynamic linker which takes those .so files
Dialogue: 0,1:05:27.86,1:05:33.18,English,,0,0,0,,And then actually resolves all the references to any on any unresolved reference
Dialogue: 0,1:05:33.70,1:05:41.52,English,,0,0,0,,Okay so the the address of addvwc the addvec and printf functions isn't determined until
Dialogue: 0,1:05:42.14,1:05:49.32,English,,0,0,0,,The program is loaded and by that and it isn't determined by the dynamic linker until the program is loaded
Dialogue: 0,1:05:50.46,1:05:55.02,English,,0,0,0,,So that the dynamic linker does it goes through a similar process that the static linker did
Dialogue: 0,1:05:55.32,1:05:59.82,English,,0,0,0,,Sort of fixing up references to add back at references to to printf
Dialogue: 0,1:06:00.46,1:06:08.42,English,,0,0,0,,And then at that point the binary the binary is in it is in a form that can be executed directly
Dialogue: 0,1:06:08.56,1:06:26.98,English,,0,0,0,,So question yes what if you look the part where did like where is that like if you include violence and use anger and greed zero actually
Dialogue: 0,1:06:26.98,1:06:29.64,English,,0,0,0,,If okay the question is what happens if you include a file
Dialogue: 0,1:06:30.50,1:06:34.28,English,,0,0,0,,So includes are handled by the C preprocessor
Dialogue: 0,1:06:34.94,1:06:40.78,English,,0,0,0,,So they're gone they're long gone by the time the by the time the linker gets around to it
Dialogue: 0,1:06:41.28,1:06:45.82,English,,0,0,0,,Okay so the C preprocessor just takes sharp sign define sharp sign include
Dialogue: 0,1:06:46.70,1:06:51.44,English,,0,0,0,,And and interprets those and outputs another C program
Dialogue: 0,1:06:51.98,1:06:59.18,English,,0,0,0,,So if you if you include a file the C preprocessor just takes that file and just expands it
Dialogue: 0,1:06:59.90,1:07:05.36,English,,0,0,0,,And the output C program contains an expanded version of all the files that you include it
Dialogue: 0,1:07:11.38,1:07:16.82,English,,0,0,0,,Okay now what's really cool is that you can also do this dynamic linking at runtime
Dialogue: 0,1:07:17.34,1:07:20.84,English,,0,0,0,,So what I showed you before we're doing it at load time
Dialogue: 0,1:07:21.78,1:07:27.39,English,,0,0,0,,But you can also arbitrarily decide to to load link and
Dialogue: 0,1:07:27.39,1:07:34.68,English,,0,0,0,,Call a function from a shared from a from any function defined in a .so file
Dialogue: 0,1:07:35.94,1:07:41.36,English,,0,0,0,,And the way you do it is there's a there's an interface called the dl open
Dialogue: 0,1:07:41.84,1:07:44.90,English,,0,0,0,,That's in lib C that allows you to do this
Dialogue: 0,1:07:45.76,1:07:52.58,English,,0,0,0,,This and so let's say we want to this is this is our main program and just like before we want to call addvec
Dialogue: 0,1:07:53.28,1:07:57.24,English,,0,0,0,,Okay but addvec now is defined in it in a .so file
Dialogue: 0,1:07:57.92,1:08:00.98,English,,0,0,0,,The exact same .so file that we generated before
Dialogue: 0,1:08:02.32,1:08:08.72,English,,0,0,0,,When we compile so we'll call this dll.c when we compile this program ddl.c
Dialogue: 0,1:08:10.52,1:08:18.92,English,,0,0,0,,We have no we have no idea that it's going to call a function from from lib.so
Dialogue: 0,1:08:19.38,1:08:23.84,English,,0,0,0,,We just compile it as though a standalone C c program
Dialogue: 0,1:08:24.72,1:08:29.32,English,,0,0,0,,Within this program though we declare a pointer a function pointer called addvec
Dialogue: 0,1:08:30.10,1:08:32.64,English,,0,0,0,,And we give the prototype for this function
Dialogue: 0,1:08:32.70,1:08:39.14,English,,0,0,0,,It's pointers city so it's a two input arrays the output array on the size
Dialogue: 0,1:08:41.28,1:08:46.00,English,,0,0,0,,And then first we dynamically load the shared library that contains the function we want
Dialogue: 0,1:08:47.24,1:08:55.32,English,,0,0,0,,So we call dlopen and we say load up this this .so file into memory
Dialogue: 0,1:08:55.42,1:08:57.50,English,,0,0,0,,So that I can call a function
Dialogue: 0,1:08:57.96,1:09:02.20,English,,0,0,0,,But don't resolve you know don't worry don't worry about the
Dialogue: 0,1:09:02.20,1:09:06.28,English,,0,0,0,,Resolving the references to it functions until I actually tell you too
Dialogue: 0,1:09:07.24,1:09:09.00,English,,0,0,0,,That's the lazy part
Dialogue: 0,1:09:10.50,1:09:13.74,English,,0,0,0,,And so what what this deal open returns a handle
Dialogue: 0,1:09:14.40,1:09:18.06,English,,0,0,0,,That that then you use in subsequent calls okay
Dialogue: 0,1:09:19.08,1:09:24.98,English,,0,0,0,,So if we don't if the handle is null there was some kind of error like maybe maybe this data so file does exist
Dialogue: 0,1:09:27.76,1:09:34.32,English,,0,0,0,,So once we've opened that .so file then we use dlsym with the handle so this
Dialogue: 0,1:09:34.94,1:09:41.62,English,,0,0,0,,And then we we give it as we pass as a string the name of the function that we want to invoke
Dialogue: 0,1:09:43.26,1:09:47.90,English,,0,0,0,,And we get what we get back from dlsym as a pointer to that function
Dialogue: 0,1:09:48.90,1:09:53.96,English,,0,0,0,,And then we can we can use that function just like any other function so we can use that function pointer
Dialogue: 0,1:09:54.24,1:09:57.44,English,,0,0,0,,And we call it just as though it were a statically defined function
Dialogue: 0,1:09:58.86,1:10:01.88,English,,0,0,0,,So you can see this is real very powerful technique
Dialogue: 0,1:10:08.50,1:10:14.86,English,,0,0,0,,Okay so looks let's finish the the last little bits of the class
Dialogue: 0,1:10:14.86,1:10:21.02,English,,0,0,0,,I want to show you it to try to convince you that linking is is actually interesting which is kind of a hard sell sometime
Dialogue: 0,1:10:21.04,1:10:33.80,English,,0,0,0,,Yes question...yes...no it's that's how you know
Dialogue: 0,1:10:34.18,1:10:37.72,English,,0,0,0,,No you just it's it's declared as a function pointer
Dialogue: 0,1:10:37.72,1:10:43.46,English,,0,0,0,,And you then you just you just you just use the name of the function you don't have to dereference it
Dialogue: 0,1:10:45.42,1:10:52.90,English,,0,0,0,,Or you just you call it you call the function by just using that that that function pointer name okay
Dialogue: 0,1:10:53.42,1:10:54.38,English,,0,0,0,,Just like I did
Dialogue: 0,1:10:59.98,1:11:03.22,English,,0,0,0,,If you dereference it I just get back a pointer value
Dialogue: 0,1:11:04.08,1:11:07.80,English,,0,0,0,,You get back the address of that function
Dialogue: 0,1:11:09.70,1:11:15.64,English,,0,0,0,,All right so it's kind of a hard sell to that to convince you that linking is is interesting
Dialogue: 0,1:11:15.64,1:11:16.80,English,,0,0,0,,But I'm going to try
Dialogue: 0,1:11:17.30,1:11:22.52,English,,0,0,0,,Ok so there's there's this powerful technique called inner library inter positioning
Dialogue: 0,1:11:23.24,1:11:27.88,English,,0,0,0,,And the goal is to intercept function calls from from libraries
Dialogue: 0,1:11:28.64,1:11:32.60,English,,0,0,0,,And do something intercept them for for some reason
Dialogue: 0,1:11:33.30,1:11:37.24,English,,0,0,0,,Right so what we typically want to do is intercept a function call
Dialogue: 0,1:11:38.12,1:11:42.04,English,,0,0,0,,Maybe record some to some statistics or do some error checking
Dialogue: 0,1:11:42.56,1:11:45.94,English,,0,0,0,,And then call the real function as intended
Dialogue: 0,1:11:46.04,1:11:50.16,English,,0,0,0,,Right so so the idea is we're going to create wrappers
Dialogue: 0,1:11:52.00,1:12:00.18,English,,0,0,0,,And when the program when a program calls a function what we're going to do is we're going to execute its wrapper instead
Dialogue: 0,1:12:01.88,1:12:04.30,English,,0,0,0,,Okay and we're going to do it without changing any of the source
Dialogue: 0,1:12:09.68,1:12:13.34,English,,0,0,0,,Now there's a lot of reasons there's a lot of applications for this
Dialogue: 0,1:12:13.94,1:12:21.10,English,,0,0,0,,That the neatest one that that I know is that these facebook engineers
Dialogue: 0,1:12:21.56,1:12:25.30,English,,0,0,0,,So we're trying to deal with this year-long bug in the facebook iphone app
Dialogue: 0,1:12:26.10,1:12:28.20,English,,0,0,0,,And nobody could figure out what was going on
Dialogue: 0,1:12:29.28,1:12:31.86,English,,0,0,0,,And they figured it out using library inter positioning
Dialogue: 0,1:12:32.28,1:12:37.40,English,,0,0,0,,They figured out that there was something in the network stack writing to the wrong location
Dialogue: 0,1:12:37.40,1:12:43.26,English,,0,0,0,,They figured it out by intercepting all the calls from their facebook app  that did rights
Dialogue: 0,1:12:43.90,1:12:47.04,English,,0,0,0,,So things like write write to the ep right
Dialogue: 0,1:12:47.96,1:12:51.02,English,,0,0,0,,So they just they intercepted all those calls and then they were able to
Dialogue: 0,1:12:51.02,1:12:54.06,English,,0,0,0,,To when they looked at the arguments and how those functions were being called
Dialogue: 0,1:12:54.26,1:12:55.94,English,,0,0,0,,They determine the air
Dialogue: 0,1:13:00.04,1:13:02.54,English,,0,0,0,,You can also use it for monitoring and profiling like
Dialogue: 0,1:13:02.54,1:13:07.80,English,,0,0,0,,So if you want to know like how many times different functions get called you can you can do you can interpose
Dialogue: 0,1:13:08.34,1:13:12.64,English,,0,0,0,,We use it for for generating address traces
Dialogue: 0,1:13:12.70,1:13:17.46,English,,0,0,0,,So you're malloc when you do your malloc lab later in the semester
Dialogue: 0,1:13:17.80,1:13:22.76,English,,0,0,0,,You're going to be evaluating your malloc using a traces
Dialogue: 0,1:13:22.76,1:13:27.36,English,,0,0,0,,That we generated from real programs using this inter positioning technique
Dialogue: 0,1:13:27.62,1:13:34.08,English,,0,0,0,,Right so we we enter post on all the malloc and free calls in like netscape
Dialogue: 0,1:13:35.62,1:13:39.18,English,,0,0,0,,And then we just recorded what addresses and and sizes
Dialogue: 0,1:13:39.64,1:13:44.88,English,,0,0,0,,Malik was was returning and what what blocks free was freeing up
Dialogue: 0,1:13:45.30,1:13:51.84,English,,0,0,0,,And we just created a trace of those and and then so let me show you how you would do this
Dialogue: 0,1:13:54.00,1:13:56.24,English,,0,0,0,,So the idea let's say we have this main program
Dialogue: 0,1:13:56.26,1:13:59.54,English,,0,0,0,,And the idea is to trace all the malloc and free calls
Dialogue: 0,1:13:59.54,1:14:02.38,English,,0,0,0,,So there's one malloc call and there's one free call
Dialogue: 0,1:14:03.16,1:14:07.18,English,,0,0,0,,And we want to know what these addresses are and we want to know what these sizes are
Dialogue: 0,1:14:08.48,1:14:12.50,English,,0,0,0,,So we can do this at either compile time link time or run time
Dialogue: 0,1:14:13.80,1:14:15.20,English,,0,0,0,,To do it at compile time
Dialogue: 0,1:14:16.02,1:14:19.90,English,,0,0,0,,We first write wrapper functions called my malloc and my free
Dialogue: 0,1:14:20.44,1:14:23.52,English,,0,0,0,,Where my malloc call most the real malloc function
Dialogue: 0,1:14:24.08,1:14:30.82,English,,0,0,0,,And then it prints out the the size that it was called and the the address that malloc returned
Dialogue: 0,1:14:31.40,1:14:35.60,English,,0,0,0,,Okay so this when we run our program it will it will print out these all these addresses
Dialogue: 0,1:14:35.60,1:14:37.36,English,,0,0,0,,And it does the same thing for free
Dialogue: 0,1:14:38.18,1:14:41.46,English,,0,0,0,,And then here's the trick in malloc.h
Dialogue: 0,1:14:42.26,1:14:49.20,English,,0,0,0,,We we define malloc to be my malloc  okay and free to be my free
Dialogue: 0,1:14:49.52,1:14:53.34,English,,0,0,0,,And then we give the prototype for it so the compiler doesn't get confused
Dialogue: 0,1:14:54.14,1:14:58.10,English,,0,0,0,,And then we can pi might we compile my malloc C into a .o file
Dialogue: 0,1:14:59.22,1:15:03.54,English,,0,0,0,,And then we call week then we complete we call our program
Dialogue: 0,1:15:03.54,1:15:10.74,English,,0,0,0,,Which is is our main program int dot C for inner positioning
Dialogue: 0,1:15:11.72,1:15:13.70,English,,0,0,0,,And we call that and here's the trick
Dialogue: 0,1:15:14.58,1:15:18.14,English,,0,0,0,,We call it with the - cap I argument
Dialogue: 0,1:15:18.74,1:15:22.22,English,,0,0,0,,And we say look for any include files in the current directory
Dialogue: 0,1:15:22.56,1:15:29.94,English,,0,0,0,,Okay so this was similar to that el - cap el argument
Dialogue: 0,1:15:30.90,1:15:35.12,English,,0,0,0,,But because we tell GCC to look in the current directory first
Dialogue: 0,1:15:35.80,1:15:38.20,English,,0,0,0,,So this is sort of where the inner positioning happens
Dialogue: 0,1:15:38.68,1:15:44.60,English,,0,0,0,,This because when it does that it's going to it's going to find a
Dialogue: 0,1:15:45.82,1:15:48.28,English,,0,0,0,,It's going to find a library called malloc.h
Dialogue: 0,1:15:49.44,1:15:51.54,English,,0,0,0,,I mean .h file called malloc.h
Dialogue: 0,1:15:52.02,1:15:57.26,English,,0,0,0,,And so all the calls to malloc will be translated by the C preprocessor to my malloc
Dialogue: 0,1:15:58.76,1:16:04.90,English,,0,0,0,,So when we run this it prints out the the trip malloc and free trace
Dialogue: 0,1:16:07.86,1:16:09.60,English,,0,0,0,,Now we can also do this at link time
Dialogue: 0,1:16:09.60,1:16:14.38,English,,0,0,0,,So we can tell C in order to do this we had to get access to the
Dialogue: 0,1:16:15.14,1:16:19.24,English,,0,0,0,,We had to compile the program we didn't have to change it but we had to compile it
Dialogue: 0,1:16:19.94,1:16:27.08,English,,0,0,0,,We can use link time at our positioning if to avoid that that that compilation
Dialogue: 0,1:16:28.40,1:16:34.10,English,,0,0,0,,So the way this works we define our wrapper functions with this special name underscore underscore wrap malloc
Dialogue: 0,1:16:35.20,1:16:38.96,English,,0,0,0,,And this calls the real malloc function and then prints out the information
Dialogue: 0,1:16:41.14,1:16:51.16,English,,0,0,0,,And then at link time then we do the inter positioning by calling the linker with this special -wl  argument
Dialogue: 0,1:16:52.14,1:16:57.72,English,,0,0,0,,And so what this does the the -wl flag to GCC says hey
Dialogue: 0,1:16:58.34,1:17:05.00,English,,0,0,0,,Take what follows the argument that follows replace all the commas with spaces
Dialogue: 0,1:17:05.00,1:17:07.50,English,,0,0,0,,And then invoke the linker with this argument
Dialogue: 0,1:17:07.72,1:17:11.40,English,,0,0,0,,Okay so what we're doing is passing a linker arguments to the linker
Dialogue: 0,1:17:12.28,1:17:15.54,English,,0,0,0,,And this - - wrap argument to the linker
Dialogue: 0,1:17:16.44,1:17:23.76,English,,0,0,0,,It tells the linker to resolve all references to malik as underscore underscore wrap malik
Dialogue: 0,1:17:24.80,1:17:30.86,English,,0,0,0,,And all references to underscore real malik - should be resolved as malik
Dialogue: 0,1:17:32.68,1:17:37.74,English,,0,0,0,,Okay so anywhere in the program what we call malik it'll be resolved to underscore underscore wrap malik
Dialogue: 0,1:17:38.24,1:17:41.92,English,,0,0,0,,And it will invoke our wrapper and then the wrapper calls real malik
Dialogue: 0,1:17:42.54,1:17:50.70,English,,0,0,0,,Which which by because of this flag resolves to the the actual malik routine
Dialogue: 0,1:17:53.16,1:17:55.98,English,,0,0,0,,Now here you can also in the really the really amazing thing
Dialogue: 0,1:17:56.02,1:18:01.06,English,,0,0,0,,Is you can also do this inter positioning it load timer and run time  when the program is loaded
Dialogue: 0,1:18:01.08,1:18:05.52,English,,0,0,0,,So you don't even need access to the dot o files all you need is access to the executable
Dialogue: 0,1:18:06.66,1:18:09.50,English,,0,0,0,,Right and for every program we have access to the executable
Dialogue: 0,1:18:10.17,1:18:12.40,English,,0,0,0,,So think about that we can take any program
Dialogue: 0,1:18:13.08,1:18:17.24,English,,0,0,0,,And we can interpose on its library calls at runtime
Dialogue: 0,1:18:18.58,1:18:26.15,English,,0,0,0,,So the way we do this is we write the wrapper function now uses the dlsym call that we saw before
Dialogue: 0,1:18:27.62,1:18:32.10,English,,0,0,0,,And we call it with this special function the special argument called next
Dialogue: 0,1:18:33.70,1:18:39.08,English,,0,0,0,,And we silver and what this is saying is get the address of the real malloc
Dialogue: 0,1:18:40.26,1:18:43.98,English,,0,0,0,,Okay so and we're going to we're going to trick the linker into looking first
Dialogue: 0,1:18:44.70,1:18:47.90,English,,0,0,0,,To our our implementation of malloc
Dialogue: 0,1:18:48.60,1:18:55.00,English,,0,0,0,,But here we want the real one so we're telling it to get to look in the next place its next place that it would normally look
Dialogue: 0,1:18:55.78,1:18:59.52,English,,0,0,0,,And and and fetch the the address of malloc
Dialogue: 0,1:18:59.52,1:19:04.02,English,,0,0,0,,So the result is a pointer a function pointer called mallocp
Dialogue: 0,1:19:04.64,1:19:09.58,English,,0,0,0,,And then we can just call that function to get to call the lipsy malik
Dialogue: 0,1:19:09.92,1:19:12.28,English,,0,0,0,,And then print out the the data
Dialogue: 0,1:19:12.94,1:19:19.50,English,,0,0,0,,Okay we do the same thing for free.st. we use dlsym in exactly the same way for free
Dialogue: 0,1:19:20.68,1:19:25.22,English,,0,0,0,,And then the inter positioning now happens when the program is loaded
Dialogue: 0,1:19:26.56,1:19:31.92,English,,0,0,0,,So notice we built this our main program now in tar for run time inter positioning
Dialogue: 0,1:19:32.82,1:19:40.28,English,,0,0,0,,We built it I'm sorry we created our .so file mymalloc.so  using the shared argument
Dialogue: 0,1:19:41.56,1:19:43.92,English,,0,0,0,,And then and then we we compiled int
Dialogue: 0,1:19:44.82,1:19:48.24,English,,0,0,0,,Int.c into this executable called intr
Dialogue: 0,1:19:48.24,1:19:51.66,English,,0,0,0,,But notice there's no mention of mymalloc.so anywhere
Dialogue: 0,1:19:54.42,1:19:57.76,English,,0,0,0,,And now the inner positioning happens when we actually run the program
Dialogue: 0,1:19:58.68,1:20:13.06,English,,0,0,0,,And we do it we we affect the the inner positioning by setting an environment variable  called ld-preload  to mymalloc.so
Dialogue: 0,1:20:13.42,1:20:17.82,English,,0,0,0,,And so what this is a environment variable that tells the dynamic linker
Dialogue: 0,1:20:18.60,1:20:26.20,English,,0,0,0,,To look first in the the value it looked first in the the value of ld preload is a list of locations
Dialogue: 0,1:20:26.62,1:20:29.64,English,,0,0,0,,Look first in those locations when to resolve references
Dialogue: 0,1:20:29.98,1:20:33.90,English,,0,0,0,,And only only later look in the normal system places
Dialogue: 0,1:20:34.86,1:20:38.95,English,,0,0,0,,So we're saying to look in mymalloc.so unresolved references first
Dialogue: 0,1:20:39.46,1:20:44.44,English,,0,0,0,,And then and then we're invoking so this is in bash this is how you initialize an environment variable
Dialogue: 0,1:20:44.68,1:20:50.54,English,,0,0,0,,So we're initializing it to mymalloc.so and then we're loading and running the program
Dialogue: 0,1:20:51.86,1:21:00.08,English,,0,0,0,,And so the ld so all the references to malloc get turned into the references to the wrapper function
Dialogue: 0,1:21:01.34,1:21:05.34,English,,0,0,0,,The malloc function that we defined in in our program okay
Dialogue: 0,1:21:07.74,1:21:12.46,English,,0,0,0,,So that's uh so that's it so that that inter positioning is a really cool technique
Dialogue: 0,1:21:12.60,1:21:15.86,English,,0,0,0,,And it's only it's only possible because of linkers so
Dialogue: 0,1:21:17.46,1:21:23.86,English,,0,0,0,,Alright so good we'll see you on on thursday and good luck with your cache labs
Dialogue: 0,1:21:17.46,1:21:23.86,English,,0,0,0,,alright so good we'll see you on on Thursday and good luck with your cache labs
