[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video File: ../../../Desktop/csapp/Lecture 10  Program Optimization.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 858
Active Line: 862
Video Position: 132257

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:04.92,csapp,,0,0,0,,so we've now gotten through all the lectures on machine code
Dialogue: 0,0:00:04.92,0:00:07.00,csapp,,0,0,0,,and we're starting to talk about...
Dialogue: 0,0:00:07.34,0:00:10.12,csapp,,0,0,0,,okay now that you know this stuff what can you do with it
Dialogue: 0,0:00:10.88,0:00:14.30,csapp,,0,0,0,,and this lecture is along the lines of that
Dialogue: 0,0:00:14.30,0:00:17.64,csapp,,0,0,0,,this is sort of what you are now empowered to do now that
Dialogue: 0,0:00:17.64,0:00:21.06,csapp,,0,0,0,,you can look at an understand machine code
Dialogue: 0,0:00:21.44,0:00:26.20,csapp,,0,0,0,,this material is a little this actually there's a whole chapter
Dialogue: 0,0:00:26.20,0:00:29.10,csapp,,0,0,0,,of the book chapter five on performance optimization
Dialogue: 0,0:00:29.10,0:00:33.11,csapp,,0,0,0,,and we're only going to do one lecture on it and we don't have any labs
Dialogue: 0,0:00:33.28,0:00:38.36,csapp,,0,0,0,,unfortunately that really get you to push your limits on this which is too bad
Dialogue: 0,0:00:38.36,0:00:43.08,csapp,,0,0,0,,because it's a very interesting topic and one I think you'd find yourself well equipped for
Dialogue: 0,0:00:43.56,0:00:50.26,csapp,,0,0,0,,there are typically a few small exam problems that are sort of based on some of the material here
Dialogue: 0,0:00:50.26,0:00:52.12,csapp,,0,0,0,,you'll find in old exams
Dialogue: 0,0:00:52.72,0:00:56.02,csapp,,0,0,0,,but really the idea is how can I make programs run fast
Dialogue: 0,0:00:56.66,0:01:02.30,csapp,,0,0,0,,given that I I sort of know what algorithm I'm using
Dialogue: 0,0:01:02.30,0:01:05.66,csapp,,0,0,0,,and I've perhaps gotten a program that runs
Dialogue: 0,0:01:05.96,0:01:12.34,csapp,,0,0,0,,how can I make it run faster and one of the the themes of it
Dialogue: 0,0:01:12.66,0:01:18.16,csapp,,0,0,0,,is you can sort of do this in layers you can sort of first of all do the stuff to avoid
Dialogue: 0,0:01:21.30,0:01:22.10,csapp,,0,0,0,,a sort of
Dialogue: 0,0:01:23.34,0:01:29.52,csapp,,0,0,0,,things that make programs run slow across a wide variety of machines  and just make your
Dialogue: 0,0:01:29.68,0:01:34.50,csapp,,0,0,0,, and I would describe it as making your code more compiler friendly
Dialogue: 0,0:01:34.50,0:01:36.04,csapp,,0,0,0,, and we'll talk about what that means
Dialogue: 0,0:01:36.60,0:01:40.74,csapp,,0,0,0,,and you have to have some understanding and appreciation for what compilers are good
Dialogue: 0,0:01:41.20,0:01:43.94,csapp,,0,0,0,,at and what they're not good at to be able to do that
Dialogue: 0,0:01:43.94,0:01:48.82,csapp,,0,0,0,, and I describe these is the kind of things that you should just be in the habit of
Dialogue: 0,0:01:49.20,0:01:53.24,csapp,,0,0,0,,when you write programs writing this code that I'll describe is compiler friendly
Dialogue: 0,0:01:53.92,0:02:00.02,csapp,,0,0,0,,and then the next level is okay given that I've sort of taken away
Dialogue: 0,0:02:00.34,0:02:03.04,csapp,,0,0,0,,the things that really shouldn't have been there in the first place
Dialogue: 0,0:02:03.40,0:02:06.38,csapp,,0,0,0,,now how can I make my programs run faster
Dialogue: 0,0:02:06.38,0:02:12.46,csapp,,0,0,0,,in particular how can I adapt it to the capabilities of the the types of machines
Dialogue: 0,0:02:12.46,0:02:14.12,csapp,,0,0,0,,that this program is going to run on
Dialogue: 0,0:02:14.44,0:02:18.64,csapp,,0,0,0,, and that can again go from ones that will generally make programs run fast
Dialogue: 0,0:02:18.64,0:02:24.32,csapp,,0,0,0,,across a wide variety of machines to ones that become very specific and very specific
Dialogue: 0,0:02:24.46,0:02:30.08,csapp,,0,0,0,, is a risky thing because even in the world of  say x86 machines
Dialogue: 0,0:02:30.32,0:02:34.56,csapp,,0,0,0,,there's quite a variety of them that are available at any given point in time
Dialogue: 0,0:02:35.04,0:02:37.02,csapp,,0,0,0,,and they evolve over time as well
Dialogue: 0,0:02:37.02,0:02:44.44,csapp,,0,0,0,,so you can make a program run really fast on one particular model of one x86 processor
Dialogue: 0,0:02:44.82,0:02:48.56,csapp,,0,0,0,,but it might not that if you're trying too hard
Dialogue: 0,0:02:48.56,0:02:51.54,csapp,,0,0,0,,you'll find your effort is sort of wasted when you move it to another
Dialogue: 0,0:02:51.94,0:02:57.38,csapp,,0,0,0,,on the other hand these general ideas I'm going to describe actually work across quite a range of machines
Dialogue: 0,0:02:58.62,0:03:01.10,csapp,,0,0,0,,so and I'll talk about that more as we go along
Dialogue: 0,0:03:02.96,0:03:06.32,csapp,,0,0,0,,so it used to be in the bad old days that
Dialogue: 0,0:03:06.32,0:03:09.88,csapp,,0,0,0,,if you wanted a program to run fast you had to write an assembly code
Dialogue: 0,0:03:10.20,0:03:13.60,csapp,,0,0,0,,and that's just plain not true anymore and if anyone tells you it's true
Dialogue: 0,0:03:13.94,0:03:16.70,csapp,,0,0,0,, it's because they're full of it it's just not true
Dialogue: 0,0:03:17.04,0:03:23.32,csapp,,0,0,0,,unless except for the exceptional case where you're running on a very small resource constrained machine
Dialogue: 0,0:03:23.98,0:03:27.56,csapp,,0,0,0,,such as a very small underpowered embedded system
Dialogue: 0,0:03:29.09,0:03:32.56,csapp,,0,0,0,,so let's just assume that we're going to use a compiler
Dialogue: 0,0:03:33.02,0:03:36.66,csapp,,0,0,0,,and we'll assume for this course we're going to use GCC because it's generally available
Dialogue: 0,0:03:37.06,0:03:44.40,csapp,,0,0,0,,it's not actually the best compiler out there Intel makes a compiler that costs money to license and stuff
Dialogue: 0,0:03:44.40,0:03:49.88,csapp,,0,0,0,,but it's it really can do some amazing things and other compilers exist
Dialogue: 0,0:03:49.88,0:03:53.96,csapp,,0,0,0,,but GCC is sort of a a good enough compiler for most people
Dialogue: 0,0:03:56.80,0:04:02.80,csapp,,0,0,0,,but there's some features of some things that sort of puzzle compilers that they don't really understand
Dialogue: 0,0:04:02.80,0:04:07.80,csapp,,0,0,0,, compilers don't really understand for example that the numbers you're using
Dialogue: 0,0:04:08.24,0:04:13.14,csapp,,0,0,0,,when you say it's an INT might actually range over a much smaller set of values
Dialogue: 0,0:04:14.18,0:04:18.92,csapp,,0,0,0,,and they have a very hard time understanding memory referencing patterns
Dialogue: 0,0:04:19.30,0:04:21.18,csapp,,0,0,0,,and the effect of procedure calls
Dialogue: 0,0:04:26.50,0:04:29.62,csapp,,0,0,0,,and so in general what happens with the compiler is it
Dialogue: 0,0:04:29.92,0:04:35.92,csapp,,0,0,0,,has a whole sort of cookbook of optimization strategies
Dialogue: 0,0:04:35.92,0:04:40.84,csapp,,0,0,0,,and some recipes for how to try out different strategies and apply them
Dialogue: 0,0:04:41.44,0:04:46.14,csapp,,0,0,0,,but in general if it ever feels like this code is something that
Dialogue: 0,0:04:46.14,0:04:50.14,csapp,,0,0,0,, it doesn't feel confident about being able to make certain transformations
Dialogue: 0,0:04:50.48,0:04:56.98,csapp,,0,0,0,,that it just won't it will keep things sort of a more direct implementation of exactly what you described
Dialogue: 0,0:04:57.36,0:05:00.04,csapp,,0,0,0,,and we'll show examples of that as we go along
Dialogue: 0,0:05:00.70,0:05:06.82,csapp,,0,0,0,,so the thing about it optimizing compilers it always has a fallback position which is to not optimize
Dialogue: 0,0:05:07.42,0:05:11.86,csapp,,0,0,0,, and sometimes that will get in trouble if you want your program to run faster
Dialogue: 0,0:05:12.28,0:05:19.10,csapp,,0,0,0,,and the compiler just in its own conservative white decides not to do that optimization
Dialogue: 0,0:05:19.30,0:05:22.18,csapp,,0,0,0,,and one of the tricks that you'll find is pretty useful
Dialogue: 0,0:05:22.56,0:05:25.80,csapp,,0,0,0,,now that you can read assembly code is you run the compiler
Dialogue: 0,0:05:26.22,0:05:28.32,csapp,,0,0,0,,you see what optimizations it does
Dialogue: 0,0:05:28.90,0:05:33.38,csapp,,0,0,0,,and if it doesn't make something that you expect it to be able to do you go back and figure it out
Dialogue: 0,0:05:33.44,0:05:42.30,csapp,,0,0,0,,so it's very common by the way to rewrite your program in the same language
Dialogue: 0,0:05:42.30,0:05:49.74,csapp,,0,0,0,,and sort of tune it in and up to make it run faster to make it more compiler friendly
Dialogue: 0,0:05:49.74,0:05:51.32,csapp,,0,0,0,,that's there's nothing wrong with that
Dialogue: 0,0:05:51.78,0:05:55.96,csapp,,0,0,0,,as long as you don't then just totally obliterate the program and make it totally illegible
Dialogue: 0,0:05:57.66,0:06:01.50,csapp,,0,0,0,, so let's just describe some sort of general optimizations
Dialogue: 0,0:06:01.50,0:06:06.82,csapp,,0,0,0,,and you've actually seen versions of this in some of the assembly code we've already looked at
Dialogue: 0,0:06:08.02,0:06:13.70,csapp,,0,0,0,,oh and I'll use mostly sort of examples from multi-dimensional arrays
Dialogue: 0,0:06:13.70,0:06:17.68,csapp,,0,0,0,,because those are actually fairly easy optimization type of tasks
Dialogue: 0,0:06:18.40,0:06:21.16,csapp,,0,0,0,,but these applied to other types of program as well
Dialogue: 0,0:06:21.98,0:06:29.58,csapp,,0,0,0,,so you saw before when we described how to do array indexing in multi-dimensional arrays
Dialogue: 0,0:06:30.22,0:06:36.63,csapp,,0,0,0,,that the old style of code was if you had a a variable sized array
Dialogue: 0,0:06:36.84,0:06:40.78,csapp,,0,0,0,,it was up to you the programmer to write the formula
Dialogue: 0,0:06:40.88,0:06:46.66,csapp,,0,0,0,,of how you convert row I column J into a position in a one-dimensional array
Dialogue: 0,0:06:47.58,0:06:53.46,csapp,,0,0,0,,so remember it's just the number of columns times the row number plus the column numbers standard one
Dialogue: 0,0:06:54.12,0:06:57.68,csapp,,0,0,0,,so that would give this would be pretty typical code
Dialogue: 0,0:06:57.68,0:07:00.72,csapp,,0,0,0,,then it would give you a notation like this
Dialogue: 0,0:07:00.72,0:07:09.60,csapp,,0,0,0,,if you wanted to set one row in array a to the values in a one dimensional row of B
Dialogue: 0,0:07:10.98,0:07:13.08,csapp,,0,0,0,,this is a code you'd write
Dialogue: 0,0:07:13.52,0:07:16.28,csapp,,0,0,0,,and the main observation is within this loop
Dialogue: 0,0:07:16.74,0:07:19.04,csapp,,0,0,0,, the only variable that's changing is J
Dialogue: 0,0:07:20.24,0:07:25.82,csapp,,0,0,0,,and so from the array perspective your this computation n* i··
Dialogue: 0,0:07:25.82,0:07:28.56,csapp,,0,0,0,,if it gets repeated over and over again within this loop
Dialogue: 0,0:07:29.22,0:07:32.52,csapp,,0,0,0,, then you're just wasting it's a wasted effort
Dialogue: 0,0:07:32.92,0:07:35.16,csapp,,0,0,0,, so you can do what's called code motion
Dialogue: 0,0:07:35.42,0:07:40.54,csapp,,0,0,0,,which is to pre compute the value of n*i outside of the loop
Dialogue: 0,0:07:40.96,0:07:45.74,csapp,,0,0,0,,and then use it over and over again inside and compilers will generally do this
Dialogue: 0,0:07:47.36,0:07:53.78,csapp,,0,0,0,,when they can detect for example that it's a array access code and it has this technique
Dialogue: 0,0:07:54.14,0:07:56.84,csapp,,0,0,0,, it will generally do optimizations like this
Dialogue: 0,0:07:56.84,0:08:03.42,csapp,,0,0,0,, if you set say an optimization level of 1 or higher to GCC
Dialogue: 0,0:08:07.14,0:08:14.42,csapp,,0,0,0,,and we can see this in fact this is this code that I ran it through GCC using optimization 1
Dialogue: 0,0:08:14.68,0:08:19.22,csapp,,0,0,0,,and you see as this read instruction shows it boosted this multiplication outside of the loop
Dialogue: 0,0:08:20.60,0:08:25.90,csapp,,0,0,0,,and it's a little as if you actually this code does even more
Dialogue: 0,0:08:25.90,0:08:29.50,csapp,,0,0,0,,it turns the code into something that looks more like a pointer code
Dialogue: 0,0:08:29.78,0:08:38.34,csapp,,0,0,0,,accessing array a and stepping through that element by element  of the array
Dialogue: 0,0:08:39.62,0:08:42.46,csapp,,0,0,0,,another one and we've seen this already that when
Dialogue: 0,0:08:42.94,0:08:49.30,csapp,,0,0,0,,GCC turns a multiplication or a division by shifting and adding an operations like that
Dialogue: 0,0:08:49.67,0:08:51.97,csapp,,0,0,0,,multiplication or division by constants
Dialogue: 0,0:08:52.12,0:08:55.90,csapp,,0,0,0,,we've seen examples of that and a similar one would happen if
Dialogue: 0,0:09:01.58,0:09:09.82,csapp,,0,0,0,, if we took that program I showed before  and applied it to every row
Dialogue: 0,0:09:09.96,0:09:16.78,csapp,,0,0,0,,so we want to set for array a we wanted to set every one of its rows to the value of the one dimensional array B
Dialogue: 0,0:09:19.22,0:09:24.80,csapp,,0,0,0,,then again if we we took that code we boosted the end times I in there
Dialogue: 0,0:09:25.62,0:09:31.32,csapp,,0,0,0,, so now the inner loop is good but you realize that this multiplication isn't necessary either
Dialogue: 0,0:09:31.32,0:09:36.20,csapp,,0,0,0,,because what we're doing from I equals 0 to I equals 1 to I equals 2 is
Dialogue: 0,0:09:36.68,0:09:41.26,csapp,,0,0,0,,is we're just increasing the parameter ni by we're adding m to it
Dialogue: 0,0:09:41.86,0:09:49.12,csapp,,0,0,0,,so we can and that's called a reduction in strength we've taken a multiplication and turned it into addition
Dialogue: 0,0:09:49.12,0:09:56.02,csapp,,0,0,0,,because there's some predictable pattern of how this variable ni is going to be updated
Dialogue: 0,0:09:56.34,0:10:02.30,csapp,,0,0,0,,another example and again array indexing is a good example for optimizations
Dialogue: 0,0:10:02.64,0:10:10.60,csapp,,0,0,0,,imagine we had a image that we represent as a two-dimensional array of pixel values
Dialogue: 0,0:10:11.38,0:10:15.58,csapp,,0,0,0,,and we want to do something that's what a filtering operation
Dialogue: 0,0:10:15.58,0:10:22.62,csapp,,0,0,0,,where we want to take the sum of the four neighbors of a given pixel north south east and west
Dialogue: 0,0:10:23.14,0:10:26.56,csapp,,0,0,0,, and average those together or sum them together
Dialogue: 0,0:10:27.68,0:10:37.20,csapp,,0,0,0,,and so the natural way you'd write this and see is to say I want usually i
Dialogue: 0,0:10:38.04,0:10:40.94,csapp,,0,0,0,,n images you count from the top down and so
Dialogue: 0,0:10:41.28,0:10:45.10,csapp,,0,0,0,, you'd say this is the the pixel above
Dialogue: 0,0:10:45.58,0:10:50.00,csapp,,0,0,0,,this is the pixel below this is the pixel to the left and this is the pixel to the right
Dialogue: 0,0:10:50.98,0:10:56.60,csapp,,0,0,0,,and if you do this in and just compile it straight through
Dialogue: 0,0:10:56.94,0:11:02.36,csapp,,0,0,0,,unfortunately it appears as if there's three different multiplications by n
Dialogue: 0,0:11:02.74,0:11:05.08,csapp,,0,0,0,,i-1, i+1 and i
Dialogue: 0,0:11:05.56,0:11:11.94,csapp,,0,0,0,,and if the compiler isn't too clever it won't realize that these are related to each other
Dialogue: 0,0:11:11.94,0:11:16.02,csapp,,0,0,0,, and it will issue three different multiply operations just to do this one pixel thing
Dialogue: 0,0:11:16.78,0:11:18.94,csapp,,0,0,0,,whereas if I'm a little more clever
Dialogue: 0,0:11:19.40,0:11:22.76,csapp,,0,0,0,,and this is one where I manually rewrote the code
Dialogue: 0,0:11:22.76,0:11:24.42,csapp,,0,0,0,,so the compiler would pick it up
Dialogue: 0,0:11:25.00,0:11:30.84,csapp,,0,0,0,,I'd say well if I on so I and J is I times n plus J
Dialogue: 0,0:11:31.52,0:11:37.36,csapp,,0,0,0,,and I can get the the pixel above the pixel below by shifting that
Dialogue: 0,0:11:37.46,0:11:39.74,csapp,,0,0,0,,off setting that by a value of M
Dialogue: 0,0:11:42.06,0:11:46.42,csapp,,0,0,0,,and then it will issue the code this will compile with the code with just one multiply
Dialogue: 0,0:11:46.54,0:11:51.36,csapp,,0,0,0,,and in general by the way multiply used to be a very expensive instruction
Dialogue: 0,0:11:51.80,0:11:57.20,csapp,,0,0,0,,nowadays is enough hardware resources that it takes about three clock cycles so it's not a huge deal
Dialogue: 0,0:11:57.74,0:12:02.38,csapp,,0,0,0,, but anytime you can take three multiplies and use just one instead that's generally a good idea
Dialogue: 0,0:12:02.38,0:12:08.54,csapp,,0,0,0,,question
Dialogue: 0,0:12:08.60,0:12:11.48,csapp,,0,0,0,,so the question is what if you're trying to optimize for space
Dialogue: 0,0:12:11.48,0:12:13.84,csapp,,0,0,0,,and there are a lot of optimizations that will
Dialogue: 0,0:12:14.54,0:12:19.48,csapp,,0,0,0,,make your code be bigger at the expense of in order to go faster right
Dialogue: 0,0:12:19.90,0:12:22.78,csapp,,0,0,0,,this one though I'd argue this is actually shorter code right
Dialogue: 0,0:12:24.10,0:12:26.30,csapp,,0,0,0,,and just look at the number of instructions so
Dialogue: 0,0:12:26.64,0:12:32.02,csapp,,0,0,0,,and usually so code you know that used to be a bigger concern when memory was sort of
Dialogue: 0,0:12:32.44,0:12:37.16,csapp,,0,0,0,,you know back the original IBM PC had 640 kilobytes of memory so
Dialogue: 0,0:12:37.56,0:12:42.34,csapp,,0,0,0,,in its maximum configuration and that was a big deal to actually buy it that much
Dialogue: 0,0:12:42.88,0:12:46.72,csapp,,0,0,0,,so you know back then that was a big deal memory but nowadays memory
Dialogue: 0,0:12:47.10,0:12:52.02,csapp,,0,0,0,,the size of the program is usually a pretty small fraction of what you're dealing with overall
Dialogue: 0,0:12:52.56,0:12:53.72,csapp,,0,0,0,,but it's a valid question
Dialogue: 0,0:12:57.14,0:13:02.80,csapp,,0,0,0,,okay so that just shows you an example and in general compilers are pretty good at doing
Dialogue: 0,0:13:03.26,0:13:07.92,csapp,,0,0,0,,those low-level optimizations like that if you write the code in a way that's reasonable
Dialogue: 0,0:13:08.40,0:13:13.58,csapp,,0,0,0,,but there's some other ones that the compiler and even a the fanciest compiler you can buy
Dialogue: 0,0:13:13.84,0:13:15.48,csapp,,0,0,0,,might not be able to figure it out
Dialogue: 0,0:13:15.90,0:13:20.70,csapp,,0,0,0,,and so I like to illustrate this with when the first term we ever taught 2:13
Dialogue: 0,0:13:21.16,0:13:26.08,csapp,,0,0,0,,I was looking at some lab a code
Dialogue: 0,0:13:26.08,0:13:29.32,csapp,,0,0,0,,that some of the students wrote and I was horrified about this code
Dialogue: 0,0:13:30.08,0:13:33.68,csapp,,0,0,0,, and I showed it to the TAS and none of them figured out what was wrong
Dialogue: 0,0:13:33.68,0:13:38.76,csapp,,0,0,0,,and I've shown it to many other highly-trained C programmers professionals
Dialogue: 0,0:13:39.04,0:13:40.70,csapp,,0,0,0,,they go looks ok to me
Dialogue: 0,0:13:42.22,0:13:45.40,csapp,,0,0,0,,so let's figure out what's why I was horrified by this code
Dialogue: 0,0:13:45.86,0:13:49.56,csapp,,0,0,0,,so the idea of this code is supposed to be pretty straightforward there's a string s
Dialogue: 0,0:13:50.18,0:13:56.64,csapp,,0,0,0,,and I want to convert that string all the characters in it to lowercase
Dialogue: 0,0:13:58.34,0:14:03.24,csapp,,0,0,0,,so I'm just going to read through the string and for each string position
Dialogue: 0,0:14:04.02,0:14:09.06,csapp,,0,0,0,, test that character and if it's somewhere between upper case a and upper case Z
Dialogue: 0,0:14:09.38,0:14:14.56,csapp,,0,0,0,,then I'm going to shift it to being between lowercase a and lowercase Z otherwise I will change it
Dialogue: 0,0:14:15.00,0:14:16.36,csapp,,0,0,0,,so pretty straightforward
Dialogue: 0,0:14:17.30,0:14:20.52,csapp,,0,0,0,,but if you run this you see that
Dialogue: 0,0:14:21.08,0:14:24.20,csapp,,0,0,0,, if you go up to half a million characters
Dialogue: 0,0:14:25.26,0:14:33.66,csapp,,0,0,0,,which might sound like a lot but it takes 240 or so so  so four minutes to run this code
Dialogue: 0,0:14:35.30,0:14:37.78,csapp,,0,0,0,,and you go well that's a pretty big string
Dialogue: 0,0:14:37.78,0:14:43.04,csapp,,0,0,0,,it's really not a big string you should be able to do lowercase conversion of a string
Dialogue: 0,0:14:43.04,0:14:44.92,csapp,,0,0,0,,and a lot less than four seconds
Dialogue: 0,0:14:45.26,0:14:48.68,csapp,,0,0,0,, and you also notice this growth is nonlinear it's quadratic
Dialogue: 0,0:14:48.68,0:14:52.78,csapp,,0,0,0,,it's growing as the square of the string length so this is not good
Dialogue: 0,0:14:53.48,0:14:58.74,csapp,,0,0,0,,and unfortunately it's the kind and by the way this is one of the that is very easy surprisingly easy
Dialogue: 0,0:14:58.74,0:15:03.64,csapp,,0,0,0,,to have programs that have some hidden performance bug
Dialogue: 0,0:15:03.90,0:15:06.46,csapp,,0,0,0,,that makes them run quadratic and you run test
Dialogue: 0,0:15:07.14,0:15:11.26,csapp,,0,0,0,,and you test for strings of 10,000 or less
Dialogue: 0,0:15:11.68,0:15:16.16,csapp,,0,0,0,,and it doesn't look like a big deal because the run time is insignificant so
Dialogue: 0,0:15:16.64,0:15:19.76,csapp,,0,0,0,,but then all of a sudden it hits a really bad case
Dialogue: 0,0:15:20.30,0:15:25.68,csapp,,0,0,0,,so this is a there's something wrong here
Dialogue: 0,0:15:26.30,0:15:28.72,csapp,,0,0,0,,so what's so bad about this program well
Dialogue: 0,0:15:29.82,0:15:35.36,csapp,,0,0,0,,the key is I went in a test like this of calling sterlin
Dialogue: 0,0:15:36.34,0:15:41.20,csapp,,0,0,0,,so the way it's determining whether it's reached the end of the string
Dialogue: 0,0:15:41.56,0:15:44.62,csapp,,0,0,0,, is by calling sterling to figure out how long the string is
Dialogue: 0,0:15:46.66,0:15:51.68,csapp,,0,0,0,,and the now and remember if we do the conversion of a four loop
Dialogue: 0,0:15:52.06,0:15:57.08,csapp,,0,0,0,, into a go to form like you've seen there's various ways to convert it
Dialogue: 0,0:15:57.08,0:16:00.98,csapp,,0,0,0,,but all of them the test gets built into the loop
Dialogue: 0,0:16:02.02,0:16:08.94,csapp,,0,0,0,,so the main feature of that is this call to sterling will happen every time you go through the loop
Dialogue: 0,0:16:11.14,0:16:13.28,csapp,,0,0,0,,and people overlook that fact
Dialogue: 0,0:16:14.18,0:16:17.66,csapp,,0,0,0,,when you look at the different parts of a four loop
Dialogue: 0,0:16:18.20,0:16:20.70,csapp,,0,0,0,, the initialization only gets executed once
Dialogue: 0,0:16:21.36,0:16:28.98,csapp,,0,0,0,,but both the tests and the update get incremented  get applied every time you run through the loop
Dialogue: 0,0:16:30.14,0:16:36.44,csapp,,0,0,0,, so if that's getting called as many times as there are characters in the loop  in the string right
Dialogue: 0,0:16:37.60,0:16:42.58,csapp,,0,0,0,,and now how does sterling work remember and see the only way you know how long a string is
Dialogue: 0,0:16:43.06,0:16:47.26,csapp,,0,0,0,,is to step through the whole thing and find the null character at the end
Dialogue: 0,0:16:48.18,0:16:52.28,csapp,,0,0,0,,so sterlin itself is a linear time operation in the string
Dialogue: 0,0:16:54.02,0:16:59.84,csapp,,0,0,0,,and you're doing that and so you're doing n calls to a function that takes time n
Dialogue: 0,0:17:00.80,0:17:04.66,csapp,,0,0,0,, if the string is getting shorter as you go but not very fast so
Dialogue: 0,0:17:05.10,0:17:07.06,csapp,,0,0,0,,basically that's quadratic performance
Dialogue: 0,0:17:09.98,0:17:12.46,csapp,,0,0,0,,and that explains why you get that runtime
Dialogue: 0,0:17:13.64,0:17:16.62,csapp,,0,0,0,, so in particular if I just make the following little change
Dialogue: 0,0:17:17.14,0:17:20.56,csapp,,0,0,0,,I introduce a local variable called Glen
Dialogue: 0,0:17:21.38,0:17:24.50,csapp,,0,0,0,,and I pre compute sterlin
Dialogue: 0,0:17:24.50,0:17:29.26,csapp,,0,0,0,,because the string isn't the length of the string isn't changing I'm just changing the characters
Dialogue: 0,0:17:30.10,0:17:34.46,csapp,,0,0,0,, in this string um then so the the program will do the same thing
Dialogue: 0,0:17:34.78,0:17:38.22,csapp,,0,0,0,,but now the runtime is so short it doesn't even show up
Dialogue: 0,0:17:38.60,0:17:43.68,csapp,,0,0,0,,it's it's maybe a second to do a million characters it's just not a big deal at all
Dialogue: 0,0:17:44.28,0:17:46.66,csapp,,0,0,0,,as it should be it's just running through
Dialogue: 0,0:17:47.22,0:17:53.72,csapp,,0,0,0,,and so that's just an example one of many that I've seen in my career where
Dialogue: 0,0:17:54.42,0:18:00.14,csapp,,0,0,0,, something that that seems almost insignificant turns out to be a serious performance problem
Dialogue: 0,0:18:03.58,0:18:06.34,csapp,,0,0,0,,so why couldn't a compiler figure this out
Dialogue: 0,0:18:07.62,0:18:09.58,csapp,,0,0,0,,why couldn't a smart compiler
Dialogue: 0,0:18:13.08,0:18:14.90,csapp,,0,0,0,,look at the original code
Dialogue: 0,0:18:17.14,0:18:22.68,csapp,,0,0,0,,and say look you know this is what the programmer wrote
Dialogue: 0,0:18:22.68,0:18:26.52,csapp,,0,0,0,,but I know a better way to do it I'll pre compute sterlin in advance
Dialogue: 0,0:18:27.36,0:18:32.66,csapp,,0,0,0,, well there's a couple reasons one is actually if you look at the code for strlen
Dialogue: 0,0:18:32.90,0:18:35.80,csapp,,0,0,0,,you see that it's actually modifying the string
Dialogue: 0,0:18:36.34,0:18:42.06,csapp,,0,0,0,,and strlen at this I mean the the code here is modifying the string and we're calling sterling on it
Dialogue: 0,0:18:42.20,0:18:48.24,csapp,,0,0,0,,so you'd have to be pretty careful to do the analysis the compiler would to figure out that
Dialogue: 0,0:18:48.72,0:18:50.72,csapp,,0,0,0,,even though the string is changing
Dialogue: 0,0:18:51.54,0:18:55.62,csapp,,0,0,0,,the result you're going to get from sterling is not going to change
Dialogue: 0,0:18:58.89,0:19:03.80,csapp,,0,0,0,,so that's a one reason
Dialogue: 0,0:19:04.26,0:19:12.54,csapp,,0,0,0,,and the second is well and how do how does the can the compiler be sure which version of sterling
Dialogue: 0,0:19:12.76,0:19:14.36,csapp,,0,0,0,,is actually going to get used
Dialogue: 0,0:19:14.80,0:19:18.66,csapp,,0,0,0,,you remember and see each of the files gets compiled separately
Dialogue: 0,0:19:19.00,0:19:23.68,csapp,,0,0,0,,and only afterwards does it all get brought together  in the linking phase
Dialogue: 0,0:19:23.68,0:19:26.70,csapp,,0,0,0,,and some of that even happens after the program gets started
Dialogue: 0,0:19:27.48,0:19:30.74,csapp,,0,0,0,,so even though there's a standard strlen function
Dialogue: 0,0:19:31.36,0:19:37.26,csapp,,0,0,0,,it's not necessarily the case that that's the one that will actually get used in the final program
Dialogue: 0,0:19:37.26,0:19:40.98,csapp,,0,0,0,, so the compiler really can't be sure of that
Dialogue: 0,0:19:41.18,0:19:46.70,csapp,,0,0,0,,in particular imagine I provided a sort of customized sterlin function like this
Dialogue: 0,0:19:47.40,0:19:53.26,csapp,,0,0,0,,that is keeping track of the sum of the lengths of all the strings that it's been called on
Dialogue: 0,0:19:53.72,0:19:57.12,csapp,,0,0,0,,or some other side effect like that that
Dialogue: 0,0:19:57.84,0:20:02.20,csapp,,0,0,0,,well that that program would produce a very different result than if
Dialogue: 0,0:20:02.78,0:20:05.86,csapp,,0,0,0,,if I whether or not I make the optimization
Dialogue: 0,0:20:05.98,0:20:08.78,csapp,,0,0,0,,so the compiler has to assume that
Dialogue: 0,0:20:09.28,0:20:12.36,csapp,,0,0,0,,sterling is just a black box that does whatever it does
Dialogue: 0,0:20:12.76,0:20:16.62,csapp,,0,0,0,,and can't make any assumptions about what how
Dialogue: 0,0:20:17.30,0:20:19.68,csapp,,0,0,0,,what side effects it might have and so forth
Dialogue: 0,0:20:19.72,0:20:26.52,csapp,,0,0,0,,so it won't make that optimization on any machine  even with the best compiler
Dialogue: 0,0:20:27.44,0:20:35.70,csapp,,0,0,0,,so that's just an example that and you can tell that I've gotten kind of sensitized to this
Dialogue: 0,0:20:36.24,0:20:39.06,csapp,,0,0,0,,so that I spot these but a lot of people don't
Dialogue: 0,0:20:42.52,0:20:44.12,csapp,,0,0,0,,um so let's look at this
Dialogue: 0,0:20:44.98,0:20:47.12,csapp,,0,0,0,,let's see
Dialogue: 0,0:20:50.78,0:20:54.28,csapp,,0,0,0,,oh this is another bad example a bad coding example
Dialogue: 0,0:20:55.50,0:21:06.36,csapp,,0,0,0,,of imagine I want to compute for a two-dimensional array a  and a one-dimensional array B
Dialogue: 0,0:21:06.76,0:21:14.90,csapp,,0,0,0,,I want to make B be B sub I be the sum of of all the elements in row I of  a
Dialogue: 0,0:21:15.94,0:21:20.46,csapp,,0,0,0,,so again this is a fairly obvious kind of way to write this program that you say
Dialogue: 0,0:21:21.60,0:21:27.64,csapp,,0,0,0,,say well B I cook 0 and I'm going to just accumulate it I'll step through the row and accumulate all the values
Dialogue: 0,0:21:28.40,0:21:33.12,csapp,,0,0,0,,and of course we know now we could improve this by moving i*n
Dialogue: 0,0:21:33.20,0:21:35.56,csapp,,0,0,0,,out and so forth I'm not trying to illustrate that
Dialogue: 0,0:21:36.64,0:21:39.52,csapp,,0,0,0,,but what you'll see in the program this is in the inner loop
Dialogue: 0,0:21:40.08,0:21:44.58,csapp,,0,0,0,,and we've looked briefly at some floating-point instructions
Dialogue: 0,0:21:44.82,0:21:47.18,csapp,,0,0,0,,and remember that the main feature of them is
Dialogue: 0,0:21:47.74,0:21:51.24,csapp,,0,0,0,,the move instructions look like the move ones you're familiar with
Dialogue: 0,0:21:51.50,0:21:56.08,csapp,,0,0,0,,except when we we put floating-point data in one of these %xmm registers
Dialogue: 0,0:21:57.32,0:22:02.42,csapp,,0,0,0,,so the main thing you see here is it's reading from memory
Dialogue: 0,0:22:02.94,0:22:06.42,csapp,,0,0,0,,it's adding something to it and then it's writing back to memory
Dialogue: 0,0:22:06.98,0:22:10.48,csapp,,0,0,0,, and what that memory location corresponds to B of i
Dialogue: 0,0:22:11.30,0:22:18.64,csapp,,0,0,0,,so what it means is every time through this loop it's having to do a memory read and a memory write  of B
Dialogue: 0,0:22:19.08,0:22:21.12,csapp,,0,0,0,,in addition to the memory read of a
Dialogue: 0,0:22:22.08,0:22:29.30,csapp,,0,0,0,,even though presumably B of AI is the same of value that you just updated it to
Dialogue: 0,0:22:30.46,0:22:33.56,csapp,,0,0,0,,well in the previous execution of this loop right
Dialogue: 0,0:22:33.82,0:22:37.10,csapp,,0,0,0,,so why do you have to why do you read it why do you write it out
Dialogue: 0,0:22:37.52,0:22:41.54,csapp,,0,0,0,,and then read it back in increment it and then again copy it back out
Dialogue: 0,0:22:41.54,0:22:47.78,csapp,,0,0,0,,why does it have to go keep jumping back and forth between memory and registers  over and over again
Dialogue: 0,0:22:49.28,0:22:53.24,csapp,,0,0,0,,well the reason is because in C you can't be sure
Dialogue: 0,0:22:53.78,0:22:57.86,csapp,,0,0,0,, that there isn't what's known as aliasing and I'm demonstrating it here
Dialogue: 0,0:22:58.24,0:23:04.54,csapp,,0,0,0,,imagine if row B is just declared to be that
Dialogue: 0,0:23:05.32,0:23:10.10,csapp,,0,0,0,,okay so imagine and you can do this and see this is legal C code
Dialogue: 0,0:23:10.50,0:23:16.34,csapp,,0,0,0,,you can make one memory data structure overlay another data structure
Dialogue: 0,0:23:16.34,0:23:21.02,csapp,,0,0,0,,that's referred to as aliasing when too soon as separate parts of
Dialogue: 0,0:23:21.02,0:23:24.54,csapp,,0,0,0,,the program are referring to the same locations in memory
Dialogue: 0,0:23:25.04,0:23:27.28,csapp,,0,0,0,, and the C compiler has no way of knowing
Dialogue: 0,0:23:29.14,0:23:35.44,csapp,,0,0,0,,whether there's a lot of work and optimizing compilers to detect aliasing possibilities
Dialogue: 0,0:23:35.80,0:23:38.30,csapp,,0,0,0,,but in general as to assume aliasing might happen
Dialogue: 0,0:23:38.84,0:23:47.72,csapp,,0,0,0,,so imagine this aliasing happened so that array B can corresponds then to this row of array a
Dialogue: 0,0:23:49.50,0:23:53.10,csapp,,0,0,0,,well then of course its initial value is 4, 8, 16
Dialogue: 0,0:23:53.10,0:23:55.20,csapp,,0,0,0,,but if you trace through what this code will do
Dialogue: 0,0:23:55.58,0:24:00.76,csapp,,0,0,0,,it has a sort of odd behavior that is probably not useful for anything
Dialogue: 0,0:24:01.28,0:24:09.30,csapp,,0,0,0,, but it just demonstrates that what will happen is as this as B gets updated
Dialogue: 0,0:24:09.66,0:24:15.46,csapp,,0,0,0,, it's effectively changing a and it's changing then what's being read during the summation
Dialogue: 0,0:24:17.70,0:24:20.86,csapp,,0,0,0,,and so this is a real possibility in C
Dialogue: 0,0:24:21.72,0:24:24.70,csapp,,0,0,0,,and so the compiler when it's given code like this
Dialogue: 0,0:24:25.72,0:24:32.18,csapp,,0,0,0,,it has to assume that the these two memory locations might court overlap each other
Dialogue: 0,0:24:32.22,0:24:37.68,csapp,,0,0,0,,so that's why it's carefully writing it out and then reading it back in over and over again
Dialogue: 0,0:24:40.50,0:24:45.32,csapp,,0,0,0,,and so if I just rewrite this code by introducing again a local variable
Dialogue: 0,0:24:46.20,0:24:48.44,csapp,,0,0,0,,and accumulating in that local variable
Dialogue: 0,0:24:49.06,0:24:52.98,csapp,,0,0,0,,and then only at the end do I sign that to B sub
Dialogue: 0,0:24:53.64,0:24:57.18,csapp,,0,0,0,,I then you'll see this exact same loop all of a sudden gets a lot simpler
Dialogue: 0,0:24:57.24,0:25:02.82,csapp,,0,0,0,,it's just a read floating point read an ad to do that
Dialogue: 0,0:25:03.80,0:25:12.90,csapp,,0,0,0,,and we'll see in fact the memory is actually one of the limiting perform performance limiters in a program
Dialogue: 0,0:25:12.90,0:25:16.71,csapp,,0,0,0,,so this is won't be a significantly faster
Dialogue: 0,0:25:16.88,0:25:22.08,csapp,,0,0,0,,and again that's something that you as a programmer would hardly think is a big deal
Dialogue: 0,0:25:23.08,0:25:25.32,csapp,,0,0,0,, but the C compiler can't do that in general
Dialogue: 0,0:25:25.56,0:25:30.62,csapp,,0,0,0,,because it can't determine in advance what possible aliasing there can be
Dialogue: 0,0:25:35.20,0:25:41.84,csapp,,0,0,0,,so as is these two examples say sort of get in the habit of introducing local variables  and using them
Dialogue: 0,0:25:42.12,0:25:47.74,csapp,,0,0,0,,and it's your way of telling the compiler don't call the same function over and over again
Dialogue: 0,0:25:47.74,0:25:50.70,csapp,,0,0,0,,don't read and write the same memory location over and over again
Dialogue: 0,0:25:50.70,0:25:53.38,csapp,,0,0,0,, just hold it in a temporary one
Dialogue: 0,0:25:53.58,0:25:58.26,csapp,,0,0,0,,and then it will automatically allocate a register and store it in that register and everything will be good
Dialogue: 0,0:26:01.40,0:26:09.88,csapp,,0,0,0,,okay so that's sort of the the kind of what we call optimization blockers the kind of things that
Dialogue: 0,0:26:10.40,0:26:12.48,csapp,,0,0,0,, you as a programmer can make a difference on
Dialogue: 0,0:26:12.48,0:26:17.10,csapp,,0,0,0,,and the main blockers are memory referencing aliasing and function calls
Dialogue: 0,0:26:17.60,0:26:21.54,csapp,,0,0,0,,and sort of understanding what might happen in that function call
Dialogue: 0,0:26:22.38,0:26:24.70,csapp,,0,0,0,,and so now what we're going to do is transition
Dialogue: 0,0:26:24.82,0:26:48.50,csapp,,0,0,0,,question equals three of this seem to be I think these two makes a distinction
Dialogue: 0,0:26:48.78,0:26:51.36,csapp,,0,0,0,, oh no no this is Alan C code
Dialogue: 0,0:26:53.96,0:26:57.12,csapp,,0,0,0,,I'm sure this is known C code because it ran
Dialogue: 0,0:26:59.86,0:27:08.50,csapp,,0,0,0,,so this is initializing calling it an array B remember these are in stars these aren't two-dimensional arrays right
Dialogue: 0,0:27:11.24,0:27:14.82,csapp,,0,0,0,, so this is saying a is now a
Dialogue: 0,0:27:15.80,0:27:19.72,csapp,,0,0,0,, think of it as a linear array of four elements of nine elements
Dialogue: 0,0:27:20.38,0:27:24.68,csapp,,0,0,0,,and a plus three is just to go in three
Dialogue: 0,0:27:25.02,0:27:28.80,csapp,,0,0,0,,so this is it is declaring B is not a pointer it's an array
Dialogue: 0,0:27:29.10,0:27:33.14,csapp,,0,0,0,,but remember with an array you can refuse that the name of that array
Dialogue: 0,0:27:33.14,0:27:38.02,csapp,,0,0,0,,as a reference to a pointer a readable reference not a writable reference right
Dialogue: 0,0:27:38.34,0:27:44.54,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:27:44.72,0:27:48.02,csapp,,0,0,0,,right for this exact code well I'll double check it
Dialogue: 0,0:27:48.02,0:28:05.78,csapp,,0,0,0,, this design of the seafront language use null terminated strange instead of like hot dogs ice cream
Dialogue: 0,0:28:05.80,0:28:08.58,csapp,,0,0,0,,so the question is why to see use null terminated strings
Dialogue: 0,0:28:09.20,0:28:14.28,csapp,,0,0,0,,and it it does and it might be a bad decision for multiple reasons right but
Dialogue: 0,0:28:14.84,0:28:22.12,csapp,,0,0,0,,I think in general think of C was somebody who had or a couple people
Dialogue: 0,0:28:22.12,0:28:28.16,csapp,,0,0,0,,who had been writing a lot of assembly code and wanted to lift up that level
Dialogue: 0,0:28:28.16,0:28:30.80,csapp,,0,0,0,, so they weren't writing the same stuff over and over again
Dialogue: 0,0:28:31.16,0:28:35.98,csapp,,0,0,0,,but not thinking in terms of how can I be the most abstract possible
Dialogue: 0,0:28:35.98,0:28:41.54,csapp,,0,0,0,,so they were trying to provide sort of a minimum layer on top of machine level programming
Dialogue: 0,0:28:41.84,0:28:45.00,csapp,,0,0,0,,that would let them write code that could run from one machine to another
Dialogue: 0,0:28:45.38,0:28:51.84,csapp,,0,0,0,, so in everything they do they sort of use the most simple representation and don't assume any kind of
Dialogue: 0,0:28:52.06,0:28:58.74,csapp,,0,0,0,, there's no array you know most languages would have array bounds checking
Dialogue: 0,0:28:58.86,0:29:06.12,csapp,,0,0,0,,and array would be a data structure that would include its size you know range of values and stuff and
Dialogue: 0,0:29:06.50,0:29:09.68,csapp,,0,0,0,,see just doesn't so everything about see is suit at the minimum
Dialogue: 0,0:29:10.46,0:29:15.78,csapp,,0,0,0,,and you know it's been around for a 40 or something year so
Dialogue: 0,0:29:15.78,0:29:20.68,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:29:20.70,0:29:25.78,csapp,,0,0,0,, no Pascal does not proceed see no as simply not true
Dialogue: 0,0:29:26.04,0:29:31.10,csapp,,0,0,0,,Pascal was created as a language for teaching by this phone and Nick was very
Dialogue: 0,0:29:31.80,0:29:35.02,csapp,,0,0,0,,and it was very much an instructional language
Dialogue: 0,0:29:35.02,0:29:39.88,csapp,,0,0,0,,so it was really designed to help students who needed help
Dialogue: 0,0:29:40.34,0:29:43.18,csapp,,0,0,0,,and C was designed by professional programmers
Dialogue: 0,0:29:43.60,0:29:48.72,csapp,,0,0,0,,  to let them write their code and not get in their way
Dialogue: 0,0:29:48.86,0:29:52.74,csapp,,0,0,0,,so they're very different theory between the two languages right
Dialogue: 0,0:29:54.02,0:30:08.04,csapp,,0,0,0,,yes what's that
Dialogue: 0,0:30:08.04,0:30:11.16,csapp,,0,0,0,,I'm sorry F oh yes that's a mistake there
Dialogue: 0,0:30:12.36,0:30:19.35,csapp,,0,0,0,,I'll double-check this or people could check it I'm pretty sure this code is okay though
Dialogue: 0,0:30:20.72,0:30:25.02,csapp,,0,0,0,, if not you can certainly say double star B equals a plus three and that would work right
Dialogue: 0,0:30:26.12,0:30:35.10,csapp,,0,0,0,,question
Dialogue: 0,0:30:35.10,0:30:40.52,csapp,,0,0,0,,you think what
Dialogue: 0,0:30:40.62,0:30:46.56,csapp,,0,0,0,,you think this is 28 yeah well I'm not going to try and execute it here
Dialogue: 0,0:30:46.56,0:30:49.28,csapp,,0,0,0,, but let's check it you and I will check this code out
Dialogue: 0,0:30:49.80,0:30:53.30,csapp,,0,0,0,,and we'll fix it if it needs to be fixed okay thanks for pointing it out
Dialogue: 0,0:30:53.76,0:31:01.92,csapp,,0,0,0,,yeah
Dialogue: 0,0:31:01.98,0:31:04.86,csapp,,0,0,0,,no that doesn't make any difference at all in this code
Dialogue: 0,0:31:06.10,0:31:09.08,csapp,,0,0,0,,no know where it's allocated makes no difference at all here
Dialogue: 0,0:31:10.38,0:31:13.76,csapp,,0,0,0,,so I'll check that might have to be double star B equals a plus 3
Dialogue: 0,0:31:13.76,0:31:18.02,csapp,,0,0,0,,but I this was a while ago that I wrote this code Oh double-check  it number
Dialogue: 0,0:31:19.76,0:31:31.08,csapp,,0,0,0,,ok so anyway sets the sort of end of the story for for simple
Dialogue: 0,0:31:32.42,0:31:36.38,csapp,,0,0,0,,simple Optima and they are simple optimizations it's just you have to get in the habit of doing it
Dialogue: 0,0:31:38.44,0:31:41.80,csapp,,0,0,0,,ok now what we're going to do is go a little bit fancier than this
Dialogue: 0,0:31:41.96,0:31:45.94,csapp,,0,0,0,,and as I said this becomes somewhat more system dependent but
Dialogue: 0,0:31:46.22,0:31:51.88,csapp,,0,0,0,,pretty much nowadays all processors are have similar implementation
Dialogue: 0,0:31:51.88,0:31:55.24,csapp,,0,0,0,,they all do what's known as out of order execution
Dialogue: 0,0:31:56.68,0:31:59.38,csapp,,0,0,0,, except for the most primitive micro controllers
Dialogue: 0,0:31:59.92,0:32:02.84,csapp,,0,0,0,,and so this is a the kind of optimization oh sure
Dialogue: 0,0:32:03.12,0:32:09.46,csapp,,0,0,0,,you'll find well this general approach will work across quite a variety machines
Dialogue: 0,0:32:11.64,0:32:15.68,csapp,,0,0,0,, so what I'm going to do is is do this by a series of examples
Dialogue: 0,0:32:15.76,0:32:19.70,csapp,,0,0,0,,starting from some not very efficient code and making it run faster and faster
Dialogue: 0,0:32:19.70,0:32:24.24,csapp,,0,0,0,,and we'll get a speed-up of around 40
Dialogue: 0,0:32:25.02,0:32:27.02,csapp,,0,0,0,,  just in doing what we're doing
Dialogue: 0,0:32:28.08,0:32:32.80,csapp,,0,0,0,,so as I'll start by saying well assume I have a data structure
Dialogue: 0,0:32:32.80,0:32:35.48,csapp,,0,0,0,,that looks like the way Pascal implements arrays
Dialogue: 0,0:32:37.08,0:32:38.86,csapp,,0,0,0,,sorry I have nothing against Pascal
Dialogue: 0,0:32:40.18,0:32:43.46,csapp,,0,0,0,,we used to teach it back in the old days but um
Dialogue: 0,0:32:43.72,0:32:47.46,csapp,,0,0,0,,so a typical way you'd implement an array in a language is
Dialogue: 0,0:32:47.72,0:32:51.66,csapp,,0,0,0,,you'd provide both the values that are stored in that array
Dialogue: 0,0:32:51.94,0:32:57.28,csapp,,0,0,0,,and then there'd be other information associated with it for example what size it is
Dialogue: 0,0:32:58.02,0:33:02.64,csapp,,0,0,0,,and so this is sort of the sort of nice abstract way to do it
Dialogue: 0,0:33:03.26,0:33:10.26,csapp,,0,0,0,,and you write code that makes sure that if you ever try to exceed the bounds on the array
Dialogue: 0,0:33:10.52,0:33:13.20,csapp,,0,0,0,,you'd return an error signal
Dialogue: 0,0:33:13.56,0:33:17.78,csapp,,0,0,0,,and so this particular function you're seeing
Dialogue: 0,0:33:18.88,0:33:23.54,csapp,,0,0,0,,is what I want to retrieve an element I passed an a pointer
Dialogue: 0,0:33:23.74,0:33:30.08,csapp,,0,0,0,,and then that value the pointer gets used to retrieve the value from the array
Dialogue: 0,0:33:30.82,0:33:36.20,csapp,,0,0,0,,and the return value of this function is then to 0 or 1 0 meaning failure in one meaning success
Dialogue: 0,0:33:36.86,0:33:41.98,csapp,,0,0,0,, and I'm writing it this way that I use a datatype I'll call data underscore T
Dialogue: 0,0:33:42.40,0:33:45.26,csapp,,0,0,0,,and that way I can run this I can compile this code
Dialogue: 0,0:33:45.46,0:33:50.48,csapp,,0,0,0,,using different definitions of data underscore T to get in so long floats and doubles
Dialogue: 0,0:33:50.98,0:33:57.08,csapp,,0,0,0,,and we'll see how the performance characteristics of those shift with the different data types
Dialogue: 0,0:33:59.38,0:34:03.30,csapp,,0,0,0,,and the benchmark I'm going to use is a fairly simple one
Dialogue: 0,0:34:03.30,0:34:10.06,csapp,,0,0,0,,it's just to for a an array or one of these vectors
Dialogue: 0,0:34:10.88,0:34:15.76,csapp,,0,0,0,,I just want to combine all the elements of it either compute their sum or their product
Dialogue: 0,0:34:16.52,0:34:22.16,csapp,,0,0,0,,and again I'm going to use macros here ident and up   and define those
Dialogue: 0,0:34:22.88,0:34:26.30,csapp,,0,0,0,,so that op is addition and the identity value is 0
Dialogue: 0,0:34:26.88,0:34:31.36,csapp,,0,0,0,,or the OP is multiplication and the identity element is 1
Dialogue: 0,0:34:31.66,0:34:34.24,csapp,,0,0,0,,so that I can compare addition in multiplication
Dialogue: 0,0:34:35.10,0:34:37.66,csapp,,0,0,0,,so that gives us sort of eight possibilities here
Dialogue: 0,0:34:37.88,0:34:40.24,csapp,,0,0,0,, two different operations in four different data types
Dialogue: 0,0:34:42.06,0:34:45.84,csapp,,0,0,0,,and so this is written in the sort of most straightforward manner that
Dialogue: 0,0:34:45.84,0:34:48.58,csapp,,0,0,0,,I'm using this function called get vac element
Dialogue: 0,0:34:49.04,0:34:52.46,csapp,,0,0,0,,to retrieve the successive values of this array
Dialogue: 0,0:34:53.04,0:34:55.96,csapp,,0,0,0,,and then performing this operation on them
Dialogue: 0,0:34:57.48,0:35:01.98,csapp,,0,0,0,,so now to express a performance of this
Dialogue: 0,0:35:02.62,0:35:06.58,csapp,,0,0,0,,we're going to use a metric I introduced called CPE
Dialogue: 0,0:35:06.82,0:35:10.68,csapp,,0,0,0,,which stands for cycles per element
Dialogue: 0,0:35:11.16,0:35:15.04,csapp,,0,0,0,,and the idea is that usually when you write code that say steps through a vector
Dialogue: 0,0:35:15.04,0:35:18.40,csapp,,0,0,0,,anything that has sort of some linear performance as you get bigger
Dialogue: 0,0:35:19.02,0:35:28.88,csapp,,0,0,0,,you don't really want to know for exactly it takes this many seconds or microseconds or nanoseconds to do an operation
Dialogue: 0,0:35:29.32,0:35:33.66,csapp,,0,0,0,,you kind of want to know often more what's its overall performance characteristics
Dialogue: 0,0:35:34.38,0:35:38.90,csapp,,0,0,0,,and also it turns out when you're doing low-level code optimization
Dialogue: 0,0:35:38.90,0:35:44.94,csapp,,0,0,0,,it's much more useful to think in terms of clock cycles of the inner clock of the processor
Dialogue: 0,0:35:45.12,0:35:48.36,csapp,,0,0,0,,rather than an absolute term such as nanoseconds
Dialogue: 0,0:35:48.66,0:35:52.88,csapp,,0,0,0,,because whether a processor is running at two gigahertz through 2.3 gigahertz
Dialogue: 0,0:35:53.68,0:35:57.68,csapp,,0,0,0,, I don't really I have no control over that as a programmer
Dialogue: 0,0:35:57.96,0:36:01.02,csapp,,0,0,0,,but I can control sort of it the low-level
Dialogue: 0,0:36:01.42,0:36:05.08,csapp,,0,0,0,,how many clock cycles are being used for different parts of the computation
Dialogue: 0,0:36:06.64,0:36:09.62,csapp,,0,0,0,, so that's why it's called cycles per element
Dialogue: 0,0:36:09.72,0:36:13.84,csapp,,0,0,0,,and you can think of it as and this shows some actual measurements
Dialogue: 0,0:36:14.36,0:36:21.48,csapp,,0,0,0,,but typically a function like this get what I showed the combine will have some overhead
Dialogue: 0,0:36:21.78,0:36:24.82,csapp,,0,0,0,,a fixed amount that's associated with setting up the loop
Dialogue: 0,0:36:24.98,0:36:27.42,csapp,,0,0,0,,doing the top level call and all that stuff
Dialogue: 0,0:36:27.82,0:36:31.20,csapp,,0,0,0,,and then some component that's linear in the size
Dialogue: 0,0:36:31.68,0:36:35.00,csapp,,0,0,0,,and so what I want to know is the slope of that linear component
Dialogue: 0,0:36:37.66,0:36:41.56,csapp,,0,0,0,,I'll and that will determine that's what I'll call the cycles per element
Dialogue: 0,0:36:41.56,0:36:48.36,csapp,,0,0,0,,the sort of incremental cost of adding one more element to the array
Dialogue: 0,0:36:53.88,0:36:56.64,csapp,,0,0,0,,so now if I run this function
Dialogue: 0,0:36:57.12,0:37:01.26,csapp,,0,0,0,,I showed you and I'm only showing I'll mostly only show four results
Dialogue: 0,0:37:01.26,0:37:07.44,csapp,,0,0,0,,because it turns out whether it's int or long or float or double
Dialogue: 0,0:37:07.92,0:37:12.26,csapp,,0,0,0,,is not going to actually have any effect on performance for most of the cases
Dialogue: 0,0:37:13.04,0:37:15.56,csapp,,0,0,0,,so if I just run this code through a compiler
Dialogue: 0,0:37:15.56,0:37:19.66,csapp,,0,0,0,,and don't do any optimizations it takes around 20 cycles per element
Dialogue: 0,0:37:20.22,0:37:26.48,csapp,,0,0,0,,and if I turn on optimization level 1 which is sort of the first serious optimization
Dialogue: 0,0:37:26.80,0:37:27.92,csapp,,0,0,0,,it takes the time in half
Dialogue: 0,0:37:28.06,0:37:33.30,csapp,,0,0,0,,so I'm down to 10 clock cycles per element just by changing the compilation
Dialogue: 0,0:37:33.90,0:37:37.28,csapp,,0,0,0,,and that's using the most unoptimized code I could think of here
Dialogue: 0,0:37:41.20,0:37:47.02,csapp,,0,0,0,,and then I won't go through it all but using sort of the kind of things
Dialogue: 0,0:37:47.02,0:37:53.08,csapp,,0,0,0,, I described earlier of sort of cut away some of the redundancy in this program
Dialogue: 0,0:37:53.42,0:37:55.98,csapp,,0,0,0,,you can get it down to something a little bit simpler
Dialogue: 0,0:37:56.10,0:37:59.58,csapp,,0,0,0,,and so one thing instead of you saw before I was making a call to this
Dialogue: 0,0:38:00.12,0:38:04.10,csapp,,0,0,0,,get Veck element and every time it did that it went bounds checking
Dialogue: 0,0:38:04.44,0:38:08.50,csapp,,0,0,0,,and it's kind of silly to keep bounds checking the same array over and over again
Dialogue: 0,0:38:08.72,0:38:15.58,csapp,,0,0,0,,when I'm stepping I'm using its length as the determinate of how many elements to access
Dialogue: 0,0:38:16.14,0:38:18.68,csapp,,0,0,0,,so if I'm willing to suit a forgo bounds checking
Dialogue: 0,0:38:19.04,0:38:26.14,csapp,,0,0,0,, what I can do is introduce a function that will just give me the actual data storage part of this vector
Dialogue: 0,0:38:26.50,0:38:28.30,csapp,,0,0,0,,and skip over all the other stuff
Dialogue: 0,0:38:29.26,0:38:35.82,csapp,,0,0,0,,and so I can write a loop that and I introduce you know local variables and all the kind of things we described
Dialogue: 0,0:38:37.28,0:38:41.82,csapp,,0,0,0,,and accumulating temporaries and things like that
Dialogue: 0,0:38:42.64,0:38:45.62,csapp,,0,0,0,,then the program actually gets a lot faster
Dialogue: 0,0:38:46.38,0:38:49.90,csapp,,0,0,0,,again with this is everything from here out is optimization level one
Dialogue: 0,0:38:50.54,0:38:56.94,csapp,,0,0,0,,and so it drops it down to a little over a clock cycle for integers addition of
Dialogue: 0,0:38:57.44,0:39:01.70,csapp,,0,0,0,,or three clock cycles up to five clock cycles for double precision multiplier
Dialogue: 0,0:39:02.14,0:39:06.14,csapp,,0,0,0,,so that's pretty good I've sort of definitely improved things
Dialogue: 0,0:39:06.52,0:39:09.70,csapp,,0,0,0,,but the question is well is that the best  there is
Dialogue: 0,0:39:09.88,0:39:15.84,csapp,,0,0,0,, and first and well so try to understand what is it about these numbers three five
Dialogue: 0,0:39:16.38,0:39:19.02,csapp,,0,0,0,,and this seems to be something close to one point two five
Dialogue: 0,0:39:19.02,0:39:25.58,csapp,,0,0,0,,so where those numbers coming from and does that indicate some fundamental limitation in my program
Dialogue: 0,0:39:27.92,0:39:32.74,csapp,,0,0,0,,well in order to do that you have to have some understanding of the underlying hardware
Dialogue: 0,0:39:32.82,0:39:38.62,csapp,,0,0,0,,and there's a really good course you can take I think it's called ECE 741
Dialogue: 0,0:39:39.82,0:39:44.02,csapp,,0,0,0,,that will tell you everything you ever could imagine wanting to know about processor design
Dialogue: 0,0:39:44.86,0:39:47.50,csapp,,0,0,0,,and you actually design processors like this
Dialogue: 0,0:39:47.98,0:39:50.36,csapp,,0,0,0,,but I'm assuming you're not going to do that for a while
Dialogue: 0,0:39:50.36,0:39:53.28,csapp,,0,0,0,,because you have up seven prerequisites to do before that happens
Dialogue: 0,0:39:55.82,0:39:59.28,csapp,,0,0,0,,so let me just give you the simple version
Dialogue: 0,0:39:59.80,0:40:05.52,csapp,,0,0,0,,and this is sort of a an idea of what a processor has looked like since about 1995
Dialogue: 0,0:40:05.86,0:40:12.34,csapp,,0,0,0,,so this is old stuff but it's enough actually to really understand it
Dialogue: 0,0:40:12.34,0:40:16.82,csapp,,0,0,0,,it's so hard it's really the details are pretty massive
Dialogue: 0,0:40:17.26,0:40:23.70,csapp,,0,0,0,,and so it's not even taught for example 447 is the ECE is the computer architecture course
Dialogue: 0,0:40:23.70,0:40:26.60,csapp,,0,0,0,,and they don't really go into this kind of design here
Dialogue: 0,0:40:26.92,0:40:29.32,csapp,,0,0,0,,because they're pretty hard they're actually hard to design on your own
Dialogue: 0,0:40:30.14,0:40:34.24,csapp,,0,0,0,,but the the basic idea is you think about a program as
Dialogue: 0,0:40:34.78,0:40:39.94,csapp,,0,0,0,,is the computer just reads in an instruction does whatever it says to do
Dialogue: 0,0:40:40.64,0:40:43.52,csapp,,0,0,0,,reads in another instruction does what that says to do
Dialogue: 0,0:40:44.14,0:40:46.98,csapp,,0,0,0,,and that has nothing to do with how programs actually execute
Dialogue: 0,0:40:47.30,0:40:51.02,csapp,,0,0,0,, what they've built up is this massive hardware infrastructure
Dialogue: 0,0:40:51.46,0:40:54.20,csapp,,0,0,0,,to make a program run way faster than
Dialogue: 0,0:40:54.90,0:40:57.74,csapp,,0,0,0,,it would if it were just doing one instruction at a time
Dialogue: 0,0:40:58.26,0:41:03.12,csapp,,0,0,0,,and it employs a technique that's called superscalar out of order execution
Dialogue: 0,0:41:03.72,0:41:07.60,csapp,,0,0,0,,and the idea is roughly speaking it it takes your program
Dialogue: 0,0:41:07.60,0:41:10.84,csapp,,0,0,0,,if you think of your program as a linear sequence of instructions
Dialogue: 0,0:41:11.40,0:41:14.12,csapp,,0,0,0,,and it just sucks in as many of those as it can
Dialogue: 0,0:41:14.68,0:41:18.48,csapp,,0,0,0,,and it pulls it apart to realize that certain operations
Dialogue: 0,0:41:18.96,0:41:23.76,csapp,,0,0,0,,don't really do on each other so I can start one even though it's later in the program
Dialogue: 0,0:41:24.18,0:41:27.51,csapp,,0,0,0,,than the one I'm working on right now because they're independent of each other
Dialogue: 0,0:41:27.82,0:41:32.34,csapp,,0,0,0,,and it's extracting what they call instruction level parallelism choices where
Dialogue: 0,0:41:32.94,0:41:36.24,csapp,,0,0,0,,even though your program is a linear sequence of instruction
Dialogue: 0,0:41:37.12,0:41:43.42,csapp,,0,0,0,,buried in there is actually a sort of forest of different computations that need to be done
Dialogue: 0,0:41:43.78,0:41:46.18,csapp,,0,0,0,,some which depend on each other and some which don't
Dialogue: 0,0:41:47.24,0:41:49.44,csapp,,0,0,0,,and then it has a bunch of hardware
Dialogue: 0,0:41:50.34,0:41:57.70,csapp,,0,0,0,,and so that's up here this upper part shows this idea of of fetching instructions
Dialogue: 0,0:41:57.70,0:42:02.88,csapp,,0,0,0,,so there's a cache memory a high performance high speed local memory
Dialogue: 0,0:42:03.42,0:42:07.05,csapp,,0,0,0,,that is just pulling in your instructions as fast as it can
Dialogue: 0,0:42:07.72,0:42:14.00,csapp,,0,0,0,,and those instructions are then feeding a big pile of hardware that will  extract out of it
Dialogue: 0,0:42:14.36,0:42:19.00,csapp,,0,0,0,,these low-level operations and figure out which ones depend on which others
Dialogue: 0,0:42:21.20,0:42:26.78,csapp,,0,0,0,,and then the there is a set of functional units in this part of it
Dialogue: 0,0:42:26.78,0:42:33.90,csapp,,0,0,0,,that are able to perform these low-level operations to do arithmetic floating-point operations
Dialogue: 0,0:42:34.28,0:42:39.24,csapp,,0,0,0,, to read data from memory to store data back to memory
Dialogue: 0,0:42:39.40,0:42:43.34,csapp,,0,0,0,,all using a cache which is something you're going to learn about fairly soon
Dialogue: 0,0:42:43.68,0:42:50.08,csapp,,0,0,0,,how what all this cache is but think of this as a high speed copy of some of the data memory
Dialogue: 0,0:42:51.44,0:42:59.13,csapp,,0,0,0,,and and so what this this logic tries to do is keep a forking out
Dialogue: 0,0:42:59.86,0:43:02.48,csapp,,0,0,0,,spawning off operations based on your  program
Dialogue: 0,0:43:02.76,0:43:05.58,csapp,,0,0,0,,and keeping these as busy as they can be
Dialogue: 0,0:43:05.90,0:43:11.40,csapp,,0,0,0,,doing different fragments of your code doing different instructions in a different order from before
Dialogue: 0,0:43:12.02,0:43:20.96,csapp,,0,0,0,,and it turns out you think of a register as a little the set of registers is a part of memory that  get read and written
Dialogue: 0,0:43:21.34,0:43:25.98,csapp,,0,0,0,,it turns out that in executing a register now just becomes the name
Dialogue: 0,0:43:26.32,0:43:30.82,csapp,,0,0,0,,of something that one instruction produces and some other instructions consume
Dialogue: 0,0:43:30.82,0:43:34.18,csapp,,0,0,0,,it's a destination for some it's a source for other
Dialogue: 0,0:43:34.72,0:43:39.84,csapp,,0,0,0,,and this whole a bunch of stuff here just sort of magically passes
Dialogue: 0,0:43:40.40,0:43:45.38,csapp,,0,0,0,,the results of one computation to the input to another computation
Dialogue: 0,0:43:45.70,0:43:50.92,csapp,,0,0,0,,based on register names without ever storing them in a and a explicit register file
Dialogue: 0,0:43:51.26,0:43:55.90,csapp,,0,0,0,, there is a register file when things kind of settle down they get stored away
Dialogue: 0,0:43:56.68,0:43:59.14,csapp,,0,0,0,,anyways there's a lot of stuff going on here
Dialogue: 0,0:43:59.58,0:44:07.74,csapp,,0,0,0,,but the main thing to think about is your machine has resources to do multiple operations  all at the same time
Dialogue: 0,0:44:07.74,0:44:13.74,csapp,,0,0,0,,if you can somehow structure your program so that those can all get used
Dialogue: 0,0:44:16.04,0:44:20.42,csapp,,0,0,0,,so this is as I mentioned it's called a superscalar instruct  processor
Dialogue: 0,0:44:20.42,0:44:23.84,csapp,,0,0,0,, is one that can do more than one instruction every clock cycle
Dialogue: 0,0:44:25.38,0:44:32.96,csapp,,0,0,0,,and actually Intel started in 93 the very first Pentium could do two instructions at once
Dialogue: 0,0:44:33.50,0:44:36.86,csapp,,0,0,0,,but then a little later they came out with one called the Pentium Pro
Dialogue: 0,0:44:37.04,0:44:40.08,csapp,,0,0,0,,which is sort of the basis of all modern processors
Dialogue: 0,0:44:40.52,0:44:43.22,csapp,,0,0,0,,and the lead architect by the way was a CMU graduate
Dialogue: 0,0:44:45.14,0:44:50.38,csapp,,0,0,0,,but this out order execution is the model that's used nowadays
Dialogue: 0,0:44:51.86,0:44:58.53,csapp,,0,0,0,,so the other thing is those functional units are more complex than you think they might be
Dialogue: 0,0:44:58.90,0:45:00.92,csapp,,0,0,0,,and that they have what's called pipelining
Dialogue: 0,0:45:01.46,0:45:07.38,csapp,,0,0,0,,and the ideas of pipelining is imagine you can break up a computation into a series of distinct stages
Dialogue: 0,0:45:09.24,0:45:13.50,csapp,,0,0,0,,a simple example is if you want to compute a times B plus C
Dialogue: 0,0:45:13.88,0:45:16.16,csapp,,0,0,0,,you first do the times then you do the plus
Dialogue: 0,0:45:17.06,0:45:21.22,csapp,,0,0,0,,but it actually gets more than that you can take something like multiplication
Dialogue: 0,0:45:22.24,0:45:26.16,csapp,,0,0,0,,and break it up into smaller steps
Dialogue: 0,0:45:26.76,0:45:28.88,csapp,,0,0,0,,that can be done one after the other
Dialogue: 0,0:45:29.50,0:45:34.16,csapp,,0,0,0,,in a way that and then if you have a separate dedicated Hardware for each of those stages
Dialogue: 0,0:45:34.62,0:45:37.22,csapp,,0,0,0,,then you can do what's called pipelining which is
Dialogue: 0,0:45:37.86,0:45:40.94,csapp,,0,0,0,,when one operation moves from one stage to the next
Dialogue: 0,0:45:41.40,0:45:45.22,csapp,,0,0,0,, a new operation can come in behind and start start its thing 
Dialogue: 0,0:45:45.82,0:45:51.98,csapp,,0,0,0,,so this example shows imagine I had a three stage pipeline multiplier 
Dialogue: 0,0:45:52.56,0:45:59.56,csapp,,0,0,0,,and I want to do this computation a*b, a*c  and now multiply those together 
Dialogue: 0,0:46:00.56,0:46:06.16,csapp,,0,0,0,,so the thing to observe is that a*b and a*c don't depend on each other in any way 
Dialogue: 0,0:46:07.06,0:46:12.10,csapp,,0,0,0,,so I can do them both and I don't have hardware to do them simultaneously
Dialogue: 0,0:46:12.10,0:46:15.52,csapp,,0,0,0,, but I have them enough to do one right after the other 
Dialogue: 0,0:46:16.20,0:46:23.70,csapp,,0,0,0,,so I can feed the first computation into the first stage a*b on step time step one 
Dialogue: 0,0:46:24.24,0:46:27.06,csapp,,0,0,0,,and then time step two it will move on to stage two 
Dialogue: 0,0:46:27.06,0:46:32.18,csapp,,0,0,0,,and times step three it will move on to stage three 
Dialogue: 0,0:46:32.82,0:46:37.28,csapp,,0,0,0,,but now I can start a*c in the time step two 
Dialogue: 0,0:46:38.10,0:46:40.68,csapp,,0,0,0,,because this stage became available 
Dialogue: 0,0:46:40.98,0:46:45.10,csapp,,0,0,0,,once a*b moved from stage one to stage two 
Dialogue: 0,0:46:45.46,0:46:51.32,csapp,,0,0,0,,and so I can follow right behind just one clock cycle behind this other operation 
Dialogue: 0,0:46:52.86,0:46:58.00,csapp,,0,0,0,,now a P times one times p2 obviously depends on both of these products 
Dialogue: 0,0:46:58.78,0:47:03.22,csapp,,0,0,0,,so it can't start until a times C is completed 
Dialogue: 0,0:47:03.68,0:47:07.32,csapp,,0,0,0,,and then it will run through the pipeline without anything else
Dialogue: 0,0:47:07.86,0:47:15.44,csapp,,0,0,0,,so overall then we've done what would have normally seemed to be nine steps worth of arithmetic 
Dialogue: 0,0:47:16.44,0:47:20.66,csapp,,0,0,0,,in a total of seven steps here because of pipelining
Dialogue: 0,0:47:20.78,0:47:27.54,csapp,,0,0,0,,question
Dialogue: 0,0:47:27.56,0:47:31.84,csapp,,0,0,0,,what's it if you had like in this a a picture here 
Dialogue: 0,0:47:32.58,0:47:36.50,csapp,,0,0,0,,if there were different multipliers in these different places yes you could do 
Dialogue: 0,0:47:37.50,0:47:39.86,csapp,,0,0,0,,those two completely independent of each other 
Dialogue: 0,0:47:39.92,0:47:48.78,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:47:48.80,0:47:53.50,csapp,,0,0,0,,yes this is all in a single core of a single processor  multi-core is yet another 
Dialogue: 0,0:47:53.90,0:47:57.12,csapp,,0,0,0,,this is a lower level parallelism than you get through multi-core 
Dialogue: 0,0:47:57.82,0:48:03.14,csapp,,0,0,0,,and it's present except in the sort of lowest n lowest powered embedded processors 
Dialogue: 0,0:48:03.14,0:48:04.52,csapp,,0,0,0,,some version of this exists 
Dialogue: 0,0:48:05.30,0:48:09.30,csapp,,0,0,0,,and most of the time your hardware is not being fully utilized it's one thing you're going to learn from this 
Dialogue: 0,0:48:12.50,0:48:16.64,csapp,,0,0,0,,so that's the idea of pipelining it it's  a sort of like parallelism 
Dialogue: 0,0:48:16.64,0:48:20.96,csapp,,0,0,0,,but it's not that you have multiple copies of resources it's that you have 
Dialogue: 0,0:48:21.30,0:48:29.62,csapp,,0,0,0,,this ability to stream operations through a single Hardware resource  in close succession to each other 
Dialogue: 0,0:48:33.28,0:48:39.34,csapp,,0,0,0,,and so as well which is a little bit more recent than the sharp machines
Dialogue: 0,0:48:39.34,0:48:41.98,csapp,,0,0,0,,but not that much more 
Dialogue: 0,0:48:42.38,0:48:47.12,csapp,,0,0,0,,is one of the most recent versions of the Intel x86 series 
Dialogue: 0,0:48:48.60,0:48:55.50,csapp,,0,0,0,,and the functional units include there's a lot of functional units that can do different things 
Dialogue: 0,0:48:55.52,0:49:02.10,csapp,,0,0,0,,but when you add it all up there's a possibility of it doing  two loads in one store 
Dialogue: 0,0:49:02.54,0:49:07.74,csapp,,0,0,0,,for integer operations two floating-point multiplies one addition and one division 
Dialogue: 0,0:49:08.26,0:49:13.72,csapp,,0,0,0,,they can't all happen at the same time because there's some are share functional units
Dialogue: 0,0:49:13.86,0:49:17.88,csapp,,0,0,0,,but the point is there's really a lot of equipment there that can do stuff 
Dialogue: 0,0:49:20.30,0:49:25.50,csapp,,0,0,0,,and also you can measure how an instruction now has 
Dialogue: 0,0:49:25.98,0:49:30.34,csapp,,0,0,0,,two characteristics and operation is how long does it take from beginning to end 
Dialogue: 0,0:49:30.78,0:49:36.84,csapp,,0,0,0,,but also how closely spaced can two in stations be  because of this pipelining
Dialogue: 0,0:49:37.34,0:49:42.48,csapp,,0,0,0,, so you see that most to them take some number of clock cycles to perform 
Dialogue: 0,0:49:42.94,0:49:46.46,csapp,,0,0,0,,but they're also pipelines so that you can do a series of them 
Dialogue: 0,0:49:47.12,0:49:48.44,csapp,,0,0,0,,just one cycle apart 
Dialogue: 0,0:49:48.92,0:49:52.36,csapp,,0,0,0,,the only different ones that are does you'll notice the division
Dialogue: 0,0:49:52.74,0:49:55.74,csapp,,0,0,0,,is both very slow and it's not pipelined
Dialogue: 0,0:49:55.74,0:50:01.28,csapp,,0,0,0,,and division is a very expensive operation on most machines  relatively speaking 
Dialogue: 0,0:50:05.18,0:50:10.46,csapp,,0,0,0,,um so what I claim then is is these these characteristics then 
Dialogue: 0,0:50:11.42,0:50:19.24,csapp,,0,0,0,,provide a limit on how fast our program can run our original program in that 
Dialogue: 0,0:50:19.90,0:50:24.02,csapp,,0,0,0,,I have a series of multiplications for example of integers here 
Dialogue: 0,0:50:25.20,0:50:27.18,csapp,,0,0,0,,and this shows the code for it
Dialogue: 0,0:50:27.70,0:50:33.52,csapp,,0,0,0,, and the result of I need the result of one multiplication before I can begin the next 
Dialogue: 0,0:50:33.74,0:50:37.28,csapp,,0,0,0,,so there's a three clock cycle bound here 
Dialogue: 0,0:50:37.72,0:50:41.28,csapp,,0,0,0,,and you'll see that in fact my measurements all correspond to 
Dialogue: 0,0:50:41.28,0:50:46.78,csapp,,0,0,0,,what I'm calling the latency bound of these machines which is just based on 
Dialogue: 0,0:50:46.94,0:50:51.08,csapp,,0,0,0,,how much time it takes from a beginning of an operation to the end 
Dialogue: 0,0:50:52.42,0:50:57.32,csapp,,0,0,0,,and the reason is we considered diagram the computation being done by this program 
Dialogue: 0,0:50:57.88,0:51:00.86,csapp,,0,0,0,,that it's doing a series of multiplications 
Dialogue: 0,0:51:01.46,0:51:06.30,csapp,,0,0,0,,and I require the result of one multiplication before I can start the next 
Dialogue: 0,0:51:07.00,0:51:09.04,csapp,,0,0,0,,in general if you look at this loop code
Dialogue: 0,0:51:09.86,0:51:12.18,csapp,,0,0,0,, it has to compute ECX 
Dialogue: 0,0:51:12.38,0:51:16.88,csapp,,0,0,0,,the updated value of it before it can now start the next one 
Dialogue: 0,0:51:18.12,0:51:23.48,csapp,,0,0,0,,and so that's why even though this I have a PI point multiplier 
Dialogue: 0,0:51:24.34,0:51:30.26,csapp,,0,0,0,,my program itself limits me to of the sequential execution of all the multiplies
Dialogue: 0,0:51:35.58,0:51:40.54,csapp,,0,0,0,,so let's see if we can't get beyond that bound that latency bound 
Dialogue: 0,0:51:41.12,0:51:43.68,csapp,,0,0,0,,well there's a fairly common technique that 
Dialogue: 0,0:51:43.68,0:51:46.42,csapp,,0,0,0,,you might have heard of before that's called loop unrolling 
Dialogue: 0,0:51:47.02,0:51:50.14,csapp,,0,0,0,,and the idea of loop unrolling is just that you 
Dialogue: 0,0:51:53.90,0:51:59.46,csapp,,0,0,0,,rather than executing one value within a loop you execute a multiple ones 
Dialogue: 0,0:51:59.92,0:52:02.48,csapp,,0,0,0,,and so this code shows unrolling by two 
Dialogue: 0,0:52:02.86,0:52:09.54,csapp,,0,0,0,,and what it says is I'm going to step through this array  two elements at a time 
Dialogue: 0,0:52:09.86,0:52:15.96,csapp,,0,0,0,,and within each of the inner group I'm going to combine the values  from di and di plus one 
Dialogue: 0,0:52:16.42,0:52:19.08,csapp,,0,0,0,,and I have to put in some extra code to finish off 
Dialogue: 0,0:52:19.50,0:52:22.40,csapp,,0,0,0,,what happens if the original rate was a von wenk 
Dialogue: 0,0:52:22.68,0:52:24.19,csapp,,0,0,0,,but you get the idea and
Dialogue: 0,0:52:24.64,0:52:27.50,csapp,,0,0,0,,this idea I showed this code of of two
Dialogue: 0,0:52:27.50,0:52:31.68,csapp,,0,0,0,,but you could imagine this applying for different values of loop unrolling 
Dialogue: 0,0:52:32.84,0:52:34.14,csapp,,0,0,0,,so will this help us any well 
Dialogue: 0,0:52:35.68,0:52:41.12,csapp,,0,0,0,,when I run it I get that the integer addition got a little faster 
Dialogue: 0,0:52:41.46,0:52:43.26,csapp,,0,0,0,,but the other ones didn't improve at all 
Dialogue: 0,0:52:44.58,0:52:46.70,csapp,,0,0,0,,so this one is going faster 
Dialogue: 0,0:52:46.70,0:52:55.66,csapp,,0,0,0,,because basically the old code is the overhead of the loop indexing and incrementing was enough  to be slowing me down 
Dialogue: 0,0:52:55.96,0:52:58.42,csapp,,0,0,0,,because it's already close to a clock cycle 
Dialogue: 0,0:52:58.44,0:53:05.80,csapp,,0,0,0,,so I just managed to knock that down to be at the latency bound of this particular instruction 
Dialogue: 0,0:53:06.58,0:53:11.44,csapp,,0,0,0,,but it didn't have the other ones because I still have this sequential dependency 
Dialogue: 0,0:53:11.88,0:53:15.70,csapp,,0,0,0,,in order to get my new value of X I have to first 
Dialogue: 0,0:53:16.44,0:53:21.42,csapp,,0,0,0,,do one computation and then do the other before I can begin another one 
Dialogue: 0,0:53:23.98,0:53:30.94,csapp,,0,0,0,,but this shows me the way I could make a very very small change and change performance fairly dramatically 
Dialogue: 0,0:53:31.52,0:53:36.38,csapp,,0,0,0,,what if I take these parentheses and shift them to the right um
Dialogue: 0,0:53:41.40,0:53:43.16,csapp,,0,0,0,,what would that make any difference 
Dialogue: 0,0:53:44.94,0:53:49.22,csapp,,0,0,0,,and lo and behold yes you find that 
Dialogue: 0,0:53:49.80,0:54:01.46,csapp,,0,0,0,,and I'll call that transformation unrolling by two computing a one element at a time
Dialogue: 0,0:54:01.46,0:54:02.70,csapp,,0,0,0,,I'll talk about that in a minute 
Dialogue: 0,0:54:03.38,0:54:08.16,csapp,,0,0,0,,but I'll use this lowercase a to say I've done an associate ivities formation 
Dialogue: 0,0:54:08.76,0:54:13.18,csapp,,0,0,0,,and you see all of a sudden my time's dropped in half  for these three cases
Dialogue: 0,0:54:16.97,0:54:18.02,csapp,,0,0,0,, so something's going on 
Dialogue: 0,0:54:20.14,0:54:24.60,csapp,,0,0,0,,um and so let's see why that isn't and now I'll introduce 
Dialogue: 0,0:54:27.64,0:54:30.44,csapp,,0,0,0,,it and so if I take my picture from before
Dialogue: 0,0:54:31.50,0:54:34.88,csapp,,0,0,0,,and think about what those computations employ you'll see that
Dialogue: 0,0:54:35.46,0:54:38.88,csapp,,0,0,0,, right now I've changed the structure of the computation
Dialogue: 0,0:54:38.88,0:54:46.04,csapp,,0,0,0,,so that I'm pairwise combining each element of pair of elements of the array
Dialogue: 0,0:54:46.50,0:54:51.02,csapp,,0,0,0,,and then accumulating those into the overall computation 
Dialogue: 0,0:54:51.02,0:54:55.40,csapp,,0,0,0,,so I've actually that shifting of the parentheses fundamentally changed 
Dialogue: 0,0:54:55.82,0:54:57.40,csapp,,0,0,0,,how I'm doing my computation 
Dialogue: 0,0:54:59.12,0:55:02.90,csapp,,0,0,0,,and you can see now that this critical path which is what determines 
Dialogue: 0,0:55:03.30,0:55:05.96,csapp,,0,0,0,,in this case the the performance limitation 
Dialogue: 0,0:55:06.20,0:55:08.66,csapp,,0,0,0,,just got shorter by a factor of two 
Dialogue: 0,0:55:08.94,0:55:11.62,csapp,,0,0,0,,and that's why I'm now running twice as fast 
Dialogue: 0,0:55:11.82,0:55:16.50,csapp,,0,0,0,,for for the operations not for energy or addition
Dialogue: 0,0:55:17.02,0:55:21.48,csapp,,0,0,0,,but for the other three operations I've cut by a factor or two
Dialogue: 0,0:55:22.58,0:55:26.48,csapp,,0,0,0,, just by that shift now there's some good news and bad news here 
Dialogue: 0,0:55:27.20,0:55:29.88,csapp,,0,0,0,,the good news is if this is integer arithmetic 
Dialogue: 0,0:55:29.88,0:55:39.56,csapp,,0,0,0,,we know already you know that  a two's complement arithmetic is associative and commutative 
Dialogue: 0,0:55:39.96,0:55:44.14,csapp,,0,0,0,,so it really doesn't matter for both multiplication and addition 
Dialogue: 0,0:55:44.32,0:55:47.24,csapp,,0,0,0,,so it really doesn't matter what order I combine these elements in 
Dialogue: 0,0:55:47.24,0:55:49.84,csapp,,0,0,0,,I'm going to get the exact same answer no matter what
Dialogue: 0,0:55:50.70,0:55:53.30,csapp,,0,0,0,, but you also solve for floating-point that's not the case 
Dialogue: 0,0:55:53.92,0:55:58.18,csapp,,0,0,0,,so with floating-point that shift shifting these parentheses 
Dialogue: 0,0:55:58.74,0:56:02.58,csapp,,0,0,0,,because of rounding possibilities and even potentially overflow 
Dialogue: 0,0:56:03.12,0:56:07.02,csapp,,0,0,0,,you might get different values results from these computations
Dialogue: 0,0:56:07.58,0:56:13.46,csapp,,0,0,0,, but then again if you think about you know is that really going to happen chances are no
Dialogue: 0,0:56:14.02,0:56:17.16,csapp,,0,0,0,, that it's not really going to affect the outcome of your program 
Dialogue: 0,0:56:17.46,0:56:21.64,csapp,,0,0,0,,but it's enough of a change that most C compilers or most compilers period 
Dialogue: 0,0:56:21.92,0:56:24.96,csapp,,0,0,0,,will not make any change that changes associativity 
Dialogue: 0,0:56:24.96,0:56:28.22,csapp,,0,0,0,,because they're very conservative when it comes to floating-point 
Dialogue: 0,0:56:29.98,0:56:34.62,csapp,,0,0,0,,so that's something you as an application programmer has to have to know well enough is
Dialogue: 0,0:56:34.62,0:56:38.20,csapp,,0,0,0,, this a valid can I do this transformation without messing things up 
Dialogue: 0,0:56:41.16,0:56:45.90,csapp,,0,0,0,,and now without I'll say is now there's a new set of bounds
Dialogue: 0,0:56:45.90,0:56:52.46,csapp,,0,0,0,, so a bound is what would appear to be sort of the best you can do based on some constraint in the program 
Dialogue: 0,0:56:52.88,0:56:56.20,csapp,,0,0,0,,and before it was saying well the latency 
Dialogue: 0,0:56:56.42,0:56:59.58,csapp,,0,0,0,,the total time through a given for a given operation was abound 
Dialogue: 0,0:57:00.50,0:57:05.56,csapp,,0,0,0,,and now I say well there's an even more fundamental bound which I'll call the throughput bound
Dialogue: 0,0:57:05.56,0:57:09.66,csapp,,0,0,0,,which is just based on I only have so much hardware out there 
Dialogue: 0,0:57:09.92,0:57:12.54,csapp,,0,0,0,,and I can only a pump it so fast 
Dialogue: 0,0:57:13.32,0:57:19.26,csapp,,0,0,0,,so for example these two that the throughput bound is one 
Dialogue: 0,0:57:19.82,0:57:28.78,csapp,,0,0,0,,because I only have that actually becomes limited by the requirement
Dialogue: 0,0:57:28.78,0:57:32.34,csapp,,0,0,0,, that I'm having to read from memory
Dialogue: 0,0:57:32.74,0:57:35.10,csapp,,0,0,0,, and I have two different load units
Dialogue: 0,0:57:39.02,0:57:45.28,csapp,,0,0,0,, oh no I'm sorry I only have one multiplier for integers in one for  addition
Dialogue: 0,0:57:46.00,0:57:49.84,csapp,,0,0,0,, the throughput bound for these two actually is just a half
Dialogue: 0,0:57:50.38,0:57:55.68,csapp,,0,0,0,,because it turns out there's some odd part of the hardware design that has two 14-point multipliers 
Dialogue: 0,0:57:56.20,0:57:57.96,csapp,,0,0,0,,but only one floating point adder 
Dialogue: 0,0:57:58.18,0:58:03.08,csapp,,0,0,0,,and we'll see that we can actually make this multiplication code run faster than addition code 
Dialogue: 0,0:58:03.64,0:58:08.28,csapp,,0,0,0,,and over here again my limit will be that I only have to load units now to be 
Dialogue: 0,0:58:09.30,0:58:14.74,csapp,,0,0,0,,and I have to read for every element I'm computing I have to be reading one element from memory
Dialogue: 0,0:58:14.74,0:58:16.14,csapp,,0,0,0,, so I can't get below
Dialogue: 0,0:58:20.18,0:58:23.26,csapp,,0,0,0,, that okay so but we saw this transformation now is let us 
Dialogue: 0,0:58:23.70,0:58:28.60,csapp,,0,0,0,,break out of this latency limitation and get something closer to throughput 
Dialogue: 0,0:58:29.38,0:58:35.76,csapp,,0,0,0,,and here's another technique that can be used to again sort of get more parallelism going 
Dialogue: 0,0:58:36.04,0:58:38.30,csapp,,0,0,0,,and I call this multiple accumulators
Dialogue: 0,0:58:38.82,0:58:41.70,csapp,,0,0,0,, the idea is let's a imagine that 
Dialogue: 0,0:58:41.70,0:58:45.74,csapp,,0,0,0,,we have the odd-numbered elements and the even-numbered elements in the array 
Dialogue: 0,0:58:46.36,0:58:52.88,csapp,,0,0,0,,and we can we can compute separate sums or products of those two sets of elements
Dialogue: 0,0:58:53.34,0:58:56.28,csapp,,0,0,0,, and then the very end combine them together 
Dialogue: 0,0:58:56.60,0:59:00.53,csapp,,0,0,0,,so this is another form of and associativity transformation
Dialogue: 0,0:59:00.53,0:59:04.54,csapp,,0,0,0,,you were changing the order in which we combine things together 
Dialogue: 0,0:59:05.08,0:59:08.14,csapp,,0,0,0,,it's just that we're doing it in the suit of odd-even manner 
Dialogue: 0,0:59:08.14,0:59:15.78,csapp,,0,0,0,,or in general every I do it by some by some parameter I
Dialogue: 0,0:59:17.92,0:59:21.58,csapp,,0,0,0,, it has the same issues that if it's integer arithmetic it's fine 
Dialogue: 0,0:59:21.58,0:59:26.54,csapp,,0,0,0,,if it's floating-point there's a risk of of changing the behavior of the program 
Dialogue: 0,0:59:27.78,0:59:32.40,csapp,,0,0,0,,but you'll see that again we get a cutting in half here and 
Dialogue: 0,0:59:32.48,0:59:35.80,csapp,,0,0,0,,a little bit below one for integer addition 
Dialogue: 0,0:59:39.04,0:59:41.98,csapp,,0,0,0,,and again we can think of it by looking at these pictures 
Dialogue: 0,0:59:41.98,0:59:44.16,csapp,,0,0,0,,of what are the what gets computed 
Dialogue: 0,0:59:44.16,0:59:47.92,csapp,,0,0,0,,and you see what we're doing is we're computing here all the even numbers 
Dialogue: 0,0:59:48.36,0:59:51.58,csapp,,0,0,0,,even numbered elements being combined and here all the odd ones 
Dialogue: 0,0:59:51.88,0:59:54.12,csapp,,0,0,0,,and the very end we're combining those together 
Dialogue: 0,0:59:56.82,0:59:59.66,csapp,,0,0,0,,and so we can generalize this if we can 
Dialogue: 0,1:00:00.24,1:00:04.00,csapp,,0,0,0,,unroll by a factor of K of L
Dialogue: 0,1:00:04.24,1:00:07.32,csapp,,0,0,0,,and we can accumulate K results in parallel 
Dialogue: 0,1:00:07.90,1:00:11.82,csapp,,0,0,0,,and we can use various values of L and K for it 
Dialogue: 0,1:00:11.82,1:00:14.68,csapp,,0,0,0,,in general has to be a multiple of k
Dialogue: 0,1:00:16.36,1:00:21.78,csapp,,0,0,0,,and so you run it out and you can get for floating-point
Dialogue: 0,1:00:23.28,1:00:27.70,csapp,,0,0,0,,why you can actually get it down almost to this throughput bounds of 0.5 
Dialogue: 0,1:00:36.62,1:00:42.02,csapp,,0,0,0,,this is incorrect this is integer addition I should say in tradition 
Dialogue: 0,1:00:42.70,1:00:45.92,csapp,,0,0,0,,you can again get it down to around 0.5 
Dialogue: 0,1:00:46.64,1:00:53.48,csapp,,0,0,0,,and in general by sort of picking the best parameters
Dialogue: 0,1:00:53.48,1:00:57.88,csapp,,0,0,0,,  I can get very close to the throughput bound of this processor 
Dialogue: 0,1:00:58.36,1:01:04.14,csapp,,0,0,0,,so I've been able to take something remember it originally was  20 clock cycles than 10
Dialogue: 0,1:01:04.38,1:01:08.44,csapp,,0,0,0,,and now I'm getting it down to one or fewer clock cycles per element 
Dialogue: 0,1:01:10.58,1:01:17.56,csapp,,0,0,0,,so now just as the final step is okay is that as good as it go actually no 
Dialogue: 0,1:01:18.96,1:01:22.18,csapp,,0,0,0,,you remember when I talked about floating-point I mentioned
Dialogue: 0,1:01:22.18,1:01:25.34,csapp,,0,0,0,, that there's the special set of registers
Dialogue: 0,1:01:25.70,1:01:31.96,csapp,,0,0,0,, that are on x86 that we're called xmm registers on the sharp machines 
Dialogue: 0,1:01:32.26,1:01:36.68,csapp,,0,0,0,,and now this has well this newer generation have something called ymm registers 
Dialogue: 0,1:01:37.08,1:01:40.04,csapp,,0,0,0,,which have the feature being twice as big as xmm registers 
Dialogue: 0,1:01:40.90,1:01:51.10,csapp,,0,0,0,,so in particular these registers are are 32 bytes long 
Dialogue: 0,1:01:51.76,1:01:57.38,csapp,,0,0,0,,and there's a new version coming out within a year or something they call avx-512
Dialogue: 0,1:01:57.86,1:02:03.92,csapp,,0,0,0,,where the register is 512 bits so that's 256 bytes  long 
Dialogue: 0,1:02:04.42,1:02:10.60,csapp,,0,0,0,,no it's of to 512 excuse me it's 64 bytes right 
Dialogue: 0,1:02:11.04,1:02:13.36,csapp,,0,0,0,,64 bytes so it'll be twice as big as these 
Dialogue: 0,1:02:14.08,1:02:17.24,csapp,,0,0,0,,and as I mentioned before you can think of these as a way of 
Dialogue: 0,1:02:17.72,1:02:21.78,csapp,,0,0,0,,operating on 32 individual characters
Dialogue: 0,1:02:22.30,1:02:24.52,csapp,,0,0,0,, or I can treat them as floating point 
Dialogue: 0,1:02:25.20,1:02:28.86,csapp,,0,0,0,,and we saw before that you nowadays the 
Dialogue: 0,1:02:29.26,1:02:35.52,csapp,,0,0,0,, the regular floating point makes use of Ceuta the low order  for 8 bytes of these read jester's 
Dialogue: 0,1:02:36.64,1:02:40.16,csapp,,0,0,0,,but there's also instructions called vector addition 
Dialogue: 0,1:02:41.22,1:02:50.76,csapp,,0,0,0,,where one instruction has the effect of doing eight floating-point additions at once unload data
Dialogue: 0,1:02:51.02,1:02:55.34,csapp,,0,0,0,, and on double precision this counterpart does four of them at once of these 
Dialogue: 0,1:02:56.78,1:03:02.98,csapp,,0,0,0,,and the that hardware is there it's just sitting there waiting to use and it seldom gets fired up
Dialogue: 0,1:03:03.60,1:03:05.58,csapp,,0,0,0,, to really make use of it 
Dialogue: 0,1:03:06.00,1:03:09.68,csapp,,0,0,0,,but so that floating point multiplier that can do 
Dialogue: 0,1:03:10.12,1:03:15.04,csapp,,0,0,0,,a floating point multiplication in three clock cycles and is fully pipeline 
Dialogue: 0,1:03:16.19,1:03:24.32,csapp,,0,0,0,,you can actually do eight fighting point multiplications in parallel and pipelined in three clock cycles 
Dialogue: 0,1:03:27.38,1:03:33.04,csapp,,0,0,0,,and as I mentioned the shark machines has an earlier version where the numbers are half of these 
Dialogue: 0,1:03:33.04,1:03:37.49,csapp,,0,0,0,,so it can do for single precision or two double precision at once
Dialogue: 0,1:03:38.76,1:03:44.16,csapp,,0,0,0,,and if I write code that uses that what I call vector code
Dialogue: 0,1:03:44.70,1:03:51.16,csapp,,0,0,0,, then you can see I can drop by a factor of about four across the board here 
Dialogue: 0,1:03:51.86,1:03:54.82,csapp,,0,0,0,,and make it run much faster 
Dialogue: 0,1:03:54.82,1:03:58.92,csapp,,0,0,0,,so this 0.06 is really 0.0625 right
Dialogue: 0,1:03:58.92,1:04:05.48,csapp,,0,0,0,, it's doing 16 operations per clock cycle on that
Dialogue: 0,1:04:10.06,1:04:14.46,csapp,,0,0,0,, and can't quite hit the vector throughput bound
Dialogue: 0,1:04:14.46,1:04:17.68,csapp,,0,0,0,,  but in general making this thing run much faster 
Dialogue: 0,1:04:18.10,1:04:20.54,csapp,,0,0,0,,and so the people really worry about 
Dialogue: 0,1:04:20.54,1:04:27.16,csapp,,0,0,0,,and you can imagine these instructions were introduced for things like video processing image processing of sound 
Dialogue: 0,1:04:27.46,1:04:31.98,csapp,,0,0,0,,sort of signal processing where a performance really matters
Dialogue: 0,1:04:32.00,1:04:38.02,csapp,,0,0,0,, how fast you can display an image how fast you can rotate something 
Dialogue: 0,1:04:38.02,1:04:41.06,csapp,,0,0,0,,you know how fast you can perform graphics makes a big difference 
Dialogue: 0,1:04:41.74,1:04:48.60,csapp,,0,0,0,,in video games are one of the big drivers but even for sort of other operations you might do an image
Dialogue: 0,1:04:48.90,1:04:51.40,csapp,,0,0,0,,and so these instructions were really designed to do it 
Dialogue: 0,1:04:51.40,1:04:54.10,csapp,,0,0,0,,and people write code for those kind of applications 
Dialogue: 0,1:04:54.52,1:04:59.98,csapp,,0,0,0,,get pretty good at writing code in a way that they can do this vector I what's called vectorizing 
Dialogue: 0,1:05:00.58,1:05:05.82,csapp,,0,0,0,,and unfortunately so the Intel compiler will actually automatically do some of this for you
Dialogue: 0,1:05:06.10,1:05:09.11,csapp,,0,0,0,,a GCC they attempted to implement it and
Dialogue: 0,1:05:09.11,1:05:11.96,csapp,,0,0,0,,it didn't work very well so I think they discontinued it 
Dialogue: 0,1:05:12.58,1:05:15.64,csapp,,0,0,0,, it turns out there's a web aside 
Dialogue: 0,1:05:16.90,1:05:21.44,csapp,,0,0,0,,so this is on the web from the books web page that describes 
Dialogue: 0,1:05:21.44,1:05:23.52,csapp,,0,0,0,,how to do this programming if you're interested
Dialogue: 0,1:05:23.90,1:05:28.82,csapp,,0,0,0,,there's extensions to GCC that are very funky really weird stuff 
Dialogue: 0,1:05:29.36,1:05:32.20,csapp,,0,0,0,, but you can write code 
Dialogue: 0,1:05:32.72,1:05:37.12,csapp,,0,0,0,,that then will get compiled down to make use of these kind of instructions 
Dialogue: 0,1:05:37.18,1:05:40.22,csapp,,0,0,0,,and that's how I did it and how I got these performance results 
Dialogue: 0,1:05:43.48,1:05:46.76,csapp,,0,0,0,,okay so that shows you if you really want to it
Dialogue: 0,1:05:47.00,1:05:50.38,csapp,,0,0,0,,but that's very machine specific that will only work on 
Dialogue: 0,1:05:52.02,1:05:58.46,csapp,,0,0,0,,well you have to you can actually tune it so it's easy to compile it   to go between different machines 
Dialogue: 0,1:05:58.46,1:06:05.34,csapp,,0,0,0,,but it's still a fairly specific and very specific to GCC in fact 
Dialogue: 0,1:06:05.92,1:06:09.48,csapp,,0,0,0,,so that sort of shows you though if you really want to push it what you can do
Dialogue: 0,1:06:10.48,1:06:13.16,csapp,,0,0,0,,now let's uh get back to one of the thing
Dialogue: 0,1:06:13.56,1:06:20.04,csapp,,0,0,0,,I told you about how you can if you think of your program as a very long linear sequence of instructions 
Dialogue: 0,1:06:20.72,1:06:26.96,csapp,,0,0,0,,then the thing is trying to grab as many of those and pull them apart as fast as it can
Dialogue: 0,1:06:27.52,1:06:30.40,csapp,,0,0,0,,but of course you know your program is actually typically a loop 
Dialogue: 0,1:06:30.78,1:06:32.69,csapp,,0,0,0,,and there aren't many instructions in that loop
Dialogue: 0,1:06:33.08,1:06:35.84,csapp,,0,0,0,, so how is it turning that into a linear sequence 
Dialogue: 0,1:06:36.72,1:06:41.52,csapp,,0,0,0,,well that relies on an idea of how do you handle branches 
Dialogue: 0,1:06:42.30,1:06:48.38,csapp,,0,0,0,,so typically the program you know fetching ahead grabbing instructions 
Dialogue: 0,1:06:48.38,1:06:53.92,csapp,,0,0,0,,and it will come to a branch instruction a conditional jump of some sort 
Dialogue: 0,1:06:54.58,1:06:59.86,csapp,,0,0,0,,and there is a dilemma because in general this branch could either 
Dialogue: 0,1:07:01.10,1:07:07.32,csapp,,0,0,0,,I'm sorry either be taken meaning it will go to the branch target 
Dialogue: 0,1:07:07.80,1:07:13.70,csapp,,0,0,0,,or it could do what's called fall through meaning it it the test fails and so it just continues execution 
Dialogue: 0,1:07:14.14,1:07:19.32,csapp,,0,0,0,,and there's no way a priority to know what will happen these can often be data dependent 
Dialogue: 0,1:07:22.66,1:07:27.14,csapp,,0,0,0,,well and so the way this is handled on a modern processor is by doing 
Dialogue: 0,1:07:27.14,1:07:30.64,csapp,,0,0,0,,what's known as branch prediction which is essentially just guess 
Dialogue: 0,1:07:32.10,1:07:34.64,csapp,,0,0,0,, which ways this branch going to go is going to be taken or 
Dialogue: 0,1:07:35.10,1:07:39.14,csapp,,0,0,0,,not and you predict and then you start executing along the predicted direction
Dialogue: 0,1:07:39.56,1:07:41.98,csapp,,0,0,0,, but do it in a way that if you make a mistake that
Dialogue: 0,1:07:42.52,1:07:45.94,csapp,,0,0,0,, you haven't caused your reparable harm to the program
Dialogue: 0,1:07:46.44,1:07:48.40,csapp,,0,0,0,, and we'll see what that means 
Dialogue: 0,1:07:48.86,1:07:52.12,csapp,,0,0,0,,so what really happens then is up here there's a lot of logic
Dialogue: 0,1:07:52.12,1:07:55.60,csapp,,0,0,0,, that's trying to suck out instructions 
Dialogue: 0,1:07:56.12,1:08:02.54,csapp,,0,0,0,,and then there's a branch unit that's being basically coming along later and saying
Dialogue: 0,1:08:02.94,1:08:07.00,csapp,,0,0,0,,yeah you're okay you predicted that correctly so you can keep going
Dialogue: 0,1:08:07.20,1:08:10.70,csapp,,0,0,0,, or it will throw up a flag and say oh wait a minute stop 
Dialogue: 0,1:08:11.44,1:08:16.24,csapp,,0,0,0,,your misprediction you miss predicted this branch way back 100 clock cycles ago
Dialogue: 0,1:08:16.32,1:08:17.64,csapp,,0,0,0,, it's not that long ago but
Dialogue: 0,1:08:18.30,1:08:21.80,csapp,,0,0,0,, some number of clock cycles ago you've got to fix it 
Dialogue: 0,1:08:22.44,1:08:28.10,csapp,,0,0,0,,and so so the hand-wave jumps then becomes more a case of of
Dialogue: 0,1:08:28.36,1:08:34.58,csapp,,0,0,0,, guessing up here and then either confirming or  denying that guess down below
Dialogue: 0,1:08:40.58,1:08:45.60,csapp,,0,0,0,,so in general then if you it will predict it one way and begin executing
Dialogue: 0,1:08:46.26,1:08:50.28,csapp,,0,0,0,,so a mansion for example in a loop like I've shown you 
Dialogue: 0,1:08:50.56,1:08:54.80,csapp,,0,0,0,,that you predict that the branch will be taken that you'll go back to the start of the loop again
Dialogue: 0,1:08:54.80,1:08:57.04,csapp,,0,0,0,, that's actually a pretty good guess
Dialogue: 0,1:08:57.38,1:09:00.36,csapp,,0,0,0,, it's a good guess extol you hit the end of the loop
Dialogue: 0,1:09:00.88,1:09:02.64,csapp,,0,0,0,,but let's just guess that way
Dialogue: 0,1:09:03.18,1:09:08.56,csapp,,0,0,0,, and so the program will just keep guessing that the branch will be taken 
Dialogue: 0,1:09:09.02,1:09:16.28,csapp,,0,0,0,,and by that means by all those guesses basically create this long linear sequence of instructions
Dialogue: 0,1:09:16.66,1:09:19.68,csapp,,0,0,0,, that can be pulled in and executed 
Dialogue: 0,1:09:21.88,1:09:27.60,csapp,,0,0,0,,and in general some of them will be fetched and some of them you'll actually have done 
Dialogue: 0,1:09:28.20,1:09:31.06,csapp,,0,0,0,,the operations that are called for in the instruction 
Dialogue: 0,1:09:33.56,1:09:40.50,csapp,,0,0,0,,and then what happens is if if the flag goes up they say no this was invalid 
Dialogue: 0,1:09:41.22,1:09:45.66,csapp,,0,0,0,,then what will happen is it will go back and cancel 
Dialogue: 0,1:09:46.12,1:09:50.38,csapp,,0,0,0,,all the instructions that have been fetched and executed 
Dialogue: 0,1:09:50.78,1:09:56.96,csapp,,0,0,0,,and the way it does that is you'll notice not all these instructions only modify registers 
Dialogue: 0,1:09:57.66,1:10:00.66,csapp,,0,0,0,,and it has multiple copies of all the registers 
Dialogue: 0,1:10:01.10,1:10:03.14,csapp,,0,0,0,,going back these are the registers 
Dialogue: 0,1:10:03.14,1:10:08.84,csapp,,0,0,0,,these are the values that I'm sure of these are sort of speculative values  appending updates to them
Dialogue: 0,1:10:09.26,1:10:14.56,csapp,,0,0,0,, and so when it comes time to cancel it just cancels out all those pending updates
Dialogue: 0,1:10:14.78,1:10:17.00,csapp,,0,0,0,,and goes back to values that it's certain of 
Dialogue: 0,1:10:17.12,1:10:20.40,csapp,,0,0,0,,question 
Dialogue: 0,1:10:20.40,1:10:27.66,csapp,,0,0,0,,the there's a big block they call the register renaming unit which is sort of 
Dialogue: 0,1:10:27.94,1:10:31.80,csapp,,0,0,0,,multiple copies of of all the registers as they get accumulated
Dialogue: 0,1:10:31.80,1:10:42.00,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:10:42.00,1:10:45.94,csapp,,0,0,0,,it has many more will typically have several hundred reg of these 
Dialogue: 0,1:10:46.26,1:10:50.72,csapp,,0,0,0,,sort of virtual registers to keep pending copies to the actual registers 
Dialogue: 0,1:10:50.72,1:10:52.56,csapp,,0,0,0,,[student speaking]
Dialogue: 0,1:10:52.56,1:10:56.80,csapp,,0,0,0,,what it does it stores you know here's the old value 
Dialogue: 0,1:10:56.80,1:10:59.64,csapp,,0,0,0,,here's the first update here's the second update here's the third
Dialogue: 0,1:11:01.60,1:11:05.74,csapp,,0,0,0,, and it keeps track of all that you can imagine why this is not a 
Dialogue: 0,1:11:06.28,1:11:09.02,csapp,,0,0,0,,something you learn in a one semester course right that
Dialogue: 0,1:11:09.46,1:11:13.24,csapp,,0,0,0,,to keep track of all those different things flying by and make sure that it works 
Dialogue: 0,1:11:13.90,1:11:15.58,csapp,,0,0,0,,is a pretty tricky business
Dialogue: 0,1:11:16.06,1:11:18.48,csapp,,0,0,0,,but the conceptually it's a pretty simple idea
Dialogue: 0,1:11:18.80,1:11:24.02,csapp,,0,0,0,, that it just races off does a lot of things based purely on speculation 
Dialogue: 0,1:11:24.42,1:11:27.48,csapp,,0,0,0,,and then only if it makes a mistake it goes oh 
Dialogue: 0,1:11:27.76,1:11:29.14,csapp,,0,0,0,,and it sort of rolls back 
Dialogue: 0,1:11:29.94,1:11:32.62,csapp,,0,0,0,,to as if it had only executed up to a certain point 
Dialogue: 0,1:11:33.04,1:11:34.60,csapp,,0,0,0,,and then it moves forward 
Dialogue: 0,1:11:35.76,1:11:38.68,csapp,,0,0,0,,and starts in going the correct way 
Dialogue: 0,1:11:39.58,1:11:46.14,csapp,,0,0,0,,so end up and so and it can get away with this it's very interesting tricky stuff 
Dialogue: 0,1:11:46.48,1:11:48.80,csapp,,0,0,0,,but you remember we talked early in the course 
Dialogue: 0,1:11:49.54,1:11:53.92,csapp,,0,0,0,,about the difference between using conditional moves and conditional jumps 
Dialogue: 0,1:11:53.92,1:11:56.42,csapp,,0,0,0,,to implement conditional operations 
Dialogue: 0,1:11:57.08,1:12:03.72,csapp,,0,0,0,,and conditional moves can take place totally within the structure of this pipeline 
Dialogue: 0,1:12:04.36,1:12:07.92,csapp,,0,0,0,,but a conditional jump if it's an unpredictable branch
Dialogue: 0,1:12:08.32,1:12:13.14,csapp,,0,0,0,, the problem is it might go off executing  and make do a lot of wasted work 
Dialogue: 0,1:12:13.14,1:12:16.52,csapp,,0,0,0,,but even worse than when it gets back and has to restart 
Dialogue: 0,1:12:16.98,1:12:21.02,csapp,,0,0,0,,it takes a while to sort of fill up all the the buffers in the system 
Dialogue: 0,1:12:21.02,1:12:23.28,csapp,,0,0,0,,and get the whole thing running at full steam ahead
Dialogue: 0,1:12:27.55,1:12:32.44,csapp,,0,0,0,,  so that kind of finishes up then the the way I describe it is
Dialogue: 0,1:12:32.72,1:12:38.08,csapp,,0,0,0,, first of all don't do anything stupid even and stupid is probably it was too strong a word 
Dialogue: 0,1:12:38.08,1:12:44.94,csapp,,0,0,0,,don't do sort of keep in mind there's certain things that you should as a programmer be doing all the time 
Dialogue: 0,1:12:45.48,1:12:47.20,csapp,,0,0,0,,and they're not obvious
Dialogue: 0,1:12:47.72,1:12:52.54,csapp,,0,0,0,,and then begin thinking about tuning and getting some instruction level parallelism 
Dialogue: 0,1:12:53.22,1:12:58.24,csapp,,0,0,0,,and I describe it as for the machine but as I said pretty much all processors nowadays 
Dialogue: 0,1:12:58.48,1:13:01.98,csapp,,0,0,0,,it's a class of machines and so these general techniques will work
Dialogue: 0,1:13:02.46,1:13:05.58,csapp,,0,0,0,, that those ideas of changing the associativity
Dialogue: 0,1:13:05.78,1:13:10.86,csapp,,0,0,0,, they'll work whether it's a you know the ARM processor built into my cell phone 
Dialogue: 0,1:13:10.86,1:13:15.90,csapp,,0,0,0,,or the x86 processor built into your laptop  or one of the shark machines 
Dialogue: 0,1:13:15.90,1:13:19.72,csapp,,0,0,0,,they all have the same general of implementation structures 
Dialogue: 0,1:13:19.72,1:13:23.52,csapp,,0,0,0,,so these techniques will work across across all of them 
Dialogue: 0,1:13:24.34,1:13:28.57,csapp,,0,0,0,,okay that'll do us for today
