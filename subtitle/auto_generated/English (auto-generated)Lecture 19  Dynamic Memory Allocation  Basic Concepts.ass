[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video File: ../../../Desktop/csapp/Lecture 19  Dynamic Memory Allocation  Basic Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Active Line: 3
Video Position: 524

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:02.08,0:00:03.44,csapp,,0,0,0,,all right good afternoon everybody
Dialogue: 0,0:00:04.56,0:00:09.10,csapp,,0,0,0,,welcome good to see you all welcome also to our our viewers on video 
Dialogue: 0,0:00:10.56,0:00:15.12,csapp,,0,0,0,, so last week we looked at this this virtual memory mechanism 
Dialogue: 0,0:00:17.44,0:00:21.40,csapp,,0,0,0,,and how it provides so many different useful functionalities to the system 
Dialogue: 0,0:00:20.92,0:00:25.30,csapp,,0,0,0,,along with this sort of
Dialogue: 0,0:00:25.30,0:00:27.00,csapp,,0,0,0,,abstraction of having this large
Dialogue: 0,0:00:27.00,0:00:33.19,csapp,,0,0,0,,contiguous array of bytes now once we're
Dialogue: 0,0:00:33.19,0:00:36.73,csapp,,0,0,0,,given that that large array of bytes now
Dialogue: 0,0:00:36.73,0:00:42.34,csapp,,0,0,0,,we have to manage it and we have to we
Dialogue: 0,0:00:42.34,0:00:44.55,csapp,,0,0,0,,have to have some mechanism to to manage
Dialogue: 0,0:00:44.55,0:00:47.14,csapp,,0,0,0,,and use that that resource okay so
Dialogue: 0,0:00:47.14,0:00:51.30,csapp,,0,0,0,,that's the topic of our our lectures
Dialogue: 0,0:00:51.30,0:00:54.46,csapp,,0,0,0,,this week is a storage allocation and
Dialogue: 0,0:00:54.46,0:00:57.85,csapp,,0,0,0,,how storage allocators work and how you
Dialogue: 0,0:00:57.85,0:00:59.80,csapp,,0,0,0,,use them to manage the matter the
Dialogue: 0,0:00:59.80,0:01:06.93,csapp,,0,0,0,,virtual memory in your system so the the
Dialogue: 0,0:01:06.93,0:01:10.21,csapp,,0,0,0,,basic idea of a dynamic memory allocator
Dialogue: 0,0:01:10.21,0:01:13.99,csapp,,0,0,0,,is that applications use it to to
Dialogue: 0,0:01:13.99,0:01:17.47,csapp,,0,0,0,,manipulate virtual memory to create to
Dialogue: 0,0:01:17.47,0:01:21.00,csapp,,0,0,0,,to allocate and free chunks of virtual
Dialogue: 0,0:01:21.00,0:01:23.29,csapp,,0,0,0,,memory that you need in your program and
Dialogue: 0,0:01:23.29,0:01:26.22,csapp,,0,0,0,,it's this this memory is maintained in
Dialogue: 0,0:01:26.22,0:01:28.03,csapp,,0,0,0,,it in an area of virtual memory called
Dialogue: 0,0:01:28.03,0:01:32.38,csapp,,0,0,0,,the heap okay and although all all
Dialogue: 0,0:01:32.38,0:01:34.57,csapp,,0,0,0,,languages have some ask some mechanism
Dialogue: 0,0:01:34.57,0:01:36.93,csapp,,0,0,0,,for we're acquiring and manipulating
Dialogue: 0,0:01:36.93,0:01:45.68,csapp,,0,0,0,,this this this dynamic memory so in NC
Dialogue: 0,0:01:45.68,0:01:48.36,csapp,,0,0,0,,it's a phone it's the malloc package
Dialogue: 0,0:01:48.36,0:01:52.81,csapp,,0,0,0,,languages like Java have the new the new
Dialogue: 0,0:01:52.81,0:01:58.18,csapp,,0,0,0,,method now the allocator the allocator
Dialogue: 0,0:01:58.18,0:01:59.89,csapp,,0,0,0,,maintains the heap as a contiguous
Dialogue: 0,0:01:59.89,0:02:03.70,csapp,,0,0,0,,collection of blocks where and it blocks
Dialogue: 0,0:02:03.70,0:02:06.70,csapp,,0,0,0,,can be allocated or free ok allocated
Dialogue: 0,0:02:06.70,0:02:08.25,csapp,,0,0,0,,meaning that they're they're being used
Dialogue: 0,0:02:08.25,0:02:13.54,csapp,,0,0,0,,by some program application free meaning
Dialogue: 0,0:02:13.54,0:02:14.03,csapp,,0,0,0,,that there
Dialogue: 0,0:02:14.03,0:02:17.30,csapp,,0,0,0,,available to be for use by an
Dialogue: 0,0:02:17.30,0:02:20.12,csapp,,0,0,0,,application and there's there's two
Dialogue: 0,0:02:20.12,0:02:21.77,csapp,,0,0,0,,types of allocators the kind of
Dialogue: 0,0:02:21.77,0:02:24.59,csapp,,0,0,0,,allocator that you find in c such as the
Dialogue: 0,0:02:24.59,0:02:26.87,csapp,,0,0,0,,malloc package it's up to the
Dialogue: 0,0:02:26.87,0:02:30.23,csapp,,0,0,0,,application to both explicitly allocate
Dialogue: 0,0:02:30.23,0:02:32.75,csapp,,0,0,0,,the the memory and explicitly free it
Dialogue: 0,0:02:32.75,0:02:34.67,csapp,,0,0,0,,when when the when the application is
Dialogue: 0,0:02:34.67,0:02:36.38,csapp,,0,0,0,,finished with it okay so the system
Dialogue: 0,0:02:36.38,0:02:39.02,csapp,,0,0,0,,won't won't free up any memory that you
Dialogue: 0,0:02:39.02,0:02:42.95,csapp,,0,0,0,,allocate unless you do it explicitly by
Dialogue: 0,0:02:42.95,0:02:45.55,csapp,,0,0,0,,calling the by calling the free function
Dialogue: 0,0:02:45.55,0:02:49.94,csapp,,0,0,0,,but there's other languages that that
Dialogue: 0,0:02:49.94,0:02:52.55,csapp,,0,0,0,,support implicit allocators and in these
Dialogue: 0,0:02:52.55,0:02:55.04,csapp,,0,0,0,,in these implicit allocators the
Dialogue: 0,0:02:55.04,0:02:58.40,csapp,,0,0,0,,programmer al explicitly allocates
Dialogue: 0,0:02:58.40,0:03:01.55,csapp,,0,0,0,,memory but then the system takes care of
Dialogue: 0,0:03:01.55,0:03:04.22,csapp,,0,0,0,,freeing the memory okay so it's that the
Dialogue: 0,0:03:04.22,0:03:07.04,csapp,,0,0,0,,burden of freeing the memory is shifted
Dialogue: 0,0:03:07.04,0:03:10.04,csapp,,0,0,0,,from the application program to the to
Dialogue: 0,0:03:10.04,0:03:13.19,csapp,,0,0,0,,the system and it it frees this memory
Dialogue: 0,0:03:13.19,0:03:15.05,csapp,,0,0,0,,implicitly sort of behind the scenes
Dialogue: 0,0:03:15.05,0:03:16.58,csapp,,0,0,0,,using a process called garbage
Dialogue: 0,0:03:16.58,0:03:19.29,csapp,,0,0,0,,collection okay so languages like Java
Dialogue: 0,0:03:19.29,0:03:23.20,csapp,,0,0,0,,ml Lisp um they all they all do implicit
Dialogue: 0,0:03:23.20,0:03:25.67,csapp,,0,0,0,,implicit they all support in close at
Dialogue: 0,0:03:25.67,0:03:28.07,csapp,,0,0,0,,allocators now today we're going to just
Dialogue: 0,0:03:28.07,0:03:30.20,csapp,,0,0,0,,we're going to discuss explicit memory
Dialogue: 0,0:03:30.20,0:03:32.65,csapp,,0,0,0,,alligators on Thursday we'll get into
Dialogue: 0,0:03:32.65,0:03:36.64,csapp,,0,0,0,,implicit alligators and how they work
Dialogue: 0,0:03:36.64,0:03:40.19,csapp,,0,0,0,,now the alligator and C is provided it
Dialogue: 0,0:03:40.19,0:03:44.06,csapp,,0,0,0,,by the standard c library in a set of
Dialogue: 0,0:03:44.06,0:03:48.44,csapp,,0,0,0,,function called malloc package the the
Dialogue: 0,0:03:48.44,0:03:50.81,csapp,,0,0,0,,malloc function is used to to allocate
Dialogue: 0,0:03:50.81,0:03:53.95,csapp,,0,0,0,,memory and it takes as input a size
Dialogue: 0,0:03:53.95,0:03:57.65,csapp,,0,0,0,,argument which is in bytes okay and then
Dialogue: 0,0:03:57.65,0:04:01.37,csapp,,0,0,0,,it returns a pointer to a to a memory
Dialogue: 0,0:04:01.37,0:04:04.04,csapp,,0,0,0,,block that contains at least size bytes
Dialogue: 0,0:04:04.04,0:04:07.43,csapp,,0,0,0,,and that block is the line T on x86
Dialogue: 0,0:04:07.43,0:04:10.88,csapp,,0,0,0,,systems to eight bytes on x86 64 systems
Dialogue: 0,0:04:10.88,0:04:16.60,csapp,,0,0,0,,to 16 bytes if size is 0 it returns null
Dialogue: 0,0:04:16.60,0:04:20.47,csapp,,0,0,0,,and then it returns minus 1 like like
Dialogue: 0,0:04:20.47,0:04:22.94,csapp,,0,0,0,,most typical
Dialogue: 0,0:04:22.94,0:04:27.36,csapp,,0,0,0,,system calls the programmer frees memory
Dialogue: 0,0:04:27.36,0:04:31.35,csapp,,0,0,0,,by calling the free function it takes as
Dialogue: 0,0:04:31.35,0:04:34.50,csapp,,0,0,0,,an argument a pointer that was returned
Dialogue: 0,0:04:34.50,0:04:36.57,csapp,,0,0,0,,from some prior invocation of malloc and
Dialogue: 0,0:04:36.57,0:04:42.47,csapp,,0,0,0,,it returns nothing and it frees that
Dialogue: 0,0:04:42.47,0:04:44.85,csapp,,0,0,0,,I've given this pointer that was
Dialogue: 0,0:04:44.85,0:04:46.47,csapp,,0,0,0,,returned by the prior indication of
Dialogue: 0,0:04:46.47,0:04:48.81,csapp,,0,0,0,,malloc it frees the block at that
Dialogue: 0,0:04:48.81,0:04:52.74,csapp,,0,0,0,,address and then returns that block to
Dialogue: 0,0:04:52.74,0:04:55.80,csapp,,0,0,0,,the pool of available memory now there's
Dialogue: 0,0:04:55.80,0:04:59.30,csapp,,0,0,0,,some there's some other functions so
Dialogue: 0,0:04:59.30,0:05:02.10,csapp,,0,0,0,,sialic is a version of malloc that gives
Dialogue: 0,0:05:02.10,0:05:04.26,csapp,,0,0,0,,you an initialized block of memory
Dialogue: 0,0:05:04.26,0:05:06.17,csapp,,0,0,0,,that's initialized to 0
Dialogue: 0,0:05:06.17,0:05:09.24,csapp,,0,0,0,,and realloc you can you can malloc a
Dialogue: 0,0:05:09.24,0:05:10.92,csapp,,0,0,0,,block and then call realloc to change
Dialogue: 0,0:05:10.92,0:05:12.87,csapp,,0,0,0,,the size of that previously allocated
Dialogue: 0,0:05:12.87,0:05:16.08,csapp,,0,0,0,,block and then there's a function called
Dialogue: 0,0:05:16.08,0:05:18.27,csapp,,0,0,0,,S break which is used internally by
Dialogue: 0,0:05:18.27,0:05:20.37,csapp,,0,0,0,,allocators to grow and shrink the heap
Dialogue: 0,0:05:20.37,0:05:22.40,csapp,,0,0,0,,so when an allocator needs more memory
Dialogue: 0,0:05:22.40,0:05:25.83,csapp,,0,0,0,,it calls S break to to get that
Dialogue: 0,0:05:25.83,0:05:27.99,csapp,,0,0,0,,additional virtual memory and then that
Dialogue: 0,0:05:27.99,0:05:30.18,csapp,,0,0,0,,that's added to the heap that the
Dialogue: 0,0:05:30.18,0:05:32.61,csapp,,0,0,0,,portion that grows the heap and then it
Dialogue: 0,0:05:32.61,0:05:34.41,csapp,,0,0,0,,adds it to the memory that the the
Dialogue: 0,0:05:34.41,0:05:39.77,csapp,,0,0,0,,allocator is is manipulating
Dialogue: 0,0:05:39.77,0:05:41.99,csapp,,0,0,0,,so here's an example of how we would use
Dialogue: 0,0:05:41.99,0:05:45.28,csapp,,0,0,0,,Malik and it's in a simple program we
Dialogue: 0,0:05:45.28,0:05:50.59,csapp,,0,0,0,,have a pointer to an int P and we call
Dialogue: 0,0:05:50.59,0:05:53.75,csapp,,0,0,0,,malloc and we we want to allocate an
Dialogue: 0,0:05:53.75,0:05:56.75,csapp,,0,0,0,,array of N in so this is that this is
Dialogue: 0,0:05:56.75,0:05:59.33,csapp,,0,0,0,,sort of the standard way you call it we
Dialogue: 0,0:05:59.33,0:06:02.33,csapp,,0,0,0,,want n int and so we we call it with n
Dialogue: 0,0:06:02.33,0:06:04.97,csapp,,0,0,0,,times the size event because remember
Dialogue: 0,0:06:04.97,0:06:08.66,csapp,,0,0,0,,the argument is in bytes malloc returns
Dialogue: 0,0:06:08.66,0:06:11.87,csapp,,0,0,0,,a pointer it returns that generic
Dialogue: 0,0:06:11.87,0:06:15.53,csapp,,0,0,0,,pointer void star pointer so we cast it
Dialogue: 0,0:06:15.53,0:06:18.74,csapp,,0,0,0,,to a pointer to an int to keep keep the
Dialogue: 0,0:06:18.74,0:06:21.40,csapp,,0,0,0,,compiler happy and then assign it to to
Dialogue: 0,0:06:21.40,0:06:27.16,csapp,,0,0,0,,P we check for a we check for a null
Dialogue: 0,0:06:27.16,0:06:31.90,csapp,,0,0,0,,return value so I should I should point
Dialogue: 0,0:06:31.90,0:06:35.69,csapp,,0,0,0,,out the it returns 0 on error so we
Dialogue: 0,0:06:35.69,0:06:39.25,csapp,,0,0,0,,check we recheck recheck for this no the
Dialogue: 0,0:06:39.25,0:06:43.43,csapp,,0,0,0,,snow pointer which is 0 in print an
Dialogue: 0,0:06:43.43,0:06:46.46,csapp,,0,0,0,,error if it's no now once we've got that
Dialogue: 0,0:06:46.46,0:06:48.83,csapp,,0,0,0,,pointer now P we can treat it just like
Dialogue: 0,0:06:48.83,0:06:52.21,csapp,,0,0,0,,an array so we can so inside the loop if
Dialogue: 0,0:06:52.21,0:06:56.41,csapp,,0,0,0,,we want to initialize it we loop across
Dialogue: 0,0:06:56.41,0:06:57.88,csapp,,0,0,0,,the elements of the array
Dialogue: 0,0:06:57.88,0:07:01.19,csapp,,0,0,0,,initializing each one to some value now
Dialogue: 0,0:07:01.19,0:07:03.02,csapp,,0,0,0,,when we're finished when we're finished
Dialogue: 0,0:07:03.02,0:07:04.31,csapp,,0,0,0,,with this chunk of memory that we've
Dialogue: 0,0:07:04.31,0:07:06.05,csapp,,0,0,0,,allocated then we free it by calling
Dialogue: 0,0:07:06.05,0:07:11.75,csapp,,0,0,0,,free with the pointer P
Dialogue: 0,0:07:11.75,0:07:14.84,csapp,,0,0,0,,okay now the so we're going to look
Dialogue: 0,0:07:14.84,0:07:17.63,csapp,,0,0,0,,today at how functions like malloc and
Dialogue: 0,0:07:17.63,0:07:19.97,csapp,,0,0,0,,free are implemented so we're going to
Dialogue: 0,0:07:19.97,0:07:23.93,csapp,,0,0,0,,make a few simplifying assumptions so
Dialogue: 0,0:07:23.93,0:07:28.49,csapp,,0,0,0,,I'm going to memory it is byte address
Dialogue: 0,0:07:28.49,0:07:30.33,csapp,,0,0,0,,we know that but for the purposes of
Dialogue: 0,0:07:30.33,0:07:31.74,csapp,,0,0,0,,this lecture we're going to assume that
Dialogue: 0,0:07:31.74,0:07:33.33,csapp,,0,0,0,,it's it's word address okay so we're
Dialogue: 0,0:07:33.33,0:07:37.66,csapp,,0,0,0,,just going to look at word size units
Dialogue: 0,0:07:37.66,0:07:41.61,csapp,,0,0,0,,and I'm going to assume that words are 4
Dialogue: 0,0:07:41.61,0:07:47.58,csapp,,0,0,0,,bytes so they basically the size of an
Dialogue: 0,0:07:47.58,0:07:52.31,csapp,,0,0,0,,int so this isn't actually this this
Dialogue: 0,0:07:52.31,0:07:56.39,csapp,,0,0,0,,isn't true I need to fix that so
Dialogue: 0,0:07:56.39,0:07:57.80,csapp,,0,0,0,,basically we're going to we're going to
Dialogue: 0,0:07:57.80,0:08:00.71,csapp,,0,0,0,,think of words as four byte quantity
Dialogue: 0,0:08:00.71,0:08:05.37,csapp,,0,0,0,,sort of integer size quantities and then
Dialogue: 0,0:08:05.37,0:08:07.37,csapp,,0,0,0,,our blocks or contiguous chunks of those
Dialogue: 0,0:08:07.37,0:08:09.24,csapp,,0,0,0,,words that can be either allocated or
Dialogue: 0,0:08:09.24,0:08:12.87,csapp,,0,0,0,,free so here we have a portion of the
Dialogue: 0,0:08:12.87,0:08:15.02,csapp,,0,0,0,,heap which consists of a four word
Dialogue: 0,0:08:15.02,0:08:17.53,csapp,,0,0,0,,allocated block followed by a two word
Dialogue: 0,0:08:17.53,0:08:21.33,csapp,,0,0,0,,free block followed by another for word
Dialogue: 0,0:08:21.33,0:08:24.14,csapp,,0,0,0,,allocated block followed by a three word
Dialogue: 0,0:08:24.14,0:08:26.37,csapp,,0,0,0,,free blocking and we'll indicate these
Dialogue: 0,0:08:26.37,0:08:29.09,csapp,,0,0,0,,free blocks white by white and will
Dialogue: 0,0:08:29.09,0:08:31.43,csapp,,0,0,0,,indicate allocated blocks with some some
Dialogue: 0,0:08:31.43,0:08:37.26,csapp,,0,0,0,,shade of of color so let's look now how
Dialogue: 0,0:08:37.26,0:08:40.50,csapp,,0,0,0,,a sequence of of allocations and freeze
Dialogue: 0,0:08:40.50,0:08:43.94,csapp,,0,0,0,,would work and now notice I'm calling
Dialogue: 0,0:08:43.94,0:08:46.82,csapp,,0,0,0,,malloc with the size of in words not
Dialogue: 0,0:08:46.82,0:08:49.41,csapp,,0,0,0,,bytes just to keep just to keep things
Dialogue: 0,0:08:49.41,0:08:54.56,csapp,,0,0,0,,keep these pictures simpler
Dialogue: 0,0:08:54.56,0:08:58.49,csapp,,0,0,0,,so in this first we call malloc and
Dialogue: 0,0:08:58.49,0:09:04.37,csapp,,0,0,0,,allocate of a forward block then we can
Dialogue: 0,0:09:04.37,0:09:06.11,csapp,,0,0,0,,that and that gives us a pointer P 1
Dialogue: 0,0:09:06.11,0:09:08.08,csapp,,0,0,0,,then we call malloc again to get a
Dialogue: 0,0:09:08.08,0:09:10.87,csapp,,0,0,0,,five-word block so it just takes it one
Dialogue: 0,0:09:10.87,0:09:15.64,csapp,,0,0,0,,of the free words and allocates it we
Dialogue: 0,0:09:15.64,0:09:17.48,csapp,,0,0,0,,call malloc again to get a six word
Dialogue: 0,0:09:17.48,0:09:21.07,csapp,,0,0,0,,block and then we free the block that's
Dialogue: 0,0:09:21.07,0:09:25.32,csapp,,0,0,0,,pointed at by P to this purple block
Dialogue: 0,0:09:25.32,0:09:28.39,csapp,,0,0,0,,okay so now we that frees up that block
Dialogue: 0,0:09:28.39,0:09:31.97,csapp,,0,0,0,,and then we do another allocation for a
Dialogue: 0,0:09:31.97,0:09:35.17,csapp,,0,0,0,,two word block and so the the allocator
Dialogue: 0,0:09:35.17,0:09:37.69,csapp,,0,0,0,,looks to see if it can find a free block
Dialogue: 0,0:09:37.69,0:09:40.69,csapp,,0,0,0,,that has enough enough room and it finds
Dialogue: 0,0:09:40.69,0:09:42.35,csapp,,0,0,0,,that it finds this free block here that
Dialogue: 0,0:09:42.35,0:09:46.12,csapp,,0,0,0,,has five free words and then it
Dialogue: 0,0:09:46.12,0:09:50.50,csapp,,0,0,0,,allocates the the requested block inside
Dialogue: 0,0:09:50.50,0:09:58.04,csapp,,0,0,0,,of that that free block now allocators
Dialogue: 0,0:09:58.04,0:10:00.25,csapp,,0,0,0,,work under a lot of a lot of different
Dialogue: 0,0:10:00.25,0:10:02.00,csapp,,0,0,0,,constraints okay so it's hard to write
Dialogue: 0,0:10:02.00,0:10:03.35,csapp,,0,0,0,,an allocator because of all these
Dialogue: 0,0:10:03.35,0:10:07.91,csapp,,0,0,0,,constraints applications can choose any
Dialogue: 0,0:10:07.91,0:10:10.69,csapp,,0,0,0,,combination of allocated and free blocks
Dialogue: 0,0:10:10.69,0:10:12.76,csapp,,0,0,0,,so you can't predict what what an
Dialogue: 0,0:10:12.76,0:10:16.12,csapp,,0,0,0,,application is going to request and and
Dialogue: 0,0:10:16.12,0:10:19.25,csapp,,0,0,0,,the application is required to free a
Dialogue: 0,0:10:19.25,0:10:21.47,csapp,,0,0,0,,block by when it frees a block to pass a
Dialogue: 0,0:10:21.47,0:10:24.11,csapp,,0,0,0,,pointer that was returned from a
Dialogue: 0,0:10:24.11,0:10:26.89,csapp,,0,0,0,,previous invocation of malloc okay so
Dialogue: 0,0:10:26.89,0:10:28.63,csapp,,0,0,0,,the the application has a few
Dialogue: 0,0:10:28.63,0:10:32.05,csapp,,0,0,0,,constraints but but really the only one
Dialogue: 0,0:10:32.05,0:10:34.37,csapp,,0,0,0,,that it has is that the fact that the
Dialogue: 0,0:10:34.37,0:10:36.62,csapp,,0,0,0,,when it frees something it has to be a
Dialogue: 0,0:10:36.62,0:10:38.72,csapp,,0,0,0,,pointer from a previous invocation of
Dialogue: 0,0:10:38.72,0:10:39.23,csapp,,0,0,0,,malloc
Dialogue: 0,0:10:39.23,0:10:43.12,csapp,,0,0,0,,now the malloc operates or allocators
Dialogue: 0,0:10:43.12,0:10:44.68,csapp,,0,0,0,,like malloc operate under a lot of
Dialogue: 0,0:10:44.68,0:10:47.02,csapp,,0,0,0,,different constraints they can't control
Dialogue: 0,0:10:47.02,0:10:49.06,csapp,,0,0,0,,the size or the number of the allocated
Dialogue: 0,0:10:49.06,0:10:51.41,csapp,,0,0,0,,blocks because they have no control over
Dialogue: 0,0:10:51.41,0:10:55.18,csapp,,0,0,0,,the what the application is doing if an
Dialogue: 0,0:10:55.18,0:10:57.52,csapp,,0,0,0,,application calls Malik Malik has to
Dialogue: 0,0:10:57.52,0:11:00.31,csapp,,0,0,0,,respond right away it might you might be
Dialogue: 0,0:11:00.31,0:11:02.42,csapp,,0,0,0,,able to do a better more efficient
Dialogue: 0,0:11:02.42,0:11:04.93,csapp,,0,0,0,,version by batching up requests and then
Dialogue: 0,0:11:04.93,0:11:07.45,csapp,,0,0,0,,responding to all those requests at once
Dialogue: 0,0:11:07.45,0:11:09.35,csapp,,0,0,0,,which the allocator can't do it when it
Dialogue: 0,0:11:09.35,0:11:11.36,csapp,,0,0,0,,gets called it has to process the
Dialogue: 0,0:11:11.36,0:11:14.80,csapp,,0,0,0,,request and then return right away it
Dialogue: 0,0:11:14.80,0:11:16.22,csapp,,0,0,0,,has to of course it has to allocate
Dialogue: 0,0:11:16.22,0:11:17.92,csapp,,0,0,0,,blocks from free memory so it can't
Dialogue: 0,0:11:17.92,0:11:20.50,csapp,,0,0,0,,in general I can't touch any allocated
Dialogue: 0,0:11:20.50,0:11:22.67,csapp,,0,0,0,,block right once it allocates a block
Dialogue: 0,0:11:22.67,0:11:25.10,csapp,,0,0,0,,that block belongs to the application
Dialogue: 0,0:11:25.10,0:11:28.79,csapp,,0,0,0,,and the the malloc package can't touch
Dialogue: 0,0:11:28.79,0:11:30.37,csapp,,0,0,0,,it now this this has a number of
Dialogue: 0,0:11:30.37,0:11:33.74,csapp,,0,0,0,,implications so this means that the
Dialogue: 0,0:11:33.74,0:11:37.97,csapp,,0,0,0,,allocator can't it can't move blocks
Dialogue: 0,0:11:37.97,0:11:39.92,csapp,,0,0,0,,around like it can't compress blocks
Dialogue: 0,0:11:39.92,0:11:41.60,csapp,,0,0,0,,like an alligator might want to take
Dialogue: 0,0:11:41.60,0:11:43.63,csapp,,0,0,0,,allocated blocks and smoosh them all
Dialogue: 0,0:11:43.63,0:11:46.04,csapp,,0,0,0,,together to create larger free blocks
Dialogue: 0,0:11:46.04,0:11:49.05,csapp,,0,0,0,,hey but it can't do that okay so once
Dialogue: 0,0:11:49.05,0:11:52.06,csapp,,0,0,0,,you know in a language like C once once
Dialogue: 0,0:11:52.06,0:11:55.12,csapp,,0,0,0,,an alligator gives a block to a an
Dialogue: 0,0:11:55.12,0:11:58.97,csapp,,0,0,0,,application it can't touch it okay now
Dialogue: 0,0:11:58.97,0:12:02.05,csapp,,0,0,0,,blocks like blocked because blocks are
Dialogue: 0,0:12:02.05,0:12:03.98,csapp,,0,0,0,,holding data structures like strux
Dialogue: 0,0:12:03.98,0:12:08.95,csapp,,0,0,0,,or you know scalar scalar objects it has
Dialogue: 0,0:12:08.95,0:12:10.93,csapp,,0,0,0,,to be aligned to the size of the largest
Dialogue: 0,0:12:10.93,0:12:13.93,csapp,,0,0,0,,object that that can occur okay so for
Dialogue: 0,0:12:13.93,0:12:16.75,csapp,,0,0,0,,64-bit systems that's 16 byte alignment
Dialogue: 0,0:12:16.75,0:12:23.76,csapp,,0,0,0,,for 32-bit systems it's 8 byte alignment
Dialogue: 0,0:12:23.76,0:12:26.82,csapp,,0,0,0,,now alligators are really interesting
Dialogue: 0,0:12:26.82,0:12:29.62,csapp,,0,0,0,,objects because they they combine a
Dialogue: 0,0:12:29.62,0:12:33.67,csapp,,0,0,0,,trade-off of both so running time sort
Dialogue: 0,0:12:33.67,0:12:36.40,csapp,,0,0,0,,of speed and space so it's kind of a
Dialogue: 0,0:12:36.40,0:12:38.68,csapp,,0,0,0,,space and performance trade-off you're
Dialogue: 0,0:12:38.68,0:12:40.33,csapp,,0,0,0,,trying to optimize both you want it to
Dialogue: 0,0:12:40.33,0:12:42.94,csapp,,0,0,0,,run as quickly as possible but you want
Dialogue: 0,0:12:42.94,0:12:45.19,csapp,,0,0,0,,to you wanted to use the virtual memory
Dialogue: 0,0:12:45.19,0:12:47.71,csapp,,0,0,0,,in the heap as efficiently as possible
Dialogue: 0,0:12:47.71,0:12:52.54,csapp,,0,0,0,,okay so let's and we define these these
Dialogue: 0,0:12:52.54,0:12:57.97,csapp,,0,0,0,,sort of speed and and efficiency memory
Dialogue: 0,0:12:57.97,0:13:00.25,csapp,,0,0,0,,efficiency metrics we have we have two
Dialogue: 0,0:13:00.25,0:13:01.77,csapp,,0,0,0,,metrics that we use one is called
Dialogue: 0,0:13:01.77,0:13:04.66,csapp,,0,0,0,,throughput so given some sequence of
Dialogue: 0,0:13:04.66,0:13:08.86,csapp,,0,0,0,,malloc and free requests are 0 through R
Dialogue: 0,0:13:08.86,0:13:12.46,csapp,,0,0,0,,and minus 1 so just some where R is
Dialogue: 0,0:13:12.46,0:13:16.51,csapp,,0,0,0,,either a malloc or free our goal is to
Dialogue: 0,0:13:16.51,0:13:20.47,csapp,,0,0,0,,maximize throughput and the peak memory
Dialogue: 0,0:13:20.47,0:13:23.88,csapp,,0,0,0,,utilization and what makes malloc such a
Dialogue: 0,0:13:23.88,0:13:26.02,csapp,,0,0,0,,fascinating and interesting study is
Dialogue: 0,0:13:26.02,0:13:29.35,csapp,,0,0,0,,that these often conflict like it's very
Dialogue: 0,0:13:29.35,0:13:31.57,csapp,,0,0,0,,easy to make a really fast malloc that
Dialogue: 0,0:13:31.57,0:13:36.64,csapp,,0,0,0,,that has terrible memory utilization so
Dialogue: 0,0:13:36.64,0:13:38.91,csapp,,0,0,0,,throughput is just the number of
Dialogue: 0,0:13:38.91,0:13:41.29,csapp,,0,0,0,,recomputed requests per unit time so if
Dialogue: 0,0:13:41.29,0:13:44.50,csapp,,0,0,0,,we have 5,000 malloc calls and 5,000
Dialogue: 0,0:13:44.50,0:13:47.26,csapp,,0,0,0,,free calls in 10 seconds then our
Dialogue: 0,0:13:47.26,0:13:49.15,csapp,,0,0,0,,throughput is a thousand operations per
Dialogue: 0,0:13:49.15,0:13:52.72,csapp,,0,0,0,,second so it's just measuring sort of
Dialogue: 0,0:13:52.72,0:13:55.54,csapp,,0,0,0,,how efficiently are our malloc can can
Dialogue: 0,0:13:55.54,0:13:57.01,csapp,,0,0,0,,process these requests from an
Dialogue: 0,0:13:57.01,0:14:00.14,csapp,,0,0,0,,application
Dialogue: 0,0:14:00.14,0:14:06.74,csapp,,0,0,0,,now peak memory utilization is a measure
Dialogue: 0,0:14:06.74,0:14:11.51,csapp,,0,0,0,,sort of how how much useful space so how
Dialogue: 0,0:14:11.51,0:14:14.45,csapp,,0,0,0,,much it measured how efficiently the
Dialogue: 0,0:14:14.45,0:14:16.94,csapp,,0,0,0,,allocator uses the heat sort of how much
Dialogue: 0,0:14:16.94,0:14:19.76,csapp,,0,0,0,,is wasted on sort of overheads in the
Dialogue: 0,0:14:19.76,0:14:22.13,csapp,,0,0,0,,data structures that the allocator has
Dialogue: 0,0:14:22.13,0:14:26.24,csapp,,0,0,0,,to uses to in its implementation so
Dialogue: 0,0:14:26.24,0:14:30.07,csapp,,0,0,0,,we'll define a payload when when malloc
Dialogue: 0,0:14:30.07,0:14:33.32,csapp,,0,0,0,,returns a block what when it I'm sorry
Dialogue: 0,0:14:33.32,0:14:34.73,csapp,,0,0,0,,what an application makes a call to
Dialogue: 0,0:14:34.73,0:14:37.49,csapp,,0,0,0,,malloc it's requesting a certain size
Dialogue: 0,0:14:37.49,0:14:40.49,csapp,,0,0,0,,block and that that block is called the
Dialogue: 0,0:14:40.49,0:14:42.95,csapp,,0,0,0,,payload so if we call malloc with an
Dialogue: 0,0:14:42.95,0:14:45.92,csapp,,0,0,0,,argument of 10 bytes we're requesting a
Dialogue: 0,0:14:45.92,0:14:49.01,csapp,,0,0,0,,block that has a payload of it that's at
Dialogue: 0,0:14:49.01,0:14:52.01,csapp,,0,0,0,,least size 10 okay and the 10 bytes that
Dialogue: 0,0:14:52.01,0:14:53.57,csapp,,0,0,0,,we request that are called the payload
Dialogue: 0,0:14:53.57,0:14:55.76,csapp,,0,0,0,,everything else in that block is is
Dialogue: 0,0:14:55.76,0:15:03.35,csapp,,0,0,0,,overhead okay so after after we've run a
Dialogue: 0,0:15:03.35,0:15:06.91,csapp,,0,0,0,,sequence of requests the aggregate
Dialogue: 0,0:15:06.91,0:15:09.62,csapp,,0,0,0,,payload is the sum of all the the
Dialogue: 0,0:15:09.62,0:15:11.30,csapp,,0,0,0,,payloads in the currently allocated
Dialogue: 0,0:15:11.30,0:15:14.80,csapp,,0,0,0,,blocks okay so in a perfect allocator
Dialogue: 0,0:15:14.80,0:15:19.37,csapp,,0,0,0,,the the aggregate payload would would
Dialogue: 0,0:15:19.37,0:15:21.94,csapp,,0,0,0,,would equal the amount of memory the
Dialogue: 0,0:15:21.94,0:15:23.77,csapp,,0,0,0,,total size of all the allocated blocks
Dialogue: 0,0:15:23.77,0:15:25.01,csapp,,0,0,0,,right because there'd be no overhead
Dialogue: 0,0:15:25.01,0:15:27.56,csapp,,0,0,0,,would just be we just be pure every
Dialogue: 0,0:15:27.56,0:15:33.18,csapp,,0,0,0,,block would be pure payload
Dialogue: 0,0:15:33.18,0:15:35.49,csapp,,0,0,0,,now we're going to assume that the heap
Dialogue: 0,0:15:35.49,0:15:38.37,csapp,,0,0,0,,is is monotonically non-decreasing so it
Dialogue: 0,0:15:38.37,0:15:41.34,csapp,,0,0,0,,always gets bigger okay so are this is a
Dialogue: 0,0:15:41.34,0:15:43.59,csapp,,0,0,0,,simplifying assumption it's not it's not
Dialogue: 0,0:15:43.59,0:15:46.08,csapp,,0,0,0,,true in a real Malak package but we'll
Dialogue: 0,0:15:46.08,0:15:47.96,csapp,,0,0,0,,just assume that the allocator never
Dialogue: 0,0:15:47.96,0:15:50.34,csapp,,0,0,0,,decreases the size of the heap it only
Dialogue: 0,0:15:50.34,0:15:57.06,csapp,,0,0,0,,increases the size of the heap okay so
Dialogue: 0,0:15:57.06,0:15:59.67,csapp,,0,0,0,,the peak given those given those notions
Dialogue: 0,0:15:59.67,0:16:03.87,csapp,,0,0,0,,of aggregate payload and heap size the
Dialogue: 0,0:16:03.87,0:16:07.32,csapp,,0,0,0,,peak memory utilization after k plus 1
Dialogue: 0,0:16:07.32,0:16:12.48,csapp,,0,0,0,,requests is the sum of all the is the
Dialogue: 0,0:16:12.48,0:16:15.87,csapp,,0,0,0,,sum of all the payloads divided by the
Dialogue: 0,0:16:15.87,0:16:20.76,csapp,,0,0,0,,total size of the heap so the in the
Dialogue: 0,0:16:20.76,0:16:25.37,csapp,,0,0,0,,best case each each block in the heap
Dialogue: 0,0:16:25.37,0:16:28.14,csapp,,0,0,0,,consists of pure payload so the
Dialogue: 0,0:16:28.14,0:16:30.86,csapp,,0,0,0,,utilization would be 1 that's the best
Dialogue: 0,0:16:30.86,0:16:34.65,csapp,,0,0,0,,we can do but in practice each block the
Dialogue: 0,0:16:34.65,0:16:37.53,csapp,,0,0,0,,allocator is going to place have data
Dialogue: 0,0:16:37.53,0:16:39.45,csapp,,0,0,0,,structures and padding inside of each
Dialogue: 0,0:16:39.45,0:16:43.86,csapp,,0,0,0,,block that that that keep it from
Dialogue: 0,0:16:43.86,0:16:46.56,csapp,,0,0,0,,getting a perfect utilization now one
Dialogue: 0,0:16:46.56,0:16:48.63,csapp,,0,0,0,,one obvious thing is that since blocks
Dialogue: 0,0:16:48.63,0:16:52.29,csapp,,0,0,0,,have to be aligned to some you know if
Dialogue: 0,0:16:52.29,0:16:54.54,csapp,,0,0,0,,they're 16-byte aligned then blocks have
Dialogue: 0,0:16:54.54,0:16:56.37,csapp,,0,0,0,,to start on 16 byte boundaries and they
Dialogue: 0,0:16:56.37,0:16:59.25,csapp,,0,0,0,,have to be at least 16 bytes so if you
Dialogue: 0,0:16:59.25,0:17:01.50,csapp,,0,0,0,,were to request a payload of 2 bytes
Dialogue: 0,0:17:01.50,0:17:04.26,csapp,,0,0,0,,you'd have a lot of wasted bytes right
Dialogue: 0,0:17:04.26,0:17:06.06,csapp,,0,0,0,,that would sort of decrease the
Dialogue: 0,0:17:06.06,0:17:09.27,csapp,,0,0,0,,utilization so this is some of this some
Dialogue: 0,0:17:09.27,0:17:12.18,csapp,,0,0,0,,of this overhead is unavoidable but your
Dialogue: 0,0:17:12.18,0:17:14.97,csapp,,0,0,0,,job as a someone who writes them
Dialogue: 0,0:17:14.97,0:17:17.28,csapp,,0,0,0,,implements malloc is to try to keep that
Dialogue: 0,0:17:17.28,0:17:21.94,csapp,,0,0,0,,as small as possible
Dialogue: 0,0:17:21.94,0:17:25.48,csapp,,0,0,0,,so poor memory utilization is this
Dialogue: 0,0:17:25.48,0:17:27.10,csapp,,0,0,0,,example that we just talked about is an
Dialogue: 0,0:17:27.10,0:17:29.82,csapp,,0,0,0,,example of what we call fragmentation
Dialogue: 0,0:17:29.82,0:17:31.93,csapp,,0,0,0,,and there's there's two types of
Dialogue: 0,0:17:31.93,0:17:35.08,csapp,,0,0,0,,fragmentation internal fragmentation
Dialogue: 0,0:17:35.08,0:17:37.48,csapp,,0,0,0,,occurs if the payload is smaller than
Dialogue: 0,0:17:37.48,0:17:38.82,csapp,,0,0,0,,the block size so it's just what we're
Dialogue: 0,0:17:38.82,0:17:41.74,csapp,,0,0,0,,talking about and this can be caused by
Dialogue: 0,0:17:41.74,0:17:45.67,csapp,,0,0,0,,either padding in the block or some kind
Dialogue: 0,0:17:45.67,0:17:47.14,csapp,,0,0,0,,of data structure in the block that the
Dialogue: 0,0:17:47.14,0:17:52.69,csapp,,0,0,0,,allocator needs sometimes to it you
Dialogue: 0,0:17:52.69,0:17:54.49,csapp,,0,0,0,,might make a policy decision that if at
Dialogue: 0,0:17:54.49,0:17:57.07,csapp,,0,0,0,,if application requests a small block
Dialogue: 0,0:17:57.07,0:17:59.35,csapp,,0,0,0,,you might return a larger block just to
Dialogue: 0,0:17:59.35,0:18:01.66,csapp,,0,0,0,,keep so the blocks don't get sort of
Dialogue: 0,0:18:01.66,0:18:03.34,csapp,,0,0,0,,splintered up into little chunks you
Dialogue: 0,0:18:03.34,0:18:06.31,csapp,,0,0,0,,might want to keep blocks at some
Dialogue: 0,0:18:06.31,0:18:12.14,csapp,,0,0,0,,minimum size
Dialogue: 0,0:18:12.14,0:18:16.19,csapp,,0,0,0,,now internal fragmentation you know
Dialogue: 0,0:18:16.19,0:18:20.15,csapp,,0,0,0,,given a series of requests we can we can
Dialogue: 0,0:18:20.15,0:18:22.04,csapp,,0,0,0,,just stop and freeze the heap and it's
Dialogue: 0,0:18:22.04,0:18:24.74,csapp,,0,0,0,,very easy to sort of compute the amount
Dialogue: 0,0:18:24.74,0:18:26.63,csapp,,0,0,0,,of internal fragmentation we can at any
Dialogue: 0,0:18:26.63,0:18:29.15,csapp,,0,0,0,,point in time we can just look at all
Dialogue: 0,0:18:29.15,0:18:31.88,csapp,,0,0,0,,the previous requests that we we've made
Dialogue: 0,0:18:31.88,0:18:34.58,csapp,,0,0,0,,and and look at the size of the payload
Dialogue: 0,0:18:34.58,0:18:38.54,csapp,,0,0,0,,for each one of those requests and so we
Dialogue: 0,0:18:38.54,0:18:43.25,csapp,,0,0,0,,can so we can determine the level you
Dialogue: 0,0:18:43.25,0:18:44.57,csapp,,0,0,0,,know get at a point in time we can
Dialogue: 0,0:18:44.57,0:18:46.16,csapp,,0,0,0,,determine the level of internal
Dialogue: 0,0:18:46.16,0:18:48.47,csapp,,0,0,0,,fragmentation just by looking at the
Dialogue: 0,0:18:48.47,0:18:52.94,csapp,,0,0,0,,previous request so there's another form
Dialogue: 0,0:18:52.94,0:18:55.10,csapp,,0,0,0,,of fragmentation called external
Dialogue: 0,0:18:55.10,0:18:56.57,csapp,,0,0,0,,fragmentation which is a little more
Dialogue: 0,0:18:56.57,0:19:00.14,csapp,,0,0,0,,difficult to to deal with so external
Dialogue: 0,0:19:00.14,0:19:02.53,csapp,,0,0,0,,fragmentation occurs when there's enough
Dialogue: 0,0:19:02.53,0:19:05.72,csapp,,0,0,0,,memory in the heap but there's there's
Dialogue: 0,0:19:05.72,0:19:08.27,csapp,,0,0,0,,no single free block that can satisfy a
Dialogue: 0,0:19:08.27,0:19:10.79,csapp,,0,0,0,,particular request ok so external
Dialogue: 0,0:19:10.79,0:19:13.25,csapp,,0,0,0,,fragmentation occurs when the
Dialogue: 0,0:19:13.25,0:19:15.82,csapp,,0,0,0,,application makes a request for a block
Dialogue: 0,0:19:15.82,0:19:18.50,csapp,,0,0,0,,but nowhere in the heap is there a free
Dialogue: 0,0:19:18.50,0:19:21.02,csapp,,0,0,0,,block a free block that's large enough
Dialogue: 0,0:19:21.02,0:19:25.74,csapp,,0,0,0,,to satisfy that request
Dialogue: 0,0:19:25.74,0:19:28.26,csapp,,0,0,0,,so an example of this like suppose
Dialogue: 0,0:19:28.26,0:19:30.48,csapp,,0,0,0,,here's the previous example we looked at
Dialogue: 0,0:19:30.48,0:19:33.12,csapp,,0,0,0,,now where we have after a series of
Dialogue: 0,0:19:33.12,0:19:37.11,csapp,,0,0,0,,malloc and free calls we have two free
Dialogue: 0,0:19:37.11,0:19:39.99,csapp,,0,0,0,,blocks in the heap one containing five
Dialogue: 0,0:19:39.99,0:19:41.78,csapp,,0,0,0,,words and the other containing two words
Dialogue: 0,0:19:41.78,0:19:44.19,csapp,,0,0,0,,so the total the total number of free
Dialogue: 0,0:19:44.19,0:19:46.74,csapp,,0,0,0,,words in our heap is seven seven words
Dialogue: 0,0:19:46.74,0:19:51.44,csapp,,0,0,0,,and now we get a request for six words
Dialogue: 0,0:19:51.44,0:19:54.72,csapp,,0,0,0,,hey we have enough free blocks we have
Dialogue: 0,0:19:54.72,0:19:57.89,csapp,,0,0,0,,enough free words in the heap but we
Dialogue: 0,0:19:57.89,0:20:01.32,csapp,,0,0,0,,can't satisfy that request and it's it's
Dialogue: 0,0:20:01.32,0:20:03.69,csapp,,0,0,0,,because of it's because of this
Dialogue: 0,0:20:03.69,0:20:05.64,csapp,,0,0,0,,phenomenon called external fragmentation
Dialogue: 0,0:20:05.64,0:20:10.20,csapp,,0,0,0,,for example if we'd have if we'd have
Dialogue: 0,0:20:10.20,0:20:15.27,csapp,,0,0,0,,somehow allocated
Dialogue: 0,0:20:15.27,0:20:18.12,csapp,,0,0,0,,Oh
Dialogue: 0,0:20:18.12,0:20:19.74,csapp,,0,0,0,,yeah I don't know in this case I don't
Dialogue: 0,0:20:19.74,0:20:21.48,csapp,,0,0,0,,think we could have avoided the external
Dialogue: 0,0:20:21.48,0:20:24.12,csapp,,0,0,0,,fragmentation but nonetheless there's
Dialogue: 0,0:20:24.12,0:20:26.40,csapp,,0,0,0,,enough memory here we just just the way
Dialogue: 0,0:20:26.40,0:20:29.40,csapp,,0,0,0,,that our blocks are configured in the
Dialogue: 0,0:20:29.40,0:20:31.98,csapp,,0,0,0,,heap we can't satisfy the request so in
Dialogue: 0,0:20:31.98,0:20:34.50,csapp,,0,0,0,,this in this in this case that the
Dialogue: 0,0:20:34.50,0:20:36.45,csapp,,0,0,0,,allocator has to go and get more more
Dialogue: 0,0:20:36.45,0:20:39.69,csapp,,0,0,0,,virtual memory would have to go and it
Dialogue: 0,0:20:39.69,0:20:40.95,csapp,,0,0,0,,would have to get more virtual memory
Dialogue: 0,0:20:40.95,0:20:44.46,csapp,,0,0,0,,and extend the heap out this way and to
Dialogue: 0,0:20:44.46,0:20:48.41,csapp,,0,0,0,,get a large enough free block so you
Dialogue: 0,0:20:48.41,0:20:50.34,csapp,,0,0,0,,know assessing and sort of understanding
Dialogue: 0,0:20:50.34,0:20:53.00,csapp,,0,0,0,,external fragmentation is difficult
Dialogue: 0,0:20:53.00,0:20:55.23,csapp,,0,0,0,,because unlike internal fragmentation
Dialogue: 0,0:20:55.23,0:20:58.58,csapp,,0,0,0,,which depended on the previous requests
Dialogue: 0,0:20:58.58,0:21:01.50,csapp,,0,0,0,,external fragmentation depends on future
Dialogue: 0,0:21:01.50,0:21:04.02,csapp,,0,0,0,,requests so if we look back at this
Dialogue: 0,0:21:04.02,0:21:06.69,csapp,,0,0,0,,point we say is is our is our heap
Dialogue: 0,0:21:06.69,0:21:09.65,csapp,,0,0,0,,externally fragmented well we it depends
Dialogue: 0,0:21:09.65,0:21:12.87,csapp,,0,0,0,,right we can't say it turns out it is
Dialogue: 0,0:21:12.87,0:21:15.24,csapp,,0,0,0,,because the next request is is for a
Dialogue: 0,0:21:15.24,0:21:17.52,csapp,,0,0,0,,block of size six but if all of the
Dialogue: 0,0:21:17.52,0:21:19.71,csapp,,0,0,0,,future blocks or future requests were
Dialogue: 0,0:21:19.71,0:21:20.27,csapp,,0,0,0,,for bullet
Dialogue: 0,0:21:20.27,0:21:22.47,csapp,,0,0,0,,we're for blocks of you know say small
Dialogue: 0,0:21:22.47,0:21:24.77,csapp,,0,0,0,,blocks then we be able to satisfy those
Dialogue: 0,0:21:24.77,0:21:27.41,csapp,,0,0,0,,than and we wouldn't we wouldn't suffer
Dialogue: 0,0:21:27.41,0:21:32.54,csapp,,0,0,0,,from external fragmentation
Dialogue: 0,0:21:32.54,0:21:37.89,csapp,,0,0,0,,okay now when we build an alligator all
Dialogue: 0,0:21:37.89,0:21:42.78,csapp,,0,0,0,,kinds of issues come up and that I've
Dialogue: 0,0:21:42.78,0:21:44.61,csapp,,0,0,0,,glossed over with my simple examples
Dialogue: 0,0:21:44.61,0:21:49.47,csapp,,0,0,0,,right you know how do we know if we call
Dialogue: 0,0:21:49.47,0:21:52.20,csapp,,0,0,0,,free how does free know how much memory
Dialogue: 0,0:21:52.20,0:21:54.30,csapp,,0,0,0,,to free up right we don't call free with
Dialogue: 0,0:21:54.30,0:21:56.43,csapp,,0,0,0,,a block size we call it with a pointer
Dialogue: 0,0:21:56.43,0:21:59.73,csapp,,0,0,0,,so how does free know how big that block
Dialogue: 0,0:21:59.73,0:22:03.33,csapp,,0,0,0,,is how do we keep track of all the free
Dialogue: 0,0:22:03.33,0:22:09.39,csapp,,0,0,0,,blocks when we have you know when we're
Dialogue: 0,0:22:09.39,0:22:13.05,csapp,,0,0,0,,satisfying an allocation request we're
Dialogue: 0,0:22:13.05,0:22:14.16,csapp,,0,0,0,,going to fight we're going to look for a
Dialogue: 0,0:22:14.16,0:22:17.19,csapp,,0,0,0,,free block that is larger than the the
Dialogue: 0,0:22:17.19,0:22:20.10,csapp,,0,0,0,,requested size on that that case what do
Dialogue: 0,0:22:20.10,0:22:21.96,csapp,,0,0,0,,we do with the extra space in the block
Dialogue: 0,0:22:21.96,0:22:25.14,csapp,,0,0,0,,we do we just keep it in the block you
Dialogue: 0,0:22:25.14,0:22:26.64,csapp,,0,0,0,,know and and suffer some internal
Dialogue: 0,0:22:26.64,0:22:29.40,csapp,,0,0,0,,fragmentation do we split that block
Dialogue: 0,0:22:29.40,0:22:34.26,csapp,,0,0,0,,into a smaller block there's a lot of
Dialogue: 0,0:22:34.26,0:22:37.37,csapp,,0,0,0,,free blocks in the in the heap how do we
Dialogue: 0,0:22:37.37,0:22:39.87,csapp,,0,0,0,,when we make an out when the allocator
Dialogue: 0,0:22:39.87,0:22:42.57,csapp,,0,0,0,,gets a allocation request how does it
Dialogue: 0,0:22:42.57,0:22:44.49,csapp,,0,0,0,,pick from all among all of those
Dialogue: 0,0:22:44.49,0:22:46.08,csapp,,0,0,0,,different free blocks make as many
Dialogue: 0,0:22:46.08,0:22:51.90,csapp,,0,0,0,,choices and then once when free tries to
Dialogue: 0,0:22:51.90,0:22:54.59,csapp,,0,0,0,,insert a free block we're in the heap
Dialogue: 0,0:22:54.59,0:22:57.75,csapp,,0,0,0,,you know where does it insert it okay
Dialogue: 0,0:22:57.75,0:22:59.73,csapp,,0,0,0,,when it's when it's freed and how do we
Dialogue: 0,0:22:59.73,0:23:01.56,csapp,,0,0,0,,reinsert a free block what does that
Dialogue: 0,0:23:01.56,0:23:04.08,csapp,,0,0,0,,mean okay so today we're going to look
Dialogue: 0,0:23:04.08,0:23:08.07,csapp,,0,0,0,,at at all of these issues starting with
Dialogue: 0,0:23:08.07,0:23:11.28,csapp,,0,0,0,,knowing how much to free so how big our
Dialogue: 0,0:23:11.28,0:23:15.09,csapp,,0,0,0,,block sizes so the typical the standard
Dialogue: 0,0:23:15.09,0:23:20.04,csapp,,0,0,0,,method is to keep sort of a word sized
Dialogue: 0,0:23:20.04,0:23:21.84,csapp,,0,0,0,,quantity at the beginning of each block
Dialogue: 0,0:23:21.84,0:23:25.47,csapp,,0,0,0,,that gives the size of that block in in
Dialogue: 0,0:23:25.47,0:23:29.01,csapp,,0,0,0,,some units I'm showing them here in word
Dialogue: 0,0:23:29.01,0:23:33.39,csapp,,0,0,0,,size units okay so that if if the
Dialogue: 0,0:23:33.39,0:23:35.94,csapp,,0,0,0,,application Malick's a payload of size
Dialogue: 0,0:23:35.94,0:23:38.16,csapp,,0,0,0,,wants to wants to now like a payload of
Dialogue: 0,0:23:38.16,0:23:43.44,csapp,,0,0,0,,size four then the allocator needs to
Dialogue: 0,0:23:43.44,0:23:44.85,csapp,,0,0,0,,find a block
Dialogue: 0,0:23:44.85,0:23:49.86,csapp,,0,0,0,,of size five so consisting of four
Dialogue: 0,0:23:49.86,0:23:51.72,csapp,,0,0,0,,payload words at least four payload
Dialogue: 0,0:23:51.72,0:23:54.72,csapp,,0,0,0,,words and then a header block
Dialogue: 0,0:23:54.72,0:23:58.34,csapp,,0,0,0,,a header word at the beginning that that
Dialogue: 0,0:23:58.34,0:24:00.78,csapp,,0,0,0,,indicates the size the total size of
Dialogue: 0,0:24:00.78,0:24:03.84,csapp,,0,0,0,,that block and then it returns a pointer
Dialogue: 0,0:24:03.84,0:24:06.36,csapp,,0,0,0,,p0 in this case to the beginning of the
Dialogue: 0,0:24:06.36,0:24:12.18,csapp,,0,0,0,,payload
Dialogue: 0,0:24:12.18,0:24:14.25,csapp,,0,0,0,,okay so now we know how big each block
Dialogue: 0,0:24:14.25,0:24:16.38,csapp,,0,0,0,,is that's pretty simple and how we keep
Dialogue: 0,0:24:16.38,0:24:17.91,csapp,,0,0,0,,track of the free blocks and this is
Dialogue: 0,0:24:17.91,0:24:21.27,csapp,,0,0,0,,where it gets interesting the simplest
Dialogue: 0,0:24:21.27,0:24:23.37,csapp,,0,0,0,,method is to use that we call an
Dialogue: 0,0:24:23.37,0:24:27.15,csapp,,0,0,0,,implicit list an implicit list of free
Dialogue: 0,0:24:27.15,0:24:31.14,csapp,,0,0,0,,blocks and the idea here is to just put
Dialogue: 0,0:24:31.14,0:24:33.87,csapp,,0,0,0,,a header in the front of every block in
Dialogue: 0,0:24:33.87,0:24:37.56,csapp,,0,0,0,,the heap whether allocated or free okay
Dialogue: 0,0:24:37.56,0:24:40.53,csapp,,0,0,0,,and then we can use that starting at the
Dialogue: 0,0:24:40.53,0:24:42.15,csapp,,0,0,0,,beginning of the heap we can use that
Dialogue: 0,0:24:42.15,0:24:47.64,csapp,,0,0,0,,size to walk the heat okay so here's a
Dialogue: 0,0:24:47.64,0:24:50.07,csapp,,0,0,0,,block of size five so we can we can jump
Dialogue: 0,0:24:50.07,0:24:52.86,csapp,,0,0,0,,we know that the next block starts at an
Dialogue: 0,0:24:52.86,0:24:57.51,csapp,,0,0,0,,offset of five with the second block we
Dialogue: 0,0:24:57.51,0:24:59.88,csapp,,0,0,0,,know the then the next block starts at
Dialogue: 0,0:24:59.88,0:25:03.03,csapp,,0,0,0,,an offset of four and so on okay so we
Dialogue: 0,0:25:03.03,0:25:06.42,csapp,,0,0,0,,call it an implicit free list because
Dialogue: 0,0:25:06.42,0:25:08.07,csapp,,0,0,0,,there's there's no real list of free
Dialogue: 0,0:25:08.07,0:25:10.80,csapp,,0,0,0,,blocks but we can trick an traverse that
Dialogue: 0,0:25:10.80,0:25:15.11,csapp,,0,0,0,,all of the free blocks in the heap by
Dialogue: 0,0:25:15.11,0:25:18.33,csapp,,0,0,0,,traversing all of the blocks in the heat
Dialogue: 0,0:25:18.33,0:25:20.37,csapp,,0,0,0,,and then just ignoring the the allocated
Dialogue: 0,0:25:20.37,0:25:25.41,csapp,,0,0,0,,blocks okay so
Dialogue: 0,0:25:25.41,0:25:27.09,csapp,,0,0,0,,now another thing we could do is we
Dialogue: 0,0:25:27.09,0:25:30.00,csapp,,0,0,0,,could actually use some of the some of
Dialogue: 0,0:25:30.00,0:25:32.20,csapp,,0,0,0,,the words in the block to create a
Dialogue: 0,0:25:32.20,0:25:34.79,csapp,,0,0,0,,linked list of some kind either us
Dialogue: 0,0:25:34.79,0:25:38.88,csapp,,0,0,0,,singly or doubly linked lists and in
Dialogue: 0,0:25:38.88,0:25:42.94,csapp,,0,0,0,,this case we it's an explicit list of
Dialogue: 0,0:25:42.94,0:25:44.91,csapp,,0,0,0,,the free blocks and we can just walk
Dialogue: 0,0:25:44.91,0:25:49.69,csapp,,0,0,0,,that list so we here we visit the first
Dialogue: 0,0:25:49.69,0:25:53.07,csapp,,0,0,0,,free block and then there's a pointer to
Dialogue: 0,0:25:53.07,0:25:55.57,csapp,,0,0,0,,the next free block and so on so this
Dialogue: 0,0:25:55.57,0:25:57.27,csapp,,0,0,0,,you can see this might be a little more
Dialogue: 0,0:25:57.27,0:25:59.95,csapp,,0,0,0,,efficient because if we want to traverse
Dialogue: 0,0:25:59.95,0:26:04.38,csapp,,0,0,0,,the free list in this case it's a it's
Dialogue: 0,0:26:04.38,0:26:06.19,csapp,,0,0,0,,going to be ordered the number of blocks
Dialogue: 0,0:26:06.19,0:26:08.61,csapp,,0,0,0,,in the list okay it's going to be linear
Dialogue: 0,0:26:08.61,0:26:10.45,csapp,,0,0,0,,in the total number of blocks in the
Dialogue: 0,0:26:10.45,0:26:12.75,csapp,,0,0,0,,heap which might be quite large there
Dialogue: 0,0:26:12.75,0:26:16.14,csapp,,0,0,0,,could be lots of allocated blocks in
Dialogue: 0,0:26:16.14,0:26:18.90,csapp,,0,0,0,,this case with an explicit list any
Dialogue: 0,0:26:18.90,0:26:22.50,csapp,,0,0,0,,traversal just just be linear in the
Dialogue: 0,0:26:22.50,0:26:28.94,csapp,,0,0,0,,size of the free list question
Dialogue: 0,0:26:28.94,0:26:31.71,csapp,,0,0,0,,yeah that's the question is done we need
Dialogue: 0,0:26:31.71,0:26:34.50,csapp,,0,0,0,,a free bit and we do and I'll we have
Dialogue: 0,0:26:34.50,0:26:45.24,csapp,,0,0,0,,that's the next question
Dialogue: 0,0:26:45.24,0:26:47.07,csapp,,0,0,0,,now another method a more sophisticated
Dialogue: 0,0:26:47.07,0:26:49.62,csapp,,0,0,0,,method instead of having one free list
Dialogue: 0,0:26:49.62,0:26:52.62,csapp,,0,0,0,,we can have multiple free lists where
Dialogue: 0,0:26:52.62,0:26:55.71,csapp,,0,0,0,,each free list contains blocks of a
Dialogue: 0,0:26:55.71,0:27:02.49,csapp,,0,0,0,,certain size or certain range of sizes
Dialogue: 0,0:27:02.49,0:27:05.26,csapp,,0,0,0,,or we can get really fancy and use some
Dialogue: 0,0:27:05.26,0:27:09.85,csapp,,0,0,0,,kind of some kind of a balance tree to
Dialogue: 0,0:27:09.85,0:27:12.34,csapp,,0,0,0,,sort the blocks to use the tree to sort
Dialogue: 0,0:27:12.34,0:27:17.02,csapp,,0,0,0,,them by size order now today we're going
Dialogue: 0,0:27:17.02,0:27:19.45,csapp,,0,0,0,,to look at the implicit list the
Dialogue: 0,0:27:19.45,0:27:22.51,csapp,,0,0,0,,simplest kind of free list and this will
Dialogue: 0,0:27:22.51,0:27:24.82,csapp,,0,0,0,,identify a lot of basic concepts that
Dialogue: 0,0:27:24.82,0:27:27.46,csapp,,0,0,0,,are used in the more sophisticated free
Dialogue: 0,0:27:27.46,0:27:34.78,csapp,,0,0,0,,list question okay the question is what
Dialogue: 0,0:27:34.78,0:27:36.55,csapp,,0,0,0,,do you what do we mean by different free
Dialogue: 0,0:27:36.55,0:27:39.55,csapp,,0,0,0,,lists for different size classes so what
Dialogue: 0,0:27:39.55,0:27:43.90,csapp,,0,0,0,,what I mean is that you identify a range
Dialogue: 0,0:27:43.90,0:27:47.29,csapp,,0,0,0,,of sizes and you associate that range
Dialogue: 0,0:27:47.29,0:27:49.84,csapp,,0,0,0,,with with each of these individual free
Dialogue: 0,0:27:49.84,0:27:52.27,csapp,,0,0,0,,lists okay so one free list might hold
Dialogue: 0,0:27:52.27,0:27:56.02,csapp,,0,0,0,,blocks of size 0 to 8 and another free
Dialogue: 0,0:27:56.02,0:27:58.36,csapp,,0,0,0,,list might hold blocks of size 9 to 16
Dialogue: 0,0:27:58.36,0:28:01.36,csapp,,0,0,0,,and the other another free list may be
Dialogue: 0,0:28:01.36,0:28:06.70,csapp,,0,0,0,,17 to 32 you know some and so you're
Dialogue: 0,0:28:06.70,0:28:10.69,csapp,,0,0,0,,guaranteed you now know when you're
Dialogue: 0,0:28:10.69,0:28:13.21,csapp,,0,0,0,,traversing a certain list you know the
Dialogue: 0,0:28:13.21,0:28:15.22,csapp,,0,0,0,,range of sizes of the blocks in that
Dialogue: 0,0:28:15.22,0:28:20.26,csapp,,0,0,0,,list the the reason you might want to do
Dialogue: 0,0:28:20.26,0:28:23.95,csapp,,0,0,0,,that by the way is that imagine you had
Dialogue: 0,0:28:23.95,0:28:28.27,csapp,,0,0,0,,an infinite number of of these lists one
Dialogue: 0,0:28:28.27,0:28:32.35,csapp,,0,0,0,,for each possible size then every time
Dialogue: 0,0:28:32.35,0:28:34.75,csapp,,0,0,0,,you allocated a block you'd get a block
Dialogue: 0,0:28:34.75,0:28:37.78,csapp,,0,0,0,,of exactly the size you needed so
Dialogue: 0,0:28:37.78,0:28:38.98,csapp,,0,0,0,,there'd be a minimum amount of
Dialogue: 0,0:28:38.98,0:28:41.05,csapp,,0,0,0,,fragmentation if you had an infinite
Dialogue: 0,0:28:41.05,0:28:43.86,csapp,,0,0,0,,number of these of these size classes
Dialogue: 0,0:28:43.86,0:28:46.54,csapp,,0,0,0,,now if we of course we can't have an
Dialogue: 0,0:28:46.54,0:28:48.79,csapp,,0,0,0,,infinite number but the more of these
Dialogue: 0,0:28:48.79,0:28:50.89,csapp,,0,0,0,,size classes we have the closer we get
Dialogue: 0,0:28:50.89,0:28:54.79,csapp,,0,0,0,,to that ideal
Dialogue: 0,0:28:54.79,0:28:57.01,csapp,,0,0,0,,all right so let's look at how we would
Dialogue: 0,0:28:57.01,0:29:01.39,csapp,,0,0,0,,build imprint implicit free lists so as
Dialogue: 0,0:29:01.39,0:29:04.42,csapp,,0,0,0,,you correctly point it out for each each
Dialogue: 0,0:29:04.42,0:29:07.09,csapp,,0,0,0,,block we need we need both size and the
Dialogue: 0,0:29:07.09,0:29:17.00,csapp,,0,0,0,,allocation status question
Dialogue: 0,0:29:17.00,0:29:28.99,csapp,,0,0,0,,why can't we map every size class
Dialogue: 0,0:29:28.99,0:29:32.01,csapp,,0,0,0,,if I'm fine
Dialogue: 0,0:29:32.01,0:29:34.23,csapp,,0,0,0,,yeah that's so why can't we have an
Dialogue: 0,0:29:34.23,0:29:41.36,csapp,,0,0,0,,infinite number of size classes
Dialogue: 0,0:29:41.36,0:29:44.80,csapp,,0,0,0,,I suppose you know that'd be an
Dialogue: 0,0:29:44.80,0:29:48.29,csapp,,0,0,0,,interesting strategy to to think about
Dialogue: 0,0:29:48.29,0:29:50.66,csapp,,0,0,0,,so you can't have an infinite number of
Dialogue: 0,0:29:50.66,0:29:53.27,csapp,,0,0,0,,size classes but you could create a new
Dialogue: 0,0:29:53.27,0:29:55.82,csapp,,0,0,0,,size class for every new size that you
Dialogue: 0,0:29:55.82,0:29:59.63,csapp,,0,0,0,,get and that that might work but it just
Dialogue: 0,0:29:59.63,0:30:02.05,csapp,,0,0,0,,depends on the the range of these size
Dialogue: 0,0:30:02.05,0:30:04.85,csapp,,0,0,0,,classes and the frequency and one
Dialogue: 0,0:30:04.85,0:30:08.36,csapp,,0,0,0,,problem you might have is that you you
Dialogue: 0,0:30:08.36,0:30:12.23,csapp,,0,0,0,,would get maybe if you only get it
Dialogue: 0,0:30:12.23,0:30:14.21,csapp,,0,0,0,,depends on the distribution of your
Dialogue: 0,0:30:14.21,0:30:16.25,csapp,,0,0,0,,sizes that you get if you're getting an
Dialogue: 0,0:30:16.25,0:30:18.16,csapp,,0,0,0,,equal number if your distribution of
Dialogue: 0,0:30:18.16,0:30:21.14,csapp,,0,0,0,,sizes is is fairly uniform that would
Dialogue: 0,0:30:21.14,0:30:22.97,csapp,,0,0,0,,probably work pretty well if you're
Dialogue: 0,0:30:22.97,0:30:27.38,csapp,,0,0,0,,getting if you have requests if if you
Dialogue: 0,0:30:27.38,0:30:28.79,csapp,,0,0,0,,have a lot of requests for different
Dialogue: 0,0:30:28.79,0:30:31.76,csapp,,0,0,0,,size classes you'd have a lot of sort of
Dialogue: 0,0:30:31.76,0:30:35.36,csapp,,0,0,0,,wasted free lists I think right good so
Dialogue: 0,0:30:35.36,0:30:37.85,csapp,,0,0,0,,it's a good question it depends on it
Dialogue: 0,0:30:37.85,0:30:40.37,csapp,,0,0,0,,depends on your workload and there and
Dialogue: 0,0:30:40.37,0:30:45.14,csapp,,0,0,0,,that is for that and that is a really
Dialogue: 0,0:30:45.14,0:30:48.32,csapp,,0,0,0,,useful strategy for so you if you have
Dialogue: 0,0:30:48.32,0:30:50.99,csapp,,0,0,0,,really popular size classes in your
Dialogue: 0,0:30:50.99,0:30:53.99,csapp,,0,0,0,,request then you could just make you
Dialogue: 0,0:30:53.99,0:30:57.11,csapp,,0,0,0,,know special case special case free
Dialogue: 0,0:30:57.11,0:30:59.87,csapp,,0,0,0,,lists to handle those requests and then
Dialogue: 0,0:30:59.87,0:31:01.94,csapp,,0,0,0,,and then let the other free list sort of
Dialogue: 0,0:31:01.94,0:31:05.03,csapp,,0,0,0,,handle a wider range and imagine if you
Dialogue: 0,0:31:05.03,0:31:06.50,csapp,,0,0,0,,had a free list where all the blocks
Dialogue: 0,0:31:06.50,0:31:08.48,csapp,,0,0,0,,were the same it could be a lot more
Dialogue: 0,0:31:08.48,0:31:11.03,csapp,,0,0,0,,efficient right because you won't make
Dialogue: 0,0:31:11.03,0:31:14.54,csapp,,0,0,0,,you only need like a bit vector 1 1 bit
Dialogue: 0,0:31:14.54,0:31:16.22,csapp,,0,0,0,,for each potential block to tell you
Dialogue: 0,0:31:16.22,0:31:18.79,csapp,,0,0,0,,whether it's allocated or free so it
Dialogue: 0,0:31:18.79,0:31:20.92,csapp,,0,0,0,,could be very efficient you wouldn't you
Dialogue: 0,0:31:20.92,0:31:22.73,csapp,,0,0,0,,wouldn't need to walk any any lists or
Dialogue: 0,0:31:22.73,0:31:26.13,csapp,,0,0,0,,anything
Dialogue: 0,0:31:26.13,0:31:28.23,csapp,,0,0,0,,that's a good question and that's the
Dialogue: 0,0:31:28.23,0:31:29.49,csapp,,0,0,0,,kind of thing you'll be thinking about
Dialogue: 0,0:31:29.49,0:31:31.86,csapp,,0,0,0,,when you do your Mallik lab it's one of
Dialogue: 0,0:31:31.86,0:31:36.39,csapp,,0,0,0,,the there's a huge design space in
Dialogue: 0,0:31:36.39,0:31:39.57,csapp,,0,0,0,,implementing malloc function and we just
Dialogue: 0,0:31:39.57,0:31:41.49,csapp,,0,0,0,,we just explored a one tiny part of it
Dialogue: 0,0:31:41.49,0:31:43.73,csapp,,0,0,0,,just now
Dialogue: 0,0:31:43.73,0:31:47.37,csapp,,0,0,0,,so with this implicit list we're going
Dialogue: 0,0:31:47.37,0:31:51.00,csapp,,0,0,0,,to need both the size of the block and
Dialogue: 0,0:31:51.00,0:31:52.55,csapp,,0,0,0,,then its allocation status whether it's
Dialogue: 0,0:31:52.55,0:31:54.99,csapp,,0,0,0,,allocated or free now we could do this
Dialogue: 0,0:31:54.99,0:31:56.61,csapp,,0,0,0,,in two words right but that would be
Dialogue: 0,0:31:56.61,0:31:57.24,csapp,,0,0,0,,wasteful
Dialogue: 0,0:31:57.24,0:31:59.88,csapp,,0,0,0,,so the standard trick is to take
Dialogue: 0,0:31:59.88,0:32:02.10,csapp,,0,0,0,,advantage of the fact that blocks have
Dialogue: 0,0:32:02.10,0:32:05.10,csapp,,0,0,0,,to be aligned okay so this is actually
Dialogue: 0,0:32:05.10,0:32:06.36,csapp,,0,0,0,,it's kind of a pain in the neck to
Dialogue: 0,0:32:06.36,0:32:08.94,csapp,,0,0,0,,always have to align these blocks but we
Dialogue: 0,0:32:08.94,0:32:10.47,csapp,,0,0,0,,can take advantage of it in this case
Dialogue: 0,0:32:10.47,0:32:13.59,csapp,,0,0,0,,and the reason is is that if a block is
Dialogue: 0,0:32:13.59,0:32:16.77,csapp,,0,0,0,,aligned to some say 8 by 8 or 16 byte
Dialogue: 0,0:32:16.77,0:32:19.08,csapp,,0,0,0,,boundary then the lower order bits are
Dialogue: 0,0:32:19.08,0:32:21.41,csapp,,0,0,0,,always going to be 0 so if it's aligned
Dialogue: 0,0:32:21.41,0:32:24.24,csapp,,0,0,0,,to an 8 byte boundary the lower order 3
Dialogue: 0,0:32:24.24,0:32:27.33,csapp,,0,0,0,,the 3 low order bits will always be 0
Dialogue: 0,0:32:27.33,0:32:36.28,csapp,,0,0,0,,right 8 is 1 0 0 0 16 1 with 4 zeros 24
Dialogue: 0,0:32:36.28,0:32:41.48,csapp,,0,0,0,,1 1 0 0 0 right so there any any 8 byte
Dialogue: 0,0:32:41.48,0:32:47.25,csapp,,0,0,0,,any 8 byte aligned block has to be size
Dialogue: 0,0:32:47.25,0:32:49.40,csapp,,0,0,0,,8 and it has to start on address that's
Dialogue: 0,0:32:49.40,0:32:52.86,csapp,,0,0,0,,a multiple of 8 all right so those the
Dialogue: 0,0:32:52.86,0:32:55.86,csapp,,0,0,0,,the size will always the size of that
Dialogue: 0,0:32:55.86,0:33:00.99,csapp,,0,0,0,,block will always have 0 the 3 3 or 4 a
Dialogue: 0,0:33:00.99,0:33:04.38,csapp,,0,0,0,,low-order bits set to 0 so we can take
Dialogue: 0,0:33:04.38,0:33:05.85,csapp,,0,0,0,,it we can take advantage of that and
Dialogue: 0,0:33:05.85,0:33:10.40,csapp,,0,0,0,,we'll just make will just have 1 I will
Dialogue: 0,0:33:10.40,0:33:13.59,csapp,,0,0,0,,just have one header word and we'll use
Dialogue: 0,0:33:13.59,0:33:15.90,csapp,,0,0,0,,the lower order bit to store the
Dialogue: 0,0:33:15.90,0:33:19.50,csapp,,0,0,0,,allocation status okay and we can do
Dialogue: 0,0:33:19.50,0:33:22.02,csapp,,0,0,0,,that because we know it's always zero so
Dialogue: 0,0:33:22.02,0:33:25.53,csapp,,0,0,0,,when we so we use that low order bit to
Dialogue: 0,0:33:25.53,0:33:27.36,csapp,,0,0,0,,store the allocation status and then the
Dialogue: 0,0:33:27.36,0:33:30.27,csapp,,0,0,0,,remaining bits correspond to the size
Dialogue: 0,0:33:30.27,0:33:32.73,csapp,,0,0,0,,and then whenever we want to extract the
Dialogue: 0,0:33:32.73,0:33:35.46,csapp,,0,0,0,,size we just mask out this allocation
Dialogue: 0,0:33:35.46,0:33:38.01,csapp,,0,0,0,,status and always set it to zero because
Dialogue: 0,0:33:38.01,0:33:47.91,csapp,,0,0,0,,we know that it's zero
Dialogue: 0,0:33:47.91,0:33:51.34,csapp,,0,0,0,,so let's look in detail what given this
Dialogue: 0,0:33:51.34,0:33:55.00,csapp,,0,0,0,,given this form of implicit list how we
Dialogue: 0,0:33:55.00,0:33:58.93,csapp,,0,0,0,,might set things up so in this case
Dialogue: 0,0:33:58.93,0:34:02.26,csapp,,0,0,0,,we're going to assume for bite words
Dialogue: 0,0:34:02.26,0:34:06.10,csapp,,0,0,0,,okay in sized words and we're going to
Dialogue: 0,0:34:06.10,0:34:10.60,csapp,,0,0,0,,align on eight byte boundaries okay so
Dialogue: 0,0:34:10.60,0:34:12.42,csapp,,0,0,0,,remember the payload of our blocks
Dialogue: 0,0:34:12.42,0:34:14.62,csapp,,0,0,0,,always has to start on an eight eight
Dialogue: 0,0:34:14.62,0:34:17.62,csapp,,0,0,0,,byte boundary so the way we do that is
Dialogue: 0,0:34:17.62,0:34:19.75,csapp,,0,0,0,,we create this unused word at the
Dialogue: 0,0:34:19.75,0:34:21.88,csapp,,0,0,0,,beginning of the heap that's aligned on
Dialogue: 0,0:34:21.88,0:34:25.41,csapp,,0,0,0,,this eight byte boundary and then the
Dialogue: 0,0:34:25.41,0:34:29.86,csapp,,0,0,0,,the first block and the heap starts at
Dialogue: 0,0:34:29.86,0:34:32.40,csapp,,0,0,0,,an offset of four from that from the
Dialogue: 0,0:34:32.40,0:34:34.69,csapp,,0,0,0,,beginning of the heap so we have the
Dialogue: 0,0:34:34.69,0:34:39.55,csapp,,0,0,0,,header which is is not aligned and then
Dialogue: 0,0:34:39.55,0:34:42.28,csapp,,0,0,0,,we have the payload which follows in
Dialogue: 0,0:34:42.28,0:34:44.40,csapp,,0,0,0,,this case it's a payload of one one word
Dialogue: 0,0:34:44.40,0:34:49.03,csapp,,0,0,0,,and that starts on this that begins on
Dialogue: 0,0:34:49.03,0:34:51.01,csapp,,0,0,0,,this this eight word boundary and then
Dialogue: 0,0:34:51.01,0:34:54.28,csapp,,0,0,0,,the next block and and here we're
Dialogue: 0,0:34:54.28,0:34:58.18,csapp,,0,0,0,,indicating a free block consisting of
Dialogue: 0,0:34:58.18,0:35:02.38,csapp,,0,0,0,,eight bytes and then that's followed by
Dialogue: 0,0:35:02.38,0:35:05.05,csapp,,0,0,0,,an allocated block the one here of
Dialogue: 0,0:35:05.05,0:35:11.05,csapp,,0,0,0,,sixteen bytes or four forwards
Dialogue: 0,0:35:11.05,0:35:15.13,csapp,,0,0,0,,and now the payload is only two words so
Dialogue: 0,0:35:15.13,0:35:17.92,csapp,,0,0,0,,we have to pad right all of our blocks
Dialogue: 0,0:35:17.92,0:35:19.57,csapp,,0,0,0,,because we're assuming that they're
Dialogue: 0,0:35:19.57,0:35:21.97,csapp,,0,0,0,,aligned on eight byte boundary all of
Dialogue: 0,0:35:21.97,0:35:24.40,csapp,,0,0,0,,our blocks have to be a multiple of size
Dialogue: 0,0:35:24.40,0:35:26.89,csapp,,0,0,0,,multiple of eight okay so here's the
Dialogue: 0,0:35:26.89,0:35:28.66,csapp,,0,0,0,,case of internal fragmentation where we
Dialogue: 0,0:35:28.66,0:35:31.36,csapp,,0,0,0,,have this extra this extra block in
Dialogue: 0,0:35:31.36,0:35:32.44,csapp,,0,0,0,,order to maintain the alignment
Dialogue: 0,0:35:32.44,0:35:34.84,csapp,,0,0,0,,requirement so that that ensures that
Dialogue: 0,0:35:34.84,0:35:39.82,csapp,,0,0,0,,the next block payload starts at a an
Dialogue: 0,0:35:39.82,0:35:42.01,csapp,,0,0,0,,eight byte aligned boundary and so on
Dialogue: 0,0:35:42.01,0:35:45.40,csapp,,0,0,0,,and so we can walk this heap by just
Dialogue: 0,0:35:45.40,0:35:47.38,csapp,,0,0,0,,following these headers masking out the
Dialogue: 0,0:35:47.38,0:35:50.11,csapp,,0,0,0,,allocation bits and then we have this
Dialogue: 0,0:35:50.11,0:35:55.78,csapp,,0,0,0,,special epilogue block which is a zero
Dialogue: 0,0:35:55.78,0:35:58.87,csapp,,0,0,0,,it's a block of with a zero sized
Dialogue: 0,0:35:58.87,0:36:00.46,csapp,,0,0,0,,payload
Dialogue: 0,0:36:00.46,0:36:03.66,csapp,,0,0,0,,it's an allocated block of size zero and
Dialogue: 0,0:36:03.66,0:36:07.15,csapp,,0,0,0,,this is a this is a trick this is a
Dialogue: 0,0:36:07.15,0:36:10.12,csapp,,0,0,0,,trick you should use to so this and
Dialogue: 0,0:36:10.12,0:36:11.92,csapp,,0,0,0,,we'll see when we look at coalescing why
Dialogue: 0,0:36:11.92,0:36:14.71,csapp,,0,0,0,,this is why this helps but this this
Dialogue: 0,0:36:14.71,0:36:16.86,csapp,,0,0,0,,allocated block at the very end
Dialogue: 0,0:36:16.86,0:36:19.09,csapp,,0,0,0,,eliminates some sort of special cases
Dialogue: 0,0:36:19.09,0:36:21.37,csapp,,0,0,0,,when we when we start to coalesce free
Dialogue: 0,0:36:21.37,0:36:23.86,csapp,,0,0,0,,blocks we'll talk about that in just a
Dialogue: 0,0:36:23.86,0:36:27.63,csapp,,0,0,0,,just a moment but you can finish your
Dialogue: 0,0:36:27.63,0:36:31.51,csapp,,0,0,0,,like this this this this allocated block
Dialogue: 0,0:36:31.51,0:36:33.49,csapp,,0,0,0,,of size zero is also helpful in
Dialogue: 0,0:36:33.49,0:36:35.56,csapp,,0,0,0,,terminating when you're walking this
Dialogue: 0,0:36:35.56,0:36:37.24,csapp,,0,0,0,,list you can you can check for a size
Dialogue: 0,0:36:37.24,0:36:39.43,csapp,,0,0,0,,allocated block of size zero to
Dialogue: 0,0:36:39.43,0:36:43.26,csapp,,0,0,0,,terminate your search
Dialogue: 0,0:36:43.26,0:36:45.58,csapp,,0,0,0,,okay so given this kind of structure
Dialogue: 0,0:36:45.58,0:36:48.43,csapp,,0,0,0,,then how do we find a free block okay
Dialogue: 0,0:36:48.43,0:36:49.75,csapp,,0,0,0,,there's a there's a number of different
Dialogue: 0,0:36:49.75,0:36:52.57,csapp,,0,0,0,,ways the first the first way which is
Dialogue: 0,0:36:52.57,0:36:55.27,csapp,,0,0,0,,called first fit up first fit is to
Dialogue: 0,0:36:55.27,0:36:57.82,csapp,,0,0,0,,search the free list from the beginning
Dialogue: 0,0:36:57.82,0:37:01.39,csapp,,0,0,0,,and just look for the first block we can
Dialogue: 0,0:37:01.39,0:37:07.48,csapp,,0,0,0,,find that satisfies the request so we're
Dialogue: 0,0:37:07.48,0:37:09.97,csapp,,0,0,0,,allocating we're asking for a block of
Dialogue: 0,0:37:09.97,0:37:12.13,csapp,,0,0,0,,size 10 we start at the beginning of the
Dialogue: 0,0:37:12.13,0:37:15.04,csapp,,0,0,0,,heap and we walked a list we walk the
Dialogue: 0,0:37:15.04,0:37:19.39,csapp,,0,0,0,,heap looking for a free block that's at
Dialogue: 0,0:37:19.39,0:37:23.74,csapp,,0,0,0,,least size 10 and we needs to be
Dialogue: 0,0:37:23.74,0:37:25.87,csapp,,0,0,0,,actually it needs to be 10 plus the size
Dialogue: 0,0:37:25.87,0:37:33.07,csapp,,0,0,0,,of our header 2 so once so that's a
Dialogue: 0,0:37:33.07,0:37:35.62,csapp,,0,0,0,,simple idea now some people have
Dialogue: 0,0:37:35.62,0:37:37.99,csapp,,0,0,0,,proposed an alternative called next fit
Dialogue: 0,0:37:37.99,0:37:40.12,csapp,,0,0,0,,so the idea here is that instead of
Dialogue: 0,0:37:40.12,0:37:41.71,csapp,,0,0,0,,starting over each time from the
Dialogue: 0,0:37:41.71,0:37:44.17,csapp,,0,0,0,,beginning of the heap to find a block
Dialogue: 0,0:37:44.17,0:37:46.78,csapp,,0,0,0,,that fits we just pick up where we left
Dialogue: 0,0:37:46.78,0:37:49.99,csapp,,0,0,0,,off the last time okay so we look we
Dialogue: 0,0:37:49.99,0:37:52.99,csapp,,0,0,0,,scan the heap and we find a block that's
Dialogue: 0,0:37:52.99,0:37:54.97,csapp,,0,0,0,,that's big enough to satisfy the request
Dialogue: 0,0:37:54.97,0:37:56.89,csapp,,0,0,0,,and then we remember where that where we
Dialogue: 0,0:37:56.89,0:38:00.13,csapp,,0,0,0,,left off and the next time the request
Dialogue: 0,0:38:00.13,0:38:02.26,csapp,,0,0,0,,comes in we pick up the search starting
Dialogue: 0,0:38:02.26,0:38:04.69,csapp,,0,0,0,,where we left off now this seems like
Dialogue: 0,0:38:04.69,0:38:06.64,csapp,,0,0,0,,would be a good idea but but studies
Dialogue: 0,0:38:06.64,0:38:08.38,csapp,,0,0,0,,peer achill studies that people have
Dialogue: 0,0:38:08.38,0:38:10.87,csapp,,0,0,0,,done have shown that this actually
Dialogue: 0,0:38:10.87,0:38:15.01,csapp,,0,0,0,,results in worse fragmentation so you
Dialogue: 0,0:38:15.01,0:38:16.90,csapp,,0,0,0,,know you can you can consider it but it
Dialogue: 0,0:38:16.90,0:38:20.11,csapp,,0,0,0,,it generally it's generally probably not
Dialogue: 0,0:38:20.11,0:38:23.92,csapp,,0,0,0,,the best thing to do now another
Dialogue: 0,0:38:23.92,0:38:29.11,csapp,,0,0,0,,alternative is to find that the Block in
Dialogue: 0,0:38:29.11,0:38:30.88,csapp,,0,0,0,,the heap if a free block in the heap
Dialogue: 0,0:38:30.88,0:38:35.20,csapp,,0,0,0,,that's the best fit so look at so in
Dialogue: 0,0:38:35.20,0:38:37.36,csapp,,0,0,0,,general look at all the blocks in the
Dialogue: 0,0:38:37.36,0:38:40.21,csapp,,0,0,0,,heap and find the block that fits the
Dialogue: 0,0:38:40.21,0:38:44.77,csapp,,0,0,0,,best ok so if we ask for 10 bytes try to
Dialogue: 0,0:38:44.77,0:38:46.90,csapp,,0,0,0,,scan the heap for the block that has the
Dialogue: 0,0:38:46.90,0:38:49.69,csapp,,0,0,0,,closest to 10 bytes in it okay so that's
Dialogue: 0,0:38:49.69,0:38:54.40,csapp,,0,0,0,,called best fit and best fit you can see
Dialogue: 0,0:38:54.40,0:38:55.72,csapp,,0,0,0,,it might be more it
Dialogue: 0,0:38:55.72,0:38:56.65,csapp,,0,0,0,,sounds like it would be a lot more
Dialogue: 0,0:38:56.65,0:38:58.18,csapp,,0,0,0,,expensive right because you'd have to
Dialogue: 0,0:38:58.18,0:38:59.74,csapp,,0,0,0,,look instead of just looking until you
Dialogue: 0,0:38:59.74,0:39:01.75,csapp,,0,0,0,,find a fit you'd have to scan all the
Dialogue: 0,0:39:01.75,0:39:03.90,csapp,,0,0,0,,free blocks and then pick the best one
Dialogue: 0,0:39:03.90,0:39:06.64,csapp,,0,0,0,,okay but it has a nice property that it
Dialogue: 0,0:39:06.64,0:39:09.64,csapp,,0,0,0,,improves memory utilization okay so if
Dialogue: 0,0:39:09.64,0:39:11.65,csapp,,0,0,0,,this isn't this is a classic example the
Dialogue: 0,0:39:11.65,0:39:15.13,csapp,,0,0,0,,space time trade-off so it's slower but
Dialogue: 0,0:39:15.13,0:39:17.23,csapp,,0,0,0,,it improves it improves our use of the
Dialogue: 0,0:39:17.23,0:39:23.60,csapp,,0,0,0,,efficiency of the way we use memory
Dialogue: 0,0:39:23.60,0:39:27.90,csapp,,0,0,0,,and there's now we mentioned we
Dialogue: 0,0:39:27.90,0:39:30.15,csapp,,0,0,0,,mentioned an alternative way to organize
Dialogue: 0,0:39:30.15,0:39:31.95,csapp,,0,0,0,,the free list using multiple free lists
Dialogue: 0,0:39:31.95,0:39:35.16,csapp,,0,0,0,,for different size classes now going
Dialogue: 0,0:39:35.16,0:39:36.83,csapp,,0,0,0,,back to that example again if we had an
Dialogue: 0,0:39:36.83,0:39:38.88,csapp,,0,0,0,,infinite number of size classes one for
Dialogue: 0,0:39:38.88,0:39:41.99,csapp,,0,0,0,,each size that would implement best fit
Dialogue: 0,0:39:41.99,0:39:44.33,csapp,,0,0,0,,with a constant time search we don't
Dialogue: 0,0:39:44.33,0:39:46.76,csapp,,0,0,0,,we'd know exactly which free list to get
Dialogue: 0,0:39:46.76,0:39:50.51,csapp,,0,0,0,,the block from the problem of course is
Dialogue: 0,0:39:50.51,0:39:53.48,csapp,,0,0,0,,how much memory such a organization
Dialogue: 0,0:39:53.48,0:39:57.69,csapp,,0,0,0,,would use but the interesting thing
Dialogue: 0,0:39:57.69,0:40:00.29,csapp,,0,0,0,,about using multiple free lists is that
Dialogue: 0,0:40:00.29,0:40:03.08,csapp,,0,0,0,,the more the more of these free lists
Dialogue: 0,0:40:03.08,0:40:05.27,csapp,,0,0,0,,you have the closer you get to it to a
Dialogue: 0,0:40:05.27,0:40:08.24,csapp,,0,0,0,,true best fit okay so you can approach
Dialogue: 0,0:40:08.24,0:40:10.55,csapp,,0,0,0,,best fit and then at some point you
Dialogue: 0,0:40:10.55,0:40:13.95,csapp,,0,0,0,,begin to get diminishing returns so so
Dialogue: 0,0:40:13.95,0:40:15.69,csapp,,0,0,0,,that's another sort of design decision
Dialogue: 0,0:40:15.69,0:40:17.48,csapp,,0,0,0,,is how many of these multiple free lists
Dialogue: 0,0:40:17.48,0:40:19.31,csapp,,0,0,0,,do you need and what what's sort of what
Dialogue: 0,0:40:19.31,0:40:21.02,csapp,,0,0,0,,what should be the size ranges
Dialogue: 0,0:40:21.02,0:40:25.04,csapp,,0,0,0,,associated with them
Dialogue: 0,0:40:25.04,0:40:27.23,csapp,,0,0,0,,okay another question now once we found
Dialogue: 0,0:40:27.23,0:40:29.78,csapp,,0,0,0,,a block so the application is made a
Dialogue: 0,0:40:29.78,0:40:34.40,csapp,,0,0,0,,call to malloc the malloc package is
Dialogue: 0,0:40:34.40,0:40:36.56,csapp,,0,0,0,,look in the free list that somehow using
Dialogue: 0,0:40:36.56,0:40:40.43,csapp,,0,0,0,,some some policy it's identified a block
Dialogue: 0,0:40:40.43,0:40:42.50,csapp,,0,0,0,,that in which the requested block a free
Dialogue: 0,0:40:42.50,0:40:44.06,csapp,,0,0,0,,block in which the requested block will
Dialogue: 0,0:40:44.06,0:40:48.17,csapp,,0,0,0,,fit okay so now what does it do it has
Dialogue: 0,0:40:48.17,0:40:52.55,csapp,,0,0,0,,to the malloc package has to allocate it
Dialogue: 0,0:40:52.55,0:40:57.38,csapp,,0,0,0,,has to sort of take that but so there's
Dialogue: 0,0:40:57.38,0:40:59.90,csapp,,0,0,0,,a question how does it it could allocate
Dialogue: 0,0:40:59.90,0:41:03.80,csapp,,0,0,0,,the whole block and return that back to
Dialogue: 0,0:41:03.80,0:41:05.69,csapp,,0,0,0,,the programmer or it could it could
Dialogue: 0,0:41:05.69,0:41:08.45,csapp,,0,0,0,,choose to split out a portion just only
Dialogue: 0,0:41:08.45,0:41:10.13,csapp,,0,0,0,,the portion of block that's needed and
Dialogue: 0,0:41:10.13,0:41:14.12,csapp,,0,0,0,,then create a smaller free block okay so
Dialogue: 0,0:41:14.12,0:41:20.75,csapp,,0,0,0,,for example if if we if our if our
Dialogue: 0,0:41:20.75,0:41:24.11,csapp,,0,0,0,,application is has requested a block of
Dialogue: 0,0:41:24.11,0:41:28.55,csapp,,0,0,0,,size 4 or I'm sorry it if the malloc
Dialogue: 0,0:41:28.55,0:41:30.92,csapp,,0,0,0,,package is determined that that it in
Dialogue: 0,0:41:30.92,0:41:32.87,csapp,,0,0,0,,order to satisfy the application request
Dialogue: 0,0:41:32.87,0:41:36.26,csapp,,0,0,0,,it needs a block of size 4 okay
Dialogue: 0,0:41:36.26,0:41:40.28,csapp,,0,0,0,,including the header then it would look
Dialogue: 0,0:41:40.28,0:41:43.58,csapp,,0,0,0,,and it would try to find a free block of
Dialogue: 0,0:41:43.58,0:41:47.48,csapp,,0,0,0,,at least size forward so let's say it
Dialogue: 0,0:41:47.48,0:41:50.87,csapp,,0,0,0,,chooses this block for some reason maybe
Dialogue: 0,0:41:50.87,0:41:54.58,csapp,,0,0,0,,because it was a next fit picked up here
Dialogue: 0,0:41:54.58,0:42:00.25,csapp,,0,0,0,,so this free block is actually six
Dialogue: 0,0:42:00.25,0:42:05.24,csapp,,0,0,0,,contains six words so the allocator has
Dialogue: 0,0:42:05.24,0:42:06.77,csapp,,0,0,0,,to decide whether just to keep this
Dialogue: 0,0:42:06.77,0:42:08.72,csapp,,0,0,0,,block of size six and just return that
Dialogue: 0,0:42:08.72,0:42:12.98,csapp,,0,0,0,,back to the to the application or
Dialogue: 0,0:42:12.98,0:42:15.38,csapp,,0,0,0,,whether to split that block into two
Dialogue: 0,0:42:15.38,0:42:17.48,csapp,,0,0,0,,blocks into an allocated block of size
Dialogue: 0,0:42:17.48,0:42:19.76,csapp,,0,0,0,,four which it then returns to the
Dialogue: 0,0:42:19.76,0:42:23.00,csapp,,0,0,0,,application followed by a free block of
Dialogue: 0,0:42:23.00,0:42:30.53,csapp,,0,0,0,,of size two
Dialogue: 0,0:42:30.53,0:42:33.95,csapp,,0,0,0,,okay now another question is how to free
Dialogue: 0,0:42:33.95,0:42:35.84,csapp,,0,0,0,,a block so the application is requested
Dialogue: 0,0:42:35.84,0:42:37.52,csapp,,0,0,0,,the elec is called free and it's asked
Dialogue: 0,0:42:37.52,0:42:39.44,csapp,,0,0,0,,the allocator to free up a particular
Dialogue: 0,0:42:39.44,0:42:47.69,csapp,,0,0,0,,block so this is pretty simple
Dialogue: 0,0:42:47.69,0:42:49.49,csapp,,0,0,0,,so if we want to free up this block you
Dialogue: 0,0:42:49.49,0:42:53.15,csapp,,0,0,0,,just clear the allocated flag so if we
Dialogue: 0,0:42:53.15,0:42:54.47,csapp,,0,0,0,,want to free up the block we just
Dialogue: 0,0:42:54.47,0:42:57.38,csapp,,0,0,0,,created you just clear you just set the
Dialogue: 0,0:42:57.38,0:43:00.14,csapp,,0,0,0,,allocated bit to zero and you're done
Dialogue: 0,0:43:00.14,0:43:02.54,csapp,,0,0,0,,it's really simple but the problem now
Dialogue: 0,0:43:02.54,0:43:04.88,csapp,,0,0,0,,is this this creates external
Dialogue: 0,0:43:04.88,0:43:10.19,csapp,,0,0,0,,fragmentation so here now if if we just
Dialogue: 0,0:43:10.19,0:43:13.55,csapp,,0,0,0,,free that block of size for what used to
Dialogue: 0,0:43:13.55,0:43:17.06,csapp,,0,0,0,,be a block of size six now consists of
Dialogue: 0,0:43:17.06,0:43:19.43,csapp,,0,0,0,,two contiguous smaller blocks one of
Dialogue: 0,0:43:19.43,0:43:24.53,csapp,,0,0,0,,size four and one of size two and so now
Dialogue: 0,0:43:24.53,0:43:26.72,csapp,,0,0,0,,if that's followed by a request for five
Dialogue: 0,0:43:26.72,0:43:31.07,csapp,,0,0,0,,blocks now we're stuck right so this but
Dialogue: 0,0:43:31.07,0:43:32.69,csapp,,0,0,0,,we've got plenty of memory and it's even
Dialogue: 0,0:43:32.69,0:43:35.72,csapp,,0,0,0,,worse in this case that memory is all
Dialogue: 0,0:43:35.72,0:43:39.77,csapp,,0,0,0,,contiguous just because but just because
Dialogue: 0,0:43:39.77,0:43:42.20,csapp,,0,0,0,,we just oh we just cleared the free
Dialogue: 0,0:43:42.20,0:43:45.23,csapp,,0,0,0,,block we didn't we didn't really notice
Dialogue: 0,0:43:45.23,0:43:47.54,csapp,,0,0,0,,that it was contiguous and so we ended
Dialogue: 0,0:43:47.54,0:43:49.07,csapp,,0,0,0,,up in with the situation where we have
Dialogue: 0,0:43:49.07,0:43:53.90,csapp,,0,0,0,,these two contiguous free blocks
Dialogue: 0,0:43:53.90,0:43:57.63,csapp,,0,0,0,,so this this suggests that when we do
Dialogue: 0,0:43:57.63,0:44:00.45,csapp,,0,0,0,,when we free up blocks that we somehow
Dialogue: 0,0:44:00.45,0:44:03.51,csapp,,0,0,0,,need to coalesce any neighboring blocks
Dialogue: 0,0:44:03.51,0:44:06.12,csapp,,0,0,0,,to keep blocks as big as possible right
Dialogue: 0,0:44:06.12,0:44:09.03,csapp,,0,0,0,,so we cannot one of the invariance of
Dialogue: 0,0:44:09.03,0:44:13.02,csapp,,0,0,0,,any decent allocator is that they're
Dialogue: 0,0:44:13.02,0:44:15.33,csapp,,0,0,0,,never there never contiguous free blocks
Dialogue: 0,0:44:15.33,0:44:17.58,csapp,,0,0,0,,like this it's always a free block
Dialogue: 0,0:44:17.58,0:44:23.16,csapp,,0,0,0,,followed by an allocated block okay so
Dialogue: 0,0:44:23.16,0:44:25.74,csapp,,0,0,0,,the idea is that if we free a particular
Dialogue: 0,0:44:25.74,0:44:28.94,csapp,,0,0,0,,so here we have this allocated block and
Dialogue: 0,0:44:28.94,0:44:31.98,csapp,,0,0,0,,if we free that block and we somehow
Dialogue: 0,0:44:31.98,0:44:35.04,csapp,,0,0,0,,have to check and see if there's any
Dialogue: 0,0:44:35.04,0:44:38.66,csapp,,0,0,0,,adjacent free blocks either following
Dialogue: 0,0:44:38.66,0:44:42.03,csapp,,0,0,0,,either neck either next in memory or
Dialogue: 0,0:44:42.03,0:44:45.15,csapp,,0,0,0,,previous in memory and if there are we
Dialogue: 0,0:44:45.15,0:44:48.09,csapp,,0,0,0,,need to as part of the freeing process
Dialogue: 0,0:44:48.09,0:44:49.71,csapp,,0,0,0,,we need to coalesce those two blocks
Dialogue: 0,0:44:49.71,0:44:52.74,csapp,,0,0,0,,into a into a larger block the largest
Dialogue: 0,0:44:52.74,0:44:56.79,csapp,,0,0,0,,possible block possible now it's pretty
Dialogue: 0,0:44:56.79,0:44:59.40,csapp,,0,0,0,,easy if we're if we're asked to free
Dialogue: 0,0:44:59.40,0:45:03.18,csapp,,0,0,0,,this block this green block it's pretty
Dialogue: 0,0:45:03.18,0:45:05.40,csapp,,0,0,0,,easy to check the the next block because
Dialogue: 0,0:45:05.40,0:45:07.62,csapp,,0,0,0,,you just we have the size we have this
Dialogue: 0,0:45:07.62,0:45:10.02,csapp,,0,0,0,,header so we know that the next block
Dialogue: 0,0:45:10.02,0:45:13.50,csapp,,0,0,0,,starts at an offset of four so we just
Dialogue: 0,0:45:13.50,0:45:17.22,csapp,,0,0,0,,we just we just check we know and we
Dialogue: 0,0:45:17.22,0:45:18.60,csapp,,0,0,0,,know that the header for that block is
Dialogue: 0,0:45:18.60,0:45:20.82,csapp,,0,0,0,,at your offset of four so we just check
Dialogue: 0,0:45:20.82,0:45:22.71,csapp,,0,0,0,,the allocated status of that next block
Dialogue: 0,0:45:22.71,0:45:26.40,csapp,,0,0,0,,using the using the size using the size
Dialogue: 0,0:45:26.40,0:45:28.47,csapp,,0,0,0,,field in our header but what about the
Dialogue: 0,0:45:28.47,0:45:31.86,csapp,,0,0,0,,previous block what about this block how
Dialogue: 0,0:45:31.86,0:45:33.95,csapp,,0,0,0,,do we check that
Dialogue: 0,0:45:33.95,0:45:37.11,csapp,,0,0,0,,well given given all that we've talked
Dialogue: 0,0:45:37.11,0:45:38.85,csapp,,0,0,0,,about now the only thing the only way we
Dialogue: 0,0:45:38.85,0:45:40.26,csapp,,0,0,0,,could do it would be to start at the
Dialogue: 0,0:45:40.26,0:45:42.78,csapp,,0,0,0,,beginning of the heap and now walk the
Dialogue: 0,0:45:42.78,0:45:45.42,csapp,,0,0,0,,free list until we get to this current
Dialogue: 0,0:45:45.42,0:45:49.35,csapp,,0,0,0,,block remembering the previous block so
Dialogue: 0,0:45:49.35,0:45:52.29,csapp,,0,0,0,,each time we each time we traverse we
Dialogue: 0,0:45:52.29,0:45:55.11,csapp,,0,0,0,,remember the previous block okay so that
Dialogue: 0,0:45:55.11,0:45:57.00,csapp,,0,0,0,,but that would be very inefficient right
Dialogue: 0,0:45:57.00,0:45:59.46,csapp,,0,0,0,,that would be that what that would make
Dialogue: 0,0:45:59.46,0:46:01.92,csapp,,0,0,0,,free linear in the size of the heat
Dialogue: 0,0:46:01.92,0:46:04.11,csapp,,0,0,0,,because we'd have to in order to check
Dialogue: 0,0:46:04.11,0:46:05.64,csapp,,0,0,0,,the previous block we'd have to walk
Dialogue: 0,0:46:05.64,0:46:06.90,csapp,,0,0,0,,starting at the very beginning
Dialogue: 0,0:46:06.90,0:46:11.40,csapp,,0,0,0,,and walk the entire heap so the solution
Dialogue: 0,0:46:11.40,0:46:13.56,csapp,,0,0,0,,for that is was proposed by a famous
Dialogue: 0,0:46:13.56,0:46:17.36,csapp,,0,0,0,,computer scientist Don Knuth in 1973
Dialogue: 0,0:46:17.36,0:46:20.25,csapp,,0,0,0,,it's very clever it very simple like all
Dialogue: 0,0:46:20.25,0:46:22.65,csapp,,0,0,0,,really good ideas it seems obvious that
Dialogue: 0,0:46:22.65,0:46:24.99,csapp,,0,0,0,,when you see it but it turns out to be
Dialogue: 0,0:46:24.99,0:46:28.62,csapp,,0,0,0,,very clever and a very very useful
Dialogue: 0,0:46:28.62,0:46:31.67,csapp,,0,0,0,,technique and the idea is just to
Dialogue: 0,0:46:31.67,0:46:34.83,csapp,,0,0,0,,replicate for each block replicate the
Dialogue: 0,0:46:34.83,0:46:37.89,csapp,,0,0,0,,header block at the end of the block
Dialogue: 0,0:46:37.89,0:46:40.47,csapp,,0,0,0,,okay so each block now contains a header
Dialogue: 0,0:46:40.47,0:46:43.50,csapp,,0,0,0,,and a footer identical header and footer
Dialogue: 0,0:46:43.50,0:46:47.19,csapp,,0,0,0,,and then this creates sort of an
Dialogue: 0,0:46:47.19,0:46:52.68,csapp,,0,0,0,,implicit backwards backwards link that
Dialogue: 0,0:46:52.68,0:46:58.29,csapp,,0,0,0,,we can use so now given given some block
Dialogue: 0,0:46:58.29,0:47:02.28,csapp,,0,0,0,,that we want to given some block that we
Dialogue: 0,0:47:02.28,0:47:06.09,csapp,,0,0,0,,want to free we know that the the size
Dialogue: 0,0:47:06.09,0:47:10.07,csapp,,0,0,0,,of that block will just be one one word
Dialogue: 0,0:47:10.07,0:47:13.65,csapp,,0,0,0,,previous in memory so so we can just and
Dialogue: 0,0:47:13.65,0:47:16.38,csapp,,0,0,0,,it's always a fixed fixed offset of one
Dialogue: 0,0:47:16.38,0:47:21.24,csapp,,0,0,0,,word so given you know given a pointer
Dialogue: 0,0:47:21.24,0:47:23.10,csapp,,0,0,0,,to the header of this block we can look
Dialogue: 0,0:47:23.10,0:47:25.23,csapp,,0,0,0,,one word back to see the size and the
Dialogue: 0,0:47:25.23,0:47:27.21,csapp,,0,0,0,,allocated allocation status of the
Dialogue: 0,0:47:27.21,0:47:30.12,csapp,,0,0,0,,previous block okay so and so that
Dialogue: 0,0:47:30.12,0:47:31.83,csapp,,0,0,0,,allows us to do that in constant time
Dialogue: 0,0:47:31.83,0:47:34.89,csapp,,0,0,0,,and so this footer is sometimes called
Dialogue: 0,0:47:34.89,0:47:38.31,csapp,,0,0,0,,the boundary tag and Knuth call that a
Dialogue: 0,0:47:38.31,0:47:41.46,csapp,,0,0,0,,boundary tag but we'll just and we can
Dialogue: 0,0:47:41.46,0:47:44.55,csapp,,0,0,0,,call it a footer to be sort of parallel
Dialogue: 0,0:47:44.55,0:47:46.52,csapp,,0,0,0,,with with with the notion of a header
Dialogue: 0,0:47:46.52,0:47:48.78,csapp,,0,0,0,,but the the key thing is that it's just
Dialogue: 0,0:47:48.78,0:47:50.91,csapp,,0,0,0,,identical has the identical size and
Dialogue: 0,0:47:50.91,0:47:55.12,csapp,,0,0,0,,allocation status
Dialogue: 0,0:47:55.12,0:48:06.85,csapp,,0,0,0,,and also given yes question so the
Dialogue: 0,0:48:06.85,0:48:07.90,csapp,,0,0,0,,question is if we want to have a
Dialogue: 0,0:48:07.90,0:48:09.61,csapp,,0,0,0,,boundary tag when we allocate a block do
Dialogue: 0,0:48:09.61,0:48:11.41,csapp,,0,0,0,,we need to set aside space for it and
Dialogue: 0,0:48:11.41,0:48:16.60,csapp,,0,0,0,,the answer is yes most of the time I'll
Dialogue: 0,0:48:16.60,0:48:18.37,csapp,,0,0,0,,show you a one I'll show you one
Dialogue: 0,0:48:18.37,0:48:26.31,csapp,,0,0,0,,optimization in a bit okay so given
Dialogue: 0,0:48:26.31,0:48:29.50,csapp,,0,0,0,,given this idea of a over the boundary
Dialogue: 0,0:48:29.50,0:48:36.31,csapp,,0,0,0,,tag and and and given that we have some
Dialogue: 0,0:48:36.31,0:48:38.31,csapp,,0,0,0,,allocated block that we want to free
Dialogue: 0,0:48:38.31,0:48:44.47,csapp,,0,0,0,,this yellow block yes question
Dialogue: 0,0:48:44.47,0:48:51.83,csapp,,0,0,0,,I
Dialogue: 0,0:48:51.83,0:48:56.21,csapp,,0,0,0,,yeah we so they quit yeah so just to
Dialogue: 0,0:48:56.21,0:49:00.65,csapp,,0,0,0,,summarize the question you need to when
Dialogue: 0,0:49:00.65,0:49:02.00,csapp,,0,0,0,,you allocate when you're looking for
Dialogue: 0,0:49:02.00,0:49:03.77,csapp,,0,0,0,,blocks that fit you have to include the
Dialogue: 0,0:49:03.77,0:49:06.35,csapp,,0,0,0,,the size of the header and the boundary
Dialogue: 0,0:49:06.35,0:49:12.59,csapp,,0,0,0,,tag it would you then you'd have and
Dialogue: 0,0:49:12.59,0:49:15.43,csapp,,0,0,0,,then you have to insert padding to get a
Dialogue: 0,0:49:15.43,0:49:18.02,csapp,,0,0,0,,size a total block size that's a
Dialogue: 0,0:49:18.02,0:49:20.84,csapp,,0,0,0,,multiple of that set of multiple that
Dialogue: 0,0:49:20.84,0:49:23.59,csapp,,0,0,0,,satisfies your alignment requirement
Dialogue: 0,0:49:23.59,0:49:30.98,csapp,,0,0,0,,sorry yeah I mean it can yeah if you
Dialogue: 0,0:49:30.98,0:49:33.32,csapp,,0,0,0,,have it the question is wouldn't I use a
Dialogue: 0,0:49:33.32,0:49:35.69,csapp,,0,0,0,,lot of memory and it can if again it
Dialogue: 0,0:49:35.69,0:49:38.12,csapp,,0,0,0,,depends on the requests the request
Dialogue: 0,0:49:38.12,0:49:39.92,csapp,,0,0,0,,pattern if if the application is
Dialogue: 0,0:49:39.92,0:49:42.38,csapp,,0,0,0,,requesting lots of small payloads then
Dialogue: 0,0:49:42.38,0:49:43.61,csapp,,0,0,0,,it's going to it's going to waste a lot
Dialogue: 0,0:49:43.61,0:49:45.86,csapp,,0,0,0,,of memory if it's requesting big
Dialogue: 0,0:49:45.86,0:49:51.91,csapp,,0,0,0,,payloads not so bad
Dialogue: 0,0:49:51.91,0:49:54.40,csapp,,0,0,0,,okay so given that we have some block
Dialogue: 0,0:49:54.40,0:49:56.74,csapp,,0,0,0,,that we want to free there's four cases
Dialogue: 0,0:49:56.74,0:49:59.14,csapp,,0,0,0,,that we need to consider when when
Dialogue: 0,0:49:59.14,0:50:02.31,csapp,,0,0,0,,coalescing the case where the the next
Dialogue: 0,0:50:02.31,0:50:04.18,csapp,,0,0,0,,block is allocated and the previous
Dialogue: 0,0:50:04.18,0:50:09.13,csapp,,0,0,0,,block is free is allocated a case where
Dialogue: 0,0:50:09.13,0:50:10.75,csapp,,0,0,0,,the next block is free and the previous
Dialogue: 0,0:50:10.75,0:50:13.83,csapp,,0,0,0,,block is allocated a case where the the
Dialogue: 0,0:50:13.83,0:50:15.57,csapp,,0,0,0,,previous block is free and the next
Dialogue: 0,0:50:15.57,0:50:17.07,csapp,,0,0,0,,block is allocated in the case where
Dialogue: 0,0:50:17.07,0:50:18.97,csapp,,0,0,0,,both the previous and next block are
Dialogue: 0,0:50:18.97,0:50:24.46,csapp,,0,0,0,,free okay so in case one where we have
Dialogue: 0,0:50:24.46,0:50:27.60,csapp,,0,0,0,,our allocated block that we want to free
Dialogue: 0,0:50:27.60,0:50:30.75,csapp,,0,0,0,,surrounded by two allocated blocks we
Dialogue: 0,0:50:30.75,0:50:32.04,csapp,,0,0,0,,don't do anything right because we only
Dialogue: 0,0:50:32.04,0:50:37.42,csapp,,0,0,0,,call us free memory so so in this case
Dialogue: 0,0:50:37.42,0:50:40.26,csapp,,0,0,0,,we just set keep the size of the header
Dialogue: 0,0:50:40.26,0:50:41.85,csapp,,0,0,0,,and footer stays the same and we just
Dialogue: 0,0:50:41.85,0:50:45.27,csapp,,0,0,0,,set the allocation status to to shift
Dialogue: 0,0:50:45.27,0:50:49.40,csapp,,0,0,0,,free
Dialogue: 0,0:50:49.40,0:50:53.39,csapp,,0,0,0,,now if the if the next block is is free
Dialogue: 0,0:50:53.39,0:50:56.72,csapp,,0,0,0,,and the previous block is allocated what
Dialogue: 0,0:50:56.72,0:51:00.14,csapp,,0,0,0,,we do is we we check the boundary tag of
Dialogue: 0,0:51:00.14,0:51:02.30,csapp,,0,0,0,,the the previous block and we see that
Dialogue: 0,0:51:02.30,0:51:03.86,csapp,,0,0,0,,it's allocated so there's nothing to do
Dialogue: 0,0:51:03.86,0:51:07.79,csapp,,0,0,0,,there we use the size to check the
Dialogue: 0,0:51:07.79,0:51:10.85,csapp,,0,0,0,,allocation status of the next block we
Dialogue: 0,0:51:10.85,0:51:13.37,csapp,,0,0,0,,use n to jump to the header of the next
Dialogue: 0,0:51:13.37,0:51:16.12,csapp,,0,0,0,,block we see that it's allocations
Dialogue: 0,0:51:16.12,0:51:20.51,csapp,,0,0,0,,status is free so these two blocks need
Dialogue: 0,0:51:20.51,0:51:23.72,csapp,,0,0,0,,to be coalesced so we do that by just
Dialogue: 0,0:51:23.72,0:51:28.16,csapp,,0,0,0,,adding adding the two sizes together to
Dialogue: 0,0:51:28.16,0:51:30.26,csapp,,0,0,0,,create this larger coalesce block and
Dialogue: 0,0:51:30.26,0:51:34.45,csapp,,0,0,0,,setting its allocation status to zero
Dialogue: 0,0:51:34.45,0:51:36.77,csapp,,0,0,0,,now in the case where the previous block
Dialogue: 0,0:51:36.77,0:51:42.11,csapp,,0,0,0,,is is free again we we check the
Dialogue: 0,0:51:42.11,0:51:43.88,csapp,,0,0,0,,boundary tech footer when we see that
Dialogue: 0,0:51:43.88,0:51:48.53,csapp,,0,0,0,,it's we see it it's free so in this case
Dialogue: 0,0:51:48.53,0:51:52.87,csapp,,0,0,0,,we create we have to update the size of
Dialogue: 0,0:51:52.87,0:51:55.43,csapp,,0,0,0,,the the old the header of the old
Dialogue: 0,0:51:55.43,0:51:57.91,csapp,,0,0,0,,previous block to create this now new
Dialogue: 0,0:51:57.91,0:52:01.07,csapp,,0,0,0,,larger coalesce block can we and we
Dialogue: 0,0:52:01.07,0:52:02.72,csapp,,0,0,0,,update the header and the boundary check
Dialogue: 0,0:52:02.72,0:52:07.82,csapp,,0,0,0,,footer accordingly and then in the case
Dialogue: 0,0:52:07.82,0:52:09.98,csapp,,0,0,0,,where where both the previous and the
Dialogue: 0,0:52:09.98,0:52:16.97,csapp,,0,0,0,,next block are free we create a single
Dialogue: 0,0:52:16.97,0:52:22.37,csapp,,0,0,0,,block a single block that's the sum of
Dialogue: 0,0:52:22.37,0:52:27.49,csapp,,0,0,0,,all three of those sizes
Dialogue: 0,0:52:27.49,0:52:29.08,csapp,,0,0,0,,okay so is that is that clear to
Dialogue: 0,0:52:29.08,0:52:35.61,csapp,,0,0,0,,everybody
Dialogue: 0,0:52:35.61,0:52:38.30,csapp,,0,0,0,,now as you pointed out correctly pointed
Dialogue: 0,0:52:38.30,0:52:40.40,csapp,,0,0,0,,out that boundary tags can create
Dialogue: 0,0:52:40.40,0:52:41.92,csapp,,0,0,0,,additional internal fragmentation
Dialogue: 0,0:52:41.92,0:52:44.39,csapp,,0,0,0,,because they're they're not part of
Dialogue: 0,0:52:44.39,0:52:46.94,csapp,,0,0,0,,payload so by definition they're their
Dialogue: 0,0:52:46.94,0:52:52.22,csapp,,0,0,0,,overhead and so you might you might ask
Dialogue: 0,0:52:52.22,0:52:57.02,csapp,,0,0,0,,yourself are there any cases where you
Dialogue: 0,0:52:57.02,0:53:06.34,csapp,,0,0,0,,don't need a boundary tag
Dialogue: 0,0:53:06.34,0:53:11.20,csapp,,0,0,0,,so which which blocks need which blocks
Dialogue: 0,0:53:11.20,0:53:29.02,csapp,,0,0,0,,need a boundary tag
Dialogue: 0,0:53:29.02,0:53:30.46,csapp,,0,0,0,,could you get away with does an
Dialogue: 0,0:53:30.46,0:53:47.36,csapp,,0,0,0,,allocated block need one
Dialogue: 0,0:53:47.36,0:53:50.48,csapp,,0,0,0,,yeah you're if you're not going to if
Dialogue: 0,0:53:50.48,0:53:52.31,csapp,,0,0,0,,you're not if you don't need to coalesce
Dialogue: 0,0:53:52.31,0:53:55.94,csapp,,0,0,0,,and you don't need to that footer and
Dialogue: 0,0:53:55.94,0:53:59.53,csapp,,0,0,0,,what kind of blocks don't you call us
Dialogue: 0,0:53:59.53,0:54:08.72,csapp,,0,0,0,,allocated blocks so what
Dialogue: 0,0:54:08.72,0:54:11.54,csapp,,0,0,0,,so maybe we can maybe maybe we don't
Dialogue: 0,0:54:11.54,0:54:13.49,csapp,,0,0,0,,need those at those boundary tech
Dialogue: 0,0:54:13.49,0:54:15.61,csapp,,0,0,0,,footers on allocated blocks right just
Dialogue: 0,0:54:15.61,0:54:19.19,csapp,,0,0,0,,on free blocks but then how are we going
Dialogue: 0,0:54:19.19,0:54:21.98,csapp,,0,0,0,,to determine that the previous block is
Dialogue: 0,0:54:21.98,0:54:25.81,csapp,,0,0,0,,allocated or free if an allocated block
Dialogue: 0,0:54:25.81,0:54:32.48,csapp,,0,0,0,,doesn't have a boundary tag footer yes
Dialogue: 0,0:54:32.48,0:54:38.03,csapp,,0,0,0,,sorry well yeah you would give it one
Dialogue: 0,0:54:38.03,0:54:40.19,csapp,,0,0,0,,when you free it but somehow when we're
Dialogue: 0,0:54:40.19,0:54:41.60,csapp,,0,0,0,,doing coalescing we need to check
Dialogue: 0,0:54:41.60,0:54:44.18,csapp,,0,0,0,,somehow that that previous block whether
Dialogue: 0,0:54:44.18,0:54:50.35,csapp,,0,0,0,,it's allocated or free okay but how does
Dialogue: 0,0:54:50.35,0:54:52.25,csapp,,0,0,0,,it know it's whether it's a boundary tag
Dialogue: 0,0:54:52.25,0:54:58.85,csapp,,0,0,0,,or not not sure no that's okay that's it
Dialogue: 0,0:54:58.85,0:55:09.08,csapp,,0,0,0,,okay yes bingo you got it so remember
Dialogue: 0,0:55:09.08,0:55:10.67,csapp,,0,0,0,,this remember remember because of our
Dialogue: 0,0:55:10.67,0:55:14.69,csapp,,0,0,0,,alignment we've got we've got multiple
Dialogue: 0,0:55:14.69,0:55:16.91,csapp,,0,0,0,,at least three bits in three or four
Dialogue: 0,0:55:16.91,0:55:19.09,csapp,,0,0,0,,bits that are always zero
Dialogue: 0,0:55:19.09,0:55:22.64,csapp,,0,0,0,,we're only using one of them so why not
Dialogue: 0,0:55:22.64,0:55:24.68,csapp,,0,0,0,,use another one to contain the
Dialogue: 0,0:55:24.68,0:55:27.60,csapp,,0,0,0,,allocation status of the previous block
Dialogue: 0,0:55:27.60,0:55:39.33,csapp,,0,0,0,,okay so very good that was
Dialogue: 0,0:55:39.33,0:55:45.66,csapp,,0,0,0,,it's so the idea so here's the block
Dialogue: 0,0:55:45.66,0:55:48.45,csapp,,0,0,0,,that we want to free and here's its
Dialogue: 0,0:55:48.45,0:55:52.68,csapp,,0,0,0,,header and we pass the P to it and we
Dialogue: 0,0:55:52.68,0:55:54.90,csapp,,0,0,0,,wonder if we want to free it and we've
Dialogue: 0,0:55:54.90,0:55:58.92,csapp,,0,0,0,,got we've got one bit we know that if we
Dialogue: 0,0:55:58.92,0:56:01.95,csapp,,0,0,0,,have a eight byte alignment we know that
Dialogue: 0,0:56:01.95,0:56:05.10,csapp,,0,0,0,,these are all implicitly zero so we're
Dialogue: 0,0:56:05.10,0:56:07.80,csapp,,0,0,0,,using this is a allocated block that we
Dialogue: 0,0:56:07.80,0:56:09.33,csapp,,0,0,0,,want to free so it has an allocation
Dialogue: 0,0:56:09.33,0:56:17.43,csapp,,0,0,0,,status of 1 and let's use this let's use
Dialogue: 0,0:56:17.43,0:56:20.94,csapp,,0,0,0,,one of these spare bits to indicate the
Dialogue: 0,0:56:20.94,0:56:23.87,csapp,,0,0,0,,allocation status of the previous block
Dialogue: 0,0:56:23.87,0:56:31.10,csapp,,0,0,0,,okay so far if the previous block is is
Dialogue: 0,0:56:31.10,0:56:38.22,csapp,,0,0,0,,allocated and this would be a 1 and when
Dialogue: 0,0:56:38.22,0:56:39.54,csapp,,0,0,0,,we're checking to see whether we need to
Dialogue: 0,0:56:39.54,0:56:42.48,csapp,,0,0,0,,coalesce we just check that we just
Dialogue: 0,0:56:42.48,0:56:45.60,csapp,,0,0,0,,check that that that's 2nd allocated bit
Dialogue: 0,0:56:45.60,0:56:47.19,csapp,,0,0,0,,the allocated bit of the previous block
Dialogue: 0,0:56:47.19,0:56:51.09,csapp,,0,0,0,,and if it's 1 we don't need to know what
Dialogue: 0,0:56:51.09,0:56:53.22,csapp,,0,0,0,,its size is okay we don't need to know
Dialogue: 0,0:56:53.22,0:56:54.42,csapp,,0,0,0,,where that block is because we're not
Dialogue: 0,0:56:54.42,0:56:57.90,csapp,,0,0,0,,going to coalesce it okay so in that we
Dialogue: 0,0:56:57.90,0:57:00.15,csapp,,0,0,0,,don't need so here we don't need a
Dialogue: 0,0:57:00.15,0:57:04.41,csapp,,0,0,0,,boundary tag for an allocated block but
Dialogue: 0,0:57:04.41,0:57:09.99,csapp,,0,0,0,,now if that if that block is free it'll
Dialogue: 0,0:57:09.99,0:57:14.40,csapp,,0,0,0,,have a boundary tag so we'll check if
Dialogue: 0,0:57:14.40,0:57:19.95,csapp,,0,0,0,,that block is free then the the
Dialogue: 0,0:57:19.95,0:57:23.91,csapp,,0,0,0,,allocation status will be will indicate
Dialogue: 0,0:57:23.91,0:57:27.30,csapp,,0,0,0,,free and then we know we need to we need
Dialogue: 0,0:57:27.30,0:57:30.74,csapp,,0,0,0,,to coalesce and we're going to need
Dialogue: 0,0:57:30.74,0:57:33.00,csapp,,0,0,0,,we're going to need a boundary tag
Dialogue: 0,0:57:33.00,0:57:34.59,csapp,,0,0,0,,because we need to know where that block
Dialogue: 0,0:57:34.59,0:57:37.29,csapp,,0,0,0,,starts we need to know its size so that
Dialogue: 0,0:57:37.29,0:57:41.28,csapp,,0,0,0,,we can go back and and update this size
Dialogue: 0,0:57:41.28,0:57:43.62,csapp,,0,0,0,,to include the you know the total
Dialogue: 0,0:57:43.62,0:57:48.12,csapp,,0,0,0,,coalesce size of those two blocks
Dialogue: 0,0:57:48.12,0:57:56.04,csapp,,0,0,0,,so is that that clear yes oh I just uh
Dialogue: 0,0:57:56.04,0:57:58.83,csapp,,0,0,0,,it's just the allocated bit so zero
Dialogue: 0,0:57:58.83,0:58:09.31,csapp,,0,0,0,,means not allocated one means allocated
Dialogue: 0,0:58:09.31,0:58:11.68,csapp,,0,0,0,,oh why are those bits that are why are
Dialogue: 0,0:58:11.68,0:58:17.11,csapp,,0,0,0,,the bits always zero why okay so blocks
Dialogue: 0,0:58:17.11,0:58:19.12,csapp,,0,0,0,,have to be aligned to eight byte
Dialogue: 0,0:58:19.12,0:58:20.86,csapp,,0,0,0,,boundaries okay
Dialogue: 0,0:58:20.86,0:58:22.57,csapp,,0,0,0,,oil payloads have to be aligned to eight
Dialogue: 0,0:58:22.57,0:58:26.17,csapp,,0,0,0,,byte boundaries okay that means that
Dialogue: 0,0:58:26.17,0:58:29.23,csapp,,0,0,0,,that blocks have to be the size of
Dialogue: 0,0:58:29.23,0:58:32.49,csapp,,0,0,0,,blocks has to be a multiple of eight
Dialogue: 0,0:58:32.49,0:58:34.60,csapp,,0,0,0,,because it's the same thing as when we
Dialogue: 0,0:58:34.60,0:58:37.06,csapp,,0,0,0,,were doing padding alignment instructs
Dialogue: 0,0:58:37.06,0:58:41.32,csapp,,0,0,0,,the next each block has to be a size has
Dialogue: 0,0:58:41.32,0:58:43.21,csapp,,0,0,0,,to be a multiple of eight so that the
Dialogue: 0,0:58:43.21,0:58:45.94,csapp,,0,0,0,,the block that follows that in memory is
Dialogue: 0,0:58:45.94,0:58:49.42,csapp,,0,0,0,,aligned properly okay so you're
Dialogue: 0,0:58:49.42,0:58:50.68,csapp,,0,0,0,,guaranteed because of the alignment
Dialogue: 0,0:58:50.68,0:58:52.47,csapp,,0,0,0,,requirement you're guaranteed that of
Dialogue: 0,0:58:52.47,0:58:54.88,csapp,,0,0,0,,eight or sixteen you're guaranteed that
Dialogue: 0,0:58:54.88,0:58:56.41,csapp,,0,0,0,,the size of the blocks are always
Dialogue: 0,0:58:56.41,0:59:00.82,csapp,,0,0,0,,multiples of either 8 or 16 okay and so
Dialogue: 0,0:59:00.82,0:59:02.89,csapp,,0,0,0,,that and that so that because that size
Dialogue: 0,0:59:02.89,0:59:04.99,csapp,,0,0,0,,is always a multiple of eight or sixteen
Dialogue: 0,0:59:04.99,0:59:08.08,csapp,,0,0,0,,you're guaranteed that either three or
Dialogue: 0,0:59:08.08,0:59:09.12,csapp,,0,0,0,,four
Dialogue: 0,0:59:09.12,0:59:17.22,csapp,,0,0,0,,four bits are all zeros
Dialogue: 0,0:59:17.22,0:59:18.14,csapp,,0,0,0,,okay
Dialogue: 0,0:59:18.14,0:59:22.68,csapp,,0,0,0,,[Music]
Dialogue: 0,0:59:22.68,0:59:28.30,csapp,,0,0,0,,any other questions
Dialogue: 0,0:59:28.30,0:59:32.06,csapp,,0,0,0,,[Music]
Dialogue: 0,0:59:32.06,0:59:34.43,csapp,,0,0,0,,okay let me summarize then some key
Dialogue: 0,0:59:34.43,0:59:38.72,csapp,,0,0,0,,policies when when implementing an
Dialogue: 0,0:59:38.72,0:59:40.55,csapp,,0,0,0,,allocator and I mentioned that there's
Dialogue: 0,0:59:40.55,0:59:43.10,csapp,,0,0,0,,the design spaces for these things is
Dialogue: 0,0:59:43.10,0:59:44.57,csapp,,0,0,0,,really large and really interesting
Dialogue: 0,0:59:44.57,0:59:47.21,csapp,,0,0,0,,there's a lot of things that you a lot
Dialogue: 0,0:59:47.21,0:59:49.00,csapp,,0,0,0,,of decisions that you have to make about
Dialogue: 0,0:59:49.00,0:59:52.37,csapp,,0,0,0,,various policies so the first is the
Dialogue: 0,0:59:52.37,0:59:55.94,csapp,,0,0,0,,placement policy where when we when
Dialogue: 0,0:59:55.94,0:59:57.23,csapp,,0,0,0,,we're trying to find when we're trying
Dialogue: 0,0:59:57.23,1:00:00.83,csapp,,0,0,0,,to place a free block I mean and out
Dialogue: 0,1:00:00.83,1:00:02.93,csapp,,0,0,0,,when we're trying to place an allocated
Dialogue: 0,1:00:02.93,1:00:04.91,csapp,,0,0,0,,block somewhere in a free block
Dialogue: 0,1:00:04.91,1:00:05.93,csapp,,0,0,0,,somewhere in the list
Dialogue: 0,1:00:05.93,1:00:08.66,csapp,,0,0,0,,what what what policy do we use first
Dialogue: 0,1:00:08.66,1:00:11.87,csapp,,0,0,0,,fit next fit or best fit and generally
Dialogue: 0,1:00:11.87,1:00:14.36,csapp,,0,0,0,,these things they trade-off throughput
Dialogue: 0,1:00:14.36,1:00:19.28,csapp,,0,0,0,,for fragmentation all right so the the
Dialogue: 0,1:00:19.28,1:00:26.70,csapp,,0,0,0,,faster faster versions like
Dialogue: 0,1:00:26.70,1:00:29.10,csapp,,0,0,0,,if you're willing to if you're willing
Dialogue: 0,1:00:29.10,1:00:30.88,csapp,,0,0,0,,to deal with with lower throughput like
Dialogue: 0,1:00:30.88,1:00:33.94,csapp,,0,0,0,,in the case of best fit then you can get
Dialogue: 0,1:00:33.94,1:00:38.89,csapp,,0,0,0,,better memory utilization now there are
Dialogue: 0,1:00:38.89,1:00:41.89,csapp,,0,0,0,,interesting there are interesting ways
Dialogue: 0,1:00:41.89,1:00:43.85,csapp,,0,0,0,,to improve the performance of best fit
Dialogue: 0,1:00:43.85,1:00:46.32,csapp,,0,0,0,,you might you might consider something
Dialogue: 0,1:00:46.32,1:00:49.45,csapp,,0,0,0,,like good fit which is sort of a mix of
Dialogue: 0,1:00:49.45,1:00:52.03,csapp,,0,0,0,,first fit and best fit so maybe maybe
Dialogue: 0,1:00:52.03,1:00:55.63,csapp,,0,0,0,,you only search the first you know a
Dialogue: 0,1:00:55.63,1:00:57.40,csapp,,0,0,0,,portion of the heap and then identify
Dialogue: 0,1:00:57.40,1:00:59.14,csapp,,0,0,0,,the best fit you know maybe instead of
Dialogue: 0,1:00:59.14,1:01:01.42,csapp,,0,0,0,,searching the entire heap you just
Dialogue: 0,1:01:01.42,1:01:03.40,csapp,,0,0,0,,search some some portion of the heap and
Dialogue: 0,1:01:03.40,1:01:05.77,csapp,,0,0,0,,then cut off the search and then within
Dialogue: 0,1:01:05.77,1:01:08.05,csapp,,0,0,0,,that region that you search do you pick
Dialogue: 0,1:01:08.05,1:01:11.73,csapp,,0,0,0,,the best block so that's something that
Dialogue: 0,1:01:11.73,1:01:15.79,csapp,,0,0,0,,called good fit so that that kind of
Dialogue: 0,1:01:15.79,1:01:19.59,csapp,,0,0,0,,approximates best fit or you can use
Dialogue: 0,1:01:19.59,1:01:21.46,csapp,,0,0,0,,these multiple free lists to approximate
Dialogue: 0,1:01:21.46,1:01:25.00,csapp,,0,0,0,,best fit and that's and then and there
Dialogue: 0,1:01:25.00,1:01:28.05,csapp,,0,0,0,,you the real advantage of using multiple
Dialogue: 0,1:01:28.05,1:01:31.48,csapp,,0,0,0,,free lists is that it not only improves
Dialogue: 0,1:01:31.48,1:01:33.30,csapp,,0,0,0,,memory utilization but it improves
Dialogue: 0,1:01:33.30,1:01:35.82,csapp,,0,0,0,,performance too because the individual
Dialogue: 0,1:01:35.82,1:01:38.04,csapp,,0,0,0,,lists that you're looking for you know
Dialogue: 0,1:01:38.04,1:01:40.21,csapp,,0,0,0,,that they contain blocks that are close
Dialogue: 0,1:01:40.21,1:01:43.61,csapp,,0,0,0,,to what you're asking for and since
Dialogue: 0,1:01:43.61,1:01:46.15,csapp,,0,0,0,,you're dividing all the free blocks up
Dialogue: 0,1:01:46.15,1:01:48.76,csapp,,0,0,0,,amongst multiple amongst multiple free
Dialogue: 0,1:01:48.76,1:01:50.84,csapp,,0,0,0,,lists those free lists will be shorter
Dialogue: 0,1:01:50.84,1:01:53.14,csapp,,0,0,0,,okay so your searches will take less
Dialogue: 0,1:01:53.14,1:01:55.78,csapp,,0,0,0,,time and your your probability of
Dialogue: 0,1:01:55.78,1:01:58.26,csapp,,0,0,0,,finding a block that fits goes up
Dialogue: 0,1:01:58.26,1:02:00.48,csapp,,0,0,0,,because you're segregating these
Dialogue: 0,1:02:00.48,1:02:04.88,csapp,,0,0,0,,different size classes
Dialogue: 0,1:02:04.88,1:02:08.15,csapp,,0,0,0,,now there's a we also have to decide on
Dialogue: 0,1:02:08.15,1:02:11.29,csapp,,0,0,0,,some splitting policy so when we find
Dialogue: 0,1:02:11.29,1:02:13.09,csapp,,0,0,0,,when we find a free block that's big
Dialogue: 0,1:02:13.09,1:02:15.31,csapp,,0,0,0,,enough what do we do with the leftover
Dialogue: 0,1:02:15.31,1:02:18.28,csapp,,0,0,0,,the leftover part of that block you know
Dialogue: 0,1:02:18.28,1:02:21.10,csapp,,0,0,0,,once we placed our allocated block into
Dialogue: 0,1:02:21.10,1:02:23.74,csapp,,0,0,0,,that into that free block what do we do
Dialogue: 0,1:02:23.74,1:02:25.33,csapp,,0,0,0,,with the leftovers do we just leave the
Dialogue: 0,1:02:25.33,1:02:27.89,csapp,,0,0,0,,leftover part in the block itself and
Dialogue: 0,1:02:27.89,1:02:29.63,csapp,,0,0,0,,return that back to the application
Dialogue: 0,1:02:29.63,1:02:32.86,csapp,,0,0,0,,you know avoiding so that sort of
Dialogue: 0,1:02:32.86,1:02:35.72,csapp,,0,0,0,,keeping keeping larger blocks or do we
Dialogue: 0,1:02:35.72,1:02:37.78,csapp,,0,0,0,,go ahead and split it like like I showed
Dialogue: 0,1:02:37.78,1:02:42.28,csapp,,0,0,0,,before and splitting we go ahead and
Dialogue: 0,1:02:42.28,1:02:44.63,csapp,,0,0,0,,splitting that block and creating the
Dialogue: 0,1:02:44.63,1:02:46.80,csapp,,0,0,0,,creating the original free block
Dialogue: 0,1:02:46.80,1:02:48.71,csapp,,0,0,0,,allocating a portion of it and then
Dialogue: 0,1:02:48.71,1:02:51.91,csapp,,0,0,0,,creating a smaller free block so that's
Dialogue: 0,1:02:51.91,1:02:54.38,csapp,,0,0,0,,you know that's a policy we may you may
Dialogue: 0,1:02:54.38,1:02:57.92,csapp,,0,0,0,,want to you may want to for small
Dialogue: 0,1:02:57.92,1:03:01.06,csapp,,0,0,0,,requests for small payloads you may up
Dialogue: 0,1:03:01.06,1:03:03.10,csapp,,0,0,0,,to a certain size you may not want to
Dialogue: 0,1:03:03.10,1:03:05.35,csapp,,0,0,0,,split so you may not you may decide not
Dialogue: 0,1:03:05.35,1:03:08.72,csapp,,0,0,0,,to split blocks smaller you may not you
Dialogue: 0,1:03:08.72,1:03:12.10,csapp,,0,0,0,,may decide not to create free blocks
Dialogue: 0,1:03:12.10,1:03:14.63,csapp,,0,0,0,,that are smaller than some threshold and
Dialogue: 0,1:03:14.63,1:03:18.14,csapp,,0,0,0,,only splitting for 4 requests for larger
Dialogue: 0,1:03:18.14,1:03:21.52,csapp,,0,0,0,,blocks and then there's the there's a
Dialogue: 0,1:03:21.52,1:03:27.41,csapp,,0,0,0,,coalescing policy now we've seen freeing
Dialogue: 0,1:03:27.41,1:03:29.21,csapp,,0,0,0,,is pretty quick now it's constant time
Dialogue: 0,1:03:29.21,1:03:32.86,csapp,,0,0,0,,because of the boundary tag footers but
Dialogue: 0,1:03:32.86,1:03:36.10,csapp,,0,0,0,,you may you may want to you may want to
Dialogue: 0,1:03:36.10,1:03:38.32,csapp,,0,0,0,,try to just speed that up even more by
Dialogue: 0,1:03:38.32,1:03:43.77,csapp,,0,0,0,,by deferring the coalescing so you could
Dialogue: 0,1:03:43.77,1:03:48.41,csapp,,0,0,0,,you can do coalescing it every time the
Dialogue: 0,1:03:48.41,1:03:50.39,csapp,,0,0,0,,free is called like like we just looked
Dialogue: 0,1:03:50.39,1:03:54.17,csapp,,0,0,0,,at or you could defer coalescing to some
Dialogue: 0,1:03:54.17,1:03:56.53,csapp,,0,0,0,,later time you know maybe when you're
Dialogue: 0,1:03:56.53,1:03:58.67,csapp,,0,0,0,,scanning the free list when you're
Dialogue: 0,1:03:58.67,1:04:01.33,csapp,,0,0,0,,scanning the free list looking set try
Dialogue: 0,1:04:01.33,1:04:02.96,csapp,,0,0,0,,trying to find trying to place an
Dialogue: 0,1:04:02.96,1:04:04.99,csapp,,0,0,0,,allocated block in response to a malloc
Dialogue: 0,1:04:04.99,1:04:07.70,csapp,,0,0,0,,call maybe as you scan that free list
Dialogue: 0,1:04:07.70,1:04:09.38,csapp,,0,0,0,,you could go ahead and do the coalescing
Dialogue: 0,1:04:09.38,1:04:13.21,csapp,,0,0,0,,at that time right so
Dialogue: 0,1:04:13.21,1:04:15.64,csapp,,0,0,0,,I'm not saying which one is better it's
Dialogue: 0,1:04:15.64,1:04:17.53,csapp,,0,0,0,,hard to it's really hard to argue for
Dialogue: 0,1:04:17.53,1:04:19.99,csapp,,0,0,0,,deferred colas and giving the constant
Dialogue: 0,1:04:19.99,1:04:25.17,csapp,,0,0,0,,time performance of a boundary tag-based
Dialogue: 0,1:04:25.17,1:04:27.37,csapp,,0,0,0,,coalescing but it but it is an option
Dialogue: 0,1:04:27.37,1:04:32.41,csapp,,0,0,0,,okay so here's the summary then of
Dialogue: 0,1:04:32.41,1:04:37.35,csapp,,0,0,0,,implicit lists this is the simplest well
Dialogue: 0,1:04:37.35,1:04:41.13,csapp,,0,0,0,,it's a very simple kind of allocator i
Dialogue: 0,1:04:41.13,1:04:46.54,csapp,,0,0,0,,it's it's the cost to allocate is linear
Dialogue: 0,1:04:46.54,1:04:50.23,csapp,,0,0,0,,in the in the size of the heap worst
Dialogue: 0,1:04:50.23,1:04:54.52,csapp,,0,0,0,,case that the cost of free is constant
Dialogue: 0,1:04:54.52,1:04:57.88,csapp,,0,0,0,,time even with coalescing memory usage
Dialogue: 0,1:04:57.88,1:04:59.41,csapp,,0,0,0,,will be will depend on the placement
Dialogue: 0,1:04:59.41,1:05:03.37,csapp,,0,0,0,,policy first fit next fit or best fit um
Dialogue: 0,1:05:03.37,1:05:07.60,csapp,,0,0,0,,it's not used in practice because of the
Dialogue: 0,1:05:07.60,1:05:10.12,csapp,,0,0,0,,linear time the linear time cost of
Dialogue: 0,1:05:10.12,1:05:14.71,csapp,,0,0,0,,allocation okay but it it can be used in
Dialogue: 0,1:05:14.71,1:05:17.05,csapp,,0,0,0,,sort of special-purpose allocators where
Dialogue: 0,1:05:17.05,1:05:19.39,csapp,,0,0,0,,you have a small number of size classes
Dialogue: 0,1:05:19.39,1:05:21.58,csapp,,0,0,0,,maybe or you have a very you know that
Dialogue: 0,1:05:21.58,1:05:23.50,csapp,,0,0,0,,you have a very small or a fairly small
Dialogue: 0,1:05:23.50,1:05:27.43,csapp,,0,0,0,,free list but the ideas of splitting and
Dialogue: 0,1:05:27.43,1:05:29.65,csapp,,0,0,0,,coalescing that we looked at or general
Dialogue: 0,1:05:29.65,1:05:32.11,csapp,,0,0,0,,to all allocators okay so the idea of a
Dialogue: 0,1:05:32.11,1:05:33.49,csapp,,0,0,0,,boundary tag boundary tag-based
Dialogue: 0,1:05:33.49,1:05:38.23,csapp,,0,0,0,,coalescing is is u is used regardless of
Dialogue: 0,1:05:38.23,1:05:41.65,csapp,,0,0,0,,the structure of your free list so
Dialogue: 0,1:05:41.65,1:05:43.92,csapp,,0,0,0,,implicit lists are useful to study
Dialogue: 0,1:05:43.92,1:05:47.08,csapp,,0,0,0,,because they introduce some important
Dialogue: 0,1:05:47.08,1:05:48.70,csapp,,0,0,0,,concepts but generally they're not
Dialogue: 0,1:05:48.70,1:05:52.86,csapp,,0,0,0,,they're not they're not that useful
Dialogue: 0,1:05:52.86,1:05:57.73,csapp,,0,0,0,,so next next class we'll look at some
Dialogue: 0,1:05:57.73,1:06:00.13,csapp,,0,0,0,,more sophisticated organizations of free
Dialogue: 0,1:06:00.13,1:06:04.39,csapp,,0,0,0,,less the explicit list and multiple free
Dialogue: 0,1:06:04.39,1:06:07.84,csapp,,0,0,0,,lists in particular alright so we'll see
Dialogue: 0,1:06:07.84,1:06:10.03,csapp,,0,0,0,,you then good luck on your shell lab due
Dialogue: 0,1:06:10.03,1:06:15.72,csapp,,0,0,0,,tonight and we'll see you on Thursday
