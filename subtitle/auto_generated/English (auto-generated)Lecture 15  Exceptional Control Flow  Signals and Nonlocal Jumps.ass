[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video File: ../../../Desktop/csapp/Lecture 14  Exceptional Control Flow  Exceptions and Processes.mp4
Active Line: 4
Video Position: 359

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FF0000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:03.06,csapp,,0,0,0,,good afternoon everybody welcome good to
Dialogue: 0,0:00:03.06,0:00:05.91,csapp,,0,0,0,,see you today we're going to continue
Dialogue: 0,0:00:05.91,0:00:09.66,csapp,,0,0,0,,our study of exceptional control flow by
Dialogue: 0,0:00:09.66,0:00:11.96,csapp,,0,0,0,,looking at some higher level mechanisms
Dialogue: 0,0:00:11.96,0:00:15.78,csapp,,0,0,0,,known as Linux signals and see non-local
Dialogue: 0,0:00:15.78,0:00:18.86,csapp,,0,0,0,,jumps now we're going to spend most of
Dialogue: 0,0:00:18.86,0:00:21.42,csapp,,0,0,0,,our most of our time looking at signals
Dialogue: 0,0:00:21.42,0:00:23.34,csapp,,0,0,0,,because they have a lot of subtleties
Dialogue: 0,0:00:23.34,0:00:26.13,csapp,,0,0,0,,the semantics can be kind of confusing
Dialogue: 0,0:00:26.13,0:00:27.57,csapp,,0,0,0,,so we're going to we're going to spend
Dialogue: 0,0:00:27.57,0:00:30.61,csapp,,0,0,0,,most of our time there and I'll mention
Dialogue: 0,0:00:30.61,0:00:36.18,csapp,,0,0,0,,the idea of non-local jumps but for
Dialogue: 0,0:00:36.18,0:00:38.07,csapp,,0,0,0,,details on those you'll want to look in
Dialogue: 0,0:00:38.07,0:00:40.02,csapp,,0,0,0,,your textbook and in the slides at the
Dialogue: 0,0:00:40.02,0:00:41.94,csapp,,0,0,0,,Supplemental slides at the end of this
Dialogue: 0,0:00:41.94,0:00:46.86,csapp,,0,0,0,,the slide deck now to motivate the
Dialogue: 0,0:00:46.86,0:00:50.43,csapp,,0,0,0,,notion of signals I want to want to talk
Dialogue: 0,0:00:50.43,0:00:56.28,csapp,,0,0,0,,a little bit about shell programs now as
Dialogue: 0,0:00:56.28,0:00:58.28,csapp,,0,0,0,,we mentioned last time there's only one
Dialogue: 0,0:00:58.28,0:01:01.32,csapp,,0,0,0,,way to create processes on a Linux
Dialogue: 0,0:01:01.32,0:01:03.65,csapp,,0,0,0,,system and that's using the fork call in
Dialogue: 0,0:01:03.65,0:01:07.71,csapp,,0,0,0,,fact the all of the processes on the
Dialogue: 0,0:01:07.71,0:01:09.99,csapp,,0,0,0,,system actually form a hierarchy so that
Dialogue: 0,0:01:09.99,0:01:12.72,csapp,,0,0,0,,the very first process created when you
Dialogue: 0,0:01:12.72,0:01:15.50,csapp,,0,0,0,,boot the system up is the anit process
Dialogue: 0,0:01:15.50,0:01:18.72,csapp,,0,0,0,,which has a process ID of one and then
Dialogue: 0,0:01:18.72,0:01:20.49,csapp,,0,0,0,,all other processes on the system are
Dialogue: 0,0:01:20.49,0:01:23.81,csapp,,0,0,0,,descendants of that of that init process
Dialogue: 0,0:01:23.81,0:01:27.84,csapp,,0,0,0,,now the anit process when it starts up
Dialogue: 0,0:01:27.84,0:01:30.63,csapp,,0,0,0,,it creates daemons which are
Dialogue: 0,0:01:30.63,0:01:32.25,csapp,,0,0,0,,long-running programs that provide
Dialogue: 0,0:01:32.25,0:01:35.22,csapp,,0,0,0,,services typically so for example of a
Dialogue: 0,0:01:35.22,0:01:39.21,csapp,,0,0,0,,web server it other kinds of services
Dialogue: 0,0:01:39.21,0:01:40.92,csapp,,0,0,0,,that you always want running on the
Dialogue: 0,0:01:40.92,0:01:43.47,csapp,,0,0,0,,system and then eventually it creates
Dialogue: 0,0:01:43.47,0:01:46.64,csapp,,0,0,0,,login so called login shells which
Dialogue: 0,0:01:46.64,0:01:48.63,csapp,,0,0,0,,provide the command-line interface to
Dialogue: 0,0:01:48.63,0:01:51.96,csapp,,0,0,0,,two users so when you log into a Linux
Dialogue: 0,0:01:51.96,0:01:54.42,csapp,,0,0,0,,system what you eventually get to is
Dialogue: 0,0:01:54.42,0:01:57.84,csapp,,0,0,0,,that is a login shell that's expecting
Dialogue: 0,0:01:57.84,0:02:02.64,csapp,,0,0,0,,you to type commands now the login login
Dialogue: 0,0:02:02.64,0:02:06.89,csapp,,0,0,0,,shells execute programs on your your
Dialogue: 0,0:02:06.89,0:02:10.80,csapp,,0,0,0,,behalf so when we type something into
Dialogue: 0,0:02:10.80,0:02:12.30,csapp,,0,0,0,,the shell
Dialogue: 0,0:02:12.30,0:02:15.33,csapp,,0,0,0,,say we type the LS command we're asking
Dialogue: 0,0:02:15.33,0:02:17.13,csapp,,0,0,0,,we're asking the shell to run the
Dialogue: 0,0:02:17.13,0:02:23.37,csapp,,0,0,0,,executable program called LS and so what
Dialogue: 0,0:02:23.37,0:02:25.05,csapp,,0,0,0,,the shell will do is it will create a
Dialogue: 0,0:02:25.05,0:02:28.77,csapp,,0,0,0,,child and then it will execute LS within
Dialogue: 0,0:02:28.77,0:02:31.92,csapp,,0,0,0,,that child process and it's possible
Dialogue: 0,0:02:31.92,0:02:35.82,csapp,,0,0,0,,that that process may create other other
Dialogue: 0,0:02:35.82,0:02:41.46,csapp,,0,0,0,,child processes so a shell is an
Dialogue: 0,0:02:41.46,0:02:43.26,csapp,,0,0,0,,application program no different from
Dialogue: 0,0:02:43.26,0:02:46.41,csapp,,0,0,0,,any other program that executes programs
Dialogue: 0,0:02:46.41,0:02:50.82,csapp,,0,0,0,,on the behalf of users okay the default
Dialogue: 0,0:02:50.82,0:02:52.80,csapp,,0,0,0,,shell for Linux is called bash but
Dialogue: 0,0:02:52.80,0:02:55.77,csapp,,0,0,0,,there's there's other shells that that
Dialogue: 0,0:02:55.77,0:03:00.36,csapp,,0,0,0,,were created on earlier with earlier
Dialogue: 0,0:03:00.36,0:03:04.23,csapp,,0,0,0,,versions of UNIX SH was the original
Dialogue: 0,0:03:04.23,0:03:05.82,csapp,,0,0,0,,shell called the bourne shell because it
Dialogue: 0,0:03:05.82,0:03:08.19,csapp,,0,0,0,,was created by steven born and when
Dialogue: 0,0:03:08.19,0:03:09.18,csapp,,0,0,0,,berkeley came out with their
Dialogue: 0,0:03:09.18,0:03:11.67,csapp,,0,0,0,,distribution of unix they created a
Dialogue: 0,0:03:11.67,0:03:17.20,csapp,,0,0,0,,shell called the CSH now the the
Dialogue: 0,0:03:17.20,0:03:20.28,csapp,,0,0,0,,execution is in a shell is a sequence of
Dialogue: 0,0:03:20.28,0:03:23.67,csapp,,0,0,0,,read and evaluate steps so first a shell
Dialogue: 0,0:03:23.67,0:03:26.45,csapp,,0,0,0,,prints out a prompt and then it waits
Dialogue: 0,0:03:26.45,0:03:28.98,csapp,,0,0,0,,for it waits for you to type something
Dialogue: 0,0:03:28.98,0:03:30.72,csapp,,0,0,0,,in on the command line and hit return
Dialogue: 0,0:03:30.72,0:03:33.51,csapp,,0,0,0,,okay and typically what you're what
Dialogue: 0,0:03:33.51,0:03:37.70,csapp,,0,0,0,,you're typing in is a is a command which
Dialogue: 0,0:03:37.70,0:03:40.11,csapp,,0,0,0,,is just the so the first thing you type
Dialogue: 0,0:03:40.11,0:03:41.64,csapp,,0,0,0,,is a command and then you follow that
Dialogue: 0,0:03:41.64,0:03:43.53,csapp,,0,0,0,,with optional arguments separated by
Dialogue: 0,0:03:43.53,0:03:47.70,csapp,,0,0,0,,spaces okay so once you hit once you
Dialogue: 0,0:03:47.70,0:03:49.59,csapp,,0,0,0,,type in a command and those optional
Dialogue: 0,0:03:49.59,0:03:53.34,csapp,,0,0,0,,arguments and hit return the shell
Dialogue: 0,0:03:53.34,0:03:56.82,csapp,,0,0,0,,checks for the end of file character
Dialogue: 0,0:03:56.82,0:04:00.90,csapp,,0,0,0,,which is a control D to terminal and if
Dialogue: 0,0:04:00.90,0:04:03.75,csapp,,0,0,0,,so it exits otherwise it evaluates that
Dialogue: 0,0:04:03.75,0:04:08.33,csapp,,0,0,0,,command line and the evaluation consists
Dialogue: 0,0:04:08.33,0:04:11.55,csapp,,0,0,0,,and then when it returns from the
Dialogue: 0,0:04:11.55,0:04:13.56,csapp,,0,0,0,,evaluation it just does the same thing
Dialogue: 0,0:04:13.56,0:04:16.23,csapp,,0,0,0,,over in it now the evaluation consists
Dialogue: 0,0:04:16.23,0:04:22.19,csapp,,0,0,0,,of the following kinds of steps first it
Dialogue: 0,0:04:22.19,0:04:24.98,csapp,,0,0,0,,parses the command line
Dialogue: 0,0:04:24.98,0:04:30.00,csapp,,0,0,0,,and bite and and in the process so it
Dialogue: 0,0:04:30.00,0:04:31.47,csapp,,0,0,0,,takes the command-line which in this
Dialogue: 0,0:04:31.47,0:04:34.32,csapp,,0,0,0,,example is in buff and it produces an RV
Dialogue: 0,0:04:34.32,0:04:37.26,csapp,,0,0,0,,array okay where arc v-0 is a command
Dialogue: 0,0:04:37.26,0:04:40.14,csapp,,0,0,0,,and then our V one and two and so on are
Dialogue: 0,0:04:40.14,0:04:44.28,csapp,,0,0,0,,the optional arguments and the
Dialogue: 0,0:04:44.28,0:04:46.35,csapp,,0,0,0,,convention in a shell is that if the
Dialogue: 0,0:04:46.35,0:04:49.83,csapp,,0,0,0,,command line is terminated by an
Dialogue: 0,0:04:49.83,0:04:51.75,csapp,,0,0,0,,ampersand then you're asking the shell
Dialogue: 0,0:04:51.75,0:04:54.36,csapp,,0,0,0,,to run that job to run that command in
Dialogue: 0,0:04:54.36,0:04:56.88,csapp,,0,0,0,,the background meaning the shell won't
Dialogue: 0,0:04:56.88,0:04:59.16,csapp,,0,0,0,,wait for that job to finish before it
Dialogue: 0,0:04:59.16,0:05:02.70,csapp,,0,0,0,,goes through its next read stub if it if
Dialogue: 0,0:05:02.70,0:05:05.01,csapp,,0,0,0,,the the line that you type doesn't have
Dialogue: 0,0:05:05.01,0:05:06.45,csapp,,0,0,0,,an ampersand then you're asking the
Dialogue: 0,0:05:06.45,0:05:08.19,csapp,,0,0,0,,shell to to run that job in the
Dialogue: 0,0:05:08.19,0:05:10.11,csapp,,0,0,0,,foreground which means the shell will
Dialogue: 0,0:05:10.11,0:05:17.22,csapp,,0,0,0,,wait so so first we parse this this
Dialogue: 0,0:05:17.22,0:05:19.71,csapp,,0,0,0,,command line into an art V array and we
Dialogue: 0,0:05:19.71,0:05:21.81,csapp,,0,0,0,,return whether or not it was terminated
Dialogue: 0,0:05:21.81,0:05:25.46,csapp,,0,0,0,,by an ampersand D so BG for background
Dialogue: 0,0:05:25.46,0:05:28.98,csapp,,0,0,0,,if art V zero is null then that means we
Dialogue: 0,0:05:28.98,0:05:30.96,csapp,,0,0,0,,just hit a we just hit return right so
Dialogue: 0,0:05:30.96,0:05:33.18,csapp,,0,0,0,,as an empty line so we'll just return
Dialogue: 0,0:05:33.18,0:05:38.60,csapp,,0,0,0,,and just ignore those now a shell also
Dialogue: 0,0:05:38.60,0:05:41.10,csapp,,0,0,0,,implements what are called built-in
Dialogue: 0,0:05:41.10,0:05:45.50,csapp,,0,0,0,,commands so various things like jobs BG
Dialogue: 0,0:05:45.50,0:05:49.62,csapp,,0,0,0,,f G are examples of built-in commands
Dialogue: 0,0:05:49.62,0:05:51.42,csapp,,0,0,0,,which are just implemented in the shell
Dialogue: 0,0:05:51.42,0:05:54.69,csapp,,0,0,0,,itself so if you type if the first thing
Dialogue: 0,0:05:54.69,0:05:57.72,csapp,,0,0,0,,you type if the command you enter is a
Dialogue: 0,0:05:57.72,0:06:01.68,csapp,,0,0,0,,built in then the shell will it will
Dialogue: 0,0:06:01.68,0:06:04.05,csapp,,0,0,0,,check that it will check our v-0 for a
Dialogue: 0,0:06:04.05,0:06:06.90,csapp,,0,0,0,,to see if it's a built-in command and if
Dialogue: 0,0:06:06.90,0:06:09.93,csapp,,0,0,0,,it is it'll just execute it whatever
Dialogue: 0,0:06:09.93,0:06:13.95,csapp,,0,0,0,,whatever it is you asked it to do okay
Dialogue: 0,0:06:13.95,0:06:16.29,csapp,,0,0,0,,otherwise if it's not a built-in then
Dialogue: 0,0:06:16.29,0:06:18.57,csapp,,0,0,0,,that means that that you're asking the
Dialogue: 0,0:06:18.57,0:06:22.62,csapp,,0,0,0,,shell to run some program okay so in
Dialogue: 0,0:06:22.62,0:06:24.78,csapp,,0,0,0,,that case the shell will fork a child
Dialogue: 0,0:06:24.78,0:06:28.02,csapp,,0,0,0,,and then the child will execute that
Dialogue: 0,0:06:28.02,0:06:33.47,csapp,,0,0,0,,program by calling exact ve passing as
Dialogue: 0,0:06:33.47,0:06:34.95,csapp,,0,0,0,,the first argument the name of the
Dialogue: 0,0:06:34.95,0:06:37.68,csapp,,0,0,0,,command and as the second and third
Dialogue: 0,0:06:37.68,0:06:38.28,csapp,,0,0,0,,argument
Dialogue: 0,0:06:38.28,0:06:41.24,csapp,,0,0,0,,RV and and the environment respectively
Dialogue: 0,0:06:41.24,0:06:44.31,csapp,,0,0,0,,now exactly if you recall from last time
Dialogue: 0,0:06:44.31,0:06:47.37,csapp,,0,0,0,,never returns unless there's an error so
Dialogue: 0,0:06:47.37,0:06:49.91,csapp,,0,0,0,,it checks so we check it the return
Dialogue: 0,0:06:49.91,0:06:53.94,csapp,,0,0,0,,value for x ik ve and if it returns less
Dialogue: 0,0:06:53.94,0:06:56.22,csapp,,0,0,0,,than zero fact the only time it will
Dialogue: 0,0:06:56.22,0:06:58.74,csapp,,0,0,0,,return if it does return it will always
Dialogue: 0,0:06:58.74,0:07:03.15,csapp,,0,0,0,,return minus one but we're just being
Dialogue: 0,0:07:03.15,0:07:06.87,csapp,,0,0,0,,careful here so we check that for a an
Dialogue: 0,0:07:06.87,0:07:10.68,csapp,,0,0,0,,error and in in print and error message
Dialogue: 0,0:07:10.68,0:07:15.30,csapp,,0,0,0,,if we find an error and then exit so
Dialogue: 0,0:07:15.30,0:07:21.06,csapp,,0,0,0,,once the once the once the parent gets
Dialogue: 0,0:07:21.06,0:07:23.61,csapp,,0,0,0,,control again then it waits for that
Dialogue: 0,0:07:23.61,0:07:26.73,csapp,,0,0,0,,foreground job to terminate okay so if
Dialogue: 0,0:07:26.73,0:07:29.76,csapp,,0,0,0,,it's not a background job then it waits
Dialogue: 0,0:07:29.76,0:07:32.01,csapp,,0,0,0,,for it to terminate by calling wake ped
Dialogue: 0,0:07:32.01,0:07:35.76,csapp,,0,0,0,,and waiting for that child that
Dialogue: 0,0:07:35.76,0:07:37.62,csapp,,0,0,0,,foreground job to terminate and then and
Dialogue: 0,0:07:37.62,0:07:40.80,csapp,,0,0,0,,reaping it otherwise if it's a
Dialogue: 0,0:07:40.80,0:07:42.51,csapp,,0,0,0,,background job it just prints say a
Dialogue: 0,0:07:42.51,0:07:45.41,csapp,,0,0,0,,message and goes on so this is really
Dialogue: 0,0:07:45.41,0:07:47.07,csapp,,0,0,0,,interesting right that there's really
Dialogue: 0,0:07:47.07,0:07:48.69,csapp,,0,0,0,,the only difference between a foreground
Dialogue: 0,0:07:48.69,0:07:50.43,csapp,,0,0,0,,job and a background job is just that
Dialogue: 0,0:07:50.43,0:07:52.97,csapp,,0,0,0,,the shell does a weight pit on that job
Dialogue: 0,0:07:52.97,0:07:54.99,csapp,,0,0,0,,or not right so there otherwise there's
Dialogue: 0,0:07:54.99,0:08:00.02,csapp,,0,0,0,,really there's really no difference now
Dialogue: 0,0:08:00.02,0:08:02.28,csapp,,0,0,0,,what's the prob there's a problem with
Dialogue: 0,0:08:02.28,0:08:06.96,csapp,,0,0,0,,our example show and that the problem is
Dialogue: 0,0:08:06.96,0:08:08.70,csapp,,0,0,0,,that we're we're doing the right thing
Dialogue: 0,0:08:08.70,0:08:11.07,csapp,,0,0,0,,for the foreground job we always have to
Dialogue: 0,0:08:11.07,0:08:15.45,csapp,,0,0,0,,reap these children so they they so that
Dialogue: 0,0:08:15.45,0:08:19.95,csapp,,0,0,0,,they're their state can be released but
Dialogue: 0,0:08:19.95,0:08:22.26,csapp,,0,0,0,,we're not we're not doing anything to
Dialogue: 0,0:08:22.26,0:08:24.33,csapp,,0,0,0,,reap any background jobs right when if
Dialogue: 0,0:08:24.33,0:08:27.39,csapp,,0,0,0,,the background job so if not BG we're
Dialogue: 0,0:08:27.39,0:08:28.71,csapp,,0,0,0,,just printing a message and then we're
Dialogue: 0,0:08:28.71,0:08:31.26,csapp,,0,0,0,,returning and then we're continuing with
Dialogue: 0,0:08:31.26,0:08:34.50,csapp,,0,0,0,,this read evaluate step and never never
Dialogue: 0,0:08:34.50,0:08:37.11,csapp,,0,0,0,,going back and and taking care of that
Dialogue: 0,0:08:37.11,0:08:40.86,csapp,,0,0,0,,of that background job so this is a
Dialogue: 0,0:08:40.86,0:08:42.65,csapp,,0,0,0,,problem because that the background job
Dialogue: 0,0:08:42.65,0:08:46.62,csapp,,0,0,0,,will eventually become if we have enough
Dialogue: 0,0:08:46.62,0:08:48.33,csapp,,0,0,0,,of those jobs we create a memory leak
Dialogue: 0,0:08:48.33,0:08:50.01,csapp,,0,0,0,,that could crash the system right so
Dialogue: 0,0:08:50.01,0:08:51.46,csapp,,0,0,0,,this is an error
Dialogue: 0,0:08:51.46,0:08:53.54,csapp,,0,0,0,,so what are we going to do about this
Dialogue: 0,0:08:53.54,0:08:55.94,csapp,,0,0,0,,well it turns out that exceptional
Dialogue: 0,0:08:55.94,0:08:58.46,csapp,,0,0,0,,control flow will help us solve this
Dialogue: 0,0:08:58.46,0:09:03.14,csapp,,0,0,0,,problem and what happens is that the
Dialogue: 0,0:09:03.14,0:09:06.26,csapp,,0,0,0,,kernel will notify the shell when when a
Dialogue: 0,0:09:06.26,0:09:10.10,csapp,,0,0,0,,any of its children terminate okay and
Dialogue: 0,0:09:10.10,0:09:13.16,csapp,,0,0,0,,then the shell can can then react to
Dialogue: 0,0:09:13.16,0:09:16.01,csapp,,0,0,0,,that and issue a wait pit okay and this
Dialogue: 0,0:09:16.01,0:09:18.68,csapp,,0,0,0,,this notification mechanism that the the
Dialogue: 0,0:09:18.68,0:09:24.97,csapp,,0,0,0,,kernel uses is something called a signal
Dialogue: 0,0:09:24.97,0:09:30.62,csapp,,0,0,0,,so a signal is a small message that the
Dialogue: 0,0:09:30.62,0:09:33.86,csapp,,0,0,0,,kernel delivers to a process to notify
Dialogue: 0,0:09:33.86,0:09:36.26,csapp,,0,0,0,,it that there's been some event in the
Dialogue: 0,0:09:36.26,0:09:40.00,csapp,,0,0,0,,system now so this is very similar to
Dialogue: 0,0:09:40.00,0:09:43.55,csapp,,0,0,0,,the exceptions that we studied the last
Dialogue: 0,0:09:43.55,0:09:46.19,csapp,,0,0,0,,time right except it's it's it's all
Dialogue: 0,0:09:46.19,0:09:50.71,csapp,,0,0,0,,implemented in software now kernel
Dialogue: 0,0:09:50.71,0:09:53.00,csapp,,0,0,0,,signals are always sent from the kernel
Dialogue: 0,0:09:53.00,0:09:54.89,csapp,,0,0,0,,but sometimes they're sent at the
Dialogue: 0,0:09:54.89,0:09:56.93,csapp,,0,0,0,,request of another process right
Dialogue: 0,0:09:56.93,0:09:59.42,csapp,,0,0,0,,sometimes the the kernel will notice
Dialogue: 0,0:09:59.42,0:10:02.29,csapp,,0,0,0,,that there's some event other times
Dialogue: 0,0:10:02.29,0:10:05.06,csapp,,0,0,0,,another process will ask the kernel to
Dialogue: 0,0:10:05.06,0:10:08.63,csapp,,0,0,0,,send a message to some other process now
Dialogue: 0,0:10:08.63,0:10:12.01,csapp,,0,0,0,,that we say that it's a small message
Dialogue: 0,0:10:12.01,0:10:14.15,csapp,,0,0,0,,because the only information that's
Dialogue: 0,0:10:14.15,0:10:17.36,csapp,,0,0,0,,contained in a signal is its it's a
Dialogue: 0,0:10:17.36,0:10:20.60,csapp,,0,0,0,,unique integer ID and the fact that it
Dialogue: 0,0:10:20.60,0:10:23.12,csapp,,0,0,0,,was it was it was delivered okay so
Dialogue: 0,0:10:23.12,0:10:26.00,csapp,,0,0,0,,that's so there's nothing else in a
Dialogue: 0,0:10:26.00,0:10:28.07,csapp,,0,0,0,,signal except except that it arrived and
Dialogue: 0,0:10:28.07,0:10:33.14,csapp,,0,0,0,,that it has some some some unique ID now
Dialogue: 0,0:10:33.14,0:10:37.58,csapp,,0,0,0,,examples of these are the sig int so
Dialogue: 0,0:10:37.58,0:10:40.25,csapp,,0,0,0,,signals have this I this unique ID and
Dialogue: 0,0:10:40.25,0:10:46.10,csapp,,0,0,0,,then they also have a name so the sig
Dialogue: 0,0:10:46.10,0:10:49.10,csapp,,0,0,0,,antis is what the when you type control
Dialogue: 0,0:10:49.10,0:10:52.25,csapp,,0,0,0,,C at on the command line the kernel
Dialogue: 0,0:10:52.25,0:10:56.24,csapp,,0,0,0,,sends a signal to every any processes in
Dialogue: 0,0:10:56.24,0:10:58.40,csapp,,0,0,0,,the foreground and the default action of
Dialogue: 0,0:10:58.40,0:11:00.41,csapp,,0,0,0,,receiving a SIGINT is to terminate right
Dialogue: 0,0:11:00.41,0:11:01.91,csapp,,0,0,0,,so this is how if you're running a
Dialogue: 0,0:11:01.91,0:11:04.52,csapp,,0,0,0,,foreground job you hit control C
Dialogue: 0,0:11:04.52,0:11:06.50,csapp,,0,0,0,,you get the prompt back because it kills
Dialogue: 0,0:11:06.50,0:11:11.60,csapp,,0,0,0,,that job sig kill number nine can be
Dialogue: 0,0:11:11.60,0:11:15.86,csapp,,0,0,0,,used to kill terminate any program so
Dialogue: 0,0:11:15.86,0:11:18.50,csapp,,0,0,0,,these two have sig ant and sig kill have
Dialogue: 0,0:11:18.50,0:11:21.74,csapp,,0,0,0,,the same effect on the programs me that
Dialogue: 0,0:11:21.74,0:11:26.20,csapp,,0,0,0,,they kill the program the the unique
Dialogue: 0,0:11:26.20,0:11:28.61,csapp,,0,0,0,,aspect of sig kill is that there's no
Dialogue: 0,0:11:28.61,0:11:30.89,csapp,,0,0,0,,way to ignore it or override it okay so
Dialogue: 0,0:11:30.89,0:11:33.92,csapp,,0,0,0,,this is like the failsafe as we'll see
Dialogue: 0,0:11:33.92,0:11:36.74,csapp,,0,0,0,,there are there are ways to to catch and
Dialogue: 0,0:11:36.74,0:11:40.37,csapp,,0,0,0,,ignore other signals like sig int sig
Dialogue: 0,0:11:40.37,0:11:43.13,csapp,,0,0,0,,SEC v is the our favorite segment
Dialogue: 0,0:11:43.13,0:11:45.41,csapp,,0,0,0,,segmentation violation so if you if you
Dialogue: 0,0:11:45.41,0:11:47.93,csapp,,0,0,0,,access a region of memory that's
Dialogue: 0,0:11:47.93,0:11:52.85,csapp,,0,0,0,,protected or or not legal then your
Dialogue: 0,0:11:52.85,0:11:55.31,csapp,,0,0,0,,program will the kernel will send your
Dialogue: 0,0:11:55.31,0:12:00.47,csapp,,0,0,0,,that process a sig seg v okay signal and
Dialogue: 0,0:12:00.47,0:12:04.43,csapp,,0,0,0,,that the default the default effective
Dialogue: 0,0:12:04.43,0:12:07.52,csapp,,0,0,0,,that is to terminate the program sig
Dialogue: 0,0:12:07.52,0:12:09.41,csapp,,0,0,0,,alarm is a way within your program you
Dialogue: 0,0:12:09.41,0:12:11.21,csapp,,0,0,0,,can arrange for a signal to be sent to
Dialogue: 0,0:12:11.21,0:12:14.87,csapp,,0,0,0,,yourself so you can say inside your
Dialogue: 0,0:12:14.87,0:12:17.63,csapp,,0,0,0,,program send me a sig alarm signal in
Dialogue: 0,0:12:17.63,0:12:21.65,csapp,,0,0,0,,three seconds something like that so
Dialogue: 0,0:12:21.65,0:12:23.36,csapp,,0,0,0,,this is a way to do things like you can
Dialogue: 0,0:12:23.36,0:12:25.91,csapp,,0,0,0,,set up timers you can set up timeouts
Dialogue: 0,0:12:25.91,0:12:28.70,csapp,,0,0,0,,like if you want to X if you want to set
Dialogue: 0,0:12:28.70,0:12:30.32,csapp,,0,0,0,,a timeout value and you're doing some
Dialogue: 0,0:12:30.32,0:12:33.92,csapp,,0,0,0,,some some work and you want to guard
Dialogue: 0,0:12:33.92,0:12:35.45,csapp,,0,0,0,,against that that work taking
Dialogue: 0,0:12:35.45,0:12:37.28,csapp,,0,0,0,,exceptionally long time you can you can
Dialogue: 0,0:12:37.28,0:12:39.47,csapp,,0,0,0,,you can use sig alarm to set a timeout
Dialogue: 0,0:12:39.47,0:12:41.96,csapp,,0,0,0,,and then a very important one is as
Dialogue: 0,0:12:41.96,0:12:43.94,csapp,,0,0,0,,we'll see that would be very important
Dialogue: 0,0:12:43.94,0:12:46.99,csapp,,0,0,0,,for our shell is the sig child signal
Dialogue: 0,0:12:46.99,0:12:50.05,csapp,,0,0,0,,which the colonel sends to a parent
Dialogue: 0,0:12:50.05,0:12:51.98,csapp,,0,0,0,,every time one of its children
Dialogue: 0,0:12:51.98,0:12:56.81,csapp,,0,0,0,,terminates or stops okay so this as
Dialogue: 0,0:12:56.81,0:12:59.21,csapp,,0,0,0,,we'll see now we'll see this is how
Dialogue: 0,0:12:59.21,0:13:00.71,csapp,,0,0,0,,we're going this is how our shell that
Dialogue: 0,0:13:00.71,0:13:03.65,csapp,,0,0,0,,is going to actually reap it's it's all
Dialogue: 0,0:13:03.65,0:13:06.56,csapp,,0,0,0,,of its children right is by taking
Dialogue: 0,0:13:06.56,0:13:10.22,csapp,,0,0,0,,advantage of the sig child signal but
Dialogue: 0,0:13:10.22,0:13:13.25,csapp,,0,0,0,,before I can show you that we need to go
Dialogue: 0,0:13:13.25,0:13:16.88,csapp,,0,0,0,,through a number of concepts
Dialogue: 0,0:13:16.88,0:13:22.92,csapp,,0,0,0,,around signals okay like I said the the
Dialogue: 0,0:13:22.92,0:13:25.77,csapp,,0,0,0,,semantics of signals it's probably one
Dialogue: 0,0:13:25.77,0:13:29.51,csapp,,0,0,0,,of the thorniest aspects of Linux it was
Dialogue: 0,0:13:29.51,0:13:32.37,csapp,,0,0,0,,it was developed very early in the the
Dialogue: 0,0:13:32.37,0:13:37.02,csapp,,0,0,0,,lifespan of Linux when and it maybe
Dialogue: 0,0:13:37.02,0:13:40.71,csapp,,0,0,0,,wasn't as clean as it could be right so
Dialogue: 0,0:13:40.71,0:13:43.05,csapp,,0,0,0,,in order to get a handle on signals
Dialogue: 0,0:13:43.05,0:13:44.28,csapp,,0,0,0,,we're going to be very careful about
Dialogue: 0,0:13:44.28,0:13:46.71,csapp,,0,0,0,,defining terms and very careful about
Dialogue: 0,0:13:46.71,0:13:50.70,csapp,,0,0,0,,the way we talk about them so we say
Dialogue: 0,0:13:50.70,0:13:53.76,csapp,,0,0,0,,that the kernel sends or delivers a
Dialogue: 0,0:13:53.76,0:13:57.77,csapp,,0,0,0,,signal to some destination process and
Dialogue: 0,0:13:57.77,0:14:02.73,csapp,,0,0,0,,it does this by setting some state in
Dialogue: 0,0:14:02.73,0:14:04.92,csapp,,0,0,0,,the context of the destination process
Dialogue: 0,0:14:04.92,0:14:10.83,csapp,,0,0,0,,now nothing happens except that some
Dialogue: 0,0:14:10.83,0:14:12.84,csapp,,0,0,0,,bits get changed in the destination
Dialogue: 0,0:14:12.84,0:14:15.36,csapp,,0,0,0,,process context okay there's no there's
Dialogue: 0,0:14:15.36,0:14:18.48,csapp,,0,0,0,,no impact of immediate impact of sending
Dialogue: 0,0:14:18.48,0:14:25.07,csapp,,0,0,0,,a signal now a kernel sends a signal
Dialogue: 0,0:14:25.07,0:14:28.05,csapp,,0,0,0,,either because it detected some event in
Dialogue: 0,0:14:28.05,0:14:31.17,csapp,,0,0,0,,the in the system like that like a child
Dialogue: 0,0:14:31.17,0:14:34.77,csapp,,0,0,0,,process is terminated for example or
Dialogue: 0,0:14:34.77,0:14:37.41,csapp,,0,0,0,,another process has asked the kernel to
Dialogue: 0,0:14:37.41,0:14:40.83,csapp,,0,0,0,,send to deliver a process on a signal on
Dialogue: 0,0:14:40.83,0:14:44.31,csapp,,0,0,0,,its behalf and there's a number of ways
Dialogue: 0,0:14:44.31,0:14:46.23,csapp,,0,0,0,,to do that one of them is with the kill
Dialogue: 0,0:14:46.23,0:14:50.15,csapp,,0,0,0,,system call it's kind of an unfortunate
Dialogue: 0,0:14:50.15,0:14:53.61,csapp,,0,0,0,,tournament I mean the so kill is a
Dialogue: 0,0:14:53.61,0:14:57.39,csapp,,0,0,0,,general way to send signals and the the
Dialogue: 0,0:14:57.39,0:15:00.39,csapp,,0,0,0,,impact is not as is sometimes not to
Dialogue: 0,0:15:00.39,0:15:02.04,csapp,,0,0,0,,kill the program right but for some
Dialogue: 0,0:15:02.04,0:15:06.89,csapp,,0,0,0,,reason they chose to to call it kill
Dialogue: 0,0:15:06.89,0:15:11.18,csapp,,0,0,0,,now the destination process receives a
Dialogue: 0,0:15:11.18,0:15:15.10,csapp,,0,0,0,,signal when it's forced by the kernel to
Dialogue: 0,0:15:15.10,0:15:18.95,csapp,,0,0,0,,act in some way to react in some way to
Dialogue: 0,0:15:18.95,0:15:22.58,csapp,,0,0,0,,the delivery of a signal okay so these
Dialogue: 0,0:15:22.58,0:15:24.29,csapp,,0,0,0,,are two very different things sending a
Dialogue: 0,0:15:24.29,0:15:27.40,csapp,,0,0,0,,signal set state in the context of the
Dialogue: 0,0:15:27.40,0:15:30.71,csapp,,0,0,0,,destination process receiving a signal
Dialogue: 0,0:15:30.71,0:15:34.46,csapp,,0,0,0,,is what happens when the destination
Dialogue: 0,0:15:34.46,0:15:37.61,csapp,,0,0,0,,process is is finally forced by the
Dialogue: 0,0:15:37.61,0:15:40.31,csapp,,0,0,0,,kernel to act in some way to react in
Dialogue: 0,0:15:40.31,0:15:40.90,csapp,,0,0,0,,some way
Dialogue: 0,0:15:40.90,0:15:44.45,csapp,,0,0,0,,now some possible ways to react are to
Dialogue: 0,0:15:44.45,0:15:49.70,csapp,,0,0,0,,just ignore the signal okay to terminate
Dialogue: 0,0:15:49.70,0:15:54.74,csapp,,0,0,0,,the process or to catch the signal by
Dialogue: 0,0:15:54.74,0:15:57.59,csapp,,0,0,0,,executing a user level function called a
Dialogue: 0,0:15:57.59,0:15:59.78,csapp,,0,0,0,,signal handler so in this case when we
Dialogue: 0,0:15:59.78,0:16:02.45,csapp,,0,0,0,,when we catch signals it's very similar
Dialogue: 0,0:16:02.45,0:16:06.53,csapp,,0,0,0,,to the the and executes a signal handle
Dialogue: 0,0:16:06.53,0:16:08.95,csapp,,0,0,0,,it's very similar to executing a an
Dialogue: 0,0:16:08.95,0:16:12.26,csapp,,0,0,0,,exception handler in response to some
Dialogue: 0,0:16:12.26,0:16:14.39,csapp,,0,0,0,,kind of event in the system now the
Dialogue: 0,0:16:14.39,0:16:16.67,csapp,,0,0,0,,difference is that exception handlers
Dialogue: 0,0:16:16.67,0:16:18.98,csapp,,0,0,0,,are in the kernel signal handlers are
Dialogue: 0,0:16:18.98,0:16:21.14,csapp,,0,0,0,,actually just in your C code okay there
Dialogue: 0,0:16:21.14,0:16:25.31,csapp,,0,0,0,,and they execute in your in your process
Dialogue: 0,0:16:25.31,0:16:31.55,csapp,,0,0,0,,so the so the way to think about if if
Dialogue: 0,0:16:31.55,0:16:33.83,csapp,,0,0,0,,we catch a signal by executing a signal
Dialogue: 0,0:16:33.83,0:16:36.92,csapp,,0,0,0,,handler we have our process executing
Dialogue: 0,0:16:36.92,0:16:40.13,csapp,,0,0,0,,instructions and then the signal is
Dialogue: 0,0:16:40.13,0:16:43.58,csapp,,0,0,0,,received by that process so the kernel
Dialogue: 0,0:16:43.58,0:16:47.24,csapp,,0,0,0,,passes control to a signal handler which
Dialogue: 0,0:16:47.24,0:16:50.18,csapp,,0,0,0,,is also just in the code that's
Dialogue: 0,0:16:50.18,0:16:51.89,csapp,,0,0,0,,executing in the current process it's
Dialogue: 0,0:16:51.89,0:16:56.30,csapp,,0,0,0,,just a function in our in our C code the
Dialogue: 0,0:16:56.30,0:16:57.95,csapp,,0,0,0,,signal handler runs and when it returns
Dialogue: 0,0:16:57.95,0:17:00.86,csapp,,0,0,0,,it eventually returns back to the next
Dialogue: 0,0:17:00.86,0:17:03.80,csapp,,0,0,0,,instruction and then then we continue
Dialogue: 0,0:17:03.80,0:17:06.41,csapp,,0,0,0,,okay so it's it's it's just like kind of
Dialogue: 0,0:17:06.41,0:17:07.55,csapp,,0,0,0,,like an interrupt right we just
Dialogue: 0,0:17:07.55,0:17:10.40,csapp,,0,0,0,,temporarily pause what we're doing in
Dialogue: 0,0:17:10.40,0:17:13.79,csapp,,0,0,0,,the in our code to execute this this
Dialogue: 0,0:17:13.79,0:17:18.14,csapp,,0,0,0,,handler before just continuing on
Dialogue: 0,0:17:18.14,0:17:21.16,csapp,,0,0,0,,okay now we say that a signal is pending
Dialogue: 0,0:17:21.16,0:17:25.19,csapp,,0,0,0,,if it's been sent by the colonel but not
Dialogue: 0,0:17:25.19,0:17:30.87,csapp,,0,0,0,,you have received okay so if at any
Dialogue: 0,0:17:30.87,0:17:32.52,csapp,,0,0,0,,given point in time there can only be
Dialogue: 0,0:17:32.52,0:17:34.59,csapp,,0,0,0,,one pending signal of any particular
Dialogue: 0,0:17:34.59,0:17:38.07,csapp,,0,0,0,,type okay so this has very important
Dialogue: 0,0:17:38.07,0:17:40.95,csapp,,0,0,0,,consequences for using signals because
Dialogue: 0,0:17:40.95,0:17:43.59,csapp,,0,0,0,,you can't cue signals up right at any
Dialogue: 0,0:17:43.59,0:17:45.77,csapp,,0,0,0,,point in time there's there can only be
Dialogue: 0,0:17:45.77,0:17:48.24,csapp,,0,0,0,,one pending sig child signal for example
Dialogue: 0,0:17:48.24,0:17:52.88,csapp,,0,0,0,,or sig sig in signal and if a subsequent
Dialogue: 0,0:17:52.88,0:17:56.37,csapp,,0,0,0,,sig child signals say is sent it just
Dialogue: 0,0:17:56.37,0:17:59.10,csapp,,0,0,0,,over writes well you can think of it as
Dialogue: 0,0:17:59.10,0:18:00.51,csapp,,0,0,0,,it has no impact
Dialogue: 0,0:18:00.51,0:18:02.78,csapp,,0,0,0,,it's just discarded right if there's
Dialogue: 0,0:18:02.78,0:18:04.44,csapp,,0,0,0,,already a pending signal so they don't
Dialogue: 0,0:18:04.44,0:18:06.05,csapp,,0,0,0,,they don't queue up in any meaningful
Dialogue: 0,0:18:06.05,0:18:11.22,csapp,,0,0,0,,way now our process can block the
Dialogue: 0,0:18:11.22,0:18:13.98,csapp,,0,0,0,,receipt of certain signals okay now it
Dialogue: 0,0:18:13.98,0:18:16.13,csapp,,0,0,0,,can't stop signals from being delivered
Dialogue: 0,0:18:16.13,0:18:19.74,csapp,,0,0,0,,but it can stop it can stop the process
Dialogue: 0,0:18:19.74,0:18:22.32,csapp,,0,0,0,,from having to react to the route to
Dialogue: 0,0:18:22.32,0:18:27.92,csapp,,0,0,0,,that signal when it's received okay so
Dialogue: 0,0:18:27.92,0:18:30.84,csapp,,0,0,0,,block signals can be delivered but they
Dialogue: 0,0:18:30.84,0:18:33.02,csapp,,0,0,0,,won't be received until the signals
Dialogue: 0,0:18:33.02,0:18:38.33,csapp,,0,0,0,,unblocked
Dialogue: 0,0:18:38.33,0:18:40.91,csapp,,0,0,0,,and pending signals are received at most
Dialogue: 0,0:18:40.91,0:18:47.78,csapp,,0,0,0,,once now the colonel keeps track of
Dialogue: 0,0:18:47.78,0:18:51.08,csapp,,0,0,0,,these pending and blocked signals in bit
Dialogue: 0,0:18:51.08,0:18:53.96,csapp,,0,0,0,,vectors that will call pending and
Dialogue: 0,0:18:53.96,0:18:57.53,csapp,,0,0,0,,blocked and pending represents the set
Dialogue: 0,0:18:57.53,0:18:59.66,csapp,,0,0,0,,of pending signals right where each bit
Dialogue: 0,0:18:59.66,0:19:02.60,csapp,,0,0,0,,in the pending bit vector corresponds to
Dialogue: 0,0:19:02.60,0:19:05.39,csapp,,0,0,0,,some particular signal okay so this is
Dialogue: 0,0:19:05.39,0:19:07.36,csapp,,0,0,0,,why they can't be queued right because
Dialogue: 0,0:19:07.36,0:19:10.52,csapp,,0,0,0,,there's only one bit for any signal Kay
Dialogue: 0,0:19:10.52,0:19:12.08,csapp,,0,0,0,,there's only one bit in the bit vector
Dialogue: 0,0:19:12.08,0:19:14.96,csapp,,0,0,0,,and if we and when we deliver a signal
Dialogue: 0,0:19:14.96,0:19:16.76,csapp,,0,0,0,,we're just setting will set that bit the
Dialogue: 0,0:19:16.76,0:19:18.74,csapp,,0,0,0,,colonel will set that bit we deliver
Dialogue: 0,0:19:18.74,0:19:20.90,csapp,,0,0,0,,another signal of the same type it'll
Dialogue: 0,0:19:20.90,0:19:23.51,csapp,,0,0,0,,just set that bit again which has no has
Dialogue: 0,0:19:23.51,0:19:25.90,csapp,,0,0,0,,no effect
Dialogue: 0,0:19:25.90,0:19:30.26,csapp,,0,0,0,,now the colonel sets that the bit in
Dialogue: 0,0:19:30.26,0:19:32.03,csapp,,0,0,0,,pending when the signals delivered and
Dialogue: 0,0:19:32.03,0:19:34.07,csapp,,0,0,0,,it clears it when the signals received
Dialogue: 0,0:19:34.07,0:19:38.51,csapp,,0,0,0,,and the colonel also provides mechanism
Dialogue: 0,0:19:38.51,0:19:41.72,csapp,,0,0,0,,for users to block signals with this
Dialogue: 0,0:19:41.72,0:19:43.94,csapp,,0,0,0,,blocked bit vector so the block bit
Dialogue: 0,0:19:43.94,0:19:45.95,csapp,,0,0,0,,vector is the same size as the pending
Dialogue: 0,0:19:45.95,0:19:48.59,csapp,,0,0,0,,bit vector turns out it's just a 32 bit
Dialogue: 0,0:19:48.59,0:19:53.42,csapp,,0,0,0,,int okay and it can be set and cleared
Dialogue: 0,0:19:53.42,0:19:55.31,csapp,,0,0,0,,the bits and that can be set and cleared
Dialogue: 0,0:19:55.31,0:19:59.21,csapp,,0,0,0,,using the sig proc mask system call okay
Dialogue: 0,0:19:59.21,0:20:01.70,csapp,,0,0,0,,now that the blocked in the linux
Dialogue: 0,0:20:01.70,0:20:03.92,csapp,,0,0,0,,literature the blocked bit vector is
Dialogue: 0,0:20:03.92,0:20:09.46,csapp,,0,0,0,,also called the signal mask
Dialogue: 0,0:20:09.46,0:20:12.07,csapp,,0,0,0,,okay now we want to look in a little
Dialogue: 0,0:20:12.07,0:20:13.51,csapp,,0,0,0,,more detail about sending and receiving
Dialogue: 0,0:20:13.51,0:20:15.28,csapp,,0,0,0,,signals so let's start first with
Dialogue: 0,0:20:15.28,0:20:19.33,csapp,,0,0,0,,sending signals first we need to
Dialogue: 0,0:20:19.33,0:20:21.54,csapp,,0,0,0,,understand the idea of a process group
Dialogue: 0,0:20:21.54,0:20:24.94,csapp,,0,0,0,,so every process belongs to exactly one
Dialogue: 0,0:20:24.94,0:20:29.56,csapp,,0,0,0,,process group and those so here I'm
Dialogue: 0,0:20:29.56,0:20:32.08,csapp,,0,0,0,,showing a shell that's in process it has
Dialogue: 0,0:20:32.08,0:20:34.42,csapp,,0,0,0,,a process ID of 10 and a process group
Dialogue: 0,0:20:34.42,0:20:38.41,csapp,,0,0,0,,ID of 10 the shell created a foreground
Dialogue: 0,0:20:38.41,0:20:43.15,csapp,,0,0,0,,job which has a process ID of 20 and a
Dialogue: 0,0:20:43.15,0:20:45.85,csapp,,0,0,0,,process group ID of 20 and then all of
Dialogue: 0,0:20:45.85,0:20:47.91,csapp,,0,0,0,,the children that this foreground job
Dialogue: 0,0:20:47.91,0:20:51.13,csapp,,0,0,0,,created have the same process group ID
Dialogue: 0,0:20:51.13,0:20:55.42,csapp,,0,0,0,,of 20 so these these process groups can
Dialogue: 0,0:20:55.42,0:20:57.55,csapp,,0,0,0,,be set by a system call set called the
Dialogue: 0,0:20:57.55,0:21:02.44,csapp,,0,0,0,,set process group ID and you can and you
Dialogue: 0,0:21:02.44,0:21:04.72,csapp,,0,0,0,,can fetch that process group using the
Dialogue: 0,0:21:04.72,0:21:07.99,csapp,,0,0,0,,get process group system call so you can
Dialogue: 0,0:21:07.99,0:21:09.88,csapp,,0,0,0,,see in this example what what this shell
Dialogue: 0,0:21:09.88,0:21:13.90,csapp,,0,0,0,,is done is it created a foreground child
Dialogue: 0,0:21:13.90,0:21:17.26,csapp,,0,0,0,,so it created this child and it it
Dialogue: 0,0:21:17.26,0:21:20.02,csapp,,0,0,0,,changed the process group ID to be equal
Dialogue: 0,0:21:20.02,0:21:24.28,csapp,,0,0,0,,to the process ID of the child and then
Dialogue: 0,0:21:24.28,0:21:26.23,csapp,,0,0,0,,when this child created other child
Dialogue: 0,0:21:26.23,0:21:29.26,csapp,,0,0,0,,children they just inherited the same
Dialogue: 0,0:21:29.26,0:21:34.32,csapp,,0,0,0,,process group ID okay
Dialogue: 0,0:21:34.32,0:21:36.48,csapp,,0,0,0,,now this this notion of a process group
Dialogue: 0,0:21:36.48,0:21:39.90,csapp,,0,0,0,,is useful because it allows you to send
Dialogue: 0,0:21:39.90,0:21:42.57,csapp,,0,0,0,,signals to groups of processes at the
Dialogue: 0,0:21:42.57,0:21:44.82,csapp,,0,0,0,,same time and you can do that with a
Dialogue: 0,0:21:44.82,0:21:47.82,csapp,,0,0,0,,program called kill which is typically
Dialogue: 0,0:21:47.82,0:21:49.35,csapp,,0,0,0,,in /bin directory
Dialogue: 0,0:21:49.35,0:21:52.53,csapp,,0,0,0,,and that the kill program you can use
Dialogue: 0,0:21:52.53,0:21:54.78,csapp,,0,0,0,,the kill program to send an arbitrary
Dialogue: 0,0:21:54.78,0:21:56.82,csapp,,0,0,0,,signal to either an individual process
Dialogue: 0,0:21:56.82,0:22:00.09,csapp,,0,0,0,,or all the processes in one process
Dialogue: 0,0:22:00.09,0:22:05.22,csapp,,0,0,0,,group so let's look at an example this
Dialogue: 0,0:22:05.22,0:22:09.78,csapp,,0,0,0,,program this Forks program creates two
Dialogue: 0,0:22:09.78,0:22:14.88,csapp,,0,0,0,,children and with each of which has a
Dialogue: 0,0:22:14.88,0:22:19.35,csapp,,0,0,0,,process group of 24 8 1 7 and of course
Dialogue: 0,0:22:19.35,0:22:20.64,csapp,,0,0,0,,they have different process they have
Dialogue: 0,0:22:20.64,0:22:24.30,csapp,,0,0,0,,different process IDs and so if we if we
Dialogue: 0,0:22:24.30,0:22:27.60,csapp,,0,0,0,,do a PS we see these two we see these
Dialogue: 0,0:22:27.60,0:22:31.86,csapp,,0,0,0,,two processes running and these just go
Dialogue: 0,0:22:31.86,0:22:33.30,csapp,,0,0,0,,into loop so they'll just they'll just
Dialogue: 0,0:22:33.30,0:22:40.59,csapp,,0,0,0,,run continuously okay now we can we can
Dialogue: 0,0:22:40.59,0:22:42.93,csapp,,0,0,0,,use kill to to kill an individual
Dialogue: 0,0:22:42.93,0:22:46.41,csapp,,0,0,0,,process for example so if we call it the
Dialogue: 0,0:22:46.41,0:22:50.43,csapp,,0,0,0,,first argument indicates what signal you
Dialogue: 0,0:22:50.43,0:22:52.47,csapp,,0,0,0,,want to send so in this case it's its
Dialogue: 0,0:22:52.47,0:22:55.92,csapp,,0,0,0,,signal 9 which is the cig kill signal so
Dialogue: 0,0:22:55.92,0:22:59.49,csapp,,0,0,0,,kill minus 9 is is a very typical
Dialogue: 0,0:22:59.49,0:23:01.56,csapp,,0,0,0,,usually if you want to kill processes
Dialogue: 0,0:23:01.56,0:23:04.65,csapp,,0,0,0,,you just kill minus 9 and actually one
Dialogue: 0,0:23:04.65,0:23:08.52,csapp,,0,0,0,,of my favorite Auto lab nuke names for
Dialogue: 0,0:23:08.52,0:23:12.60,csapp,,0,0,0,,213 was the nickname was kill - 9 15 - 1
Dialogue: 0,0:23:12.60,0:23:17.19,csapp,,0,0,0,,3 so but then then the second argument
Dialogue: 0,0:23:17.19,0:23:23.31,csapp,,0,0,0,,is the if it's is the the process ID so
Dialogue: 0,0:23:23.31,0:23:26.31,csapp,,0,0,0,,this is asking this is asking the kernel
Dialogue: 0,0:23:26.31,0:23:30.60,csapp,,0,0,0,,to kill process ID - for a 1 8 by
Dialogue: 0,0:23:30.60,0:23:34.29,csapp,,0,0,0,,sending it a cig kill signal now if the
Dialogue: 0,0:23:34.29,0:23:37.83,csapp,,0,0,0,,if the process ID is is preceded by a
Dialogue: 0,0:23:37.83,0:23:42.51,csapp,,0,0,0,,dash then it sends a signal to every
Dialogue: 0,0:23:42.51,0:23:45.93,csapp,,0,0,0,,process in process group - then it
Dialogue: 0,0:23:45.93,0:23:48.01,csapp,,0,0,0,,treats this argument as a process
Dialogue: 0,0:23:48.01,0:23:50.92,csapp,,0,0,0,,group and it sends a signal to every
Dialogue: 0,0:23:50.92,0:23:53.23,csapp,,0,0,0,,process in that process group so in this
Dialogue: 0,0:23:53.23,0:23:56.50,csapp,,0,0,0,,case it will send a signal to both of
Dialogue: 0,0:23:56.50,0:23:58.72,csapp,,0,0,0,,these both of these children processes
Dialogue: 0,0:23:58.72,0:24:03.70,csapp,,0,0,0,,and then afterwards we if we do a PS we
Dialogue: 0,0:24:03.70,0:24:05.62,csapp,,0,0,0,,see that those processes are gone okay
Dialogue: 0,0:24:05.62,0:24:09.88,csapp,,0,0,0,,that it really did work that way now
Dialogue: 0,0:24:09.88,0:24:13.00,csapp,,0,0,0,,another way to send signals is by typing
Dialogue: 0,0:24:13.00,0:24:17.38,csapp,,0,0,0,,either control C or control Z at the to
Dialogue: 0,0:24:17.38,0:24:21.10,csapp,,0,0,0,,the command line control C causes the
Dialogue: 0,0:24:21.10,0:24:23.50,csapp,,0,0,0,,kernel to send a signal to every job in
Dialogue: 0,0:24:23.50,0:24:25.50,csapp,,0,0,0,,the the foreground process group and
Dialogue: 0,0:24:25.50,0:24:32.65,csapp,,0,0,0,,control Z causes it to send a signal to
Dialogue: 0,0:24:32.65,0:24:34.72,csapp,,0,0,0,,every job in the in the foreground
Dialogue: 0,0:24:34.72,0:24:37.39,csapp,,0,0,0,,process group the default action for
Dialogue: 0,0:24:37.39,0:24:39.46,csapp,,0,0,0,,SIGINT is to terminate the process the
Dialogue: 0,0:24:39.46,0:24:41.80,csapp,,0,0,0,,default action for the sig tea stop is
Dialogue: 0,0:24:41.80,0:24:44.80,csapp,,0,0,0,,to suspend the process stop it until it
Dialogue: 0,0:24:44.80,0:24:54.29,csapp,,0,0,0,,receives a sig cont a signal
Dialogue: 0,0:24:54.29,0:24:57.17,csapp,,0,0,0,,so you can see an example of this here
Dialogue: 0,0:24:57.17,0:25:01.61,csapp,,0,0,0,,we have a program that creates a parent
Dialogue: 0,0:25:01.61,0:25:05.70,csapp,,0,0,0,,and a child running in the foreground so
Dialogue: 0,0:25:05.70,0:25:07.27,csapp,,0,0,0,,the parents running in the foreground
Dialogue: 0,0:25:07.27,0:25:10.16,csapp,,0,0,0,,now when we type control Z to the
Dialogue: 0,0:25:10.16,0:25:14.33,csapp,,0,0,0,,command line the shell notifies us that
Dialogue: 0,0:25:14.33,0:25:17.42,csapp,,0,0,0,,it's suspended that process and if we do
Dialogue: 0,0:25:17.42,0:25:22.09,csapp,,0,0,0,,a PS we can see the parent and the child
Dialogue: 0,0:25:22.09,0:25:25.61,csapp,,0,0,0,,indeed are suspended so the PS indicates
Dialogue: 0,0:25:25.61,0:25:32.17,csapp,,0,0,0,,that it's suspended or stopped using RT
Dialogue: 0,0:25:32.17,0:25:34.85,csapp,,0,0,0,,now next we type in the built in the
Dialogue: 0,0:25:34.85,0:25:38.14,csapp,,0,0,0,,shell built in which is F G and F G
Dialogue: 0,0:25:38.14,0:25:41.75,csapp,,0,0,0,,restores those those suspended jobs to
Dialogue: 0,0:25:41.75,0:25:46.91,csapp,,0,0,0,,the foreground so after typing F G now
Dialogue: 0,0:25:46.91,0:25:49.28,csapp,,0,0,0,,we're running this our program again in
Dialogue: 0,0:25:49.28,0:25:52.32,csapp,,0,0,0,,the foreground and then we can kill it
Dialogue: 0,0:25:52.32,0:25:55.67,csapp,,0,0,0,,by typing ctrl C which which elicits a
Dialogue: 0,0:25:55.67,0:25:58.25,csapp,,0,0,0,,SIGINT whose default action is to
Dialogue: 0,0:25:58.25,0:26:00.47,csapp,,0,0,0,,terminate and then when we do a PS we
Dialogue: 0,0:26:00.47,0:26:06.32,csapp,,0,0,0,,see that indeed that's that they're gone
Dialogue: 0,0:26:06.32,0:26:08.81,csapp,,0,0,0,,now the third way that we can send
Dialogue: 0,0:26:08.81,0:26:14.53,csapp,,0,0,0,,signals is by using the kill system call
Dialogue: 0,0:26:14.53,0:26:17.48,csapp,,0,0,0,,so here's an example of how that works
Dialogue: 0,0:26:17.48,0:26:19.40,csapp,,0,0,0,,so in this in this example we're
Dialogue: 0,0:26:19.40,0:26:23.66,csapp,,0,0,0,,creating end children now each of which
Dialogue: 0,0:26:23.66,0:26:26.15,csapp,,0,0,0,,goes into an infinite loop and we're
Dialogue: 0,0:26:26.15,0:26:28.67,csapp,,0,0,0,,recording this the process ID of each
Dialogue: 0,0:26:28.67,0:26:32.78,csapp,,0,0,0,,child that we create and then in it we
Dialogue: 0,0:26:32.78,0:26:35.21,csapp,,0,0,0,,go in another loop we go through and we
Dialogue: 0,0:26:35.21,0:26:37.55,csapp,,0,0,0,,we kill each of those child processes
Dialogue: 0,0:26:37.55,0:26:41.12,csapp,,0,0,0,,with by using the kill function passing
Dialogue: 0,0:26:41.12,0:26:43.76,csapp,,0,0,0,,it the process ID and the signal that we
Dialogue: 0,0:26:43.76,0:26:48.26,csapp,,0,0,0,,want sent to that process okay and then
Dialogue: 0,0:26:48.26,0:26:51.62,csapp,,0,0,0,,we do our due diligence and reap each
Dialogue: 0,0:26:51.62,0:26:53.27,csapp,,0,0,0,,one of those children that we've
Dialogue: 0,0:26:53.27,0:26:54.64,csapp,,0,0,0,,terminated
Dialogue: 0,0:26:54.64,0:26:57.23,csapp,,0,0,0,,now this isn't strictly necessary
Dialogue: 0,0:26:57.23,0:26:59.30,csapp,,0,0,0,,because we're going to exit as soon as
Dialogue: 0,0:26:59.30,0:27:03.68,csapp,,0,0,0,,this 412 function returns we're going to
Dialogue: 0,0:27:03.68,0:27:06.58,csapp,,0,0,0,,exit the code so but we're just being
Dialogue: 0,0:27:06.58,0:27:09.86,csapp,,0,0,0,,you know careful here and maybe a little
Dialogue: 0,0:27:09.86,0:27:15.62,csapp,,0,0,0,,pedantic but
Dialogue: 0,0:27:15.62,0:27:18.11,csapp,,0,0,0,,okay now now let's look at how we
Dialogue: 0,0:27:18.11,0:27:21.70,csapp,,0,0,0,,process receive signals
Dialogue: 0,0:27:21.70,0:27:27.42,csapp,,0,0,0,,now suppose process a is running along
Dialogue: 0,0:27:27.42,0:27:31.13,csapp,,0,0,0,,executing its user code and then there's
Dialogue: 0,0:27:31.13,0:27:33.71,csapp,,0,0,0,,a control passes into the kernel because
Dialogue: 0,0:27:33.71,0:27:35.20,csapp,,0,0,0,,of some exception
Dialogue: 0,0:27:35.20,0:27:39.62,csapp,,0,0,0,,now that exception can be either a timer
Dialogue: 0,0:27:39.62,0:27:42.08,csapp,,0,0,0,,going off they've been interrupts or it
Dialogue: 0,0:27:42.08,0:27:44.95,csapp,,0,0,0,,can be a trap user calls a system call
Dialogue: 0,0:27:44.95,0:27:48.77,csapp,,0,0,0,,okay but it's always caused that the
Dialogue: 0,0:27:48.77,0:27:51.64,csapp,,0,0,0,,trap into the or the transferring
Dialogue: 0,0:27:51.64,0:27:53.09,csapp,,0,0,0,,control into the kernel is always caused
Dialogue: 0,0:27:53.09,0:27:57.02,csapp,,0,0,0,,by some exception so at this point the
Dialogue: 0,0:27:57.02,0:27:59.48,csapp,,0,0,0,,kernel calls its scheduler function and
Dialogue: 0,0:27:59.48,0:28:04.22,csapp,,0,0,0,,it decides to to do a context switch
Dialogue: 0,0:28:04.22,0:28:09.98,csapp,,0,0,0,,from process a to process B and it gets
Dialogue: 0,0:28:09.98,0:28:12.55,csapp,,0,0,0,,processed be all set up and right before
Dialogue: 0,0:28:12.55,0:28:16.70,csapp,,0,0,0,,it returns from that exception and right
Dialogue: 0,0:28:16.70,0:28:18.62,csapp,,0,0,0,,before it's ready to pass control back
Dialogue: 0,0:28:18.62,0:28:23.29,csapp,,0,0,0,,to back to process the user code and
Dialogue: 0,0:28:23.29,0:28:27.15,csapp,,0,0,0,,process B it checks for any signals that
Dialogue: 0,0:28:27.15,0:28:33.04,csapp,,0,0,0,,any pending signals okay and it does
Dialogue: 0,0:28:33.04,0:28:37.15,csapp,,0,0,0,,this by computing a bit vector PNB so
Dialogue: 0,0:28:37.15,0:28:40.34,csapp,,0,0,0,,pending non blocked which is the logical
Dialogue: 0,0:28:40.34,0:28:44.21,csapp,,0,0,0,,and of the pending bit vector and the
Dialogue: 0,0:28:44.21,0:28:47.87,csapp,,0,0,0,,inverse of the blocked bit vector okay
Dialogue: 0,0:28:47.87,0:28:50.89,csapp,,0,0,0,,so PN B is a list of all the pending
Dialogue: 0,0:28:50.89,0:28:53.53,csapp,,0,0,0,,signals that aren't blocked okay so
Dialogue: 0,0:28:53.53,0:28:55.15,csapp,,0,0,0,,these are all the pending signals that
Dialogue: 0,0:28:55.15,0:29:00.71,csapp,,0,0,0,,should be received if now if pn b is all
Dialogue: 0,0:29:00.71,0:29:03.08,csapp,,0,0,0,,zeros then there's no pending signals so
Dialogue: 0,0:29:03.08,0:29:05.86,csapp,,0,0,0,,it just returns it passes control back
Dialogue: 0,0:29:05.86,0:29:09.32,csapp,,0,0,0,,it passes control back to process b
Dialogue: 0,0:29:09.32,0:29:12.16,csapp,,0,0,0,,which can continue executing however if
Dialogue: 0,0:29:12.16,0:29:15.77,csapp,,0,0,0,,if P and B is nonzero then it chooses
Dialogue: 0,0:29:15.77,0:29:20.00,csapp,,0,0,0,,the smallest nonzero bit in PN B and it
Dialogue: 0,0:29:20.00,0:29:23.05,csapp,,0,0,0,,forces process P to receive that signal
Dialogue: 0,0:29:23.05,0:29:26.82,csapp,,0,0,0,,the corresponding signal
Dialogue: 0,0:29:26.82,0:29:29.44,csapp,,0,0,0,,the receipt of the signal triggers some
Dialogue: 0,0:29:29.44,0:29:36.61,csapp,,0,0,0,,action in in the process and then we
Dialogue: 0,0:29:36.61,0:29:39.64,csapp,,0,0,0,,repeat that for all the nonzero signals
Dialogue: 0,0:29:39.64,0:29:43.45,csapp,,0,0,0,,K that are nonzero bits that are set in
Dialogue: 0,0:29:43.45,0:29:46.06,csapp,,0,0,0,,PN B and finally when we've gone all
Dialogue: 0,0:29:46.06,0:29:48.76,csapp,,0,0,0,,through all the non zero bits then we
Dialogue: 0,0:29:48.76,0:29:52.47,csapp,,0,0,0,,pass control to the next instruction in
Dialogue: 0,0:29:52.47,0:30:01.48,csapp,,0,0,0,,in the in in process P so the receipt of
Dialogue: 0,0:30:01.48,0:30:03.70,csapp,,0,0,0,,a signal always triggers some action
Dialogue: 0,0:30:03.70,0:30:06.93,csapp,,0,0,0,,which is either the process terminates
Dialogue: 0,0:30:06.93,0:30:10.03,csapp,,0,0,0,,the process stops until it's restarted
Dialogue: 0,0:30:10.03,0:30:13.09,csapp,,0,0,0,,by a sick can't signal the process
Dialogue: 0,0:30:13.09,0:30:16.21,csapp,,0,0,0,,ignores the signal ok so that's there's
Dialogue: 0,0:30:16.21,0:30:20.79,csapp,,0,0,0,,always some predefined default action
Dialogue: 0,0:30:20.79,0:30:24.49,csapp,,0,0,0,,but we can modify that that default
Dialogue: 0,0:30:24.49,0:30:28.93,csapp,,0,0,0,,action by using a function system call
Dialogue: 0,0:30:28.93,0:30:33.46,csapp,,0,0,0,,called signal ok so we can now signals a
Dialogue: 0,0:30:33.46,0:30:34.99,csapp,,0,0,0,,little that's another sort of misleading
Dialogue: 0,0:30:34.99,0:30:36.73,csapp,,0,0,0,,kind of term just like kill right
Dialogue: 0,0:30:36.73,0:30:38.62,csapp,,0,0,0,,because when we when we send a signal to
Dialogue: 0,0:30:38.62,0:30:40.30,csapp,,0,0,0,,a process we don't always want to kill
Dialogue: 0,0:30:40.30,0:30:43.42,csapp,,0,0,0,,it and signal doesn't actually signal
Dialogue: 0,0:30:43.42,0:30:46.06,csapp,,0,0,0,,anything it just it just modifies the
Dialogue: 0,0:30:46.06,0:30:48.67,csapp,,0,0,0,,default action associated with some
Dialogue: 0,0:30:48.67,0:30:51.85,csapp,,0,0,0,,signal okay so if the signal function
Dialogue: 0,0:30:51.85,0:30:57.81,csapp,,0,0,0,,takes out a signal number and and then
Dialogue: 0,0:30:57.81,0:31:00.88,csapp,,0,0,0,,specifies a change in the default action
Dialogue: 0,0:31:00.88,0:31:04.81,csapp,,0,0,0,,for that signal and those default
Dialogue: 0,0:31:04.81,0:31:07.00,csapp,,0,0,0,,actions can be either to ignore the
Dialogue: 0,0:31:07.00,0:31:11.94,csapp,,0,0,0,,signal ok ignore signals of type signal
Dialogue: 0,0:31:11.94,0:31:14.38,csapp,,0,0,0,,revert to the default behavior for that
Dialogue: 0,0:31:14.38,0:31:19.42,csapp,,0,0,0,,signal or we can we can give it or it
Dialogue: 0,0:31:19.42,0:31:21.07,csapp,,0,0,0,,can be the address of a user level
Dialogue: 0,0:31:21.07,0:31:24.31,csapp,,0,0,0,,signal handler which is a function that
Dialogue: 0,0:31:24.31,0:31:27.19,csapp,,0,0,0,,we've declared in our C program ok it's
Dialogue: 0,0:31:27.19,0:31:29.41,csapp,,0,0,0,,there's nothing special about the
Dialogue: 0,0:31:29.41,0:31:31.18,csapp,,0,0,0,,function it has a certain prototype that
Dialogue: 0,0:31:31.18,0:31:34.24,csapp,,0,0,0,,has it takes a single argument which is
Dialogue: 0,0:31:34.24,0:31:36.01,csapp,,0,0,0,,the signal number so when that function
Dialogue: 0,0:31:36.01,0:31:39.52,csapp,,0,0,0,,gets called in in response to receiving
Dialogue: 0,0:31:39.52,0:31:42.40,csapp,,0,0,0,,a signal that argument will be set to
Dialogue: 0,0:31:42.40,0:31:50.59,csapp,,0,0,0,,the signal number so calling signal with
Dialogue: 0,0:31:50.59,0:31:52.90,csapp,,0,0,0,,a and specifying a signal handler is
Dialogue: 0,0:31:52.90,0:31:55.90,csapp,,0,0,0,,called installing a handler and then
Dialogue: 0,0:31:55.90,0:31:57.85,csapp,,0,0,0,,executing the handlers referred to as
Dialogue: 0,0:31:57.85,0:32:00.91,csapp,,0,0,0,,catching or executing they were handling
Dialogue: 0,0:32:00.91,0:32:04.72,csapp,,0,0,0,,the signal and and this this handler
Dialogue: 0,0:32:04.72,0:32:06.55,csapp,,0,0,0,,then is just like an exception handler
Dialogue: 0,0:32:06.55,0:32:09.97,csapp,,0,0,0,,when it when it returns it will be when
Dialogue: 0,0:32:09.97,0:32:12.39,csapp,,0,0,0,,it's executed it will interrupt the
Dialogue: 0,0:32:12.39,0:32:14.89,csapp,,0,0,0,,whatever is currently executing in the
Dialogue: 0,0:32:14.89,0:32:17.44,csapp,,0,0,0,,process when it returns it will return
Dialogue: 0,0:32:17.44,0:32:18.88,csapp,,0,0,0,,back to that point and continue
Dialogue: 0,0:32:18.88,0:32:23.86,csapp,,0,0,0,,executing okay so here's a simple
Dialogue: 0,0:32:23.86,0:32:28.75,csapp,,0,0,0,,example of of installing a handler so
Dialogue: 0,0:32:28.75,0:32:30.58,csapp,,0,0,0,,here in Maine where we're going to
Dialogue: 0,0:32:30.58,0:32:35.32,csapp,,0,0,0,,install a sig int handler which is
Dialogue: 0,0:32:35.32,0:32:37.63,csapp,,0,0,0,,called sig int underscore handler which
Dialogue: 0,0:32:37.63,0:32:41.29,csapp,,0,0,0,,is defined up here and the prototype for
Dialogue: 0,0:32:41.29,0:32:44.23,csapp,,0,0,0,,this function is returns nothing and it
Dialogue: 0,0:32:44.23,0:32:46.36,csapp,,0,0,0,,takes a single integer argument which is
Dialogue: 0,0:32:46.36,0:32:48.96,csapp,,0,0,0,,the signal number and returns nothing
Dialogue: 0,0:32:48.96,0:32:52.27,csapp,,0,0,0,,okay and after we install that handler
Dialogue: 0,0:32:52.27,0:32:55.60,csapp,,0,0,0,,then we're going to execute the pause
Dialogue: 0,0:32:55.60,0:32:58.21,csapp,,0,0,0,,this call which just waits for a signal
Dialogue: 0,0:32:58.21,0:33:00.01,csapp,,0,0,0,,handler to execute ok so pause
Dialogue: 0,0:33:00.01,0:33:02.32,csapp,,0,0,0,,terminates the current or suspends the
Dialogue: 0,0:33:02.32,0:33:05.32,csapp,,0,0,0,,current process until a signal is
Dialogue: 0,0:33:05.32,0:33:07.84,csapp,,0,0,0,,received and a handler executes in that
Dialogue: 0,0:33:07.84,0:33:10.06,csapp,,0,0,0,,process and then pause then pause
Dialogue: 0,0:33:10.06,0:33:14.53,csapp,,0,0,0,,returns so we're going to wait until the
Dialogue: 0,0:33:14.53,0:33:18.13,csapp,,0,0,0,,SIGINT happens so sig entry call is when
Dialogue: 0,0:33:18.13,0:33:22.66,csapp,,0,0,0,,we type ctrl C so when you're doing your
Dialogue: 0,0:33:22.66,0:33:24.82,csapp,,0,0,0,,bombs did did you panic at some point
Dialogue: 0,0:33:24.82,0:33:27.45,csapp,,0,0,0,,and try to hit ctrl C to get out of it
Dialogue: 0,0:33:27.45,0:33:30.19,csapp,,0,0,0,,okay so that snarky message you got that
Dialogue: 0,0:33:30.19,0:33:34.42,csapp,,0,0,0,,was we did that by installing a signal
Dialogue: 0,0:33:34.42,0:33:37.86,csapp,,0,0,0,,hello SIGINT handler in in in your bomb
Dialogue: 0,0:33:37.86,0:33:40.30,csapp,,0,0,0,,okay so when when you type control C
Dialogue: 0,0:33:40.30,0:33:44.32,csapp,,0,0,0,,that elicits a a SIGINT when that SIGINT
Dialogue: 0,0:33:44.32,0:33:48.52,csapp,,0,0,0,,is received we printed this message and
Dialogue: 0,0:33:48.52,0:33:56.01,csapp,,0,0,0,,then eventually let you exit
Dialogue: 0,0:33:56.01,0:33:59.74,csapp,,0,0,0,,now signaler signals are another
Dialogue: 0,0:33:59.74,0:34:02.72,csapp,,0,0,0,,examples of concurrency now we've seen
Dialogue: 0,0:34:02.72,0:34:06.13,csapp,,0,0,0,,concurrency earlier in the form of
Dialogue: 0,0:34:06.13,0:34:11.10,csapp,,0,0,0,,processes right concurrent flows
Dialogue: 0,0:34:11.10,0:34:14.96,csapp,,0,0,0,,overlapping in time okay logical flows
Dialogue: 0,0:34:14.96,0:34:18.22,csapp,,0,0,0,,overlapping in time by definition are
Dialogue: 0,0:34:18.22,0:34:24.34,csapp,,0,0,0,,concurrent now with with processes the
Dialogue: 0,0:34:24.34,0:34:25.97,csapp,,0,0,0,,because they have separate address
Dialogue: 0,0:34:25.97,0:34:28.25,csapp,,0,0,0,,spaces those concurrent flows never
Dialogue: 0,0:34:28.25,0:34:30.04,csapp,,0,0,0,,interfere with each other right so in
Dialogue: 0,0:34:30.04,0:34:32.99,csapp,,0,0,0,,some sense processes are very easy to
Dialogue: 0,0:34:32.99,0:34:35.14,csapp,,0,0,0,,deal with and we don't really have to
Dialogue: 0,0:34:35.14,0:34:35.58,csapp,,0,0,0,,worry
Dialogue: 0,0:34:35.58,0:34:38.00,csapp,,0,0,0,,one process doesn't have to worry about
Dialogue: 0,0:34:38.00,0:34:41.58,csapp,,0,0,0,,being interfered with by another process
Dialogue: 0,0:34:41.58,0:34:44.05,csapp,,0,0,0,,in fact you have to go to great lengths
Dialogue: 0,0:34:44.05,0:34:46.63,csapp,,0,0,0,,to share like to share things between
Dialogue: 0,0:34:46.63,0:34:49.66,csapp,,0,0,0,,processes you have to use specific
Dialogue: 0,0:34:49.66,0:34:51.71,csapp,,0,0,0,,system calls in order to say share
Dialogue: 0,0:34:51.71,0:34:56.17,csapp,,0,0,0,,memory between two processes now signals
Dialogue: 0,0:34:56.17,0:34:58.36,csapp,,0,0,0,,are another form of concurrency this is
Dialogue: 0,0:34:58.36,0:35:01.52,csapp,,0,0,0,,the second time in this class that that
Dialogue: 0,0:35:01.52,0:35:04.49,csapp,,0,0,0,,you've experienced concurrency and so a
Dialogue: 0,0:35:04.49,0:35:06.34,csapp,,0,0,0,,signal is just a concurrent flow it's
Dialogue: 0,0:35:06.34,0:35:09.50,csapp,,0,0,0,,just a logical flow a sit so a handler
Dialogue: 0,0:35:09.50,0:35:12.23,csapp,,0,0,0,,is just another logical flow that runs
Dialogue: 0,0:35:12.23,0:35:15.29,csapp,,0,0,0,,concurrently with your program right so
Dialogue: 0,0:35:15.29,0:35:17.75,csapp,,0,0,0,,we're let's say we're executing a while
Dialogue: 0,0:35:17.75,0:35:21.50,csapp,,0,0,0,,loop in process a okay that while loop
Dialogue: 0,0:35:21.50,0:35:24.31,csapp,,0,0,0,,is is executing and in process a
Dialogue: 0,0:35:24.31,0:35:27.14,csapp,,0,0,0,,receives the signal which causes a
Dialogue: 0,0:35:27.14,0:35:31.97,csapp,,0,0,0,,transfer of control to this handler this
Dialogue: 0,0:35:31.97,0:35:34.79,csapp,,0,0,0,,handler executes so this is a concurrent
Dialogue: 0,0:35:34.79,0:35:37.94,csapp,,0,0,0,,flow that overlaps in time with the
Dialogue: 0,0:35:37.94,0:35:40.54,csapp,,0,0,0,,while loop in process a eventually this
Dialogue: 0,0:35:40.54,0:35:45.58,csapp,,0,0,0,,handler returns and we return for the
Dialogue: 0,0:35:45.58,0:35:51.77,csapp,,0,0,0,,back tip to back to process a now one of
Dialogue: 0,0:35:51.77,0:35:55.04,csapp,,0,0,0,,the reasons signals are so tricky is
Dialogue: 0,0:35:55.04,0:35:56.86,csapp,,0,0,0,,because of this this overlapping
Dialogue: 0,0:35:56.86,0:36:00.07,csapp,,0,0,0,,concurrent flow this
Dialogue: 0,0:36:00.07,0:36:02.18,csapp,,0,0,0,,this concurrency because the signal
Dialogue: 0,0:36:02.18,0:36:05.29,csapp,,0,0,0,,handler runs in the same process as the
Dialogue: 0,0:36:05.29,0:36:08.11,csapp,,0,0,0,,main program so it shares all the global
Dialogue: 0,0:36:08.11,0:36:12.36,csapp,,0,0,0,,variables of that program okay so you're
Dialogue: 0,0:36:12.36,0:36:15.14,csapp,,0,0,0,,that signal handler is a function that
Dialogue: 0,0:36:15.14,0:36:17.18,csapp,,0,0,0,,you've declared and it has access to all
Dialogue: 0,0:36:17.18,0:36:20.90,csapp,,0,0,0,,all the state all the global state in
Dialogue: 0,0:36:20.90,0:36:24.25,csapp,,0,0,0,,the program okay and the existence of
Dialogue: 0,0:36:24.25,0:36:26.93,csapp,,0,0,0,,the shared global state can create real
Dialogue: 0,0:36:26.93,0:36:37.04,csapp,,0,0,0,,problems
Dialogue: 0,0:36:37.04,0:36:39.26,csapp,,0,0,0,,and we'll get into more details about
Dialogue: 0,0:36:39.26,0:36:42.74,csapp,,0,0,0,,some of those problems so another way to
Dialogue: 0,0:36:42.74,0:36:45.16,csapp,,0,0,0,,look at these signal handlers disking as
Dialogue: 0,0:36:45.16,0:36:48.35,csapp,,0,0,0,,concurrent flows is using this this
Dialogue: 0,0:36:48.35,0:36:51.68,csapp,,0,0,0,,context switch diagram so suppose we're
Dialogue: 0,0:36:51.68,0:36:55.22,csapp,,0,0,0,,executing in process a and now at some
Dialogue: 0,0:36:55.22,0:37:00.85,csapp,,0,0,0,,point a signal is delivered to process a
Dialogue: 0,0:37:00.85,0:37:04.31,csapp,,0,0,0,,now nothing happens right just just the
Dialogue: 0,0:37:04.31,0:37:06.26,csapp,,0,0,0,,pending bit gets set in process a at
Dialogue: 0,0:37:06.26,0:37:10.15,csapp,,0,0,0,,this point now at some point there's a
Dialogue: 0,0:37:10.15,0:37:12.85,csapp,,0,0,0,,transfer of control into the kernel and
Dialogue: 0,0:37:12.85,0:37:15.92,csapp,,0,0,0,,the kernel decides to do a context
Dialogue: 0,0:37:15.92,0:37:19.28,csapp,,0,0,0,,switch from A to B and now B gets to run
Dialogue: 0,0:37:19.28,0:37:21.23,csapp,,0,0,0,,for a while there's another transfer of
Dialogue: 0,0:37:21.23,0:37:24.68,csapp,,0,0,0,,control to the kernel and the kernel
Dialogue: 0,0:37:24.68,0:37:28.88,csapp,,0,0,0,,decides to schedule process a and now
Dialogue: 0,0:37:28.88,0:37:31.94,csapp,,0,0,0,,right before it returns control to
Dialogue: 0,0:37:31.94,0:37:34.73,csapp,,0,0,0,,process a it notices that the the
Dialogue: 0,0:37:34.73,0:37:37.97,csapp,,0,0,0,,pending bit for this signal is set so it
Dialogue: 0,0:37:37.97,0:37:40.13,csapp,,0,0,0,,causes process a to receive that signal
Dialogue: 0,0:37:40.13,0:37:43.82,csapp,,0,0,0,,so that executes the handler code when
Dialogue: 0,0:37:43.82,0:37:46.70,csapp,,0,0,0,,the handler returns it returns for brief
Dialogue: 0,0:37:46.70,0:37:48.35,csapp,,0,0,0,,briefly to the kernel which then
Dialogue: 0,0:37:48.35,0:37:51.02,csapp,,0,0,0,,transfers control back to the the next
Dialogue: 0,0:37:51.02,0:37:53.15,csapp,,0,0,0,,instruction that the process was going
Dialogue: 0,0:37:53.15,0:37:58.49,csapp,,0,0,0,,to execute now handlers are also tricky
Dialogue: 0,0:37:58.49,0:37:59.96,csapp,,0,0,0,,because they can be interrupted by other
Dialogue: 0,0:37:59.96,0:38:02.96,csapp,,0,0,0,,handlers so suppose we have our main
Dialogue: 0,0:38:02.96,0:38:08.15,csapp,,0,0,0,,program that catches a signal S which
Dialogue: 0,0:38:08.15,0:38:10.34,csapp,,0,0,0,,causes a transfer of control to handle
Dialogue: 0,0:38:10.34,0:38:13.19,csapp,,0,0,0,,or s and then we'll handle RS did you
Dialogue: 0,0:38:13.19,0:38:13.81,csapp,,0,0,0,,have a question
Dialogue: 0,0:38:13.81,0:38:22.06,csapp,,0,0,0,,okay well handle RS is is is executing
Dialogue: 0,0:38:22.06,0:38:30.86,csapp,,0,0,0,,the the program catches a signal T which
Dialogue: 0,0:38:30.86,0:38:33.56,csapp,,0,0,0,,causes a transfer of control to the
Dialogue: 0,0:38:33.56,0:38:36.86,csapp,,0,0,0,,handler first for T and when then when
Dialogue: 0,0:38:36.86,0:38:38.78,csapp,,0,0,0,,at handler returns it returns to the
Dialogue: 0,0:38:38.78,0:38:43.46,csapp,,0,0,0,,point to the to the to the instruction
Dialogue: 0,0:38:43.46,0:38:45.08,csapp,,0,0,0,,and handle or else that was where it was
Dialogue: 0,0:38:45.08,0:38:47.45,csapp,,0,0,0,,interrupted and then handle or us
Dialogue: 0,0:38:47.45,0:38:50.39,csapp,,0,0,0,,continues its execution and eventually a
Dialogue: 0,0:38:50.39,0:38:50.99,csapp,,0,0,0,,return
Dialogue: 0,0:38:50.99,0:38:53.00,csapp,,0,0,0,,back to the the point in the main
Dialogue: 0,0:38:53.00,0:38:59.95,csapp,,0,0,0,,program where it was interrupted now
Dialogue: 0,0:38:59.95,0:39:02.61,csapp,,0,0,0,,signals that the colonel always blocks
Dialogue: 0,0:39:02.61,0:39:05.03,csapp,,0,0,0,,pending signals of the type currently
Dialogue: 0,0:39:05.03,0:39:08.63,csapp,,0,0,0,,being handled right so a handler for a
Dialogue: 0,0:39:08.63,0:39:13.67,csapp,,0,0,0,,signal of type T can't be interrupted by
Dialogue: 0,0:39:13.67,0:39:15.44,csapp,,0,0,0,,the receipt of another signal of that
Dialogue: 0,0:39:15.44,0:39:18.26,csapp,,0,0,0,,same type okay can be as I showed in the
Dialogue: 0,0:39:18.26,0:39:19.88,csapp,,0,0,0,,previous slide it can be interrupted by
Dialogue: 0,0:39:19.88,0:39:21.95,csapp,,0,0,0,,a signal of another type but not by a
Dialogue: 0,0:39:21.95,0:39:24.23,csapp,,0,0,0,,signal of the same type so that's sort
Dialogue: 0,0:39:24.23,0:39:29.69,csapp,,0,0,0,,of an implicit form of of blocking but
Dialogue: 0,0:39:29.69,0:39:32.24,csapp,,0,0,0,,there's the kernel also provides a
Dialogue: 0,0:39:32.24,0:39:33.71,csapp,,0,0,0,,system call that allows you to
Dialogue: 0,0:39:33.71,0:39:37.58,csapp,,0,0,0,,explicitly block and unblock signals in
Dialogue: 0,0:39:37.58,0:39:40.01,csapp,,0,0,0,,the form of the sig proc mask function
Dialogue: 0,0:39:40.01,0:39:44.27,csapp,,0,0,0,,and then there's associated so this
Dialogue: 0,0:39:44.27,0:39:47.47,csapp,,0,0,0,,allows you to block and unblock a set of
Dialogue: 0,0:39:47.47,0:39:50.96,csapp,,0,0,0,,signals and then there some support
Dialogue: 0,0:39:50.96,0:39:53.69,csapp,,0,0,0,,functions that allow you to create those
Dialogue: 0,0:39:53.69,0:39:57.80,csapp,,0,0,0,,sets so just think of these as bit
Dialogue: 0,0:39:57.80,0:40:01.03,csapp,,0,0,0,,vectors and these functions will set in
Dialogue: 0,0:40:01.03,0:40:04.60,csapp,,0,0,0,,set and reset the bits and those those
Dialogue: 0,0:40:04.60,0:40:08.38,csapp,,0,0,0,,bit vectors so let's see how we can use
Dialogue: 0,0:40:08.38,0:40:11.86,csapp,,0,0,0,,sig proc masks to temporarily block and
Dialogue: 0,0:40:11.86,0:40:13.84,csapp,,0,0,0,,unblock a signal so this is going to
Dialogue: 0,0:40:13.84,0:40:15.10,csapp,,0,0,0,,this is going to turn out to be very
Dialogue: 0,0:40:15.10,0:40:17.54,csapp,,0,0,0,,important for you when you working on
Dialogue: 0,0:40:17.54,0:40:20.21,csapp,,0,0,0,,your shells that which is your next your
Dialogue: 0,0:40:20.21,0:40:25.36,csapp,,0,0,0,,next lab assignment okay
Dialogue: 0,0:40:25.36,0:40:28.09,csapp,,0,0,0,,so what we do we'll use cig empty set to
Dialogue: 0,0:40:28.09,0:40:30.17,csapp,,0,0,0,,create an empty mask so this is a mask
Dialogue: 0,0:40:30.17,0:40:32.74,csapp,,0,0,0,,with all zeros okay with with no
Dialogue: 0,0:40:32.74,0:40:35.21,csapp,,0,0,0,,elements in the set and then we're going
Dialogue: 0,0:40:35.21,0:40:37.71,csapp,,0,0,0,,to add a single element to this set
Dialogue: 0,0:40:37.71,0:40:43.46,csapp,,0,0,0,,which is sig int and now we temp we have
Dialogue: 0,0:40:43.46,0:40:44.96,csapp,,0,0,0,,some code that we don't want to be
Dialogue: 0,0:40:44.96,0:40:48.85,csapp,,0,0,0,,interrupted by the seed of sig end okay
Dialogue: 0,0:40:48.85,0:40:51.41,csapp,,0,0,0,,so we want to temporarily block the
Dialogue: 0,0:40:51.41,0:40:54.79,csapp,,0,0,0,,receipt of sig n signals and we do it by
Dialogue: 0,0:40:54.79,0:40:58.51,csapp,,0,0,0,,calling sig proc mask with the command
Dialogue: 0,0:40:58.51,0:41:01.99,csapp,,0,0,0,,say I want to block I want to block the
Dialogue: 0,0:41:01.99,0:41:05.86,csapp,,0,0,0,,signals that are spent that that are in
Dialogue: 0,0:41:05.86,0:41:12.71,csapp,,0,0,0,,the set specified by mask and I'll
Dialogue: 0,0:41:12.71,0:41:15.61,csapp,,0,0,0,,assign the so this will become my new
Dialogue: 0,0:41:15.61,0:41:18.46,csapp,,0,0,0,,mask so this this becomes the new
Dialogue: 0,0:41:18.46,0:41:21.76,csapp,,0,0,0,,blocked bit vector okay or the not the
Dialogue: 0,0:41:21.76,0:41:25.19,csapp,,0,0,0,,this the new signal mask and it makes a
Dialogue: 0,0:41:25.19,0:41:28.35,csapp,,0,0,0,,copy of the old one and stores it at at
Dialogue: 0,0:41:28.35,0:41:30.73,csapp,,0,0,0,,the address specified in the third
Dialogue: 0,0:41:30.73,0:41:34.00,csapp,,0,0,0,,argument so at this point after we
Dialogue: 0,0:41:34.00,0:41:36.61,csapp,,0,0,0,,returned from sig proc mask sig n
Dialogue: 0,0:41:36.61,0:41:38.02,csapp,,0,0,0,,signals are blocked and they won't be
Dialogue: 0,0:41:38.02,0:41:43.27,csapp,,0,0,0,,received and then we so we can execute
Dialogue: 0,0:41:43.27,0:41:44.77,csapp,,0,0,0,,this code knowing that we won't be
Dialogue: 0,0:41:44.77,0:41:48.95,csapp,,0,0,0,,interrupted by receipt of a sig int and
Dialogue: 0,0:41:48.95,0:41:51.44,csapp,,0,0,0,,then we can restore the previous block
Dialogue: 0,0:41:51.44,0:41:56.66,csapp,,0,0,0,,set by using the cig set mask in stopper
Dialogue: 0,0:41:56.66,0:41:59.50,csapp,,0,0,0,,ation and passing in the previous mask
Dialogue: 0,0:41:59.50,0:42:01.72,csapp,,0,0,0,,that we that we saved up here when we
Dialogue: 0,0:42:01.72,0:42:09.49,csapp,,0,0,0,,when we initially blocks again
Dialogue: 0,0:42:09.49,0:42:13.18,csapp,,0,0,0,,okay so signals and signal handling is a
Dialogue: 0,0:42:13.18,0:42:16.00,csapp,,0,0,0,,really tricky business and there's sort
Dialogue: 0,0:42:16.00,0:42:19.21,csapp,,0,0,0,,of three things that make them so tricky
Dialogue: 0,0:42:19.21,0:42:23.65,csapp,,0,0,0,,and kind of nasty really one is that you
Dialogue: 0,0:42:23.65,0:42:25.00,csapp,,0,0,0,,have to be very careful to write
Dialogue: 0,0:42:25.00,0:42:26.80,csapp,,0,0,0,,handlers that are safe
Dialogue: 0,0:42:26.80,0:42:29.50,csapp,,0,0,0,,okay so there's you can write signal
Dialogue: 0,0:42:29.50,0:42:31.35,csapp,,0,0,0,,handlers that are unsafe in the sense
Dialogue: 0,0:42:31.35,0:42:33.36,csapp,,0,0,0,,that they'll create a deadlock in your
Dialogue: 0,0:42:33.36,0:42:38.08,csapp,,0,0,0,,program okay or you can or you can write
Dialogue: 0,0:42:38.08,0:42:39.79,csapp,,0,0,0,,signal handlers that will that will
Dialogue: 0,0:42:39.79,0:42:42.67,csapp,,0,0,0,,corrupt a global data structure that's
Dialogue: 0,0:42:42.67,0:42:46.39,csapp,,0,0,0,,being modified by the main program so I
Dialogue: 0,0:42:46.39,0:42:48.64,csapp,,0,0,0,,mean imagine imagine your main
Dialogue: 0,0:42:48.64,0:42:52.72,csapp,,0,0,0,,programming is updating some some data
Dialogue: 0,0:42:52.72,0:42:55.18,csapp,,0,0,0,,structure like a linked list and right
Dialogue: 0,0:42:55.18,0:42:56.85,csapp,,0,0,0,,in the middle of updating that data
Dialogue: 0,0:42:56.85,0:42:58.83,csapp,,0,0,0,,structure when it's when it's no longer
Dialogue: 0,0:42:58.83,0:43:02.71,csapp,,0,0,0,,consistent the program gets interrupted
Dialogue: 0,0:43:02.71,0:43:05.56,csapp,,0,0,0,,by the receipt of a signal and if that
Dialogue: 0,0:43:05.56,0:43:08.23,csapp,,0,0,0,,signal handler is updating that same
Dialogue: 0,0:43:08.23,0:43:10.45,csapp,,0,0,0,,data structure reading that structure or
Dialogue: 0,0:43:10.45,0:43:13.11,csapp,,0,0,0,,modifying it then it's going to
Dialogue: 0,0:43:13.11,0:43:14.85,csapp,,0,0,0,,encounter it in an inconsistent state
Dialogue: 0,0:43:14.85,0:43:19.99,csapp,,0,0,0,,and and and you're in trouble okay so
Dialogue: 0,0:43:19.99,0:43:24.70,csapp,,0,0,0,,this the fact that it's the fact that
Dialogue: 0,0:43:24.70,0:43:26.68,csapp,,0,0,0,,it's it's it's it's easy to write signal
Dialogue: 0,0:43:26.68,0:43:29.34,csapp,,0,0,0,,handlers that are that are unsafe is is
Dialogue: 0,0:43:29.34,0:43:31.39,csapp,,0,0,0,,is one aspect of that makes them tough
Dialogue: 0,0:43:31.39,0:43:33.97,csapp,,0,0,0,,to deal with another aspect is they have
Dialogue: 0,0:43:33.97,0:43:36.55,csapp,,0,0,0,,this funny semantics that signals aren't
Dialogue: 0,0:43:36.55,0:43:39.31,csapp,,0,0,0,,cued and so if you're not if you're not
Dialogue: 0,0:43:39.31,0:43:42.00,csapp,,0,0,0,,really careful about this it's very easy
Dialogue: 0,0:43:42.00,0:43:45.09,csapp,,0,0,0,,to use the receipt of signals to count
Dialogue: 0,0:43:45.09,0:43:47.77,csapp,,0,0,0,,events and you can't do that
Dialogue: 0,0:43:47.77,0:43:50.26,csapp,,0,0,0,,if signals were cued you could use you
Dialogue: 0,0:43:50.26,0:43:51.76,csapp,,0,0,0,,could use the receipt of a signal to
Dialogue: 0,0:43:51.76,0:43:53.50,csapp,,0,0,0,,count events in the system but you can't
Dialogue: 0,0:43:53.50,0:43:55.96,csapp,,0,0,0,,do it because their signals aren't cued
Dialogue: 0,0:43:55.96,0:43:59.10,csapp,,0,0,0,,and then a third a third aspect of
Dialogue: 0,0:43:59.10,0:44:00.78,csapp,,0,0,0,,signals which makes them tough is that
Dialogue: 0,0:44:00.78,0:44:02.92,csapp,,0,0,0,,they're not even they're not even
Dialogue: 0,0:44:02.92,0:44:04.75,csapp,,0,0,0,,portable across different versions of
Dialogue: 0,0:44:04.75,0:44:09.61,csapp,,0,0,0,,Linux okay so if you use
Dialogue: 0,0:44:09.61,0:44:12.14,csapp,,0,0,0,,solaris or some form of bsd it's not
Dialogue: 0,0:44:12.14,0:44:14.24,csapp,,0,0,0,,necessarily the single handling
Dialogue: 0,0:44:14.24,0:44:16.01,csapp,,0,0,0,,semantics aren't necessarily the same as
Dialogue: 0,0:44:16.01,0:44:17.02,csapp,,0,0,0,,they are in Linux
Dialogue: 0,0:44:17.02,0:44:19.58,csapp,,0,0,0,,okay so we'll we'll look at all three of
Dialogue: 0,0:44:19.58,0:44:21.56,csapp,,0,0,0,,these in a little more detail and first
Dialogue: 0,0:44:21.56,0:44:26.02,csapp,,0,0,0,,we'll start with writing safe handlers
Dialogue: 0,0:44:26.02,0:44:29.33,csapp,,0,0,0,,so let me give you some guidelines for
Dialogue: 0,0:44:29.33,0:44:33.95,csapp,,0,0,0,,how to write safe handlers and this is
Dialogue: 0,0:44:33.95,0:44:37.16,csapp,,0,0,0,,just a collection of fun this is just a
Dialogue: 0,0:44:37.16,0:44:39.85,csapp,,0,0,0,,collection of sort of collected wisdom
Dialogue: 0,0:44:39.85,0:44:46.36,csapp,,0,0,0,,from from various sources but it covers
Dialogue: 0,0:44:46.36,0:44:49.34,csapp,,0,0,0,,a lot of aspects of signal handlers so
Dialogue: 0,0:44:49.34,0:44:51.05,csapp,,0,0,0,,the first guideline is to keep your
Dialogue: 0,0:44:51.05,0:44:52.76,csapp,,0,0,0,,handlers as simple as possible for
Dialogue: 0,0:44:52.76,0:44:55.46,csapp,,0,0,0,,example the simplest possible handle I
Dialogue: 0,0:44:55.46,0:44:56.99,csapp,,0,0,0,,can think of just sets a global variable
Dialogue: 0,0:44:56.99,0:45:02.80,csapp,,0,0,0,,and then it returns okay and in fact
Dialogue: 0,0:45:02.80,0:45:08.27,csapp,,0,0,0,,cert the CMU cert provides guidelines
Dialogue: 0,0:45:08.27,0:45:12.29,csapp,,0,0,0,,for sort of compliant programs and this
Dialogue: 0,0:45:12.29,0:45:14.93,csapp,,0,0,0,,is the only signal handler that they
Dialogue: 0,0:45:14.93,0:45:17.42,csapp,,0,0,0,,allow this is the only compliant signal
Dialogue: 0,0:45:17.42,0:45:19.49,csapp,,0,0,0,,handler one that just sets a global
Dialogue: 0,0:45:19.49,0:45:25.72,csapp,,0,0,0,,variable and then returns okay
Dialogue: 0,0:45:25.72,0:45:28.60,csapp,,0,0,0,,guideline number one call only functions
Dialogue: 0,0:45:28.60,0:45:30.89,csapp,,0,0,0,,in your handlers that are that have this
Dialogue: 0,0:45:30.89,0:45:34.46,csapp,,0,0,0,,property of async signals safety okay
Dialogue: 0,0:45:34.46,0:45:37.40,csapp,,0,0,0,,and we'll look at this in a second but I
Dialogue: 0,0:45:37.40,0:45:39.98,csapp,,0,0,0,,want to point out that printf s printf
Dialogue: 0,0:45:39.98,0:45:43.01,csapp,,0,0,0,,Malak exit functions that are very
Dialogue: 0,0:45:43.01,0:45:45.47,csapp,,0,0,0,,common and commonly used are not safe
Dialogue: 0,0:45:45.47,0:45:49.04,csapp,,0,0,0,,okay
Dialogue: 0,0:45:49.04,0:45:52.04,csapp,,0,0,0,,guideline number two is to always save
Dialogue: 0,0:45:52.04,0:45:54.80,csapp,,0,0,0,,and restore error no on entry and exit
Dialogue: 0,0:45:54.80,0:45:57.89,csapp,,0,0,0,,so you know error no is a global global
Dialogue: 0,0:45:57.89,0:45:59.15,csapp,,0,0,0,,variable that's set when there's
Dialogue: 0,0:45:59.15,0:46:00.26,csapp,,0,0,0,,whenever there's an error in a
Dialogue: 0,0:46:00.26,0:46:03.34,csapp,,0,0,0,,system-level function so you need to
Dialogue: 0,0:46:03.34,0:46:05.51,csapp,,0,0,0,,save and you need to save and restore it
Dialogue: 0,0:46:05.51,0:46:08.18,csapp,,0,0,0,,on entry and exit so that it doesn't get
Dialogue: 0,0:46:08.18,0:46:09.80,csapp,,0,0,0,,overwritten if you're interrupted by
Dialogue: 0,0:46:09.80,0:46:12.52,csapp,,0,0,0,,another handler
Dialogue: 0,0:46:12.52,0:46:15.11,csapp,,0,0,0,,[Music]
Dialogue: 0,0:46:15.11,0:46:17.67,csapp,,0,0,0,,okay if you're accessing any shared data
Dialogue: 0,0:46:17.67,0:46:21.00,csapp,,0,0,0,,structures inside a signal handler that
Dialogue: 0,0:46:21.00,0:46:25.02,csapp,,0,0,0,,are also accessed by your main routine
Dialogue: 0,0:46:25.02,0:46:26.88,csapp,,0,0,0,,then you need to temporarily block
Dialogue: 0,0:46:26.88,0:46:28.59,csapp,,0,0,0,,signals while you access that data
Dialogue: 0,0:46:28.59,0:46:31.11,csapp,,0,0,0,,structure both in the main routine and
Dialogue: 0,0:46:31.11,0:46:33.42,csapp,,0,0,0,,your signal handler right and the reason
Dialogue: 0,0:46:33.42,0:46:35.43,csapp,,0,0,0,,for this is what I described earlier if
Dialogue: 0,0:46:35.43,0:46:37.56,csapp,,0,0,0,,your main routine is updating that
Dialogue: 0,0:46:37.56,0:46:39.09,csapp,,0,0,0,,global data structure and then it gets
Dialogue: 0,0:46:39.09,0:46:41.37,csapp,,0,0,0,,interrupted and the signal handler is
Dialogue: 0,0:46:41.37,0:46:42.81,csapp,,0,0,0,,reading that data structure it's going
Dialogue: 0,0:46:42.81,0:46:44.46,csapp,,0,0,0,,to find it in an inconsistent state and
Dialogue: 0,0:46:44.46,0:46:51.36,csapp,,0,0,0,,bad things will happen okay you want to
Dialogue: 0,0:46:51.36,0:46:53.31,csapp,,0,0,0,,be sure to declare your any global
Dialogue: 0,0:46:53.31,0:46:55.23,csapp,,0,0,0,,variables that are shared between signal
Dialogue: 0,0:46:55.23,0:46:57.06,csapp,,0,0,0,,handlers and the main routine as
Dialogue: 0,0:46:57.06,0:46:59.64,csapp,,0,0,0,,volatile okay the volatile attribute
Dialogue: 0,0:46:59.64,0:47:02.22,csapp,,0,0,0,,will prevent the compiler from putting
Dialogue: 0,0:47:02.22,0:47:07.92,csapp,,0,0,0,,that that value in a register so if you
Dialogue: 0,0:47:07.92,0:47:11.04,csapp,,0,0,0,,declare a global variable as volatile it
Dialogue: 0,0:47:11.04,0:47:13.11,csapp,,0,0,0,,will always be reads and writes will
Dialogue: 0,0:47:13.11,0:47:16.08,csapp,,0,0,0,,always go to and from memory okay so
Dialogue: 0,0:47:16.08,0:47:18.95,csapp,,0,0,0,,this is very important right you might
Dialogue: 0,0:47:18.95,0:47:21.57,csapp,,0,0,0,,if you don't declare these global
Dialogue: 0,0:47:21.57,0:47:23.46,csapp,,0,0,0,,variables at volatile and the compiler
Dialogue: 0,0:47:23.46,0:47:26.28,csapp,,0,0,0,,chooses to put to put one of those in a
Dialogue: 0,0:47:26.28,0:47:31.32,csapp,,0,0,0,,in a register then you may miss that
Dialogue: 0,0:47:31.32,0:47:33.60,csapp,,0,0,0,,variable being updated so suppose
Dialogue: 0,0:47:33.60,0:47:36.69,csapp,,0,0,0,,suppose your signal handlers is setting
Dialogue: 0,0:47:36.69,0:47:40.14,csapp,,0,0,0,,a global variable and now suppose your
Dialogue: 0,0:47:40.14,0:47:43.05,csapp,,0,0,0,,main routine is spinning waiting for
Dialogue: 0,0:47:43.05,0:47:46.71,csapp,,0,0,0,,that global variable to get set well if
Dialogue: 0,0:47:46.71,0:47:48.81,csapp,,0,0,0,,it's in a register the write to that
Dialogue: 0,0:47:48.81,0:47:51.45,csapp,,0,0,0,,variable will just update the register
Dialogue: 0,0:47:51.45,0:47:54.75,csapp,,0,0,0,,right and so your main routine is in
Dialogue: 0,0:47:54.75,0:47:56.76,csapp,,0,0,0,,danger of just of spinning forever not
Dialogue: 0,0:47:56.76,0:48:00.72,csapp,,0,0,0,,not seeing the change right okay so
Dialogue: 0,0:48:00.72,0:48:03.45,csapp,,0,0,0,,always use volatility so that they're
Dialogue: 0,0:48:03.45,0:48:06.75,csapp,,0,0,0,,not stored in registers and then if you
Dialogue: 0,0:48:06.75,0:48:09.27,csapp,,0,0,0,,have fun if you have a special kind of
Dialogue: 0,0:48:09.27,0:48:12.30,csapp,,0,0,0,,global called a flag which by definition
Dialogue: 0,0:48:12.30,0:48:14.81,csapp,,0,0,0,,is a variable it's only read or written
Dialogue: 0,0:48:14.81,0:48:17.91,csapp,,0,0,0,,not incremented or updated it's just
Dialogue: 0,0:48:17.91,0:48:21.72,csapp,,0,0,0,,read or written if you have if you have
Dialogue: 0,0:48:21.72,0:48:23.49,csapp,,0,0,0,,a variable with that property then you
Dialogue: 0,0:48:23.49,0:48:26.70,csapp,,0,0,0,,can declare it with this SIG atomic tea
Dialogue: 0,0:48:26.70,0:48:30.78,csapp,,0,0,0,,tribute and if you do that then the
Dialogue: 0,0:48:30.78,0:48:32.67,csapp,,0,0,0,,system guarantees that reads and writes
Dialogue: 0,0:48:32.67,0:48:34.82,csapp,,0,0,0,,to that variable will be atomic so you
Dialogue: 0,0:48:34.82,0:48:36.75,csapp,,0,0,0,,don't have to in other words you don't
Dialogue: 0,0:48:36.75,0:48:39.03,csapp,,0,0,0,,have to protect accesses to the shared
Dialogue: 0,0:48:39.03,0:48:42.10,csapp,,0,0,0,,two accesses or references to those
Dialogue: 0,0:48:42.10,0:48:46.32,csapp,,0,0,0,,global variables okay and so by this by
Dialogue: 0,0:48:46.32,0:48:48.57,csapp,,0,0,0,,atomic which means that the the read or
Dialogue: 0,0:48:48.57,0:48:51.03,csapp,,0,0,0,,write of that flag will always happen in
Dialogue: 0,0:48:51.03,0:48:55.36,csapp,,0,0,0,,one uninterruptible step okay one
Dialogue: 0,0:48:55.36,0:48:59.27,csapp,,0,0,0,,uninterruptible load or store particular
Dialogue: 0,0:48:59.27,0:49:02.82,csapp,,0,0,0,,now in practice on most systems this SIG
Dialogue: 0,0:49:02.82,0:49:07.44,csapp,,0,0,0,,atomic T is an int kids so you can you
Dialogue: 0,0:49:07.44,0:49:09.54,csapp,,0,0,0,,can read or write an int with one one
Dialogue: 0,0:49:09.54,0:49:12.75,csapp,,0,0,0,,instruction okay so it's it's atomic but
Dialogue: 0,0:49:12.75,0:49:14.22,csapp,,0,0,0,,if you want to be portable you declare
Dialogue: 0,0:49:14.22,0:49:16.77,csapp,,0,0,0,,it with sig atomic T and then it'll
Dialogue: 0,0:49:16.77,0:49:20.49,csapp,,0,0,0,,it'll work on none it will work on all
Dialogue: 0,0:49:20.49,0:49:26.01,csapp,,0,0,0,,systems okay we mentioned this property
Dialogue: 0,0:49:26.01,0:49:29.36,csapp,,0,0,0,,of a sync signal safety now a function
Dialogue: 0,0:49:29.36,0:49:32.19,csapp,,0,0,0,,is is safe to be used inside of a signal
Dialogue: 0,0:49:32.19,0:49:36.72,csapp,,0,0,0,,handler if it's either reentrant okay or
Dialogue: 0,0:49:36.72,0:49:38.31,csapp,,0,0,0,,if it can't be interrupted by signals
Dialogue: 0,0:49:38.31,0:49:41.09,csapp,,0,0,0,,and will a reentrant function as we'll
Dialogue: 0,0:49:41.09,0:49:43.61,csapp,,0,0,0,,see when we study threads is a function
Dialogue: 0,0:49:43.61,0:49:46.17,csapp,,0,0,0,,where all of its all of the data that it
Dialogue: 0,0:49:46.17,0:49:51.03,csapp,,0,0,0,,accesses is on its own stack okay so no
Dialogue: 0,0:49:51.03,0:49:53.19,csapp,,0,0,0,,global variables no pointers to global
Dialogue: 0,0:49:53.19,0:49:54.75,csapp,,0,0,0,,variables everything's stored on the
Dialogue: 0,0:49:54.75,0:49:58.74,csapp,,0,0,0,,stack locally okay so that means you can
Dialogue: 0,0:49:58.74,0:50:00.96,csapp,,0,0,0,,be it's called reentrant because you can
Dialogue: 0,0:50:00.96,0:50:02.81,csapp,,0,0,0,,write have multiple instances of that
Dialogue: 0,0:50:02.81,0:50:04.26,csapp,,0,0,0,,function and they all have their own
Dialogue: 0,0:50:04.26,0:50:07.31,csapp,,0,0,0,,separate copies of all of the variables
Dialogue: 0,0:50:07.31,0:50:11.25,csapp,,0,0,0,,that they're they're using now the POSIX
Dialogue: 0,0:50:11.25,0:50:14.49,csapp,,0,0,0,,standard guarantees 117 different
Dialogue: 0,0:50:14.49,0:50:18.95,csapp,,0,0,0,,functions to be a sync signal saved
Dialogue: 0,0:50:18.95,0:50:22.61,csapp,,0,0,0,,these include underscore exit right wait
Dialogue: 0,0:50:22.61,0:50:26.33,csapp,,0,0,0,,wait kids sleep kill but unfortunately
Dialogue: 0,0:50:26.33,0:50:28.17,csapp,,0,0,0,,there's some very popular functions that
Dialogue: 0,0:50:28.17,0:50:30.81,csapp,,0,0,0,,aren't on this list printf s printf
Dialogue: 0,0:50:30.81,0:50:32.79,csapp,,0,0,0,,things that you really want to use and
Dialogue: 0,0:50:32.79,0:50:35.64,csapp,,0,0,0,,in fact Wright is the only output
Dialogue: 0,0:50:35.64,0:50:40.16,csapp,,0,0,0,,function that's a sync signal safe
Dialogue: 0,0:50:40.16,0:50:43.45,csapp,,0,0,0,,so this is kind of a problem because
Dialogue: 0,0:50:43.45,0:50:47.03,csapp,,0,0,0,,especially when you know you something
Dialogue: 0,0:50:47.03,0:50:48.56,csapp,,0,0,0,,you'd often like your signal handlers to
Dialogue: 0,0:50:48.56,0:50:52.61,csapp,,0,0,0,,output information but you can't if you
Dialogue: 0,0:50:52.61,0:50:54.32,csapp,,0,0,0,,want to really be pedantic and careful
Dialogue: 0,0:50:54.32,0:50:57.59,csapp,,0,0,0,,you can't use printf in fact it's
Dialogue: 0,0:50:57.59,0:51:01.04,csapp,,0,0,0,,possible to write a program and I'll try
Dialogue: 0,0:51:01.04,0:51:03.50,csapp,,0,0,0,,to I'll try to it's possible to write a
Dialogue: 0,0:51:03.50,0:51:07.22,csapp,,0,0,0,,program that does a tight loop of
Dialogue: 0,0:51:07.22,0:51:11.51,csapp,,0,0,0,,printouts in the main routine and then a
Dialogue: 0,0:51:11.51,0:51:14.78,csapp,,0,0,0,,steady stream of interrupts which
Dialogue: 0,0:51:14.78,0:51:17.36,csapp,,0,0,0,,execute a handler which also does a
Dialogue: 0,0:51:17.36,0:51:22.00,csapp,,0,0,0,,printf okay now
Dialogue: 0,0:51:22.00,0:51:26.99,csapp,,0,0,0,,the printf call has to acquire what's
Dialogue: 0,0:51:26.99,0:51:29.60,csapp,,0,0,0,,called a lock on the terminal okay each
Dialogue: 0,0:51:29.60,0:51:32.80,csapp,,0,0,0,,printf inside that that library function
Dialogue: 0,0:51:32.80,0:51:36.23,csapp,,0,0,0,,it acquires a lock which means only one
Dialogue: 0,0:51:36.23,0:51:38.57,csapp,,0,0,0,,instance of printf can write to the
Dialogue: 0,0:51:38.57,0:51:41.33,csapp,,0,0,0,,terminal at a point in time if another
Dialogue: 0,0:51:41.33,0:51:43.34,csapp,,0,0,0,,if another function tries to acquire
Dialogue: 0,0:51:43.34,0:51:47.30,csapp,,0,0,0,,that lock it has to wait until whatever
Dialogue: 0,0:51:47.30,0:51:50.93,csapp,,0,0,0,,function owns the lock releases it okay
Dialogue: 0,0:51:50.93,0:51:53.80,csapp,,0,0,0,,so a lock prevents a lock is a way for
Dialogue: 0,0:51:53.80,0:51:57.02,csapp,,0,0,0,,to get mutually exclusive access to two
Dialogue: 0,0:51:57.02,0:52:00.39,csapp,,0,0,0,,shared resources so if we have a tight
Dialogue: 0,0:52:00.39,0:52:04.34,csapp,,0,0,0,,loop in our main routine with executing
Dialogue: 0,0:52:04.34,0:52:07.85,csapp,,0,0,0,,printf imagine what happens if one of
Dialogue: 0,0:52:07.85,0:52:09.77,csapp,,0,0,0,,those printouts acquires a lock on the
Dialogue: 0,0:52:09.77,0:52:14.15,csapp,,0,0,0,,terminal and then gets interrupted not
Dialogue: 0,0:52:14.15,0:52:17.21,csapp,,0,0,0,,by the receipt of a signal now within
Dialogue: 0,0:52:17.21,0:52:19.94,csapp,,0,0,0,,the signal handler it calls another
Dialogue: 0,0:52:19.94,0:52:23.72,csapp,,0,0,0,,printf and that printf tries to acquire
Dialogue: 0,0:52:23.72,0:52:27.39,csapp,,0,0,0,,that lock and it blocks forever because
Dialogue: 0,0:52:27.39,0:52:28.76,csapp,,0,0,0,,nothing's going to release that lock
Dialogue: 0,0:52:28.76,0:52:30.98,csapp,,0,0,0,,because the the main routine was
Dialogue: 0,0:52:30.98,0:52:35.66,csapp,,0,0,0,,interrupted by the handler so you have
Dialogue: 0,0:52:35.66,0:52:38.74,csapp,,0,0,0,,what's called a classical a classical
Dialogue: 0,0:52:38.74,0:52:41.48,csapp,,0,0,0,,condition called deadlock which is we
Dialogue: 0,0:52:41.48,0:52:43.25,csapp,,0,0,0,,have a process waiting for an event that
Dialogue: 0,0:52:43.25,0:52:45.74,csapp,,0,0,0,,will never occur in this case the the
Dialogue: 0,0:52:45.74,0:52:47.40,csapp,,0,0,0,,printf and the signal handler is waiting
Dialogue: 0,0:52:47.40,0:52:49.70,csapp,,0,0,0,,for a lock to be released that will
Dialogue: 0,0:52:49.70,0:52:50.76,csapp,,0,0,0,,never be released
Dialogue: 0,0:52:50.76,0:52:55.59,csapp,,0,0,0,,so it's interesting you can try this
Dialogue: 0,0:52:55.59,0:52:59.25,csapp,,0,0,0,,it's it's it's not too hard to to create
Dialogue: 0,0:52:59.25,0:53:03.54,csapp,,0,0,0,,this deadlock situation so to deal with
Dialogue: 0,0:53:03.54,0:53:05.46,csapp,,0,0,0,,this I really didn't want to tell you
Dialogue: 0,0:53:05.46,0:53:06.78,csapp,,0,0,0,,guys that you couldn't have any output
Dialogue: 0,0:53:06.78,0:53:08.58,csapp,,0,0,0,,in your programs and writes a very
Dialogue: 0,0:53:08.58,0:53:12.30,csapp,,0,0,0,,difficult thing to deal with so so I
Dialogue: 0,0:53:12.30,0:53:15.45,csapp,,0,0,0,,created a small little library called
Dialogue: 0,0:53:15.45,0:53:19.85,csapp,,0,0,0,,the safe i/o library consists of three
Dialogue: 0,0:53:19.85,0:53:22.83,csapp,,0,0,0,,routines and they're available to you in
Dialogue: 0,0:53:22.83,0:53:26.49,csapp,,0,0,0,,the CSAP PC file which is distributed on
Dialogue: 0,0:53:26.49,0:53:30.24,csapp,,0,0,0,,the website and it consists of three
Dialogue: 0,0:53:30.24,0:53:35.06,csapp,,0,0,0,,reentrant routines sio put us
Dialogue: 0,0:53:35.06,0:53:40.85,csapp,,0,0,0,,prince/princess string put L prints
Dialogue: 0,0:53:40.85,0:53:47.46,csapp,,0,0,0,,along and SiO error prints a message and
Dialogue: 0,0:53:47.46,0:53:51.66,csapp,,0,0,0,,then exits okay so you can safely use
Dialogue: 0,0:53:51.66,0:53:53.76,csapp,,0,0,0,,take my word for it you can safely use
Dialogue: 0,0:53:53.76,0:53:56.58,csapp,,0,0,0,,this in your in your signal handlers so
Dialogue: 0,0:53:56.58,0:53:59.60,csapp,,0,0,0,,if we were going to rewrite our SIGINT
Dialogue: 0,0:53:59.60,0:54:03.11,csapp,,0,0,0,,handler from the from the binary bomb we
Dialogue: 0,0:54:03.11,0:54:04.56,csapp,,0,0,0,,could rewrite it like this and now we
Dialogue: 0,0:54:04.56,0:54:07.95,csapp,,0,0,0,,have every function is is a sync signal
Dialogue: 0,0:54:07.95,0:54:12.48,csapp,,0,0,0,,safe all right now signals are also
Dialogue: 0,0:54:12.48,0:54:14.73,csapp,,0,0,0,,tucked because of this this funky non
Dialogue: 0,0:54:14.73,0:54:20.46,csapp,,0,0,0,,cueing semantics of and so it's really
Dialogue: 0,0:54:20.46,0:54:24.60,csapp,,0,0,0,,easy to make mistakes when you have an
Dialogue: 0,0:54:24.60,0:54:28.05,csapp,,0,0,0,,implicit assumption that the that the
Dialogue: 0,0:54:28.05,0:54:30.09,csapp,,0,0,0,,receipt of a signal it can be used to
Dialogue: 0,0:54:30.09,0:54:34.89,csapp,,0,0,0,,count the occurrence of an event so
Dialogue: 0,0:54:34.89,0:54:37.08,csapp,,0,0,0,,let's look at this let's look at this
Dialogue: 0,0:54:37.08,0:54:42.27,csapp,,0,0,0,,example program we install a sick child
Dialogue: 0,0:54:42.27,0:54:45.21,csapp,,0,0,0,,handler okay and this is actually this
Dialogue: 0,0:54:45.21,0:54:47.46,csapp,,0,0,0,,this sort of close the loop member we
Dialogue: 0,0:54:47.46,0:54:49.38,csapp,,0,0,0,,talked about our example shell
Dialogue: 0,0:54:49.38,0:54:51.30,csapp,,0,0,0,,we're wondering how are we going to reap
Dialogue: 0,0:54:51.30,0:54:54.00,csapp,,0,0,0,,those those background children well we
Dialogue: 0,0:54:54.00,0:54:56.01,csapp,,0,0,0,,do it by installing a sick child handle
Dialogue: 0,0:54:56.01,0:54:58.53,csapp,,0,0,0,,like we're doing in this example so this
Dialogue: 0,0:54:58.53,0:55:01.50,csapp,,0,0,0,,here we have a program that installs
Dialogue: 0,0:55:01.50,0:55:03.78,csapp,,0,0,0,,this sick child handler
Dialogue: 0,0:55:03.78,0:55:08.04,csapp,,0,0,0,,and then it creates n different child
Dialogue: 0,0:55:08.04,0:55:11.13,csapp,,0,0,0,,processes where each child sleeps for a
Dialogue: 0,0:55:11.13,0:55:18.00,csapp,,0,0,0,,little bit and exits and then it spins
Dialogue: 0,0:55:18.00,0:55:23.00,csapp,,0,0,0,,until the C count variable becomes zero
Dialogue: 0,0:55:23.00,0:55:25.32,csapp,,0,0,0,,that the parent I'm sorry the parent
Dialogue: 0,0:55:25.32,0:55:28.65,csapp,,0,0,0,,spins until the C count variable becomes
Dialogue: 0,0:55:28.65,0:55:35.76,csapp,,0,0,0,,zero now in the in our child handler we
Dialogue: 0,0:55:35.76,0:55:38.10,csapp,,0,0,0,,we have a global that's that's
Dialogue: 0,0:55:38.10,0:55:39.39,csapp,,0,0,0,,initialized to zero
Dialogue: 0,0:55:39.39,0:55:45.06,csapp,,0,0,0,,see count and then we wait we're going
Dialogue: 0,0:55:45.06,0:55:46.80,csapp,,0,0,0,,to wait so this child when the child
Dialogue: 0,0:55:46.80,0:55:48.96,csapp,,0,0,0,,handler gets called that means it's
Dialogue: 0,0:55:48.96,0:55:50.61,csapp,,0,0,0,,called because we received a sick child
Dialogue: 0,0:55:50.61,0:55:54.42,csapp,,0,0,0,,signal okay so in our in our handler
Dialogue: 0,0:55:54.42,0:55:57.75,csapp,,0,0,0,,we're going to reap that child by
Dialogue: 0,0:55:57.75,0:56:00.81,csapp,,0,0,0,,calling weight and we're going to Dec
Dialogue: 0,0:56:00.81,0:56:05.37,csapp,,0,0,0,,and then will decrement C count okay so
Dialogue: 0,0:56:05.37,0:56:07.95,csapp,,0,0,0,,once all of the children if then have
Dialogue: 0,0:56:07.95,0:56:10.56,csapp,,0,0,0,,been reaped C count will be zero and
Dialogue: 0,0:56:10.56,0:56:13.56,csapp,,0,0,0,,then the parent can exit this this while
Dialogue: 0,0:56:13.56,0:56:16.50,csapp,,0,0,0,,loop okay now in this particular example
Dialogue: 0,0:56:16.50,0:56:23.88,csapp,,0,0,0,,N was 5 but will you run this code we
Dialogue: 0,0:56:23.88,0:56:26.22,csapp,,0,0,0,,only the handle or only gets called
Dialogue: 0,0:56:26.22,0:56:31.68,csapp,,0,0,0,,twice okay so the the message handler
Dialogue: 0,0:56:31.68,0:56:35.13,csapp,,0,0,0,,Reap child only gets executed twice
Dialogue: 0,0:56:35.13,0:56:37.02,csapp,,0,0,0,,right which means the handler was only
Dialogue: 0,0:56:37.02,0:56:41.13,csapp,,0,0,0,,called twice we created five children we
Dialogue: 0,0:56:41.13,0:56:44.01,csapp,,0,0,0,,terminated five children but we only
Dialogue: 0,0:56:44.01,0:56:48.57,csapp,,0,0,0,,reaped - okay so that the problem is
Dialogue: 0,0:56:48.57,0:56:51.18,csapp,,0,0,0,,that when we the problem is that we
Dialogue: 0,0:56:51.18,0:56:57.03,csapp,,0,0,0,,assumed that the receipt that the that
Dialogue: 0,0:56:57.03,0:56:58.89,csapp,,0,0,0,,the execution of the child handled our
Dialogue: 0,0:56:58.89,0:57:01.86,csapp,,0,0,0,,correspondent to the single receipt of a
Dialogue: 0,0:57:01.86,0:57:05.34,csapp,,0,0,0,,single sick child signal okay when when
Dialogue: 0,0:57:05.34,0:57:08.49,csapp,,0,0,0,,in reality these signals aren't cued
Dialogue: 0,0:57:08.49,0:57:13.32,csapp,,0,0,0,,right we had in reality multiple sick
Dialogue: 0,0:57:13.32,0:57:15.21,csapp,,0,0,0,,child signals were delivered to that
Dialogue: 0,0:57:15.21,0:57:17.43,csapp,,0,0,0,,child which kept overriding that
Dialogue: 0,0:57:17.43,0:57:21.27,csapp,,0,0,0,,at bid in the pending bit vector and the
Dialogue: 0,0:57:21.27,0:57:23.73,csapp,,0,0,0,,delivery of those signals didn't didn't
Dialogue: 0,0:57:23.73,0:57:26.04,csapp,,0,0,0,,have didn't cause any reaction in the
Dialogue: 0,0:57:26.04,0:57:28.14,csapp,,0,0,0,,process until that process was was just
Dialogue: 0,0:57:28.14,0:57:30.90,csapp,,0,0,0,,about ready to be rescheduled and only
Dialogue: 0,0:57:30.90,0:57:33.02,csapp,,0,0,0,,then was where was a signal received
Dialogue: 0,0:57:33.02,0:57:35.88,csapp,,0,0,0,,but even though like say three signals
Dialogue: 0,0:57:35.88,0:57:37.74,csapp,,0,0,0,,were delivered only one was received
Dialogue: 0,0:57:37.74,0:57:42.54,csapp,,0,0,0,,okay so you can't use events in this
Dialogue: 0,0:57:42.54,0:57:44.97,csapp,,0,0,0,,case we're using event we're using
Dialogue: 0,0:57:44.97,0:57:48.00,csapp,,0,0,0,,signals to count events which in this
Dialogue: 0,0:57:48.00,0:57:51.30,csapp,,0,0,0,,case is the termination of a child okay
Dialogue: 0,0:57:51.30,0:57:55.34,csapp,,0,0,0,,so the receipt of a signal in this case
Dialogue: 0,0:57:55.34,0:57:58.92,csapp,,0,0,0,,it only indicates that at least one
Dialogue: 0,0:57:58.92,0:58:03.27,csapp,,0,0,0,,child terminated right not not one child
Dialogue: 0,0:58:03.27,0:58:06.69,csapp,,0,0,0,,terminated all we can infer from the
Dialogue: 0,0:58:06.69,0:58:08.25,csapp,,0,0,0,,receipt of that signal is that at least
Dialogue: 0,0:58:08.25,0:58:12.59,csapp,,0,0,0,,one child has terminated okay so to fix
Dialogue: 0,0:58:12.59,0:58:18.86,csapp,,0,0,0,,that when we receive a sick child we
Dialogue: 0,0:58:18.86,0:58:20.43,csapp,,0,0,0,,have to put we have to put the weight
Dialogue: 0,0:58:20.43,0:58:24.66,csapp,,0,0,0,,that's reaping on our children we have
Dialogue: 0,0:58:24.66,0:58:27.56,csapp,,0,0,0,,to put that in this in a loop so we have
Dialogue: 0,0:58:27.56,0:58:29.01,csapp,,0,0,0,,to assume that the receipt of a sick
Dialogue: 0,0:58:29.01,0:58:31.14,csapp,,0,0,0,,child if we get a sick child there could
Dialogue: 0,0:58:31.14,0:58:35.43,csapp,,0,0,0,,be multiple terminated children that we
Dialogue: 0,0:58:35.43,0:58:39.03,csapp,,0,0,0,,have to that we have to reap and so we
Dialogue: 0,0:58:39.03,0:58:41.67,csapp,,0,0,0,,put we put that in this loop and we
Dialogue: 0,0:58:41.67,0:58:43.79,csapp,,0,0,0,,execute this loop until there's no more
Dialogue: 0,0:58:43.79,0:58:46.55,csapp,,0,0,0,,terminated children in which case wait
Dialogue: 0,0:58:46.55,0:58:50.36,csapp,,0,0,0,,will will will exit with an error code
Dialogue: 0,0:58:50.36,0:58:53.13,csapp,,0,0,0,,of minus one and a error know of a child
Dialogue: 0,0:58:53.13,0:58:55.31,csapp,,0,0,0,,so this isn't really an error it's just
Dialogue: 0,0:58:55.31,0:58:57.59,csapp,,0,0,0,,it just means there's no more terminated
Dialogue: 0,0:58:57.59,0:58:59.88,csapp,,0,0,0,,children so we check as long as if our
Dialogue: 0,0:58:59.88,0:59:02.70,csapp,,0,0,0,,error knows naughty child then we have
Dialogue: 0,0:59:02.70,0:59:05.13,csapp,,0,0,0,,an error otherwise we terminated
Dialogue: 0,0:59:05.13,0:59:08.33,csapp,,0,0,0,,normally as we expect it now if we run
Dialogue: 0,0:59:08.33,0:59:12.80,csapp,,0,0,0,,this code now we we see that we reap all
Dialogue: 0,0:59:12.80,0:59:18.02,csapp,,0,0,0,,five children as as we should
Dialogue: 0,0:59:18.02,0:59:21.91,csapp,,0,0,0,,okay so let's the litany of problems
Dialogue: 0,0:59:21.91,0:59:25.04,csapp,,0,0,0,,with signals first it's easy to write
Dialogue: 0,0:59:25.04,0:59:28.21,csapp,,0,0,0,,handlers that aren't safe second it's
Dialogue: 0,0:59:28.21,0:59:31.44,csapp,,0,0,0,,easy to get the semantics wrong third
Dialogue: 0,0:59:31.44,0:59:33.97,csapp,,0,0,0,,they're often not even portable across
Dialogue: 0,0:59:33.97,0:59:37.69,csapp,,0,0,0,,different versions of Unix so there's
Dialogue: 0,0:59:37.69,0:59:39.86,csapp,,0,0,0,,some older systems I don't know if any
Dialogue: 0,0:59:39.86,0:59:42.57,csapp,,0,0,0,,there's some earlier versions of Unix
Dialogue: 0,0:59:42.57,0:59:45.53,csapp,,0,0,0,,that after you catch a signal it
Dialogue: 0,0:59:45.53,0:59:48.09,csapp,,0,0,0,,restores the default action so you have
Dialogue: 0,0:59:48.09,0:59:51.73,csapp,,0,0,0,,to reinstall the handler every time well
Dialogue: 0,0:59:51.73,0:59:53.44,csapp,,0,0,0,,every time a handler gets called you
Dialogue: 0,0:59:53.44,0:59:55.11,csapp,,0,0,0,,have to re-install that handler by
Dialogue: 0,0:59:55.11,0:59:57.80,csapp,,0,0,0,,calling signal inside the handler itself
Dialogue: 0,0:59:57.80,1:00:00.40,csapp,,0,0,0,,we don't have to do that for for Linux
Dialogue: 0,1:00:00.40,1:00:06.76,csapp,,0,0,0,,systems on on some systems when you have
Dialogue: 0,1:00:06.76,1:00:10.11,csapp,,0,0,0,,so-called slow sis calls for example
Dialogue: 0,1:00:10.11,1:00:13.05,csapp,,0,0,0,,read you know if you do a read system
Dialogue: 0,1:00:13.05,1:00:16.77,csapp,,0,0,0,,call the kernel doesn't wait around for
Dialogue: 0,1:00:16.77,1:00:20.79,csapp,,0,0,0,,that data to arrive it's it you know it
Dialogue: 0,1:00:20.79,1:00:23.55,csapp,,0,0,0,,sends a request to the disk controller
Dialogue: 0,1:00:23.55,1:00:26.82,csapp,,0,0,0,,and that schedules another process right
Dialogue: 0,1:00:26.82,1:00:28.86,csapp,,0,0,0,,so in a way that the read call is sort
Dialogue: 0,1:00:28.86,1:00:31.02,csapp,,0,0,0,,of and then only when the data arrives
Dialogue: 0,1:00:31.02,1:00:33.64,csapp,,0,0,0,,and the interrupt comes in announcing
Dialogue: 0,1:00:33.64,1:00:35.71,csapp,,0,0,0,,that the data arrives does that read
Dialogue: 0,1:00:35.71,1:00:38.71,csapp,,0,0,0,,call finish and then restore and return
Dialogue: 0,1:00:38.71,1:00:41.04,csapp,,0,0,0,,so you can think of read is actually
Dialogue: 0,1:00:41.04,1:00:43.48,csapp,,0,0,0,,kind of broken up into two parts right
Dialogue: 0,1:00:43.48,1:00:50.94,csapp,,0,0,0,,then and so that functions like read
Dialogue: 0,1:00:50.94,1:00:53.44,csapp,,0,0,0,,these kind of functions are called slow
Dialogue: 0,1:00:53.44,1:00:57.60,csapp,,0,0,0,,sis calls and on some systems if the
Dialogue: 0,1:00:57.60,1:01:00.91,csapp,,0,0,0,,process receives a signal before a slow
Dialogue: 0,1:01:00.91,1:01:04.75,csapp,,0,0,0,,system calls has finished the kernel
Dialogue: 0,1:01:04.75,1:01:06.84,csapp,,0,0,0,,will will just abort that system call
Dialogue: 0,1:01:06.84,1:01:08.82,csapp,,0,0,0,,and return from that system call with an
Dialogue: 0,1:01:08.82,1:01:12.45,csapp,,0,0,0,,error okay so from users point of view
Dialogue: 0,1:01:12.45,1:01:15.84,csapp,,0,0,0,,you're doing a read call and it returns
Dialogue: 0,1:01:15.84,1:01:18.67,csapp,,0,0,0,,with this this e enter signal this e
Dialogue: 0,1:01:18.67,1:01:21.73,csapp,,0,0,0,,enter error you did nothing wrong you
Dialogue: 0,1:01:21.73,1:01:22.99,csapp,,0,0,0,,just happen to have the bad luck of
Dialogue: 0,1:01:22.99,1:01:25.39,csapp,,0,0,0,,being interrupted by some signal and so
Dialogue: 0,1:01:25.39,1:01:26.92,csapp,,0,0,0,,in your user code you have to check for
Dialogue: 0,1:01:26.92,1:01:30.67,csapp,,0,0,0,,that and if if a slow system call like
Dialogue: 0,1:01:30.67,1:01:31.15,csapp,,0,0,0,,read is
Dialogue: 0,1:01:31.15,1:01:33.04,csapp,,0,0,0,,interrupted by signal you have to redo
Dialogue: 0,1:01:33.04,1:01:35.59,csapp,,0,0,0,,it so you have to put which is really a
Dialogue: 0,1:01:35.59,1:01:37.00,csapp,,0,0,0,,pain right because you have to put these
Dialogue: 0,1:01:37.00,1:01:40.30,csapp,,0,0,0,,these read calls in a loop and keep keep
Dialogue: 0,1:01:40.30,1:01:43.51,csapp,,0,0,0,,looping until it succeeds and finally
Dialogue: 0,1:01:43.51,1:01:45.58,csapp,,0,0,0,,some systems don't block signals of the
Dialogue: 0,1:01:45.58,1:01:49.30,csapp,,0,0,0,,type being handled right so that the
Dialogue: 0,1:01:49.30,1:01:51.31,csapp,,0,0,0,,solution for this is a replacement for
Dialogue: 0,1:01:51.31,1:01:53.68,csapp,,0,0,0,,signal so the problem is with the signal
Dialogue: 0,1:01:53.68,1:01:56.38,csapp,,0,0,0,,syscall and the solution is a newer
Dialogue: 0,1:01:56.38,1:01:59.86,csapp,,0,0,0,,syscall called sig action which provides
Dialogue: 0,1:01:59.86,1:02:02.23,csapp,,0,0,0,,a mechanism a replacement for signal
Dialogue: 0,1:02:02.23,1:02:05.08,csapp,,0,0,0,,that provides a mechanism for portable
Dialogue: 0,1:02:05.08,1:02:07.81,csapp,,0,0,0,,and predictable signal handling and so
Dialogue: 0,1:02:07.81,1:02:11.14,csapp,,0,0,0,,what I've done what I've done is created
Dialogue: 0,1:02:11.14,1:02:12.46,csapp,,0,0,0,,a rapper called
Dialogue: 0,1:02:12.46,1:02:17.23,csapp,,0,0,0,,uppercase signal that takes the same
Dialogue: 0,1:02:17.23,1:02:21.04,csapp,,0,0,0,,arguments as that the signal call but
Dialogue: 0,1:02:21.04,1:02:23.47,csapp,,0,0,0,,inside it calls the sig action function
Dialogue: 0,1:02:23.47,1:02:27.52,csapp,,0,0,0,,to get portable signal handling and so
Dialogue: 0,1:02:27.52,1:02:31.12,csapp,,0,0,0,,it's it's not really important to go
Dialogue: 0,1:02:31.12,1:02:35.17,csapp,,0,0,0,,into detail about this the point is in
Dialogue: 0,1:02:35.17,1:02:37.17,csapp,,0,0,0,,your code you always want to call
Dialogue: 0,1:02:37.17,1:02:40.57,csapp,,0,0,0,,uppercase signal using the rapper that
Dialogue: 0,1:02:40.57,1:02:43.93,csapp,,0,0,0,,provided in si si PP dot C and then if
Dialogue: 0,1:02:43.93,1:02:45.97,csapp,,0,0,0,,you do that then you'll always block
Dialogue: 0,1:02:45.97,1:02:48.70,csapp,,0,0,0,,signals of the typing handle the system
Dialogue: 0,1:02:48.70,1:02:52.75,csapp,,0,0,0,,will automatically restart slow syscalls
Dialogue: 0,1:02:52.75,1:02:57.72,csapp,,0,0,0,,that have been interrupted by by signals
Dialogue: 0,1:02:57.72,1:03:00.01,csapp,,0,0,0,,okay so fortunately there's an easy fix
Dialogue: 0,1:03:00.01,1:03:06.34,csapp,,0,0,0,,for this now let's let's finish up with
Dialogue: 0,1:03:06.34,1:03:09.67,csapp,,0,0,0,,them there's some interesting I
Dialogue: 0,1:03:09.67,1:03:11.56,csapp,,0,0,0,,mentioned that signals are difficult
Dialogue: 0,1:03:11.56,1:03:13.24,csapp,,0,0,0,,because of these the fact that they're
Dialogue: 0,1:03:13.24,1:03:15.97,csapp,,0,0,0,,they're concurrent flows so I want to
Dialogue: 0,1:03:15.97,1:03:18.22,csapp,,0,0,0,,look at some sort of subtle issues that
Dialogue: 0,1:03:18.22,1:03:19.54,csapp,,0,0,0,,you can run into because of this
Dialogue: 0,1:03:19.54,1:03:23.71,csapp,,0,0,0,,concurrency and and I want to talk about
Dialogue: 0,1:03:23.71,1:03:25.84,csapp,,0,0,0,,how to identify those errors and how to
Dialogue: 0,1:03:25.84,1:03:30.23,csapp,,0,0,0,,fix them
Dialogue: 0,1:03:30.23,1:03:34.20,csapp,,0,0,0,,so here's a program that this is like a
Dialogue: 0,1:03:34.20,1:03:37.77,csapp,,0,0,0,,simple shell program that maintains a
Dialogue: 0,1:03:37.77,1:03:40.02,csapp,,0,0,0,,jobs list right so every time it creates
Dialogue: 0,1:03:40.02,1:03:43.65,csapp,,0,0,0,,a new child it adds it to the jobs list
Dialogue: 0,1:03:43.65,1:03:46.59,csapp,,0,0,0,,and every time that child terminates it
Dialogue: 0,1:03:46.59,1:03:52.89,csapp,,0,0,0,,removes it from the jobs list okay so so
Dialogue: 0,1:03:52.89,1:03:56.40,csapp,,0,0,0,,our simple show just in a loop it just
Dialogue: 0,1:03:56.40,1:03:59.10,csapp,,0,0,0,,creates a child and then executes the
Dialogue: 0,1:03:59.10,1:04:02.88,csapp,,0,0,0,,program within that child and then in
Dialogue: 0,1:04:02.88,1:04:06.33,csapp,,0,0,0,,the parent it correctly blocks all of
Dialogue: 0,1:04:06.33,1:04:08.31,csapp,,0,0,0,,the signals temporarily while it adds
Dialogue: 0,1:04:08.31,1:04:12.96,csapp,,0,0,0,,the job to the job queue and then it
Dialogue: 0,1:04:12.96,1:04:13.50,csapp,,0,0,0,,unblocks
Dialogue: 0,1:04:13.50,1:04:18.03,csapp,,0,0,0,,and then it unblocks those signals okay
Dialogue: 0,1:04:18.03,1:04:19.65,csapp,,0,0,0,,so this is correct and that it's it's
Dialogue: 0,1:04:19.65,1:04:22.32,csapp,,0,0,0,,protecting access to this the shared job
Dialogue: 0,1:04:22.32,1:04:27.93,csapp,,0,0,0,,queue because that that that job that
Dialogue: 0,1:04:27.93,1:04:30.42,csapp,,0,0,0,,job queue is also manipulated by the
Dialogue: 0,1:04:30.42,1:04:34.28,csapp,,0,0,0,,sick child handler so when when a child
Dialogue: 0,1:04:34.28,1:04:36.90,csapp,,0,0,0,,terminates and the parent receives the
Dialogue: 0,1:04:36.90,1:04:37.68,csapp,,0,0,0,,sick
Dialogue: 0,1:04:37.68,1:04:42.84,csapp,,0,0,0,,this handler runs and this handler goes
Dialogue: 0,1:04:42.84,1:04:44.90,csapp,,0,0,0,,through and it reaps all of the children
Dialogue: 0,1:04:44.90,1:04:48.03,csapp,,0,0,0,,potentially terminated children and then
Dialogue: 0,1:04:48.03,1:04:50.13,csapp,,0,0,0,,for each one it deletes that
Dialogue: 0,1:04:50.13,1:04:53.25,csapp,,0,0,0,,that job from the job queue all right so
Dialogue: 0,1:04:53.25,1:04:55.83,csapp,,0,0,0,,here's a classic case we have two
Dialogue: 0,1:04:55.83,1:04:57.66,csapp,,0,0,0,,concurrent flows our main routine and
Dialogue: 0,1:04:57.66,1:05:02.10,csapp,,0,0,0,,our our signal handler they're each
Dialogue: 0,1:05:02.10,1:05:03.90,csapp,,0,0,0,,accessing a shared data structure in
Dialogue: 0,1:05:03.90,1:05:10.10,csapp,,0,0,0,,this case the the job queue okay and
Dialogue: 0,1:05:10.10,1:05:14.40,csapp,,0,0,0,,they're there correctly blocking signals
Dialogue: 0,1:05:14.40,1:05:18.29,csapp,,0,0,0,,while they update this this job queue
Dialogue: 0,1:05:18.29,1:05:21.12,csapp,,0,0,0,,but this program has a really subtle and
Dialogue: 0,1:05:21.12,1:05:29.72,csapp,,0,0,0,,nasty bug in it can you see what it is
Dialogue: 0,1:05:29.72,1:05:32.72,csapp,,0,0,0,,what's the sequence of events that would
Dialogue: 0,1:05:32.72,1:05:46.89,csapp,,0,0,0,,cause this program to to fail yes
Dialogue: 0,1:05:46.89,1:05:50.01,csapp,,0,0,0,,exactly that's exactly it so is it
Dialogue: 0,1:05:50.01,1:05:52.46,csapp,,0,0,0,,possible that the the child process
Dialogue: 0,1:05:52.46,1:05:54.96,csapp,,0,0,0,,could terminate before the parent has a
Dialogue: 0,1:05:54.96,1:05:56.91,csapp,,0,0,0,,chance to add that job to the queue and
Dialogue: 0,1:05:56.91,1:06:00.06,csapp,,0,0,0,,the answer is yes right we you cannot
Dialogue: 0,1:06:00.06,1:06:02.14,csapp,,0,0,0,,make any assumptions about the execution
Dialogue: 0,1:06:02.14,1:06:04.90,csapp,,0,0,0,,ordering of the child in the process or
Dialogue: 0,1:06:04.90,1:06:07.20,csapp,,0,0,0,,about how long they run right so it's
Dialogue: 0,1:06:07.20,1:06:10.83,csapp,,0,0,0,,it's it's very possible that the child
Dialogue: 0,1:06:10.83,1:06:14.22,csapp,,0,0,0,,can connect after after the four control
Dialogue: 0,1:06:14.22,1:06:15.78,csapp,,0,0,0,,returns to the child instead of the
Dialogue: 0,1:06:15.78,1:06:17.91,csapp,,0,0,0,,parent and then the child terminates
Dialogue: 0,1:06:17.91,1:06:20.10,csapp,,0,0,0,,before the parent ever has a chance to
Dialogue: 0,1:06:20.10,1:06:23.61,csapp,,0,0,0,,to add that job to the job queue so now
Dialogue: 0,1:06:23.61,1:06:29.40,csapp,,0,0,0,,what's happened is that the the child is
Dialogue: 0,1:06:29.40,1:06:32.94,csapp,,0,0,0,,deleting a deleting a job that hasn't
Dialogue: 0,1:06:32.94,1:06:35.43,csapp,,0,0,0,,been added to the job queue right and
Dialogue: 0,1:06:35.43,1:06:37.26,csapp,,0,0,0,,now when the parent finally gets around
Dialogue: 0,1:06:37.26,1:06:39.88,csapp,,0,0,0,,to running it adds that job to the job
Dialogue: 0,1:06:39.88,1:06:42.06,csapp,,0,0,0,,queue and that job will never be deleted
Dialogue: 0,1:06:42.06,1:06:46.28,csapp,,0,0,0,,right so this is the kind of subtle
Dialogue: 0,1:06:46.28,1:06:49.86,csapp,,0,0,0,,nasty horrible kind of bug that you run
Dialogue: 0,1:06:49.86,1:06:51.51,csapp,,0,0,0,,into when you're dealing with
Dialogue: 0,1:06:51.51,1:06:54.24,csapp,,0,0,0,,concurrency trying to keep track of all
Dialogue: 0,1:06:54.24,1:06:57.09,csapp,,0,0,0,,of these interleaving of events can just
Dialogue: 0,1:06:57.09,1:07:00.06,csapp,,0,0,0,,make your head explode all right now and
Dialogue: 0,1:07:00.06,1:07:03.72,csapp,,0,0,0,,it happens and Sigma it happens with any
Dialogue: 0,1:07:03.72,1:07:05.67,csapp,,0,0,0,,kind of concurrency where you have
Dialogue: 0,1:07:05.67,1:07:07.15,csapp,,0,0,0,,concurrent flows accessing shared
Dialogue: 0,1:07:07.15,1:07:09.33,csapp,,0,0,0,,resources and signal handlers are no
Dialogue: 0,1:07:09.33,1:07:11.73,csapp,,0,0,0,,different now we'll look at principled
Dialogue: 0,1:07:11.73,1:07:13.35,csapp,,0,0,0,,ways where we can deal with this kind of
Dialogue: 0,1:07:13.35,1:07:16.43,csapp,,0,0,0,,sharing when we study threads later on
Dialogue: 0,1:07:16.43,1:07:19.43,csapp,,0,0,0,,but I just want to point this out to him
Dialogue: 0,1:07:19.43,1:07:23.67,csapp,,0,0,0,,scare you a little bit all right so
Dialogue: 0,1:07:23.67,1:07:27.60,csapp,,0,0,0,,here's how we would fix that what we
Dialogue: 0,1:07:27.60,1:07:31.65,csapp,,0,0,0,,have to do is somehow avoid the avoid
Dialogue: 0,1:07:31.65,1:07:35.52,csapp,,0,0,0,,the the avoid the possibility of the
Dialogue: 0,1:07:35.52,1:07:39.47,csapp,,0,0,0,,child handle or executing before the
Dialogue: 0,1:07:39.47,1:07:42.64,csapp,,0,0,0,,parent can add the corresponding job to
Dialogue: 0,1:07:42.64,1:07:45.00,csapp,,0,0,0,,the job queue now we can't control
Dialogue: 0,1:07:45.00,1:07:47.28,csapp,,0,0,0,,whether the child executes first or the
Dialogue: 0,1:07:47.28,1:07:50.07,csapp,,0,0,0,,parent execute first and we can't
Dialogue: 0,1:07:50.07,1:07:52.74,csapp,,0,0,0,,control how long the child runs but we
Dialogue: 0,1:07:52.74,1:07:56.04,csapp,,0,0,0,,can control when the the sig child
Dialogue: 0,1:07:56.04,1:07:57.60,csapp,,0,0,0,,handler runs because we can block
Dialogue: 0,1:07:57.60,1:07:58.81,csapp,,0,0,0,,signals
Dialogue: 0,1:07:58.81,1:08:03.37,csapp,,0,0,0,,okay so what we'll do we'll modify our
Dialogue: 0,1:08:03.37,1:08:08.92,csapp,,0,0,0,,program - we'll use cig proc mask to
Dialogue: 0,1:08:08.92,1:08:12.28,csapp,,0,0,0,,block cig tiled signals before we create
Dialogue: 0,1:08:12.28,1:08:15.40,csapp,,0,0,0,,the child okay so at this point after
Dialogue: 0,1:08:15.40,1:08:18.22,csapp,,0,0,0,,this invocation of cig proc sig child
Dialogue: 0,1:08:18.22,1:08:22.60,csapp,,0,0,0,,signals are blocked okay then we create
Dialogue: 0,1:08:22.60,1:08:27.06,csapp,,0,0,0,,the child and before we do our exit ve
Dialogue: 0,1:08:27.06,1:08:29.89,csapp,,0,0,0,,since we don't know that child may may
Dialogue: 0,1:08:29.89,1:08:32.50,csapp,,0,0,0,,need to reap its children right we don't
Dialogue: 0,1:08:32.50,1:08:36.19,csapp,,0,0,0,,know if it we by default children
Dialogue: 0,1:08:36.19,1:08:40.30,csapp,,0,0,0,,inherit the the blocked a bit vector of
Dialogue: 0,1:08:40.30,1:08:42.28,csapp,,0,0,0,,their parents okay so when this child
Dialogue: 0,1:08:42.28,1:08:46.66,csapp,,0,0,0,,runs F after it returns from fork at
Dialogue: 0,1:08:46.66,1:08:48.85,csapp,,0,0,0,,this point right after the fork sig
Dialogue: 0,1:08:48.85,1:08:50.83,csapp,,0,0,0,,child is blocked in the child as well
Dialogue: 0,1:08:50.83,1:08:53.44,csapp,,0,0,0,,right so if if we didn't do anything if
Dialogue: 0,1:08:53.44,1:08:57.13,csapp,,0,0,0,,and the child created children and tried
Dialogue: 0,1:08:57.13,1:08:59.23,csapp,,0,0,0,,to reap you know reap them with a sick
Dialogue: 0,1:08:59.23,1:09:00.76,csapp,,0,0,0,,child handle that sick child handler
Dialogue: 0,1:09:00.76,1:09:02.02,csapp,,0,0,0,,wouldn't run right so that would be a
Dialogue: 0,1:09:02.02,1:09:04.87,csapp,,0,0,0,,problem so in the child before we
Dialogue: 0,1:09:04.87,1:09:07.00,csapp,,0,0,0,,execute that the program itself we
Dialogue: 0,1:09:07.00,1:09:09.67,csapp,,0,0,0,,unblock sick child and this was an
Dialogue: 0,1:09:09.67,1:09:11.41,csapp,,0,0,0,,example that I was alluding to last time
Dialogue: 0,1:09:11.41,1:09:14.81,csapp,,0,0,0,,of how it's useful sometimes to separate
Dialogue: 0,1:09:14.81,1:09:18.37,csapp,,0,0,0,,creating processes with executing
Dialogue: 0,1:09:18.37,1:09:21.43,csapp,,0,0,0,,programs right then so this allows us to
Dialogue: 0,1:09:21.43,1:09:23.77,csapp,,0,0,0,,get our our signal mask set up the way
Dialogue: 0,1:09:23.77,1:09:26.14,csapp,,0,0,0,,we want it before we run our program in
Dialogue: 0,1:09:26.14,1:09:32.17,csapp,,0,0,0,,the child so now even if the child
Dialogue: 0,1:09:32.17,1:09:37.39,csapp,,0,0,0,,terminates early the sick child handler
Dialogue: 0,1:09:37.39,1:09:40.60,csapp,,0,0,0,,won't run until after we've added the
Dialogue: 0,1:09:40.60,1:09:44.85,csapp,,0,0,0,,job to the to the job queue because we
Dialogue: 0,1:09:44.85,1:09:47.55,csapp,,0,0,0,,don't unblock sick child until after the
Dialogue: 0,1:09:47.55,1:09:56.90,csapp,,0,0,0,,until after we call a job okay
Dialogue: 0,1:09:56.90,1:09:59.90,csapp,,0,0,0,,okay now there's another so this this
Dialogue: 0,1:09:59.90,1:10:03.21,csapp,,0,0,0,,sort of scenario be very relevant to you
Dialogue: 0,1:10:03.21,1:10:05.48,csapp,,0,0,0,,when you do your shell lab okay so you
Dialogue: 0,1:10:05.48,1:10:07.19,csapp,,0,0,0,,want to be careful not to not to make
Dialogue: 0,1:10:07.19,1:10:13.56,csapp,,0,0,0,,that mistake another another thing that
Dialogue: 0,1:10:13.56,1:10:15.23,csapp,,0,0,0,,you you're going to need to do in your
Dialogue: 0,1:10:15.23,1:10:17.94,csapp,,0,0,0,,shell lab now you remember in our simple
Dialogue: 0,1:10:17.94,1:10:19.89,csapp,,0,0,0,,our simple shell example we did the
Dialogue: 0,1:10:19.89,1:10:22.44,csapp,,0,0,0,,weight inside the main routine so we
Dialogue: 0,1:10:22.44,1:10:24.65,csapp,,0,0,0,,waited for foreground jobs using weight
Dialogue: 0,1:10:24.65,1:10:27.23,csapp,,0,0,0,,but now in a real shell we're going to
Dialogue: 0,1:10:27.23,1:10:29.01,csapp,,0,0,0,,have our sick child handler do all the
Dialogue: 0,1:10:29.01,1:10:31.62,csapp,,0,0,0,,all the weights call all the weights and
Dialogue: 0,1:10:31.62,1:10:34.56,csapp,,0,0,0,,it week so we can't put the weight has
Dialogue: 0,1:10:34.56,1:10:36.65,csapp,,0,0,0,,to go in the sig child handler can't go
Dialogue: 0,1:10:36.65,1:10:43.14,csapp,,0,0,0,,in the main routine okay so if it so
Dialogue: 0,1:10:43.14,1:10:44.76,csapp,,0,0,0,,high if we can't put a weight in the
Dialogue: 0,1:10:44.76,1:10:48.03,csapp,,0,0,0,,main routine how are we going to how are
Dialogue: 0,1:10:48.03,1:10:49.98,csapp,,0,0,0,,we going to detect that our foreground
Dialogue: 0,1:10:49.98,1:10:58.80,csapp,,0,0,0,,job is finished okay so somehow so what
Dialogue: 0,1:10:58.80,1:11:00.54,csapp,,0,0,0,,we could do we could define in the sig
Dialogue: 0,1:11:00.54,1:11:04.02,csapp,,0,0,0,,child handler when we read the
Dialogue: 0,1:11:04.02,1:11:07.62,csapp,,0,0,0,,foreground job right we've created a
Dialogue: 0,1:11:07.62,1:11:09.15,csapp,,0,0,0,,foreground job when we read that
Dialogue: 0,1:11:09.15,1:11:13.29,csapp,,0,0,0,,foreground job we could set this global
Dialogue: 0,1:11:13.29,1:11:17.46,csapp,,0,0,0,,flag we could declare the process this
Dialogue: 0,1:11:17.46,1:11:21.00,csapp,,0,0,0,,process ID a variable PID as a as a
Dialogue: 0,1:11:21.00,1:11:23.61,csapp,,0,0,0,,global flag and then just assign the
Dialogue: 0,1:11:23.61,1:11:26.67,csapp,,0,0,0,,process ID of the of the of the
Dialogue: 0,1:11:26.67,1:11:30.27,csapp,,0,0,0,,foreground job okay so in this this is
Dialogue: 0,1:11:30.27,1:11:32.37,csapp,,0,0,0,,an example of a handler it just all it
Dialogue: 0,1:11:32.37,1:11:38.21,csapp,,0,0,0,,does it sets a flag and then exits
Dialogue: 0,1:11:38.21,1:11:41.64,csapp,,0,0,0,,and then in our main routine okay we
Dialogue: 0,1:11:41.64,1:11:44.25,csapp,,0,0,0,,want to we want to block sig tile just
Dialogue: 0,1:11:44.25,1:11:46.89,csapp,,0,0,0,,by just like before okay to avoid that
Dialogue: 0,1:11:46.89,1:11:50.58,csapp,,0,0,0,,that race condition between the parent
Dialogue: 0,1:11:50.58,1:11:54.78,csapp,,0,0,0,,and the child and then we create the
Dialogue: 0,1:11:54.78,1:11:59.46,csapp,,0,0,0,,child and then and then in the and then
Dialogue: 0,1:11:59.46,1:12:04.26,csapp,,0,0,0,,the parent we set PID to zero okay then
Dialogue: 0,1:12:04.26,1:12:07.86,csapp,,0,0,0,,we unblock sig child and then we wait
Dialogue: 0,1:12:07.86,1:12:09.84,csapp,,0,0,0,,for the sick child handler to run and
Dialogue: 0,1:12:09.84,1:12:15.93,csapp,,0,0,0,,set PID to non zero okay okay everybody
Dialogue: 0,1:12:15.93,1:12:17.85,csapp,,0,0,0,,see that I mean this so this is correct
Dialogue: 0,1:12:17.85,1:12:21.81,csapp,,0,0,0,,right but it's extremely wasteful right
Dialogue: 0,1:12:21.81,1:12:26.42,csapp,,0,0,0,,we're spinning we're using valuable
Dialogue: 0,1:12:26.42,1:12:29.25,csapp,,0,0,0,,processor cycles in this in this tight
Dialogue: 0,1:12:29.25,1:12:31.41,csapp,,0,0,0,,spin loop just executing over and over
Dialogue: 0,1:12:31.41,1:12:32.88,csapp,,0,0,0,,and over and over and over and over for
Dialogue: 0,1:12:32.88,1:12:35.69,csapp,,0,0,0,,who knows how long okay so that's not a
Dialogue: 0,1:12:35.69,1:12:38.64,csapp,,0,0,0,,good that's not a good solution alright
Dialogue: 0,1:12:38.64,1:12:40.19,csapp,,0,0,0,,so let's look at a couple other things
Dialogue: 0,1:12:40.19,1:12:43.14,csapp,,0,0,0,,we might might consider and that have
Dialogue: 0,1:12:43.14,1:12:45.44,csapp,,0,0,0,,been considered by generations of 213
Dialogue: 0,1:12:45.44,1:12:50.52,csapp,,0,0,0,,students so one thing you might think
Dialogue: 0,1:12:50.52,1:12:53.91,csapp,,0,0,0,,well I'll just instead of just putting a
Dialogue: 0,1:12:53.91,1:12:59.01,csapp,,0,0,0,,semicolon here I'll pause and then I'll
Dialogue: 0,1:12:59.01,1:13:02.78,csapp,,0,0,0,,wait for the sick child handler to run
Dialogue: 0,1:13:02.78,1:13:05.25,csapp,,0,0,0,,and then I'll go back up and I'll check
Dialogue: 0,1:13:05.25,1:13:09.60,csapp,,0,0,0,,I'll check PID again now you have to put
Dialogue: 0,1:13:09.60,1:13:11.21,csapp,,0,0,0,,this in a loop it still has to be in a
Dialogue: 0,1:13:11.21,1:13:14.61,csapp,,0,0,0,,loop because we have other signal
Dialogue: 0,1:13:14.61,1:13:16.29,csapp,,0,0,0,,handlers in our program we have a SIGINT
Dialogue: 0,1:13:16.29,1:13:18.81,csapp,,0,0,0,,handler so it might be if we do the
Dialogue: 0,1:13:18.81,1:13:20.67,csapp,,0,0,0,,pause here and this again comes in and
Dialogue: 0,1:13:20.67,1:13:24.30,csapp,,0,0,0,,say get Sigyn handler runs that would
Dialogue: 0,1:13:24.30,1:13:26.52,csapp,,0,0,0,,cause us to exit the pause function and
Dialogue: 0,1:13:26.52,1:13:28.23,csapp,,0,0,0,,go back up so we have to keep checking
Dialogue: 0,1:13:28.23,1:13:30.98,csapp,,0,0,0,,PID because we're not sure we have to
Dialogue: 0,1:13:30.98,1:13:33.51,csapp,,0,0,0,,keep checking for the specific signal
Dialogue: 0,1:13:33.51,1:13:35.21,csapp,,0,0,0,,handler sick child handler to run
Dialogue: 0,1:13:35.21,1:13:38.93,csapp,,0,0,0,,instead of other handlers that might run
Dialogue: 0,1:13:38.93,1:13:44.79,csapp,,0,0,0,,but this is actually wrong because it
Dialogue: 0,1:13:44.79,1:13:54.19,csapp,,0,0,0,,has a race can you see what the race is
Dialogue: 0,1:13:54.19,1:13:55.81,csapp,,0,0,0,,what's wrong with this there's a good
Dialogue: 0,1:13:55.81,1:13:57.96,csapp,,0,0,0,,chance that this thing will block
Dialogue: 0,1:13:57.96,1:14:15.69,csapp,,0,0,0,,forever yes
Dialogue: 0,1:14:15.69,1:14:19.21,csapp,,0,0,0,,yeah that's so the the problem the
Dialogue: 0,1:14:19.21,1:14:21.91,csapp,,0,0,0,,problem with this is like so if the
Dialogue: 0,1:14:21.91,1:14:24.55,csapp,,0,0,0,,signal if the signal is received after
Dialogue: 0,1:14:24.55,1:14:27.94,csapp,,0,0,0,,PID is checked but before the pause
Dialogue: 0,1:14:27.94,1:14:32.25,csapp,,0,0,0,,executes okay which is possible right
Dialogue: 0,1:14:32.25,1:14:37.92,csapp,,0,0,0,,it's unlikely but it's possible if that
Dialogue: 0,1:14:37.92,1:14:42.88,csapp,,0,0,0,,if that signal is arrives here then the
Dialogue: 0,1:14:42.88,1:14:45.36,csapp,,0,0,0,,handler will set PID to non zero and
Dialogue: 0,1:14:45.36,1:14:49.23,csapp,,0,0,0,,then we'll execute the pause and the
Dialogue: 0,1:14:49.23,1:14:51.10,csapp,,0,0,0,,pause will be blocked forever waiting
Dialogue: 0,1:14:51.10,1:14:52.54,csapp,,0,0,0,,for a signal that will never arrive
Dialogue: 0,1:14:52.54,1:14:54.69,csapp,,0,0,0,,right because the sync child signal
Dialogue: 0,1:14:54.69,1:14:59.37,csapp,,0,0,0,,already already came very subtle right
Dialogue: 0,1:14:59.37,1:15:02.29,csapp,,0,0,0,,so this code looks okay it looks benign
Dialogue: 0,1:15:02.29,1:15:06.76,csapp,,0,0,0,,but it's wrong and and and your program
Dialogue: 0,1:15:06.76,1:15:10.15,csapp,,0,0,0,,would just hang forever so we say well
Dialogue: 0,1:15:10.15,1:15:11.26,csapp,,0,0,0,,okay that's no good
Dialogue: 0,1:15:11.26,1:15:13.98,csapp,,0,0,0,,we could replace the pause with asleep
Dialogue: 0,1:15:13.98,1:15:16.71,csapp,,0,0,0,,so we could say let's let's check PID
Dialogue: 0,1:15:16.71,1:15:20.32,csapp,,0,0,0,,and then sleep for some predetermined
Dialogue: 0,1:15:20.32,1:15:23.13,csapp,,0,0,0,,amount of time in this case one second
Dialogue: 0,1:15:23.13,1:15:27.48,csapp,,0,0,0,,and then go back up and check PID again
Dialogue: 0,1:15:27.48,1:15:29.92,csapp,,0,0,0,,so this while this is correct it's way
Dialogue: 0,1:15:29.92,1:15:31.69,csapp,,0,0,0,,too slow right we're asking the system
Dialogue: 0,1:15:31.69,1:15:33.34,csapp,,0,0,0,,to wait for a second which is an
Dialogue: 0,1:15:33.34,1:15:36.25,csapp,,0,0,0,,eternity and there's there's forms of
Dialogue: 0,1:15:36.25,1:15:38.23,csapp,,0,0,0,,sleep nanosecond where you can wait
Dialogue: 0,1:15:38.23,1:15:40.42,csapp,,0,0,0,,instead of units of seconds you can wait
Dialogue: 0,1:15:40.42,1:15:42.73,csapp,,0,0,0,,in units of nanoseconds but that what
Dialogue: 0,1:15:42.73,1:15:46.15,csapp,,0,0,0,,value do you use right if it's it that
Dialogue: 0,1:15:46.15,1:15:47.83,csapp,,0,0,0,,so that's if you choose a value that's
Dialogue: 0,1:15:47.83,1:15:50.50,csapp,,0,0,0,,too large then you have this problem the
Dialogue: 0,1:15:50.50,1:15:52.69,csapp,,0,0,0,,slowness problem if you choose a sleep
Dialogue: 0,1:15:52.69,1:15:55.87,csapp,,0,0,0,,time that's too small then you have the
Dialogue: 0,1:15:55.87,1:15:59.23,csapp,,0,0,0,,other problem that it's inefficient so
Dialogue: 0,1:15:59.23,1:16:03.21,csapp,,0,0,0,,the solution is to use six suspend which
Dialogue: 0,1:16:03.21,1:16:04.98,csapp,,0,0,0,,is the last last thing we're going to
Dialogue: 0,1:16:04.98,1:16:09.04,csapp,,0,0,0,,look at today so six suspend is a
Dialogue: 0,1:16:09.04,1:16:12.67,csapp,,0,0,0,,function that takes a signal mask and
Dialogue: 0,1:16:12.67,1:16:15.76,csapp,,0,0,0,,it's equivalent to an uninterruptible
Dialogue: 0,1:16:15.76,1:16:19.30,csapp,,0,0,0,,version of these three statements so we
Dialogue: 0,1:16:19.30,1:16:22.33,csapp,,0,0,0,,block the signals that are specified in
Dialogue: 0,1:16:22.33,1:16:26.32,csapp,,0,0,0,,the signal mask and then it's atomic in
Dialogue: 0,1:16:26.32,1:16:29.76,csapp,,0,0,0,,the sense that
Dialogue: 0,1:16:29.76,1:16:33.21,csapp,,0,0,0,,after that this this these two
Dialogue: 0,1:16:33.21,1:16:34.80,csapp,,0,0,0,,statements can't be interrupted they're
Dialogue: 0,1:16:34.80,1:16:37.68,csapp,,0,0,0,,always executed together okay so we
Dialogue: 0,1:16:37.68,1:16:40.65,csapp,,0,0,0,,blocked these signals and then we
Dialogue: 0,1:16:40.65,1:16:44.67,csapp,,0,0,0,,execute the pause okay so there's no
Dialogue: 0,1:16:44.67,1:16:48.51,csapp,,0,0,0,,chance of a signal interrupting this
Dialogue: 0,1:16:48.51,1:16:50.97,csapp,,0,0,0,,program in between the sig proc mask and
Dialogue: 0,1:16:50.97,1:16:57.07,csapp,,0,0,0,,the pause okay and then and then when a
Dialogue: 0,1:16:57.07,1:17:00.99,csapp,,0,0,0,,signal does come in and the execution of
Dialogue: 0,1:17:00.99,1:17:03.72,csapp,,0,0,0,,the handle or causes pause to exit then
Dialogue: 0,1:17:03.72,1:17:05.19,csapp,,0,0,0,,we set the mask back to what it was
Dialogue: 0,1:17:05.19,1:17:09.82,csapp,,0,0,0,,before okay so the proper way then to
Dialogue: 0,1:17:09.82,1:17:12.87,csapp,,0,0,0,,wait for a signal is to use sig suspend
Dialogue: 0,1:17:12.87,1:17:15.24,csapp,,0,0,0,,in the following way so here's our
Dialogue: 0,1:17:15.24,1:17:18.48,csapp,,0,0,0,,here's our program again we before we
Dialogue: 0,1:17:18.48,1:17:20.66,csapp,,0,0,0,,create the child's we block sig child
Dialogue: 0,1:17:20.66,1:17:24.39,csapp,,0,0,0,,then we create the child and now we're
Dialogue: 0,1:17:24.39,1:17:25.89,csapp,,0,0,0,,going to wait for the sick child to be
Dialogue: 0,1:17:25.89,1:17:29.48,csapp,,0,0,0,,received now sick child is still blocked
Dialogue: 0,1:17:29.48,1:17:33.28,csapp,,0,0,0,,okay so there's no danger of the sick
Dialogue: 0,1:17:33.28,1:17:36.30,csapp,,0,0,0,,child handler running okay so we set
Dialogue: 0,1:17:36.30,1:17:39.93,csapp,,0,0,0,,that global variable to zero and then
Dialogue: 0,1:17:39.93,1:17:42.60,csapp,,0,0,0,,while it's while it's non zero we
Dialogue: 0,1:17:42.60,1:17:46.53,csapp,,0,0,0,,repeatedly call sick suspend and sick
Dialogue: 0,1:17:46.53,1:17:49.14,csapp,,0,0,0,,suspend is using the previous mask that
Dialogue: 0,1:17:49.14,1:17:51.28,csapp,,0,0,0,,was set up here so sick suspend is using
Dialogue: 0,1:17:51.28,1:17:54.53,csapp,,0,0,0,,the mask where sick child is unblocked
Dialogue: 0,1:17:54.53,1:17:57.35,csapp,,0,0,0,,okay when we when we entered this first
Dialogue: 0,1:17:57.35,1:18:02.42,csapp,,0,0,0,,cig proc mask sick child was unblocked
Dialogue: 0,1:18:02.42,1:18:06.66,csapp,,0,0,0,,so this allows inside the cig suspend
Dialogue: 0,1:18:06.66,1:18:10.17,csapp,,0,0,0,,sick child is unblocked okay so it
Dialogue: 0,1:18:10.17,1:18:12.76,csapp,,0,0,0,,allows for the the handler now to be
Dialogue: 0,1:18:12.76,1:18:17.70,csapp,,0,0,0,,received or to be executed okay so in it
Dialogue: 0,1:18:17.70,1:18:21.20,csapp,,0,0,0,,and it does it safely because of the uh
Dialogue: 0,1:18:21.20,1:18:24.24,csapp,,0,0,0,,the atomic nature of those those first
Dialogue: 0,1:18:24.24,1:18:26.51,csapp,,0,0,0,,two instructions
Dialogue: 0,1:18:26.51,1:18:30.96,csapp,,0,0,0,,so once the so it's possible that the
Dialogue: 0,1:18:30.96,1:18:33.07,csapp,,0,0,0,,the implicit pause inside of sick child
Dialogue: 0,1:18:33.07,1:18:35.73,csapp,,0,0,0,,could be interrupted by say another
Dialogue: 0,1:18:35.73,1:18:39.03,csapp,,0,0,0,,signal like SIGINT okay in which case
Dialogue: 0,1:18:39.03,1:18:41.80,csapp,,0,0,0,,we'd loop back up we notice that PID was
Dialogue: 0,1:18:41.80,1:18:42.46,csapp,,0,0,0,,still zero
Dialogue: 0,1:18:42.46,1:18:44.94,csapp,,0,0,0,,and we go back into six suspend with
Dialogue: 0,1:18:44.94,1:18:49.24,csapp,,0,0,0,,with sig child unblocked okay so that
Dialogue: 0,1:18:49.24,1:18:50.77,csapp,,0,0,0,,makes sense to everybody and now so this
Dialogue: 0,1:18:50.77,1:18:52.60,csapp,,0,0,0,,is exactly the behavior we want where
Dialogue: 0,1:18:52.60,1:18:54.46,csapp,,0,0,0,,we're not wasting resources but we've
Dialogue: 0,1:18:54.46,1:19:00.16,csapp,,0,0,0,,eliminated the race okay so that's it
Dialogue: 0,1:19:00.16,1:19:01.75,csapp,,0,0,0,,for today if you're interested non
Dialogue: 0,1:19:01.75,1:19:03.79,csapp,,0,0,0,,non-local jumps are this weird thing and
Dialogue: 0,1:19:03.79,1:19:07.15,csapp,,0,0,0,,see that allows a function to return to
Dialogue: 0,1:19:07.15,1:19:08.88,csapp,,0,0,0,,some other function that didn't call it
Dialogue: 0,1:19:08.88,1:19:12.70,csapp,,0,0,0,,okay but it's described in your textbook
Dialogue: 0,1:19:12.70,1:19:14.44,csapp,,0,0,0,,and also in some additional slides here
Dialogue: 0,1:19:14.44,1:19:17.37,csapp,,0,0,0,,if you if you're interested
