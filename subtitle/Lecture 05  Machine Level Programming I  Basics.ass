[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/5n.mp4
Video File: ../../../Desktop/csapp/5n.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.015625
Scroll Position: 875
Active Line: 888
Video Position: 131761

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FF0000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.82,csapp,,0,0,0,,good afternoon everyone
Dialogue: 0,0:00:05.48,0:00:08.42,csapp,,0,0,0,,so now we're going to jump into the part of the course
Dialogue: 0,0:00:08.42,0:00:10.40,csapp,,0,0,0,,that I'd call the real core of course
Dialogue: 0,0:00:10.40,0:00:14.32,csapp,,0,0,0,,where we go into machine level programming
Dialogue: 0,0:00:14.32,0:00:17.18,csapp,,0,0,0,,and by the term machine level programming I mean
Dialogue: 0,0:00:17.70,0:00:20.58,csapp,,0,0,0,,when you're actually considering the
Dialogue: 0,0:00:20.58,0:00:26.24,csapp,,0,0,0,,the individual instructions to get executed by the machine in response to your program
Dialogue: 0,0:00:26.54,0:00:29.64,csapp,,0,0,0,,and there's really two forms of machine programs
Dialogue: 0,0:00:29.64,0:00:33.44,csapp,,0,0,0,,one is the actual object code that runs on the computer
Dialogue: 0,0:00:33.62,0:00:36.34,csapp,,0,0,0,,and as we'll see that's a series of bytes
Dialogue: 0,0:00:36.34,0:00:39.92,csapp,,0,0,0,,that encode instructions  that the prostitute executes
Dialogue: 0,0:00:40.46,0:00:43.46,csapp,,0,0,0,,but well because it's hard to look at bytes
Dialogue: 0,0:00:43.94,0:00:48.40,csapp,,0,0,0,,and understand them there's various text forms to make it more clear
Dialogue: 0,0:00:48.88,0:00:51.04,csapp,,0,0,0,,and one of  those is assembly code
Dialogue: 0,0:00:51.22,0:00:54.86,csapp,,0,0,0,, that it used to be that's how people program machines
Dialogue: 0,0:00:54.86,0:01:00.10,csapp,,0,0,0,,and nowadays it's what the target of a compiler is to generate assembly code
Dialogue: 0,0:01:00.40,0:01:01.86,csapp,,0,0,0,,and I'll use those terms
Dialogue: 0,0:01:01.86,0:01:04.90,csapp,,0,0,0,,when I say machine code I sort of interchangeably mean
Dialogue: 0,0:01:05.34,0:01:10.12,csapp,,0,0,0,,object code the binary form or assembly code the text version of it
Dialogue: 0,0:01:10.58,0:01:14.58,csapp,,0,0,0,,interchangeably because it really is a one-to-one mapping between them
Dialogue: 0,0:01:14.76,0:01:19.56,csapp,,0,0,0,,but in case I sort of use a term like assembly code
Dialogue: 0,0:01:19.76,0:01:22.76,csapp,,0,0,0,,when I instead of consistently saying machine code
Dialogue: 0,0:01:22.78,0:01:25.14,csapp,,0,0,0,,it's because they're really the same general idea
Dialogue: 0,0:01:26.12,0:01:29.56,csapp,,0,0,0,,so this is sort of one place where
Dialogue: 0,0:01:29.94,0:01:35.50,csapp,,0,0,0,,this course 213/513 takes a particular perspective
Dialogue: 0,0:01:35.50,0:01:38.72,csapp,,0,0,0,,that's very different from done ever elsewhere
Dialogue: 0,0:01:39.18,0:01:41.54,csapp,,0,0,0,,in the bad old days of computing
Dialogue: 0,0:01:42.02,0:01:46.74,csapp,,0,0,0,,you would be required to take a course it was typically called assembly level programming
Dialogue: 0,0:01:47.34,0:01:50.26,csapp,,0,0,0,,the way you actually learn to write programs in assembler
Dialogue: 0,0:01:50.74,0:01:58.52,csapp,,0,0,0,,and your assignments would be to do things like to  sort a array of numbers
Dialogue: 0,0:01:58.52,0:02:03.30,csapp,,0,0,0,,who set up some kind of linked list data structure  just sort of low-level programming
Dialogue: 0,0:02:03.30,0:02:06.94,csapp,,0,0,0,,that nowadays you wouldn't even think of wanting to write an assembly code
Dialogue: 0,0:02:07.68,0:02:12.34,csapp,,0,0,0,,and so people didn't really enjoy those courses very well
Dialogue: 0,0:02:12.66,0:02:15.32,csapp,,0,0,0,,and so they got sort of our we cut out of the curriculum
Dialogue: 0,0:02:15.76,0:02:17.88,csapp,,0,0,0,,but what our version of it is is
Dialogue: 0,0:02:18.26,0:02:20.78,csapp,,0,0,0,,this is pretty important stuff to know
Dialogue: 0,0:02:21.12,0:02:25.98,csapp,,0,0,0,,as the sort of gateway between what's how you write your programs
Dialogue: 0,0:02:25.98,0:02:28.20,csapp,,0,0,0,,say and C or any other
Dialogue: 0,0:02:28.58,0:02:31.40,csapp,,0,0,0,,and how those programs actually execute on a machine
Dialogue: 0,0:02:32.08,0:02:35.30,csapp,,0,0,0,,so machine code is sort of the intermediate form there
Dialogue: 0,0:02:35.30,0:02:39.46,csapp,,0,0,0,,the intermediate language and you need to understand that to understand better
Dialogue: 0,0:02:39.74,0:02:41.86,csapp,,0,0,0,,what your programs are trying to do
Dialogue: 0,0:02:42.32,0:02:44.84,csapp,,0,0,0,,and what the machine is trying to do
Dialogue: 0,0:02:45.60,0:02:49.18,csapp,,0,0,0,,so as a result of that our perspective will be
Dialogue: 0,0:02:49.18,0:02:52.72,csapp,,0,0,0,,we won't actually write except in very very small amounts
Dialogue: 0,0:02:53.22,0:02:57.32,csapp,,0,0,0,,we're not going to actually sit down and write assembly programs in this course
Dialogue: 0,0:02:57.96,0:03:01.04,csapp,,0,0,0,,but what you'll do is you're going to look at a lot of code
Dialogue: 0,0:03:01.38,0:03:04.38,csapp,,0,0,0,,that was generated by a C compiler GCC
Dialogue: 0,0:03:05.08,0:03:11.04,csapp,,0,0,0,,and try to see how does that what came out of that compiler relate to what went into it
Dialogue: 0,0:03:11.04,0:03:18.72,csapp,,0,0,0,,how does this low-level code implement the higher level constructs
Dialogue: 0,0:03:18.72,0:03:21.70,csapp,,0,0,0,, that I was trying to express my program in
Dialogue: 0,0:03:22.28,0:03:26.92,csapp,,0,0,0,,how our procedures functions implemented in machine language
Dialogue: 0,0:03:26.92,0:03:29.91,csapp,,0,0,0,,how our data structures such as arrays and struts
Dialogue: 0,0:03:30.52,0:03:33.92,csapp,,0,0,0,,how are those implemented in machine codes
Dialogue: 0,0:03:33.92,0:03:35.60,csapp,,0,0,0,,so we're going to learn all of that stuff
Dialogue: 0,0:03:35.96,0:03:39.14,csapp,,0,0,0,,and it takes a significant chunk of this course
Dialogue: 0,0:03:39.58,0:03:42.38,csapp,,0,0,0,,and a fair number of lectures to get through all that material
Dialogue: 0,0:03:42.38,0:03:43.56,csapp,,0,0,0,, because it's really quite a bit
Dialogue: 0,0:03:44.42,0:03:50.52,csapp,,0,0,0,,but I think it's like I said I think this is sort of the core of where this course is
Dialogue: 0,0:03:52.78,0:04:00.72,csapp,,0,0,0,,and as you know in this course we only look at one particular class of machines
Dialogue: 0,0:04:00.72,0:04:07.12,csapp,,0,0,0,,even though there's many more different machine level programming possibilities out there
Dialogue: 0,0:04:07.12,0:04:12.72,csapp,,0,0,0,,and we've chosen the Intel the 64-bit version of the Intel instruction set
Dialogue: 0,0:04:13.46,0:04:16.91,csapp,,0,0,0,,so I'll go through a little bit of the history behind Intel
Dialogue: 0,0:04:16.91,0:04:18.50,csapp,,0,0,0,,and how it got to where it is
Dialogue: 0,0:04:19.74,0:04:25.56,csapp,,0,0,0,,we'll look at through this idea of how does C code relate to assembly code machine code and so forth
Dialogue: 0,0:04:26.36,0:04:29.22,csapp,,0,0,0,,we'll go through set of low-level basics
Dialogue: 0,0:04:29.22,0:04:33.94,csapp,,0,0,0,,that you need to understand the of what assembly cup machine code looks like
Dialogue: 0,0:04:34.28,0:04:36.86,csapp,,0,0,0,,and then we'll actually take on and look at some real code
Dialogue: 0,0:04:38.12,0:04:40.48,csapp,,0,0,0,,focusing specifically on arithmetic operations
Dialogue: 0,0:04:42.86,0:04:48.66,csapp,,0,0,0,,so x86 is insert a colloquial term for Intel processors
Dialogue: 0,0:04:48.66,0:04:51.66,csapp,,0,0,0,,and the reason is that the first one was called the 8086
Dialogue: 0,0:04:52.80,0:04:58.65,csapp,,0,0,0,,and then they kind of skipped a t1 but then they went to 80 to 86
Dialogue: 0,0:04:58.65,0:05:01.50,csapp,,0,0,0,,and so forth 8386
Dialogue: 0,0:05:01.56,0:05:06.84,csapp,,0,0,0,,so the one thing in common was 86  and so people just call it x86
Dialogue: 0,0:05:07.74,0:05:09.92,csapp,,0,0,0,,and one thing that's important to this
Dialogue: 0,0:05:09.92,0:05:13.78,csapp,,0,0,0,,and it will have influence on what the programs look like is
Dialogue: 0,0:05:14.28,0:05:17.06,csapp,,0,0,0,,x86 is a language like English
Dialogue: 0,0:05:17.18,0:05:24.76,csapp,,0,0,0,, that it's been an accrual and evolution of different features layered on top of each other
Dialogue: 0,0:05:25.30,0:05:27.84,csapp,,0,0,0,,and not always the most elegant way
Dialogue: 0,0:05:28.24,0:05:32.70,csapp,,0,0,0,,so just like English there's all these sort of quirky things
Dialogue: 0,0:05:32.70,0:05:35.80,csapp,,0,0,0,,that how you write it is very different from how you pronounce it
Dialogue: 0,0:05:36.04,0:05:38.16,csapp,,0,0,0,,then there's all these irregular cases
Dialogue: 0,0:05:38.50,0:05:41.94,csapp,,0,0,0,,it doesn't make sense it's not sort of a purpose-designed language
Dialogue: 0,0:05:42.40,0:05:44.06,csapp,,0,0,0,, it's the same with x86
Dialogue: 0,0:05:44.06,0:05:46.32,csapp,,0,0,0,,it's a language that just got there
Dialogue: 0,0:05:46.32,0:05:50.96,csapp,,0,0,0,,because of a bunch of decisions that locally were probably the right thing to do
Dialogue: 0,0:05:50.96,0:05:52.00,csapp,,0,0,0,,but globally were not
Dialogue: 0,0:05:52.52,0:05:56.36,csapp,,0,0,0,,there's other instruction sets that are much cleaner and easier to understand
Dialogue: 0,0:05:56.70,0:06:00.70,csapp,,0,0,0,,but we figure it's just the same reason that you learn English
Dialogue: 0,0:06:01.04,0:06:04.00,csapp,,0,0,0,, instead of learning Esperanto or something like that
Dialogue: 0,0:06:04.46,0:06:06.44,csapp,,0,0,0,,that it's a much more useful language
Dialogue: 0,0:06:09.18,0:06:12.28,csapp,,0,0,0,,x86 is what sometimes was called a CISC
Dialogue: 0,0:06:12.90,0:06:19.84,csapp,,0,0,0,,there's a big thing in the early 80s  80s in general called RISC vs. CISC
Dialogue: 0,0:06:20.46,0:06:23.90,csapp,,0,0,0,,CISC a well risk was a new relatively new idea
Dialogue: 0,0:06:23.90,0:06:28.54,csapp,,0,0,0,,what they called a reduced instruction set computer  and it was all the rage
Dialogue: 0,0:06:28.98,0:06:31.54,csapp,,0,0,0,,and nobody had a name for what came before
Dialogue: 0,0:06:31.54,0:06:35.40,csapp,,0,0,0,,but the RSIC people named what came before a CISC
Dialogue: 0,0:06:35.96,0:06:41.24,csapp,,0,0,0,, for complex instruction set computer with the obvious sort of pejorative nature to that title
Dialogue: 0,0:06:41.68,0:06:46.38,csapp,,0,0,0,,and so Intel to the the classic CISC architecture
Dialogue: 0,0:06:46.38,0:06:51.68,csapp,,0,0,0,,meaning it has a ton of features we're not going to even scratch the surface if you want it
Dialogue: 0,0:06:52.00,0:06:55.42,csapp,,0,0,0,,the manual for it is two big fat books
Dialogue: 0,0:06:56.04,0:07:00.78,csapp,,0,0,0,,which nowadays you do with PDF documents but it's still a huge amount of stuff
Dialogue: 0,0:07:01.18,0:07:04.38,csapp,,0,0,0,,some 500 or more instructions everything
Dialogue: 0,0:07:04.68,0:07:09.98,csapp,,0,0,0,,from doing decimal arithmetic to even decimal floating point
Dialogue: 0,0:07:09.98,0:07:12.14,csapp,,0,0,0,,and all kinds of goofy stuff in there
Dialogue: 0,0:07:13.38,0:07:17.24,csapp,,0,0,0,,but it turns out that you can kind of get a pretty good handle on it
Dialogue: 0,0:07:17.24,0:07:20.84,csapp,,0,0,0,,by focusing more on just what does the code look like that
Dialogue: 0,0:07:21.08,0:07:25.46,csapp,,0,0,0,,GCC is generating for the kind of programs that you typically write
Dialogue: 0,0:07:27.62,0:07:30.06,csapp,,0,0,0,,and it should also realize it
Dialogue: 0,0:07:30.70,0:07:40.36,csapp,,0,0,0,,it many levels of this should not have been the six the the successful design
Dialogue: 0,0:07:40.36,0:07:43.30,csapp,,0,0,0,,because as I said it's just got lots of stuff on there
Dialogue: 0,0:07:43.78,0:07:48.34,csapp,,0,0,0,,but Intel has been such a powerful company and had so much market
Dialogue: 0,0:07:48.66,0:07:51.12,csapp,,0,0,0,,and such better technology
Dialogue: 0,0:07:51.12,0:07:53.54,csapp,,0,0,0,,as far as semiconductors than its competitors
Dialogue: 0,0:07:53.98,0:07:59.56,csapp,,0,0,0,,that's been able to kind of keep this thing alive for almost 40 years
Dialogue: 0,0:08:00.08,0:08:01.34,csapp,,0,0,0,,it's pretty admirable
Dialogue: 0,0:08:03.76,0:08:05.92,csapp,,0,0,0,,so just to give you a sort of timescale
Dialogue: 0,0:08:05.92,0:08:09.30,csapp,,0,0,0,,as I mentioned the 8086 was the first
Dialogue: 0,0:08:09.30,0:08:15.10,csapp,,0,0,0,,one of the first single chip 16-bit microprocessors  came out in 78
Dialogue: 0,0:08:15.48,0:08:20.76,csapp,,0,0,0,,and it a slight variation on it was a very basis for the original IBM PC
Dialogue: 0,0:08:20.78,0:08:24.96,csapp,,0,0,0,,which I know predates most of you your lives
Dialogue: 0,0:08:24.96,0:08:33.30,csapp,,0,0,0,,but it was sort of a the the big breakthrough that put computers on the desktops of many people
Dialogue: 0,0:08:35.08,0:08:38.20,csapp,,0,0,0,,and there's been many many generations I'm just giving you the highlights
Dialogue: 0,0:08:38.20,0:08:41.30,csapp,,0,0,0,,from that are relevant to this particular class
Dialogue: 0,0:08:41.90,0:08:45.18,csapp,,0,0,0,,the 386 which dates back to 1985
Dialogue: 0,0:08:45.56,0:08:49.60,csapp,,0,0,0,,was the one that really made the transition from these being personal computers
Dialogue: 0,0:08:49.60,0:08:52.96,csapp,,0,0,0,,that could run not very interesting applications
Dialogue: 0,0:08:53.48,0:08:57.70,csapp,,0,0,0,, to ones that could actually run something like a UNIX or Linux machine
Dialogue: 0,0:08:58.42,0:09:01.18,csapp,,0,0,0,,and the reason is they extended it to 32 bit
Dialogue: 0,0:09:01.46,0:09:06.00,csapp,,0,0,0,,and they removed some of the weird addressing stuff that used to be in there
Dialogue: 0,0:09:06.38,0:09:09.78,csapp,,0,0,0,,so that these look like sort of a generic a processor
Dialogue: 0,0:09:10.56,0:09:16.84,csapp,,0,0,0,, and that was clear back in 85 and that was what sometimes called IA32 intel architecture 32
Dialogue: 0,0:09:17.48,0:09:25.42,csapp,,0,0,0,,which was the dominant way of code up told just even a few years ago
Dialogue: 0,0:09:25.52,0:09:28.28,csapp,,0,0,0,,so even up as recently as this past summer
Dialogue: 0,0:09:29.14,0:09:31.54,csapp,,0,0,0,,this course was teaching IA32
Dialogue: 0,0:09:33.70,0:09:36.70,csapp,,0,0,0,,and then there and i'll talk about it more later
Dialogue: 0,0:09:36.70,0:09:43.68,csapp,,0,0,0,,there was a reason in a strange story behind the extension from 32 to 64 bits
Dialogue: 0,0:09:44.10,0:09:46.62,csapp,,0,0,0,,which kind of was sneaked in by intel
Dialogue: 0,0:09:47.22,0:09:50.36,csapp,,0,0,0,,uh and an odd model the pentium 4E
Dialogue: 0,0:09:50.36,0:09:53.74,csapp,,0,0,0,,but you see it was only about 10 years ago
Dialogue: 0,0:09:54.94,0:09:58.08,csapp,,0,0,0,,and one of the smart things they did with that is
Dialogue: 0,0:09:58.34,0:10:04.32,csapp,,0,0,0,,is that the machines that can run the 64-bit code can also run 32-bit code
Dialogue: 0,0:10:04.84,0:10:08.12,csapp,,0,0,0,,so they were able to sort of bring out all these machines
Dialogue: 0,0:10:08.12,0:10:10.88,csapp,,0,0,0,,without everybody having to change over their software
Dialogue: 0,0:10:11.20,0:10:13.96,csapp,,0,0,0,,and it's taken about that amount of time
Dialogue: 0,0:10:14.06,0:10:20.62,csapp,,0,0,0,,for the software to largely transition away from 32-bit code to 64-bit code
Dialogue: 0,0:10:22.66,0:10:28.60,csapp,,0,0,0,,and then for actually fairly interesting reasons
Dialogue: 0,0:10:28.92,0:10:32.98,csapp,,0,0,0,, it you could map how fast a single processor would run
Dialogue: 0,0:10:33.38,0:10:39.26,csapp,,0,0,0,,and it was climbing up at a pretty steady pace until around 2004
Dialogue: 0,0:10:39.72,0:10:44.98,csapp,,0,0,0,, and then Intel got and all the companies got into serious trouble with the power consumption of their chips
Dialogue: 0,0:10:45.68,0:10:47.48,csapp,,0,0,0,,they're approaching a hundred watts
Dialogue: 0,0:10:47.52,0:10:50.02,csapp,,0,0,0,,so imagine a hundred watt light bulb
Dialogue: 0,0:10:50.02,0:10:53.20,csapp,,0,0,0,,and how much heat that generates inside of a box
Dialogue: 0,0:10:53.60,0:10:57.66,csapp,,0,0,0,,that you try to blow a fan on really hard to keep it from getting too hot
Dialogue: 0,0:10:58.40,0:11:04.08,csapp,,0,0,0,,and they were reaching the point where they really couldn't go much beyond a hundred watts
Dialogue: 0,0:11:04.10,0:11:06.94,csapp,,0,0,0,,and so they sort of got into a power budget problem
Dialogue: 0,0:11:07.40,0:11:10.52,csapp,,0,0,0,,and as a result they haven't been a to scale up the frequency
Dialogue: 0,0:11:10.52,0:11:16.00,csapp,,0,0,0,,how fast the inner clock that drives this thing is beyond just a few GHz
Dialogue: 0,0:11:17.42,0:11:21.88,csapp,,0,0,0,, since 2004 so what's happened was
Dialogue: 0,0:11:22.24,0:11:25.32,csapp,,0,0,0,,they said well we can't make any single processor faster
Dialogue: 0,0:11:25.32,0:11:28.18,csapp,,0,0,0,,but we can put a bunch of processors on a single chip
Dialogue: 0,0:11:28.64,0:11:31.04,csapp,,0,0,0,,and those are referred to cores or multi-core
Dialogue: 0,0:11:31.58,0:11:36.02,csapp,,0,0,0,,so most of you with laptops probably have two cores on those
Dialogue: 0,0:11:36.76,0:11:40.88,csapp,,0,0,0,,and a laptop processor and a server might have up to 16 cores
Dialogue: 0,0:11:42.18,0:11:46.90,csapp,,0,0,0,,so those are independent processors that are all reside on a single chip
Dialogue: 0,0:11:48.52,0:11:51.64,csapp,,0,0,0,,the shark machines date back to 2008
Dialogue: 0,0:11:52.40,0:11:55.48,csapp,,0,0,0,,and they are each have four cores on them
Dialogue: 0,0:11:57.08,0:11:59.46,csapp,,0,0,0,,the shark machines the one thing about
Dialogue: 0,0:12:00.00,0:12:04.10,csapp,,0,0,0,,computers haven't really gotten that much faster of in the meantime
Dialogue: 0,0:12:04.10,0:12:10.14,csapp,,0,0,0,,so there's still fairways and they were in their day a very high-performance machine
Dialogue: 0,0:12:10.14,0:12:11.38,csapp,,0,0,0,, so they're still pretty decent
Dialogue: 0,0:12:14.82,0:12:19.22,csapp,,0,0,0,,this shows a picture of the chip that makes up a
Dialogue: 0,0:12:20.88,0:12:25.66,csapp,,0,0,0,,I think the the shark machines or approximately that same area
Dialogue: 0,0:12:26.02,0:12:31.68,csapp,,0,0,0,,and you'll see that as the picture shows these four cores are integrated onto one chip
Dialogue: 0,0:12:32.10,0:12:34.94,csapp,,0,0,0,,and then down at the bottom is what they call a cache
Dialogue: 0,0:12:35.02,0:12:37.06,csapp,,0,0,0,,and we'll learn a lot about cache memory but it's
Dialogue: 0,0:12:37.62,0:12:42.06,csapp,,0,0,0,,it's basically a temporary memory
Dialogue: 0,0:12:42.06,0:12:44.62,csapp,,0,0,0,,used to hold the most recently accessed data
Dialogue: 0,0:12:44.62,0:12:46.62,csapp,,0,0,0,,so that you can get to it more quickly
Dialogue: 0,0:12:47.52,0:12:50.08,csapp,,0,0,0,,and you'll see that that shared across the four cores
Dialogue: 0,0:12:53.02,0:13:00.22,csapp,,0,0,0,,so if you look at the latest if you were to go off shopping on in the catalog the latest instance
Dialogue: 0,0:13:00.22,0:13:02.06,csapp,,0,0,0,, and I don't have any chip pictures
Dialogue: 0,0:13:02.62,0:13:04.88,csapp,,0,0,0,,it is a model they called a Broadwell model
Dialogue: 0,0:13:05.54,0:13:09.70,csapp,,0,0,0,,and you'll see that on a single chip they have multiple cores
Dialogue: 0,0:13:10.74,0:13:16.44,csapp,,0,0,0,,4 cores a serious standard desktop model eight first a server class machine
Dialogue: 0,0:13:16.88,0:13:22.38,csapp,,0,0,0,,and then built around the perimeter there are various connections to the rest of the world
Dialogue: 0,0:13:22.88,0:13:28.52,csapp,,0,0,0,,so DDR is the way you connect to the main memory what's called DRAM dynamic ram
Dialogue: 0,0:13:29.32,0:13:32.64,csapp,,0,0,0,,PCI is the connection to peripheral devices
Dialogue: 0,0:13:34.34,0:13:37.38,csapp,,0,0,0,, SATA is a connection to different types of discs
Dialogue: 0,0:13:38.82,0:13:42.61,csapp,,0,0,0,, and USB well you know USB is
Dialogue: 0,0:13:44.34,0:13:48.20,csapp,,0,0,0,,and then the ethernet is the connection also to a network connection
Dialogue: 0,0:13:48.44,0:13:55.74,csapp,,0,0,0,,so that's all integrated onto a single chip is not just the processor itself
Dialogue: 0,0:13:56.22,0:14:01.76,csapp,,0,0,0,,but a lot of logic that glues that processor into a larger system
Dialogue: 0,0:14:02.78,0:14:08.24,csapp,,0,0,0,,and one interesting thing you'll notice is that the desktop model is a higher power 65 Watts
Dialogue: 0,0:14:08.84,0:14:10.80,csapp,,0,0,0,, versus the server is 45 watts
Dialogue: 0,0:14:10.90,0:14:13.20,csapp,,0,0,0,,when you put a lot of computers in a room
Dialogue: 0,0:14:13.76,0:14:16.58,csapp,,0,0,0,,turns out power is the biggest issue you have to deal with
Dialogue: 0,0:14:21.22,0:14:23.90,csapp,,0,0,0,,so Intel isn't the only company in this game
Dialogue: 0,0:14:24.02,0:14:27.76,csapp,,0,0,0,,they're sort of historic competitors a company called AMD
Dialogue: 0,0:14:28.32,0:14:33.64,csapp,,0,0,0,, and AMD was always sort of NO.2 behind Intel
Dialogue: 0,0:14:34.52,0:14:37.58,csapp,,0,0,0,,in all the just so I gave is his NO.2 behind Hertz
Dialogue: 0,0:14:38.36,0:14:42.22,csapp,,0,0,0,,but they are
Dialogue: 0,0:14:43.58,0:14:48.04,csapp,,0,0,0,,but they had a little burst in time when they kind of got out ahead of Intel
Dialogue: 0,0:14:48.04,0:14:52.38,csapp,,0,0,0,,because Intel had wasted their time on some bad ideas
Dialogue: 0,0:14:53.08,0:14:58.26,csapp,,0,0,0,,and they actually were the one that came up with the 64-bit extension to Intel that we use
Dialogue: 0,0:15:00.48,0:15:03.28,csapp,,0,0,0,,right now though AMD is not doing very well
Dialogue: 0,0:15:03.36,0:15:07.74,csapp,,0,0,0,,Intel sort of realized that it had to get its act together and it did
Dialogue: 0,0:15:08.20,0:15:10.00,csapp,,0,0,0,,and is more or less crushed AMD
Dialogue: 0,0:15:12.18,0:15:16.98,csapp,,0,0,0,,but and I should mention that they had these ferocious patent suits
Dialogue: 0,0:15:17.60,0:15:24.72,csapp,,0,0,0,,many years ago and the result of that was a cross licensing deal that allows AMD to produce x86 processors
Dialogue: 0,0:15:26.50,0:15:29.58,csapp,,0,0,0,, - now it's interesting story behind Intel in 64 bit
Dialogue: 0,0:15:30.20,0:15:34.94,csapp,,0,0,0,,they decided to make this radical shift to an architecture that they called the
Dialogue: 0,0:15:38.10,0:15:40.96,csapp,,0,0,0,,they called IA-64 at the time
Dialogue: 0,0:15:41.22,0:15:43.70,csapp,,0,0,0,,and it was based on a whole new concept
Dialogue: 0,0:15:44.36,0:15:48.98,csapp,,0,0,0,, that looked really good on paper and initial results look promising
Dialogue: 0,0:15:49.28,0:15:51.18,csapp,,0,0,0,,they invested a lot of money in this stuff
Dialogue: 0,0:15:51.40,0:15:56.28,csapp,,0,0,0,,they formed a joint operation with Hewlett Packard on this and it turned out not to work
Dialogue: 0,0:15:56.50,0:16:03.98,csapp,,0,0,0,, it was much too aggressive it assumed miraculous optimization capabilities by the compiler
Dialogue: 0,0:16:05.58,0:16:08.94,csapp,,0,0,0,,and so it was a from a technical idea it was very interesting technology
Dialogue: 0,0:16:08.94,0:16:10.86,csapp,,0,0,0,,but in the marketplace it didn't work
Dialogue: 0,0:16:11.46,0:16:14.16,csapp,,0,0,0,,and this was sort of a branch off
Dialogue: 0,0:16:14.84,0:16:19.42,csapp,,0,0,0,,the Intel pursued and felt obligated to keep it up because they'd invested so much in it
Dialogue: 0,0:16:19.86,0:16:23.34,csapp,,0,0,0,,and Along Came AMD and they said well we don't have to do this radical shift
Dialogue: 0,0:16:23.46,0:16:26.62,csapp,,0,0,0,,we'll just sort of do the obvious thing of adding
Dialogue: 0,0:16:27.34,0:16:32.20,csapp,,0,0,0,,making the registers bigger making things go from 32 to 64 bits
Dialogue: 0,0:16:32.66,0:16:37.08,csapp,,0,0,0,,and they came along with that and gotta and were successful
Dialogue: 0,0:16:37.16,0:16:43.46,csapp,,0,0,0,,and so Intel kind of had to just sheepishly follow behind AMD on this
Dialogue: 0,0:16:43.86,0:16:46.08,csapp,,0,0,0,,but they could because of their cross licensing deal
Dialogue: 0,0:16:47.06,0:16:51.34,csapp,,0,0,0,,so nowadays as I mentioned hardware wise just about every processor that
Dialogue: 0,0:16:52.02,0:16:59.12,csapp,,0,0,0,, is in a laptop,in a desktop  even your cell phones of recent generation are all 64-bit processors
Dialogue: 0,0:17:03.90,0:17:08.06,csapp,,0,0,0,,so what we'll talk about then we used to teach IA32
Dialogue: 0,0:17:08.06,0:17:12.42,csapp,,0,0,0,,but that's gone this is the first term where we're skipping it all together
Dialogue: 0,0:17:13.04,0:17:16.82,csapp,,0,0,0,,so we're using what we'll call x86 - 64
Dialogue: 0,0:17:16.82,0:17:21.46,csapp,,0,0,0,, there's various ways this is named but this is sort of the Linux way of naming it
Dialogue: 0,0:17:22.60,0:17:27.64,csapp,,0,0,0,, if you're interested in IA32 there's a document on the web associated with the book
Dialogue: 0,0:17:27.78,0:17:31.50,csapp,,0,0,0,,called a web aside that goes through at least some of the basics of
Dialogue: 0,0:17:31.94,0:17:35.38,csapp,,0,0,0,,but to really read that you need to learn the 64 bit
Dialogue: 0,0:17:35.38,0:17:37.34,csapp,,0,0,0,,because it assumes you kind of already know that
Dialogue: 0,0:17:39.76,0:17:43.76,csapp,,0,0,0,,okay so let's go in and I should mention - if just for general interest
Dialogue: 0,0:17:44.26,0:17:48.84,csapp,,0,0,0,, the other major class of processor and common use today are called arm
Dialogue: 0,0:17:49.48,0:17:53.82,csapp,,0,0,0,,so arm actually is an acronym for acorn RISC machine
Dialogue: 0,0:17:54.66,0:17:58.58,csapp,,0,0,0,,I just told you at-risk means it means risk reduced instruction set computer
Dialogue: 0,0:17:59.04,0:18:04.64,csapp,,0,0,0,,an acorn means like you know the seed of an oak tree it was a British company
Dialogue: 0,0:18:04.86,0:18:10.96,csapp,,0,0,0,, that decided to make its own personal computers in the early days of it and they said
Dialogue: 0,0:18:11.58,0:18:13.18,csapp,,0,0,0,,we're not going to buy those chips from Intel
Dialogue: 0,0:18:13.18,0:18:16.42,csapp,,0,0,0,,we're going to make them ourselves so they designed and manufactured their own chips
Dialogue: 0,0:18:17.10,0:18:20.62,csapp,,0,0,0,,well as a company a computer manufacturer it was a complete bus
Dialogue: 0,0:18:21.32,0:18:26.24,csapp,,0,0,0,,but it turned out that they'd come up with a fairly good instruction set
Dialogue: 0,0:18:26.32,0:18:32.60,csapp,,0,0,0,,that was sufficiently simple that it could be put on chips and better yet
Dialogue: 0,0:18:32.60,0:18:33.84,csapp,,0,0,0,,it could be customized
Dialogue: 0,0:18:34.32,0:18:39.04,csapp,,0,0,0,,so arm is now a company of its own headquartered in Cambridge England
Dialogue: 0,0:18:39.64,0:18:43.06,csapp,,0,0,0,,and the reason why part of the reason they're successful therefore is
Dialogue: 0,0:18:43.58,0:18:49.70,csapp,,0,0,0,,because it tends to be a lower power Pross than an x86 machine because it's simpler
Dialogue: 0,0:18:50.20,0:18:52.86,csapp,,0,0,0,,but the other is that they don't actually sell processors
Dialogue: 0,0:18:52.86,0:18:58.86,csapp,,0,0,0,,they sell companies the rights the licensing rights to use their designs
Dialogue: 0,0:18:59.34,0:19:03.50,csapp,,0,0,0,,and so if you look at like a a cell phone processor
Dialogue: 0,0:19:03.50,0:19:07.56,csapp,,0,0,0,, the actual ARM processor is a little tiny part of it on the chip
Dialogue: 0,0:19:08.20,0:19:14.80,csapp,,0,0,0,,and then they'll have other stuff to make the graphics go better to improve your phone calls and so forth
Dialogue: 0,0:19:14.84,0:19:19.36,csapp,,0,0,0,,and so they're really selling what intellectual property is opposed to chips
Dialogue: 0,0:19:20.10,0:19:23.66,csapp,,0,0,0,,and so people we've gotten various enquiries
Dialogue: 0,0:19:23.66,0:19:28.08,csapp,,0,0,0,,when are you going to start talking about ARM in your book or your course or something and we go
Dialogue: 0,0:19:28.46,0:19:31.74,csapp,,0,0,0,, it would be another book to write to do justice to ARM
Dialogue: 0,0:19:31.74,0:19:34.24,csapp,,0,0,0,, it would be like a whole redo of the thing
Dialogue: 0,0:19:34.58,0:19:37.74,csapp,,0,0,0,,and we were not inclined to do that right now
Dialogue: 0,0:19:39.32,0:19:44.16,csapp,,0,0,0,,but just so you know there's sort of a two worlds out there x86
Dialogue: 0,0:19:44.16,0:19:46.06,csapp,,0,0,0,,ARM are the dominant players right now
Dialogue: 0,0:19:49.46,0:19:51.32,csapp,,0,0,0,,so let's talk some terminology
Dialogue: 0,0:19:51.32,0:19:54.36,csapp,,0,0,0,,and you've probably heard some of these terms before but let's make it clear
Dialogue: 0,0:19:54.91,0:19:58.40,csapp,,0,0,0,,so when we talk about the instructions the instruction set
Dialogue: 0,0:19:58.96,0:20:04.80,csapp,,0,0,0,,that's the the target of a compiler to give you a series of instructions
Dialogue: 0,0:20:04.80,0:20:06.76,csapp,,0,0,0,, that tell the Machine exactly what to do
Dialogue: 0,0:20:08.92,0:20:11.50,csapp,,0,0,0,,but it turns out that the hardware people have figured out
Dialogue: 0,0:20:11.50,0:20:14.60,csapp,,0,0,0,,all kinds of clever ways to implement instructions
Dialogue: 0,0:20:15.26,0:20:18.96,csapp,,0,0,0,,some of them are really fast but take a lot of hardware
Dialogue: 0,0:20:19.48,0:20:22.16,csapp,,0,0,0,,some are pretty slow but don't take much hardware at all
Dialogue: 0,0:20:22.64,0:20:24.38,csapp,,0,0,0,,and so they managed to create this
Dialogue: 0,0:20:24.94,0:20:28.70,csapp,,0,0,0,,this abstraction that's called the instruction set architecture
Dialogue: 0,0:20:28.70,0:20:31.84,csapp,,0,0,0,,which is what the target of a compiler should be
Dialogue: 0,0:20:32.12,0:20:35.18,csapp,,0,0,0,,and then let the hardware people figure out how best to implement it
Dialogue: 0,0:20:35.84,0:20:40.52,csapp,,0,0,0,,and then the low so that that's a concept actually it came along in the 1960s
Dialogue: 0,0:20:41.66,0:20:48.30,csapp,,0,0,0,,so that's even before my time as far as a computer person
Dialogue: 0,0:20:49.10,0:20:52.98,csapp,,0,0,0,,but it's a very important concept in the world of computers
Dialogue: 0,0:20:53.50,0:20:55.92,csapp,,0,0,0,,and then what they call the lower level stuff
Dialogue: 0,0:20:55.92,0:20:58.80,csapp,,0,0,0,,how it actually gets implement is called the microarchitecture
Dialogue: 0,0:20:59.12,0:21:02.50,csapp,,0,0,0,,and we will talk very very little about microarchitecture in this course
Dialogue: 0,0:21:03.54,0:21:07.82,csapp,,0,0,0,,and as I mentioned machine code is sort of a generic term that incorporates both
Dialogue: 0,0:21:08.26,0:21:14.20,csapp,,0,0,0,,the actual (bit)bytes that are operated executing as well as the assembly level version of it
Dialogue: 0,0:21:18.26,0:21:22.12,csapp,,0,0,0,,and as I mentioned you can think of from instruction set point of view
Dialogue: 0,0:21:22.88,0:21:27.74,csapp,,0,0,0,,so IA32,x86-64 and what's called Itanium
Dialogue: 0,0:21:28.46,0:21:31.20,csapp,,0,0,0,, this not very successful Intel thing
Dialogue: 0,0:21:31.46,0:21:37.28,csapp,,0,0,0,,those are all in some ways different instruction set architectures
Dialogue: 0,0:21:37.28,0:21:42.02,csapp,,0,0,0,,ARM actually similar to Intel has gone through various different generations
Dialogue: 0,0:21:42.02,0:21:45.42,csapp,,0,0,0,,so there's various different generations of its instruction set
Dialogue: 0,0:21:47.82,0:21:51.32,csapp,,0,0,0,, so from a programmer machine level programmers perspective
Dialogue: 0,0:21:51.74,0:21:55.00,csapp,,0,0,0,,things are a bit different than you see when you write C code
Dialogue: 0,0:21:56.24,0:22:01.38,csapp,,0,0,0,,first of all there is some very visible parts of the instruction the Machine state
Dialogue: 0,0:22:02.12,0:22:06.32,csapp,,0,0,0,,that you can examine and test and operate on  and you must in fact
Dialogue: 0,0:22:06.82,0:22:10.92,csapp,,0,0,0,,that you would never understand what those are if you're just thinking in terms of C
Dialogue: 0,0:22:11.88,0:22:17.50,csapp,,0,0,0,,so in particular there's some sort of a program counter to tells you what
Dialogue: 0,0:22:17.66,0:22:22.54,csapp,,0,0,0,, what address is the instruction that you're going to execute next
Dialogue: 0,0:22:22.66,0:22:24.38,csapp,,0,0,0,,where is that located in memory
Dialogue: 0,0:22:25.40,0:22:30.46,csapp,,0,0,0,,and then there's a set of registers which are part of the
Dialogue: 0,0:22:30.84,0:22:33.38,csapp,,0,0,0,,that the programmer actually makes use of
Dialogue: 0,0:22:33.38,0:22:38.14,csapp,,0,0,0,,you can think of them as as a very small number of memory locations
Dialogue: 0,0:22:38.14,0:22:43.28,csapp,,0,0,0,,but rather than giving an address from 0 up to n-1 or something
Dialogue: 0,0:22:43.50,0:22:47.38,csapp,,0,0,0,,you actually give them by name as specifically
Dialogue: 0,0:22:48.22,0:22:50.34,csapp,,0,0,0,,and then there's another sort of state
Dialogue: 0,0:22:50.54,0:22:53.64,csapp,,0,0,0,,that's just a few bits worth of state that talked about
Dialogue: 0,0:22:54.10,0:22:59.26,csapp,,0,0,0,,what what are the results of some recent instructions
Dialogue: 0,0:22:59.76,0:23:04.26,csapp,,0,0,0,,where they did it produce a value of 0 did it produce a negative or a positive value
Dialogue: 0,0:23:04.60,0:23:06.66,csapp,,0,0,0,,and those are used to implement conditional branching
Dialogue: 0,0:23:06.66,0:23:08.82,csapp,,0,0,0,,which we'll look at later as we go
Dialogue: 0,0:23:10.12,0:23:11.60,csapp,,0,0,0,,and then the other part of it
Dialogue: 0,0:23:11.86,0:23:15.64,csapp,,0,0,0,,so that's sort of the processor and then the other part of is the memory
Dialogue: 0,0:23:16.20,0:23:21.78,csapp,,0,0,0,,and as I mentioned in the one of the first lectures
Dialogue: 0,0:23:21.78,0:23:25.56,csapp,,0,0,0,,the memory is you can think of logically as just an array of bytes
Dialogue: 0,0:23:26.72,0:23:30.50,csapp,,0,0,0,,and that's what the Machine level programmer sees
Dialogue: 0,0:23:31.36,0:23:35.88,csapp,,0,0,0,,and it's actually kind of a fiction in different ways as I mentioned before
Dialogue: 0,0:23:35.90,0:23:39.24,csapp,,0,0,0,,there's sort of a collaboration between the operating system and the hardware
Dialogue: 0,0:23:39.68,0:23:45.08,csapp,,0,0,0,,what they call virtual memory to make it look like each program running on the processor
Dialogue: 0,0:23:45.56,0:23:50.14,csapp,,0,0,0,,has its own independent array of bytes that it can access
Dialogue: 0,0:23:51.20,0:23:56.70,csapp,,0,0,0,,even though they actually share values within the the physical memory itself
Dialogue: 0,0:23:57.24,0:23:59.40,csapp,,0,0,0,,and furthermore you heard the term cache
Dialogue: 0,0:24:00.06,0:24:02.76,csapp,,0,0,0,,the idea of a cache is not visible here at all
Dialogue: 0,0:24:03.28,0:24:06.84,csapp,,0,0,0,,because it just is automatically loaded with recent stuff
Dialogue: 0,0:24:08.16,0:24:13.14,csapp,,0,0,0,,and the only thing that will look different is if you re access that memory it will go faster
Dialogue: 0,0:24:13.18,0:24:15.18,csapp,,0,0,0,,than it would if it hadn't been cached
Dialogue: 0,0:24:15.82,0:24:17.72,csapp,,0,0,0,,but it's not visible in terms of
Dialogue: 0,0:24:18.04,0:24:20.62,csapp,,0,0,0,,there's no instructions to manipulate the cache
Dialogue: 0,0:24:20.72,0:24:24.92,csapp,,0,0,0,,there's no way you can directly access the cache
Dialogue: 0,0:24:26.94,0:24:33.08,csapp,,0,0,0,,so you already see that it's already abstract it's got some more details of real Hardware
Dialogue: 0,0:24:33.50,0:24:39.28,csapp,,0,0,0,,but underneath it the sort of micro architecture level has some features built into it
Dialogue: 0,0:24:39.64,0:24:45.38,csapp,,0,0,0,,that you're not operating on you're not making use of directly
Dialogue: 0,0:24:47.30,0:24:49.14,csapp,,0,0,0,,yeah when you write machine level programs
Dialogue: 0,0:24:52.84,0:24:57.38,csapp,,0,0,0,,so if you have a program then say and C
Dialogue: 0,0:24:57.38,0:25:01.58,csapp,,0,0,0,,it would typically on a larger program that will include multiple files
Dialogue: 0,0:25:02.30,0:25:05.20,csapp,,0,0,0,,and it will make use of some library code
Dialogue: 0,0:25:05.72,0:25:09.92,csapp,,0,0,0,,and so the process of compilation is actually a series of steps
Dialogue: 0,0:25:10.68,0:25:12.82,csapp,,0,0,0,,that will take what you've written for code
Dialogue: 0,0:25:13.34,0:25:17.24,csapp,,0,0,0,,turn it into machine code combine it with the compiled
Dialogue: 0,0:25:18.00,0:25:24.16,csapp,,0,0,0,,compiler generated code for the libraries and produce finally a in a file
Dialogue: 0,0:25:24.56,0:25:26.76,csapp,,0,0,0,,that's your actual executable program
Dialogue: 0,0:25:27.52,0:25:31.08,csapp,,0,0,0,,and there's shown here in this picture that the first step is to
Dialogue: 0,0:25:31.36,0:25:34.24,csapp,,0,0,0,, take C and actually generate assembly code from it
Dialogue: 0,0:25:35.20,0:25:38.04,csapp,,0,0,0,,and then the next is to run that through an assembler
Dialogue: 0,0:25:38.04,0:25:44.84,csapp,,0,0,0,,which takes the text representation of instructions and turns it into the actual byte level representation
Dialogue: 0,0:25:45.06,0:25:46.66,csapp,,0,0,0,,we'll look at all this shortly
Dialogue: 0,0:25:47.56,0:25:50.98,csapp,,0,0,0,,and then there's a program called a linker
Dialogue: 0,0:25:51.28,0:25:57.28,csapp,,0,0,0,,which merges together all the different files for both your individual file
Dialogue: 0,0:25:57.72,0:26:01.99,csapp,,0,0,0,,their compiled versions and for the library code
Dialogue: 0,0:26:02.78,0:26:06.28,csapp,,0,0,0,,and then finally there's a even once you run a program
Dialogue: 0,0:26:06.28,0:26:10.78,csapp,,0,0,0,,there's actually some libraries that get imported dynamically
Dialogue: 0,0:26:11.02,0:26:12.62,csapp,,0,0,0,,when the program first begins
Dialogue: 0,0:26:14.16,0:26:17.36,csapp,,0,0,0,, so it's a sort of many layered set of activities
Dialogue: 0,0:26:17.84,0:26:21.10,csapp,,0,0,0,,and I'll go through some of these one-by-one for you
Dialogue: 0,0:26:22.58,0:26:28.84,csapp,,0,0,0,,so for example here's a not very interesting function in terms of doing anything useful
Dialogue: 0,0:26:28.84,0:26:33.22,csapp,,0,0,0,, but it sort of demonstrates the basic ideas of compilation
Dialogue: 0,0:26:33.68,0:26:36.34,csapp,,0,0,0,,and if I run this through a C compiler
Dialogue: 0,0:26:37.02,0:26:42.10,csapp,,0,0,0,,I get something that looks like what's shown on the right and that's assembly code
Dialogue: 0,0:26:43.12,0:26:45.36,csapp,,0,0,0,,and just to give you an idea of what it is
Dialogue: 0,0:26:45.36,0:26:48.50,csapp,,0,0,0,,it looks like a sort of strange language the first time you see it
Dialogue: 0,0:26:49.06,0:26:51.44,csapp,,0,0,0,,but you'll see those percent are
Dialogue: 0,0:26:51.88,0:26:54.54,csapp,,0,0,0,,something those are the actual names of registers
Dialogue: 0,0:26:54.66,0:26:57.58,csapp,,0,0,0,,remember I told you there's registers that you give by name
Dialogue: 0,0:26:59.28,0:27:02.06,csapp,,0,0,0,,and then those instructions are telling it to do something
Dialogue: 0,0:27:02.16,0:27:04.98,csapp,,0,0,0,, pushq means push something onto a stack
Dialogue: 0,0:27:05.72,0:27:09.10,csapp,,0,0,0,,move means move copy it from one place to another
Dialogue: 0,0:27:09.56,0:27:11.86,csapp,,0,0,0,, call means to call some procedure
Dialogue: 0,0:27:12.70,0:27:15.12,csapp,,0,0,0,,pop is the counterpart to push
Dialogue: 0,0:27:15.74,0:27:20.32,csapp,,0,0,0,,and then rep is exit return out of this particular function
Dialogue: 0,0:27:20.32,0:27:24.82,csapp,,0,0,0,,so you see each of those is an instruction  and it's written in text
Dialogue: 0,0:27:24.82,0:27:30.74,csapp,,0,0,0,,but each of those will turn into one actual instruction  in the object code representation
Dialogue: 0,0:27:32.38,0:27:37.58,csapp,,0,0,0,,so I should tell you that this is actually a slightly cleaned up version of what really happens
Dialogue: 0,0:27:37.60,0:27:41.80,csapp,,0,0,0,,so let me show you the reality because you'll be experiencing that a bit more too
Dialogue: 0,0:27:47.60,0:28:04.68,csapp,,0,0,0,,they had this bigger before let me make it bigger
Dialogue: 0,0:28:04.72,0:28:10.42,csapp,,0,0,0,,and blow this up so that you can see it that
Dialogue: 0,0:28:10.48,0:28:12.02,csapp,,0,0,0,,that can you see it in the back there?
Dialogue: 0,0:28:13.82,0:28:23.70,csapp,,0,0,0,,bigger better
Dialogue: 0,0:28:23.82,0:28:29.16,csapp,,0,0,0,,and let me get the other one
Dialogue: 0,0:28:29.20,0:28:50.42,csapp,,0,0,0,,it's not anyone
Dialogue: 0,0:28:50.44,0:28:56.18,csapp,,0,0,0,,and they've already logged into a fish machine to get here
Dialogue: 0,0:28:56.18,0:29:01.80,csapp,,0,0,0,,so this is a file then you see it's called some dot C
Dialogue: 0,0:29:02.26,0:29:07.14,csapp,,0,0,0,,and I'll mention that all of these programs are available you can see the whole
Dialogue: 0,0:29:08.26,0:29:14.62,csapp,,0,0,0,,well slash AFS is my own personal and all that first stuff is my own personal links
Dialogue: 0,0:29:15.18,0:29:17.56,csapp,,0,0,0,,but once you get to the class webpage
Dialogue: 0,0:29:18.10,0:29:24.34,csapp,,0,0,0,,or www/code/slash and then it's all given by which particular lecture it
Dialogue: 0,0:29:25.20,0:29:27.86,csapp,,0,0,0,,I think these are linked on the home page too
Dialogue: 0,0:29:28.38,0:29:30.04,csapp,,0,0,0,,and you can see various files there
Dialogue: 0,0:29:30.90,0:29:37.54,csapp,,0,0,0,,that are used for the demonstration the C files are obviously the programs that we typed in
Dialogue: 0,0:29:37.54,0:29:41.72,csapp,,0,0,0,,and then once it have an S at the end that's assembly code disassembly
Dialogue: 0,0:29:41.72,0:29:44.16,csapp,,0,0,0,,one that end of d what's called
Dialogue: 0,0:29:44.94,0:29:57.24,csapp,,0,0,0,,so anyways if I say GCC -O2 ,I'm sorry. -Og -S sum.c
Dialogue: 0,0:29:58.80,0:30:05.68,csapp,,0,0,0,,that what I did was just tell the compiler to take the C code and turn it into assembly code 
Dialogue: 0,0:30:06.14,0:30:10.90,csapp,,0,0,0,,so when you invoke GCC you're actually invoking it's not just one program 
Dialogue: 0,0:30:10.90,0:30:12.50,csapp,,0,0,0,,but a whole sequence of programs 
Dialogue: 0,0:30:13.36,0:30:16.52,csapp,,0,0,0,,that do various stages of the compilation 
Dialogue: 0,0:30:16.88,0:30:20.34,csapp,,0,0,0,,and by giving it this -S which I'm saying stop 
Dialogue: 0,0:30:21.42,0:30:24.20,csapp,,0,0,0,,I'll just do the first part C to assembly code 
Dialogue: 0,0:30:25.66,0:30:33.56,csapp,,0,0,0,,and the -Og is a specification of what kind of optimization I want the compiler to do
Dialogue: 0,0:30:34.22,0:30:36.02,csapp,,0,0,0,,so if you don't say anything
Dialogue: 0,0:30:36.64,0:30:44.38,csapp,,0,0,0,,if you just again it will generate completely unoptimized code and it's actually very hard to read that code
Dialogue: 0,0:30:44.38,0:30:47.92,csapp,,0,0,0,,it's very tedious the way it works if
Dialogue: 0,0:30:48.56,0:30:51.56,csapp,,0,0,0,,you say -01 
Dialogue: 0,0:30:51.56,0:30:55.76,csapp,,0,0,0,,which is what you used to do to turn on the optimizer 
Dialogue: 0,0:30:55.96,0:30:59.44,csapp,,0,0,0,,it turns out that as GCC as they've gotten more advanced 
Dialogue: 0,0:30:59.90,0:31:02.22,csapp,,0,0,0,,it does a lot of up Touma's ations now 
Dialogue: 0,0:31:02.66,0:31:07.34,csapp,,0,0,0,,that for the purpose of this course make the code pretty hard to understand 
Dialogue: 0,0:31:07.90,0:31:16.46,csapp,,0,0,0,,so just with one of the most recent generations of GCC came out with this level called G for debugging
Dialogue: 0,0:31:16.88,0:31:22.10,csapp,,0,0,0,,that's a nice for this course purpose of this course a nice level that 
Dialogue: 0,0:31:22.24,0:31:26.92,csapp,,0,0,0,,it sort of does the obvious kind of optimizations to make the code readable 
Dialogue: 0,0:31:27.16,0:31:30.90,csapp,,0,0,0,,without being sort of extravagant and trying to
Dialogue: 0,0:31:31.30,0:31:36.68,csapp,,0,0,0,,rewrite your whole program in a way that would make it a lot different  and hopefully more efficient 
Dialogue: 0,0:31:37.06,0:31:38.62,csapp,,0,0,0,,so that's what we'll use in this course 
Dialogue: 0,0:31:39.16,0:31:44.30,csapp,,0,0,0,,it's only exists in the recent versions of GCC it's non-standard across other compilers
Dialogue: 0,0:31:44.32,0:31:48.34,csapp,,0,0,0,,question 
Dialogue: 0,0:31:48.34,0:31:53.02,csapp,,0,0,0,,no it's an O capital o.it stands for optimized 
Dialogue: 0,0:31:55.84,0:32:00.76,csapp,,0,0,0,,so what that command just did was produce a file called sum.s 
Dialogue: 0,0:32:02.08,0:32:07.20,csapp,,0,0,0,,so let me show you 
Dialogue: 0,0:32:07.28,0:32:11.26,csapp,,0,0,0,,what sum.s is and let me show you the function some store
Dialogue: 0,0:32:16.24,0:32:28.58,csapp,,0,0,0,,Can you see that then? okay
Dialogue: 0,0:32:28.58,0:32:32.10,csapp,,0,0,0,,so this is the code it says some store
Dialogue: 0,0:32:33.12,0:32:36.74,csapp,,0,0,0,,and then you'll see you'll recognize those instructions I mentioned before
Dialogue: 0,0:32:36.74,0:32:41.36,csapp,,0,0,0,,the push,the move, the call, the move, the pop and the ret 
Dialogue: 0,0:32:41.68,0:32:43.44,csapp,,0,0,0,,but you also see other junk there
Dialogue: 0,0:32:47.32,0:32:52.02,csapp,,0,0,0,, that that we edited out for the presentation and even in the book it got edited out 
Dialogue: 0,0:32:52.66,0:32:57.74,csapp,,0,0,0,,and the reason is these are various directives that aren't really directly part of the code itself
Dialogue: 0,0:32:58.20,0:33:01.56,csapp,,0,0,0,,the fact they start with a period is an indication that 
Dialogue: 0,0:33:01.56,0:33:04.44,csapp,,0,0,0,,these aren't actually instructions they're something else 
Dialogue: 0,0:33:04.66,0:33:10.40,csapp,,0,0,0,,and they all are related to what the information that needs to be fed 
Dialogue: 0,0:33:10.98,0:33:16.22,csapp,,0,0,0,,to a debugger for it to be able to locate various parts of the program 
Dialogue: 0,0:33:16.76,0:33:22.16,csapp,,0,0,0,,and some information for the linker to tell it that this is a globally defined function
Dialogue: 0,0:33:22.56,0:33:27.42,csapp,,0,0,0,,and various other things that you don't really need to at least think about initially 
Dialogue: 0,0:33:27.78,0:33:32.88,csapp,,0,0,0,,so we sort of take those out of the program just to make them more readable 
Dialogue: 0,0:33:33.26,0:33:37.22,csapp,,0,0,0,,but if you ever do this yourself you'll find this crud in there
Dialogue: 0,0:33:37.22,0:33:41.48,csapp,,0,0,0,,and we don't want you to get like oh my gosh this wasn't in the book I don't know what to do with it
Dialogue: 0,0:33:46.72,0:33:48.44,csapp,,0,0,0,,so let's go back
Dialogue: 0,0:33:58.04,0:34:04.32,csapp,,0,0,0,,the other thing is people are learning on data lab is shark versus non shark it makes a difference 
Dialogue: 0,0:34:04.56,0:34:11.32,csapp,,0,0,0,,and even like this is a Mac computer and I can run got GCC installed 
Dialogue: 0,0:34:11.92,0:34:14.62,csapp,,0,0,0,,and it generates its Intel processor in there 
Dialogue: 0,0:34:15.18,0:34:19.00,csapp,,0,0,0,,but it's not directly compatible with Linux code so 
Dialogue: 0,0:34:19.44,0:34:21.22,csapp,,0,0,0,,it's pretty important for this course 
Dialogue: 0,0:34:21.22,0:34:24.60,csapp,,0,0,0,,we're saying just stick with the shark machines for everything you do 
Dialogue: 0,0:34:29.32,0:34:32.06,csapp,,0,0,0,,so what are some characteristics that have assembly code 
Dialogue: 0,0:34:32.06,0:34:34.72,csapp,,0,0,0,,especially how do they differ from C 
Dialogue: 0,0:34:35.38,0:34:39.54,csapp,,0,0,0,,well first of all there is a number of different sort of integer data types 
Dialogue: 0,0:34:40.02,0:34:42.96,csapp,,0,0,0,,of size 1 2 4 and 8 bytes
Dialogue: 0,0:34:43.32,0:34:51.54,csapp,,0,0,0,, in integer data types they don't distinguish sign versus unsigned in how in how it gets stored 
Dialogue: 0,0:34:51.86,0:34:57.26,csapp,,0,0,0,,and even at an address or a pointer is just stored as a number in a computer 
Dialogue: 0,0:34:57.78,0:35:01.10,csapp,,0,0,0,,and doesn't have any special significance to it 
Dialogue: 0,0:35:02.16,0:35:04.74,csapp,,0,0,0,,a floating-point is handled in a very different way 
Dialogue: 0,0:35:04.74,0:35:07.20,csapp,,0,0,0,,on the other hand with a different set of registers
Dialogue: 0,0:35:07.68,0:35:11.82,csapp,,0,0,0,, that I think Oh talked about very briefly in one of the later lectures 
Dialogue: 0,0:35:12.50,0:35:16.68,csapp,,0,0,0,,the program itself is in x86 it's just a series of bytes 
Dialogue: 0,0:35:16.68,0:35:18.48,csapp,,0,0,0,,and I'll show you some examples of those
Dialogue: 0,0:35:19.30,0:35:21.88,csapp,,0,0,0,, and things like arrays and structs 
Dialogue: 0,0:35:22.32,0:35:25.34,csapp,,0,0,0,,and things that you think of as fundamental datatypes 
Dialogue: 0,0:35:25.38,0:35:27.82,csapp,,0,0,0,,don't exist at the machine level 
Dialogue: 0,0:35:27.82,0:35:31.74,csapp,,0,0,0,,they're sort of constructed artificially by the compiler 
Dialogue: 0,0:35:31.78,0:35:37.52,csapp,,0,0,0,,and later in the course in these lectures we'll cross over into how that's actually done as well 
Dialogue: 0,0:35:38.52,0:35:42.50,csapp,,0,0,0,,so some of the things you know about and see exist here 
Dialogue: 0,0:35:42.86,0:35:49.42,csapp,,0,0,0,,and some of them are sort of have to be built up in layers on top of the assembly level program
Dialogue: 0,0:35:52.54,0:35:55.30,csapp,,0,0,0,,so the other thing about assembly level programming is 
Dialogue: 0,0:35:55.30,0:35:58.80,csapp,,0,0,0,,each instruction is very very limited in what it can do 
Dialogue: 0,0:35:58.80,0:36:03.04,csapp,,0,0,0,,it can move data from a register to memory, from...
Dialogue: 0,0:36:03.56,0:36:08.52,csapp,,0,0,0,,or it can do an addition or a multiplication 
Dialogue: 0,0:36:09.30,0:36:12.68,csapp,,0,0,0,,or something like that but it can really basically only do one thing 
Dialogue: 0,0:36:13.64,0:36:19.64,csapp,,0,0,0,,and so you have to write a whole  if you were writing it by hand
Dialogue: 0,0:36:19.64,0:36:23.22,csapp,,0,0,0,,you'd have to write a whole series of instructions to get anything done 
Dialogue: 0,0:36:23.66,0:36:26.84,csapp,,0,0,0,,and that's part of the reason why it's really much better to what the compiler do that 
Dialogue: 0,0:36:28.72,0:36:39.42,csapp,,0,0,0,,and we'll also see they're sort of how things like do loops,while loops ,conditionals,switch statements 
Dialogue: 0,0:36:39.42,0:36:45.84,csapp,,0,0,0,,those are all built up on top of some other on lower level features in the instructions
Dialogue: 0,0:36:47.54,0:36:54.36,csapp,,0,0,0,,so for this function of some store actually it gets encoded by a total of fourteen bytes 
Dialogue: 0,0:36:55.38,0:37:00.14,csapp,,0,0,0,,and so one thing about x86 is some instructions are as short as one byte 
Dialogue: 0,0:37:00.84,0:37:07.10,csapp,,0,0,0,,but others can be as long as 15 bytes  thought in the encoding and
Dialogue: 0,0:37:13.74,0:37:18.22,csapp,,0,0,0,,like I said each each instruction really typically only does one thing 
Dialogue: 0,0:37:18.82,0:37:22.46,csapp,,0,0,0,,so for example and see if you say *dest equals t
Dialogue: 0,0:37:23.32,0:37:26.86,csapp,,0,0,0,,what that will typically and not always but this sort of way to 
Dialogue: 0,0:37:26.86,0:37:28.86,csapp,,0,0,0,,think about that at the machine level is its
Dialogue: 0,0:37:29.30,0:37:33.54,csapp,,0,0,0,,t or some local value would be typically stored in a register 
Dialogue: 0,0:37:34.22,0:37:38.64,csapp,,0,0,0,,and as you know and see if you put star in front of it you want it referenced as a pointer
Dialogue: 0,0:37:39.04,0:37:40.62,csapp,,0,0,0,, and if that reference is on the left 
Dialogue: 0,0:37:41.06,0:37:47.24,csapp,,0,0,0,,you want to store a number of value at that place where you're pointing to 
Dialogue: 0,0:37:47.90,0:37:50.64,csapp,,0,0,0,,so what would typically happen is 
Dialogue: 0,0:37:51.04,0:37:57.40,csapp,,0,0,0,,dest the the actual pointer value would also be stored in a register here it's in register rbx
Dialogue: 0,0:37:58.58,0:38:04.92,csapp,,0,0,0,, and I use a move instruction to say take the value from one register which is called rax here 
Dialogue: 0,0:38:05.18,0:38:08.04,csapp,,0,0,0,,and store it in the memory location 
Dialogue: 0,0:38:08.34,0:38:10.42,csapp,,0,0,0,,that's specified by another register 
Dialogue: 0,0:38:10.82,0:38:14.70,csapp,,0,0,0,,so you see the idea we'll go into more detail about 
Dialogue: 0,0:38:14.70,0:38:17.36,csapp,,0,0,0,,all these register names and what the parentheses mean 
Dialogue: 0,0:38:17.36,0:38:20.98,csapp,,0,0,0,,but you get the rough idea that a move instruction is saying 
Dialogue: 0,0:38:22.08,0:38:26.16,csapp,,0,0,0,,can refer to either a register or a memory location
Dialogue: 0,0:38:27.72,0:38:31.78,csapp,,0,0,0,,um and the actual object code representation of this is just a three bytes 
Dialogue: 0,0:38:32.00,0:38:38.48,csapp,,0,0,0,,where the first byte tells it that it 
Dialogue: 0,0:38:38.56,0:38:41.10,csapp,,0,0,0,,and we would even talk much in this course about 
Dialogue: 0,0:38:41.26,0:38:46.98,csapp,,0,0,0,,how the instructions are encoded won't generally let programs do that for us 
Dialogue: 0,0:38:47.94,0:38:51.98,csapp,,0,0,0,,but in this case it only takes three bytes to write that particular instruction 
Dialogue: 0,0:38:53.26,0:38:57.64,csapp,,0,0,0,,so how can we know that kind of stuff how can we figure out that level of detail 
Dialogue: 0,0:38:58.02,0:39:02.70,csapp,,0,0,0,,well there's some really useful tools that let you examine machine code
Dialogue: 0,0:39:03.10,0:39:09.74,csapp,,0,0,0,, even if you don't have a copy of the original C file or even the assembly code file ahead of time 
Dialogue: 0,0:39:10.14,0:39:12.02,csapp,,0,0,0,,and there's one called a disassembler 
Dialogue: 0,0:39:12.46,0:39:20.36,csapp,,0,0,0,,so an assembler goes from this text version of instructions to a byte level representation 
Dialogue: 0,0:39:20.80,0:39:24.94,csapp,,0,0,0,,and the disassembler just reverses that it says here is a series of bytes
Dialogue: 0,0:39:26.08,0:39:33.80,csapp,,0,0,0,,and I the disassembler know that this particular byte sequence refers is a move instruction 
Dialogue: 0,0:39:33.88,0:39:39.82,csapp,,0,0,0,, and so it will now print out on the screen to say oh that was a move instruction
Dialogue: 0,0:39:39.82,0:39:45.34,csapp,,0,0,0,,and so it basically reverse engineers from the object code back to the assembly code 
Dialogue: 0,0:39:45.34,0:39:48.26,csapp,,0,0,0,,or something sort of like the assembly code 
Dialogue: 0,0:39:48.26,0:39:56.54,csapp,,0,0,0,,you'll see it lost ,what it's very slightly different 
Dialogue: 0,0:39:57.12,0:40:01.36,csapp,,0,0,0,,one thing also to notice I should mention about assembly code is 
Dialogue: 0,0:40:02.18,0:40:05.14,csapp,,0,0,0,,all those you know all the names I used 
Dialogue: 0,0:40:05.14,0:40:11.96,csapp,,0,0,0,,all the names of variables are completely lost at the assembly code level,at the machine code level 
Dialogue: 0,0:40:12.16,0:40:15.10,csapp,,0,0,0,,things are just during registers they're somewhere in memory 
Dialogue: 0,0:40:15.50,0:40:20.16,csapp,,0,0,0,,the program has no understanding of your original source code at that level 
Dialogue: 0,0:40:21.72,0:40:24.92,csapp,,0,0,0,,and so the disassembled is just a way to go backward 
Dialogue: 0,0:40:25.40,0:40:26.90,csapp,,0,0,0,,and you can do that yourself
Dialogue: 0,0:40:27.94,0:40:37.73,csapp,,0,0,0,,and you'll find that useful in various contexts and to do that yourself
Dialogue: 0,0:40:38.32,0:40:40.70,csapp,,0,0,0,,thanks kind of monkeying around me 
Dialogue: 0,0:40:43.14,0:41:02.34,csapp,,0,0,0,,so if I compile the sum program
Dialogue: 0,0:41:02.34,0:41:05.40,csapp,,0,0,0,,so if I do the more standard thing you doing 
Dialogue: 0,0:41:06.30,0:41:11.34,csapp,,0,0,0,,using  a compiler you say run the compiler give it some optimization 
Dialogue: 0,0:41:11.86,0:41:16.22,csapp,,0,0,0,,tell it what the source files are until it where to put the final executable code
Dialogue: 0,0:41:16.22,0:41:19.42,csapp,,0,0,0,,and I'm terribly clever I call the function sum 
Dialogue: 0,0:41:20.22,0:41:22.08,csapp,,0,0,0,,and so sum is a binary file
Dialogue: 0,0:41:25.74,0:41:32.36,csapp,,0,0,0,,of 8663 bytes, you see off on the left its mark is executable 
Dialogue: 0,0:41:33.04,0:41:34.80,csapp,,0,0,0,,and it actually works
Dialogue: 0,0:41:35.34,0:41:37.24,csapp,,0,0,0,,I can add numbers together with it 
Dialogue: 0,0:41:37.40,0:41:42.22,csapp,,0,0,0,,so that's the year two standard executable program 
Dialogue: 0,0:41:43.38,0:41:44.60,csapp,,0,0,0,,excuse me
Dialogue: 0,0:41:46.12,0:41:48.98,csapp,,0,0,0,, and if I run a program called object dump 
Dialogue: 0,0:41:50.88,0:41:53.68,csapp,,0,0,0,,and ask it to disassemble it can do various things 
Dialogue: 0,0:41:54.62,0:42:00.44,csapp,,0,0,0,,it will spit out a disassembled version of the program it will fly by on the screen
Dialogue: 0,0:42:00.44,0:42:05.06,csapp,,0,0,0,,but if I redirect that to some a file
Dialogue: 0,0:42:08.12,0:42:18.30,csapp,,0,0,0,,which I already did I'll remove the old one
Dialogue: 0,0:42:18.30,0:42:19.36,csapp,,0,0,0,,and now I look at that 
Dialogue: 0,0:42:22.02,0:42:28.12,csapp,,0,0,0,,you'll see that it has what I described as is the disassembled representation of the program 
Dialogue: 0,0:42:28.64,0:42:32.26,csapp,,0,0,0,,including some files that you didn't some functions that you didn't write 
Dialogue: 0,0:42:32.58,0:42:41.04,csapp,,0,0,0,,has ones that are sort of the low-level functions that are used in the initial startup of a program called in it
Dialogue: 0,0:42:48.52,0:42:52.22,csapp,,0,0,0,,but here somewhere in the middle of it  you'll see go and behold is 
Dialogue: 0,0:42:52.58,0:42:57.38,csapp,,0,0,0,,that program,that function some store that got compiled 
Dialogue: 0,0:42:58.12,0:43:08.56,csapp,,0,0,0,,and you can see that what it did was it took this 14 bytes from the original that the object code 
Dialogue: 0,0:43:09.22,0:43:14.57,csapp,,0,0,0,,and it picked those apart and came back with what instructions those bytes in code 
Dialogue: 0,0:43:14.88,0:43:18.18,csapp,,0,0,0,,so for example the push instruction only takes a single byte 
Dialogue: 0,0:43:19.06,0:43:21.92,csapp,,0,0,0,,the move as you saw before takes three bytes 
Dialogue: 0,0:43:22.88,0:43:31.64,csapp,,0,0,0,,this call because it has to give the location of where to call is a five byte instruction and so forth 
Dialogue: 0,0:43:34.28,0:43:37.54,csapp,,0,0,0,,but again the disassembler didn't have access to the source code 
Dialogue: 0,0:43:37.54,0:43:39.46,csapp,,0,0,0,,it didn't have access even to the assembly code 
Dialogue: 0,0:43:39.46,0:43:43.92,csapp,,0,0,0,,it figured this out just by the bytes in the actual object code file 
Dialogue: 0,0:43:45.78,0:43:51.02,csapp,,0,0,0,,so this is the way if you ever want to know actually the byte level encoding 
Dialogue: 0,0:43:51.40,0:43:52.80,csapp,,0,0,0,, this is how you figure it out 
Dialogue: 0,0:43:53.58,0:44:02.09,csapp,,0,0,0,,is to run a program  run it through an assembler get object code  and then come back out with
Dialogue: 0,0:44:03.52,0:44:05.12,csapp,,0,0,0,,it there's another way you can do it
Dialogue: 0,0:44:07.34,0:44:09.92,csapp,,0,0,0,,using the debugging program which 
Dialogue: 0,0:44:10.04,0:44:13.28,csapp,,0,0,0,,you'll get to know very well in the next web you're going to do 
Dialogue: 0,0:44:15.66,0:44:17.09,csapp,,0,0,0,,and it's called gdb
Dialogue: 0,0:44:20.26,0:44:24.86,csapp,,0,0,0,,and gdb is a very powerful debugging program that 
Dialogue: 0,0:44:25.10,0:44:29.83,csapp,,0,0,0,,you can examine step through and operate on programs in 
Dialogue: 0,0:44:30.04,0:44:36.64,csapp,,0,0,0,,and again you can if you,if the source code for it's available it will make use of it 
Dialogue: 0,0:44:37.08,0:44:40.92,csapp,,0,0,0,,but it also can be used on programs for which there's no source available
Dialogue: 0,0:44:41.34,0:44:45.02,csapp,,0,0,0,,but one of the features is the ability to disassemble functions in there 
Dialogue: 0,0:44:45.02,0:44:50.60,csapp,,0,0,0,,so if I say disassemble sumstore
Dialogue: 0,0:44:52.50,0:44:56.98,csapp,,0,0,0,,it'll come back with something that looks a lot like what you saw from the from object dump 
Dialogue: 0,0:44:57.76,0:45:02.40,csapp,,0,0,0,,a listing of the instructions and here it just shows in hex 
Dialogue: 0,0:45:02.46,0:45:07.30,csapp,,0,0,0,,what the addresses of those different instructions are it doesn't show the byte level encoding
Dialogue: 0,0:45:08.62,0:45:13.74,csapp,,0,0,0,, so there's my point here is there's various tools
Dialogue: 0,0:45:13.74,0:45:16.34,csapp,,0,0,0,,that let you look at a program 
Dialogue: 0,0:45:16.68,0:45:21.98,csapp,,0,0,0,,even if it's actual representation is a binary file that you don't want to examine directly
Dialogue: 0,0:45:34.84,0:45:36.36,csapp,,0,0,0,,I just put this in
Dialogue: 0,0:45:43.42,0:45:47.28,csapp,,0,0,0,,so what this slide shows is what I just showed you on the screen 
Dialogue: 0,0:45:47.28,0:45:51.08,csapp,,0,0,0,,which is what the object dump program produces for this function 
Dialogue: 0,0:45:53.36,0:45:57.09,csapp,,0,0,0,,and this is a version showing what gdb would show you for it
Dialogue: 0,0:45:57.70,0:46:01.06,csapp,,0,0,0,,and with gdb if you want to actually get the bytes out 
Dialogue: 0,0:46:01.30,0:46:06.08,csapp,,0,0,0,,you can do that you can basically for any address 
Dialogue: 0,0:46:06.08,0:46:10.68,csapp,,0,0,0,,you can just give an address and tell it to display some number of bytes 
Dialogue: 0,0:46:11.16,0:46:19.02,csapp,,0,0,0,,and so this rather cryptic command to gdb says examine 14 bytes in hex format 
Dialogue: 0,0:46:20.00,0:46:23.40,csapp,,0,0,0,,starting at the address of the function sumstore 
Dialogue: 0,0:46:25.66,0:46:28.82,csapp,,0,0,0,,and it produced something that looks like what you see on the left
Dialogue: 0,0:46:32.88,0:46:38.92,csapp,,0,0,0,,in fact disassembly is a tool that can be used as part of any reverse engineering tools 
Dialogue: 0,0:46:39.40,0:46:46.33,csapp,,0,0,0,,and I used to demo this by showing a disassembly of the windows of Microsoft Word
Dialogue: 0,0:46:46.70,0:46:49.94,csapp,,0,0,0,,I had a PC back then not a Mac
Dialogue: 0,0:46:49.94,0:46:55.12,csapp,,0,0,0,, but um some people and you know our slides are online 
Dialogue: 0,0:46:55.12,0:46:57.78,csapp,,0,0,0,,and so we got some nasty grams from people saying 
Dialogue: 0,0:46:58.06,0:47:02.42,csapp,,0,0,0,,you know you're violating the Microsoft end-user license agreement when you do that 
Dialogue: 0,0:47:02.42,0:47:05.78,csapp,,0,0,0,,because you're supposed to you don't know this 
Dialogue: 0,0:47:05.78,0:47:08.38,csapp,,0,0,0,,but remember all those click through I agree things 
Dialogue: 0,0:47:10.00,0:47:10.76,csapp,,0,0,0,,but you never read 
Dialogue: 0,0:47:11.22,0:47:17.90,csapp,,0,0,0,,one of them is very not to try to reverse engineer any Microsoft product so 
Dialogue: 0,0:47:19.68,0:47:24.50,csapp,,0,0,0,,so this is would technically so I've served just for modesty I blanked this out 
Dialogue: 0,0:47:24.50,0:47:25.68,csapp,,0,0,0,,but you can actually do it 
Dialogue: 0,0:47:26.10,0:47:29.14,csapp,,0,0,0,,if you can find where the file is it's sort of 
Dialogue: 0,0:47:29.50,0:47:32.82,csapp,,0,0,0,,obscure where the actual executable files of an application are 
Dialogue: 0,0:47:33.90,0:47:36.72,csapp,,0,0,0,,my point is that word like any other 
Dialogue: 0,0:47:39.20,0:47:42.30,csapp,,0,0,0,,application you run is just a executable file 
Dialogue: 0,0:47:42.30,0:47:46.54,csapp,,0,0,0,,and that executable file is just a bunch of bytes that encode instructions 
Dialogue: 0,0:47:48.82,0:47:53.80,csapp,,0,0,0,,okay so let's go a little bit further into this assembly level programming business 
Dialogue: 0,0:47:55.16,0:47:57.16,csapp,,0,0,0,,so I keep talking about registers 
Dialogue: 0,0:47:57.98,0:48:03.06,csapp,,0,0,0,,and x86-64 has this totally quirky set of registers
Dialogue: 0,0:48:03.48,0:48:07.30,csapp,,0,0,0,,and it's a reflection again of this sort of evolutionary history to it 
Dialogue: 0,0:48:08.10,0:48:12.70,csapp,,0,0,0,,but you'll see that there's sixteen registers that
Dialogue: 0,0:48:12.70,0:48:15.52,csapp,,0,0,0,,you can use to hold integers and pointers
Dialogue: 0,0:48:16.34,0:48:22.20,csapp,,0,0,0,, and some of them have these sort of alphabetic names and some of them have numeric names 
Dialogue: 0,0:48:23.00,0:48:24.14,csapp,,0,0,0,,I'll show you why in a minute 
Dialogue: 0,0:48:24.72,0:48:29.50,csapp,,0,0,0,,and also for each register if you use the sort of %r name of it 
Dialogue: 0,0:48:29.92,0:48:31.36,csapp,,0,0,0,,you'll get 64 bits 
Dialogue: 0,0:48:32.28,0:48:35.86,csapp,,0,0,0,,but if you use the %e version of it.you'll get 32 bits 
Dialogue: 0,0:48:36.42,0:48:43.12,csapp,,0,0,0,,and what you'll find in programs that manipulate long int.you'll see the use of R 
Dialogue: 0,0:48:43.64,0:48:48.26,csapp,,0,0,0,,and if they're just in 32-bit things you'll see code saying %e
Dialogue: 0,0:48:48.28,0:48:50.04,csapp,,0,0,0,, so you'll see both of these show up 
Dialogue: 0,0:48:50.64,0:48:53.42,csapp,,0,0,0,,but and it's fairly important to remember 
Dialogue: 0,0:48:53.88,0:49:00.82,csapp,,0,0,0,,that the %e version is just the low-order 32 bits of a larger %r entity 
Dialogue: 0,0:49:02.74,0:49:09.08,csapp,,0,0,0,,and in fact it goes beyond that you can also reference the lower order 16 bits 
Dialogue: 0,0:49:09.50,0:49:12.32,csapp,,0,0,0,,and the low order 2 bit,I'm sorry, 1 byte  
Dialogue: 0,0:49:12.62,0:49:17.54,csapp,,0,0,0,,16 one 2 bytes and 1 byte within each of these registers as well 
Dialogue: 0,0:49:19.32,0:49:22.28,csapp,,0,0,0,,but again think of these as like named 
Dialogue: 0,0:49:23.04,0:49:28.46,csapp,,0,0,0,,locations where you can store values and you can retrieve values from them 
Dialogue: 0,0:49:29.18,0:49:35.80,csapp,,0,0,0,,and you have to you the I'm I'm sort of personifying machine level programming here not 
Dialogue: 0,0:49:35.96,0:49:43.82,csapp,,0,0,0,,you personally will actually have to explicitly name those registers for the most part 
Dialogue: 0,0:49:44.32,0:49:46.90,csapp,,0,0,0,,to say where things should go where they should come out of 
Dialogue: 0,0:49:46.90,0:49:52.50,csapp,,0,0,0,,it's not like a memory where you just give a number to tell where to look for
Dialogue: 0,0:49:52.52,0:49:57.04,csapp,,0,0,0,,you could compute a number there actually each one is identified separately 
Dialogue: 0,0:49:58.18,0:50:05.08,csapp,,0,0,0,,so just as a little bit of history with IA32  so back 
Dialogue: 0,0:50:05.74,0:50:11.80,csapp,,0,0,0,,we just talked about other being 8 registers all the %e versions 
Dialogue: 0,0:50:12.56,0:50:19.62,csapp,,0,0,0,,and one of the changes that went from IA32 to x86-64 was to double the number of registers 
Dialogue: 0,0:50:20.08,0:50:22.66,csapp,,0,0,0,,and by the way this is a really helpful thing because 
Dialogue: 0,0:50:23.12,0:50:29.42,csapp,,0,0,0,,it was very frustrating how few registers there were in the old IA32 machines 
Dialogue: 0,0:50:32.20,0:50:35.04,csapp,,0,0,0,,and then the as I mentioned
Dialogue: 0,0:50:37.36,0:50:44.74,csapp,,0,0,0,, you could actually in the old machine refer to the Lord or 16 bytes of these registers 
Dialogue: 0,0:50:44.74,0:50:48.42,csapp,,0,0,0,,and that was a legacy from the 8086 days 
Dialogue: 0,0:50:49.68,0:50:57.58,csapp,,0,0,0,,and within the first four you could even refer to the individual to Lord or bytes in those 
Dialogue: 0,0:50:58.46,0:51:03.14,csapp,,0,0,0,,so nowadays you can actually get to the low order byte of all of them 
Dialogue: 0,0:51:03.32,0:51:08.04,csapp,,0,0,0,,and we just sort of got that's covered in the book actually 
Dialogue: 0,0:51:08.46,0:51:13.84,csapp,,0,0,0,,we don't talk about how you can get to these bytes because  that's really a legacy from back 
Dialogue: 0,0:51:14.42,0:51:29.92,csapp,,0,0,0,,before the 8086 was one called the 8080 which was a an 8 byte machine
Dialogue: 0,0:51:30.00,0:51:37.88,csapp,,0,0,0,,so anyways you can see then how you got from this kind of weird state of affairs to the even weirder state 
Dialogue: 0,0:51:37.88,0:51:39.56,csapp,,0,0,0,,that we are in today 
Dialogue: 0,0:51:39.96,0:51:43.80,csapp,,0,0,0,,where some of them have names and some of them have numbers 
Dialogue: 0,0:51:45.80,0:51:50.06,csapp,,0,0,0,,and those names by the way had a reason back in ancient days 
Dialogue: 0,0:51:50.76,0:51:57.28,csapp,,0,0,0,,they had very specific purposes and so they were given names that sort of reflected those purposes
Dialogue: 0,0:51:57.84,0:52:01.98,csapp,,0,0,0,,but that that all went away years and years ago 
Dialogue: 0,0:52:02.34,0:52:07.26,csapp,,0,0,0,,and so now these names are just legacy names have nothing to do with their purpose 
Dialogue: 0,0:52:08.20,0:52:13.28,csapp,,0,0,0,,now I should mention these only there are some special there's one special register nowadays 
Dialogue: 0,0:52:15.72,0:52:19.20,csapp,,0,0,0,,as shown in pink here and that's called the stack pointer 
Dialogue: 0,0:52:19.54,0:52:24.90,csapp,,0,0,0,,and that register you don't just use any old way you please it has a very specific purpose 
Dialogue: 0,0:52:25.72,0:52:29.44,csapp,,0,0,0,,and all the other registers there's some that are slightly different than the other 
Dialogue: 0,0:52:29.44,0:52:33.60,csapp,,0,0,0,,but for the most part they're all usable for holding program data 
Dialogue: 0,0:52:34.90,0:52:39.72,csapp,,0,0,0,,back in the IA32 days there was a register called the base pointer 
Dialogue: 0,0:52:39.72,0:52:41.78,csapp,,0,0,0,,that also got used for procedures  
Dialogue: 0,0:52:42.36,0:52:46.88,csapp,,0,0,0,,but that no longer gets used anymore either at least not usually 
Dialogue: 0,0:52:48.12,0:52:53.30,csapp,,0,0,0,,so anyways I didn't want to I don't want to spend a lot of time on historic legacy stuff 
Dialogue: 0,0:52:53.74,0:52:58.64,csapp,,0,0,0,,and have you memorized you know what feature was added and what model of processor 
Dialogue: 0,0:52:58.64,0:53:04.04,csapp,,0,0,0,,but just in case you're wondering why there's these weird names for these things 
Dialogue: 0,0:53:04.04,0:53:07.20,csapp,,0,0,0,,just so you appreciate the fact that this is a legacy thing 
Dialogue: 0,0:53:09.50,0:53:15.98,csapp,,0,0,0,,okay so now we can think of it then that there's eight registers with names 
Dialogue: 0,0:53:16.10,0:53:19.42,csapp,,0,0,0,,and there's eight registers that are indicated by some number 
Dialogue: 0,0:53:20.38,0:53:23.90,csapp,,0,0,0,,and let's look at some of the instructions that operate on those registers 
Dialogue: 0,0:53:27.62,0:53:30.70,csapp,,0,0,0,,and there's sort of three different some move 
Dialogue: 0,0:53:30.84,0:53:35.18,csapp,,0,0,0,,the move instruction in x86 is actually can do a lot of things
Dialogue: 0,0:53:38.00,0:53:43.06,csapp,,0,0,0,,oh because it can take different types of information or what they call operands 
Dialogue: 0,0:53:43.84,0:53:49.46,csapp,,0,0,0,,so the source is some where you're you're copying from the source to the destination 
Dialogue: 0,0:53:50.86,0:53:53.42,csapp,,0,0,0,,the source can be some what's called a mediate.
Dialogue: 0,0:53:53.42,0:53:56.18,csapp,,0,0,0,,it's actually a number that's baked into the program.
Dialogue: 0,0:53:56.56,0:53:59.82,csapp,,0,0,0,,that you want to copy into some other location 
Dialogue: 0,0:54:00.64,0:54:06.66,csapp,,0,0,0,,a register we've talked about is one a specially named memory of locations 
Dialogue: 0,0:54:06.86,0:54:12.24,csapp,,0,0,0,,and memory is the array of bytes that you typically you have to specify what's the address 
Dialogue: 0,0:54:12.78,0:54:19.96,csapp,,0,0,0,,that you're either reading from if if it's the source are you writing to if it's the destination 
Dialogue: 0,0:54:22.42,0:54:25.88,csapp,,0,0,0,,and so the move instruction gives you all these possibilities 
Dialogue: 0,0:54:26.70,0:54:33.10,csapp,,0,0,0,,an immediate value can be written to a register or directly to memory 
Dialogue: 0,0:54:34.00,0:54:38.18,csapp,,0,0,0,,a register value can be copied to another register or written to memory 
Dialogue: 0,0:54:39.00,0:54:44.28,csapp,,0,0,0,,or you can take a value from memory read it from memory and copy it to a register  
Dialogue: 0,0:54:45.04,0:54:50.14,csapp,,0,0,0,,so if you think of wait shouldn't there be nine different combinations here well
Dialogue: 0,0:54:50.36,0:54:51.24,csapp,,0,0,0,, no
Dialogue: 0,0:54:51.26,0:54:56.48,csapp,,0,0,0,,because it doesn't make sense to have an immediate value as a destination right it's a constant
Dialogue: 0,0:54:57.04,0:55:02.10,csapp,,0,0,0,, and also just for sort of the sake of convenience for the hardware designers 
Dialogue: 0,0:55:02.68,0:55:06.44,csapp,,0,0,0,,it doesn't let you directly copy from one memory location to another 
Dialogue: 0,0:55:06.78,0:55:09.06,csapp,,0,0,0,,what you have to do is use two instructions 
Dialogue: 0,0:55:09.16,0:55:13.62,csapp,,0,0,0,,one to copy from memory to read it from memory copy it to a register 
Dialogue: 0,0:55:15.82,0:55:19.36,csapp,,0,0,0,,in a second to take that value in the register and write it to memory
Dialogue: 0,0:55:20.14,0:55:24.78,csapp,,0,0,0,,so that's why there's this only five possibilities 
Dialogue: 0,0:55:26.24,0:55:31.74,csapp,,0,0,0,,and so each of these actual five combinations  you'll see in some form or another 
Dialogue: 0,0:55:32.48,0:55:36.80,csapp,,0,0,0,,so for example if I take a constant value and copy it to a register 
Dialogue: 0,0:55:37.52,0:55:41.66,csapp,,0,0,0,,it's a little like you can think of register as a sort of the temporary data that 
Dialogue: 0,0:55:41.66,0:55:43.56,csapp,,0,0,0,,you're operating on right now  
Dialogue: 0,0:55:44.22,0:55:48.08,csapp,,0,0,0,,so it's a way of sort of of assigning a constant value to a temporary 
Dialogue: 0,0:55:49.84,0:55:53.88,csapp,,0,0,0,,similarly if you're have a memory as your destination 
Dialogue: 0,0:55:53.88,0:55:57.90,csapp,,0,0,0,,it's like storing a constant value  in memory somewhere 
Dialogue: 0,0:55:59.60,0:56:02.38,csapp,,0,0,0,,if you're copying from one register to another 
Dialogue: 0,0:56:02.38,0:56:08.26,csapp,,0,0,0,,it's sort of like copying one temporary value to another one  register to memory 
Dialogue: 0,0:56:08.26,0:56:13.47,csapp,,0,0,0,,it's as if you it's sort of like storing to an address
Dialogue: 0,0:56:13.90,0:56:17.80,csapp,,0,0,0,,so a pointer dereference where the pointer is on the left side the dereference 
Dialogue: 0,0:56:19.22,0:56:22.22,csapp,,0,0,0,,and memory to register is the opposite 
Dialogue: 0,0:56:22.22,0:56:27.64,csapp,,0,0,0,,it's your you're reading from some location into a temporary position 
Dialogue: 0,0:56:29.86,0:56:34.18,csapp,,0,0,0,,so these you see all five versions get used in some form or another 
Dialogue: 0,0:56:36.42,0:56:40.06,csapp,,0,0,0,,so now let's talk about how we write these up pointers
Dialogue: 0,0:56:40.62,0:56:46.40,csapp,,0,0,0,,how we specify either a source or a destination for a memory reference
Dialogue: 0,0:56:47.26,0:56:51.58,csapp,,0,0,0,,and you already saw one version of this in fact in some of the code 
Dialogue: 0,0:56:51.92,0:56:55.04,csapp,,0,0,0,,when you put the name of a register in parentheses
Dialogue: 0,0:56:55.48,0:57:00.27,csapp,,0,0,0,,that's just saying use this register whatever is in that that's an address
Dialogue: 0,0:57:00.74,0:57:03.92,csapp,,0,0,0,,and use that address to reference some memory location
Dialogue: 0,0:57:06.26,0:57:11.42,csapp,,0,0,0,, and so you'll see something like this is equivalent of dereferencing a pointer 
Dialogue: 0,0:57:11.42,0:57:12.48,csapp,,0,0,0,,and putting it in a temporary 
Dialogue: 0,0:57:13.38,0:57:15.96,csapp,,0,0,0,,you're also allowed to do a little bit of arithmetic 
Dialogue: 0,0:57:16.70,0:57:22.34,csapp,,0,0,0,,to derive an address from some collection of registers and other constant values 
Dialogue: 0,0:57:23.04,0:57:26.00,csapp,,0,0,0,,so if you see a number it's called the displacement D
Dialogue: 0,0:57:26.82,0:57:33.52,csapp,,0,0,0,, in front of this parenthesis it means to offset not use the address that's in the register 
Dialogue: 0,0:57:33.90,0:57:36.04,csapp,,0,0,0,,but add or subtract some number from it 
Dialogue: 0,0:57:36.38,0:57:40.18,csapp,,0,0,0,,to get an address that's just slightly off of it by some fixed amount 
Dialogue: 0,0:57:40.76,0:57:44.76,csapp,,0,0,0,,and that we'll see is fairly useful for accessing different data structures 
Dialogue: 0,0:57:47.70,0:57:50.40,csapp,,0,0,0,,so here's an example of a very simple function that
Dialogue: 0,0:57:50.64,0:57:55.90,csapp,,0,0,0,,we can understand everything about it already 
Dialogue: 0,0:57:56.08,0:57:58.54,csapp,,0,0,0,,because we know what the move instruction does 
Dialogue: 0,0:57:58.94,0:58:05.46,csapp,,0,0,0,,and that's the sort of classic swapping of two values that are stored in memory
Dialogue: 0,0:58:05.72,0:58:10.48,csapp,,0,0,0,,so my point my arguments are two pointers called xp and yp
Dialogue: 0,0:58:11.12,0:58:15.50,csapp,,0,0,0,,and I'm going to dereference those pointers I'm going to read from memory into registers 
Dialogue: 0,0:58:16.60,0:58:20.62,csapp,,0,0,0,,and then I'm going to copy back to to memory
Dialogue: 0,0:58:20.62,0:58:24.39,csapp,,0,0,0,,but reversing the the two destinations
Dialogue: 0,0:58:25.60,0:58:30.36,csapp,,0,0,0,,and so as you can imagine it it lines up to be for move instructions 
Dialogue: 0,0:58:30.36,0:58:33.06,csapp,,0,0,0,,that correspond to these four references 
Dialogue: 0,0:58:34.44,0:58:39.86,csapp,,0,0,0,,and the final one ret just won't learn more about functions  and how they're called
Dialogue: 0,0:58:39.86,0:58:47.30,csapp,,0,0,0,,but just think of the read is it gets you it returns from wherever the calling position was 
Dialogue: 0,0:58:51.76,0:58:57.00,csapp,,0,0,0,,and so let's look at at more detail at the actual code then 
Dialogue: 0,0:58:57.86,0:59:09.14,csapp,,0,0,0,,and so it turns out with the 64,x86-64 the arguments always come in some specific registers 
Dialogue: 0,0:59:09.52,0:59:11.44,csapp,,0,0,0,,and the ones to remember for today is 
Dialogue: 0,0:59:11.44,0:59:16.84,csapp,,0,0,0,,rdi will be the first argument register and rsi will be the second argument register 
Dialogue: 0,0:59:17.26,0:59:20.54,csapp,,0,0,0,,there can be up to six of these and we'll go into more of that later 
Dialogue: 0,0:59:21.44,0:59:25.24,csapp,,0,0,0,,so those two registers represent the values of xp and yp 
Dialogue: 0,0:59:25.24,0:59:31.28,csapp,,0,0,0,,those are set before when this before the function is actually begins executing 
Dialogue: 0,0:59:31.28,0:59:34.28,csapp,,0,0,0,,that's set by the part of the code that calls this function 
Dialogue: 0,0:59:35.90,0:59:41.58,csapp,,0,0,0,,and those will be pointers so what they are is they contain addresses that specifying locations in memory 
Dialogue: 0,0:59:43.20,0:59:47.26,csapp,,0,0,0,,and then within the code the compiler just came up with its own ideas of 
Dialogue: 0,0:59:47.26,0:59:52.60,csapp,,0,0,0,,how to use different registers for temporary data buy whatever 
Dialogue: 0,0:59:52.96,0:59:57.36,csapp,,0,0,0,,what's known as the register allocation algorithm it uses
Dialogue: 0,0:59:57.82,1:00:02.36,csapp,,0,0,0,,and we don't really care we just want to what we'll want to do is figure out what it's doing 
Dialogue: 0,1:00:03.64,1:00:11.20,csapp,,0,0,0,,and we'll see that a register is %rax is being used to hold the value t0 and %rax the value t1
Dialogue: 0,1:00:14.34,1:00:19.90,csapp,,0,0,0,,now so let's get actually concrete here and this is very detailed 
Dialogue: 0,1:00:19.96,1:00:22.64,csapp,,0,0,0,,but I think it's important that you understand 
Dialogue: 0,1:00:23.32,1:00:28.38,csapp,,0,0,0,,sort of you can almost simulate the execution of some instructions by yourself 
Dialogue: 0,1:00:29.04,1:00:31.08,csapp,,0,0,0,,you're going to really have to know this stuff
Dialogue: 0,1:00:31.68,1:00:34.44,csapp,,0,0,0,,so what each of these instructions is doing 
Dialogue: 0,1:00:34.44,1:00:38.06,csapp,,0,0,0,,and how it works and really have that wired into you pretty well 
Dialogue: 0,1:00:38.78,1:00:44.72,csapp,,0,0,0,,so let's make up an example let's imagine that the two addresses that are used for
Dialogue: 0,1:00:44.88,1:00:49.22,csapp,,0,0,0,,these two pointers are in 0x120 & 100 
Dialogue: 0,1:00:49.58,1:00:52.96,csapp,,0,0,0,,by the way those would not be typical addresses
Dialogue: 0,1:00:53.36,1:00:58.00,csapp,,0,0,0,, they're way too small a number but it's much easier to use them as an illustration 
Dialogue: 0,1:00:58.98,1:01:03.24,csapp,,0,0,0,,and let's suppose that one of them held the value 1 2 3 and the other 4 5 6 
Dialogue: 0,1:01:05.58,1:01:10.27,csapp,,0,0,0,,so the first instruction says use %rdi as an address
Dialogue: 0,1:01:10.86,1:01:15.00,csapp,,0,0,0,,copy from that memory location and store the result in register rax
Dialogue: 0,1:01:15.84,1:01:18.38,csapp,,0,0,0,,so %rdi is 120
Dialogue: 0,1:01:18.78,1:01:24.30,csapp,,0,0,0,,I'll read from that address I'll read the value 1 2 3 and store it and register rax
Dialogue: 0,1:01:24.64,1:01:26.60,csapp,,0,0,0,,these are all by the way 8 byte values 
Dialogue: 0,1:01:27.92,1:01:30.36,csapp,,0,0,0,,and I'm just sort of glossing over that part of it 
Dialogue: 0,1:01:30.36,1:01:37.00,csapp,,0,0,0,,but the Q refers to what in Intel terminology is a quad word 
Dialogue: 0,1:01:37.70,1:01:42.94,csapp,,0,0,0,,a word because it goes back to the 8086 is 16 bits 2 bytes
Dialogue: 0,1:01:43.94,1:01:52.98,csapp,,0,0,0,, a long word is 32 bits and a quad word is 64 bits
Dialogue: 0,1:01:53.06,1:01:56.80,csapp,,0,0,0,,that's just their terminology and we're stuck with it 
Dialogue: 0,1:01:58.26,1:02:01.44,csapp,,0,0,0,,ok so that one instruction had that effect
Dialogue: 0,1:02:02.12,1:02:09.20,csapp,,0,0,0,, the second instruction does the same thing but using rsi which holds 1 0 0 as an address 
Dialogue: 0,1:02:09.24,1:02:12.62,csapp,,0,0,0,,and so it copies for 456 into rdx
Dialogue: 0,1:02:14.34,1:02:19.36,csapp,,0,0,0,,and then the third instruction is writing back to memory 
Dialogue: 0,1:02:19.44,1:02:21.58,csapp,,0,0,0,,so its source is register rdx 
Dialogue: 0,1:02:22.78,1:02:27.56,csapp,,0,0,0,,the destination has the address of rdi which is 120
Dialogue: 0,1:02:28.06,1:02:29.88,csapp,,0,0,0,,it's storing that back in memory 
Dialogue: 0,1:02:30.44,1:02:35.74,csapp,,0,0,0,,and finally the this fourth instruction does the other part of the right 
Dialogue: 0,1:02:36.38,1:02:40.50,csapp,,0,0,0,,so you see these four instructions to read from memory into registers 
Dialogue: 0,1:02:40.58,1:02:44.48,csapp,,0,0,0,,two of them wrote from registers back to memory and that's the whole function 
Dialogue: 0,1:02:47.36,1:02:52.00,csapp,,0,0,0,,and you can see it this move instruction is doing all the work here 
Dialogue: 0,1:02:55.08,1:03:00.36,csapp,,0,0,0,,so we've shown that example just showed this very simple memory referencing
Dialogue: 0,1:03:00.46,1:03:03.30,csapp,,0,0,0,,that's designated by the parentheses 
Dialogue: 0,1:03:03.72,1:03:07.84,csapp,,0,0,0,,and as I mentioned you can do a version where you put a displacement there too
Dialogue: 0,1:03:08.90,1:03:11.96,csapp,,0,0,0,,and in fact there's a much more elaborate form and 
Dialogue: 0,1:03:11.96,1:03:15.48,csapp,,0,0,0,,we'll see that this is useful for implementing array references 
Dialogue: 0,1:03:16.16,1:03:18.68,csapp,,0,0,0,,where there can be actually two registers involved 
Dialogue: 0,1:03:21.94,1:03:25.92,csapp,,0,0,0,,and there can be a displacement which is a constant offset 
Dialogue: 0,1:03:26.36,1:03:29.48,csapp,,0,0,0,,and a scale factor which will be 1,2,4,8 
Dialogue: 0,1:03:30.44,1:03:35.50,csapp,,0,0,0,,and the general idea  of it is to take our register 
Dialogue: 0,1:03:35.76,1:03:40.26,csapp,,0,0,0,,that I'm referring to as R sub I that's known as an index register 
Dialogue: 0,1:03:40.64,1:03:42.92,csapp,,0,0,0,,you multiply it by the scale factor 
Dialogue: 0,1:03:44.96,1:03:49.90,csapp,,0,0,0,,I'll you add the value of Rb register Rb
Dialogue: 0,1:03:50.52,1:03:53.18,csapp,,0,0,0,,and you also add the constant displacement 
Dialogue: 0,1:03:53.68,1:03:59.96,csapp,,0,0,0,,and these have a Rb refers to base our eyes index and S is scale 
Dialogue: 0,1:04:00.22,1:04:03.86,csapp,,0,0,0,,and it turns out this will be the sort of natural way to implement array referencing
Dialogue: 0,1:04:03.90,1:04:07.02,csapp,,0,0,0,, it will make a lot more sense when we talk about arrays 
Dialogue: 0,1:04:07.64,1:04:11.30,csapp,,0,0,0,,but basically you can think of is if this is an array index 
Dialogue: 0,1:04:12.72,1:04:17.80,csapp,,0,0,0,,I have to typically scale it by however many bytes my data type is
Dialogue: 0,1:04:17.80,1:04:23.40,csapp,,0,0,0,,so if it's an int I have to scale it by four if it's a long I have to scale it by eight 
Dialogue: 0,1:04:23.88,1:04:26.00,csapp,,0,0,0,,so that's where these scale factors will come in
Dialogue: 0,1:04:30.02,1:04:33.72,csapp,,0,0,0,,and basically the the format in the assembly code 
Dialogue: 0,1:04:33.72,1:04:39.52,csapp,,0,0,0,,lets you eliminate some of these fields if they're not being used
Dialogue: 0,1:04:40.08,1:04:44.76,csapp,,0,0,0,,so you'll and we already saw the single parenthesis a sort of a reduced version of this form 
Dialogue: 0,1:04:46.86,1:04:51.25,csapp,,0,0,0,,so let's just do some examples of these address computations
Dialogue: 0,1:04:52.04,1:04:56.96,csapp,,0,0,0,,and let's imagine that register rdx hold text f with three zeros 
Dialogue: 0,1:04:57.52,1:05:00.42,csapp,,0,0,0,,and rcx holds a one with two zeros 
Dialogue: 0,1:05:01.30,1:05:06.34,csapp,,0,0,0,,so if I rather than doing one at a time 
Dialogue: 0,1:05:06.34,1:05:12.02,csapp,,0,0,0,,you can see each of these I'm taking RDX which is 0xf000 + 0x8
Dialogue: 0,1:05:12.52,1:05:14.40,csapp,,0,0,0,,and so that's 0xf008
Dialogue: 0,1:05:15.06,1:05:18.78,csapp,,0,0,0,,here I'm adding together registers %rdx and %rcx 
Dialogue: 0,1:05:19.24,1:05:21.50,csapp,,0,0,0,,and that gives me 0xf100
Dialogue: 0,1:05:22.18,1:05:25.62,csapp,,0,0,0,,I'm doing the same here except that I'm scaling %rcx by 4 
Dialogue: 0,1:05:26.26,1:05:32.03,csapp,,0,0,0,,so 4*0x100 is 0x400 and I'm adding that to f
Dialogue: 0,1:05:33.90,1:05:38.46,csapp,,0,0,0,,and here I'm taking %rdx which is 0xf000
Dialogue: 0,1:05:38.96,1:05:43.10,csapp,,0,0,0,,if I double that I get 0x1e000
Dialogue: 0,1:05:43.12,1:05:47.74,csapp,,0,0,0,,if you think about shifting an F to the left 1 you get a 1 
Dialogue: 0,1:05:48.04,1:05:50.62,csapp,,0,0,0,,and then it goes 1 1 1 0 and
Dialogue: 0,1:05:51.90,1:05:52.84,csapp,,0,0,0,,and that's an e 
Dialogue: 0,1:05:53.54,1:05:57.22,csapp,,0,0,0,,ok and then I'm adding this displacement of 80 to it 
Dialogue: 0,1:05:57.74,1:06:02.94,csapp,,0,0,0,,so the point of this is all of this is arithmetic it's all using whatever is in the register
Dialogue: 0,1:06:03.84,1:06:07.52,csapp,,0,0,0,, and there's some rules for how you combine this and get an address 
Dialogue: 0,1:06:08.04,1:06:11.64,csapp,,0,0,0,,and then that's being used to either read or write some memory location 
Dialogue: 0,1:06:14.88,1:06:18.02,csapp,,0,0,0,,okay so now what is a final part of that today
Dialogue: 0,1:06:18.78,1:06:21.40,csapp,,0,0,0,, I'll go through some arithmetic 
Dialogue: 0,1:06:22.18,1:06:26.30,csapp,,0,0,0,,and one of the things that will be sure to confuse you and drive you crazy and 
Dialogue: 0,1:06:26.30,1:06:30.32,csapp,,0,0,0,,make you be sending email to the staff  for explanation 
Dialogue: 0,1:06:30.66,1:06:33.06,csapp,,0,0,0,,is an instruction called load effective address 
Dialogue: 0,1:06:34.68,1:06:37.46,csapp,,0,0,0,,and the reason is its purpose in life is to do 
Dialogue: 0,1:06:38.00,1:06:42.08,csapp,,0,0,0,,basically the ampersand operation of C to compute an address
Dialogue: 0,1:06:42.78,1:06:46.84,csapp,,0,0,0,,based on some whatever you want to compute an address from 
Dialogue: 0,1:06:48.30,1:06:54.38,csapp,,0,0,0,,but it also turns out to be a pretty handy way to do arithmetic and the C compiler likes to use it
Dialogue: 0,1:06:55.36,1:07:05.22,csapp,,0,0,0,, so in particular it looks the the format of it looks like a move instruction there's a source and a destination 
Dialogue: 0,1:07:06.18,1:07:08.38,csapp,,0,0,0,,but the destination has to be a register 
Dialogue: 0,1:07:09.40,1:07:12.74,csapp,,0,0,0,,and the source will be one of these memory references 
Dialogue: 0,1:07:14.84,1:07:16.68,csapp,,0,0,0,,so it looks like a move instruction 
Dialogue: 0,1:07:16.68,1:07:19.76,csapp,,0,0,0,,it looks like you're doing some address computation 
Dialogue: 0,1:07:19.76,1:07:23.36,csapp,,0,0,0,,then you're reading from memory and storing it to a register 
Dialogue: 0,1:07:23.76,1:07:27.94,csapp,,0,0,0,,but what it actually does is it does that address computation 
Dialogue: 0,1:07:28.34,1:07:33.44,csapp,,0,0,0,,and then it actually writes that address not the memory value 
Dialogue: 0,1:07:33.44,1:07:38.10,csapp,,0,0,0,,but the value of got that got computed directly to the register
Dialogue: 0,1:07:38.84,1:07:42.18,csapp,,0,0,0,, which is what you want to do here remember the ampersand operation is 
Dialogue: 0,1:07:42.76,1:07:45.80,csapp,,0,0,0,,give me the address of some place give me a pointer
Dialogue: 0,1:07:46.28,1:07:49.90,csapp,,0,0,0,,that designates some location 
Dialogue: 0,1:07:50.78,1:07:56.84,csapp,,0,0,0,,so for example this is fairly typical in C code if you say multiply X by 12 
Dialogue: 0,1:07:57.60,1:08:04.31,csapp,,0,0,0,,it will turn it into a address computation
Dialogue: 0,1:08:04.31,1:08:08.44,csapp,,0,0,0,,and this is just a clever way to compute three times %rdi
Dialogue: 0,1:08:09.36,1:08:13.07,csapp,,0,0,0,,it adds are %rdi + 2*%rdi
Dialogue: 0,1:08:13.07,1:08:16.60,csapp,,0,0,0,,so that's three times %rdi and stores it in %rax
Dialogue: 0,1:08:17.74,1:08:24.68,csapp,,0,0,0,,and then salq means shift left by two 
Dialogue: 0,1:08:24.96,1:08:28.70,csapp,,0,0,0,,and so you remember shifting left by two is like multiplying by four 
Dialogue: 0,1:08:29.20,1:08:39.52,csapp,,0,0,0,,so the first value computed 3*x. I shift that left four by two positions and I have 12*x
Dialogue: 0,1:08:39.52,1:08:45.64,csapp,,0,0,0,,so that's a very special the lea but you'll see it all over the place so you need to be ready for it 
Dialogue: 0,1:08:46.18,1:08:50.30,csapp,,0,0,0,,these other ones look more like what you'd expect for arithmetic instructions 
Dialogue: 0,1:08:50.30,1:08:55.14,csapp,,0,0,0,,they have names like add and subtract and multiply and so forth 
Dialogue: 0,1:08:55.56,1:08:58.92,csapp,,0,0,0,,and they all have the same general format that they have two arguments 
Dialogue: 0,1:09:00.00,1:09:04.15,csapp,,0,0,0,,and what's called the destination is actually also a source
Dialogue: 0,1:09:04.84,1:09:08.50,csapp,,0,0,0,,it's a little like in C if you say X plus equals Y 
Dialogue: 0,1:09:09.26,1:09:15.52,csapp,,0,0,0,,it's saying take the value of x add the value of Y and then store the result in X 
Dialogue: 0,1:09:15.52,1:09:18.12,csapp,,0,0,0,,and now the destination is like that 
Dialogue: 0,1:09:19.06,1:09:24.70,csapp,,0,0,0,,the other thing that's weird is that the operands are in the inverse order from where you'd expect them to be 
Dialogue: 0,1:09:25.42,1:09:29.78,csapp,,0,0,0,,so the source comes first in the destination comes last and that's important to remember 
Dialogue: 0,1:09:33.02,1:09:37.34,csapp,,0,0,0,,and other thing you'll see that there's nothing special here whether it's a 
Dialogue: 0,1:09:37.72,1:09:41.48,csapp,,0,0,0,,except that this is a arithmetic shift and this is a logical shift 
Dialogue: 0,1:09:42.20,1:09:44.34,csapp,,0,0,0,,of whether it's a signed or unsigned value 
Dialogue: 0,1:09:44.34,1:09:48.96,csapp,,0,0,0,,because you remember the bit level behavior of these two instructions is the same 
Dialogue: 0,1:09:52.26,1:09:54.66,csapp,,0,0,0,,and then there's a series of instructions that are used 
Dialogue: 0,1:09:54.96,1:10:01.62,csapp,,0,0,0,,that are just take one operand increment decrement a negate and not 
Dialogue: 0,1:10:02.36,1:10:07.06,csapp,,0,0,0,,not is not is like the tilde operation and see not the exclamation mark 
Dialogue: 0,1:10:09.04,1:10:10.80,csapp,,0,0,0,,so those are the basic instructions 
Dialogue: 0,1:10:11.34,1:10:14.40,csapp,,0,0,0,,and again now we can actually look at some programs and understand them 
Dialogue: 0,1:10:14.40,1:10:19.50,csapp,,0,0,0,,and here's one that just does a bunch of junk of arithmetic instructions 
Dialogue: 0,1:10:20.12,1:10:23.00,csapp,,0,0,0,,and it converts into the following assembly code 
Dialogue: 0,1:10:23.64,1:10:29.40,csapp,,0,0,0,,and you see it's using this lea instruction multiple times to do addition in various forms
Dialogue: 0,1:10:30.90,1:10:35.34,csapp,,0,0,0,,and it also has shifting  and it has multiplication
Dialogue: 0,1:10:35.92,1:10:39.38,csapp,,0,0,0,, you saw in the original code I just have addition and multiplication 
Dialogue: 0,1:10:40.54,1:10:46.38,csapp,,0,0,0,,here I have various instructions I only have one multiply here whereas I had two there 
Dialogue: 0,1:10:46.40,1:10:52.26,csapp,,0,0,0,,so the compiler is sort of scrambling things around trying to find clever ways to implement
Dialogue: 0,1:10:52.50,1:10:59.94,csapp,,0,0,0,,what you're asking for using less complex expensive less time-consuming instructions 
Dialogue: 0,1:11:02.90,1:11:07.80,csapp,,0,0,0,,and if you sort of go through this code carefully what you'll find is 
Dialogue: 0,1:11:09.40,1:11:14.55,csapp,,0,0,0,,that this instruction here corresponds to this computation of t1
Dialogue: 0,1:11:14.55,1:11:19.41,csapp,,0,0,0,,it's adding two values and giving it a new name it's putting in %rax
Dialogue: 0,1:11:19.88,1:11:27.56,csapp,,0,0,0,,similarly this one is adding Z to t1 and storing it back in %rax
Dialogue: 0,1:11:28.44,1:11:31.80,csapp,,0,0,0,,the x+4 doesn't show up directly here 
Dialogue: 0,1:11:32.46,1:11:35.42,csapp,,0,0,0,,it turns out what it does is it jumps right at head to here 
Dialogue: 0,1:11:35.44,1:11:37.84,csapp,,0,0,0,,and multiply Y by 48
Dialogue: 0,1:11:38.46,1:11:42.84,csapp,,0,0,0,, it does it by first computing 3y like we saw
Dialogue: 0,1:11:44.06,1:11:47.56,csapp,,0,0,0,,and computing shifting that left by 4 
Dialogue: 0,1:11:47.80,1:11:50.18,csapp,,0,0,0,,because 3 *16=48
Dialogue: 0,1:11:50.94,1:11:54.70,csapp,,0,0,0,,and then the 4 here that sin x plus 4 actually shows up here 
Dialogue: 0,1:11:55.44,1:12:02.42,csapp,,0,0,0,,it just uses the displacement field of this computation to add 4 to some other values 
Dialogue: 0,1:12:03.80,1:12:06.10,csapp,,0,0,0,,and so this is label then these comments show 
Dialogue: 0,1:12:06.10,1:12:09.34,csapp,,0,0,0,,how these correspond to the program and these registers show it 
Dialogue: 0,1:12:09.94,1:12:12.16,csapp,,0,0,0,,so the important thing to get from here 
Dialogue: 0,1:12:12.16,1:12:15.56,csapp,,0,0,0,,you will want to actually go back through this and make sure you believe 
Dialogue: 0,1:12:16.10,1:12:19.10,csapp,,0,0,0,,that the comments are correct 
Dialogue: 0,1:12:20.68,1:12:24.10,csapp,,0,0,0,,but it's very important for you to figure out this lea instruction
Dialogue: 0,1:12:24.10,1:12:26.70,csapp,,0,0,0,,otherwise you're just going to be hopelessly confused
Dialogue: 0,1:12:27.24,1:12:30.34,csapp,,0,0,0,,and it's also important to understand that the the code 
Dialogue: 0,1:12:30.34,1:12:34.60,csapp,,0,0,0,,that gets generated will correctly implement your function 
Dialogue: 0,1:12:34.88,1:12:41.16,csapp,,0,0,0,,but it might not exactly replicate at a low level the the exact sequence of operations 
Dialogue: 0,1:12:41.16,1:12:42.70,csapp,,0,0,0,,you specified at a high level 
Dialogue: 0,1:12:44.82,1:12:53.26,csapp,,0,0,0,,so that will just to summarize then you've already gotten a glimpse then of what this very odd a world of machine programming is 
Dialogue: 0,1:12:53.26,1:12:56.00,csapp,,0,0,0,,and how different it is from C code already 
Dialogue: 0,1:12:57.26,1:13:03.68,csapp,,0,0,0,,it's all so you've already seen that x86 is weird like I said it's English 
Dialogue: 0,1:13:04.18,1:13:11.18,csapp,,0,0,0,,it's not a Latin it's not well designed and but you just got to deal with that 
Dialogue: 0,1:13:11.78,1:13:19.22,csapp,,0,0,0,,so that's your beginning to machine level programming.thanks a lot.
