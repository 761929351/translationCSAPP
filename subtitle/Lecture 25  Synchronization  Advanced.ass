[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Audio File: ../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video File: ../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 904
Active Line: 915
Video Position: 144672

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: newcsapp,Source Han Sans CN,34,&H00D6DA3A,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.70,csapp,,0,0,0,,well good afternoon everybody 
Dialogue: 0,0:00:02.68,0:00:07.94,csapp,,0,0,0,,welcome good to see you and welcome to our viewers on video as well 
Dialogue: 0,0:00:09.54,0:00:15.96,csapp,,0,0,0,,okay so today we're going to look at some additional issues around the problem of synchronizing threaded programs 
Dialogue: 0,0:00:17.72,0:00:21.44,csapp,,0,0,0,,first so let's review from last time of a few of the concepts 
Dialogue: 0,0:00:22.32,0:00:29.56,csapp,,0,0,0,,so recall that a semaphore is a non non- global synchronization variable
Dialogue: 0,0:00:29.56,0:00:31.36,csapp,,0,0,0,, it's manipulated by P and V operations 
Dialogue: 0,0:00:32.28,0:00:36.92,csapp,,0,0,0,,and the P operation takes as an argument a semaphore
Dialogue: 0,0:00:38.70,0:00:44.96,csapp,,0,0,0,, if the semaphore values nonzero it decrements the semaphore  and then continues
Dialogue: 0,0:00:45.74,0:00:48.08,csapp,,0,0,0,, if the if the semaphore values zero 
Dialogue: 0,0:00:49.58,0:00:55.98,csapp,,0,0,0,,then it blocks waiting for that that semaphore value to be incremented by a V operation 
Dialogue: 0,0:00:56.86,0:01:01.82,csapp,,0,0,0,, after the V operation increments after some V operation increments the semaphore 
Dialogue: 0,0:01:03.24,0:01:08.92,csapp,,0,0,0,,the P operation continues by decrementing s and then returning control to the caller
Dialogue: 0,0:01:10.06,0:01:12.46,csapp,,0,0,0,,the V operation never blocks
Dialogue: 0,0:01:14.00,0:01:17.66,csapp,,0,0,0,, it it first it increments the semaphore value s 
Dialogue: 0,0:01:18.42,0:01:22.94,csapp,,0,0,0,,and then it looks in the queue of four to see if there's any processes that are blocked 
Dialogue: 0,0:01:23.10,0:01:25.96,csapp,,0,0,0,,waiting for that some afford to be nonzero 
Dialogue: 0,0:01:27.66,0:01:33.52,csapp,,0,0,0,,if if there are then it selects one of those  using some unspecified criteria 
Dialogue: 0,0:01:34.08,0:01:36.14,csapp,,0,0,0,,and then it restarts that 
Dialogue: 0,0:01:38.12,0:01:43.96,csapp,,0,0,0,,it restarts that thread that's or that P operation that's waiting waiting on the semaphore 
Dialogue: 0,0:01:47.72,0:01:51.38,csapp,,0,0,0,,okay and then this the semantics of the P and V 
Dialogue: 0,0:01:51.94,0:01:55.70,csapp,,0,0,0,,ensure that semaphore values are always greater than or equal to zero 
Dialogue: 0,0:01:57.62,0:02:04.24,csapp,,0,0,0,,now the first thing we saw how to protect shared variables by by using a semaphore called 
Dialogue: 0,0:02:04.24,0:02:11.74,csapp,,0,0,0,,the mutex that guarantees mutually exclusive access to the critical sections that are updating that
Dialogue: 0,0:02:12.48,0:02:14.62,csapp,,0,0,0,,those variables are structures 
Dialogue: 0,0:02:15.64,0:02:18.84,csapp,,0,0,0,,and and the the way that we do this is very simple 
Dialogue: 0,0:02:18.84,0:02:25.58,csapp,,0,0,0,,we initialize the mutex to one and then surround the critical section with a P and a V 
Dialogue: 0,0:02:27.74,0:02:30.06,csapp,,0,0,0,,now there's a there's other ways that we can 
Dialogue: 0,0:02:30.06,0:02:34.64,csapp,,0,0,0,,so so here here's an example where we're using semaphore is to provide mutual exclusion 
Dialogue: 0,0:02:35.76,0:02:43.32,csapp,,0,0,0,,but we can also use seminar semaphores to coordinate access to shared data structures in different ways
Dialogue: 0,0:02:44.16,0:02:49.82,csapp,,0,0,0,,and so the idea here before we were using the the semaphore just to protect the access to a shared variable
Dialogue: 0,0:02:50.36,0:02:58.24,csapp,,0,0,0,, but we can also coordinate access in different ways by keep and this in this in these in these kind of scenarios 
Dialogue: 0,0:02:58.28,0:03:04.14,csapp,,0,0,0,, we're using the semaphore to keep track of State to count to count things to keep track of State 
Dialogue: 0,0:03:04.58,0:03:10.16,csapp,,0,0,0,,and to notify other other threads of changes in state okay so it's a very different usage model 
Dialogue: 0,0:03:11.02,0:03:17.86,csapp,,0,0,0,,and two classic examples that we're going to look at are the producer consumer problem and a readers writers problem
Dialogue: 0,0:03:18.82,0:03:20.44,csapp,,0,0,0,, so let's look at producer consumer first 
Dialogue: 0,0:03:21.62,0:03:24.90,csapp,,0,0,0,,so the idea in the producer consumer problem is that
Dialogue: 0,0:03:25.42,0:03:28.94,csapp,,0,0,0,,you have a resource in the form of a buffer 
Dialogue: 0,0:03:29.66,0:03:32.44,csapp,,0,0,0,,the buffer has a bounded size 
Dialogue: 0,0:03:32.50,0:03:36.60,csapp,,0,0,0,,so it consists of n slots and each slot can hold an item 
Dialogue: 0,0:03:39.08,0:03:40.80,csapp,,0,0,0,,okay the there's a producer thread 
Dialogue: 0,0:03:41.44,0:03:42.70,csapp,,0,0,0,,which produces items 
Dialogue: 0,0:03:44.52,0:03:46.48,csapp,,0,0,0,,and then inserts them into the buffer 
Dialogue: 0,0:03:47.50,0:03:49.02,csapp,,0,0,0,,and there's a consumer thread
Dialogue: 0,0:03:49.56,0:03:52.82,csapp,,0,0,0,, that retrieves removes items from the buffer 
Dialogue: 0,0:03:52.90,0:03:57.74,csapp,,0,0,0,, and then consumes them by acting on them in some way processing on them in some way 
Dialogue: 0,0:03:59.02,0:04:04.12,csapp,,0,0,0,,so the the synchronization variable the synchronization pattern is that 
Dialogue: 0,0:04:04.84,0:04:07.02,csapp,,0,0,0,,the producer waits for an empty slot right 
Dialogue: 0,0:04:07.02,0:04:12.76,csapp,,0,0,0,, so if there's if the buffer is full the producer can't insert an item into the buffer 
Dialogue: 0,0:04:13.52,0:04:15.08,csapp,,0,0,0,,so it waits for an empty slot 
Dialogue: 0,0:04:16.10,0:04:20.18,csapp,,0,0,0,,and then when it finds an empty slot when an empty slot becomes available 
Dialogue: 0,0:04:20.48,0:04:22.56,csapp,,0,0,0,,it inserts the item into the buffer 
Dialogue: 0,0:04:23.24,0:04:29.66,csapp,,0,0,0,,and then it notifies the consumer that there's now a new item in the in the in the buffer 
Dialogue: 0,0:04:31.20,0:04:37.42,csapp,,0,0,0,,the consumer of course that has to wait  for an item to show up in the buffer right 
Dialogue: 0,0:04:37.64,0:04:41.44,csapp,,0,0,0,, otherwise I mean you can't remove an item from an empty buffer 
Dialogue: 0,0:04:41.80,0:04:46.36,csapp,,0,0,0,,so it has to wait for for an item to be available in the buffer
Dialogue: 0,0:04:46.84,0:04:51.24,csapp,,0,0,0,,and when an item becomes available it removes it from the buffer 
Dialogue: 0,0:04:51.64,0:04:55.54,csapp,,0,0,0,,and then notifies the the producer that there's now an available slot 
Dialogue: 0,0:04:58.80,0:05:02.06,csapp,,0,0,0,,okay so this
Dialogue: 0,0:04:59.01,0:05:06.18,csapp,,0,0,0,,actually this very simple pattern is actually really really useful and shows up in a lot of applications 
Dialogue: 0,0:05:06.70,0:05:08.64,csapp,,0,0,0,,so for example a multimedia application
Dialogue: 0,0:05:09.14,0:05:17.82,csapp,,0,0,0,, in a multimedia application the producer might be producing say MPEG MPEG frames in it in a video 
Dialogue: 0,0:05:18.22,0:05:24.28,csapp,,0,0,0,,and a consumer would be consuming those those MPEG frames and then painting the screen  appropriately
Dialogue: 0,0:05:24.90,0:05:29.08,csapp,,0,0,0,,another important application is in graphical user interfaces 
Dialogue: 0,0:05:29.92,0:05:34.52,csapp,,0,0,0,,so graphical user interfaces are typically implemented using this producer-consumer model 
Dialogue: 0,0:05:35.26,0:05:44.86,csapp,,0,0,0,,where the mouse clicks,motions and the in the of the mouse keyboard clicks
Dialogue: 0,0:05:45.30,0:05:46.88,csapp,,0,0,0,,those are all recorded as events 
Dialogue: 0,0:05:47.26,0:05:52.74,csapp,,0,0,0,,they're detected by the system recorded as events and placed into a some kind of a queue 
Dialogue: 0,0:05:53.70,0:05:58.94,csapp,,0,0,0,,and then up various other parts of the system retrieve items from the queue and and react to them 
Dialogue: 0,0:05:58.96,0:06:01.06,csapp,,0,0,0,,so for example the graphic system will retrieve 
Dialogue: 0,0:06:01.72,0:06:07.26,csapp,,0,0,0,,events like Mouse events and mouse movements mouse clicks 
Dialogue: 0,0:06:07.72,0:06:10.44,csapp,,0,0,0,,and it will paint the screen accordingly right a soda little
Dialogue: 0,0:06:11.02,0:06:17.16,csapp,,0,0,0,, it will reflect it will repaint the screen so that the  two so that to show you that the cursor is moving 
Dialogue: 0,0:06:17.80,0:06:21.20,csapp,,0,0,0,,right or if you change the focus it will it will repaint it 
Dialogue: 0,0:06:21.90,0:06:25.68,csapp,,0,0,0,,so it's it's a very very common model
Dialogue: 0,0:06:25.68,0:06:31.70,csapp,,0,0,0,,and as we'll see later multi-threaded we can build multi-threaded concurrent servers using this this model 
Dialogue: 0,0:06:34.48,0:06:38.56,csapp,,0,0,0,,so let's see how we would implement producer/consumer on an n-element buffer
Dialogue: 0,0:06:39.52,0:06:47.16,csapp,,0,0,0,,so this the implementation requires a mutex  to guarantee mutually exclusive access to the resource of course
Dialogue: 0,0:06:47.84,0:06:52.06,csapp,,0,0,0,, and then it requires then two other semaphores counting semaphores
Dialogue: 0,0:06:53.74,0:06:58.48,csapp,,0,0,0,, slots is a semaphore that counts the available slots in the buffer 
Dialogue: 0,0:06:59.10,0:07:02.61,csapp,,0,0,0,,and items is counts the available items okay
Dialogue: 0,0:07:03.38,0:07:07.90,csapp,,0,0,0,,and we've can implement it with this this package called s buff 
Dialogue: 0,0:07:10.98,0:07:16.80,csapp,,0,0,0,,so S buff the s buff package defines a type called S buff 
Dialogue: 0,0:07:17.06,0:07:24.12,csapp,,0,0,0,,underscore T that packages up all of the data structures that are needed to implement the the shared buffer
Dialogue: 0,0:07:24.80,0:07:30.12,csapp,,0,0,0,, so there's a pointer to the the buffer which we were going to implement as an array and 
Dialogue: 0,0:07:30.62,0:07:34.52,csapp,,0,0,0,,and we'll implement a circular buffer on this array
Dialogue: 0,0:07:36.26,0:07:39.59,csapp,,0,0,0,, the maximum number of slots n so the size of the buffer
Dialogue: 0,0:07:40.14,0:07:47.50,csapp,,0,0,0,, and then two pointers front and rear to keep track of the the front and rear of the of the buffer 
Dialogue: 0,0:07:47.50,0:07:50.57,csapp,,0,0,0,,so to keep track of the first and last items in the buffer 
Dialogue: 0,0:07:51.26,0:07:55.56,csapp,,0,0,0,,and then the three semaphores the mutex and in the two counting semaphores 
Dialogue: 0,0:07:56.48,0:07:59.84,csapp,,0,0,0,,and then the package consists of these four public functions 
Dialogue: 0,0:08:00.36,0:08:08.56,csapp,,0,0,0,,S buff an it which creates the is called once to create the the buffer and initialize everything
Dialogue: 0,0:08:09.98,0:08:14.44,csapp,,0,0,0,,allocate the space and initialize things and the D in it which which frees up the space 
Dialogue: 0,0:08:15.38,0:08:18.84,csapp,,0,0,0,,and then a function to insert an item 
Dialogue: 0,0:08:19.42,0:08:24.08,csapp,,0,0,0,,into the queue and a function to remove an item from a queue and return that item 
Dialogue: 0,0:08:24.88,0:08:26.42,csapp,,0,0,0,,so in this case items are just in
Dialogue: 0,0:08:31.30,0:08:38.70,csapp,,0,0,0,,so to create the to initialize the this buffer 
Dialogue: 0,0:08:39.28,0:08:44.58,csapp,,0,0,0,,with n slots we first allocate the space for the buffer and n n 
Dialogue: 0,0:08:45.38,0:08:50.80,csapp,,0,0,0,,we set the we set the size to be the value n that was passed in 
Dialogue: 0,0:08:52.72,0:08:58.02,csapp,,0,0,0,,we indicate the empty buffer by setting front-and-rear to be zero 
Dialogue: 0,0:08:58.78,0:09:03.20,csapp,,0,0,0,,okay and so whenever front and rear are zero that's we have an empty buffer
Dialogue: 0,0:09:04.34,0:09:06.70,csapp,,0,0,0,,and then we initialize the three semaphore
Dialogue: 0,0:09:06.70,0:09:11.30,csapp,,0,0,0,, so the mutex like all meu Texas is initialized to 1
Dialogue: 0,0:09:13.32,0:09:19.48,csapp,,0,0,0,, the slot semaphore which keeps track of the number of available slots is initialized to N 
Dialogue: 0,0:09:20.38,0:09:23.20,csapp,,0,0,0,,and the item semaphore is initialized to zero 
Dialogue: 0,0:09:25.18,0:09:31.20,csapp,,0,0,0,,okay and D and it is really simple it just frees up the the heap space that we allocated 
Dialogue: 0,0:09:33.10,0:09:36.74,csapp,,0,0,0,,okay so now let's look at how we insert an item into the buffer 
Dialogue: 0,0:09:36.94,0:09:43.18,csapp,,0,0,0,,so we call we want to insert this integer item into this buffer pointed at by SP 
Dialogue: 0,0:09:44.74,0:09:49.70,csapp,,0,0,0,,so first the thread waits for an available slot 
Dialogue: 0,0:09:50.12,0:09:54.52,csapp,,0,0,0,,okay by doing a P on the slot sim before alright so P will block
Dialogue: 0,0:09:55.50,0:09:59.44,csapp,,0,0,0,, until the slots is greater than or equal to one 
Dialogue: 0,0:10:01.14,0:10:02.82,csapp,,0,0,0,,okay once there's an available slot 
Dialogue: 0,0:10:03.76,0:10:13.76,csapp,,0,0,0,,then it if then it's going to it's going to update the the rear of the of the buffer
Dialogue: 0,0:10:14.26,0:10:16.74,csapp,,0,0,0,,okay so we're going to put this item on to the rear of the buffer 
Dialogue: 0,0:10:17.08,0:10:21.56,csapp,,0,0,0,, and so it needs to protect that access to that shared buffer  with the mutex 
Dialogue: 0,0:10:22.76,0:10:26.00,csapp,,0,0,0,,then it does the bike bike by doing a P on the mutex 
Dialogue: 0,0:10:26.78,0:10:29.92,csapp,,0,0,0,,updating updating our rear pointer
Dialogue: 0,0:10:30.20,0:10:37.18,csapp,,0,0,0,,okay so we pre increment it so we increment the rear pointer and then take take the mod of that n
Dialogue: 0,0:10:37.80,0:10:43.86,csapp,,0,0,0,,2 to compute the index that we're going to insert the item
Dialogue: 0,0:10:44.80,0:10:47.74,csapp,,0,0,0,,okay then we do a V on the mutex 
Dialogue: 0,0:10:48.20,0:10:54.54,csapp,,0,0,0,,okay so that other other threads can can update that  that shared data structure
Dialogue: 0,0:10:55.52,0:11:00.56,csapp,,0,0,0,,and then we do a V on the number of items to notify any consumers 
Dialogue: 0,0:11:00.56,0:11:02.86,csapp,,0,0,0,,that there's now an item in the in the buffer
Dialogue: 0,0:11:04.68,0:11:12.48,csapp,,0,0,0,,so this this V is kind of interesting you think it was kind of like a signal right so you're sort of signaling consumers that now 
Dialogue: 0,0:11:13.14,0:11:14.86,csapp,,0,0,0,,some event has occurred in the system 
Dialogue: 0,0:11:18.08,0:11:21.76,csapp,,0,0,0,,now to remove an item it's it's symmetric but instead of
Dialogue: 0,0:11:22.46,0:11:26.48,csapp,,0,0,0,,instead of operating on the slots that before it operates on the items semaphore
Dialogue: 0,0:11:27.30,0:11:33.88,csapp,,0,0,0,, so to remove an item a consumer first does a P  on the items semaphore 
Dialogue: 0,0:11:33.94,0:11:38.78,csapp,,0,0,0,,so this now is waiting for an available item it's waiting for the semaphore to be greater than equal to one 
Dialogue: 0,0:11:39.96,0:11:43.80,csapp,,0,0,0,,when that happens then the P the P returns 
Dialogue: 0,0:11:44.44,0:11:49.00,csapp,,0,0,0,,and then we do we do the update protected by a mutex 
Dialogue: 0,0:11:49.62,0:11:54.40,csapp,,0,0,0,,by pre-incrementing front taking the mod n 
Dialogue: 0,0:11:54.86,0:12:03.70,csapp,,0,0,0,,and then reading that value and returning it and placing it into this local local variable item
Dialogue: 0,0:12:04.50,0:12:06.22,csapp,,0,0,0,,then we release the mutex 
Dialogue: 0,0:12:07.82,0:12:10.04,csapp,,0,0,0,,and then we do a V on the number of slots which 
Dialogue: 0,0:12:10.48,0:12:15.50,csapp,,0,0,0,,which is an announcement to the to any producers that there's now a new available slot 
Dialogue: 0,0:12:19.54,0:12:20.70,csapp,,0,0,0,,so any questions about that
Dialogue: 0,0:12:24.72,0:12:26.32,csapp,,0,0,0,,so it's a little more subtle 
Dialogue: 0,0:12:26.56,0:12:31.28,csapp,,0,0,0,,this looks really simple but like all concurrency problems it's actually very subtle
Dialogue: 0,0:12:33.26,0:12:39.64,csapp,,0,0,0,, so you can have potential you can have many producers and many many consumers all operating on the same 
Dialogue: 0,0:12:40.36,0:12:42.26,csapp,,0,0,0,,you know the same the same shared buffer 
Dialogue: 0,0:12:44.32,0:12:47.70,csapp,,0,0,0,,so this so what would happen if
Dialogue: 0,0:12:48.84,0:12:52.02,csapp,,0,0,0,, if we had two two consumers did 
Dialogue: 0,0:12:52.58,0:12:56.84,csapp,,0,0,0,,a a P on this item semaphore at the exact same time say we're running on two cores 
Dialogue: 0,0:12:57.68,0:13:01.68,csapp,,0,0,0,,and and we have two threads and they each each execute that P 
Dialogue: 0,0:13:03.76,0:13:07.84,csapp,,0,0,0,,at the same time on that that same that same item semaphore 
Dialogue: 0,0:13:08.72,0:13:14.30,csapp,,0,0,0,,okay so even even though they access it at the same time the kernel will make sure that one of them will execute first 
Dialogue: 0,0:13:14.58,0:13:18.40,csapp,,0,0,0,,okay so the kernel will serialize  those P operations 
Dialogue: 0,0:13:20.40,0:13:25.00,csapp,,0,0,0,,and it there's no telling which one gets it first but whoever acts whoever runs 
Dialogue: 0,0:13:25.40,0:13:29.46,csapp,,0,0,0,,there P first will will decrement this
Dialogue: 0,0:13:29.96,0:13:31.48,csapp,,0,0,0,, this item semaphore 
Dialogue: 0,0:13:33.44,0:13:35.92,csapp,,0,0,0,,and then when the next when the next thread executes 
Dialogue: 0,0:13:36.26,0:13:40.78,csapp,,0,0,0,,its P items will either be zero or nonzero 
Dialogue: 0,0:13:41.34,0:13:45.28,csapp,,0,0,0,,okay as a result so somebody wins there's kind of a ton of like a controlled race 
Dialogue: 0,0:13:45.72,0:13:50.44,csapp,,0,0,0,,and somebody wins the race always wins the race because the kernel is serializing 
Dialogue: 0,0:13:50.84,0:13:54.94,csapp,,0,0,0,,these P operations and it's executing them atomically okay
Dialogue: 0,0:13:58.46,0:14:06.68,csapp,,0,0,0,,okay now the the there's a generalization of the mutual exclusion problem called the reader writer problem
Dialogue: 0,0:14:07.30,0:14:10.22,csapp,,0,0,0,,so with with the mutual mutual exclusion problem 
Dialogue: 0,0:14:10.86,0:14:19.50,csapp,,0,0,0,,we were guaranteeing each thread mutually exclusive access to to its critical section
Dialogue: 0,0:14:19.50,0:14:23.82,csapp,,0,0,0,, that's updating a particular resource or accessing a particular resource 
Dialogue: 0,0:14:23.82,0:14:27.64,csapp,,0,0,0,,and we did this the exact same way whether that access was a read or write 
Dialogue: 0,0:14:29.34,0:14:31.94,csapp,,0,0,0,,okay but that's that's overly conservative in this case 
Dialogue: 0,0:14:33.72,0:14:39.48,csapp,,0,0,0,,because we could if all we were doing if we had multiple threads that were just reading the resource 
Dialogue: 0,0:14:40.30,0:14:44.42,csapp,,0,0,0,,there would be no reason to do Ps and Vs on that resource or if we're not changing 
Dialogue: 0,0:14:45.50,0:14:50.24,csapp,,0,0,0,,if we're not changing the resource for just reading it and there's nobody else writing it 
Dialogue: 0,0:14:51.12,0:14:53.76,csapp,,0,0,0,,then then there's no need to protect right so it
Dialogue: 0,0:14:54.42,0:15:03.04,csapp,,0,0,0,,for readers we can have as many readers as we want all at the same time reading reading the the resource the variable or set of variables 
Dialogue: 0,0:15:04.74,0:15:07.20,csapp,,0,0,0,,and there's no need for any kind of synchronization at all 
Dialogue: 0,0:15:08.08,0:15:14.40,csapp,,0,0,0,,okay so the producer consumer is sort of a generalization of that mutual exclusion problem 
Dialogue: 0,0:15:14.70,0:15:17.84,csapp,,0,0,0,,which enforces mutual exclusion only when it's absolutely necessary 
Dialogue: 0,0:15:18.46,0:15:23.66,csapp,,0,0,0,,okay so there can be is there there can be as many readers reading the resource 
Dialogue: 0,0:15:23.68,0:15:25.40,csapp,,0,0,0,,but when a writer wants to write then it
Dialogue: 0,0:15:26.25,0:15:28.74,csapp,,0,0,0,, it has to have mutual exclusive access to the resource 
Dialogue: 0,0:15:34.62,0:15:38.18,csapp,,0,0,0,,okay so this is a kind of thing this is also a very useful pattern 
Dialogue: 0,0:15:38.78,0:15:44.54,csapp,,0,0,0,,you have in an online airline reservation system you have multiple clients accessing a shared database 
Dialogue: 0,0:15:45.60,0:15:49.44,csapp,,0,0,0,,okay so as long as those clients are reading the database you can have 
Dialogue: 0,0:15:50.06,0:15:54.90,csapp,,0,0,0,,they can all be reading at the same time but as soon as somebody wants to make a reservation and update the database
Dialogue: 0,0:15:55.52,0:15:59.16,csapp,,0,0,0,, then that update has to happen a mutually exclusive way 
Dialogue: 0,0:16:00.90,0:16:05.40,csapp,,0,0,0,,you know if you had also if you had like any kind of shared data structure like a cache 
Dialogue: 0,0:16:06.54,0:16:11.14,csapp,,0,0,0,,in a in a concurrent proxy like that you're going to be writing soon 
Dialogue: 0,0:16:11.66,0:16:13.72,csapp,,0,0,0,,or if you haven't already started
Dialogue: 0,0:16:15.04,0:16:17.52,csapp,,0,0,0,, that cache is being shared by multiple threads 
Dialogue: 0,0:16:18.24,0:16:20.84,csapp,,0,0,0,,and multiple threads may be reading that cache 
Dialogue: 0,0:16:21.38,0:16:26.08,csapp,,0,0,0,,but when some when you when you get a new page and you want to cache it
Dialogue: 0,0:16:26.86,0:16:32.14,csapp,,0,0,0,,then that that that constitutes a right and that right needs to happen in our mutually exclusive way
Dialogue: 0,0:16:33.72,0:16:37.12,csapp,,0,0,0,, now the initial research the researchers that 
Dialogue: 0,0:16:40.12,0:16:42.60,csapp,,0,0,0,,that pose this readers writers problems 
Dialogue: 0,0:16:43.88,0:16:48.78,csapp,,0,0,0,,in define sort of several classes of reader writer problems 
Dialogue: 0,0:16:49.30,0:16:56.74,csapp,,0,0,0,,the first reader writer readers writers problems is an implementation that favors readers right 
Dialogue: 0,0:16:57.72,0:17:01.10,csapp,,0,0,0,,so the idea is that no reader should be kept waiting
Dialogue: 0,0:17:02.98,0:17:13.42,csapp,,0,0,0,,right unless an a writer already has a P as has sort of acquired the lock on that or the mutex on that on that resource 
Dialogue: 0,0:17:14.70,0:17:16.46,csapp,,0,0,0,,so it in this case 
Dialogue: 0,0:17:17.24,0:17:21.76,csapp,,0,0,0,,you know say there's a writer waiting to get to acquire the mutex 
Dialogue: 0,0:17:22.06,0:17:23.70,csapp,,0,0,0,,and another reader comes in 
Dialogue: 0,0:17:24.34,0:17:27.54,csapp,,0,0,0,,then in this implementation that reader would give priority over the writer 
Dialogue: 0,0:17:28.30,0:17:34.02,csapp,,0,0,0,,and it would be able to to read the to add to do its read 
Dialogue: 0,0:17:34.38,0:17:35.66,csapp,,0,0,0,,and the writer would have to wait 
Dialogue: 0,0:17:36.68,0:17:43.05,csapp,,0,0,0,,and so of court now if multiple readers keep coming in then this could starve out the writer right that
Dialogue: 0,0:17:43.58,0:17:48.14,csapp,,0,0,0,,so a writer could be starved sort of indefinitely waiting for all these readers to finish 
Dialogue: 0,0:17:49.88,0:17:53.68,csapp,,0,0,0,,and it's just based on you know based based on
Dialogue: 0,0:17:54.82,0:17:59.36,csapp,,0,0,0,, how the operating system decides to schedule these these various reader reader threads 
Dialogue: 0,0:18:00.94,0:18:06.57,csapp,,0,0,0,,the the writer could be could be starved out so that's what that's what we mean by when we say that it favors readers
Dialogue: 0,0:18:07.22,0:18:14.68,csapp,,0,0,0,,now the second reader saris problem is the sort of the opposite of that so it favors writers right 
Dialogue: 0,0:18:14.90,0:18:18.52,csapp,,0,0,0,,so any once a writer is ready to to write
Dialogue: 0,0:18:18.54,0:18:21.22,csapp,,0,0,0,, then it gets priority over any waiting readers 
Dialogue: 0,0:18:21.58,0:18:25.62,csapp,,0,0,0,, so in in this case if we have if we have multiple writers
Dialogue: 0,0:18:26.10,0:18:28.92,csapp,,0,0,0,, that want to write they could starve out readers 
Dialogue: 0,0:18:32.76,0:18:39.52,csapp,,0,0,0,,and now there's there's other variants that sort of deal with this starvation issue  potential starvation issue 
Dialogue: 0,0:18:39.52,0:18:41.88,csapp,,0,0,0,,but we won't look at them here 
Dialogue: 0,0:18:43.38,0:18:47.58,csapp,,0,0,0,,so the let's look at the solution to the first readers writers problem 
Dialogue: 0,0:18:50.62,0:18:56.84,csapp,,0,0,0,,so write initially a thread is either a reader in this sort of simplification  or it's a writer
Dialogue: 0,0:18:59.44,0:19:01.76,csapp,,0,0,0,, if we look at the writers this is pretty simple 
Dialogue: 0,0:19:01.76,0:19:09.20,csapp,,0,0,0,,it's just the writers are just doing a peon this semaphore
Dialogue: 0,0:19:09.40,0:19:17.66,csapp,,0,0,0,,so this this the semaphore W is the sort of serves as like a mutex that protects the resource  for writer 
Dialogue: 0,0:19:17.72,0:19:25.74,csapp,,0,0,0,,so it it ensures that there's at most one writer at any time executing its critical section 
Dialogue: 0,0:19:26.54,0:19:34.00,csapp,,0,0,0,,and it does that by just this this very from this familiar P followed followed by a V
Dialogue: 0,0:19:35.60,0:19:37.42,csapp,,0,0,0,,key no readers are a little more interesting 
Dialogue: 0,0:19:38.88,0:19:40.30,csapp,,0,0,0,,so with a with the reader 
Dialogue: 0,0:19:40.92,0:19:46.16,csapp,,0,0,0,,we have the shared this global variable called read count which is going to keep track of the number of readers
Dialogue: 0,0:19:46.50,0:19:51.58,csapp,,0,0,0,, that are waiting to to read the to read the resource 
Dialogue: 0,0:19:52.34,0:19:57.94,csapp,,0,0,0,,and there's a mutex semaphore mutex that protect protects the accesses the updates to read count
Dialogue: 0,0:19:58.66,0:20:01.80,csapp,,0,0,0,,okay the reads and the rights to up to read count 
Dialogue: 0,0:20:02.74,0:20:04.64,csapp,,0,0,0,,and then there's this W semaphore 
Dialogue: 0,0:20:05.12,0:20:10.68,csapp,,0,0,0,,which as we saw here is used to protect the critical section in the writer 
Dialogue: 0,0:20:11.60,0:20:13.90,csapp,,0,0,0,,and initially both of these are set to one 
Dialogue: 0,0:20:16.70,0:20:20.52,csapp,,0,0,0,,so the reader in this infinite loop in each iteration of this infinite loop 
Dialogue: 0,0:20:21.34,0:20:28.90,csapp,,0,0,0,,it is going to increment read count so it protects that that access by by doing a pee on the mutex
Dialogue: 0,0:20:28.90,0:20:30.64,csapp,,0,0,0,,which is associated with recount 
Dialogue: 0,0:20:33.04,0:20:36.80,csapp,,0,0,0,,so only one only one reader can can be 
Dialogue: 0,0:20:36.96,0:20:44.36,csapp,,0,0,0,,so this this this region between the p and the v constitutes the critical section corresponding to read count 
Dialogue: 0,0:20:45.66,0:20:50.54,csapp,,0,0,0,,so after the p completes then it 
Dialogue: 0,0:20:51.30,0:20:55.40,csapp,,0,0,0,,then we increment the read count so now there's an additional reader 
Dialogue: 0,0:20:56.20,0:20:58.80,csapp,,0,0,0,,alright so we can have potentially arbitrary number of these reader threads 
Dialogue: 0,0:20:58.80,0:21:03.18,csapp,,0,0,0,,right so this we're indicating that there's there's there's a new reader now
Dialogue: 0,0:21:04.54,0:21:07.90,csapp,,0,0,0,, and if read count is one that that means we're the first reader 
Dialogue: 0,0:21:08.46,0:21:14.82,csapp,,0,0,0,,okay so this is sort of the first reader into the this this implicit queue of waiting readers
Dialogue: 0,0:21:17.00,0:21:20.04,csapp,,0,0,0,, so if read count is one if we're the first reader 
Dialogue: 0,0:21:21.46,0:21:23.36,csapp,,0,0,0,,then we do a p on w 
Dialogue: 0,0:21:25.26,0:21:29.26,csapp,,0,0,0,,okay which now will lock out any any any future writers 
Dialogue: 0,0:21:30.58,0:21:36.90,csapp,,0,0,0,,now if there's already a writer that's done it's P of W then this will block waiting for that writer to finish 
Dialogue: 0,0:21:38.74,0:21:43.58,csapp,,0,0,0,,okay but if there's no writer in inside of its critical critical section 
Dialogue: 0,0:21:44.36,0:21:48.30,csapp,,0,0,0,,then this P will just decrement the semaphore W 
Dialogue: 0,0:21:49.08,0:21:52.76,csapp,,0,0,0,,from 1 to 0 and then lock out any subsequent writers
Dialogue: 0,0:21:54.76,0:22:01.54,csapp,,0,0,0,,okay after so now after it's done this increment and read of the recount variable then it releases the mutex
Dialogue: 0,0:22:02.40,0:22:06.00,csapp,,0,0,0,, so that other readers can can access recount 
Dialogue: 0,0:22:09.92,0:22:11.36,csapp,,0,0,0,,okay now but it's still holding
Dialogue: 0,0:22:15.30,0:22:21.02,csapp,,0,0,0,,it's it's it's it's holding so this is this is kind of interesting right it's it's it's holding the semaphore that
Dialogue: 0,0:22:21.38,0:22:22.76,csapp,,0,0,0,,that locks out the writers
Dialogue: 0,0:22:24.20,0:22:31.98,csapp,,0,0,0,, but it's not holding the any-any mutex right so the reader now can just can just read 
Dialogue: 0,0:22:32.00,0:22:33.10,csapp,,0,0,0,,it can do its read 
Dialogue: 0,0:22:34.32,0:22:41.08,csapp,,0,0,0,,and other readers that are in the same the same section of the code can also do their reads 
Dialogue: 0,0:22:42.04,0:22:42.70,csapp,,0,0,0,,right so so we're not 
Dialogue: 0,0:22:45.60,0:22:49.15,csapp,,0,0,0,,so we're allowing multiple readers now inside this critical section
Dialogue: 0,0:22:49.62,0:22:51.16,csapp,,0,0,0,,but but no writers 
Dialogue: 0,0:22:52.64,0:22:57.54,csapp,,0,0,0,,okay so everything so everything works looks like it works good now after after we read
Dialogue: 0,0:22:58.24,0:23:02.30,csapp,,0,0,0,, now the number of readers now is going to be we want to decrement the number of readers
Dialogue: 0,0:23:03.18,0:23:05.92,csapp,,0,0,0,,so we acquire the mutex on on read count
Dialogue: 0,0:23:06.54,0:23:07.86,csapp,,0,0,0,,we decrement read count 
Dialogue: 0,0:23:09.50,0:23:11.80,csapp,,0,0,0,,and then we check to see if we're the last reader
Dialogue: 0,0:23:12.52,0:23:13.76,csapp,,0,0,0,,okay so if there's no more readers
Dialogue: 0,0:23:14.51,0:23:16.32,csapp,,0,0,0,, in other words if read count is zero 
Dialogue: 0,0:23:18.14,0:23:20.96,csapp,,0,0,0,,then with now we can release the mutex for the writer 
Dialogue: 0,0:23:21.34,0:23:24.24,csapp,,0,0,0,, so that any now writers can can access that resource 
Dialogue: 0,0:23:25.98,0:23:33.52,csapp,,0,0,0,,and after we release that the writers the writers mutex then we release the mutex for recount
Dialogue: 0,0:23:37.20,0:23:39.16,csapp,,0,0,0,,so any questions about about this
Dialogue: 0,0:23:43.20,0:23:45.36,csapp,,0,0,0,,so an interesting for you to think about just uh
Dialogue: 0,0:23:46.18,0:23:47.36,csapp,,0,0,0,, if you have any spare time is
Dialogue: 0,0:23:47.80,0:23:54.24,csapp,,0,0,0,,how you might how you might write a version of this readers writers problem or that
Dialogue: 0,0:23:54.48,0:23:56.16,csapp,,0,0,0,,  favors writers instead of readers 
Dialogue: 0,0:23:59.74,0:24:05.96,csapp,,0,0,0,,yes 
Dialogue: 0,0:24:05.96,0:24:09.44,csapp,,0,0,0,,oh no okay so the question is a mutex allows for multiple readers
Dialogue: 0,0:24:11.08,0:24:15.36,csapp,,0,0,0,,the fact that we know the fact that we're releasing this mutex here 
Dialogue: 0,0:24:15.42,0:24:19.40,csapp,,0,0,0,, that this mutex is only only protecting access to read count 
Dialogue: 0,0:24:19.74,0:24:21.84,csapp,,0,0,0,,so we acquire it here and we release it here 
Dialogue: 0,0:24:22.30,0:24:25.48,csapp,,0,0,0,,after we've after we've accessed read count 
Dialogue: 0,0:24:27.22,0:24:31.72,csapp,,0,0,0,,okay but we're not protecting the critical section of the reader with any with any mutex 
Dialogue: 0,0:24:33.42,0:24:39.18,csapp,,0,0,0,,except for we're we're keeping writers out by if we're the first one in
Dialogue: 0,0:24:39.84,0:24:40.98,csapp,,0,0,0,,if we're the first reader 
Dialogue: 0,0:24:42.84,0:24:47.38,csapp,,0,0,0,,you commanders like this implicit queue of readers that we're keeping track of with read count
Dialogue: 0,0:24:48.40,0:24:52.96,csapp,,0,0,0,,okay so if we're the first ones in meaning 
Dialogue: 0,0:24:53.54,0:24:59.04,csapp,,0,0,0,,we're the first reader then we we acquire this the p on the writers mutex
Dialogue: 0,0:24:59.24,0:25:04.24,csapp,,0,0,0,, now if there's of course if there's a writer inside this critical section then
Dialogue: 0,0:25:04.88,0:25:07.86,csapp,,0,0,0,, this p will wait until the writer releases 
Dialogue: 0,0:25:09.88,0:25:14.72,csapp,,0,0,0,,okay but once once we've acquired this this this mutex w 
Dialogue: 0,0:25:16.30,0:25:18.54,csapp,,0,0,0,, then we're block we're locking out any writers 
Dialogue: 0,0:25:19.24,0:25:28.12,csapp,,0,0,0,,okay because they'll any writer that that arrives we'll do a p and it will block right here on waiting for that w to be nonzero 
Dialogue: 0,0:25:29.54,0:25:36.98,csapp,,0,0,0,,okay so so we're just we're blocking out any writers but then we're allowing any readers to just to access the resource
Dialogue: 0,0:25:40.08,0:25:40.52,csapp,,0,0,0,,okay
Dialogue: 0,0:25:41.84,0:25:42.50,csapp,,0,0,0,,okay good 
Dialogue: 0,0:25:45.14,0:25:45.72,csapp,,0,0,0,,yes question 
Dialogue: 0,0:25:45.72,0:25:49.64,csapp,,0,0,0,,
Dialogue: 0,0:25:49.66,0:25:50.96,csapp,,0,0,0,,question is blocking slow
Dialogue: 0,0:25:51.50,0:25:56.00,csapp,,0,0,0,, it can be depends well first of all you're making a call into the kernel so it's a system call 
Dialogue: 0,0:25:56.56,0:26:00.10,csapp,,0,0,0,,so you're crossing that boundary and there's always overhead associated with that 
Dialogue: 0,0:26:01.00,0:26:07.08,csapp,,0,0,0,,and then blocking you're blocked until you know it can be sort of an arbitrary amount of time right 
Dialogue: 0,0:26:07.08,0:26:09.58,csapp,,0,0,0,,until someone doesn't some thread does a V 
Dialogue: 0,0:26:10.32,0:26:11.92,csapp,,0,0,0,,so yeah it can't be slow 
Dialogue: 0,0:26:13.22,0:26:18.34,csapp,,0,0,0,,right it just it just depends you can't it's it's really hard to bound the time that you're going to be blocked 
Dialogue: 0,0:26:19.22,0:26:22.44,csapp,,0,0,0,,now if you write the program correctly eventually you'll be unblocked 
Dialogue: 0,0:26:23.10,0:26:25.48,csapp,,0,0,0,,you know eventually some thread will execute a V 
Dialogue: 0,0:26:27.88,0:26:35.50,csapp,,0,0,0,,but when we're sort of assuming that the kernel does some kind of when it implements its V it does some kind of fair scheduling that
Dialogue: 0,0:26:36.26,0:26:44.42,csapp,,0,0,0,,so a blocked a blocked P won't be in its queue for forever right that the kernel does some kind of something that's fair
Dialogue: 0,0:26:44.78,0:26:48.70,csapp,,0,0,0,,so it guarantees that a P won't remain blocked indefinitely
Dialogue: 0,0:26:54.80,0:26:55.60,csapp,,0,0,0,,other questions 
Dialogue: 0,0:27:00.86,0:27:02.86,csapp,,0,0,0,,okay so we can kind of put all of this together 
Dialogue: 0,0:27:04.42,0:27:08.46,csapp,,0,0,0,,and and use the use our producer-consumer model to
Dialogue: 0,0:27:09.30,0:27:13.26,csapp,,0,0,0,,to implement a pre threaded concurrent echo server 
Dialogue: 0,0:27:13.78,0:27:16.44,csapp,,0,0,0,, now so far when we've when we've used threads to
Dialogue: 0,0:27:16.78,0:27:20.12,csapp,,0,0,0,, in all our examples of using threads and processes for servers
Dialogue: 0,0:27:20.70,0:27:24.54,csapp,,0,0,0,,we created a new thread or process whenever a new connection requests arrived 
Dialogue: 0,0:27:25.92,0:27:27.06,csapp,,0,0,0,,and then when it went 
Dialogue: 0,0:27:28.04,0:27:30.66,csapp,,0,0,0,, and then that that thread interacted with the client
Dialogue: 0,0:27:31.66,0:27:36.36,csapp,,0,0,0,, and then whenever whenever that interaction was finished it closed the connection and exited 
Dialogue: 0,0:27:36.66,0:27:38.58,csapp,,0,0,0,,and killed the the thread or process 
Dialogue: 0,0:27:39.34,0:27:42.64,csapp,,0,0,0,,now that's that's okay but it's it's it's inefficient
Dialogue: 0,0:27:43.50,0:27:49.14,csapp,,0,0,0,, because we're this creating and killing threads introduces overhead 
Dialogue: 0,0:27:50.28,0:27:59.02,csapp,,0,0,0,,so another way to do this is to pre the treads or processes ahead of time  create a pool of threads
Dialogue: 0,0:27:59.34,0:28:04.20,csapp,,0,0,0,,where each thread so we create a pool of these worker threads 
Dialogue: 0,0:28:04.20,0:28:08.88,csapp,,0,0,0,,where each of these worker threads interacts with can interact with a client 
Dialogue: 0,0:28:11.10,0:28:14.84,csapp,,0,0,0,,okay so instead of sort of creating processes and threads on on-demand 
Dialogue: 0,0:28:14.86,0:28:22.84,csapp,,0,0,0,,we create a what we call a set of pre threaded or pre threaded threads or pre forked processes
Dialogue: 0,0:28:23.80,0:28:24.52,csapp,,0,0,0,,that do the work 
Dialogue: 0,0:28:25.48,0:28:30.44,csapp,,0,0,0,,so the idea is that we have this master thread in our server
Dialogue: 0,0:28:30.96,0:28:36.82,csapp,,0,0,0,,that's waiting for connection requests from clients  by repeated calls to accept
Dialogue: 0,0:28:38.40,0:28:41.72,csapp,,0,0,0,,and then when it when this thread receives the connection request 
Dialogue: 0,0:28:42.40,0:28:48.52,csapp,,0,0,0,, from the client the accept the accept call the accept function returns a connected file descriptor 
Dialogue: 0,0:28:49.32,0:28:52.62,csapp,,0,0,0,, ok associated with the connection to the client
Dialogue: 0,0:28:53.82,0:28:58.38,csapp,,0,0,0,, and then it inserts that descriptor into a into a buffer 
Dialogue: 0,0:28:58.76,0:29:01.74,csapp,,0,0,0,,ok now remember descriptors are just small integers
Dialogue: 0,0:29:02.48,0:29:04.74,csapp,,0,0,0,, that index the descriptor table
Dialogue: 0,0:29:05.28,0:29:09.10,csapp,,0,0,0,, right so they can be passed around from thread to thread 
Dialogue: 0,0:29:09.22,0:29:10.94,csapp,,0,0,0,,because all the threads are sharing the same
Dialogue: 0,0:29:12.00,0:29:15.50,csapp,,0,0,0,, the same set that same descriptor table right
Dialogue: 0,0:29:17.76,0:29:19.48,csapp,,0,0,0,,so the master thread puts
Dialogue: 0,0:29:21.32,0:29:28.90,csapp,,0,0,0,, the repeatedly accepts connection requests and inserts the corresponding connected file descriptor into the buffer 
Dialogue: 0,0:29:30.32,0:29:37.00,csapp,,0,0,0,,now each worker thread waits for the so in this case the items are descriptors 
Dialogue: 0,0:29:37.88,0:29:43.25,csapp,,0,0,0,,so the worker threads they're all waiting on this for items to appear in this buffer
Dialogue: 0,0:29:44.80,0:29:48.14,csapp,,0,0,0,,okay and when an item appears one of the threads will remove that item 
Dialogue: 0,0:29:51.56,0:29:55.86,csapp,,0,0,0,,and then use that descriptor to interact with the with the client 
Dialogue: 0,0:29:55.86,0:30:02.76,csapp,,0,0,0,,over the connected file descriptor associated with the connection that exists between the client  and the server 
Dialogue: 0,0:30:04.46,0:30:09.94,csapp,,0,0,0,,okay so now we have we have these the concurrency comes in the form of these multiple worker threads
Dialogue: 0,0:30:10.10,0:30:12.38,csapp,,0,0,0,, interacting with with multiple clients 
Dialogue: 0,0:30:13.24,0:30:18.16,csapp,,0,0,0,,and then when a worker thread finishes servicing a particular client
Dialogue: 0,0:30:19.70,0:30:23.44,csapp,,0,0,0,,then it just goes and it checks for the next file descriptor in the buffer 
Dialogue: 0,0:30:24.14,0:30:29.00,csapp,,0,0,0,,okay so this is much more efficient than our previous model where 
Dialogue: 0,0:30:29.70,0:30:32.50,csapp,,0,0,0,,for each new client we had to create a thread or a process
Dialogue: 0,0:30:32.90,0:30:35.64,csapp,,0,0,0,,and then destroy that thread or process once we were finished
Dialogue: 0,0:30:35.98,0:30:39.20,csapp,,0,0,0,,okay so we're sort of re amortize that
Dialogue: 0,0:30:40.40,0:30:44.50,csapp,,0,0,0,, that we had to go through to create these worker threads  by leaving them running 
Dialogue: 0,0:30:45.02,0:30:53.24,csapp,,0,0,0,,and then replacing the destruction or the killing of that thread with replacing it with just a simple 
Dialogue: 0,0:30:54.38,0:30:59.98,csapp,,0,0,0,,as simple and very fast operation of removing an item from the buffer okay
Dialogue: 0,0:31:02.80,0:31:05.60,csapp,,0,0,0,,okay so let's let's see how we would we would implement this 
Dialogue: 0,0:31:07.16,0:31:10.24,csapp,,0,0,0,,and like like all of these server examples it's surprisingly simple right 
Dialogue: 0,0:31:10.44,0:31:18.64,csapp,,0,0,0,,this is a fully functioning a real server but we can do it in one one page  one page of code 
Dialogue: 0,0:31:20.44,0:31:24.18,csapp,,0,0,0,,so for this preet we're going to use threads for our concurrent server
Dialogue: 0,0:31:25.14,0:31:28.08,csapp,,0,0,0,,and we're going to use the s buff package so we're going to create this
Dialogue: 0,0:31:28.68,0:31:33.04,csapp,,0,0,0,,this shared buffer global variable called s buff 
Dialogue: 0,0:31:36.28,0:31:41.02,csapp,,0,0,0,,and we have listening descriptor and connected descriptor 
Dialogue: 0,0:31:41.24,0:31:45.90,csapp,,0,0,0,,and we have the client length and client adder that that will be used in the accept call 
Dialogue: 0,0:31:46.32,0:31:52.44,csapp,,0,0,0,,and we have the thread ID that will be used in the when we create that when we create this thread 
Dialogue: 0,0:31:53.80,0:31:59.32,csapp,,0,0,0,,so now that we start by we're going to in this program we're going to pass in the port number 
Dialogue: 0,0:31:59.34,0:32:02.00,csapp,,0,0,0,,so the server is going to be listening on some port 
Dialogue: 0,0:32:02.66,0:32:06.60,csapp,,0,0,0,,so we passed that port number in as the first argument 
Dialogue: 0,0:32:09.42,0:32:12.30,csapp,,0,0,0,,so we call open listened FD on our V of one
Dialogue: 0,0:32:13.92,0:32:17.38,csapp,,0,0,0,,an open listened FD creates a listening descriptor and returns it
Dialogue: 0,0:32:18.04,0:32:20.78,csapp,,0,0,0,, returns the value of that descriptor and listen FD
Dialogue: 0,0:32:22.06,0:32:26.50,csapp,,0,0,0,,and then we call s buff in it to to initialize our shared buffer 
Dialogue: 0,0:32:28.36,0:32:31.58,csapp,,0,0,0,,with with s buff sized file descriptors 
Dialogue: 0,0:32:33.92,0:32:37.36,csapp,,0,0,0,,and then we create a collection of n threads worker threads 
Dialogue: 0,0:32:38.34,0:32:44.24,csapp,,0,0,0,,each of which will execute the the thread routine which we've called thread  and no argument 
Dialogue: 0,0:32:46.78,0:32:50.42,csapp,,0,0,0,,so once we create these all of these threads then we go in this infinite loop 
Dialogue: 0,0:32:52.26,0:32:56.66,csapp,,0,0,0,,where we call except
Dialogue: 0,0:32:59.38,0:33:05.06,csapp,,0,0,0,,on this listening descriptor so in that except we'll block until a connection request arrives 
Dialogue: 0,0:33:05.62,0:33:11.72,csapp,,0,0,0,,and when it does the accept returns with a connected file descriptor that can be used to to interact with the client
Dialogue: 0,0:33:14.22,0:33:18.56,csapp,,0,0,0,,and once we get that connected file descriptor then we just simply insert it
Dialogue: 0,0:33:19.48,0:33:24.02,csapp,,0,0,0,,we insert that that connected file descriptor into our shared buffer 
Dialogue: 0,0:33:24.76,0:33:28.26,csapp,,0,0,0,,and then wait for the connection request  the next connection request 
Dialogue: 0,0:33:28.26,0:33:34.98,csapp,,0,0,0,, so our servers very efficient right we're just doing an accept and then a very fast insert into the buffer 
Dialogue: 0,0:33:35.72,0:33:44.60,csapp,,0,0,0,,okay and then we're going to let the worker threads do all the work associated with those with that with with that  that queue of descriptors 
Dialogue: 0,0:33:47.44,0:33:51.50,csapp,,0,0,0,,now the thread routine first detaches 
Dialogue: 0,0:33:51.86,0:33:53.98,csapp,,0,0,0,, okay so this is a case where we don't want to run joinable 
Dialogue: 0,0:33:54.88,0:33:57.64,csapp,,0,0,0,,because we're never going to to join 
Dialogue: 0,0:33:58.10,0:34:05.56,csapp,,0,0,0,,we're never going to wait for these threads or have any any reason to I kill them  from the main thread 
Dialogue: 0,0:34:06.64,0:34:12.16,csapp,,0,0,0,, so this so now this this worker thread and in this infinite loop each iteration it removes 
Dialogue: 0,0:34:12.82,0:34:18.70,csapp,,0,0,0,,an item from the buffer so it blocks until there's an item that it can that it can remove from the buffer
Dialogue: 0,0:34:19.60,0:34:25.36,csapp,,0,0,0,, and it sets it to this local variable con FD
Dialogue: 0,0:34:26.22,0:34:30.58,csapp,,0,0,0,,and then it calls a helper sort of this this is like the the helper function
Dialogue: 0,0:34:31.42,0:34:36.90,csapp,,0,0,0,,that implements the logic for this this particular server and this is this in this case it's an echo server 
Dialogue: 0,0:34:38.20,0:34:42.54,csapp,,0,0,0,,so this this echo count routine will interact with the client 
Dialogue: 0,0:34:42.56,0:34:46.54,csapp,,0,0,0,,echoing whatever the client sends us until the client closes the connection 
Dialogue: 0,0:34:48.26,0:34:50.60,csapp,,0,0,0,,and then when it so whenever the client is finished then
Dialogue: 0,0:34:52.26,0:35:00.66,csapp,,0,0,0,,then we close the week we close the our end of the connection and go back and get the next item out of the buffer
Dialogue: 0,0:35:02.38,0:35:06.70,csapp,,0,0,0,, and as you point out that echo count is just a placeholder this could be anything
Dialogue: 0,0:35:06.70,0:35:11.72,csapp,,0,0,0,,this could be the logic for a web server for any any kind of web service or any kind of service
Dialogue: 0,0:35:15.66,0:35:16.42,csapp,,0,0,0,,now
Dialogue: 0,0:35:18.38,0:35:22.44,csapp,,0,0,0,, the the to initialize this echo count function 
Dialogue: 0,0:35:24.38,0:35:28.90,csapp,,0,0,0,,we need to we need to initialize the mutex 
Dialogue: 0,0:35:30.78,0:35:38.54,csapp,,0,0,0,, so we're so this echo count function is going to have it has it defines a global variable called byte count 
Dialogue: 0,0:35:39.34,0:35:45.12,csapp,,0,0,0,,so this in this echo server we're going to keep track of the number of bytes that we've received from all the clients
Dialogue: 0,0:35:45.42,0:35:46.74,csapp,,0,0,0,, that we're interacting with
Dialogue: 0,0:35:47.48,0:35:52.00,csapp,,0,0,0,, okay so there's a global variable called byte count which is shared by all the threads 
Dialogue: 0,0:35:52.56,0:35:57.04,csapp,,0,0,0,,and we're going to update this this byte count variable every time we receive 
Dialogue: 0,0:35:57.86,0:36:01.34,csapp,,0,0,0,,something every time we receive data from from the client 
Dialogue: 0,0:36:01.96,0:36:06.24,csapp,,0,0,0,,and we're going to use mutex to protect the accesses to byte count 
Dialogue: 0,0:36:07.98,0:36:11.80,csapp,,0,0,0,,okay so we're going to initially have to initialize 
Dialogue: 0,0:36:13.02,0:36:15.78,csapp,,0,0,0,,we have to call a function that initializes
Dialogue: 0,0:36:18.10,0:36:24.14,csapp,,0,0,0,,that initializes this by first initializing the mutex and then setting byte count to zero 
Dialogue: 0,0:36:27.06,0:36:28.76,csapp,,0,0,0,,and then within echo count itself
Dialogue: 0,0:36:35.98,0:36:39.10,csapp,,0,0,0,,there's some we've already seen Sud
Dialogue: 0,0:36:39.92,0:36:42.24,csapp,,0,0,0,,we've already seen a way to initialize a package 
Dialogue: 0,0:36:42.90,0:36:47.50,csapp,,0,0,0,,you know if we have some kind of package of library functions that are going to be used by multiple threads
Dialogue: 0,0:36:48.24,0:36:51.72,csapp,,0,0,0,,there's several ways to actually initialize this package 
Dialogue: 0,0:36:52.40,0:36:56.66,csapp,,0,0,0,,so one way is to explicitly call have the the main thread
Dialogue: 0,0:36:56.96,0:36:59.88,csapp,,0,0,0,,call this initialization function once
Dialogue: 0,0:37:00.72,0:37:05.92,csapp,,0,0,0,,okay so we've seen that with like the S buff package right the main thread has to call 
Dialogue: 0,0:37:08.80,0:37:11.02,csapp,,0,0,0,,the main thread calls S buffin at once 
Dialogue: 0,0:37:12.40,0:37:16.68,csapp,,0,0,0,, okay before any of the peer threads execute any of the worker threads executes 
Dialogue: 0,0:37:18.64,0:37:24.82,csapp,,0,0,0,,but there's another way we can do this too we can have that the worker threads actually call the initialization function 
Dialogue: 0,0:37:26.08,0:37:30.88,csapp,,0,0,0,,and we can use this technique provided by by P threads
Dialogue: 0,0:37:31.94,0:37:37.72,csapp,,0,0,0,,where we define a static variable so this is a static local variable 
Dialogue: 0,0:37:37.76,0:37:42.08,csapp,,0,0,0,,but you recall that this is actually treated like a global variable 
Dialogue: 0,0:37:42.62,0:37:47.08,csapp,,0,0,0,,so it every thread has access to this variable 
Dialogue: 0,0:37:48.00,0:37:53.94,csapp,,0,0,0,,okay but but its scope is limited to to the disco de cocao function 
Dialogue: 0,0:37:53.96,0:37:59.16,csapp,,0,0,0,,so no other no other function connect can access  this variable 
Dialogue: 0,0:37:59.50,0:38:05.48,csapp,,0,0,0,, but each each thread that executes this thread routine has access to it 
Dialogue: 0,0:38:05.96,0:38:09.64,csapp,,0,0,0,,and and in this context it's treated like a global right 
Dialogue: 0,0:38:09.72,0:38:15.34,csapp,,0,0,0,,so if one thread updates the value every other every thread sees that same value 
Dialogue: 0,0:38:16.54,0:38:21.92,csapp,,0,0,0,,okay so so we can use this this mechanism from P threads 
Dialogue: 0,0:38:22.76,0:38:24.08,csapp,,0,0,0,,but so we can create this
Dialogue: 0,0:38:25.10,0:38:31.42,csapp,,0,0,0,,this this variable of type P thread once T  and initialize it to this special P threads value 
Dialogue: 0,0:38:31.78,0:38:36.98,csapp,,0,0,0,,which is sort of like the P threads uninitialized value 
Dialogue: 0,0:38:37.04,0:38:41.04,csapp,,0,0,0,,so this is a value that P threads knows about that indicates that
Dialogue: 0,0:38:41.90,0:38:45.88,csapp,,0,0,0,, that this this variable wants hasn't been initialized
Dialogue: 0,0:38:48.20,0:38:51.98,csapp,,0,0,0,,and then and then we call the pthread once function 
Dialogue: 0,0:38:52.78,0:38:58.50,csapp,,0,0,0,,passing at this this this variable that we the address of this variable created that we created 
Dialogue: 0,0:38:59.12,0:39:02.84,csapp,,0,0,0,,and the address of the function to call to initialize 
Dialogue: 0,0:39:04.68,0:39:07.98,csapp,,0,0,0,,whatever it is we want to initialize in this case the the echo count 
Dialogue: 0,0:39:10.88,0:39:12.72,csapp,,0,0,0,,the the echo count variable
Dialogue: 0,0:39:14.16,0:39:18.66,csapp,,0,0,0,, and so what this does every thread will call P thread once 
Dialogue: 0,0:39:18.86,0:39:26.24,csapp,,0,0,0,,but only one thread will actually  call the the initialization function 
Dialogue: 0,0:39:27.68,0:39:32.66,csapp,,0,0,0,,only the very first thread that executes speith read once will we'll call it
Dialogue: 0,0:39:32.66,0:39:37.24,csapp,,0,0,0,, the other threads this this P thread wants call will be like a no op
Dialogue: 0,0:39:37.92,0:39:42.78,csapp,,0,0,0,,yes question 
Dialogue: 0,0:39:42.80,0:39:43.88,csapp,,0,0,0,,well that's the other option 
Dialogue: 0,0:39:44.66,0:39:47.88,csapp,,0,0,0,,so so the advantage of this is that 
Dialogue: 0,0:39:50.46,0:39:57.06,csapp,,0,0,0,,you can you I guess the advantage is I I don't know that it's just another way you can do it 
Dialogue: 0,0:39:58.64,0:40:02.96,csapp,,0,0,0,,you I guess it avoids it avoids having to do it in the master thread that 
Dialogue: 0,0:40:03.20,0:40:08.24,csapp,,0,0,0,, you can you can make your you can make this package sort of self-contained right that
Dialogue: 0,0:40:08.50,0:40:11.20,csapp,,0,0,0,,  you're not you're not really counting on the master doing anything 
Dialogue: 0,0:40:12.54,0:40:16.54,csapp,,0,0,0,,but yeah that's that's the other way we could have done it so I just wanted to show you this this
Dialogue: 0,0:40:17.06,0:40:17.94,csapp,,0,0,0,, this other technique 
Dialogue: 0,0:40:19.62,0:40:24.26,csapp,,0,0,0,,okay so once we once we initialize once we once 
Dialogue: 0,0:40:24.50,0:40:26.14,csapp,,0,0,0,,some thread calls the NED echo count 
Dialogue: 0,0:40:28.46,0:40:30.26,csapp,,0,0,0,,then we initialize the reo package 
Dialogue: 0,0:40:32.00,0:40:34.98,csapp,,0,0,0,,for all of our accesses on this connected descriptor 
Dialogue: 0,0:40:36.42,0:40:40.48,csapp,,0,0,0,,and then we we repeatedly read a line of text from the client 
Dialogue: 0,0:40:42.26,0:40:44.22,csapp,,0,0,0,,okay and then
Dialogue: 0,0:40:45.78,0:40:50.48,csapp,,0,0,0,, in a protected way we increment bite count with the number of bytes that
Dialogue: 0,0:40:50.54,0:40:56.28,csapp,,0,0,0,, we received  from the client which is returned by this Rio read line b function 
Dialogue: 0,0:40:57.68,0:41:00.90,csapp,,0,0,0,,and then we print a little message just to sort of keep track
Dialogue: 0,0:41:01.04,0:41:04.40,csapp,,0,0,0,, so we can see keep track of our running total
Dialogue: 0,0:41:04.98,0:41:09.42,csapp,,0,0,0,,and then we release the mutex on this on the byte count the global byte count variable 
Dialogue: 0,0:41:09.74,0:41:12.46,csapp,,0,0,0,,and then we echo that line back to the client 
Dialogue: 0,0:41:15.54,0:41:16.62,csapp,,0,0,0,,okay so any questions about that
Dialogue: 0,0:41:18.00,0:41:18.62,csapp,,0,0,0,,yes question 
Dialogue: 0,0:41:18.62,0:41:28.26,csapp,,0,0,0,,so the line there's it
Dialogue: 0,0:41:28.28,0:41:33.16,csapp,,0,0,0,, okay the question is the line that declares the static variable 
Dialogue: 0,0:41:33.92,0:41:37.08,csapp,,0,0,0,,once will it only be executed the first time
Dialogue: 0,0:41:38.08,0:41:41.44,csapp,,0,0,0,, a thread executes that statement 
Dialogue: 0,0:41:41.84,0:41:46.62,csapp,,0,0,0,,no it's so the answer is no every every thread will define this variable 
Dialogue: 0,0:41:47.00,0:41:53.28,csapp,,0,0,0,,and assign it this to this this this P thread once value
Dialogue: 0,0:41:53.94,0:41:58.66,csapp,,0,0,0,,okay what will only happen once is the call to a net echo count 
Dialogue: 0,0:41:59.42,0:42:05.36,csapp,,0,0,0,,okay so the first thread that executes this P thread once call 
Dialogue: 0,0:42:05.92,0:42:08.20,csapp,,0,0,0,,will actually call an EDD echo count 
Dialogue: 0,0:42:09.44,0:42:13.58,csapp,,0,0,0,,every other thread every subsequent thread will not call it it'll be like a no op 
Dialogue: 0,0:42:14.84,0:42:18.54,csapp,,0,0,0,,[student speaking]
Dialogue: 0,0:42:18.54,0:42:20.80,csapp,,0,0,0,,yeah uses the ones it's just an opaque
Dialogue: 0,0:42:20.86,0:42:33.44,csapp,,0,0,0,,cause the declaration line once it will be selling the flag by resetting in speech
Dialogue: 0,0:42:33.46,0:42:39.54,csapp,,0,0,0,,yeah somehow it will but somehow the pthread wants is keeping track that it's it's executed 
Dialogue: 0,0:42:41.60,0:42:44.58,csapp,,0,0,0,,okay so I I'm really not sure how how its implemented 
Dialogue: 0,0:42:45.18,0:42:48.54,csapp,,0,0,0,,okay so somehow pthread wants 
Dialogue: 0,0:42:49.64,0:42:51.12,csapp,,0,0,0,,yeah I guess every you know this 
Dialogue: 0,0:42:52.02,0:42:54.70,csapp,,0,0,0,,I mean this is just the C declaration right so there's no
Dialogue: 0,0:42:55.14,0:42:59.00,csapp,,0,0,0,, the pthreads has no control over declarations right 
Dialogue: 0,0:42:59.54,0:43:06.92,csapp,,0,0,0,,so every thread will get it every thread will sort of update this static variable 
Dialogue: 0,0:43:08.72,0:43:10.76,csapp,,0,0,0,,and you're wright if the first thread
Dialogue: 0,0:43:14.68,0:43:18.18,csapp,,0,0,0,,the second thread would overwrite this value again 
Dialogue: 0,0:43:19.02,0:43:23.50,csapp,,0,0,0,,but somehow pthread once  can keeps track of that 
Dialogue: 0,0:43:23.74,0:43:27.10,csapp,,0,0,0,,okay in a in some way that I I'm not sure about how that works 
Dialogue: 0,0:43:28.56,0:43:31.62,csapp,,0,0,0,,but this is this is the way you get that behavior
Dialogue: 0,0:43:36.84,0:43:43.44,csapp,,0,0,0,,can others there's some other issues around synchronizing threads sort of correctness issues that we have to be aware of 
Dialogue: 0,0:43:45.66,0:43:51.56,csapp,,0,0,0,,and so I hope your hope you're sort of getting the sense that this threaded programming is is kind of a tricky business right 
Dialogue: 0,0:43:52.36,0:43:57.50,csapp,,0,0,0,,and so one issue that we always have to be aware of is is is this idea called thread safety
Dialogue: 0,0:43:58.68,0:44:06.30,csapp,,0,0,0,, so in general a thread routine can only should only call functions that are that are thread safe
Dialogue: 0,0:44:06.76,0:44:08.66,csapp,,0,0,0,, that have this property called thread safety
Dialogue: 0,0:44:09.74,0:44:11.90,csapp,,0,0,0,, okay and a function is thread safe 
Dialogue: 0,0:44:13.00,0:44:18.76,csapp,,0,0,0,,if and only if that function can be invoked by multiple threads at the same time 
Dialogue: 0,0:44:19.76,0:44:22.20,csapp,,0,0,0,,okay so if we have a function f 
Dialogue: 0,0:44:24.42,0:44:29.10,csapp,,0,0,0,,its thread safe if and only if its execution can be interleaved by multiple threads
Dialogue: 0,0:44:34.70,0:44:38.96,csapp,,0,0,0,,and so we can identify a four different classes of thread unsafe functions 
Dialogue: 0,0:44:39.86,0:44:46.06,csapp,,0,0,0,, so one classes is the functions that fail to protect shared variables with mutexes
Dialogue: 0,0:44:48.22,0:44:50.06,csapp,,0,0,0,,okay so we've already seen that with bad count 
Dialogue: 0,0:44:50.66,0:44:56.06,csapp,,0,0,0,,that was an example of a thread unsafe that main routine was an example of an unsafe thread function 
Dialogue: 0,0:44:58.66,0:45:02.14,csapp,,0,0,0,,or no the thread function was an example of an unsafe thread function 
Dialogue: 0,0:45:02.40,0:45:06.24,csapp,,0,0,0,,because it didn't protect the act the update of the count variable
Dialogue: 0,0:45:09.04,0:45:16.90,csapp,,0,0,0,, another class of functions that that our thread unsafe is are those functions that keep track of state across multiple invocations
Dialogue: 0,0:45:17.74,0:45:24.34,csapp,,0,0,0,, so if they're storing State in some global global variable private or public global variable the net 
Dialogue: 0,0:45:24.90,0:45:26.14,csapp,,0,0,0,,that's thread unsafe
Dialogue: 0,0:45:26.80,0:45:30.94,csapp,,0,0,0,,because multiple threads will be accessing that State 
Dialogue: 0,0:45:33.44,0:45:38.74,csapp,,0,0,0,,another way another kind of thread unsafe function or functions that return a pointer to a static variable 
Dialogue: 0,0:45:40.22,0:45:43.34,csapp,,0,0,0,,so there's there's there's a number of functions in the standard c library 
Dialogue: 0,0:45:44.04,0:45:47.52,csapp,,0,0,0,,that were written before threads or even on anybody's radar 
Dialogue: 0,0:45:48.86,0:45:53.06,csapp,,0,0,0,,and so so an example is the C time function 
Dialogue: 0,0:45:53.82,0:45:57.94,csapp,,0,0,0,,which takes as an argument a time struck two binary time struct 
Dialogue: 0,0:45:58.92,0:46:02.52,csapp,,0,0,0,,and returns a pointer to a string date and time string
Dialogue: 0,0:46:04.18,0:46:07.46,csapp,,0,0,0,, but the address in that pointer is always the same 
Dialogue: 0,0:46:07.62,0:46:11.52,csapp,,0,0,0,,right so the this function is is defining some kind of static variable 
Dialogue: 0,0:46:12.48,0:46:18.00,csapp,,0,0,0,,and it's always returned and then it's it's it it's converting that the binary time struct 
Dialogue: 0,0:46:18.94,0:46:24.22,csapp,,0,0,0,,into it into a string that's always at the same location and it's returning the address of that string 
Dialogue: 0,0:46:24.86,0:46:27.64,csapp,,0,0,0,,so every invocation returns the exact same address 
Dialogue: 0,0:46:28.52,0:46:30.74,csapp,,0,0,0,,but with different content at that address 
Dialogue: 0,0:46:31.76,0:46:36.46,csapp,,0,0,0,,okay and this you know they just they didn't realize that this was a bad thing to do 
Dialogue: 0,0:46:36.72,0:46:40.66,csapp,,0,0,0,,for threaded programs because nobody was writing threaded programs at that at the time
Dialogue: 0,0:46:42.26,0:46:46.82,csapp,,0,0,0,,and then obviously any function that calls and unthread unsafe function is threat unsafe 
Dialogue: 0,0:46:47.94,0:46:51.50,csapp,,0,0,0,,okay so let's look at these these different classes of functions 
Dialogue: 0,0:46:52.14,0:46:56.32,csapp,,0,0,0,,okay so the class one functions fail to protect shared variables
Dialogue: 0,0:46:57.18,0:47:04.90,csapp,,0,0,0,, and so the fix as we've seen is to use P and V to guarantee mutually exclusive access and thereby protect  the accesses to the variable
Dialogue: 0,0:47:05.02,0:47:07.56,csapp,,0,0,0,, so we saw this with that good count program 
Dialogue: 0,0:47:08.50,0:47:12.40,csapp,,0,0,0,,and then the the problem is it also as we saw with good count is that the synchronization up 
Dialogue: 0,0:47:12.86,0:47:15.75,csapp,,0,0,0,,operations can be slow so if they're in a tight inner loop
Dialogue: 0,0:47:16.38,0:47:18.68,csapp,,0,0,0,,it can it can really slow your program down 
Dialogue: 0,0:47:21.42,0:47:25.32,csapp,,0,0,0,,okay the class 2 thread on safe functions rely on 
Dialogue: 0,0:47:25.66,0:47:29.56,csapp,,0,0,0,,some kind of persistent state across invocations of that function 
Dialogue: 0,0:47:30.32,0:47:35.28,csapp,,0,0,0,,okay so the classic example is the Lipsy rand function 
Dialogue: 0,0:47:36.54,0:47:43.68,csapp,,0,0,0,,whose in this the an implementation of which is I took from the K in our book 
Dialogue: 0,0:47:45.82,0:47:52.36,csapp,,0,0,0,,so this this R and this is a pseudo pseudo-random number generator
Dialogue: 0,0:47:53.22,0:47:55.32,csapp,,0,0,0,, a pseudo random in the sense that 
Dialogue: 0,0:47:56.08,0:48:00.84,csapp,,0,0,0,,if you give it the same key it'll return the same sequence of values okay 
Dialogue: 0,0:48:01.60,0:48:06.60,csapp,,0,0,0,,so this is kind of nice because it allows when you're testing it allows repeatability
Dialogue: 0,0:48:07.38,0:48:12.22,csapp,,0,0,0,, so every time you call it if you call it with the same seed you can you're guaranteed you'll get the same results 
Dialogue: 0,0:48:13.48,0:48:14.86,csapp,,0,0,0,,and the way this is implemented
Dialogue: 0,0:48:16.92,0:48:19.66,csapp,,0,0,0,, is that there's at the seed
Dialogue: 0,0:48:22.40,0:48:24.90,csapp,,0,0,0,, if there's this there's a seed variable called next 
Dialogue: 0,0:48:25.44,0:48:28.60,csapp,,0,0,0,,which is used in each iteration of the random number generator 
Dialogue: 0,0:48:28.68,0:48:33.82,csapp,,0,0,0,,and it's it's defined as a global private 
Dialogue: 0,0:48:33.96,0:48:38.58,csapp,,0,0,0,,so static makes it private so it's not accessible to programs that are calling
Dialogue: 0,0:48:39.22,0:48:42.92,csapp,,0,0,0,, the rand function but it's it's used by the rand function 
Dialogue: 0,0:48:43.70,0:48:45.94,csapp,,0,0,0,,and so this this variable is initialized to 1
Dialogue: 0,0:48:48.20,0:48:52.76,csapp,,0,0,0,, there's a function called s Rand which allows the user to set the seed value 
Dialogue: 0,0:48:52.82,0:48:55.64,csapp,,0,0,0,,so the the default seed value is one 
Dialogue: 0,0:48:56.48,0:48:59.48,csapp,,0,0,0,,but if the user calls s ran they can pass in a seed
Dialogue: 0,0:48:59.86,0:49:05.34,csapp,,0,0,0,,which will be then which will be which is just would assign to this this next variable 
Dialogue: 0,0:49:06.78,0:49:08.58,csapp,,0,0,0,,and then each iteration of R
Dialogue: 0,0:49:10.48,0:49:12.52,csapp,,0,0,0,,and does an operation on the seed 
Dialogue: 0,0:49:13.50,0:49:19.54,csapp,,0,0,0,,so it takes that the next value that's going to be used is the is a property of the previous value 
Dialogue: 0,0:49:19.60,0:49:21.54,csapp,,0,0,0,,the function of the previous value 
Dialogue: 0,0:49:22.58,0:49:24.74,csapp,,0,0,0,,and then it returns a pseudo-random number
Dialogue: 0,0:49:25.08,0:49:26.88,csapp,,0,0,0,, that's a function of that next value 
Dialogue: 0,0:49:28.60,0:49:32.74,csapp,,0,0,0,,okay so it's relying on this each iteration each time you call Rand 
Dialogue: 0,0:49:33.16,0:49:39.48,csapp,,0,0,0,,you're relying on the this next value that was computed by the previous time that you called Rand
Dialogue: 0,0:49:41.28,0:49:44.30,csapp,,0,0,0,,okay now this is perfectly fine and there's no problem with this 
Dialogue: 0,0:49:44.70,0:49:47.46,csapp,,0,0,0,,in a non-threaded situation 
Dialogue: 0,0:49:48.26,0:49:50.56,csapp,,0,0,0,,but what happens if multiple threads now
Dialogue: 0,0:49:51.44,0:49:53.06,csapp,,0,0,0,, so suppose you have multiple threads 
Dialogue: 0,0:49:54.06,0:50:01.08,csapp,,0,0,0,,and and they're each calling this rand function sort of interleaving calls to two Rand 
Dialogue: 0,0:50:02.52,0:50:07.94,csapp,,0,0,0,,okay the the fact that that Rand is relying on the this previous state
Dialogue: 0,0:50:10.40,0:50:14.26,csapp,,0,0,0,, if multiple threads are calling Rand it's going to break the pseudo-random property 
Dialogue: 0,0:50:14.58,0:50:19.78,csapp,,0,0,0,,so each thread that the the random numbers that each thread gets back 
Dialogue: 0,0:50:19.78,0:50:22.68,csapp,,0,0,0,,are not only a function of the previous 
Dialogue: 0,0:50:23.48,0:50:26.04,csapp,,0,0,0,,the seed from the previous time that thread called the function 
Dialogue: 0,0:50:26.04,0:50:31.98,csapp,,0,0,0,,but also also a function of the other threads that are calling it right
Dialogue: 0,0:50:32.90,0:50:38.40,csapp,,0,0,0,,so so if a particular thread calls this random number generator multiple times
Dialogue: 0,0:50:39.28,0:50:44.72,csapp,,0,0,0,,it potentially won't see the same sequence of pseudo-random numbers because other threads will be jumping in
Dialogue: 0,0:50:45.42,0:50:46.78,csapp,,0,0,0,,okay and
Dialogue: 0,0:50:48.88,0:50:55.08,csapp,,0,0,0,,okay so it it's it's not it's not incorrect and that the program will fail
Dialogue: 0,0:50:55.34,0:50:58.92,csapp,,0,0,0,,but if the program is counting on the pseudo random property
Dialogue: 0,0:50:59.40,0:51:01.22,csapp,,0,0,0,, then it creates a problem okay 
Dialogue: 0,0:51:02.66,0:51:07.66,csapp,,0,0,0,,so the the solution to this is to rewrite Rand 
Dialogue: 0,0:51:08.80,0:51:15.16,csapp,,0,0,0,,and require it to require the caller to keep track of this next variable 
Dialogue: 0,0:51:15.70,0:51:21.68,csapp,,0,0,0,,okay so each caller will keep its own local copy of next and it will pass in a pointer to R and 
Dialogue: 0,0:51:22.84,0:51:27.54,csapp,,0,0,0,,R and we'll compute that value so now this will be updating state in the calling
Dialogue: 0,0:51:27.54,0:51:32.66,csapp,,0,0,0,,the calling thread but this is local state on the on that thread stack okay
Dialogue: 0,0:51:32.82,0:51:37.16,csapp,,0,0,0,,so every thread will have its own copy of of next 
Dialogue: 0,0:51:40.14,0:51:44.32,csapp,,0,0,0,,so we but we have to create a new function and what we'll call it underscore R 
Dialogue: 0,0:51:44.76,0:51:48.54,csapp,,0,0,0,,the stands for reentrant which is a property we'll look at in just a second 
Dialogue: 0,0:51:50.56,0:51:54.06,csapp,,0,0,0,,but it's more work for the programmer because now the programmer has to maintain this
Dialogue: 0,0:51:54.76,0:51:58.10,csapp,,0,0,0,, this sort of this next value okay
Dialogue: 0,0:52:01.68,0:52:05.08,csapp,,0,0,0,,okay another way that threads the functions are unsafe
Dialogue: 0,0:52:06.08,0:52:14.52,csapp,,0,0,0,, is this this is are these functions that always retain a return a pointer to some global  to the same global variable
Dialogue: 0,0:52:15.02,0:52:17.18,csapp,,0,0,0,, or typically it's a static variable
Dialogue: 0,0:52:17.60,0:52:22.36,csapp,,0,0,0,, but they always return the same value each time the same address 
Dialogue: 0,0:52:24.36,0:52:27.90,csapp,,0,0,0,,okay so you can see this is similar to that race that we encountered before 
Dialogue: 0,0:52:28.20,0:52:32.64,csapp,,0,0,0,,where we were passing the address of a connected file descriptor to a worker thread 
Dialogue: 0,0:52:34.50,0:52:36.90,csapp,,0,0,0,,okay so now we're creating a race so let's say one thread 
Dialogue: 0,0:52:37.42,0:52:40.68,csapp,,0,0,0,,let's say one thread calls this function so for example 
Dialogue: 0,0:52:41.66,0:52:46.06,csapp,,0,0,0,, C time takes this this time struct as an argument 
Dialogue: 0,0:52:46.74,0:52:53.18,csapp,,0,0,0,,okay which can correspond to an arbitrary time it could be the current time or just some arbitrary time that the caller constructed 
Dialogue: 0,0:52:54.26,0:52:58.28,csapp,,0,0,0,,and it returns a pointer to a char star 
Dialogue: 0,0:52:58.30,0:53:02.66,csapp,,0,0,0,,so it just returns a pointer to a string that represents the date and the time 
Dialogue: 0,0:53:02.76,0:53:09.16,csapp,,0,0,0,,its own ASCII ASCII string that that represents the date and time 
Dialogue: 0,0:53:12.58,0:53:19.34,csapp,,0,0,0,,but it's always it's always returning a pointer to the same  the same location in memory 
Dialogue: 0,0:53:21.98,0:53:26.02,csapp,,0,0,0,,okay so you can see the problem if thread a calls this C time function
Dialogue: 0,0:53:27.20,0:53:29.42,csapp,,0,0,0,,with one with top one time struck 
Dialogue: 0,0:53:30.30,0:53:35.98,csapp,,0,0,0,,it gets back a pointer to the to the character string corresponding to that time struct 
Dialogue: 0,0:53:37.04,0:53:39.94,csapp,,0,0,0,,but now let's say before before thread a can use that 
Dialogue: 0,0:53:41.30,0:53:45.06,csapp,,0,0,0,,read that that string another thread calls C time
Dialogue: 0,0:53:46.84,0:53:49.22,csapp,,0,0,0,,and that instance of C time will overwrite that
Dialogue: 0,0:53:49.96,0:53:55.40,csapp,,0,0,0,, the copy of the time string for that that thread a computed
Dialogue: 0,0:53:56.34,0:53:58.68,csapp,,0,0,0,,so when thread a finally gets a chance to access
Dialogue: 0,0:53:59.48,0:54:04.70,csapp,,0,0,0,, that time string its accessing thread B's time string and not threat ace time string 
Dialogue: 0,0:54:06.08,0:54:11.28,csapp,,0,0,0,,okay and it just depends if thread a can get to that and read that variable before thread B 
Dialogue: 0,0:54:12.00,0:54:13.96,csapp,,0,0,0,,over writes it then everything's fine
Dialogue: 0,0:54:14.58,0:54:18.34,csapp,,0,0,0,,and otherwise threat a's accessing the wrong time string
Dialogue: 0,0:54:19.06,0:54:22.48,csapp,,0,0,0,,okay so there's there's a couple of ways to fix this like 
Dialogue: 0,0:54:23.24,0:54:27.05,csapp,,0,0,0,,we could rewrite the the function the c time function to take
Dialogue: 0,0:54:27.70,0:54:31.90,csapp,,0,0,0,,as a de nother argument that passes in
Dialogue: 0,0:54:34.78,0:54:37.36,csapp,,0,0,0,,the the location the address of the time string 
Dialogue: 0,0:54:37.40,0:54:44.70,csapp,,0,0,0,,so we could require that the caller to allocate space for the time string and passing the address to the c time function 
Dialogue: 0,0:54:45.88,0:54:51.16,csapp,,0,0,0,,okay but this has this says this would require us to change all the instances 
Dialogue: 0,0:54:52.34,0:54:53.54,csapp,,0,0,0,,where we call c time 
Dialogue: 0,0:54:55.18,0:55:01.12,csapp,,0,0,0,,but we'd also have to change the the implementation of c time in the live in the Lipsy in the library 
Dialogue: 0,0:55:03.02,0:55:08.80,csapp,,0,0,0,,right and so we can't we don't have access to Lib C source on our system 
Dialogue: 0,0:55:08.82,0:55:13.23,csapp,,0,0,0,,right so that's that's just not a feasible thing plus it would break every other program 
Dialogue: 0,0:55:13.70,0:55:16.18,csapp,,0,0,0,,that called C time right so we just can't do
Dialogue: 0,0:55:18.26,0:55:22.98,csapp,,0,0,0,,that the another op a better option is to create a new function of our own 
Dialogue: 0,0:55:24.18,0:55:28.32,csapp,,0,0,0,,okay called C time underscore TTS for thread safe 
Dialogue: 0,0:55:28.44,0:55:33.26,csapp,,0,0,0,,so we'll create our own sort of wrapper function  for it for the C time
Dialogue: 0,0:55:35.08,0:55:43.48,csapp,,0,0,0,,and we'll use a technique called lock and copy to to provide thread safe access  to 2c time 
Dialogue: 0,0:55:44.64,0:55:49.52,csapp,,0,0,0,,so the way it works is it will write this new function C time underscore TS 
Dialogue: 0,0:55:50.42,0:55:55.36,csapp,,0,0,0,,which just like c time takes this a pointer to this time struct
Dialogue: 0,0:55:55.98,0:55:57.66,csapp,,0,0,0,,but then it adds a second argument 
Dialogue: 0,0:55:59.16,0:56:04.92,csapp,,0,0,0,,which is a pointer to the threat of threads private copy of the time string 
Dialogue: 0,0:56:06.66,0:56:15.32,csapp,,0,0,0,,okay so the caller allocates the space and passes the pointer to this  to that to that string 
Dialogue: 0,0:56:17.52,0:56:22.58,csapp,,0,0,0,,and then within c time we have a local variable called shared the shared pointer 
Dialogue: 0,0:56:23.32,0:56:29.76,csapp,,0,0,0,,okay so this is going to point to that that that shared global data structure that see time is is accessing 
Dialogue: 0,0:56:31.72,0:56:36.72,csapp,,0,0,0,,and so first we do the lock that's the lock part of lock and copy by acquiring a mutex
Dialogue: 0,0:56:38.78,0:56:40.46,csapp,,0,0,0,, and then we call see time 
Dialogue: 0,0:56:42.42,0:56:44.80,csapp,,0,0,0,,so only one thread at a time we'll have this mutex 
Dialogue: 0,0:56:44.94,0:56:48.16,csapp,,0,0,0,,so whatever thread so once once we return from PE 
Dialogue: 0,0:56:48.54,0:56:52.80,csapp,,0,0,0,,we know that we're the only thread in this in this this critical section 
Dialogue: 0,0:56:53.78,0:56:57.46,csapp,,0,0,0,,so we call C time the normal lip CC time function
Dialogue: 0,0:56:58.28,0:57:02.10,csapp,,0,0,0,, which returns a pointer to this to the same location 
Dialogue: 0,0:57:03.46,0:57:06.98,csapp,,0,0,0,,and then we do the copy part we copy that that string 
Dialogue: 0,0:57:08.92,0:57:13.78,csapp,,0,0,0,,to the private string that was passed in just into our function 
Dialogue: 0,0:57:15.40,0:57:18.04,csapp,,0,0,0,,once we've done the copy then we can release the mutex 
Dialogue: 0,0:57:18.56,0:57:20.22,csapp,,0,0,0,,and then we return a pointer 
Dialogue: 0,0:57:21.68,0:57:27.86,csapp,,0,0,0,,we return private P back to the caller right ok so 
Dialogue: 0,0:57:30.16,0:57:34.20,csapp,,0,0,0,,and we don't we don't this is just more of a convenience to the caller
Dialogue: 0,0:57:34.40,0:57:38.66,csapp,,0,0,0,,because programs that are using C time are expecting to get that pointer back
Dialogue: 0,0:57:39.46,0:57:41.48,csapp,,0,0,0,,ok so by using lock and copy
Dialogue: 0,0:57:42.14,0:57:46.34,csapp,,0,0,0,, we have to we have to make changes we have to write this new function but it's fairly simple
Dialogue: 0,0:57:47.60,0:57:52.76,csapp,,0,0,0,,and then we have to make changes every place in our program where we call C time 
Dialogue: 0,0:57:52.76,0:57:56.28,csapp,,0,0,0,,we have to update those two calls to C time underscore TS
Dialogue: 0,0:57:56.92,0:58:02.72,csapp,,0,0,0,, and create this create this local string array 
Dialogue: 0,0:58:03.46,0:58:04.26,csapp,,0,0,0,,ok yes
Dialogue: 0,0:58:04.66,0:58:18.02,csapp,,0,0,0,,it has to be the variable cost
Dialogue: 0,0:58:21.04,0:58:24.56,csapp,,0,0,0,,well typically these functions are returning pointers to some data structure 
Dialogue: 0,0:58:25.00,0:58:30.22,csapp,,0,0,0,,and so they're they're sort of updating the data structure and then returning a pointer to it so
Dialogue: 0,0:58:32.10,0:58:33.82,csapp,,0,0,0,, it wouldn't makes I don't know how
Dialogue: 0,0:58:34.58,0:58:37.64,csapp,,0,0,0,, I guess it could return a struct and it would always return 
Dialogue: 0,0:58:38.60,0:58:39.28,csapp,,0,0,0,,now now
Dialogue: 0,0:58:43.52,0:58:48.16,csapp,,0,0,0,,I can't think of any I can't think of any reason why they would turn anything but a pointer
Dialogue: 0,0:58:48.62,0:58:52.72,csapp,,0,0,0,, because they're they're typically updating some some data structure 
Dialogue: 0,0:58:53.30,0:58:54.76,csapp,,0,0,0,,and then returning a pointer to it
Dialogue: 0,0:59:02.18,0:59:03.70,csapp,,0,0,0,,if they were returning 
Dialogue: 0,0:59:06.18,0:59:07.70,csapp,,0,0,0,,if they were returning 
Dialogue: 0,0:59:08.98,0:59:13.04,csapp,,0,0,0,,scalars those scalars would always be returned in EAX  or RA X 
Dialogue: 0,0:59:13.84,0:59:16.32,csapp,,0,0,0,,all right so actually that would be okay right it would just be 
Dialogue: 0,0:59:17.06,0:59:19.16,csapp,,0,0,0,,it's the pointer that causes a problem because
Dialogue: 0,0:59:20.32,0:59:23.00,csapp,,0,0,0,,  it's it's always returning that value in EAX 
Dialogue: 0,0:59:23.00,0:59:26.72,csapp,,0,0,0,,but it's always returning the same value in EAX always pointing to the same
Dialogue: 0,0:59:27.22,0:59:30.56,csapp,,0,0,0,, the same data structure okay good
Dialogue: 0,0:59:34.52,0:59:35.48,csapp,,0,0,0,,okay now one-
Dialogue: 0,0:59:37.58,0:59:41.98,csapp,,0,0,0,,one potentially significant disadvantage of lock and copy is that
Dialogue: 0,0:59:43.24,0:59:49.06,csapp,,0,0,0,,this this copy might not always be as simple as just doing like a stir copy if
Dialogue: 0,0:59:50.02,0:59:56.62,csapp,,0,0,0,,if it's a complex diff if the function that you're calling is computing some complex data structure like a nested 
Dialogue: 0,0:59:57.26,1:00:00.40,csapp,,0,0,0,,you know a struct which contains structs and pointers to arrays
Dialogue: 0,1:00:01.28,1:00:04.66,csapp,,0,0,0,, then this copy can get can get quite complicated right
Dialogue: 0,1:00:05.10,1:00:07.06,csapp,,0,0,0,, it it would require what we call a deep copy 
Dialogue: 0,1:00:08.20,1:00:10.50,csapp,,0,0,0,,so that can be that can be very difficult to 
Dialogue: 0,1:00:11.16,1:00:15.84,csapp,,0,0,0,,but in this case it's simple we're just we're just doing a we're just copying one string to another
Dialogue: 0,1:00:17.44,1:00:18.62,csapp,,0,0,0,,okay and then finally the
Dialogue: 0,1:00:19.60,1:00:22.80,csapp,,0,0,0,, the fourth class of thread unsafe functions are functions that 
Dialogue: 0,1:00:23.40,1:00:26.20,csapp,,0,0,0,,call unsafe functions right so it's kind of obvious 
Dialogue: 0,1:00:27.04,1:00:32.16,csapp,,0,0,0,,and then the obvious fix is to not call thread unsafe functions from within your function 
Dialogue: 0,1:00:32.76,1:00:34.04,csapp,,0,0,0,,and then you can make it thread safe
Dialogue: 0,1:00:37.10,1:00:39.16,csapp,,0,0,0,,now there's a very interesting an
Dialogue: 0,1:00:39.86,1:00:44.34,csapp,,0,0,0,,important subclass of thread-safe functions called reentrant functions 
Dialogue: 0,1:00:45.76,1:00:49.20,csapp,,0,0,0,,so a reentrant a function is reentrant 
Dialogue: 0,1:00:50.22,1:00:53.82,csapp,,0,0,0,,if it contains no accesses to shared to shared variables 
Dialogue: 0,1:00:54.72,1:00:59.14,csapp,,0,0,0,,okay so if all the if every variable that it accesses is
Dialogue: 0,1:00:59.56,1:01:05.10,csapp,,0,0,0,,contained on the is declared as a local variable and stored on the stack 
Dialogue: 0,1:01:05.86,1:01:09.30,csapp,,0,0,0,,for that function okay that's called a reentrant function 
Dialogue: 0,1:01:10.10,1:01:13.38,csapp,,0,0,0,,and because there's no accesses of any kind to shared variables
Dialogue: 0,1:01:14.10,1:01:17.10,csapp,,0,0,0,, there's no there's no synchronization required 
Dialogue: 0,1:01:17.10,1:01:22.14,csapp,,0,0,0,,because every function is is operating accessing its own local copy of all the variables 
Dialogue: 0,1:01:23.90,1:01:29.58,csapp,,0,0,0,,and if multiple threads execute  two instances of a reentrant function
Dialogue: 0,1:01:30.62,1:01:33.16,csapp,,0,0,0,,it's okay each thread has its own separate stack
Dialogue: 0,1:01:33.80,1:01:39.56,csapp,,0,0,0,, so you don't need to worry about any kind of synchronization they can run independently 
Dialogue: 0,1:01:40.12,1:01:45.76,csapp,,0,0,0,,so the reason reentrant functions are so important is because it's expensive to do synchronization 
Dialogue: 0,1:01:47.10,1:01:51.46,csapp,,0,0,0,,and so what you can avoid it completely with these reentrant function reentrant functions 
Dialogue: 0,1:01:51.48,1:01:52.48,csapp,,0,0,0,,so they're they're efficient 
Dialogue: 0,1:01:57.52,1:02:01.24,csapp,,0,0,0,,so as that as the diagram shows every reentrant function is thread safe 
Dialogue: 0,1:02:01.96,1:02:04.52,csapp,,0,0,0,,but not every thread safe function is reentrant 
Dialogue: 0,1:02:07.48,1:02:11.92,csapp,,0,0,0,,so we saw that before right when we have a function that accesses a shared variable
Dialogue: 0,1:02:12.48,1:02:15.90,csapp,,0,0,0,, we can make it thread safe by protecting it with a mutex 
Dialogue: 0,1:02:17.98,1:02:21.62,csapp,,0,0,0,,okay but it's not reenter n't because it's it's X it's accessing shared variables okay
Dialogue: 0,1:02:28.30,1:02:34.74,csapp,,0,0,0,,now on all the functions in the standard c library which are enumerated in the back of your k and r texture thread-safe
Dialogue: 0,1:02:35.66,1:02:37.60,csapp,,0,0,0,,okay but not not necessarily reentrant
Dialogue: 0,1:02:39.36,1:02:44.20,csapp,,0,0,0,,and most most syscalls are thread safe with just a with a few exceptions that I've listed here
Dialogue: 0,1:02:44.98,1:02:47.74,csapp,,0,0,0,, I don't I don't think I don't think this is complete
Dialogue: 0,1:02:47.76,1:02:50.44,csapp,,0,0,0,, but these are just some examples of some notable ones
Dialogue: 0,1:02:51.74,1:02:55.22,csapp,,0,0,0,, and so for each each of these thread unsafe functions 
Dialogue: 0,1:02:57.30,1:02:59.92,csapp,,0,0,0,,Linux provides a reentrant version
Dialogue: 0,1:03:00.66,1:03:02.88,csapp,,0,0,0,, which is denoted by underscore R 
Dialogue: 0,1:03:03.76,1:03:08.40,csapp,,0,0,0,,and then that reentrant version has a different different set of parameters typically 
Dialogue: 0,1:03:10.08,1:03:19.90,csapp,,0,0,0,,the only exception that I know about is I net n to a which is an episode of an obsolete Network protocol for converting 
Dialogue: 0,1:03:20.86,1:03:25.14,csapp,,0,0,0,,sort of binary Network addresses to human readable ASCII addresses 
Dialogue: 0,1:03:25.66,1:03:30.48,csapp,,0,0,0,,but this is this is ops been obsoleted by by other calls 
Dialogue: 0,1:03:30.48,1:03:36.02,csapp,,0,0,0,,so it's I guess they just never never bothered to create a reentrant version for it
Dialogue: 0,1:03:36.38,1:03:38.96,csapp,,0,0,0,,because there's there's other options alternatives to using that
Dialogue: 0,1:03:41.28,1:03:45.10,csapp,,0,0,0,,okay another so another thing we have to worry about is we've seen is races 
Dialogue: 0,1:03:46.16,1:03:49.42,csapp,,0,0,0,, again this is the real Bugaboo in in threaded programs 
Dialogue: 0,1:03:50.58,1:03:53.82,csapp,,0,0,0,,and it typically involves some kind of unexpected sharing 
Dialogue: 0,1:03:54.62,1:03:57.24,csapp,,0,0,0,,so in this case I'm going to revisit this
Dialogue: 0,1:03:58.12,1:04:02.16,csapp,,0,0,0,, this this incorrect threaded program
Dialogue: 0,1:04:03.14,1:04:07.38,csapp,,0,0,0,, that where we introduce introduced a race by passing when we create the thread 
Dialogue: 0,1:04:08.74,1:04:13.02,csapp,,0,0,0,,we we pass the argument to the thread which is like the local thread ID 
Dialogue: 0,1:04:14.30,1:04:19.18,csapp,,0,0,0,,we pass an address of a variable that we have stored on the stack 
Dialogue: 0,1:04:19.92,1:04:23.66,csapp,,0,0,0,, and is Katun the eye that the the loop loop iterator 
Dialogue: 0,1:04:26.00,1:04:26.68,csapp,,0,0,0,,and so 
Dialogue: 0,1:04:29.82,1:04:33.92,csapp,,0,0,0,,we've seen that this causes this causes a race so
Dialogue: 0,1:04:35.74,1:04:41.26,csapp,,0,0,0,,we incurred we we set initially I is 0 then we create a new thread which is pure thread 0 
Dialogue: 0,1:04:42.14,1:04:51.08,csapp,,0,0,0,,and then this thread dereferences the pointer to get its local copy of the this sort of local thread ID 
Dialogue: 0,1:04:53.26,1:04:54.86,csapp,,0,0,0,,but now we've introduced the race
Dialogue: 0,1:04:56.88,1:04:58.52,csapp,,0,0,0,, between the increment of I 
Dialogue: 0,1:05:00.50,1:05:04.86,csapp,,0,0,0,,and the dereferencing of the incrementing of I and the main thread 
Dialogue: 0,1:05:05.30,1:05:08.00,csapp,,0,0,0,,and the dereferencing of I in the peer thread
Dialogue: 0,1:05:09.12,1:05:13.42,csapp,,0,0,0,, so if this dereferencing happens before I is incremented then we're good 
Dialogue: 0,1:05:14.68,1:05:17.26,csapp,,0,0,0,,but if this dereferencing happens after
Dialogue: 0,1:05:18.08,1:05:20.96,csapp,,0,0,0,, we increment I so in other words at when I equal 1 
Dialogue: 0,1:05:22.44,1:05:26.94,csapp,,0,0,0,,then we get the wrong value in the peer thread for for my ID
Dialogue: 0,1:05:30.46,1:05:32.96,csapp,,0,0,0,,so you might wonder I think there was a question before about 
Dialogue: 0,1:05:33.98,1:05:39.24,csapp,,0,0,0,,you know this seems that the odds of this happening seems so low why why are you even worrying about it 
Dialogue: 0,1:05:40.66,1:05:46.60,csapp,,0,0,0,,so we actually create just to sort of test this out we wrote a program to see if we could 
Dialogue: 0,1:05:47.78,1:05:52.60,csapp,,0,0,0,,see if we could actually see this race in practice
Dialogue: 0,1:05:53.68,1:05:58.22,csapp,,0,0,0,,and that's one of the great things about like 2:13 is that you we can just try stuff out right so 
Dialogue: 0,1:05:58.94,1:05:59.94,csapp,,0,0,0,,so we just tried it out 
Dialogue: 0,1:06:01.94,1:06:07.90,csapp,,0,0,0,,so we wrote it we wrote a simple main thread that creates a hundred different threads
Dialogue: 0,1:06:08.76,1:06:15.54,csapp,,0,0,0,, each with then we passed the art as the argument we passed the address of of this local variable I okay 
Dialogue: 0,1:06:17.76,1:06:21.34,csapp,,0,0,0,, and then in each peer thread we detach the thread dereference 
Dialogue: 0,1:06:22.06,1:06:25.46,csapp,,0,0,0,, and then we have a function that saves the value so we're we're storing 
Dialogue: 0,1:06:27.14,1:06:31.86,csapp,,0,0,0,,we're storing that value of I  for future reference
Dialogue: 0,1:06:33.90,1:06:35.36,csapp,,0,0,0,,okay so now if there's no race 
Dialogue: 0,1:06:36.52,1:06:40.74,csapp,,0,0,0,,each of the 100 threads would get a separate distinct thread ID 
Dialogue: 0,1:06:40.98,1:06:43.72,csapp,,0,0,0,,right so each each value 0 through 99 
Dialogue: 0,1:06:44.16,1:06:45.60,csapp,,0,0,0,,if we made a histogram of it 
Dialogue: 0,1:06:46.34,1:06:50.72,csapp,,0,0,0,,there would be exactly one instance of each of each value of I
Dialogue: 0,1:06:52.42,1:06:56.54,csapp,,0,0,0,,okay but if there was a race there would be for some values of Y 
Dialogue: 0,1:06:56.54,1:06:59.56,csapp,,0,0,0,,there would be multiple instances that were encountered in multiple threads 
Dialogue: 0,1:07:00.76,1:07:02.64,csapp,,0,0,0,,okay so you can see if we go back here 
Dialogue: 0,1:07:04.02,1:07:11.62,csapp,,0,0,0,,if if if we lose if the peer thread loses the race and I gets incremented before it can dereference
Dialogue: 0,1:07:15.28,1:07:22.08,csapp,,0,0,0,, now we've got peer thread zero actually gets a an ID of one 
Dialogue: 0,1:07:25.70,1:07:27.52,csapp,,0,0,0,, okay and then peer thread one 
Dialogue: 0,1:07:28.32,1:07:34.24,csapp,,0,0,0,,if there's no race it'll it'll get the correct value of one so now we've got two instances of one okay
Dialogue: 0,1:07:36.86,1:07:38.36,csapp,,0,0,0,,so let's look so this is the case
Dialogue: 0,1:07:40.48,1:07:45.58,csapp,,0,0,0,, so we've plotted the results for a case where there's no race so along the x-axis sorry this is too small 
Dialogue: 0,1:07:46.18,1:07:51.20,csapp,,0,0,0,,the x-axis gives us all the 100 values of I 0 through 99 
Dialogue: 0,1:07:51.72,1:07:55.88,csapp,,0,0,0,, and then the y-axis is the count so this is a hit we're doing a histogram of 
Dialogue: 0,1:07:57.36,1:08:00.12,csapp,,0,0,0,,for these all the values 0 through 99 
Dialogue: 0,1:08:01.22,1:08:05.46,csapp,,0,0,0,,so in this case every value has exactly one instance so no race
Dialogue: 0,1:08:06.26,1:08:14.64,csapp,,0,0,0,,there was no race in in no races in involved in all 99 are all 100 instances
Dialogue: 0,1:08:16.52,1:08:18.22,csapp,,0,0,0,,if we run it on a single core laptop
Dialogue: 0,1:08:18.30,1:08:22.08,csapp,,0,0,0,, so now each thread is sort of taking its turn on a single core 
Dialogue: 0,1:08:24.06,1:08:27.40,csapp,,0,0,0,,it happens a few times right so there's a few times where
Dialogue: 0,1:08:28.18,1:08:31.50,csapp,,0,0,0,, the one thread gets preempted and the other thread 
Dialogue: 0,1:08:31.98,1:08:40.64,csapp,,0,0,0,,begins to run before it can so the peers when one thread gets preempted before I can dereference
Dialogue: 0,1:08:41.18,1:08:44.10,csapp,,0,0,0,, the variable so it gets the wrong the wrong value
Dialogue: 0,1:08:44.40,1:08:50.38,csapp,,0,0,0,,  but it's not very common it just it happened one two three four five six seven times 
Dialogue: 0,1:08:51.46,1:08:54.76,csapp,,0,0,0,,but now if we run this program on a on a multi-core server 
Dialogue: 0,1:08:55.48,1:08:58.30,csapp,,0,0,0,,you can see it happens a lot in fact it happens most of the time 
Dialogue: 0,1:08:58.68,1:09:04.60,csapp,,0,0,0,,so it almost never we almost never get the correct the correct value for for my ID
Dialogue: 0,1:09:06.80,1:09:11.38,csapp,,0,0,0,,okay so this is just another example of some of the create the things that can just drive you crazy
Dialogue: 0,1:09:12.04,1:09:15.78,csapp,,0,0,0,, if you're not careful when you when you program is and threads with threads 
Dialogue: 0,1:09:18.36,1:09:24.82,csapp,,0,0,0,,okay and as so as we saw the the way to eliminate these kind of erases  is to avoid 
Dialogue: 0,1:09:25.82,1:09:30.06,csapp,,0,0,0,, this the sharing of state and in this case by allocating 
Dialogue: 0,1:09:31.08,1:09:35.31,csapp,,0,0,0,,for each thread allocating a separate block in the in the heap 
Dialogue: 0,1:09:35.68,1:09:40.44,csapp,,0,0,0,,that will hold the that will hold the the local ID for that thread 
Dialogue: 0,1:09:40.88,1:09:47.60,csapp,,0,0,0,,and then passing a pointer to that that unique block of storage to the thread
Dialogue: 0,1:09:51.16,1:09:54.14,csapp,,0,0,0,,okay so if that if all of that isn't enough to worry about 
Dialogue: 0,1:09:55.58,1:09:57.22,csapp,,0,0,0,,and by now you should be losing sleep 
Dialogue: 0,1:09:58.60,1:10:01.42,csapp,,0,0,0,,at the very thought of writing a threaded program
Dialogue: 0,1:10:02.02,1:10:04.10,csapp,,0,0,0,,another thing to worry about is deadlock
Dialogue: 0,1:10:06.70,1:10:13.56,csapp,,0,0,0,,okay so here a program is deadlocked if it's waiting for some condition to occur that will never occur 
Dialogue: 0,1:10:18.16,1:10:21.28,csapp,,0,0,0,,okay so let's say a typical scenario right pee
Dialogue: 0,1:10:22.30,1:10:26.16,csapp,,0,0,0,, pee is the potential the pee operation is a potential problem because it blocks
Dialogue: 0,1:10:27.64,1:10:31.70,csapp,,0,0,0,,right and it's waiting for that semaphore that it's blocking on to become nonzero
Dialogue: 0,1:10:33.84,1:10:36.94,csapp,,0,0,0,, well it's it's not too hard to imagine scenarios where
Dialogue: 0,1:10:37.96,1:10:44.38,csapp,,0,0,0,, some there's some combination of pees of pee operations that sort of block each other
Dialogue: 0,1:10:44.92,1:10:49.00,csapp,,0,0,0,,out okay and make it impossible for the condition they're waiting on to occur 
Dialogue: 0,1:10:49.98,1:10:54.44,csapp,,0,0,0,,so for example let's say you've got two two threads 
Dialogue: 0,1:10:55.08,1:10:58.56,csapp,,0,0,0,, that need two two threads one and two
Dialogue: 0,1:10:59.22,1:11:03.18,csapp,,0,0,0,, that need two different resources a and B in order to proceed 
Dialogue: 0,1:11:03.18,1:11:06.88,csapp,,0,0,0,,so they have to acquire they have to do a pee on the mutex 
Dialogue: 0,1:11:07.00,1:11:10.76,csapp,,0,0,0,,that on this on the mutex that that's associated with 
Dialogue: 0,1:11:12.16,1:11:14.92,csapp,,0,0,0,,the mutexes that are associated with these two resources 
Dialogue: 0,1:11:16.64,1:11:22.32,csapp,,0,0,0,,so let's say process one acquires a so it does a pee on a x' mutex
Dialogue: 0,1:11:23.94,1:11:28.50,csapp,,0,0,0,, that's one it's okay so it succeeds at it so it acquires that resource
Dialogue: 0,1:11:30.04,1:11:33.38,csapp,,0,0,0,, and then it gets preempted by thread to
Dialogue: 0,1:11:34.06,1:11:35.28,csapp,,0,0,0,, which acquires B 
Dialogue: 0,1:11:36.74,1:11:41.14,csapp,,0,0,0,,first instead of acquiring a thread B for some reason acquires B 
Dialogue: 0,1:11:42.20,1:11:46.06,csapp,,0,0,0,,so now thread a holds the lock on resource a 
Dialogue: 0,1:11:47.08,1:11:49.78,csapp,,0,0,0,,and thread two holds the lock on resource B 
Dialogue: 0,1:11:52.08,1:11:56.06,csapp,,0,0,0,,and so now let's say process thread two gets preempted so now 
Dialogue: 0,1:11:56.88,1:11:59.18,csapp,,0,0,0,,and thread one runs and so now it's waiting 
Dialogue: 0,1:12:00.60,1:12:02.32,csapp,,0,0,0,,it's trying to tries to acquire
Dialogue: 0,1:12:03.18,1:12:05.36,csapp,,0,0,0,,the the lock on resource b-
Dialogue: 0,1:12:07.08,1:12:09.08,csapp,,0,0,0,,but threat to our holds that lock 
Dialogue: 0,1:12:10.54,1:12:15.02,csapp,,0,0,0,,and at the same time thread to tries to acquire the lock on resource a 
Dialogue: 0,1:12:17.04,1:12:18.64,csapp,,0,0,0,,but process one is holding that right 
Dialogue: 0,1:12:18.72,1:12:25.22,csapp,,0,0,0,,so they're each so here's the case where thread a is waiting for this semaphore 
Dialogue: 0,1:12:26.02,1:12:28.52,csapp,,0,0,0,,associated with B to become non zero 
Dialogue: 0,1:12:29.36,1:12:31.46,csapp,,0,0,0,,so it's blocked in this P operation 
Dialogue: 0,1:12:32.10,1:12:39.60,csapp,,0,0,0,,and at the same time thread two is blocked in the P operation for for for resource a 
Dialogue: 0,1:12:40.76,1:12:44.22,csapp,,0,0,0,,neither of those semaphores will ever be released 
Dialogue: 0,1:12:44.70,1:12:46.86,csapp,,0,0,0,,so thread one and two are deadlocked 
Dialogue: 0,1:12:49.70,1:12:55.38,csapp,,0,0,0,,okay and it it happened because just there was this innocuous little bug in this case 
Dialogue: 0,1:12:55.92,1:12:59.04,csapp,,0,0,0,,where one the threads acquired their resources in different orders
Dialogue: 0,1:13:05.62,1:13:08.78,csapp,,0,0,0,,so here's an example of a program that deadlocks 
Dialogue: 0,1:13:08.98,1:13:14.78,csapp,,0,0,0,,and if you looked at this you know the fact that it's wrong and buggy doesn't jump out at you right 
Dialogue: 0,1:13:14.82,1:13:17.86,csapp,,0,0,0,,so this is this kind of stuff is very subtle 
Dialogue: 0,1:13:17.86,1:13:22.22,csapp,,0,0,0,,so here's here's a program we're going to create two threads 
Dialogue: 0,1:13:24.52,1:13:29.12,csapp,,0,0,0,,we've got an array so and we have an array of meu Texas
Dialogue: 0,1:13:31.64,1:13:33.28,csapp,,0,0,0,, an array of two mutexes 
Dialogue: 0,1:13:34.58,1:13:38.62,csapp,,0,0,0,,so we create two threads and we pass each thread 
Dialogue: 0,1:13:39.16,1:13:42.86,csapp,,0,0,0,,it's a local thread ID so of 0 & 1 
Dialogue: 0,1:13:43.70,1:13:49.56,csapp,,0,0,0,,and so here we're avoiding the race we're just casting this thread ID to be -  a pointer okay 
Dialogue: 0,1:13:49.96,1:13:52.52,csapp,,0,0,0,,which is a little strange but it's okay
Dialogue: 0,1:13:53.38,1:13:55.26,csapp,,0,0,0,,and then we're waiting for those threads to finish 
Dialogue: 0,1:13:57.62,1:14:05.60,csapp,,0,0,0,, ok each thread is going to acquire two these two semaphores
Dialogue: 0,1:14:06.18,1:14:07.60,csapp,,0,0,0,, these two mutexes
Dialogue: 0,1:14:08.78,1:14:10.78,csapp,,0,0,0,,but it's going to do it in a different order
Dialogue: 0,1:14:14.94,1:14:18.44,csapp,,0,0,0,,okay so it's going to do it as a function it's going to take the ID 
Dialogue: 0,1:14:18.44,1:14:22.40,csapp,,0,0,0,,so it's going to sew thread zero will first acquire a mutex 0 
Dialogue: 0,1:14:23.82,1:14:27.68,csapp,,0,0,0,,and then and then acquire mutex 1-0 
Dialogue: 0,1:14:27.68,1:14:29.70,csapp,,0,0,0,,so then it will acquire mutex 1 
Dialogue: 0,1:14:31.50,1:14:36.20,csapp,,0,0,0,,and thread 1 will first acquire mutex one 
Dialogue: 0,1:14:36.98,1:14:38.56,csapp,,0,0,0,,and then acquire mutex 0
Dialogue: 0,1:14:41.86,1:14:46.98,csapp,,0,0,0,,0 ok so if we were to draw that diet and then and then it will attempt to then it will increment count 
Dialogue: 0,1:14:47.36,1:14:48.50,csapp,,0,0,0,,so this is totally bogus 
Dialogue: 0,1:14:48.66,1:14:51.34,csapp,,0,0,0,,but it's just to illustrate the problem 
Dialogue: 0,1:14:52.74,1:14:58.08,csapp,,0,0,0,,so you can see thread 0 does a peon semaphore 0 followed by a peon semaphore 1 
Dialogue: 0,1:14:58.86,1:15:01.30,csapp,,0,0,0,,and thread 1 does a peon semaphore 1 
Dialogue: 0,1:15:01.98,1:15:03.92,csapp,,0,0,0,,followed by a peon semaphore 0 
Dialogue: 0,1:15:06.50,1:15:10.22,csapp,,0,0,0,,and so we can see this that this is a problem very clearly 
Dialogue: 0,1:15:10.42,1:15:12.52,csapp,,0,0,0,,if we go back to our progress graphs
Dialogue: 0,1:15:17.08,1:15:19.40,csapp,,0,0,0,,so if you look at thread 0 
Dialogue: 0,1:15:20.36,1:15:22.42,csapp,,0,0,0,,it's doing a peon semaphore 1 
Dialogue: 0,1:15:22.90,1:15:28.22,csapp,,0,0,0,,and of and it followed a peon semaphore 1 followed by a V on semaphore 1 
Dialogue: 0,1:15:30.82,1:15:35.94,csapp,,0,0,0,,and thread 1 is also is doing a peon semaphore 1 followed by a V on semaphore 1 
Dialogue: 0,1:15:36.64,1:15:44.20,csapp,,0,0,0,,so if you take if you take the intersection of these two regions 
Dialogue: 0,1:15:45.00,1:15:47.92,csapp,,0,0,0,,you get the forbidden region for semaphore 1 
Dialogue: 0,1:15:48.04,1:15:51.20,csapp,,0,0,0,,okay so this is the region that enforces mutual exclusion 
Dialogue: 0,1:15:51.90,1:15:56.00,csapp,,0,0,0,,so on this on this the resource associated with semaphore 1
Dialogue: 0,1:15:58.78,1:16:02.54,csapp,,0,0,0,, and if you do the same thing for semaphore 0 so here in thread 1 
Dialogue: 0,1:16:03.20,1:16:06.26,csapp,,0,0,0,,we're acquiring semaphore 0 here and releasing it here 
Dialogue: 0,1:16:07.72,1:16:12.82,csapp,,0,0,0,,and we're in thread 0 we're acquiring it here  and releasing it here 
Dialogue: 0,1:16:13.96,1:16:16.02,csapp,,0,0,0,,so if you take the intersection of those two 
Dialogue: 0,1:16:16.66,1:16:19.84,csapp,,0,0,0,,you get this forbidden region for s0
Dialogue: 0,1:16:21.66,1:16:22.84,csapp,,0,0,0,,ok now the problem
Dialogue: 0,1:16:26.86,1:16:31.22,csapp,,0,0,0,,his right is this region here this so-called deadlock region 
Dialogue: 0,1:16:33.74,1:16:35.42,csapp,,0,0,0,,because by the rules of 
Dialogue: 0,1:16:36.58,1:16:37.98,csapp,,0,0,0,,you know time can't go backwards 
Dialogue: 0,1:16:40.82,1:16:44.16,csapp,,0,0,0,,heart once  the trajectory enters into the this deadlock region
Dialogue: 0,1:16:45.08,1:16:45.88,csapp,,0,0,0,,then it's doomed 
Dialogue: 0,1:16:46.48,1:16:49.68,csapp,,0,0,0,,because there's no once it enters this 
Dialogue: 0,1:16:50.64,1:16:54.54,csapp,,0,0,0,,once it enters this deadlock region there's nowhere for it to go eventually 
Dialogue: 0,1:16:55.60,1:16:57.26,csapp,,0,0,0,,no matter how it progresses 
Dialogue: 0,1:16:57.82,1:17:01.24,csapp,,0,0,0,,every trajectory will lead to to this point here where
Dialogue: 0,1:17:01.36,1:17:04.66,csapp,,0,0,0,, it's boxed in and can't and can no longer proceed
Dialogue: 0,1:17:11.20,1:17:12.06,csapp,,0,0,0,,so
Dialogue: 0,1:17:15.34,1:17:19.08,csapp,,0,0,0,, so interestingly this this sort of this this region back here 
Dialogue: 0,1:17:20.02,1:17:24.98,csapp,,0,0,0,,on the on the the sort of the tail end of the of these two forbidden regions
Dialogue: 0,1:17:25.66,1:17:27.98,csapp,,0,0,0,, this represents states that can never be reached
Dialogue: 0,1:17:28.26,1:17:32.44,csapp,,0,0,0,, so these are on unreachable states which may or may not be interesting 
Dialogue: 0,1:17:33.68,1:17:35.44,csapp,,0,0,0,,and then what makes this so nasty 
Dialogue: 0,1:17:36.96,1:17:37.76,csapp,,0,0,0,,is that 
Dialogue: 0,1:17:39.26,1:17:42.68,csapp,,0,0,0,,it's non-deterministic right some programs some trajectories
Dialogue: 0,1:17:44.28,1:17:47.36,csapp,,0,0,0,, if they get lucky they'll skirt this deadlock region 
Dialogue: 0,1:17:48.44,1:17:50.66,csapp,,0,0,0,,and then the program will run fine right
Dialogue: 0,1:17:52.94,1:17:55.58,csapp,,0,0,0,,there's okay so if it's trajectory maybe
Dialogue: 0,1:17:57.50,1:18:01.56,csapp,,0,0,0,, just by some you know just by some arbitrary scheduling decision 
Dialogue: 0,1:18:01.90,1:18:04.22,csapp,,0,0,0,,made by the colonel the trajectory 
Dialogue: 0,1:18:07.28,1:18:11.66,csapp,,0,0,0,,trajectory gets passed the deadlock region in this direction 
Dialogue: 0,1:18:13.00,1:18:16.98,csapp,,0,0,0,,and then it'll eventually run without any problem 
Dialogue: 0,1:18:17.84,1:18:25.46,csapp,,0,0,0,,so it's just it's only if the trajectory lands it within the deadlock region then there were that we're in trouble 
Dialogue: 0,1:18:26.76,1:18:29.76,csapp,,0,0,0,,so so this is the really nasty the really nasty part is
Dialogue: 0,1:18:30.28,1:18:34.78,csapp,,0,0,0,,that you may run your program for a million times  and every trajectory 
Dialogue: 0,1:18:36.76,1:18:40.54,csapp,,0,0,0,,every one of those million trajectories skirts the deadlock region 
Dialogue: 0,1:18:41.40,1:18:43.76,csapp,,0,0,0,,okay but on the million and first time that you run it
Dialogue: 0,1:18:44.50,1:18:47.50,csapp,,0,0,0,,it it enters the deadlock region and then deadlocks 
Dialogue: 0,1:18:50.60,1:18:53.72,csapp,,0,0,0,,okay so it's it's it's very it's a very tough problem to deal with 
Dialogue: 0,1:18:55.06,1:18:57.80,csapp,,0,0,0,,now fortunately you it's easy to avoid 
Dialogue: 0,1:18:58.94,1:19:07.32,csapp,,0,0,0,,if if threads that are acquiring locks on on resources acquire all those locks in the same order 
Dialogue: 0,1:19:07.66,1:19:11.78,csapp,,0,0,0,,okay so in our example if we rewrite this program
Dialogue: 0,1:19:11.86,1:19:17.42,csapp,,0,0,0,, so that each thread thread 0 and thread 1 acquire their locks in the same order 
Dialogue: 0,1:19:18.36,1:19:22.08,csapp,,0,0,0,,semaphore 0 first followed by semaphore 1
Dialogue: 0,1:19:25.00,1:19:28.72,csapp,,0,0,0,,then if that happens and we you can see
Dialogue: 0,1:19:28.96,1:19:31.70,csapp,,0,0,0,,it eliminates the debt the potential deadlock region 
Dialogue: 0,1:19:35.76,1:19:45.72,csapp,,0,0,0,,okay so now any trajectory that we take   will will be fine  
Dialogue: 0,1:19:45.74,1:19:49.42,csapp,,0,0,0,,because we've eliminated that that that deadlock region 
Dialogue: 0,1:19:50.12,1:19:53.44,csapp,,0,0,0,,and the the order that we release the locks doesn't matter
Dialogue: 0,1:19:53.44,1:19:57.50,csapp,,0,0,0,,because that that sort of affects the the
Dialogue: 0,1:20:00.38,1:20:06.10,csapp,,0,0,0,, it affects this or unreachable region you know the size and shape of this unreachable reason region 
Dialogue: 0,1:20:08.02,1:20:13.68,csapp,,0,0,0,,but it there's never the order that we release the locks can never introduce a deadlock region
Dialogue: 0,1:20:17.66,1:20:19.20,csapp,,0,0,0,,okay so that's it for today 
Dialogue: 0,1:20:22.40,1:20:29.44,csapp,,0,0,0,,hope you all have a very nice Thanksgiving holiday and we'll see you on Tuesday
