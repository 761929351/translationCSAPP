[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video File: ../../../../Desktop/csapp/Lecture 25  Synchronization  Advanced.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 889
Active Line: 898
Video Position: 144672

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.03,0:00:01.70,English,,0,0,0,,Well good afternoon everybody
Dialogue: 0,0:00:00.03,0:00:01.70,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.68,0:00:07.94,English,,0,0,0,,Welcome good to see you and welcome to our viewers on video as well
Dialogue: 0,0:00:02.68,0:00:07.94,Chinese,,0,0,0,,欢迎很高兴见到你，也欢迎观看我们的观众
Dialogue: 0,0:00:09.54,0:00:15.96,English,,0,0,0,,Okay so today we're going to look at some additional issues around the problem of synchronizing threaded programs
Dialogue: 0,0:00:09.54,0:00:15.96,Chinese,,0,0,0,,好的，今天我们将讨论有关同步线程程序问题的一些其他问题
Dialogue: 0,0:00:17.72,0:00:21.44,English,,0,0,0,,First so let's review from last time of a few of the concepts
Dialogue: 0,0:00:17.72,0:00:21.44,Chinese,,0,0,0,,首先让我们从上一次回顾一些概念
Dialogue: 0,0:00:22.32,0:00:29.56,English,,0,0,0,,So recall that a semaphore is a non-negative global synchronization variable
Dialogue: 0,0:00:22.32,0:00:29.56,Chinese,,0,0,0,,所以请记住，信号量是一个非负全局同步变量
Dialogue: 0,0:00:29.56,0:00:31.36,English,,0,0,0,,It's manipulated by P and V operations
Dialogue: 0,0:00:29.56,0:00:31.36,Chinese,,0,0,0,,它由P和V操作操纵
Dialogue: 0,0:00:32.28,0:00:36.92,English,,0,0,0,,And the P operation takes as an argument a semaphore
Dialogue: 0,0:00:32.28,0:00:36.92,Chinese,,0,0,0,,并且P操作将信号量作为参数
Dialogue: 0,0:00:38.70,0:00:44.96,English,,0,0,0,,If the semaphore values nonzero it decrements the semaphore and then continues
Dialogue: 0,0:00:38.70,0:00:44.96,Chinese,,0,0,0,,如果信号量值非零，则递减信号量然后继续
Dialogue: 0,0:00:45.74,0:00:48.08,English,,0,0,0,,If the semaphore values zero
Dialogue: 0,0:00:45.74,0:00:48.08,Chinese,,0,0,0,,如果信号量值为零
Dialogue: 0,0:00:49.58,0:00:55.98,English,,0,0,0,,Then it blocks waiting for that semaphore value to be incremented by a V operation
Dialogue: 0,0:00:49.58,0:00:55.98,Chinese,,0,0,0,,然后它阻止等待该信号量值通过V操作递增
Dialogue: 0,0:00:56.86,0:01:01.82,English,,0,0,0,,After the V operation increments after some V operation increments the semaphore
Dialogue: 0,0:00:56.86,0:01:01.82,Chinese,,0,0,0,,在一些V操作增加信号量之后V操作递增之后
Dialogue: 0,0:01:03.24,0:01:08.92,English,,0,0,0,,The P operation continues by decrementing s and then returning control to the caller
Dialogue: 0,0:01:03.24,0:01:08.92,Chinese,,0,0,0,,P操作继续递减s然后将控制返回给调用者
Dialogue: 0,0:01:10.06,0:01:12.46,English,,0,0,0,,The V operation never blocks
Dialogue: 0,0:01:10.06,0:01:12.46,Chinese,,0,0,0,,V操作永远不会阻塞
Dialogue: 0,0:01:14.00,0:01:17.66,English,,0,0,0,,It first it increments the semaphore value s
Dialogue: 0,0:01:14.00,0:01:17.66,Chinese,,0,0,0,,首先它增加信号量值s
Dialogue: 0,0:01:18.42,0:01:22.94,English,,0,0,0,,And then it looks in the queue of four to see if there's any processes that are blocked
Dialogue: 0,0:01:18.42,0:01:22.94,Chinese,,0,0,0,,然后它查看四个队列以查看是否有任何进程被阻止
Dialogue: 0,0:01:23.10,0:01:25.96,English,,0,0,0,,Waiting for that some afford to be nonzero
Dialogue: 0,0:01:23.10,0:01:25.96,Chinese,,0,0,0,,等待有些人能够非零
Dialogue: 0,0:01:27.66,0:01:33.52,English,,0,0,0,,If there are then it selects one of those using some unspecified criteria
Dialogue: 0,0:01:27.66,0:01:33.52,Chinese,,0,0,0,,如果有，那么它使用一些未指定的标准选择其中一个
Dialogue: 0,0:01:34.08,0:01:36.14,English,,0,0,0,,And then it restarts that
Dialogue: 0,0:01:34.08,0:01:36.14,Chinese,,0,0,0,,然后它重新开始
Dialogue: 0,0:01:38.12,0:01:43.96,English,,0,0,0,,It restarts that thread that's or that P operation that's waiting on the semaphore
Dialogue: 0,0:01:38.12,0:01:43.96,Chinese,,0,0,0,,它重新启动正在等待信号量的那个或那个P操作的线程
Dialogue: 0,0:01:47.72,0:01:51.38,English,,0,0,0,,Okay and then this the semantics of the P and V
Dialogue: 0,0:01:47.72,0:01:51.38,Chinese,,0,0,0,,好的，然后是P和V的语义
Dialogue: 0,0:01:51.94,0:01:55.70,English,,0,0,0,,Ensure that semaphore values are always greater than or equal to zero
Dialogue: 0,0:01:51.94,0:01:55.70,Chinese,,0,0,0,,确保信号量值始终大于或等于零
Dialogue: 0,0:01:57.62,0:02:05.10,English,,0,0,0,,Now the first thing we saw how to protect shared variables by using a semaphore called the mutex
Dialogue: 0,0:01:57.62,0:02:05.10,Chinese,,0,0,0,,现在我们首先看到如何通过使用称为互斥锁的信号量来保护共享变量
Dialogue: 0,0:02:05.72,0:02:11.74,English,,0,0,0,,That guarantees mutually exclusive access to the critical sections that are updating that
Dialogue: 0,0:02:05.72,0:02:11.74,Chinese,,0,0,0,,这保证了对更新它的关键部分的互斥访问
Dialogue: 0,0:02:12.48,0:02:14.62,English,,0,0,0,,Those variables are structures
Dialogue: 0,0:02:12.48,0:02:14.62,Chinese,,0,0,0,,那些变量是结构
Dialogue: 0,0:02:15.64,0:02:18.84,English,,0,0,0,,And and the way that we do this is very simple
Dialogue: 0,0:02:15.64,0:02:18.84,Chinese,,0,0,0,,而且我们这样做的方式非常简单
Dialogue: 0,0:02:18.84,0:02:25.58,English,,0,0,0,,We initialize the mutex to one and then surround the critical section with a P and V
Dialogue: 0,0:02:18.84,0:02:25.58,Chinese,,0,0,0,,我们将互斥锁初始化为1，然后用P和V围绕临界区
Dialogue: 0,0:02:27.74,0:02:30.06,English,,0,0,0,,Now there's other ways that we can
Dialogue: 0,0:02:27.74,0:02:30.06,Chinese,,0,0,0,,现在还有其他方法可以做到
Dialogue: 0,0:02:30.06,0:02:34.64,English,,0,0,0,,So here's an example where we're using semaphore is to provide mutual exclusion
Dialogue: 0,0:02:30.06,0:02:34.64,Chinese,,0,0,0,,所以这里是一个我们使用信号量的例子是提供互斥
Dialogue: 0,0:02:35.76,0:02:43.32,English,,0,0,0,,But we can also use seminar semaphores to coordinate access to shared data structures in different ways
Dialogue: 0,0:02:35.76,0:02:43.32,Chinese,,0,0,0,,但我们也可以使用研讨会信号量以不同方式协调对共享数据结构的访问
Dialogue: 0,0:02:44.16,0:02:49.82,English,,0,0,0,,And so the idea here before we were using the semaphore just to protect the access to a shared variable
Dialogue: 0,0:02:44.16,0:02:49.82,Chinese,,0,0,0,,所以我们在使用信号量之前的想法只是为了保护对共享变量的访问
Dialogue: 0,0:02:50.36,0:02:58.24,English,,0,0,0,,But we can also coordinate access in different ways by keep and this in this in these in these kind of scenarios
Dialogue: 0,0:02:50.36,0:02:58.24,Chinese,,0,0,0,,但是我们也可以通过在这些场景中保持并以此方式协调访问
Dialogue: 0,0:02:58.28,0:03:04.14,English,,0,0,0,,We're using the semaphore to keep track of state to count things to keep track of state
Dialogue: 0,0:02:58.28,0:03:04.14,Chinese,,0,0,0,,我们正在使用信号量来跟踪状态以计算事物以跟踪状态
Dialogue: 0,0:03:04.58,0:03:10.16,English,,0,0,0,,And to notify other other threads of changes in state okay so it's a very different usage model
Dialogue: 0,0:03:04.58,0:03:10.16,Chinese,,0,0,0,,并通知其他状态变化的其他线程好，所以这是一个非常不同的使用模型
Dialogue: 0,0:03:11.02,0:03:17.86,English,,0,0,0,,And two classic examples that we're going to look at are the producer consumer problem and a readers writers problem
Dialogue: 0,0:03:11.02,0:03:17.86,Chinese,,0,0,0,,我们要看的两个经典例子是制片人消费者问题和读者作家问题
Dialogue: 0,0:03:18.82,0:03:20.44,English,,0,0,0,,So let's look at producer consumer first
Dialogue: 0,0:03:18.82,0:03:20.44,Chinese,,0,0,0,,那么让我们首先看看生产者消费者
Dialogue: 0,0:03:21.62,0:03:24.90,English,,0,0,0,,So the idea in the producer consumer problem is that
Dialogue: 0,0:03:21.62,0:03:24.90,Chinese,,0,0,0,,因此，生产者消费者问题的想法是
Dialogue: 0,0:03:25.42,0:03:28.94,English,,0,0,0,,You have a resource in the form of a buffer
Dialogue: 0,0:03:25.42,0:03:28.94,Chinese,,0,0,0,,你有一个缓冲区形式的资源
Dialogue: 0,0:03:29.66,0:03:32.44,English,,0,0,0,,The buffer has a bounded size
Dialogue: 0,0:03:29.66,0:03:32.44,Chinese,,0,0,0,,缓冲区的大小有限
Dialogue: 0,0:03:32.50,0:03:36.60,English,,0,0,0,,So it consists of n slots and each slot can hold an item
Dialogue: 0,0:03:32.50,0:03:36.60,Chinese,,0,0,0,,所以它由n个插槽组成，每个插槽可以容纳一个项目
Dialogue: 0,0:03:39.08,0:03:40.80,English,,0,0,0,,Okay the there's a producer thread
Dialogue: 0,0:03:39.08,0:03:40.80,Chinese,,0,0,0,,好吧，那里有一个生产者线程
Dialogue: 0,0:03:41.44,0:03:42.70,English,,0,0,0,,Which produces items
Dialogue: 0,0:03:41.44,0:03:42.70,Chinese,,0,0,0,,哪个生产物品
Dialogue: 0,0:03:44.52,0:03:46.48,English,,0,0,0,,And then inserts them into the buffer
Dialogue: 0,0:03:44.52,0:03:46.48,Chinese,,0,0,0,,然后将它们插入缓冲区
Dialogue: 0,0:03:47.50,0:03:49.02,English,,0,0,0,,And there's a consumer thread
Dialogue: 0,0:03:47.50,0:03:49.02,Chinese,,0,0,0,,还有一个消费者主题
Dialogue: 0,0:03:49.56,0:03:52.82,English,,0,0,0,,That retrieves removes items from the buffer
Dialogue: 0,0:03:49.56,0:03:52.82,Chinese,,0,0,0,,检索从缓冲区中删除项目
Dialogue: 0,0:03:52.90,0:03:57.74,English,,0,0,0,,And then consumes them by acting on them in some way processing on them in some way
Dialogue: 0,0:03:52.90,0:03:57.74,Chinese,,0,0,0,,然后通过以某种方式对它们进行处理以某种方式处理它们来消耗它们
Dialogue: 0,0:03:59.02,0:04:04.12,English,,0,0,0,,So the synchronization variable the synchronization pattern is that
Dialogue: 0,0:03:59.02,0:04:04.12,Chinese,,0,0,0,,所以同步模式就是同步模式
Dialogue: 0,0:04:04.84,0:04:07.02,English,,0,0,0,,The producer waits for an empty slot right
Dialogue: 0,0:04:04.84,0:04:07.02,Chinese,,0,0,0,,制作人等待一个空位
Dialogue: 0,0:04:07.02,0:04:12.76,English,,0,0,0,,So if there's,if the buffer is full the producer can't insert an item into the buffer
Dialogue: 0,0:04:07.02,0:04:12.76,Chinese,,0,0,0,,因此，如果存在，如果缓冲区已满，则生产者无法将项插入缓冲区
Dialogue: 0,0:04:13.52,0:04:15.08,English,,0,0,0,,So it waits for an empty slot
Dialogue: 0,0:04:13.52,0:04:15.08,Chinese,,0,0,0,,所以它等待一个空槽
Dialogue: 0,0:04:16.10,0:04:20.18,English,,0,0,0,,And then when it finds an empty slot when an empty slot becomes available
Dialogue: 0,0:04:16.10,0:04:20.18,Chinese,,0,0,0,,然后当空槽变得可用时找到空槽
Dialogue: 0,0:04:20.48,0:04:22.56,English,,0,0,0,,It inserts the item into the buffer
Dialogue: 0,0:04:20.48,0:04:22.56,Chinese,,0,0,0,,它将项目插入缓冲区
Dialogue: 0,0:04:23.24,0:04:29.66,English,,0,0,0,,And then it notifies the consumer that there's now a new item in the buffer
Dialogue: 0,0:04:23.24,0:04:29.66,Chinese,,0,0,0,,然后它通知消费者现在缓冲区中有一个新项目
Dialogue: 0,0:04:31.20,0:04:37.42,English,,0,0,0,,The consumer of course that has to wait for an item to show up in the buffer right
Dialogue: 0,0:04:31.20,0:04:37.42,Chinese,,0,0,0,,消费者当然必须等待项目在缓冲区中显示
Dialogue: 0,0:04:37.64,0:04:41.44,English,,0,0,0,,Otherwise I mean you can't remove an item from an empty buffer
Dialogue: 0,0:04:37.64,0:04:41.44,Chinese,,0,0,0,,否则我的意思是你不能从空缓冲区中删除一个项目
Dialogue: 0,0:04:41.80,0:04:46.36,English,,0,0,0,,So it has to wait for an item to be available in the buffer
Dialogue: 0,0:04:41.80,0:04:46.36,Chinese,,0,0,0,,所以它必须等待缓冲区中的项目可用
Dialogue: 0,0:04:46.84,0:04:51.24,English,,0,0,0,,And when an item becomes available it removes it from the buffer
Dialogue: 0,0:04:46.84,0:04:51.24,Chinese,,0,0,0,,当一个项目可用时，它将其从缓冲区中删除
Dialogue: 0,0:04:51.64,0:04:55.54,English,,0,0,0,,And then notifies the producer that there's now an available slot
Dialogue: 0,0:04:51.64,0:04:55.54,Chinese,,0,0,0,,然后通知制作人现在有一个可用的插槽
Dialogue: 0,0:04:58.80,0:05:06.18,English,,0,0,0,,Okay so this Actually this very simple pattern is actually really useful and shows up in a lot of applications
Dialogue: 0,0:04:58.80,0:05:06.18,Chinese,,0,0,0,,好的，所以这实际上这个非常简单的模式实际上非常有用，并且出现在很多应用程序中
Dialogue: 0,0:05:06.70,0:05:08.64,English,,0,0,0,,So for example a multimedia application
Dialogue: 0,0:05:06.70,0:05:08.64,Chinese,,0,0,0,,例如，多媒体应用程序
Dialogue: 0,0:05:09.14,0:05:17.82,English,,0,0,0,,In a multimedia application the producer might be producing say MPEG frames in a video
Dialogue: 0,0:05:09.14,0:05:17.82,Chinese,,0,0,0,,在多媒体应用中，制作人可能会在视频中产生MPEG帧
Dialogue: 0,0:05:18.22,0:05:24.28,English,,0,0,0,,And a consumer would be consuming those MPEG frames and then painting the screen appropriately
Dialogue: 0,0:05:18.22,0:05:24.28,Chinese,,0,0,0,,并且消费者将消费那些MPEG帧然后适当地绘制屏幕
Dialogue: 0,0:05:24.90,0:05:29.08,English,,0,0,0,,Another important application is in graphical user interfaces
Dialogue: 0,0:05:24.90,0:05:29.08,Chinese,,0,0,0,,另一个重要的应用是图形用户界面
Dialogue: 0,0:05:29.92,0:05:34.52,English,,0,0,0,,So graphical user interfaces are typically implemented using this producer-consumer model
Dialogue: 0,0:05:29.92,0:05:34.52,Chinese,,0,0,0,,因此，图形用户界面通常使用此生产者 - 消费者模型来实现
Dialogue: 0,0:05:35.26,0:05:44.86,English,,0,0,0,,Where the mouse clicks,motions and the in the of the mouse,keyboard clicks
Dialogue: 0,0:05:35.26,0:05:44.86,Chinese,,0,0,0,,鼠标点击，动作和鼠标中的键盘点击
Dialogue: 0,0:05:45.30,0:05:46.88,English,,0,0,0,,Those are all recorded as events
Dialogue: 0,0:05:45.30,0:05:46.88,Chinese,,0,0,0,,这些都记录为事件
Dialogue: 0,0:05:47.26,0:05:52.74,English,,0,0,0,,They're detected by the system recorded as events and placed into a some kind of a queue
Dialogue: 0,0:05:47.26,0:05:52.74,Chinese,,0,0,0,,系统将它们记录为事件并将其置于某种队列中
Dialogue: 0,0:05:53.70,0:05:58.94,English,,0,0,0,,And then...there is other parts of the system retrieve items from the queue and react to them
Dialogue: 0,0:05:53.70,0:05:58.94,Chinese,,0,0,0,,然后......系统的其他部分从队列中检索项目并对它们作出反应
Dialogue: 0,0:05:58.96,0:06:07.26,English,,0,0,0,,So for example the graphic system will retrieve events like mouse events and mouse movements mouse clicks
Dialogue: 0,0:05:58.96,0:06:07.26,Chinese,,0,0,0,,因此，例如图形系统将检索诸如鼠标事件和鼠标移动鼠标点击之类的事件
Dialogue: 0,0:06:07.72,0:06:09.70,English,,0,0,0,,And it will paint the screen accordingly right
Dialogue: 0,0:06:07.72,0:06:09.70,Chinese,,0,0,0,,它将相应地绘制屏幕
Dialogue: 0,0:06:09.72,0:06:17.22,English,,0,0,0,,so that it will reflect it will repaint the screen ,so that to show you that the cursor is moving
Dialogue: 0,0:06:09.72,0:06:17.22,Chinese,,0,0,0,,所以它会反映它会重新绘制屏幕，​​以便向你显示光标正在移动
Dialogue: 0,0:06:17.80,0:06:21.20,English,,0,0,0,,Right or if you change the focus it will repaint it
Dialogue: 0,0:06:17.80,0:06:21.20,Chinese,,0,0,0,,正确或如果你更改焦点，它将重新绘制它
Dialogue: 0,0:06:21.90,0:06:25.68,English,,0,0,0,,So it's a very common model
Dialogue: 0,0:06:21.90,0:06:25.68,Chinese,,0,0,0,,所以这是一个非常普遍的模型
Dialogue: 0,0:06:25.68,0:06:31.70,English,,0,0,0,,And as we'll see later multi-threaded we can build multi-threaded concurrent servers using this model
Dialogue: 0,0:06:25.68,0:06:31.70,Chinese,,0,0,0,,正如我们稍后将看到的多线程，我们可以使用此模型构建多线程并发服务器
Dialogue: 0,0:06:34.48,0:06:38.56,English,,0,0,0,,So let's see how we would implement producer/consumer on an n-element buffer
Dialogue: 0,0:06:34.48,0:06:38.56,Chinese,,0,0,0,,那么让我们看看我们如何在n元素缓冲区上实现生产者/消费者
Dialogue: 0,0:06:39.52,0:06:47.16,English,,0,0,0,,So this the implementation requires a mutex to guarantee mutually exclusive access to the resource of course
Dialogue: 0,0:06:39.52,0:06:47.16,Chinese,,0,0,0,,因此，实现需要一个互斥锁来保证对资源的互斥访问
Dialogue: 0,0:06:47.84,0:06:52.06,English,,0,0,0,,And then it requires then two other semaphores counting semaphores
Dialogue: 0,0:06:47.84,0:06:52.06,Chinese,,0,0,0,,然后它需要另外两个信号量来计算信号量
Dialogue: 0,0:06:53.74,0:06:58.48,English,,0,0,0,,Slots is a semaphore that counts the available slots in the buffer
Dialogue: 0,0:06:53.74,0:06:58.48,Chinese,,0,0,0,,Slots是一个信号量，用于计算缓冲区中的可用插槽
Dialogue: 0,0:06:59.10,0:07:02.61,English,,0,0,0,,And items is counts the available items okay
Dialogue: 0,0:06:59.10,0:07:02.61,Chinese,,0,0,0,,并且物品可以计算可用物品
Dialogue: 0,0:07:03.38,0:07:07.90,English,,0,0,0,,And we've can implement it with this package called sbuf
Dialogue: 0,0:07:03.38,0:07:07.90,Chinese,,0,0,0,,我们可以使用名为sbuf的这个包实现它
Dialogue: 0,0:07:10.98,0:07:17.92,English,,0,0,0,,So sbuf the sbuf package defines a type called sbuf_t
Dialogue: 0,0:07:10.98,0:07:17.92,Chinese,,0,0,0,,所以sbuf sbuf包定义了一个名为sbuf_t的类型
Dialogue: 0,0:07:17.92,0:07:24.12,English,,0,0,0,,that packages up all of the data structures that are needed to implement the shared buffer
Dialogue: 0,0:07:17.92,0:07:24.12,Chinese,,0,0,0,,它打包了实现共享缓冲区所需的所有数据结构
Dialogue: 0,0:07:24.80,0:07:30.12,English,,0,0,0,,So there's a pointer to the buffer which we were going to implement as an array and
Dialogue: 0,0:07:24.80,0:07:30.12,Chinese,,0,0,0,,所以有一个指向缓冲区的指针，我们将把它作为一个数组来实现
Dialogue: 0,0:07:30.62,0:07:34.52,English,,0,0,0,,And we'll implement a circular buffer on this array
Dialogue: 0,0:07:30.62,0:07:34.52,Chinese,,0,0,0,,我们将在这个数组上实现一个循环缓冲区
Dialogue: 0,0:07:36.26,0:07:39.59,English,,0,0,0,,The maximum number of slots n,so the size of the buffer
Dialogue: 0,0:07:36.26,0:07:39.59,Chinese,,0,0,0,,最大插槽数n，所以缓冲区的大小
Dialogue: 0,0:07:40.14,0:07:47.50,English,,0,0,0,,And then two pointers front and rear to keep track of the front and rear of the of the buffer
Dialogue: 0,0:07:40.14,0:07:47.50,Chinese,,0,0,0,,然后前后两个指针跟踪缓冲区的前后
Dialogue: 0,0:07:47.50,0:07:50.57,English,,0,0,0,,So to keep track of the first and last items in the buffer
Dialogue: 0,0:07:47.50,0:07:50.57,Chinese,,0,0,0,,所以要跟踪缓冲区中的第一个和最后一个项目
Dialogue: 0,0:07:51.26,0:07:55.56,English,,0,0,0,,And then the three semaphores the mutex and in the two counting semaphores
Dialogue: 0,0:07:51.26,0:07:55.56,Chinese,,0,0,0,,然后是三个信号量的互斥量和两个计数信号量
Dialogue: 0,0:07:56.48,0:07:59.84,English,,0,0,0,,And then the package consists of these four public functions
Dialogue: 0,0:07:56.48,0:07:59.84,Chinese,,0,0,0,,然后包包含这四个公共功能
Dialogue: 0,0:08:00.36,0:08:11.96,English,,0,0,0,,sbuf_init which creates the is called once to create the buffer and initialize everything Allocate the space and initialize things
Dialogue: 0,0:08:00.36,0:08:11.96,Chinese,,0,0,0,,创建调用的sbuf_init一次创建缓冲区并初始化所有内容分配空间并初始化
Dialogue: 0,0:08:11.96,0:08:14.44,English,,0,0,0,,And the (sbuf_)deinit which frees up the space
Dialogue: 0,0:08:11.96,0:08:14.44,Chinese,,0,0,0,,并且（sbuf_）deinit释放了空间
Dialogue: 0,0:08:15.38,0:08:24.08,English,,0,0,0,,And then a function to insert an item into the queue and a function to remove an item from a queue and return that item
Dialogue: 0,0:08:15.38,0:08:24.08,Chinese,,0,0,0,,然后是一个将项插入队列的函数和一个从队列中删除项并返回该项的函数
Dialogue: 0,0:08:24.88,0:08:26.42,English,,0,0,0,,So in this case items are just int
Dialogue: 0,0:08:24.88,0:08:26.42,Chinese,,0,0,0,,所以在这种情况下，项目只是int
Dialogue: 0,0:08:31.30,0:08:38.70,English,,0,0,0,,So to create the...to initialize the this buffer
Dialogue: 0,0:08:31.30,0:08:38.70,Chinese,,0,0,0,,所以要创建...来初始化这个缓冲区
Dialogue: 0,0:08:39.28,0:08:44.58,English,,0,0,0,,With n slots we first allocate the space for the buffer and n ints
Dialogue: 0,0:08:39.28,0:08:44.58,Chinese,,0,0,0,,使用n个插槽，我们首先为缓冲区和n个int分配空间
Dialogue: 0,0:08:45.38,0:08:50.80,English,,0,0,0,,We set the size to be the value n that was passed in
Dialogue: 0,0:08:45.38,0:08:50.80,Chinese,,0,0,0,,我们将大小设置为传入的值n
Dialogue: 0,0:08:52.72,0:08:58.02,English,,0,0,0,,We indicate the empty buffer by setting front-and-rear to be zero
Dialogue: 0,0:08:52.72,0:08:58.02,Chinese,,0,0,0,,我们通过将前后设置为零来指示空缓冲区
Dialogue: 0,0:08:58.78,0:09:03.20,English,,0,0,0,,Okay and so whenever front and rear are zero that's we have an empty buffer
Dialogue: 0,0:08:58.78,0:09:03.20,Chinese,,0,0,0,,好的，所以无论前后都是零，我们都有一个空的缓冲区
Dialogue: 0,0:09:04.34,0:09:06.70,English,,0,0,0,,And then we initialize the three semaphore
Dialogue: 0,0:09:04.34,0:09:06.70,Chinese,,0,0,0,,然后我们初始化三个信号量
Dialogue: 0,0:09:06.70,0:09:11.30,English,,0,0,0,,So the mutex like all mutex is initialized to 1
Dialogue: 0,0:09:06.70,0:09:11.30,Chinese,,0,0,0,,因此，所有互斥锁的互斥锁初始化为1
Dialogue: 0,0:09:13.32,0:09:19.48,English,,0,0,0,,The slot semaphore which keeps track of the number of available slots is initialized to n
Dialogue: 0,0:09:13.32,0:09:19.48,Chinese,,0,0,0,,跟踪可用时隙数的时隙信号量被初始化为n
Dialogue: 0,0:09:20.38,0:09:23.20,English,,0,0,0,,And the item semaphore is initialized to zero
Dialogue: 0,0:09:20.38,0:09:23.20,Chinese,,0,0,0,,项目信号量初始化为零
Dialogue: 0,0:09:25.18,0:09:31.20,English,,0,0,0,,Okay and deinit is really simple it just frees up the heap space that we allocated
Dialogue: 0,0:09:25.18,0:09:31.20,Chinese,,0,0,0,,好吧，deinit非常简单，只需释放我们分配的堆空间
Dialogue: 0,0:09:33.10,0:09:36.74,English,,0,0,0,,Okay so now let's look at how we insert an item into the buffer
Dialogue: 0,0:09:33.10,0:09:36.74,Chinese,,0,0,0,,好的，现在让我们看看我们如何将项目插入缓冲区
Dialogue: 0,0:09:36.94,0:09:43.18,English,,0,0,0,,So we call...we want to insert this integer item into this buffer pointed at by sp
Dialogue: 0,0:09:36.94,0:09:43.18,Chinese,,0,0,0,,所以我们调用...我们想要将这个整数项插入sp指向的缓冲区
Dialogue: 0,0:09:44.74,0:09:49.70,English,,0,0,0,,So first the thread waits for an available slot
Dialogue: 0,0:09:44.74,0:09:49.70,Chinese,,0,0,0,,所以首先线程等待可用的插槽
Dialogue: 0,0:09:50.12,0:09:54.52,English,,0,0,0,,Okay by doing a p on the semaphore before alright so p will block
Dialogue: 0,0:09:50.12,0:09:54.52,Chinese,,0,0,0,,好吧，之前在信号量上做一个p，好吧所以p会阻塞
Dialogue: 0,0:09:55.50,0:09:59.44,English,,0,0,0,,Until the slots is greater than or equal to one
Dialogue: 0,0:09:55.50,0:09:59.44,Chinese,,0,0,0,,直到槽大于或等于1
Dialogue: 0,0:10:01.14,0:10:02.82,English,,0,0,0,,Okay once there's an available slot
Dialogue: 0,0:10:01.14,0:10:02.82,Chinese,,0,0,0,,好的，一旦有可用的插槽
Dialogue: 0,0:10:03.76,0:10:13.76,English,,0,0,0,,Then it if then it's going to update the rear of the buffer
Dialogue: 0,0:10:03.76,0:10:13.76,Chinese,,0,0,0,,然后，如果它然后它将更新缓冲区的后部
Dialogue: 0,0:10:14.26,0:10:16.74,English,,0,0,0,,Okay so we're going to put this item on to the rear of the buffer
Dialogue: 0,0:10:14.26,0:10:16.74,Chinese,,0,0,0,,好的，我们将把这个项目放在缓冲区的后面
Dialogue: 0,0:10:17.08,0:10:21.56,English,,0,0,0,,And so it needs to protect that access to that shared buffer with the mutex
Dialogue: 0,0:10:17.08,0:10:21.56,Chinese,,0,0,0,,因此，它需要使用互斥锁保护对该共享缓冲区的访问
Dialogue: 0,0:10:22.76,0:10:26.00,English,,0,0,0,,Then it does the by doing a p on the mutex
Dialogue: 0,0:10:22.76,0:10:26.00,Chinese,,0,0,0,,然后它通过在互斥锁上执行p来完成
Dialogue: 0,0:10:26.78,0:10:29.92,English,,0,0,0,,Updating updating our rear pointer
Dialogue: 0,0:10:26.78,0:10:29.92,Chinese,,0,0,0,,更新我们的后指针更新
Dialogue: 0,0:10:30.20,0:10:37.18,English,,0,0,0,,Okay so we pre increment it so we increment the rear pointer and then take the mod of that n
Dialogue: 0,0:10:30.20,0:10:37.18,Chinese,,0,0,0,,好吧所以我们预先增加它，所以我们增加后指针，然后取n的mod
Dialogue: 0,0:10:37.80,0:10:43.86,English,,0,0,0,,To compute the index that we're going to insert the item
Dialogue: 0,0:10:37.80,0:10:43.86,Chinese,,0,0,0,,计算我们要插入项目的索引
Dialogue: 0,0:10:44.80,0:10:47.74,English,,0,0,0,,Okay then we do a V on the mutex
Dialogue: 0,0:10:44.80,0:10:47.74,Chinese,,0,0,0,,那么我们在互斥锁上做一个V.
Dialogue: 0,0:10:48.20,0:10:54.54,English,,0,0,0,,Okay so that other threads can update that shared data structure
Dialogue: 0,0:10:48.20,0:10:54.54,Chinese,,0,0,0,,好的，以便其他线程可以更新该共享数据结构
Dialogue: 0,0:10:55.52,0:11:00.56,English,,0,0,0,,And then we do a V on the number of items to notify any consumers
Dialogue: 0,0:10:55.52,0:11:00.56,Chinese,,0,0,0,,然后我们对项目数量做一个V来通知任何消费者
Dialogue: 0,0:11:00.56,0:11:02.86,English,,0,0,0,,That there's now an item in the buffer
Dialogue: 0,0:11:00.56,0:11:02.86,Chinese,,0,0,0,,现在缓冲区中有一个项目
Dialogue: 0,0:11:04.68,0:11:12.48,English,,0,0,0,,So this V is kind of interesting you think it was kind of like a signal right so you're sort of signaling consumers that now
Dialogue: 0,0:11:04.68,0:11:12.48,Chinese,,0,0,0,,所以这个V很有意思，你认为它有点像信号，所以你现在就像消费者那样
Dialogue: 0,0:11:13.14,0:11:14.86,English,,0,0,0,,Some event has occurred in the system
Dialogue: 0,0:11:13.14,0:11:14.86,Chinese,,0,0,0,,系统中发生了某些事件
Dialogue: 0,0:11:18.08,0:11:20.92,English,,0,0,0,,Now to remove an item it's symmetric
Dialogue: 0,0:11:18.08,0:11:20.92,Chinese,,0,0,0,,现在要删除一个对称的项目
Dialogue: 0,0:11:21.04,0:11:26.48,English,,0,0,0,,But instead of operating on the slots that before it operates on the items semaphore
Dialogue: 0,0:11:21.04,0:11:26.48,Chinese,,0,0,0,,但不是在它操作项目信号量之前操作插槽
Dialogue: 0,0:11:27.30,0:11:33.88,English,,0,0,0,,So to remove an item a consumer first does a P on the items semaphore
Dialogue: 0,0:11:27.30,0:11:33.88,Chinese,,0,0,0,,因此，要删除项目，消费者首先在项目信号量上执行P.
Dialogue: 0,0:11:33.94,0:11:38.78,English,,0,0,0,,So this now is waiting for an available item it's waiting for the semaphore to be greater than equal to one
Dialogue: 0,0:11:33.94,0:11:38.78,Chinese,,0,0,0,,所以这现在正在等待一个可用的项目，它等待信号量大于等于1
Dialogue: 0,0:11:39.96,0:11:43.80,English,,0,0,0,,When that happens then the P returns
Dialogue: 0,0:11:39.96,0:11:43.80,Chinese,,0,0,0,,当发生这种情况时，P返回
Dialogue: 0,0:11:44.44,0:11:49.00,English,,0,0,0,,And then we do the update protected by a mutex
Dialogue: 0,0:11:44.44,0:11:49.00,Chinese,,0,0,0,,然后我们进行受互斥锁保护的更新
Dialogue: 0,0:11:49.62,0:11:54.40,English,,0,0,0,,By pre-incrementing front taking the mod n
Dialogue: 0,0:11:49.62,0:11:54.40,Chinese,,0,0,0,,通过预先递增前面的mod n
Dialogue: 0,0:11:54.86,0:12:03.70,English,,0,0,0,,And then reading that value and returning it and placing it into this local local variable item
Dialogue: 0,0:11:54.86,0:12:03.70,Chinese,,0,0,0,,然后读取该值并将其返回并将其放入此本地局部变量项中
Dialogue: 0,0:12:04.50,0:12:06.22,English,,0,0,0,,Then we release the mutex
Dialogue: 0,0:12:04.50,0:12:06.22,Chinese,,0,0,0,,然后我们释放互斥锁
Dialogue: 0,0:12:07.82,0:12:10.04,English,,0,0,0,,And then we do a V on the number of slots which
Dialogue: 0,0:12:07.82,0:12:10.04,Chinese,,0,0,0,,然后我们对插槽的数量做一个V
Dialogue: 0,0:12:10.48,0:12:15.50,English,,0,0,0,,Which is an announcement to any producers that there's now a new available slot
Dialogue: 0,0:12:10.48,0:12:15.50,Chinese,,0,0,0,,这是任何生产商的公告，现在有一个新的可用插槽
Dialogue: 0,0:12:19.54,0:12:20.70,English,,0,0,0,,So any questions about that
Dialogue: 0,0:12:19.54,0:12:20.70,Chinese,,0,0,0,,所以有关于此的任何问题
Dialogue: 0,0:12:24.72,0:12:26.32,English,,0,0,0,,So it's a little more subtle
Dialogue: 0,0:12:24.72,0:12:26.32,Chinese,,0,0,0,,所以它有点微妙
Dialogue: 0,0:12:26.56,0:12:31.28,English,,0,0,0,,This looks really simple but like all concurrency problems it's actually very subtle
Dialogue: 0,0:12:26.56,0:12:31.28,Chinese,,0,0,0,,这看起来非常简单但是像所有并发问题一样，它实际上非常微妙
Dialogue: 0,0:12:33.26,0:12:39.64,English,,0,0,0,,So you can have potential,you can have many producers and many many consumers all operating on the same
Dialogue: 0,0:12:33.26,0:12:39.64,Chinese,,0,0,0,,因此，你可以拥有潜力，你可以让许多生产者和许多消费者都在同一个地方运营
Dialogue: 0,0:12:40.36,0:12:42.26,English,,0,0,0,,You know the same shared buffer
Dialogue: 0,0:12:40.36,0:12:42.26,Chinese,,0,0,0,,你知道相同的共享缓冲区
Dialogue: 0,0:12:44.32,0:12:47.70,English,,0,0,0,,So this...so what would happen
Dialogue: 0,0:12:44.32,0:12:47.70,Chinese,,0,0,0,,所以这......所以会发生什么
Dialogue: 0,0:12:48.84,0:12:52.02,English,,0,0,0,,If we had two consumers did
Dialogue: 0,0:12:48.84,0:12:52.02,Chinese,,0,0,0,,如果我们有两个消费者呢
Dialogue: 0,0:12:52.58,0:12:56.84,English,,0,0,0,,A P on this item semaphore at the exact same time say we're running on two cores
Dialogue: 0,0:12:52.58,0:12:56.84,Chinese,,0,0,0,,这个项目信号量的P在同一时间说我们在两个核心上运行
Dialogue: 0,0:12:57.68,0:13:01.68,English,,0,0,0,,And and we have two threads and they each execute that P
Dialogue: 0,0:12:57.68,0:13:01.68,Chinese,,0,0,0,,而且我们有两个线程，每个线程执行P
Dialogue: 0,0:13:03.76,0:13:07.84,English,,0,0,0,,At the same time on that that same item semaphore
Dialogue: 0,0:13:03.76,0:13:07.84,Chinese,,0,0,0,,同时在那个相同的项目信号量上
Dialogue: 0,0:13:08.72,0:13:14.30,English,,0,0,0,,Okay so even though they access it at the same time the kernel will make sure that one of them will execute first
Dialogue: 0,0:13:08.72,0:13:14.30,Chinese,,0,0,0,,好的，即使他们同时访问它，内核也会确保其中一个首先执行
Dialogue: 0,0:13:14.58,0:13:18.40,English,,0,0,0,,Okay so the kernel will serialize those P operations
Dialogue: 0,0:13:14.58,0:13:18.40,Chinese,,0,0,0,,好的，所以内核将序列化那些P操作
Dialogue: 0,0:13:20.40,0:13:25.00,English,,0,0,0,,And it there's no telling which one gets it first but whoever runs
Dialogue: 0,0:13:20.40,0:13:25.00,Chinese,,0,0,0,,并且没有人知道哪一个首先获得它，但无论谁运行
Dialogue: 0,0:13:25.40,0:13:31.48,English,,0,0,0,,There P first will decrement this item semaphore
Dialogue: 0,0:13:25.40,0:13:31.48,Chinese,,0,0,0,,有P先将减少此项信号量
Dialogue: 0,0:13:33.44,0:13:35.92,English,,0,0,0,,And then when the next when the next thread executes
Dialogue: 0,0:13:33.44,0:13:35.92,Chinese,,0,0,0,,然后在下一个线程执行时的下一个
Dialogue: 0,0:13:36.26,0:13:40.78,English,,0,0,0,,Its P items will either be zero or nonzero
Dialogue: 0,0:13:36.26,0:13:40.78,Chinese,,0,0,0,,它的P项将为零或非零
Dialogue: 0,0:13:41.34,0:13:45.28,English,,0,0,0,,Okay as a result so somebody wins there's kind of a ton of like a controlled race
Dialogue: 0,0:13:41.34,0:13:45.28,Chinese,,0,0,0,,好的结果是有人赢了，有点像控制种族
Dialogue: 0,0:13:45.72,0:13:50.44,English,,0,0,0,,And somebody wins the race always wins the race because the kernel is serializing
Dialogue: 0,0:13:45.72,0:13:50.44,Chinese,,0,0,0,,有人赢得比赛总是赢得比赛，因为内核正在序列化
Dialogue: 0,0:13:50.84,0:13:54.94,English,,0,0,0,,These P operations and it's executing them atomically okay
Dialogue: 0,0:13:50.84,0:13:54.94,Chinese,,0,0,0,,这些P操作和它原子上执行它们没问题
Dialogue: 0,0:13:58.46,0:14:06.68,English,,0,0,0,,Okay now the there's a generalization of the mutual exclusion problem called the reader writer problem
Dialogue: 0,0:13:58.46,0:14:06.68,Chinese,,0,0,0,,好吧现在有一个被称为读者写作者问题的互斥问题的概括
Dialogue: 0,0:14:07.30,0:14:10.22,English,,0,0,0,,So with the mutual exclusion problem
Dialogue: 0,0:14:07.30,0:14:10.22,Chinese,,0,0,0,,因此存在互斥问题
Dialogue: 0,0:14:10.86,0:14:19.50,English,,0,0,0,,We were guaranteeing each thread mutually exclusive access to its critical section
Dialogue: 0,0:14:10.86,0:14:19.50,Chinese,,0,0,0,,我们保证每个线程互相访问其关键部分
Dialogue: 0,0:14:19.50,0:14:23.82,English,,0,0,0,,That's updating a particular resource or accessing a particular resource
Dialogue: 0,0:14:19.50,0:14:23.82,Chinese,,0,0,0,,这是更新特定资源或访问特定资源
Dialogue: 0,0:14:23.82,0:14:27.64,English,,0,0,0,,And we did this the exact same way whether that access was a read or write
Dialogue: 0,0:14:23.82,0:14:27.64,Chinese,,0,0,0,,我们这样做的方式完全相同，无论访问是读还是写
Dialogue: 0,0:14:29.34,0:14:31.94,English,,0,0,0,,Okay but that's overly conservative in this case
Dialogue: 0,0:14:29.34,0:14:31.94,Chinese,,0,0,0,,好吧，但在这种情况下，这过于保守
Dialogue: 0,0:14:33.72,0:14:39.48,English,,0,0,0,,Because we could if all we were doing if we had multiple threads that were just reading the resource
Dialogue: 0,0:14:33.72,0:14:39.48,Chinese,,0,0,0,,因为如果我们有多个只读取资源的线程，我们就可以做到
Dialogue: 0,0:14:40.30,0:14:44.42,English,,0,0,0,,There would be no reason to do ps and vs on that resource or if we're not changing
Dialogue: 0,0:14:40.30,0:14:44.42,Chinese,,0,0,0,,没有理由对该资源进行ps和vs，或者我们没有改变
Dialogue: 0,0:14:45.50,0:14:50.24,English,,0,0,0,,If we're not changing the resource for just reading it and there's nobody else writing it
Dialogue: 0,0:14:45.50,0:14:50.24,Chinese,,0,0,0,,如果我们没有改变资源只是为了阅读它而没有其他人写它
Dialogue: 0,0:14:51.12,0:14:53.76,English,,0,0,0,,Then there's no need to protect right so it
Dialogue: 0,0:14:51.12,0:14:53.76,Chinese,,0,0,0,,然后就没有必要保护它了
Dialogue: 0,0:14:54.42,0:15:03.04,English,,0,0,0,,For readers we can have as many readers as we want all at the same time reading the resource the variable or set of variables
Dialogue: 0,0:14:54.42,0:15:03.04,Chinese,,0,0,0,,对于读者来说，我们可以拥有尽可能多的读者，同时读取资源变量或变量集
Dialogue: 0,0:15:04.74,0:15:07.20,English,,0,0,0,,And there's no need for any kind of synchronization at all
Dialogue: 0,0:15:04.74,0:15:07.20,Chinese,,0,0,0,,并且根本不需要任何类型的同步
Dialogue: 0,0:15:08.08,0:15:14.40,English,,0,0,0,,Okay so the producer consumer is sort of a generalization of that mutual exclusion problem
Dialogue: 0,0:15:08.08,0:15:14.40,Chinese,,0,0,0,,好的，生产者消费者就是对这种互斥问题的概括
Dialogue: 0,0:15:14.70,0:15:17.84,English,,0,0,0,,Which enforces mutual exclusion only when it's absolutely necessary
Dialogue: 0,0:15:14.70,0:15:17.84,Chinese,,0,0,0,,只有在绝对必要的情况下，才会强制执行互斥
Dialogue: 0,0:15:18.46,0:15:23.66,English,,0,0,0,,Okay so there can be is there can be as many readers reading the resource
Dialogue: 0,0:15:18.46,0:15:23.66,Chinese,,0,0,0,,好吧，有可能有很多读者阅读资源
Dialogue: 0,0:15:23.68,0:15:28.74,English,,0,0,0,,But when a writer wants to write then it has to have mutual exclusive access to the resource
Dialogue: 0,0:15:23.68,0:15:28.74,Chinese,,0,0,0,,但是当作家想要写作时，它必须具有对资源的互斥访问权
Dialogue: 0,0:15:34.62,0:15:38.18,English,,0,0,0,,Okay so this is a kind of thing...this is also a very useful pattern
Dialogue: 0,0:15:34.62,0:15:38.18,Chinese,,0,0,0,,好的，所以这是一种事情......这也是一种非常有用的模式
Dialogue: 0,0:15:38.78,0:15:44.54,English,,0,0,0,,You have in an online airline reservation system you have multiple clients accessing a shared database
Dialogue: 0,0:15:38.78,0:15:44.54,Chinese,,0,0,0,,你在在线航空预订系统中有多个客户端访问共享数据库
Dialogue: 0,0:15:45.60,0:15:49.44,English,,0,0,0,,Okay so as long as those clients are reading the database you can have
Dialogue: 0,0:15:45.60,0:15:49.44,Chinese,,0,0,0,,好的，只要这些客户正在阅读你可以拥有的数据库
Dialogue: 0,0:15:50.06,0:15:54.90,English,,0,0,0,,They can all be reading at the same time but as soon as somebody wants to make a reservation and update the database
Dialogue: 0,0:15:50.06,0:15:54.90,Chinese,,0,0,0,,他们都可以在同一时间阅读，但只要有人想要预订并更新数据库
Dialogue: 0,0:15:55.52,0:15:59.16,English,,0,0,0,,Then that update has to happen a mutually exclusive way
Dialogue: 0,0:15:55.52,0:15:59.16,Chinese,,0,0,0,,然后，该更新必须以互斥的方式发生
Dialogue: 0,0:16:00.90,0:16:05.40,English,,0,0,0,,You know if you had also if you had like any kind of shared data structure like a cache
Dialogue: 0,0:16:00.90,0:16:05.40,Chinese,,0,0,0,,如果你喜欢任何类型的共享数据结构（如缓存），你就知道是否还有
Dialogue: 0,0:16:06.54,0:16:11.14,English,,0,0,0,,In a concurrent proxy like that you're going to be writing soon
Dialogue: 0,0:16:06.54,0:16:11.14,Chinese,,0,0,0,,在像你那样的并发代理中，你很快就要写了
Dialogue: 0,0:16:11.66,0:16:13.72,English,,0,0,0,,Or if you haven't already started
Dialogue: 0,0:16:11.66,0:16:13.72,Chinese,,0,0,0,,或者如果你还没有开始
Dialogue: 0,0:16:15.04,0:16:17.52,English,,0,0,0,,That cache is being shared by multiple threads
Dialogue: 0,0:16:15.04,0:16:17.52,Chinese,,0,0,0,,该缓存由多个线程共享
Dialogue: 0,0:16:18.24,0:16:20.84,English,,0,0,0,,And multiple threads may be reading that cache
Dialogue: 0,0:16:18.24,0:16:20.84,Chinese,,0,0,0,,并且多个线程可能正在读取该缓存
Dialogue: 0,0:16:21.38,0:16:26.08,English,,0,0,0,,But when some...when you get a new page and you want to cache it
Dialogue: 0,0:16:21.38,0:16:26.08,Chinese,,0,0,0,,但是当某些...当你得到一个新页面而你想要缓存它时
Dialogue: 0,0:16:26.86,0:16:32.14,English,,0,0,0,,Then that constitutes a right and that right needs to happen in our mutually exclusive way
Dialogue: 0,0:16:26.86,0:16:32.14,Chinese,,0,0,0,,那就构成了权利，而权利需要以我们互相排斥的方式发生
Dialogue: 0,0:16:33.72,0:16:37.12,English,,0,0,0,,Now the initial research the researchers that
Dialogue: 0,0:16:33.72,0:16:37.12,Chinese,,0,0,0,,现在研究人员最初的研究表明
Dialogue: 0,0:16:40.12,0:16:42.60,English,,0,0,0,,That pose this readers writers problems
Dialogue: 0,0:16:40.12,0:16:42.60,Chinese,,0,0,0,,这构成了读者作家的问题
Dialogue: 0,0:16:43.88,0:16:48.78,English,,0,0,0,,In define sort of several classes of reader writer problems
Dialogue: 0,0:16:43.88,0:16:48.78,Chinese,,0,0,0,,在定义几类读者写作者问题
Dialogue: 0,0:16:49.30,0:16:56.74,English,,0,0,0,,The first reader writer, readers writers problems is an implementation that favors readers right
Dialogue: 0,0:16:49.30,0:16:56.74,Chinese,,0,0,0,,第一位读者作家，读者作家的问题是一种有利于读者的实施
Dialogue: 0,0:16:57.72,0:17:01.10,English,,0,0,0,,So the idea is that no reader should be kept waiting
Dialogue: 0,0:16:57.72,0:17:01.10,Chinese,,0,0,0,,因此，我们的想法是不应该让读者等待
Dialogue: 0,0:17:02.98,0:17:13.42,English,,0,0,0,,Right unless an a writer already has a P as has sort of acquired the lock on that or the mutex on that resource
Dialogue: 0,0:17:02.98,0:17:13.42,Chinese,,0,0,0,,正确，除非作者已经拥有P，因为它已获得对该资源的锁定或该资源上的互斥锁
Dialogue: 0,0:17:14.70,0:17:16.46,English,,0,0,0,,So it in this case
Dialogue: 0,0:17:14.70,0:17:16.46,Chinese,,0,0,0,,所以在这种情况下
Dialogue: 0,0:17:17.24,0:17:21.76,English,,0,0,0,,You know say there's a writer waiting to get to acquire the mutex
Dialogue: 0,0:17:17.24,0:17:21.76,Chinese,,0,0,0,,你知道有一位作家在等着获得互斥锁
Dialogue: 0,0:17:22.06,0:17:23.70,English,,0,0,0,,And another reader comes in
Dialogue: 0,0:17:22.06,0:17:23.70,Chinese,,0,0,0,,另一位读者进来了
Dialogue: 0,0:17:24.34,0:17:27.54,English,,0,0,0,,Then in this implementation that reader would give priority over the writer
Dialogue: 0,0:17:24.34,0:17:27.54,Chinese,,0,0,0,,然后在这个实现中，读者将优先于作者
Dialogue: 0,0:17:28.30,0:17:34.02,English,,0,0,0,,And it would be able to read the to add to do its read
Dialogue: 0,0:17:28.30,0:17:34.02,Chinese,,0,0,0,,并且它将能够读取添加以进行读取
Dialogue: 0,0:17:34.38,0:17:35.66,English,,0,0,0,,And the writer would have to wait
Dialogue: 0,0:17:34.38,0:17:35.66,Chinese,,0,0,0,,作家必须等待
Dialogue: 0,0:17:36.68,0:17:43.05,English,,0,0,0,,And so of court now if multiple readers keep coming in then this could starve out the writer right that
Dialogue: 0,0:17:36.68,0:17:43.05,Chinese,,0,0,0,,如果现在如果有多位读者不断进入，那么现在就这样可能会使作者挨饿
Dialogue: 0,0:17:43.58,0:17:48.14,English,,0,0,0,,So a writer could be starved sort of indefinitely waiting for all these readers to finish
Dialogue: 0,0:17:43.58,0:17:48.14,Chinese,,0,0,0,,因此，作家可能会无限期地等待所有这些读者完成
Dialogue: 0,0:17:49.88,0:17:53.68,English,,0,0,0,,And it's just based on you know based based on
Dialogue: 0,0:17:49.88,0:17:53.68,Chinese,,0,0,0,,它只是基于你所知的基于
Dialogue: 0,0:17:54.82,0:17:59.36,English,,0,0,0,,How the operating system decides to schedule these various reader threads
Dialogue: 0,0:17:54.82,0:17:59.36,Chinese,,0,0,0,,操作系统如何决定安排这些不同的读取器线程
Dialogue: 0,0:18:00.94,0:18:06.57,English,,0,0,0,,The writer could be starved out so that's what we mean by when we say that it favors readers
Dialogue: 0,0:18:00.94,0:18:06.57,Chinese,,0,0,0,,当我们说它有利于读者时，作者可能会被挨饿，这就是我们的意思
Dialogue: 0,0:18:07.22,0:18:14.68,English,,0,0,0,,Now the second reader saris problem is the sort of the opposite of that so it favors writers right
Dialogue: 0,0:18:07.22,0:18:14.68,Chinese,,0,0,0,,现在第二个读者纱丽问题与此相反，所以它有利于作家
Dialogue: 0,0:18:14.90,0:18:18.52,English,,0,0,0,,So any once a writer is ready to write
Dialogue: 0,0:18:14.90,0:18:18.52,Chinese,,0,0,0,,所以一旦作家准备好写作
Dialogue: 0,0:18:18.54,0:18:21.22,English,,0,0,0,,Then it gets priority over any waiting readers
Dialogue: 0,0:18:18.54,0:18:21.22,Chinese,,0,0,0,,然后它优先于任何等待的读者
Dialogue: 0,0:18:21.58,0:18:25.62,English,,0,0,0,,So in this case if we have multiple writers
Dialogue: 0,0:18:21.58,0:18:25.62,Chinese,,0,0,0,,所以在这种情况下，如果我们有多个作家
Dialogue: 0,0:18:26.10,0:18:28.92,English,,0,0,0,,That want to write they could starve out readers
Dialogue: 0,0:18:26.10,0:18:28.92,Chinese,,0,0,0,,想要写，他们可能会让读者感到沮丧
Dialogue: 0,0:18:32.76,0:18:39.52,English,,0,0,0,,And now there's other variants that sort of deal with this starvation issue potential starvation issue
Dialogue: 0,0:18:32.76,0:18:39.52,Chinese,,0,0,0,,现在有其他变种可以解决这个饥饿问题的潜在饥饿问题
Dialogue: 0,0:18:39.52,0:18:41.88,English,,0,0,0,,But we won't look at them here
Dialogue: 0,0:18:39.52,0:18:41.88,Chinese,,0,0,0,,但我们不会在这里看他们
Dialogue: 0,0:18:43.38,0:18:47.58,English,,0,0,0,,So the let's look at the solution to the first readers writers problem
Dialogue: 0,0:18:43.38,0:18:47.58,Chinese,,0,0,0,,让我们来看看第一个读者编写者问题的解决方案
Dialogue: 0,0:18:50.62,0:18:56.84,English,,0,0,0,,So write initially a thread is either a reader in this sort of simplification or it's a writer
Dialogue: 0,0:18:50.62,0:18:56.84,Chinese,,0,0,0,,所以最初写一个线程要么是这种简化的读者，要么就是作家
Dialogue: 0,0:18:59.44,0:19:01.76,English,,0,0,0,,If we look at the writers this is pretty simple
Dialogue: 0,0:18:59.44,0:19:01.76,Chinese,,0,0,0,,如果我们看一下作家，这很简单
Dialogue: 0,0:19:01.76,0:19:09.20,English,,0,0,0,,It's just the writers are just doing a P on this semaphore
Dialogue: 0,0:19:01.76,0:19:09.20,Chinese,,0,0,0,,这只是作家只是在这个信号量上做P
Dialogue: 0,0:19:09.40,0:19:17.66,English,,0,0,0,,So this the semaphore w is the sort of serves as like a mutex that protects the resource for writer
Dialogue: 0,0:19:09.40,0:19:17.66,Chinese,,0,0,0,,因此，信号量w就像保护作者资源的互斥体一样
Dialogue: 0,0:19:17.72,0:19:25.74,English,,0,0,0,,So it ensures that there's at most one writer at any time executing its critical section
Dialogue: 0,0:19:17.72,0:19:25.74,Chinese,,0,0,0,,因此，它确保在任何时候最多只有一个作者执行其关键部分
Dialogue: 0,0:19:26.54,0:19:34.00,English,,0,0,0,,And it does that by just this this very from this familiar P followed followed by a V
Dialogue: 0,0:19:26.54,0:19:34.00,Chinese,,0,0,0,,就这一点来说，这就是从这个熟悉的P开始，然后是V
Dialogue: 0,0:19:35.60,0:19:37.42,English,,0,0,0,,In the readers are a little more interesting
Dialogue: 0,0:19:35.60,0:19:37.42,Chinese,,0,0,0,,在读者中更有趣
Dialogue: 0,0:19:38.88,0:19:40.30,English,,0,0,0,,So with the reader
Dialogue: 0,0:19:38.88,0:19:40.30,Chinese,,0,0,0,,所以与读者
Dialogue: 0,0:19:40.92,0:19:46.16,English,,0,0,0,,We have the shared this global variable called read count which is going to keep track of the number of readers
Dialogue: 0,0:19:40.92,0:19:46.16,Chinese,,0,0,0,,我们共享了这个名为read count的全局变量，它将跟踪读者的数量
Dialogue: 0,0:19:46.50,0:19:51.58,English,,0,0,0,,That are waiting to read the resource
Dialogue: 0,0:19:46.50,0:19:51.58,Chinese,,0,0,0,,那是在等待阅读资源
Dialogue: 0,0:19:52.34,0:19:57.94,English,,0,0,0,,And there's a mutex semaphore mutex that protects the accesses the updates to read count
Dialogue: 0,0:19:52.34,0:19:57.94,Chinese,,0,0,0,,并且有一个互斥信号量互斥锁可以保护访问更新的读取次数
Dialogue: 0,0:19:58.66,0:20:01.80,English,,0,0,0,,Okay the reads and the rights to up to read count
Dialogue: 0,0:19:58.66,0:20:01.80,Chinese,,0,0,0,,好的读取和读取权限
Dialogue: 0,0:20:02.74,0:20:04.64,English,,0,0,0,,And then there's this w semaphore
Dialogue: 0,0:20:02.74,0:20:04.64,Chinese,,0,0,0,,然后是这个w信号量
Dialogue: 0,0:20:05.12,0:20:10.68,English,,0,0,0,,Which as we saw here is used to protect the critical section in the writer
Dialogue: 0,0:20:05.12,0:20:10.68,Chinese,,0,0,0,,我们在这里看到的用于保护作者中的关键部分
Dialogue: 0,0:20:11.60,0:20:13.90,English,,0,0,0,,And initially both of these are set to one
Dialogue: 0,0:20:11.60,0:20:13.90,Chinese,,0,0,0,,最初这两个都设置为一个
Dialogue: 0,0:20:16.70,0:20:20.52,English,,0,0,0,,So the reader in this infinite loop in each iteration of this infinite loop
Dialogue: 0,0:20:16.70,0:20:20.52,Chinese,,0,0,0,,所以读者在这个无限循环的每次迭代中都有这个无限循环
Dialogue: 0,0:20:21.34,0:20:28.90,English,,0,0,0,,It is going to increment read count so it protects that that access by doing a P(&mutex)
Dialogue: 0,0:20:21.34,0:20:28.90,Chinese,,0,0,0,,它将增加读取计数，以便通过执行P（＆mutex）来保护该访问
Dialogue: 0,0:20:28.90,0:20:30.64,English,,0,0,0,,Which is associated with recount
Dialogue: 0,0:20:28.90,0:20:30.64,Chinese,,0,0,0,,这与重新计数有关
Dialogue: 0,0:20:33.04,0:20:36.80,English,,0,0,0,,So only one reader can be
Dialogue: 0,0:20:33.04,0:20:36.80,Chinese,,0,0,0,,所以只有一个读者可以
Dialogue: 0,0:20:36.96,0:20:44.36,English,,0,0,0,,So this region between the P and the V constitutes the critical section corresponding to read count
Dialogue: 0,0:20:36.96,0:20:44.36,Chinese,,0,0,0,,因此，P和V之间的这个区域构成对应于读取计数的临界区
Dialogue: 0,0:20:45.66,0:20:50.54,English,,0,0,0,,So after the P completes then it
Dialogue: 0,0:20:45.66,0:20:50.54,Chinese,,0,0,0,,所以在P完成之后呢
Dialogue: 0,0:20:51.30,0:20:55.40,English,,0,0,0,,Then we increment the read count so now there's an additional reader
Dialogue: 0,0:20:51.30,0:20:55.40,Chinese,,0,0,0,,然后我们增加读取计数，所以现在有一个额外的读者
Dialogue: 0,0:20:56.20,0:20:58.80,English,,0,0,0,,Alright so we can have potentially arbitrary number of these reader threads
Dialogue: 0,0:20:56.20,0:20:58.80,Chinese,,0,0,0,,好吧，我们可以有任意数量的这些读者线程
Dialogue: 0,0:20:58.80,0:21:03.18,English,,0,0,0,,Right so this we're indicating that there's a new reader now
Dialogue: 0,0:20:58.80,0:21:03.18,Chinese,,0,0,0,,对，所以我们现在表明有一个新的读者
Dialogue: 0,0:21:04.54,0:21:07.90,English,,0,0,0,,And if read count is one that means we're the first reader
Dialogue: 0,0:21:04.54,0:21:07.90,Chinese,,0,0,0,,如果读数是一个意味着我们是第一个读者
Dialogue: 0,0:21:08.46,0:21:14.82,English,,0,0,0,,Okay so this is sort of the first reader into this implicit queue of waiting readers
Dialogue: 0,0:21:08.46,0:21:14.82,Chinese,,0,0,0,,好的，所以这是第一个进入这个等待读者的隐式队列的读者
Dialogue: 0,0:21:17.00,0:21:20.04,English,,0,0,0,,So if read count is one if we're the first reader
Dialogue: 0,0:21:17.00,0:21:20.04,Chinese,,0,0,0,,因此，如果我们是第一个读者，那么如果读数是1
Dialogue: 0,0:21:21.46,0:21:23.36,English,,0,0,0,,Then we do a P(&w)
Dialogue: 0,0:21:21.46,0:21:23.36,Chinese,,0,0,0,,然后我们做P（＆w）
Dialogue: 0,0:21:25.26,0:21:29.26,English,,0,0,0,,Okay which now will lock out any future writers
Dialogue: 0,0:21:25.26,0:21:29.26,Chinese,,0,0,0,,好的，现在将锁定任何未来的作家
Dialogue: 0,0:21:30.58,0:21:36.90,English,,0,0,0,,Now if there's already a writer that's done it's P(&w) then this will block waiting for that writer to finish
Dialogue: 0,0:21:30.58,0:21:36.90,Chinese,,0,0,0,,现在，如果已经有一位作家完成它的P（＆w）那么这将阻止等待该作者完成
Dialogue: 0,0:21:38.74,0:21:43.58,English,,0,0,0,,Okay but if there's no writer in inside of its critical section
Dialogue: 0,0:21:38.74,0:21:43.58,Chinese,,0,0,0,,好吧，但如果其关键部分内没有作家
Dialogue: 0,0:21:44.36,0:21:48.30,English,,0,0,0,,Then this p will just decrement the semaphore w
Dialogue: 0,0:21:44.36,0:21:48.30,Chinese,,0,0,0,,然后这个p将减少信号量w
Dialogue: 0,0:21:49.08,0:21:52.76,English,,0,0,0,,From 1 to 0 and then lock out any subsequent writers
Dialogue: 0,0:21:49.08,0:21:52.76,Chinese,,0,0,0,,从1到0然后锁定任何后续编写器
Dialogue: 0,0:21:54.76,0:22:01.54,English,,0,0,0,,Okay after so now after it's done this increment and read of the recount variable then it releases the mutex
Dialogue: 0,0:21:54.76,0:22:01.54,Chinese,,0,0,0,,好了之后，现在完成这个增量并读取recount变量后，它会释放互斥锁
Dialogue: 0,0:22:02.40,0:22:06.00,English,,0,0,0,,So that other readers can access recount
Dialogue: 0,0:22:02.40,0:22:06.00,Chinese,,0,0,0,,这样其他读者就可以进行重新计票了
Dialogue: 0,0:22:09.92,0:22:11.36,English,,0,0,0,,Okay now but it's still holding
Dialogue: 0,0:22:09.92,0:22:11.36,Chinese,,0,0,0,,好的，但现在仍然坚持
Dialogue: 0,0:22:15.30,0:22:22.76,English,,0,0,0,,It's holding,so this is this is kind of interesting right, it's holding the semaphore that locks out the writers
Dialogue: 0,0:22:15.30,0:22:22.76,Chinese,,0,0,0,,它持有，所以这是一个有趣的权利，它持有锁定作家的信号量
Dialogue: 0,0:22:24.20,0:22:33.10,English,,0,0,0,,But it's not holding the any mutex right so the reader now can just read,it can do its read
Dialogue: 0,0:22:24.20,0:22:33.10,Chinese,,0,0,0,,但它并没有正确地保持任何互斥锁，所以读者现在可以阅读，它可以读取它
Dialogue: 0,0:22:34.32,0:22:41.12,English,,0,0,0,,And other readers that are in the same section of the code can also do their reads right so
Dialogue: 0,0:22:34.32,0:22:41.12,Chinese,,0,0,0,,而在代码的同一部分中的其他读者也可以正确地进行读取
Dialogue: 0,0:22:42.04,0:22:42.60,English,,0,0,0,,So we're not...
Dialogue: 0,0:22:42.04,0:22:42.60,Chinese,,0,0,0,,所以我们不是......
Dialogue: 0,0:22:45.60,0:22:49.15,English,,0,0,0,,So we're allowing multiple readers now inside this critical section
Dialogue: 0,0:22:45.60,0:22:49.15,Chinese,,0,0,0,,所以我们现在允许多个读者进入这个关键部分
Dialogue: 0,0:22:49.62,0:22:51.16,English,,0,0,0,,But but no writers
Dialogue: 0,0:22:49.62,0:22:51.16,Chinese,,0,0,0,,但是没有作家
Dialogue: 0,0:22:52.64,0:22:57.54,English,,0,0,0,,Okay so everything works looks like it works good,now after after we read
Dialogue: 0,0:22:52.64,0:22:57.54,Chinese,,0,0,0,,好的，所以一切正常，看起来效果很好，现在我们读完之后
Dialogue: 0,0:22:58.24,0:23:02.30,English,,0,0,0,,Now the number of readers now is going to be we want to decrement the number of readers
Dialogue: 0,0:22:58.24,0:23:02.30,Chinese,,0,0,0,,现在读者的数量将是我们想要减少读者的数量
Dialogue: 0,0:23:03.18,0:23:05.92,English,,0,0,0,,So we acquire the mutex on readcnt
Dialogue: 0,0:23:03.18,0:23:05.92,Chinese,,0,0,0,,所以我们在readcnt上获取了互斥量
Dialogue: 0,0:23:06.54,0:23:07.86,English,,0,0,0,,We decrement readcnt
Dialogue: 0,0:23:06.54,0:23:07.86,Chinese,,0,0,0,,我们减少了读数
Dialogue: 0,0:23:09.50,0:23:11.80,English,,0,0,0,,And then we check to see if we're the last reader
Dialogue: 0,0:23:09.50,0:23:11.80,Chinese,,0,0,0,,然后我们检查一下我们是不是最后一位读者
Dialogue: 0,0:23:12.52,0:23:13.76,English,,0,0,0,,Okay so if there's no more readers
Dialogue: 0,0:23:12.52,0:23:13.76,Chinese,,0,0,0,,好的，如果没有更多的读者
Dialogue: 0,0:23:14.51,0:23:16.32,English,,0,0,0,,In other words if read count is zero
Dialogue: 0,0:23:14.51,0:23:16.32,Chinese,,0,0,0,,换句话说，如果读取计数为零
Dialogue: 0,0:23:18.14,0:23:20.96,English,,0,0,0,,Then now we can release the mutex for the writer
Dialogue: 0,0:23:18.14,0:23:20.96,Chinese,,0,0,0,,然后现在我们可以为作者释放互斥锁
Dialogue: 0,0:23:21.34,0:23:24.24,English,,0,0,0,,So that any now writers can access that resource
Dialogue: 0,0:23:21.34,0:23:24.24,Chinese,,0,0,0,,这样任何现在的编写者都可以访问该资源
Dialogue: 0,0:23:25.98,0:23:33.52,English,,0,0,0,,And after we release that the writers mutex then we release the mutex for recount
Dialogue: 0,0:23:25.98,0:23:33.52,Chinese,,0,0,0,,在我们释放编写器互斥锁之后，我们释放互斥锁用于重新计数
Dialogue: 0,0:23:37.20,0:23:39.16,English,,0,0,0,,So any questions about about this
Dialogue: 0,0:23:37.20,0:23:39.16,Chinese,,0,0,0,,所以有关于此的任何问题
Dialogue: 0,0:23:43.20,0:23:45.36,English,,0,0,0,,So an interesting for you to think about just...
Dialogue: 0,0:23:43.20,0:23:45.36,Chinese,,0,0,0,,所以有趣的是你只想......
Dialogue: 0,0:23:46.18,0:23:47.36,English,,0,0,0,,If you have any spare time
Dialogue: 0,0:23:46.18,0:23:47.36,Chinese,,0,0,0,,如果你有空余时间
Dialogue: 0,0:23:47.80,0:23:56.16,English,,0,0,0,,How you might write a version of this readers writers problem or that favors writers instead of readers
Dialogue: 0,0:23:47.80,0:23:56.16,Chinese,,0,0,0,,你怎么可能写一个这个读者作家的版本问题或赞成作家而不是读者
Dialogue: 0,0:23:59.80,0:24:00.18,English,,0,0,0,,Yes
Dialogue: 0,0:23:59.80,0:24:00.18,Chinese,,0,0,0,,是
Dialogue: 0,0:24:00.30,0:24:05.96,English,,0,0,0,,[student speaking]
Dialogue: 0,0:24:05.96,0:24:09.44,English,,0,0,0,,Oh no okay so the question is a mutex allows for multiple readers
Dialogue: 0,0:24:05.96,0:24:09.44,Chinese,,0,0,0,,哦不行，所以问题是互斥量允许多个读者
Dialogue: 0,0:24:11.08,0:24:15.36,English,,0,0,0,,The fact that we...No,the fact that we're releasing this mutex here
Dialogue: 0,0:24:11.08,0:24:15.36,Chinese,,0,0,0,,事实上，我们......不，我们在这里发布这个互斥锁的事实
Dialogue: 0,0:24:15.42,0:24:19.40,English,,0,0,0,,That this mutex is only protecting access to readcnt
Dialogue: 0,0:24:15.42,0:24:19.40,Chinese,,0,0,0,,这个互斥锁只是保护对readcnt的访问
Dialogue: 0,0:24:19.74,0:24:21.84,English,,0,0,0,,So we acquire it here and we release it here
Dialogue: 0,0:24:19.74,0:24:21.84,Chinese,,0,0,0,,所以我们在这里获得它，我们在这里发布它
Dialogue: 0,0:24:22.30,0:24:25.48,English,,0,0,0,,After we've...after we've accessed read count
Dialogue: 0,0:24:22.30,0:24:25.48,Chinese,,0,0,0,,在我们...之后我们访问了读取计数
Dialogue: 0,0:24:27.22,0:24:31.72,English,,0,0,0,,Okay but we're not protecting the critical section of the reader with any mutex
Dialogue: 0,0:24:27.22,0:24:31.72,Chinese,,0,0,0,,好的，但我们没有用任何互斥锁来保护读者的关键部分
Dialogue: 0,0:24:33.42,0:24:39.18,English,,0,0,0,,Except for we're keeping writers out by...if we're the first one in
Dialogue: 0,0:24:33.42,0:24:39.18,Chinese,,0,0,0,,除了我们要把作家留在......如果我们是第一个
Dialogue: 0,0:24:39.84,0:24:40.98,English,,0,0,0,,If we're the first reader
Dialogue: 0,0:24:39.84,0:24:40.98,Chinese,,0,0,0,,如果我们是第一个读者
Dialogue: 0,0:24:42.84,0:24:47.38,English,,0,0,0,,You commanders like this implicit queue of readers that we're keeping track of with readcnt
Dialogue: 0,0:24:42.84,0:24:47.38,Chinese,,0,0,0,,你这个隐含的读者队列的指挥官，我们用readcnt跟踪它们
Dialogue: 0,0:24:48.40,0:24:52.96,English,,0,0,0,,Okay so if we're the first ones in meaning
Dialogue: 0,0:24:48.40,0:24:52.96,Chinese,,0,0,0,,好的，如果我们是第一个有意义的人
Dialogue: 0,0:24:53.54,0:24:59.04,English,,0,0,0,,We're the first reader then we we acquire this the p on the writers mutex
Dialogue: 0,0:24:53.54,0:24:59.04,Chinese,,0,0,0,,我们是第一个读者，然后我们在作者互斥上获得这个p
Dialogue: 0,0:24:59.24,0:25:04.24,English,,0,0,0,,Now if there's of course if there's a writer inside this critical section then
Dialogue: 0,0:24:59.24,0:25:04.24,Chinese,,0,0,0,,现在，如果当然在这个关键部分内有作家的话
Dialogue: 0,0:25:04.88,0:25:07.86,English,,0,0,0,,This P will wait until the writer releases
Dialogue: 0,0:25:04.88,0:25:07.86,Chinese,,0,0,0,,这个P将等到作者发布
Dialogue: 0,0:25:09.88,0:25:14.72,English,,0,0,0,,Okay but once we've acquired this mutex w
Dialogue: 0,0:25:09.88,0:25:14.72,Chinese,,0,0,0,,好的，但是一旦我们获得了这个互斥锁
Dialogue: 0,0:25:16.30,0:25:18.54,English,,0,0,0,,Then we're block...we're locking out any writers
Dialogue: 0,0:25:16.30,0:25:18.54,Chinese,,0,0,0,,然后我们阻止......我们将锁定任何作家
Dialogue: 0,0:25:19.24,0:25:28.12,English,,0,0,0,,Okay because they'll any writer that arrives we'll do a P and it will block right here on waiting for that w to be nonzero
Dialogue: 0,0:25:19.24,0:25:28.12,Chinese,,0,0,0,,好吧，因为他们会有任何到来的作家，我们会做一个P，它会阻止在这里等待w非零
Dialogue: 0,0:25:29.54,0:25:36.98,English,,0,0,0,,Okay so we're just blocking out any writers but then we're allowing any readers to just to access the resource
Dialogue: 0,0:25:29.54,0:25:36.98,Chinese,,0,0,0,,好的，我们只是阻止任何作者，但我们允许任何读者只是访问资源
Dialogue: 0,0:25:40.08,0:25:40.52,English,,0,0,0,,Okay
Dialogue: 0,0:25:40.08,0:25:40.52,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:41.84,0:25:42.50,English,,0,0,0,,Okay good
Dialogue: 0,0:25:41.84,0:25:42.50,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:45.14,0:25:45.72,English,,0,0,0,,Yes question
Dialogue: 0,0:25:45.14,0:25:45.72,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:25:45.72,0:25:49.64,English,,0,0,0,,[student speaking]
Dialogue: 0,0:25:49.64,0:25:51.02,English,,0,0,0,,Question is blocking slow
Dialogue: 0,0:25:49.64,0:25:51.02,Chinese,,0,0,0,,问题阻塞缓慢
Dialogue: 0,0:25:51.50,0:25:56.00,English,,0,0,0,,It can be depends well first of all you're making a call into the kernel so it's a system call
Dialogue: 0,0:25:51.50,0:25:56.00,Chinese,,0,0,0,,它首先取决于你是否正在调用内核，因此它是一个系统调用
Dialogue: 0,0:25:56.56,0:26:00.10,English,,0,0,0,,So you're crossing that boundary and there's always overhead associated with that
Dialogue: 0,0:25:56.56,0:26:00.10,Chinese,,0,0,0,,所以你越过那个边界，总是有与之相关的开销
Dialogue: 0,0:26:01.00,0:26:07.08,English,,0,0,0,,And then blocking you're blocked until you know it can be sort of an arbitrary amount of time right
Dialogue: 0,0:26:01.00,0:26:07.08,Chinese,,0,0,0,,阻止你被阻止，直到你知道它可能是一段任意的时间
Dialogue: 0,0:26:07.08,0:26:09.58,English,,0,0,0,,Until someone doesn't,some thread does a V
Dialogue: 0,0:26:07.08,0:26:09.58,Chinese,,0,0,0,,直到有人没有，有些线程会做V
Dialogue: 0,0:26:10.32,0:26:11.92,English,,0,0,0,,So yeah it can't be slow
Dialogue: 0,0:26:10.32,0:26:11.92,Chinese,,0,0,0,,所以是的，它不能慢
Dialogue: 0,0:26:13.22,0:26:18.34,English,,0,0,0,,Right it just depends you can't,it's really hard to bound the time that you're going to be blocked
Dialogue: 0,0:26:13.22,0:26:18.34,Chinese,,0,0,0,,对，它只是取决于你不能，你很难限制你被阻止的时间
Dialogue: 0,0:26:19.22,0:26:22.44,English,,0,0,0,,Now if you write the program correctly eventually you'll be unblocked
Dialogue: 0,0:26:19.22,0:26:22.44,Chinese,,0,0,0,,现在如果你正确编写程序，你将被解除阻止
Dialogue: 0,0:26:23.10,0:26:25.48,English,,0,0,0,,You know eventually some thread will execute a V
Dialogue: 0,0:26:23.10,0:26:25.48,Chinese,,0,0,0,,你知道最终一些线程将执行V
Dialogue: 0,0:26:27.88,0:26:35.50,English,,0,0,0,,But when we're sort of assuming that the kernel does some kind of when it implements its V it does some kind of fair scheduling that
Dialogue: 0,0:26:27.88,0:26:35.50,Chinese,,0,0,0,,但是，当我们假设内核在实现其V时执行某种操作时，它会执行某种公平调度
Dialogue: 0,0:26:36.26,0:26:44.42,English,,0,0,0,,So a blocked P won't be in its queue for forever right that the kernel does some kind of something that's fair
Dialogue: 0,0:26:36.26,0:26:44.42,Chinese,,0,0,0,,所以一个被阻塞的P将永远不会在其队列中，内核会做某种公平的事情
Dialogue: 0,0:26:44.78,0:26:48.70,English,,0,0,0,,So it guarantees that a P won't remain blocked indefinitely
Dialogue: 0,0:26:44.78,0:26:48.70,Chinese,,0,0,0,,因此，它保证P不会无限期地被阻止
Dialogue: 0,0:26:54.80,0:26:55.60,English,,0,0,0,,Other questions
Dialogue: 0,0:26:54.80,0:26:55.60,Chinese,,0,0,0,,其他问题
Dialogue: 0,0:27:00.86,0:27:02.86,English,,0,0,0,,Okay so we can kind of put all of this together
Dialogue: 0,0:27:00.86,0:27:02.86,Chinese,,0,0,0,,好的，我们可以将所有这些放在一起
Dialogue: 0,0:27:04.42,0:27:08.46,English,,0,0,0,,And and use our producer-consumer model
Dialogue: 0,0:27:04.42,0:27:08.46,Chinese,,0,0,0,,并使用我们的生产者 - 消费者模型
Dialogue: 0,0:27:09.30,0:27:13.26,English,,0,0,0,,To implement a pre threaded concurrent echo server
Dialogue: 0,0:27:09.30,0:27:13.26,Chinese,,0,0,0,,实现预先线程并发回显服务器
Dialogue: 0,0:27:13.78,0:27:16.44,English,,0,0,0,,Now so far when we've used threads to
Dialogue: 0,0:27:13.78,0:27:16.44,Chinese,,0,0,0,,到目前为止，当我们使用线程时
Dialogue: 0,0:27:16.78,0:27:20.12,English,,0,0,0,,In all our examples of using threads and processes for servers
Dialogue: 0,0:27:16.78,0:27:20.12,Chinese,,0,0,0,,在我们为服务器使用线程和进程的所有示例中
Dialogue: 0,0:27:20.70,0:27:24.54,English,,0,0,0,,We created a new thread or process whenever a new connection requests arrived
Dialogue: 0,0:27:20.70,0:27:24.54,Chinese,,0,0,0,,每当有新的连接请求到达时，我们都会创建一个新线程或进程
Dialogue: 0,0:27:25.92,0:27:27.06,English,,0,0,0,,And then when
Dialogue: 0,0:27:25.92,0:27:27.06,Chinese,,0,0,0,,然后什么时候
Dialogue: 0,0:27:28.04,0:27:30.66,English,,0,0,0,,And then that thread interacted with the client
Dialogue: 0,0:27:28.04,0:27:30.66,Chinese,,0,0,0,,然后该线程与客户端进行了交互
Dialogue: 0,0:27:31.66,0:27:36.36,English,,0,0,0,,And then whenever that interaction was finished it closed the connection and exited
Dialogue: 0,0:27:31.66,0:27:36.36,Chinese,,0,0,0,,然后，无论何时完成该交互，它都会关闭连接并退出
Dialogue: 0,0:27:36.66,0:27:38.58,English,,0,0,0,,And killed the thread or process
Dialogue: 0,0:27:36.66,0:27:38.58,Chinese,,0,0,0,,并杀死了线程或进程
Dialogue: 0,0:27:39.34,0:27:42.64,English,,0,0,0,,Now that's okay but it's inefficient
Dialogue: 0,0:27:39.34,0:27:42.64,Chinese,,0,0,0,,现在没关系，但效率低下
Dialogue: 0,0:27:43.50,0:27:49.14,English,,0,0,0,,Because we're this creating and killing threads introduces overhead
Dialogue: 0,0:27:43.50,0:27:49.14,Chinese,,0,0,0,,因为我们正在创建和杀死线程引入开销
Dialogue: 0,0:27:50.28,0:27:59.02,English,,0,0,0,,So another way to do this is to create the treads or processes ahead of time create a pool of threads
Dialogue: 0,0:27:50.28,0:27:59.02,Chinese,,0,0,0,,因此，另一种方法是提前创建踏板或流程创建一个线程池
Dialogue: 0,0:27:59.34,0:28:04.20,English,,0,0,0,,Where each thread so we create a pool of these worker threads
Dialogue: 0,0:27:59.34,0:28:04.20,Chinese,,0,0,0,,每个线程都在这里我们创建这些工作线程的池
Dialogue: 0,0:28:04.20,0:28:08.88,English,,0,0,0,,Where each of these worker threads interacts with can interact with a client
Dialogue: 0,0:28:04.20,0:28:08.88,Chinese,,0,0,0,,这些工作线程中的每一个与之交互的位置都可以与客户端进行交互
Dialogue: 0,0:28:11.10,0:28:14.84,English,,0,0,0,,Okay so instead of sort of creating processes and threads on on-demand
Dialogue: 0,0:28:11.10,0:28:14.84,Chinese,,0,0,0,,好的，而不是按需创建进程和线程
Dialogue: 0,0:28:14.86,0:28:22.84,English,,0,0,0,,We create a,what we call a set of pre threaded or pre threaded threads or pre forked processes
Dialogue: 0,0:28:14.86,0:28:22.84,Chinese,,0,0,0,,我们创建一个，我们称之为一组预先线程或预先线程的线程或预分叉的进程
Dialogue: 0,0:28:23.80,0:28:24.52,English,,0,0,0,,That do the work
Dialogue: 0,0:28:23.80,0:28:24.52,Chinese,,0,0,0,,那做的工作
Dialogue: 0,0:28:25.48,0:28:30.44,English,,0,0,0,,So the idea is that we have this master thread in our server
Dialogue: 0,0:28:25.48,0:28:30.44,Chinese,,0,0,0,,所以我们的想法是在服务器中有这个主线程
Dialogue: 0,0:28:30.96,0:28:36.82,English,,0,0,0,,That's waiting for connection requests from clients by repeated calls to accept
Dialogue: 0,0:28:30.96,0:28:36.82,Chinese,,0,0,0,,那是通过反复调用来等待来自客户端的连接请求
Dialogue: 0,0:28:38.40,0:28:41.72,English,,0,0,0,,And then when this thread receives the connection request
Dialogue: 0,0:28:38.40,0:28:41.72,Chinese,,0,0,0,,然后当这个线程收到连接请求
Dialogue: 0,0:28:42.40,0:28:48.52,English,,0,0,0,,From the client the accept call the accept function returns a connected file descriptor
Dialogue: 0,0:28:42.40,0:28:48.52,Chinese,,0,0,0,,从客户端接受调用accept函数返回一个连接的文件描述符
Dialogue: 0,0:28:49.32,0:28:52.62,English,,0,0,0,,Ok associated with the connection to the client
Dialogue: 0,0:28:49.32,0:28:52.62,Chinese,,0,0,0,,确定与客户端的连接相关联
Dialogue: 0,0:28:53.82,0:28:58.38,English,,0,0,0,,And then it inserts that descriptor into a into a buffer
Dialogue: 0,0:28:53.82,0:28:58.38,Chinese,,0,0,0,,然后它将该描述符插入到缓冲区中
Dialogue: 0,0:28:58.76,0:29:01.74,English,,0,0,0,,Ok now remember descriptors are just small integers
Dialogue: 0,0:28:58.76,0:29:01.74,Chinese,,0,0,0,,好的，现在记住描述符只是小整数
Dialogue: 0,0:29:02.48,0:29:04.74,English,,0,0,0,,That index the descriptor table
Dialogue: 0,0:29:02.48,0:29:04.74,Chinese,,0,0,0,,那个索引描述符表
Dialogue: 0,0:29:05.28,0:29:09.10,English,,0,0,0,,Right so they can be passed around from thread to thread
Dialogue: 0,0:29:05.28,0:29:09.10,Chinese,,0,0,0,,正确，因此它们可以从线程传递到线程
Dialogue: 0,0:29:09.22,0:29:10.94,English,,0,0,0,,Because all the threads are sharing the same
Dialogue: 0,0:29:09.22,0:29:10.94,Chinese,,0,0,0,,因为所有线程共享相同
Dialogue: 0,0:29:12.00,0:29:15.50,English,,0,0,0,,The same set that same descriptor table right
Dialogue: 0,0:29:12.00,0:29:15.50,Chinese,,0,0,0,,相同的描述符表设置相同
Dialogue: 0,0:29:17.76,0:29:19.48,English,,0,0,0,,So the master thread puts
Dialogue: 0,0:29:17.76,0:29:19.48,Chinese,,0,0,0,,所以主线程放了
Dialogue: 0,0:29:21.32,0:29:28.90,English,,0,0,0,,The repeatedly accepts connection requests and inserts the corresponding connected file descriptor into the buffer
Dialogue: 0,0:29:21.32,0:29:28.90,Chinese,,0,0,0,,重复接受连接请求并将相应的连接文件描述符插入缓冲区
Dialogue: 0,0:29:30.32,0:29:37.00,English,,0,0,0,,Now each worker thread waits for the...so in this case the items are descriptors
Dialogue: 0,0:29:30.32,0:29:37.00,Chinese,,0,0,0,,现在每个工作线程都等待...所以在这种情况下，项目是描述符
Dialogue: 0,0:29:37.88,0:29:43.25,English,,0,0,0,,So the worker threads they're all waiting on this for items to appear in this buffer
Dialogue: 0,0:29:37.88,0:29:43.25,Chinese,,0,0,0,,所以工作线程他们都在等待这个项目出现在这个缓冲区中
Dialogue: 0,0:29:44.80,0:29:48.14,English,,0,0,0,,Okay and when an item appears one of the threads will remove that item
Dialogue: 0,0:29:44.80,0:29:48.14,Chinese,,0,0,0,,好的，当一个项目出现时，其中一个线程将删除该项目
Dialogue: 0,0:29:51.56,0:29:55.86,English,,0,0,0,,And then use that descriptor to interact with the client
Dialogue: 0,0:29:51.56,0:29:55.86,Chinese,,0,0,0,,然后使用该描述符与客户端进行交互
Dialogue: 0,0:29:55.86,0:30:02.76,English,,0,0,0,,Over the connected file descriptor associated with the connection that exists between the client and the server
Dialogue: 0,0:29:55.86,0:30:02.76,Chinese,,0,0,0,,通过与客户端和服务器之间存在的连接关联的连接文件描述符
Dialogue: 0,0:30:04.46,0:30:12.38,English,,0,0,0,,Okay so now we have the concurrency comes in the form of these multiple worker threads interacting with multiple clients
Dialogue: 0,0:30:04.46,0:30:12.38,Chinese,,0,0,0,,好的，现在我们的并发性是以多个工作线程与多个客户端交互的形式出现的
Dialogue: 0,0:30:13.24,0:30:18.16,English,,0,0,0,,And then when a worker thread finishes servicing a particular client
Dialogue: 0,0:30:13.24,0:30:18.16,Chinese,,0,0,0,,然后当工作线程完成为特定客户端提供服务时
Dialogue: 0,0:30:19.70,0:30:23.44,English,,0,0,0,,Then it just goes and it checks for the next file descriptor in the buffer
Dialogue: 0,0:30:19.70,0:30:23.44,Chinese,,0,0,0,,然后它就去了，它检查缓冲区中的下一个文件描述符
Dialogue: 0,0:30:24.14,0:30:29.00,English,,0,0,0,,Okay so this is much more efficient than our previous model where
Dialogue: 0,0:30:24.14,0:30:29.00,Chinese,,0,0,0,,好的，这比我们以前的型号更有效率
Dialogue: 0,0:30:29.70,0:30:32.50,English,,0,0,0,,For each new client we had to create a thread or a process
Dialogue: 0,0:30:29.70,0:30:32.50,Chinese,,0,0,0,,对于每个新客户端，我们必须创建一个线程或进程
Dialogue: 0,0:30:32.90,0:30:35.64,English,,0,0,0,,And then destroy that thread or process once we were finished
Dialogue: 0,0:30:32.90,0:30:35.64,Chinese,,0,0,0,,然后在我们完成后销毁该线程或进程
Dialogue: 0,0:30:35.98,0:30:39.20,English,,0,0,0,,Okay so we're sort of re amortize that
Dialogue: 0,0:30:35.98,0:30:39.20,Chinese,,0,0,0,,好的，所以我们有点重新摊销
Dialogue: 0,0:30:40.40,0:30:44.50,English,,0,0,0,,That we had to go through to create these worker threads by leaving them running
Dialogue: 0,0:30:40.40,0:30:44.50,Chinese,,0,0,0,,我们必须通过让它们运行来创建这些工作线程
Dialogue: 0,0:30:45.02,0:30:53.24,English,,0,0,0,,And then replacing the destruction or the killing of that thread with replacing it with just a simple
Dialogue: 0,0:30:45.02,0:30:53.24,Chinese,,0,0,0,,然后用一个简单的替换它替换破坏或杀死该线程
Dialogue: 0,0:30:54.38,0:30:59.98,English,,0,0,0,,As simple and very fast operation of removing an item from the buffer
Dialogue: 0,0:30:54.38,0:30:59.98,Chinese,,0,0,0,,从缓冲区中删除项目的操作简单而快速
Dialogue: 0,0:31:02.80,0:31:05.60,English,,0,0,0,,Okay so let's see how we would implement this
Dialogue: 0,0:31:02.80,0:31:05.60,Chinese,,0,0,0,,好的，让我们看看我们将如何实现这一点
Dialogue: 0,0:31:07.16,0:31:10.24,English,,0,0,0,,And like all of these server examples it's surprisingly simple right
Dialogue: 0,0:31:07.16,0:31:10.24,Chinese,,0,0,0,,和所有这些服务器示例一样，它非常简单
Dialogue: 0,0:31:10.44,0:31:18.64,English,,0,0,0,,This is a fully functioning a real server but we can do it in one page of code
Dialogue: 0,0:31:10.44,0:31:18.64,Chinese,,0,0,0,,这是一个功能齐全的真实服务器，但我们可以在一页代码中完成
Dialogue: 0,0:31:20.44,0:31:24.18,English,,0,0,0,,So for this preth... we're going to use threads for our concurrent server
Dialogue: 0,0:31:20.44,0:31:24.18,Chinese,,0,0,0,,所以对于这个preth ...我们将为我们的并发服务器使用线程
Dialogue: 0,0:31:25.14,0:31:28.08,English,,0,0,0,,And we're going to use the sbuf package so we're going to create this
Dialogue: 0,0:31:25.14,0:31:28.08,Chinese,,0,0,0,,我们将使用sbuf包，所以我们将创建它
Dialogue: 0,0:31:28.68,0:31:33.04,English,,0,0,0,,This shared buffer global variable called sbuf
Dialogue: 0,0:31:28.68,0:31:33.04,Chinese,,0,0,0,,这个共享缓冲区全局变量名为sbuf
Dialogue: 0,0:31:36.28,0:31:41.02,English,,0,0,0,,And we have listening descriptor and connected descriptor
Dialogue: 0,0:31:36.28,0:31:41.02,Chinese,,0,0,0,,我们有监听描述符和连接描述符
Dialogue: 0,0:31:41.24,0:31:45.90,English,,0,0,0,,And we have the clientlen and clientaddr that that will be used in the accept call
Dialogue: 0,0:31:41.24,0:31:45.90,Chinese,,0,0,0,,我们有clientlen和clientaddr将在accept调用中使用
Dialogue: 0,0:31:46.32,0:31:52.44,English,,0,0,0,,And we have the thread id(t_id) that will be used in the when we create that this thread
Dialogue: 0,0:31:46.32,0:31:52.44,Chinese,,0,0,0,,我们有线程id（t_id）将在我们创建这个线程时使用
Dialogue: 0,0:31:53.80,0:31:59.32,English,,0,0,0,,So now that we start by...we're going to in this program,we're going to pass in the port number
Dialogue: 0,0:31:53.80,0:31:59.32,Chinese,,0,0,0,,所以现在我们开始...我们将在这个程序中，我们将传递端口号
Dialogue: 0,0:31:59.34,0:32:02.00,English,,0,0,0,,So the server is going to be listening on some port
Dialogue: 0,0:31:59.34,0:32:02.00,Chinese,,0,0,0,,所以服务器将在某个端口上侦听
Dialogue: 0,0:32:02.66,0:32:06.60,English,,0,0,0,,So we passed that port number in as the first argument
Dialogue: 0,0:32:02.66,0:32:06.60,Chinese,,0,0,0,,所以我们将该端口号作为第一个参数传递
Dialogue: 0,0:32:09.42,0:32:12.30,English,,0,0,0,,So we call Open_listenfd(argv[1])
Dialogue: 0,0:32:09.42,0:32:12.30,Chinese,,0,0,0,,所以我们调用Open_listenfd（argv [1]）
Dialogue: 0,0:32:13.92,0:32:17.38,English,,0,0,0,,An open_listenfd creates a listening descriptor and returns it
Dialogue: 0,0:32:13.92,0:32:17.38,Chinese,,0,0,0,,open_listenfd创建一个监听描述符并返回它
Dialogue: 0,0:32:18.04,0:32:20.78,English,,0,0,0,,Returns the value of that descriptor and listenfd
Dialogue: 0,0:32:18.04,0:32:20.78,Chinese,,0,0,0,,返回该描述符和listenfd的值
Dialogue: 0,0:32:22.06,0:32:26.50,English,,0,0,0,,And then we call sbuf_init to initialize a shared buffer
Dialogue: 0,0:32:22.06,0:32:26.50,Chinese,,0,0,0,,然后我们调用sbuf_init来初始化共享缓冲区
Dialogue: 0,0:32:28.36,0:32:31.58,English,,0,0,0,,With SBUFSIZE file descriptors
Dialogue: 0,0:32:28.36,0:32:31.58,Chinese,,0,0,0,,使用SBUFSIZE文件描述符
Dialogue: 0,0:32:33.92,0:32:37.36,English,,0,0,0,,And then we create a collection of NTHREADS worker threads
Dialogue: 0,0:32:33.92,0:32:37.36,Chinese,,0,0,0,,然后我们创建一个NTHREADS工作线程的集合
Dialogue: 0,0:32:38.34,0:32:44.24,English,,0,0,0,,Each of which will execute the thread routine which we've called thread  and no argument
Dialogue: 0,0:32:38.34,0:32:44.24,Chinese,,0,0,0,,每个都将执行我们调用线程而没有参数的线程例程
Dialogue: 0,0:32:46.78,0:32:50.42,English,,0,0,0,,So once we create these all of these threads then we go in this infinite loop
Dialogue: 0,0:32:46.78,0:32:50.42,Chinese,,0,0,0,,因此，一旦我们创建了所有这些线程，我们就会进入这个无限循环
Dialogue: 0,0:32:52.26,0:32:56.66,English,,0,0,0,,Where we call Accept
Dialogue: 0,0:32:52.26,0:32:56.66,Chinese,,0,0,0,,我们称之为接受
Dialogue: 0,0:32:59.38,0:33:05.06,English,,0,0,0,,On this listening descriptor so in that except we'll block until a connection request arrives
Dialogue: 0,0:32:59.38,0:33:05.06,Chinese,,0,0,0,,在这个监听描述符上，除了我们将阻止直到连接请求到达
Dialogue: 0,0:33:05.62,0:33:11.72,English,,0,0,0,,And when it does the accept returns with a connected file descriptor that can be used to interact with the client
Dialogue: 0,0:33:05.62,0:33:11.72,Chinese,,0,0,0,,当它执行时，accept返回一个连接的文件描述符，可用于与客户端进行交互
Dialogue: 0,0:33:14.22,0:33:18.56,English,,0,0,0,,And once we get that connected file descriptor then we just simply insert it
Dialogue: 0,0:33:14.22,0:33:18.56,Chinese,,0,0,0,,一旦我们获得了连接文件描述符，我们就可以简单地插入它
Dialogue: 0,0:33:19.48,0:33:24.02,English,,0,0,0,,We insert that that connected file descriptor into a shared buffer
Dialogue: 0,0:33:19.48,0:33:24.02,Chinese,,0,0,0,,我们将连接的文件描述符插入共享缓冲区
Dialogue: 0,0:33:24.76,0:33:28.26,English,,0,0,0,,And then wait for the connection request the next connection request
Dialogue: 0,0:33:24.76,0:33:28.26,Chinese,,0,0,0,,然后等待连接请求下一个连接请求
Dialogue: 0,0:33:28.26,0:33:34.98,English,,0,0,0,,So our servers very efficient right we're just doing an accept and then a very fast insert into the buffer
Dialogue: 0,0:33:28.26,0:33:34.98,Chinese,,0,0,0,,所以我们的服务器非常高效，我们只是接受，然后非常快速地插入缓冲区
Dialogue: 0,0:33:35.72,0:33:44.60,English,,0,0,0,,Okay and then we're going to let the worker threads do all the work associated with that queue of descriptors
Dialogue: 0,0:33:35.72,0:33:44.60,Chinese,,0,0,0,,好的，然后我们将让工作线程完成与该描述符队列相关的所有工作
Dialogue: 0,0:33:47.44,0:33:51.50,English,,0,0,0,,Now the thread routine first detaches
Dialogue: 0,0:33:47.44,0:33:51.50,Chinese,,0,0,0,,现在线程例程首先分离
Dialogue: 0,0:33:51.86,0:33:53.98,English,,0,0,0,,Okay so this is a case where we don't want to run joinable
Dialogue: 0,0:33:51.86,0:33:53.98,Chinese,,0,0,0,,好的，这是我们不想运行可连接的情况
Dialogue: 0,0:33:54.88,0:33:57.64,English,,0,0,0,,Because we're never going to to join
Dialogue: 0,0:33:54.88,0:33:57.64,Chinese,,0,0,0,,因为我们永远不会加入
Dialogue: 0,0:33:58.10,0:34:05.56,English,,0,0,0,,We're never going to wait for these threads or have any reason to I kill them from the main thread
Dialogue: 0,0:33:58.10,0:34:05.56,Chinese,,0,0,0,,我们永远不会等待这些线程，或者有任何理由让我从主线程中杀死它们
Dialogue: 0,0:34:06.64,0:34:12.16,English,,0,0,0,,So this so now this this worker thread and in this infinite loop each iteration it removes
Dialogue: 0,0:34:06.64,0:34:12.16,Chinese,,0,0,0,,所以这就是现在这个工作线程并且在这个无限循环中它每次迭代都会删除
Dialogue: 0,0:34:12.82,0:34:18.70,English,,0,0,0,,An item from the buffer so it blocks until there's an item that it can remove from the buffer
Dialogue: 0,0:34:12.82,0:34:18.70,Chinese,,0,0,0,,缓冲区中的一个项目，因此它会阻塞，直到有一个项目可以从缓冲区中删除
Dialogue: 0,0:34:19.60,0:34:25.36,English,,0,0,0,,And it sets it to this local variable connfd
Dialogue: 0,0:34:19.60,0:34:25.36,Chinese,,0,0,0,,并将其设置为此局部变量connfd
Dialogue: 0,0:34:26.22,0:34:30.58,English,,0,0,0,,And then it calls a helper sort of this is like the the helper function
Dialogue: 0,0:34:26.22,0:34:30.58,Chinese,,0,0,0,,然后它调用辅助类，这就像辅助函数一样
Dialogue: 0,0:34:31.42,0:34:36.90,English,,0,0,0,,That implements the logic for this this particular server and in this case it's an echo server
Dialogue: 0,0:34:31.42,0:34:36.90,Chinese,,0,0,0,,这实现了这个特定服务器的逻辑，在这种情况下它是一个echo服务器
Dialogue: 0,0:34:38.20,0:34:42.54,English,,0,0,0,,So this echo count routine will interact with the client
Dialogue: 0,0:34:38.20,0:34:42.54,Chinese,,0,0,0,,因此，此回显计数例程将与客户端进行交互
Dialogue: 0,0:34:42.56,0:34:46.54,English,,0,0,0,,Echoing whatever the client sends us until the client closes the connection
Dialogue: 0,0:34:42.56,0:34:46.54,Chinese,,0,0,0,,回应客户端发送给我们的任何信息，直到客户端关闭连接
Dialogue: 0,0:34:48.26,0:34:50.60,English,,0,0,0,,And then when it so whenever the client is finished then
Dialogue: 0,0:34:48.26,0:34:50.60,Chinese,,0,0,0,,然后当客户端完成时就这样了
Dialogue: 0,0:34:52.26,0:35:00.66,English,,0,0,0,,Then we close the we close the an end of the connection and go back and get the next item out of the buffer
Dialogue: 0,0:34:52.26,0:35:00.66,Chinese,,0,0,0,,然后我们关闭我们关闭连接的一端并返回并从缓冲区中获取下一个项目
Dialogue: 0,0:35:02.38,0:35:06.70,English,,0,0,0,,And as you point out that echo count is just a placeholder this could be anything
Dialogue: 0,0:35:02.38,0:35:06.70,Chinese,,0,0,0,,当你指出echo数只是一个占位符时，这可能是任何东西
Dialogue: 0,0:35:06.70,0:35:11.72,English,,0,0,0,,This could be the logic for a web server for any kind of web service or any kind of service
Dialogue: 0,0:35:06.70,0:35:11.72,Chinese,,0,0,0,,这可能是任何类型的Web服务或任何类型的服务的Web服务器的逻辑
Dialogue: 0,0:35:15.66,0:35:16.42,English,,0,0,0,,Now
Dialogue: 0,0:35:15.66,0:35:16.42,Chinese,,0,0,0,,现在
Dialogue: 0,0:35:18.38,0:35:22.44,English,,0,0,0,,The to initialize this echo count(init_echo_cnt) function
Dialogue: 0,0:35:18.38,0:35:22.44,Chinese,,0,0,0,,初始化此echo count（init_echo_cnt）函数
Dialogue: 0,0:35:24.38,0:35:28.90,English,,0,0,0,,We need to initialize the mutex
Dialogue: 0,0:35:24.38,0:35:28.90,Chinese,,0,0,0,,我们需要初始化互斥锁
Dialogue: 0,0:35:30.78,0:35:38.54,English,,0,0,0,,So we're...so this echo count function is going to have it has it defines a global variable called byte_cnt
Dialogue: 0,0:35:30.78,0:35:38.54,Chinese,,0,0,0,,所以我们......所以这个echo count函数会定义一个名为byte_cnt的全局变量
Dialogue: 0,0:35:39.34,0:35:45.12,English,,0,0,0,,So this in this echo server we're going to keep track of the number of bytes that we've received from all the clients
Dialogue: 0,0:35:39.34,0:35:45.12,Chinese,,0,0,0,,所以在这个echo服务器中，我们将跟踪我们从所有客户端收到的字节数
Dialogue: 0,0:35:45.42,0:35:46.74,English,,0,0,0,,That we're interacting with
Dialogue: 0,0:35:45.42,0:35:46.74,Chinese,,0,0,0,,我们正在互动
Dialogue: 0,0:35:47.48,0:35:52.00,English,,0,0,0,,Okay so there's a global variable called byte_cnt which is shared by all the threads
Dialogue: 0,0:35:47.48,0:35:52.00,Chinese,,0,0,0,,好的，所以有一个名为byte_cnt的全局变量，由所有线程共享
Dialogue: 0,0:35:52.56,0:35:57.04,English,,0,0,0,,And we're going to update this byte_cnt variable every time we receive
Dialogue: 0,0:35:52.56,0:35:57.04,Chinese,,0,0,0,,我们每次收到时都会更新这个byte_cnt变量
Dialogue: 0,0:35:57.86,0:36:01.34,English,,0,0,0,,Something every time we receive data from the client
Dialogue: 0,0:35:57.86,0:36:01.34,Chinese,,0,0,0,,每次我们从客户端收到数据时都会有东西
Dialogue: 0,0:36:01.96,0:36:06.24,English,,0,0,0,,And we're going to use mutex to protect the accesses to byte_cnt
Dialogue: 0,0:36:01.96,0:36:06.24,Chinese,,0,0,0,,我们将使用互斥锁来保护对byte_cnt的访问
Dialogue: 0,0:36:07.98,0:36:11.80,English,,0,0,0,,Okay so we're going to initially have to initialize
Dialogue: 0,0:36:07.98,0:36:11.80,Chinese,,0,0,0,,好的，所以我们最初要进行初始化
Dialogue: 0,0:36:13.02,0:36:15.78,English,,0,0,0,,We have to call a function that initializes
Dialogue: 0,0:36:13.02,0:36:15.78,Chinese,,0,0,0,,我们必须调用一个初始化的函数
Dialogue: 0,0:36:18.10,0:36:24.14,English,,0,0,0,,That initializes this by first initializing the mutex and then setting byte_cnt to zero
Dialogue: 0,0:36:18.10,0:36:24.14,Chinese,,0,0,0,,通过首先初始化互斥锁然后将byte_cnt设置为零来初始化它
Dialogue: 0,0:36:27.06,0:36:28.76,English,,0,0,0,,And then within echo count itself
Dialogue: 0,0:36:27.06,0:36:28.76,Chinese,,0,0,0,,然后在回声计数本身内
Dialogue: 0,0:36:35.98,0:36:39.10,English,,0,0,0,,There's...we've already seen...
Dialogue: 0,0:36:35.98,0:36:39.10,Chinese,,0,0,0,,有......我们已经看过......
Dialogue: 0,0:36:39.92,0:36:42.24,English,,0,0,0,,We've already seen a way to initialize a package
Dialogue: 0,0:36:39.92,0:36:42.24,Chinese,,0,0,0,,我们已经看到了初始化包的方法
Dialogue: 0,0:36:42.90,0:36:47.50,English,,0,0,0,,You know if we have some kind of package of library functions that are going to be used by multiple threads
Dialogue: 0,0:36:42.90,0:36:47.50,Chinese,,0,0,0,,你知道我们是否有一些将由多个线程使用的库函数包
Dialogue: 0,0:36:48.24,0:36:51.72,English,,0,0,0,,There's several ways to actually initialize this package
Dialogue: 0,0:36:48.24,0:36:51.72,Chinese,,0,0,0,,实际初始化此包有几种方法
Dialogue: 0,0:36:52.40,0:36:59.88,English,,0,0,0,,So one way is to explicitly call have the main thread call this initialization function once
Dialogue: 0,0:36:52.40,0:36:59.88,Chinese,,0,0,0,,所以一种方法是显式调用主线程调用这个初始化函数一次
Dialogue: 0,0:37:00.72,0:37:05.92,English,,0,0,0,,Okay so we've seen that with like the sbuf package right the main thread has to call
Dialogue: 0,0:37:00.72,0:37:05.92,Chinese,,0,0,0,,好的，所以我们已经看到，与sbuf包一样，主线程必须调用
Dialogue: 0,0:37:08.80,0:37:11.02,English,,0,0,0,,The main thread calls sbuf_init at once
Dialogue: 0,0:37:08.80,0:37:11.02,Chinese,,0,0,0,,主线程立即调用sbuf_init
Dialogue: 0,0:37:12.40,0:37:16.68,English,,0,0,0,,Okay before any of the peer threads execute any of the worker threads executes
Dialogue: 0,0:37:12.40,0:37:16.68,Chinese,,0,0,0,,好吧，在任何对等线程执行任何工作线程执行之前
Dialogue: 0,0:37:18.64,0:37:20.42,English,,0,0,0,,But there's another way we can do this too
Dialogue: 0,0:37:18.64,0:37:20.42,Chinese,,0,0,0,,但是我们还有另一种方法可以做到这一点
Dialogue: 0,0:37:20.42,0:37:24.86,English,,0,0,0,,We can have that the worker threads actually call the initialization function
Dialogue: 0,0:37:20.42,0:37:24.86,Chinese,,0,0,0,,我们可以让工作线程实际调用初始化函数
Dialogue: 0,0:37:26.08,0:37:30.88,English,,0,0,0,,And we can use this technique provided by pthreads
Dialogue: 0,0:37:26.08,0:37:30.88,Chinese,,0,0,0,,我们可以使用pthreads提供的这种技术
Dialogue: 0,0:37:31.94,0:37:35.28,English,,0,0,0,,Where we define a static variable
Dialogue: 0,0:37:31.94,0:37:35.28,Chinese,,0,0,0,,我们在哪里定义一个静态变量
Dialogue: 0,0:37:35.66,0:37:42.08,English,,0,0,0,,So this is a static local variable but you recall that, this is actually treated like a global variable
Dialogue: 0,0:37:35.66,0:37:42.08,Chinese,,0,0,0,,所以这是一个静态局部变量，但你还记得，这实际上被视为一个全局变量
Dialogue: 0,0:37:42.62,0:37:47.08,English,,0,0,0,,So it every thread has access to this variable
Dialogue: 0,0:37:42.62,0:37:47.08,Chinese,,0,0,0,,所以每个线程都可以访问这个变量
Dialogue: 0,0:37:48.00,0:37:53.94,English,,0,0,0,,Okay but its scope is limited to the echo_cnt function
Dialogue: 0,0:37:48.00,0:37:53.94,Chinese,,0,0,0,,好的，但它的范围仅限于echo_cnt函数
Dialogue: 0,0:37:53.96,0:37:59.16,English,,0,0,0,,So no other function connect can access this variable
Dialogue: 0,0:37:53.96,0:37:59.16,Chinese,,0,0,0,,因此没有其他函数connect可以访问此变量
Dialogue: 0,0:37:59.50,0:38:05.48,English,,0,0,0,,But each thread that executes this thread routine has access to it
Dialogue: 0,0:37:59.50,0:38:05.48,Chinese,,0,0,0,,但是，执行此线程例程的每个线程都可以访问它
Dialogue: 0,0:38:05.96,0:38:09.64,English,,0,0,0,,And in this context it's treated like a global right
Dialogue: 0,0:38:05.96,0:38:09.64,Chinese,,0,0,0,,在这种情况下，它被视为全球权利
Dialogue: 0,0:38:09.72,0:38:15.34,English,,0,0,0,,So if one thread updates the value every other every thread sees that same value
Dialogue: 0,0:38:09.72,0:38:15.34,Chinese,,0,0,0,,因此，如果一个线程更新该值，则每个线程都会看到相同的值
Dialogue: 0,0:38:16.54,0:38:21.92,English,,0,0,0,,Okay so we can use this mechanism from pthreads
Dialogue: 0,0:38:16.54,0:38:21.92,Chinese,,0,0,0,,好的，我们可以从pthreads使用这个机制
Dialogue: 0,0:38:22.76,0:38:31.42,English,,0,0,0,,But so we can create this variable of type pthread_once_t and initialize it to this special pthreads value
Dialogue: 0,0:38:22.76,0:38:31.42,Chinese,,0,0,0,,但是我们可以创建pthread_once_t类型的变量并将其初始化为这个特殊的pthreads值
Dialogue: 0,0:38:31.78,0:38:36.98,English,,0,0,0,,Which is sort of like the pthreads uninitialized value
Dialogue: 0,0:38:31.78,0:38:36.98,Chinese,,0,0,0,,这有点像pthreads未初始化的值
Dialogue: 0,0:38:37.04,0:38:41.04,English,,0,0,0,,So this is a value that pthreads knows about that indicates that
Dialogue: 0,0:38:37.04,0:38:41.04,Chinese,,0,0,0,,所以这是pthreads知道的值，表明这一点
Dialogue: 0,0:38:41.90,0:38:45.88,English,,0,0,0,,That this variable wants hasn't been initialized
Dialogue: 0,0:38:41.90,0:38:45.88,Chinese,,0,0,0,,这个变量想要的还没有被初始化
Dialogue: 0,0:38:48.20,0:38:51.98,English,,0,0,0,,And then we call the pthread once function
Dialogue: 0,0:38:48.20,0:38:51.98,Chinese,,0,0,0,,然后我们调用pthread一次函数
Dialogue: 0,0:38:52.78,0:38:58.50,English,,0,0,0,,Passing at this variable that we the address of this variable created that we created
Dialogue: 0,0:38:52.78,0:38:58.50,Chinese,,0,0,0,,传递这个变量，我们创建了这个变量的地址
Dialogue: 0,0:38:59.12,0:39:02.84,English,,0,0,0,,And the address of the function to call to initialize
Dialogue: 0,0:38:59.12,0:39:02.84,Chinese,,0,0,0,,以及调用初始化函数的地址
Dialogue: 0,0:39:04.68,0:39:07.98,English,,0,0,0,,Whatever it is we want to initialize in this case the echo_cnt
Dialogue: 0,0:39:04.68,0:39:07.98,Chinese,,0,0,0,,无论是什么，我们都希望在这种情况下初始化echo_cnt
Dialogue: 0,0:39:10.88,0:39:12.72,English,,0,0,0,,The the echo_cnt variable
Dialogue: 0,0:39:10.88,0:39:12.72,Chinese,,0,0,0,,echo_cnt变量
Dialogue: 0,0:39:14.16,0:39:18.66,English,,0,0,0,,And so what this does every thread will call Pthread_once
Dialogue: 0,0:39:14.16,0:39:18.66,Chinese,,0,0,0,,所以每个线程都会调用Pthread_once
Dialogue: 0,0:39:18.86,0:39:26.24,English,,0,0,0,,But only one thread will actually call the initialization function
Dialogue: 0,0:39:18.86,0:39:26.24,Chinese,,0,0,0,,但实际上只有一个线程会调用初始化函数
Dialogue: 0,0:39:27.68,0:39:32.66,English,,0,0,0,,Only the very first thread that executes Pthread_once will we'll call it
Dialogue: 0,0:39:27.68,0:39:32.66,Chinese,,0,0,0,,只有执行Pthread_once的第一个线程才会调用它
Dialogue: 0,0:39:32.66,0:39:37.24,English,,0,0,0,,The other threads this Pthread call will be like a no op
Dialogue: 0,0:39:32.66,0:39:37.24,Chinese,,0,0,0,,这个Pthread调用的其他线程将像一个无操作
Dialogue: 0,0:39:37.90,0:39:38.54,English,,0,0,0,,Yes question
Dialogue: 0,0:39:37.90,0:39:38.54,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:39:38.54,0:39:42.78,English,,0,0,0,,[student speaking]
Dialogue: 0,0:39:42.80,0:39:43.88,English,,0,0,0,,Well that's the other option
Dialogue: 0,0:39:42.80,0:39:43.88,Chinese,,0,0,0,,那是另一种选择
Dialogue: 0,0:39:44.66,0:39:47.88,English,,0,0,0,,So the advantage of this is that
Dialogue: 0,0:39:44.66,0:39:47.88,Chinese,,0,0,0,,所以这样做的好处就是
Dialogue: 0,0:39:50.46,0:39:57.06,English,,0,0,0,,You can...I guess the advantage is I don't know that it's just another way you can do it
Dialogue: 0,0:39:50.46,0:39:57.06,Chinese,,0,0,0,,你可以......我猜我的优点是我不知道这只是你能做到的另一种方式
Dialogue: 0,0:39:58.64,0:40:02.96,English,,0,0,0,,You...I guess it avoids having to do it in the master thread that
Dialogue: 0,0:39:58.64,0:40:02.96,Chinese,,0,0,0,,你...我想它避免了必须在主线程中这样做
Dialogue: 0,0:40:03.20,0:40:08.24,English,,0,0,0,,You can make your...you can make this package sort of self-contained right that
Dialogue: 0,0:40:03.20,0:40:08.24,Chinese,,0,0,0,,你可以让你...你可以使这个包装成为一种独立的权利
Dialogue: 0,0:40:08.50,0:40:11.20,English,,0,0,0,,You're not really counting on the master doing anything
Dialogue: 0,0:40:08.50,0:40:11.20,Chinese,,0,0,0,,你并不是指望主人做任何事情
Dialogue: 0,0:40:12.54,0:40:17.94,English,,0,0,0,,But yeah that's the other way we could have done it so I just wanted to show you this other technique
Dialogue: 0,0:40:12.54,0:40:17.94,Chinese,,0,0,0,,但是，这是我们可以做到的另一种方式所以我只想向你展示这种其他技术
Dialogue: 0,0:40:19.62,0:40:24.26,English,,0,0,0,,Okay so once we initialize...once we once
Dialogue: 0,0:40:19.62,0:40:24.26,Chinese,,0,0,0,,好的，一旦我们初始化......一旦我们一次
Dialogue: 0,0:40:24.50,0:40:26.14,English,,0,0,0,,Some thread calls the init_echo_cnt
Dialogue: 0,0:40:24.50,0:40:26.14,Chinese,,0,0,0,,一些线程调用init_echo_cnt
Dialogue: 0,0:40:28.46,0:40:30.26,English,,0,0,0,,Then we initialize the Rio package
Dialogue: 0,0:40:28.46,0:40:30.26,Chinese,,0,0,0,,然后我们初始化Rio包
Dialogue: 0,0:40:32.00,0:40:34.98,English,,0,0,0,,For all of our accesses on this connected descriptor
Dialogue: 0,0:40:32.00,0:40:34.98,Chinese,,0,0,0,,对于此连接描述符的所有访问
Dialogue: 0,0:40:36.42,0:40:40.48,English,,0,0,0,,And then we repeatedly read a line of text from the client
Dialogue: 0,0:40:36.42,0:40:40.48,Chinese,,0,0,0,,然后我们反复阅读客户端的一行文本
Dialogue: 0,0:40:42.26,0:40:44.22,English,,0,0,0,,Okay and then
Dialogue: 0,0:40:42.26,0:40:44.22,Chinese,,0,0,0,,好的，然后
Dialogue: 0,0:40:45.78,0:40:50.48,English,,0,0,0,,In a protected way we increment byte_cnt with the number of bytes that
Dialogue: 0,0:40:45.78,0:40:50.48,Chinese,,0,0,0,,在受保护的方式中，我们使用字节数递增byte_cnt
Dialogue: 0,0:40:50.54,0:40:56.28,English,,0,0,0,,We received  from the client which is returned by this rio read line b function
Dialogue: 0,0:40:50.54,0:40:56.28,Chinese,,0,0,0,,我们从客户端收到了这个rio读取行b函数返回的内容
Dialogue: 0,0:40:57.68,0:41:00.90,English,,0,0,0,,And then we print a little message just to sort of keep track
Dialogue: 0,0:40:57.68,0:41:00.90,Chinese,,0,0,0,,然后我们打印一条消息，只是为了跟踪
Dialogue: 0,0:41:01.04,0:41:04.40,English,,0,0,0,,So we can see keep track of our running total
Dialogue: 0,0:41:01.04,0:41:04.40,Chinese,,0,0,0,,所以我们可以看到跟踪我们的运行总量
Dialogue: 0,0:41:04.98,0:41:09.42,English,,0,0,0,,And then we release the mutex on this on the byte_cnt the global byte_cnt variable
Dialogue: 0,0:41:04.98,0:41:09.42,Chinese,,0,0,0,,然后我们在byte_cnt全局byte_cnt变量上释放互斥锁
Dialogue: 0,0:41:09.74,0:41:12.46,English,,0,0,0,,And then we echo that line back to the client
Dialogue: 0,0:41:09.74,0:41:12.46,Chinese,,0,0,0,,然后我们将该行回传给客户端
Dialogue: 0,0:41:15.54,0:41:16.62,English,,0,0,0,,Okay so any questions about that
Dialogue: 0,0:41:15.54,0:41:16.62,Chinese,,0,0,0,,好的，所以对此有任何疑问
Dialogue: 0,0:41:18.00,0:41:18.62,English,,0,0,0,,Yes question
Dialogue: 0,0:41:18.00,0:41:18.62,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:41:18.62,0:41:28.26,English,,0,0,0,,[student speaking]
Dialogue: 0,0:41:28.28,0:41:33.16,English,,0,0,0,,Okay the question is the line that declares the static variable
Dialogue: 0,0:41:28.28,0:41:33.16,Chinese,,0,0,0,,好的问题是声明静态变量的行
Dialogue: 0,0:41:33.92,0:41:37.08,English,,0,0,0,,Once will it only be executed the first time
Dialogue: 0,0:41:33.92,0:41:37.08,Chinese,,0,0,0,,一旦它将只在第一次执行
Dialogue: 0,0:41:38.08,0:41:41.44,English,,0,0,0,,A thread executes that statement
Dialogue: 0,0:41:38.08,0:41:41.44,Chinese,,0,0,0,,线程执行该语句
Dialogue: 0,0:41:41.84,0:41:46.62,English,,0,0,0,,No it's so the answer is no every thread will define this variable
Dialogue: 0,0:41:41.84,0:41:46.62,Chinese,,0,0,0,,不，所以答案是没有每个线程都会定义这个变量
Dialogue: 0,0:41:47.00,0:41:53.28,English,,0,0,0,,And assign it this to this pthread once value
Dialogue: 0,0:41:47.00,0:41:53.28,Chinese,,0,0,0,,并将其分配给此pthread一次值
Dialogue: 0,0:41:53.94,0:41:58.66,English,,0,0,0,,Okay what will only happen once is the call to a init_echo_cnt
Dialogue: 0,0:41:53.94,0:41:58.66,Chinese,,0,0,0,,好的，只有一次调用init_echo_cnt才会发生
Dialogue: 0,0:41:59.42,0:42:05.36,English,,0,0,0,,Okay so the first thread that executes this Pthread_once call
Dialogue: 0,0:41:59.42,0:42:05.36,Chinese,,0,0,0,,好的，这是执行此Pthread_once调用的第一个线程
Dialogue: 0,0:42:05.92,0:42:08.20,English,,0,0,0,,Will actually call an init_echo_cnt
Dialogue: 0,0:42:05.92,0:42:08.20,Chinese,,0,0,0,,实际上会调用init_echo_cnt
Dialogue: 0,0:42:09.44,0:42:13.58,English,,0,0,0,,Every other thread every subsequent thread will not call it it'll be like a no op
Dialogue: 0,0:42:09.44,0:42:13.58,Chinese,,0,0,0,,每个后续线程的每个其他线程都不会调用它，它将像一个无操作
Dialogue: 0,0:42:14.84,0:42:18.54,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:18.54,0:42:20.80,English,,0,0,0,,Yeah uses the ones it's just an opaque
Dialogue: 0,0:42:18.54,0:42:20.80,Chinese,,0,0,0,,是啊使用它只是一个不透明的
Dialogue: 0,0:42:20.86,0:42:33.44,English,,0,0,0,,[student speaking]
Dialogue: 0,0:42:33.46,0:42:39.54,English,,0,0,0,,Yeah somehow it will but somehow the pthread wants is keeping track that it's executed
Dialogue: 0,0:42:33.46,0:42:39.54,Chinese,,0,0,0,,是的，它会以某种方式，但pthread想要的是跟踪它的执行情况
Dialogue: 0,0:42:41.60,0:42:44.58,English,,0,0,0,,Okay so I I'm really not sure how its implemented
Dialogue: 0,0:42:41.60,0:42:44.58,Chinese,,0,0,0,,好的，所以我真的不确定它是如何实现的
Dialogue: 0,0:42:45.18,0:42:48.54,English,,0,0,0,,Okay so somehow Pthread_once
Dialogue: 0,0:42:45.18,0:42:48.54,Chinese,,0,0,0,,好吧，不知怎的，Pthread_once
Dialogue: 0,0:42:49.64,0:42:51.12,English,,0,0,0,,Yeah I guess every you know this
Dialogue: 0,0:42:49.64,0:42:51.12,Chinese,,0,0,0,,是的我猜你们都知道这一点
Dialogue: 0,0:42:52.02,0:42:54.70,English,,0,0,0,,I mean this is just the C declaration right so there's no
Dialogue: 0,0:42:52.02,0:42:54.70,Chinese,,0,0,0,,我的意思是这只是C声明，所以没有
Dialogue: 0,0:42:55.14,0:42:59.00,English,,0,0,0,,The pthreads has no control over declarations right
Dialogue: 0,0:42:55.14,0:42:59.00,Chinese,,0,0,0,,pthreads无法控制声明权
Dialogue: 0,0:42:59.54,0:43:06.92,English,,0,0,0,,So every thread will get...every thread will sort of update this static variable
Dialogue: 0,0:42:59.54,0:43:06.92,Chinese,,0,0,0,,所以每个线程都会得到......每个线程都会更新这个静态变量
Dialogue: 0,0:43:08.72,0:43:10.76,English,,0,0,0,,And you're wright if the first thread
Dialogue: 0,0:43:08.72,0:43:10.76,Chinese,,0,0,0,,如果第一个线程，你就是正确的
Dialogue: 0,0:43:14.68,0:43:18.18,English,,0,0,0,,The second thread would overwrite this value again
Dialogue: 0,0:43:14.68,0:43:18.18,Chinese,,0,0,0,,第二个线程将再次覆盖此值
Dialogue: 0,0:43:19.02,0:43:23.50,English,,0,0,0,,But somehow Pthread_once can keeps track of that
Dialogue: 0,0:43:19.02,0:43:23.50,Chinese,,0,0,0,,但不知何故，Pthread_once可以跟踪它
Dialogue: 0,0:43:23.74,0:43:27.10,English,,0,0,0,,Okay in some way that I'm not sure about how that works
Dialogue: 0,0:43:23.74,0:43:27.10,Chinese,,0,0,0,,好吧，在某种程度上，我不确定它是如何工作的
Dialogue: 0,0:43:28.56,0:43:31.62,English,,0,0,0,,But this is the way you get that behavior
Dialogue: 0,0:43:28.56,0:43:31.62,Chinese,,0,0,0,,但这就是你获得这种行为的方式
Dialogue: 0,0:43:36.84,0:43:43.44,English,,0,0,0,,Can others there's some other issues around synchronizing threads sort of correctness issues that we have to be aware of
Dialogue: 0,0:43:36.84,0:43:43.44,Chinese,,0,0,0,,其他人可以围绕同步线程来解决我们必须注意的正确性问题
Dialogue: 0,0:43:45.66,0:43:51.56,English,,0,0,0,,And so I hope you're sort of getting the sense that this threaded programming is kind of a tricky business right
Dialogue: 0,0:43:45.66,0:43:51.56,Chinese,,0,0,0,,因此，我希望你能够理解这种线程编程是一项棘手的业务
Dialogue: 0,0:43:52.36,0:43:57.50,English,,0,0,0,,And so one issue that we always have to be aware of is this idea called thread safety
Dialogue: 0,0:43:52.36,0:43:57.50,Chinese,,0,0,0,,因此，我们始终需要注意的一个问题就是称为线程安全
Dialogue: 0,0:43:58.68,0:44:06.30,English,,0,0,0,,So in general a thread routine should only call functions that are thread safe
Dialogue: 0,0:43:58.68,0:44:06.30,Chinese,,0,0,0,,所以通常一个线程例程应该只调用线程安全的函数
Dialogue: 0,0:44:06.76,0:44:08.66,English,,0,0,0,,That have this property called thread safety
Dialogue: 0,0:44:06.76,0:44:08.66,Chinese,,0,0,0,,这个属性叫做线程安全
Dialogue: 0,0:44:09.74,0:44:11.90,English,,0,0,0,,Okay and a function is thread safe
Dialogue: 0,0:44:09.74,0:44:11.90,Chinese,,0,0,0,,好的，函数是线程安全的
Dialogue: 0,0:44:13.00,0:44:18.76,English,,0,0,0,,If and only if that function can be invoked by multiple threads at the same time
Dialogue: 0,0:44:13.00,0:44:18.76,Chinese,,0,0,0,,当且仅当多个线程可以同时调用该函数时
Dialogue: 0,0:44:19.76,0:44:22.20,English,,0,0,0,,Okay so if we have a function f
Dialogue: 0,0:44:19.76,0:44:22.20,Chinese,,0,0,0,,好的，如果我们有一个函数f
Dialogue: 0,0:44:24.42,0:44:29.10,English,,0,0,0,,Its thread safe if and only if its execution can be interleaved by multiple threads
Dialogue: 0,0:44:24.42,0:44:29.10,Chinese,,0,0,0,,当且仅当其执行可由多个线程交错时，其线程安全
Dialogue: 0,0:44:34.70,0:44:38.96,English,,0,0,0,,And so we can identify a four different classes of thread-unsafe functions
Dialogue: 0,0:44:34.70,0:44:38.96,Chinese,,0,0,0,,因此我们可以识别出四种不同类型的线程不安全函数
Dialogue: 0,0:44:39.86,0:44:46.06,English,,0,0,0,,So one classes is the functions that fail to protect shared variables with mutexes
Dialogue: 0,0:44:39.86,0:44:46.06,Chinese,,0,0,0,,因此，一个类是无法使用互斥锁保护共享变量的函数
Dialogue: 0,0:44:48.22,0:44:50.06,English,,0,0,0,,Okay so we've already seen that with bad count
Dialogue: 0,0:44:48.22,0:44:50.06,Chinese,,0,0,0,,好的，所以我们已经看到了糟糕的数字
Dialogue: 0,0:44:50.66,0:44:56.06,English,,0,0,0,,That was an example of a thread-unsafe that main routine was an example of an unsafe thread function
Dialogue: 0,0:44:50.66,0:44:56.06,Chinese,,0,0,0,,这是一个线程不安全的例子，主例程是一个不安全的线程函数的例子
Dialogue: 0,0:44:58.66,0:45:02.14,English,,0,0,0,,Or no the thread function was an example of an unsafe thread function
Dialogue: 0,0:44:58.66,0:45:02.14,Chinese,,0,0,0,,或者没有线程函数是不安全线程函数的示例
Dialogue: 0,0:45:02.40,0:45:06.24,English,,0,0,0,,Because it didn't protect the act the update of the count variable
Dialogue: 0,0:45:02.40,0:45:06.24,Chinese,,0,0,0,,因为它没有保护计数变量的更新
Dialogue: 0,0:45:09.04,0:45:16.90,English,,0,0,0,,Another class of functions that a thread-unsafe is are those functions that keep track of state across multiple invocations
Dialogue: 0,0:45:09.04,0:45:16.90,Chinese,,0,0,0,,线程不安全的另一类函数是那些在多个调用中跟踪状态的函数
Dialogue: 0,0:45:17.74,0:45:26.14,English,,0,0,0,,So if they're storing state in some global variable,private or public global variable, that's thread unsafe
Dialogue: 0,0:45:17.74,0:45:26.14,Chinese,,0,0,0,,因此，如果他们将状态存储在某个全局变量，私有或公共全局变量中，则该线程不安全
Dialogue: 0,0:45:26.80,0:45:30.94,English,,0,0,0,,Because multiple threads will be accessing that state
Dialogue: 0,0:45:26.80,0:45:30.94,Chinese,,0,0,0,,因为多个线程将访问该状态
Dialogue: 0,0:45:33.44,0:45:38.74,English,,0,0,0,,Another way,another kind of thread-unsafe function or functions that return a pointer to a static variable
Dialogue: 0,0:45:33.44,0:45:38.74,Chinese,,0,0,0,,另一种方式，另一种线程不安全的函数或返回指向静态变量的指针的函数
Dialogue: 0,0:45:40.22,0:45:43.34,English,,0,0,0,,So there's a number of functions in the standard C library
Dialogue: 0,0:45:40.22,0:45:43.34,Chinese,,0,0,0,,因此标准C库中有许多功能
Dialogue: 0,0:45:44.04,0:45:47.52,English,,0,0,0,,That were written before threads or even on anybody's radar
Dialogue: 0,0:45:44.04,0:45:47.52,Chinese,,0,0,0,,这是在线程之前写的，甚至是在任何人的雷达上
Dialogue: 0,0:45:48.86,0:45:53.06,English,,0,0,0,,And so an example is the C time function
Dialogue: 0,0:45:48.86,0:45:53.06,Chinese,,0,0,0,,所以一个例子是C时间函数
Dialogue: 0,0:45:53.82,0:45:57.94,English,,0,0,0,,Which takes as an argument a time struct,a binary time struct
Dialogue: 0,0:45:53.82,0:45:57.94,Chinese,,0,0,0,,它将时间结构，二进制时间结构作为参数
Dialogue: 0,0:45:58.92,0:46:02.52,English,,0,0,0,,And returns a pointer to a string date and time string
Dialogue: 0,0:45:58.92,0:46:02.52,Chinese,,0,0,0,,并返回指向字符串日期和时间字符串的指针
Dialogue: 0,0:46:04.18,0:46:07.46,English,,0,0,0,,But the address in that pointer is always the same
Dialogue: 0,0:46:04.18,0:46:07.46,Chinese,,0,0,0,,但该指针中的地址始终相同
Dialogue: 0,0:46:07.62,0:46:11.52,English,,0,0,0,,Right so the this function is defining some kind of static variable
Dialogue: 0,0:46:07.62,0:46:11.52,Chinese,,0,0,0,,对，所以这个函数定义了某种静态变量
Dialogue: 0,0:46:12.48,0:46:18.00,English,,0,0,0,,And it's always returned and then it's converting that the binary time struct
Dialogue: 0,0:46:12.48,0:46:18.00,Chinese,,0,0,0,,它总是返回，然后它转换二进制时间结构
Dialogue: 0,0:46:18.94,0:46:24.22,English,,0,0,0,,Into a string that's always at the same location and it's returning the address of that string
Dialogue: 0,0:46:18.94,0:46:24.22,Chinese,,0,0,0,,进入一个始终位于同一位置的字符串，并返回该字符串的地址
Dialogue: 0,0:46:24.86,0:46:27.64,English,,0,0,0,,So every invocation returns the exact same address
Dialogue: 0,0:46:24.86,0:46:27.64,Chinese,,0,0,0,,所以每次调用都返回完全相同的地址
Dialogue: 0,0:46:28.52,0:46:30.74,English,,0,0,0,,But with different content at that address
Dialogue: 0,0:46:28.52,0:46:30.74,Chinese,,0,0,0,,但是在该地址有不同的内容
Dialogue: 0,0:46:31.76,0:46:36.46,English,,0,0,0,,Okay and this...you know they just...they didn't realize that this was a bad thing to do
Dialogue: 0,0:46:31.76,0:46:36.46,Chinese,,0,0,0,,好的，这......你知道他们只是......他们没有意识到这是件坏事
Dialogue: 0,0:46:36.72,0:46:40.66,English,,0,0,0,,For threaded programs because nobody was writing threaded programs at the time
Dialogue: 0,0:46:36.72,0:46:40.66,Chinese,,0,0,0,,对于线程程序，因为当时没有人编写线程程序
Dialogue: 0,0:46:42.26,0:46:46.82,English,,0,0,0,,And then obviously any function that calls and thread-unsafe function is threat unsafe
Dialogue: 0,0:46:42.26,0:46:46.82,Chinese,,0,0,0,,然后显然任何调用和线程不安全功能的函数都是威胁不安全的
Dialogue: 0,0:46:47.94,0:46:51.50,English,,0,0,0,,Okay so let's look at these different classes of functions
Dialogue: 0,0:46:47.94,0:46:51.50,Chinese,,0,0,0,,好的，让我们来看看这些不同类别的功能
Dialogue: 0,0:46:52.14,0:46:56.32,English,,0,0,0,,Okay so the class one functions fail to protect shared variables
Dialogue: 0,0:46:52.14,0:46:56.32,Chinese,,0,0,0,,好的，所以第一类功能无法保护共享变量
Dialogue: 0,0:46:57.18,0:47:04.90,English,,0,0,0,,And so the fix as we've seen is to use P and V to guarantee mutually exclusive access and thereby protect the accesses to the variable
Dialogue: 0,0:46:57.18,0:47:04.90,Chinese,,0,0,0,,因此，我们所看到的修复是使用P和V来保证互斥访问，从而保护对变量的访问
Dialogue: 0,0:47:05.02,0:47:07.56,English,,0,0,0,,So we saw this with that good count program
Dialogue: 0,0:47:05.02,0:47:07.56,Chinese,,0,0,0,,所以我们用好的计数程序看到了这个
Dialogue: 0,0:47:08.50,0:47:14.18,English,,0,0,0,,And then the problem is it also as we saw with goodcnt is that the synchronization operations can be slow
Dialogue: 0,0:47:08.50,0:47:14.18,Chinese,,0,0,0,,然后问题是，正如我们在goodcnt中看到的那样，同步操作可能很慢
Dialogue: 0,0:47:14.20,0:47:15.75,English,,0,0,0,,So if they're in a tight inner loop
Dialogue: 0,0:47:14.20,0:47:15.75,Chinese,,0,0,0,,所以，如果他们处于紧密的内循环中
Dialogue: 0,0:47:16.38,0:47:18.68,English,,0,0,0,,It can really slow your program down
Dialogue: 0,0:47:16.38,0:47:18.68,Chinese,,0,0,0,,它可以真正减慢你的程序
Dialogue: 0,0:47:21.42,0:47:25.32,English,,0,0,0,,Okay the class 2 thread-unsafe functions rely on
Dialogue: 0,0:47:21.42,0:47:25.32,Chinese,,0,0,0,,好吧，2级线程不安全的函数依赖于
Dialogue: 0,0:47:25.66,0:47:29.56,English,,0,0,0,,Some kind of persistent state across invocations of that function
Dialogue: 0,0:47:25.66,0:47:29.56,Chinese,,0,0,0,,跨该函数调用的某种持久状态
Dialogue: 0,0:47:30.32,0:47:35.28,English,,0,0,0,,Okay so the classic example is the lib.c rand function
Dialogue: 0,0:47:30.32,0:47:35.28,Chinese,,0,0,0,,好吧，经典的例子是lib.c rand函数
Dialogue: 0,0:47:36.54,0:47:43.68,English,,0,0,0,,Whose in an implementation of which is I took from the k in our book
Dialogue: 0,0:47:36.54,0:47:43.68,Chinese,,0,0,0,,在我的书中，我从k中获取了谁的实现
Dialogue: 0,0:47:45.82,0:47:52.36,English,,0,0,0,,So this rand,this is a pseudo-random number generator
Dialogue: 0,0:47:45.82,0:47:52.36,Chinese,,0,0,0,,所以这个兰特，这是一个伪随机数发生器
Dialogue: 0,0:47:53.22,0:47:55.32,English,,0,0,0,,A pseudo random in the sense that
Dialogue: 0,0:47:53.22,0:47:55.32,Chinese,,0,0,0,,在某种意义上的伪随机
Dialogue: 0,0:47:56.08,0:48:00.84,English,,0,0,0,,If you give it the same key it'll return the same sequence of values okay
Dialogue: 0,0:47:56.08,0:48:00.84,Chinese,,0,0,0,,如果你给它相同的键，它将返回相同的值序列
Dialogue: 0,0:48:01.60,0:48:06.60,English,,0,0,0,,So this is kind of nice because it allows when you're testing it allows repeatability
Dialogue: 0,0:48:01.60,0:48:06.60,Chinese,,0,0,0,,所以这很好，因为它允许在你测试它时允许重复性
Dialogue: 0,0:48:07.38,0:48:12.22,English,,0,0,0,,So every time you call it,if you call it with the same seed you're guaranteed you'll get the same results
Dialogue: 0,0:48:07.38,0:48:12.22,Chinese,,0,0,0,,因此，每当你打电话给它时，如果你用相同的种子调用它，你将保证得到相同的结果
Dialogue: 0,0:48:13.48,0:48:14.86,English,,0,0,0,,And the way this is implemented
Dialogue: 0,0:48:13.48,0:48:14.86,Chinese,,0,0,0,,以及实施方式
Dialogue: 0,0:48:16.92,0:48:19.66,English,,0,0,0,,Is that there's at the seed
Dialogue: 0,0:48:16.92,0:48:19.66,Chinese,,0,0,0,,这就是种子吗？
Dialogue: 0,0:48:22.40,0:48:24.90,English,,0,0,0,,There's a seed variable called next
Dialogue: 0,0:48:22.40,0:48:24.90,Chinese,,0,0,0,,有一个名为next的种子变量
Dialogue: 0,0:48:25.44,0:48:28.60,English,,0,0,0,,Which is used in each iteration of the random number generator
Dialogue: 0,0:48:25.44,0:48:28.60,Chinese,,0,0,0,,在随机数生成器的每次迭代中使用哪个
Dialogue: 0,0:48:28.68,0:48:33.82,English,,0,0,0,,And it's defined as a global private
Dialogue: 0,0:48:28.68,0:48:33.82,Chinese,,0,0,0,,它被定义为全球私人
Dialogue: 0,0:48:33.96,0:48:38.58,English,,0,0,0,,So static makes it private,so it's not accessible to programs that are calling
Dialogue: 0,0:48:33.96,0:48:38.58,Chinese,,0,0,0,,因此静态使其成为私有的，因此调用的程序无法访问它
Dialogue: 0,0:48:39.22,0:48:42.92,English,,0,0,0,,The rand function but it's used by the rand function
Dialogue: 0,0:48:39.22,0:48:42.92,Chinese,,0,0,0,,rand函数但它由rand函数使用
Dialogue: 0,0:48:43.70,0:48:45.94,English,,0,0,0,,And so this variable is initialized to 1
Dialogue: 0,0:48:43.70,0:48:45.94,Chinese,,0,0,0,,所以这个变量初始化为1
Dialogue: 0,0:48:48.20,0:48:52.76,English,,0,0,0,,There's a function called srand which allows the user to set the seed value
Dialogue: 0,0:48:48.20,0:48:52.76,Chinese,,0,0,0,,有一个名为srand的函数允许用户设置种子值
Dialogue: 0,0:48:52.82,0:48:55.64,English,,0,0,0,,So the default seed value is 1
Dialogue: 0,0:48:52.82,0:48:55.64,Chinese,,0,0,0,,因此默认种子值为1
Dialogue: 0,0:48:56.48,0:48:59.48,English,,0,0,0,,But if the user calls srand they can pass in a seed
Dialogue: 0,0:48:56.48,0:48:59.48,Chinese,,0,0,0,,但是如果用户调用srand，他们可以传入种子
Dialogue: 0,0:48:59.86,0:49:05.34,English,,0,0,0,,Which will be then...which will be...which is just would assign to this next variable
Dialogue: 0,0:48:59.86,0:49:05.34,Chinese,,0,0,0,,那将是...将是......这将分配给下一个变量
Dialogue: 0,0:49:06.78,0:49:08.58,English,,0,0,0,,And then each iteration of rand
Dialogue: 0,0:49:06.78,0:49:08.58,Chinese,,0,0,0,,然后是rand的每次迭代
Dialogue: 0,0:49:10.48,0:49:12.52,English,,0,0,0,,And does an operation on the seed
Dialogue: 0,0:49:10.48,0:49:12.52,Chinese,,0,0,0,,并对种子进行操作
Dialogue: 0,0:49:13.50,0:49:21.54,English,,0,0,0,,So it takes that the next value that's going to be used is a property of the previous value,the function of the previous value
Dialogue: 0,0:49:13.50,0:49:21.54,Chinese,,0,0,0,,因此，将要使用的下一个值是前一个值的属性，即前一个值的函数
Dialogue: 0,0:49:22.58,0:49:24.74,English,,0,0,0,,And then it returns a pseudo-random number
Dialogue: 0,0:49:22.58,0:49:24.74,Chinese,,0,0,0,,然后它返回一个伪随机数
Dialogue: 0,0:49:25.08,0:49:26.88,English,,0,0,0,,That's a function of that next value
Dialogue: 0,0:49:25.08,0:49:26.88,Chinese,,0,0,0,,这是下一个值的函数
Dialogue: 0,0:49:28.60,0:49:32.74,English,,0,0,0,,Okay so it's relying on this each iteration each time you call rand
Dialogue: 0,0:49:28.60,0:49:32.74,Chinese,,0,0,0,,好的，所以每次调用rand时都依赖于每次迭代
Dialogue: 0,0:49:33.16,0:49:39.48,English,,0,0,0,,You're relying on the this next value that was computed by the previous time that you called rand
Dialogue: 0,0:49:33.16,0:49:39.48,Chinese,,0,0,0,,你依赖于上一次调用rand计算的下一个值
Dialogue: 0,0:49:41.28,0:49:44.30,English,,0,0,0,,Okay now this is perfectly fine and there's no problem with this
Dialogue: 0,0:49:41.28,0:49:44.30,Chinese,,0,0,0,,好的，现在这很好，这没问题
Dialogue: 0,0:49:44.70,0:49:47.46,English,,0,0,0,,In a non-threaded situation
Dialogue: 0,0:49:44.70,0:49:47.46,Chinese,,0,0,0,,在非线程的情况下
Dialogue: 0,0:49:48.26,0:49:50.56,English,,0,0,0,,But what happens if multiple threads now
Dialogue: 0,0:49:48.26,0:49:50.56,Chinese,,0,0,0,,但是如果现在多线程会发生什么
Dialogue: 0,0:49:51.44,0:49:53.06,English,,0,0,0,,So suppose you have multiple threads
Dialogue: 0,0:49:51.44,0:49:53.06,Chinese,,0,0,0,,所以假设你有多个线程
Dialogue: 0,0:49:54.06,0:50:01.08,English,,0,0,0,,And they're each calling this rand function sort of interleaving calls to rand
Dialogue: 0,0:49:54.06,0:50:01.08,Chinese,,0,0,0,,并且他们每个人都调用这个rand函数来对rand进行交错调用
Dialogue: 0,0:50:02.52,0:50:07.94,English,,0,0,0,,Okay the fact that rand is relying on the this previous state
Dialogue: 0,0:50:02.52,0:50:07.94,Chinese,,0,0,0,,好吧，兰德依赖于此前的状态
Dialogue: 0,0:50:10.40,0:50:14.26,English,,0,0,0,,If multiple threads are calling rand it's going to break the pseudo-random property
Dialogue: 0,0:50:10.40,0:50:14.26,Chinese,,0,0,0,,如果多个线程正在调用rand，那么它将破坏伪随机属性
Dialogue: 0,0:50:14.58,0:50:19.78,English,,0,0,0,,So each thread that the random numbers that each thread gets back
Dialogue: 0,0:50:14.58,0:50:19.78,Chinese,,0,0,0,,所以每个线程都是每个线程得到的随机数
Dialogue: 0,0:50:19.78,0:50:26.04,English,,0,0,0,,Are not only a function of the previous the seed from the previous time that thread called the function
Dialogue: 0,0:50:19.78,0:50:26.04,Chinese,,0,0,0,,不仅是上一次该种子线程调用函数的前一个种子的函数
Dialogue: 0,0:50:26.04,0:50:31.98,English,,0,0,0,,But also a function of the other threads that are calling it right
Dialogue: 0,0:50:26.04,0:50:31.98,Chinese,,0,0,0,,但也是正确调用其他线程的函数
Dialogue: 0,0:50:32.90,0:50:38.40,English,,0,0,0,,So if a particular thread calls this random number generator multiple times
Dialogue: 0,0:50:32.90,0:50:38.40,Chinese,,0,0,0,,因此，如果特定线程多次调用此随机数生成器
Dialogue: 0,0:50:39.28,0:50:44.72,English,,0,0,0,,It potentially won't see the same sequence of pseudo-random numbers because other threads will be jumping in
Dialogue: 0,0:50:39.28,0:50:44.72,Chinese,,0,0,0,,它可能不会看到相同的伪随机数序列，因为其他线程将跳入
Dialogue: 0,0:50:45.42,0:50:46.78,English,,0,0,0,,Okay and
Dialogue: 0,0:50:45.42,0:50:46.78,Chinese,,0,0,0,,好的
Dialogue: 0,0:50:48.88,0:50:55.08,English,,0,0,0,,Okay so it's not incorrect and that the program will fail
Dialogue: 0,0:50:48.88,0:50:55.08,Chinese,,0,0,0,,好的，所以这不是错误的，程序会失败
Dialogue: 0,0:50:55.34,0:51:01.22,English,,0,0,0,,But if the program is counting on the pseudo random property then it creates a problem okay
Dialogue: 0,0:50:55.34,0:51:01.22,Chinese,,0,0,0,,但是如果程序指望伪随机属性，那么它就会产生问题
Dialogue: 0,0:51:02.66,0:51:07.66,English,,0,0,0,,So the solution to this is to rewrite rand
Dialogue: 0,0:51:02.66,0:51:07.66,Chinese,,0,0,0,,所以解决这个问题的方法是重写rand
Dialogue: 0,0:51:08.80,0:51:15.16,English,,0,0,0,,And require it to require the caller to keep track of this next variable
Dialogue: 0,0:51:08.80,0:51:15.16,Chinese,,0,0,0,,并要求它要求调用者跟踪下一个变量
Dialogue: 0,0:51:15.70,0:51:21.68,English,,0,0,0,,Okay so each caller will keep its own local copy of next and it will pass in a pointer to rand
Dialogue: 0,0:51:15.70,0:51:21.68,Chinese,,0,0,0,,好的，所以每个调用者都会保留自己的next的本地副本，它会传入指向rand的指针
Dialogue: 0,0:51:22.84,0:51:28.28,English,,0,0,0,,rand we'll compute that value so now this will be updating state in the calling thread
Dialogue: 0,0:51:22.84,0:51:28.28,Chinese,,0,0,0,,rand我们将计算该值，所以现在这将更新调用线程中的状态
Dialogue: 0,0:51:28.30,0:51:32.66,English,,0,0,0,,But this is local state on the thread stack okay
Dialogue: 0,0:51:28.30,0:51:32.66,Chinese,,0,0,0,,但这是线程堆栈上的本地状态没关系
Dialogue: 0,0:51:32.82,0:51:37.16,English,,0,0,0,,So every thread will have its own copy of next
Dialogue: 0,0:51:32.82,0:51:37.16,Chinese,,0,0,0,,所以每个线程都有自己的下一个副本
Dialogue: 0,0:51:40.14,0:51:44.32,English,,0,0,0,,So we...but we have to create a new function and what we'll call it underscore r
Dialogue: 0,0:51:40.14,0:51:44.32,Chinese,,0,0,0,,所以我们......但我们必须创建一个新函数，我们称之为下划线r
Dialogue: 0,0:51:44.76,0:51:48.54,English,,0,0,0,,The stands for reentrant which is a property we'll look at in just a second
Dialogue: 0,0:51:44.76,0:51:48.54,Chinese,,0,0,0,,重入的代表，这是我们将在一秒钟内看到的属性
Dialogue: 0,0:51:50.56,0:51:54.06,English,,0,0,0,,But it's more work for the programmer because now the programmer has to maintain this
Dialogue: 0,0:51:50.56,0:51:54.06,Chinese,,0,0,0,,但对于程序员来说，这是更多的工作，因为现在程序员必须保持这一点
Dialogue: 0,0:51:54.76,0:51:58.10,English,,0,0,0,,This sort of this next value okay
Dialogue: 0,0:51:54.76,0:51:58.10,Chinese,,0,0,0,,这种下一个价值还可以
Dialogue: 0,0:52:01.68,0:52:05.08,English,,0,0,0,,Okay another way that threads the functions are unsafe
Dialogue: 0,0:52:01.68,0:52:05.08,Chinese,,0,0,0,,好的另一种方法是线程化函数是不安全的
Dialogue: 0,0:52:06.08,0:52:14.52,English,,0,0,0,,are these functions that always retain a return a pointer(to some global) to the same global variable
Dialogue: 0,0:52:06.08,0:52:14.52,Chinese,,0,0,0,,这些函数总是保留一个指针（对某些全局）返回同一个全局变量
Dialogue: 0,0:52:15.02,0:52:17.18,English,,0,0,0,,Typically it's a static variable
Dialogue: 0,0:52:15.02,0:52:17.18,Chinese,,0,0,0,,通常它是一个静态变量
Dialogue: 0,0:52:17.60,0:52:22.36,English,,0,0,0,,But they always return the same value each time the same address
Dialogue: 0,0:52:17.60,0:52:22.36,Chinese,,0,0,0,,但是每次相同的地址时它们总是返回相同的值
Dialogue: 0,0:52:24.36,0:52:27.90,English,,0,0,0,,Okay so you can see this is similar to that race that we encountered before
Dialogue: 0,0:52:24.36,0:52:27.90,Chinese,,0,0,0,,好的，你可以看到这与我们之前遇到过的种族相似
Dialogue: 0,0:52:28.20,0:52:32.64,English,,0,0,0,,Where we were passing the address of a connected file descriptor to a worker thread
Dialogue: 0,0:52:28.20,0:52:32.64,Chinese,,0,0,0,,我们将连接文件描述符的地址传递给工作线程的位置
Dialogue: 0,0:52:34.50,0:52:36.90,English,,0,0,0,,Okay so now we're creating a race so let's say one thread
Dialogue: 0,0:52:34.50,0:52:36.90,Chinese,,0,0,0,,好的，现在我们正在创造一场比赛，所以让我们说一个线程
Dialogue: 0,0:52:37.42,0:52:40.68,English,,0,0,0,,Let's say one thread calls this function so for example
Dialogue: 0,0:52:37.42,0:52:40.68,Chinese,,0,0,0,,假设一个线程调用此函数，例如
Dialogue: 0,0:52:41.66,0:52:46.06,English,,0,0,0,,ctime takes this this time struct as an argument
Dialogue: 0,0:52:41.66,0:52:46.06,Chinese,,0,0,0,,ctime将此时结构作为参数
Dialogue: 0,0:52:46.74,0:52:50.22,English,,0,0,0,,Okay which can correspond to an arbitrary time it could be the current time
Dialogue: 0,0:52:46.74,0:52:50.22,Chinese,,0,0,0,,好的，它可以对应于任意时间，它可能是当前时间
Dialogue: 0,0:52:50.22,0:52:53.20,English,,0,0,0,,Or just some arbitrary time that the caller constructed
Dialogue: 0,0:52:50.22,0:52:53.20,Chinese,,0,0,0,,或者只是调用者构建的任意时间
Dialogue: 0,0:52:54.26,0:52:58.28,English,,0,0,0,,And it returns a pointer to a char*
Dialogue: 0,0:52:54.26,0:52:58.28,Chinese,,0,0,0,,它返回一个指向char *的指针
Dialogue: 0,0:52:58.30,0:53:02.66,English,,0,0,0,,So it just returns a pointer to a string that represents the date and the time
Dialogue: 0,0:52:58.30,0:53:02.66,Chinese,,0,0,0,,所以它只返回一个指向表示日期和时间的字符串的指针
Dialogue: 0,0:53:02.76,0:53:09.16,English,,0,0,0,,Its own ascii string that represents the date and time
Dialogue: 0,0:53:02.76,0:53:09.16,Chinese,,0,0,0,,它自己的ascii字符串代表日期和时间
Dialogue: 0,0:53:12.58,0:53:19.34,English,,0,0,0,,But it's always returning a pointer to the same location in memory
Dialogue: 0,0:53:12.58,0:53:19.34,Chinese,,0,0,0,,但它始终返回指向内存中相同位置的指针
Dialogue: 0,0:53:21.98,0:53:26.02,English,,0,0,0,,Okay so you can see the problem if thread a calls this ctime function
Dialogue: 0,0:53:21.98,0:53:26.02,Chinese,,0,0,0,,好吧，如果线程a调用此ctime函数，你可以看到问题
Dialogue: 0,0:53:27.20,0:53:29.42,English,,0,0,0,,With one...with one time struck
Dialogue: 0,0:53:27.20,0:53:29.42,Chinese,,0,0,0,,有一个...一次击中
Dialogue: 0,0:53:30.30,0:53:35.98,English,,0,0,0,,It gets back a pointer to the character string corresponding to that time struct
Dialogue: 0,0:53:30.30,0:53:35.98,Chinese,,0,0,0,,它返回一个指向与该时间结构对应的字符串的指针
Dialogue: 0,0:53:37.04,0:53:39.94,English,,0,0,0,,But now let's say before thread a can use that
Dialogue: 0,0:53:37.04,0:53:39.94,Chinese,,0,0,0,,但现在让我们说在线程之前可以使用它
Dialogue: 0,0:53:41.30,0:53:45.06,English,,0,0,0,,Read that string another thread calls ctime
Dialogue: 0,0:53:41.30,0:53:45.06,Chinese,,0,0,0,,读取该字符串另一个线程调用ctime
Dialogue: 0,0:53:46.84,0:53:55.40,English,,0,0,0,,And that instance of ctime will overwrite that copy of the time string for that that thread a computed
Dialogue: 0,0:53:46.84,0:53:55.40,Chinese,,0,0,0,,并且该ctime实例将覆盖该线程计算的时间字符串的副本
Dialogue: 0,0:53:56.34,0:53:58.68,English,,0,0,0,,So when thread a finally gets a chance to access
Dialogue: 0,0:53:56.34,0:53:58.68,Chinese,,0,0,0,,所以当线程最终有机会访问时
Dialogue: 0,0:53:59.48,0:54:04.70,English,,0,0,0,,That time string its accessing thread b time string and not threat a time string
Dialogue: 0,0:53:59.48,0:54:04.70,Chinese,,0,0,0,,那个时间字符串它的访问线程b时间字符串而不是威胁时间字符串
Dialogue: 0,0:54:06.08,0:54:11.28,English,,0,0,0,,Okay and it just depends if thread a can get to that and read that variable before thread b
Dialogue: 0,0:54:06.08,0:54:11.28,Chinese,,0,0,0,,好吧，它只是取决于线程a是否可以到达并在线程b之前读取该变量
Dialogue: 0,0:54:12.00,0:54:13.96,English,,0,0,0,,Over writes it then everything's fine
Dialogue: 0,0:54:12.00,0:54:13.96,Chinese,,0,0,0,,过了写它然后一切都很好
Dialogue: 0,0:54:14.58,0:54:18.34,English,,0,0,0,,And otherwise threat a accessing the wrong time string
Dialogue: 0,0:54:14.58,0:54:18.34,Chinese,,0,0,0,,否则威胁访问错误的时间字符串
Dialogue: 0,0:54:19.06,0:54:22.48,English,,0,0,0,,Okay so there's there's a couple of ways to fix this like
Dialogue: 0,0:54:19.06,0:54:22.48,Chinese,,0,0,0,,好的，有几种方法可以解决这个问题
Dialogue: 0,0:54:23.24,0:54:27.05,English,,0,0,0,,We could rewrite the the function the ctime function to take
Dialogue: 0,0:54:23.24,0:54:27.05,Chinese,,0,0,0,,我们可以重写ctime函数要执行的功能
Dialogue: 0,0:54:27.70,0:54:31.90,English,,0,0,0,,As another argument that passes in
Dialogue: 0,0:54:27.70,0:54:31.90,Chinese,,0,0,0,,作为传入的另一个论点
Dialogue: 0,0:54:34.78,0:54:37.36,English,,0,0,0,,The location the address of the time string
Dialogue: 0,0:54:34.78,0:54:37.36,Chinese,,0,0,0,,时间字符串地址的位置
Dialogue: 0,0:54:37.40,0:54:44.70,English,,0,0,0,,So we could require the caller to allocate space for the time string and passing the address to the ctime function
Dialogue: 0,0:54:37.40,0:54:44.70,Chinese,,0,0,0,,所以我们可以要求调用者为时间字符串分配空间并将地址传递给ctime函数
Dialogue: 0,0:54:45.88,0:54:51.16,English,,0,0,0,,Okay but this has...this would require us to change all the instances
Dialogue: 0,0:54:45.88,0:54:51.16,Chinese,,0,0,0,,好的，但这有......这需要我们改变所有实例
Dialogue: 0,0:54:52.34,0:54:53.54,English,,0,0,0,,Where we call ctime
Dialogue: 0,0:54:52.34,0:54:53.54,Chinese,,0,0,0,,我们称之为ctime
Dialogue: 0,0:54:55.18,0:55:01.12,English,,0,0,0,,But we'd also have to change the implementation of ctime in the lib.c in the library
Dialogue: 0,0:54:55.18,0:55:01.12,Chinese,,0,0,0,,但是我们还必须在库中的lib.c中更改ctime的实现
Dialogue: 0,0:55:03.02,0:55:08.80,English,,0,0,0,,Right and so we can't...we don't have access to lib.c source on our system
Dialogue: 0,0:55:03.02,0:55:08.80,Chinese,,0,0,0,,是的，所以我们不能......我们没有访问我们系统上的lib.c源代码
Dialogue: 0,0:55:08.82,0:55:13.23,English,,0,0,0,,Right so that's just not a feasible thing plus it would break every other program
Dialogue: 0,0:55:08.82,0:55:13.23,Chinese,,0,0,0,,是的，所以这不是一个可行的事情加上它会打破其他所有程序
Dialogue: 0,0:55:13.70,0:55:16.18,English,,0,0,0,,That called ctime right so we just can't do
Dialogue: 0,0:55:13.70,0:55:16.18,Chinese,,0,0,0,,这称为ctime正确，所以我们做不到
Dialogue: 0,0:55:18.26,0:55:22.98,English,,0,0,0,,That the another option a better option is to create a new function of our own
Dialogue: 0,0:55:18.26,0:55:22.98,Chinese,,0,0,0,,另一种选择是更好的选择是创建我们自己的新功能
Dialogue: 0,0:55:24.18,0:55:28.32,English,,0,0,0,,Okay called ctime_ts for thread safe
Dialogue: 0,0:55:24.18,0:55:28.32,Chinese,,0,0,0,,好的，为线程安全调用了ctime_ts
Dialogue: 0,0:55:28.44,0:55:33.26,English,,0,0,0,,So we'll create our own sort of wrapper function for it for the ctime
Dialogue: 0,0:55:28.44,0:55:33.26,Chinese,,0,0,0,,因此，我们将为ctime创建自己的包装函数
Dialogue: 0,0:55:35.08,0:55:43.48,English,,0,0,0,,And we'll use a technique called lock and copy to provide thread safe access to ctime
Dialogue: 0,0:55:35.08,0:55:43.48,Chinese,,0,0,0,,我们将使用一种称为锁定和复制的技术来提供对ctime的线程安全访问
Dialogue: 0,0:55:44.64,0:55:49.52,English,,0,0,0,,So the way it works is it will write this new function ctime_ts
Dialogue: 0,0:55:44.64,0:55:49.52,Chinese,,0,0,0,,所以它的工作方式是编写这个新函数ctime_ts
Dialogue: 0,0:55:50.42,0:55:55.36,English,,0,0,0,,Which just like ctime takes this a pointer to this time struct
Dialogue: 0,0:55:50.42,0:55:55.36,Chinese,,0,0,0,,就像ctime一样，这是一个指向这个时间结构的指针
Dialogue: 0,0:55:55.98,0:55:57.66,English,,0,0,0,,But then it adds a second argument
Dialogue: 0,0:55:55.98,0:55:57.66,Chinese,,0,0,0,,但随后又增加了第二个论点
Dialogue: 0,0:55:59.16,0:56:04.92,English,,0,0,0,,Which is a pointer to the threat of threads private copy of the time string
Dialogue: 0,0:55:59.16,0:56:04.92,Chinese,,0,0,0,,这是指向线程威胁的时间字符串私有副本
Dialogue: 0,0:56:06.66,0:56:15.32,English,,0,0,0,,Okay so the caller allocates the space and passes the pointer to this to that to that string
Dialogue: 0,0:56:06.66,0:56:15.32,Chinese,,0,0,0,,好的，所以调用者分配空间并将指针传递给该字符串
Dialogue: 0,0:56:17.52,0:56:22.58,English,,0,0,0,,And then within ctime we have a local variable called the shared pointer
Dialogue: 0,0:56:17.52,0:56:22.58,Chinese,,0,0,0,,然后在ctime中我们有一个名为共享指针的局部变量
Dialogue: 0,0:56:23.32,0:56:29.76,English,,0,0,0,,Okay so this is going to point to that sharred global data structure that ctime is accessing
Dialogue: 0,0:56:23.32,0:56:29.76,Chinese,,0,0,0,,好的，这将指向犯罪正在访问的共享全球数据结构
Dialogue: 0,0:56:31.72,0:56:36.72,English,,0,0,0,,And so first we do the lock that's the lock part of lock and copy by acquiring a mutex
Dialogue: 0,0:56:31.72,0:56:36.72,Chinese,,0,0,0,,因此，首先我们通过获取互斥锁来锁定锁定部分并进行复制
Dialogue: 0,0:56:38.78,0:56:40.46,English,,0,0,0,,And then we call ctime
Dialogue: 0,0:56:38.78,0:56:40.46,Chinese,,0,0,0,,然后我们称之为ctime
Dialogue: 0,0:56:42.42,0:56:44.80,English,,0,0,0,,So only one thread at a time we'll have this mutex
Dialogue: 0,0:56:42.42,0:56:44.80,Chinese,,0,0,0,,因此，一次只有一个线程我们将拥有此互斥锁
Dialogue: 0,0:56:44.94,0:56:48.16,English,,0,0,0,,So whatever thread...so once we return from p
Dialogue: 0,0:56:44.94,0:56:48.16,Chinese,,0,0,0,,无论如何......所以一旦我们从p回来
Dialogue: 0,0:56:48.54,0:56:52.80,English,,0,0,0,,We know that we're the only thread in this critical section
Dialogue: 0,0:56:48.54,0:56:52.80,Chinese,,0,0,0,,我们知道我们是这个关键部分的唯一主题
Dialogue: 0,0:56:53.78,0:56:57.46,English,,0,0,0,,So we call ctime the normal lib.c ctime function
Dialogue: 0,0:56:53.78,0:56:57.46,Chinese,,0,0,0,,所以我们称ctime为普通的lib.c ctime函数
Dialogue: 0,0:56:58.28,0:57:02.10,English,,0,0,0,,Which returns a pointer to this to the same location
Dialogue: 0,0:56:58.28,0:57:02.10,Chinese,,0,0,0,,这会将指向此的指针返回到同一位置
Dialogue: 0,0:57:03.46,0:57:06.98,English,,0,0,0,,And then we do the copy part we copy that string
Dialogue: 0,0:57:03.46,0:57:06.98,Chinese,,0,0,0,,然后我们做复制部分我们复制该字符串
Dialogue: 0,0:57:08.92,0:57:13.78,English,,0,0,0,,To the private string that was passed in just into a function
Dialogue: 0,0:57:08.92,0:57:13.78,Chinese,,0,0,0,,到刚刚传入函数的私有字符串
Dialogue: 0,0:57:15.40,0:57:18.04,English,,0,0,0,,Once we've done the copy then we can release the mutex
Dialogue: 0,0:57:15.40,0:57:18.04,Chinese,,0,0,0,,一旦我们完成了副本，我们就可以释放互斥锁
Dialogue: 0,0:57:18.56,0:57:20.22,English,,0,0,0,,And then we return a pointer
Dialogue: 0,0:57:18.56,0:57:20.22,Chinese,,0,0,0,,然后我们返回一个指针
Dialogue: 0,0:57:21.68,0:57:27.86,English,,0,0,0,,We return privatep back to the caller right ok so
Dialogue: 0,0:57:21.68,0:57:27.86,Chinese,,0,0,0,,我们将privatep返回给调用者，这样就可以了
Dialogue: 0,0:57:30.16,0:57:34.20,English,,0,0,0,,And we don't this is just more of a convenience to the caller
Dialogue: 0,0:57:30.16,0:57:34.20,Chinese,,0,0,0,,而且我们不会这对呼叫者来说更方便
Dialogue: 0,0:57:34.40,0:57:38.66,English,,0,0,0,,Because programs that are using ctime are expecting to get that pointer back
Dialogue: 0,0:57:34.40,0:57:38.66,Chinese,,0,0,0,,因为使用ctime的程序期望得到指针
Dialogue: 0,0:57:39.46,0:57:41.48,English,,0,0,0,,Ok so by using lock and copy
Dialogue: 0,0:57:39.46,0:57:41.48,Chinese,,0,0,0,,好吧，使用锁定和复制
Dialogue: 0,0:57:42.14,0:57:46.34,English,,0,0,0,,We have to make changes,we have to write this new function but it's fairly simple
Dialogue: 0,0:57:42.14,0:57:46.34,Chinese,,0,0,0,,我们必须进行更改，我们必须编写这个新函数，但它非常简单
Dialogue: 0,0:57:47.60,0:57:52.76,English,,0,0,0,,And then we have to make changes every place in our program where we call ctime
Dialogue: 0,0:57:47.60,0:57:52.76,Chinese,,0,0,0,,然后我们必须在我们称之为ctime的程序中的每个地方进行更改
Dialogue: 0,0:57:52.76,0:57:56.28,English,,0,0,0,,We have to update those to calls to ctime_ts
Dialogue: 0,0:57:52.76,0:57:56.28,Chinese,,0,0,0,,我们必须更新那些调用ctime_ts
Dialogue: 0,0:57:56.92,0:58:02.72,English,,0,0,0,,And create this local string array
Dialogue: 0,0:57:56.92,0:58:02.72,Chinese,,0,0,0,,并创建此本地字符串数组
Dialogue: 0,0:58:03.46,0:58:04.26,English,,0,0,0,,Ok yes
Dialogue: 0,0:58:03.46,0:58:04.26,Chinese,,0,0,0,,好的
Dialogue: 0,0:58:04.66,0:58:18.02,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:21.04,0:58:24.56,English,,0,0,0,,Well typically these functions are returning pointers to some data structure
Dialogue: 0,0:58:21.04,0:58:24.56,Chinese,,0,0,0,,通常这些函数返回指向某些数据结构的指针
Dialogue: 0,0:58:25.00,0:58:30.22,English,,0,0,0,,And so they're sort of updating the data structure and then returning a pointer to it so
Dialogue: 0,0:58:25.00,0:58:30.22,Chinese,,0,0,0,,因此，他们有点更新数据结构，然后返回指向它的指针
Dialogue: 0,0:58:32.10,0:58:33.82,English,,0,0,0,,It wouldn't makes,I don't know how
Dialogue: 0,0:58:32.10,0:58:33.82,Chinese,,0,0,0,,它不会，我不知道如何
Dialogue: 0,0:58:34.58,0:58:37.64,English,,0,0,0,,I guess it could return a struct and it would always return
Dialogue: 0,0:58:34.58,0:58:37.64,Chinese,,0,0,0,,我想它可以返回一个结构，它总会返回
Dialogue: 0,0:58:38.60,0:58:39.28,English,,0,0,0,,Now now
Dialogue: 0,0:58:38.60,0:58:39.28,Chinese,,0,0,0,,现在
Dialogue: 0,0:58:43.52,0:58:48.16,English,,0,0,0,,I can't think of any...I can't think of any reason why they would turn anything but a pointer
Dialogue: 0,0:58:43.52,0:58:48.16,Chinese,,0,0,0,,我想不出任何......我想不出有什么理由说他们除了指针之外什么都不会转
Dialogue: 0,0:58:48.62,0:58:52.72,English,,0,0,0,,Because they're typically updating some data structure
Dialogue: 0,0:58:48.62,0:58:52.72,Chinese,,0,0,0,,因为他们通常会更新一些数据结构
Dialogue: 0,0:58:53.30,0:58:54.76,English,,0,0,0,,And then returning a pointer to it
Dialogue: 0,0:58:53.30,0:58:54.76,Chinese,,0,0,0,,然后返回指向它的指针
Dialogue: 0,0:59:02.18,0:59:03.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:02.18,0:59:03.70,Chinese,,0,0,0,,如果他们回来了
Dialogue: 0,0:59:06.18,0:59:07.70,English,,0,0,0,,If they were returning
Dialogue: 0,0:59:06.18,0:59:07.70,Chinese,,0,0,0,,如果他们回来了
Dialogue: 0,0:59:08.98,0:59:13.04,English,,0,0,0,,Scalars those scalars would always be returned in %eax or %rax
Dialogue: 0,0:59:08.98,0:59:13.04,Chinese,,0,0,0,,这些标量的标量将始终以％eax或％rax返回
Dialogue: 0,0:59:13.84,0:59:16.32,English,,0,0,0,,All right so actually that would be okay right it would just be
Dialogue: 0,0:59:13.84,0:59:16.32,Chinese,,0,0,0,,好吧所以实际上这样就可以了
Dialogue: 0,0:59:17.06,0:59:19.16,English,,0,0,0,,It's the pointer that causes a problem because
Dialogue: 0,0:59:17.06,0:59:19.16,Chinese,,0,0,0,,这是导致问题的指针，因为
Dialogue: 0,0:59:20.32,0:59:23.00,English,,0,0,0,,It's always returning that value in %eax
Dialogue: 0,0:59:20.32,0:59:23.00,Chinese,,0,0,0,,它总是在％eax中返回该值
Dialogue: 0,0:59:23.00,0:59:30.56,English,,0,0,0,,But it's always returning the same value in %eax always pointing to the same data structure okay good
Dialogue: 0,0:59:23.00,0:59:30.56,Chinese,,0,0,0,,但是它始终在％eax中返回相同的值，总是指向相同的数据结构
Dialogue: 0,0:59:34.52,0:59:35.48,English,,0,0,0,,Okay now one...
Dialogue: 0,0:59:34.52,0:59:35.48,Chinese,,0,0,0,,好的，现在一个......
Dialogue: 0,0:59:37.58,0:59:41.98,English,,0,0,0,,One potentially significant disadvantage of lock and copy is that
Dialogue: 0,0:59:37.58,0:59:41.98,Chinese,,0,0,0,,锁定和复制的一个潜在显着缺点是
Dialogue: 0,0:59:43.24,0:59:49.06,English,,0,0,0,,This copy might not always be as simple as just doing like a strcpy,if
Dialogue: 0,0:59:43.24,0:59:49.06,Chinese,,0,0,0,,这个副本可能并不总是像strcpy一样简单，如果
Dialogue: 0,0:59:50.02,0:59:56.62,English,,0,0,0,,If it's a complex diff...if the function that you're calling is computing some complex data structure like a nested
Dialogue: 0,0:59:50.02,0:59:56.62,Chinese,,0,0,0,,如果它是一个复杂的差异...如果你正在调用的函数是计算一些复杂的数据结构，如嵌套
Dialogue: 0,0:59:57.26,1:00:00.40,English,,0,0,0,,You know a struct which contains structs and pointers to arrays
Dialogue: 0,0:59:57.26,1:00:00.40,Chinese,,0,0,0,,你知道一个包含结构和数组指针的结构
Dialogue: 0,1:00:01.28,1:00:04.66,English,,0,0,0,,Then this copy can get quite complicated right
Dialogue: 0,1:00:01.28,1:00:04.66,Chinese,,0,0,0,,然后这个副本可以变得非常复杂
Dialogue: 0,1:00:05.10,1:00:07.06,English,,0,0,0,,It would require what we call a deep copy
Dialogue: 0,1:00:05.10,1:00:07.06,Chinese,,0,0,0,,它需要我们称之为深层复制品
Dialogue: 0,1:00:08.20,1:00:10.50,English,,0,0,0,,So that can be that can be very difficult to
Dialogue: 0,1:00:08.20,1:00:10.50,Chinese,,0,0,0,,所以这可能是非常困难的
Dialogue: 0,1:00:11.16,1:00:15.84,English,,0,0,0,,But in this case it's simple we're just copying one string to another
Dialogue: 0,1:00:11.16,1:00:15.84,Chinese,,0,0,0,,但在这种情况下，我们只是将一个字符串复制到另一个字符串
Dialogue: 0,1:00:17.44,1:00:25.06,English,,0,0,0,,Okay and then finally the 4 class of thread-unsafe functions are functions that call unsafe functions right
Dialogue: 0,1:00:17.44,1:00:25.06,Chinese,,0,0,0,,好的，最后4类线程不安全的函数是正确调用不安全函数的函数
Dialogue: 0,1:00:25.08,1:00:26.20,English,,0,0,0,,So it's kind of obvious
Dialogue: 0,1:00:25.08,1:00:26.20,Chinese,,0,0,0,,所以这很明显
Dialogue: 0,1:00:27.04,1:00:32.16,English,,0,0,0,,And then the obvious fix is to not call thread-unsafe functions from within your function
Dialogue: 0,1:00:27.04,1:00:32.16,Chinese,,0,0,0,,然后明显的解决方法是不在函数内调用线程不安全的函数
Dialogue: 0,1:00:32.76,1:00:34.04,English,,0,0,0,,And then you can make it thread safe
Dialogue: 0,1:00:32.76,1:00:34.04,Chinese,,0,0,0,,然后你可以使它线程安全
Dialogue: 0,1:00:37.10,1:00:44.34,English,,0,0,0,,Now there's a very interesting an important subclass of thread-safe functions called reentrant functions
Dialogue: 0,1:00:37.10,1:00:44.34,Chinese,,0,0,0,,现在有一个非常有趣的线程安全函数的重要子类，称为可重入函数
Dialogue: 0,1:00:45.76,1:00:49.20,English,,0,0,0,,So a reentrant a function is reentrant
Dialogue: 0,1:00:45.76,1:00:49.20,Chinese,,0,0,0,,因此，重入一个函数是可重入的
Dialogue: 0,1:00:50.22,1:00:53.82,English,,0,0,0,,If it contains no accesses to shared to shared variables
Dialogue: 0,1:00:50.22,1:00:53.82,Chinese,,0,0,0,,如果它不包含对共享变量的共享变量的访问权限
Dialogue: 0,1:00:54.72,1:00:59.14,English,,0,0,0,,Okay so if all the...every variable that it accesses is
Dialogue: 0,1:00:54.72,1:00:59.14,Chinese,,0,0,0,,好的，如果所有......它访问的每个变量都是
Dialogue: 0,1:00:59.56,1:01:06.94,English,,0,0,0,,Contained on the is declared as a local variable and stored on the stack for that function
Dialogue: 0,1:00:59.56,1:01:06.94,Chinese,,0,0,0,,包含在声明为局部变量并存储在该函数的堆栈中
Dialogue: 0,1:01:07.68,1:01:09.30,English,,0,0,0,,Okay that's called a reentrant function
Dialogue: 0,1:01:07.68,1:01:09.30,Chinese,,0,0,0,,好的，这被称为可重入函数
Dialogue: 0,1:01:10.10,1:01:13.38,English,,0,0,0,,And because there's no accesses of any kind to shared variables
Dialogue: 0,1:01:10.10,1:01:13.38,Chinese,,0,0,0,,并且因为共享变量没有任何类型的访问
Dialogue: 0,1:01:14.10,1:01:17.10,English,,0,0,0,,There's no synchronization required
Dialogue: 0,1:01:14.10,1:01:17.10,Chinese,,0,0,0,,不需要同步
Dialogue: 0,1:01:17.10,1:01:22.14,English,,0,0,0,,Because every function is operating accessing its own local copy of all the variables
Dialogue: 0,1:01:17.10,1:01:22.14,Chinese,,0,0,0,,因为每个函数都在操作访问它自己的所有变量的本地副本
Dialogue: 0,1:01:23.90,1:01:29.58,English,,0,0,0,,And if multiple threads execute two instances of a reentrant function
Dialogue: 0,1:01:23.90,1:01:29.58,Chinese,,0,0,0,,如果多个线程执行可重入函数的两个实例
Dialogue: 0,1:01:30.62,1:01:33.16,English,,0,0,0,,It's okay each thread has its own separate stack
Dialogue: 0,1:01:30.62,1:01:33.16,Chinese,,0,0,0,,没关系，每个线程都有自己独立的堆栈
Dialogue: 0,1:01:33.80,1:01:39.56,English,,0,0,0,,So you don't need to worry about any kind of synchronization they can run independently
Dialogue: 0,1:01:33.80,1:01:39.56,Chinese,,0,0,0,,因此，你无需担心它们可以独立运行的任何类型的同步
Dialogue: 0,1:01:40.12,1:01:45.76,English,,0,0,0,,So the reason reentrant functions are so important is because it's expensive to do synchronization
Dialogue: 0,1:01:40.12,1:01:45.76,Chinese,,0,0,0,,因此，重入函数如此重要的原因是因为同步很昂贵
Dialogue: 0,1:01:47.10,1:01:51.46,English,,0,0,0,,And so what you can avoid it completely with these reentrant function reentrant functions
Dialogue: 0,1:01:47.10,1:01:51.46,Chinese,,0,0,0,,因此，你可以完全避免使用这些可重入的函数重入函数
Dialogue: 0,1:01:51.48,1:01:52.48,English,,0,0,0,,So they're efficient
Dialogue: 0,1:01:51.48,1:01:52.48,Chinese,,0,0,0,,所以他们很有效率
Dialogue: 0,1:01:57.52,1:02:01.24,English,,0,0,0,,So as that as the diagram shows every reentrant function is thread safe
Dialogue: 0,1:01:57.52,1:02:01.24,Chinese,,0,0,0,,因此，如图所示，每个可重入函数都是线程安全的
Dialogue: 0,1:02:01.96,1:02:04.52,English,,0,0,0,,But not every thread safe function is reentrant
Dialogue: 0,1:02:01.96,1:02:04.52,Chinese,,0,0,0,,但并非每个线程安全功能都是可重入的
Dialogue: 0,1:02:07.48,1:02:11.92,English,,0,0,0,,So we saw that before right when we have a function that accesses a shared variable
Dialogue: 0,1:02:07.48,1:02:11.92,Chinese,,0,0,0,,所以我们在拥有访问共享变量的函数之前就已经看到了
Dialogue: 0,1:02:12.48,1:02:15.90,English,,0,0,0,,We can make it thread safe by protecting it with a mutex
Dialogue: 0,1:02:12.48,1:02:15.90,Chinese,,0,0,0,,我们可以通过使用互斥锁保护它来使其安全
Dialogue: 0,1:02:17.98,1:02:21.62,English,,0,0,0,,Okay but it's not reentrant,because it's accessing shared variables okay
Dialogue: 0,1:02:17.98,1:02:21.62,Chinese,,0,0,0,,好的，但它不是可重入的，因为它正在访问共享变量
Dialogue: 0,1:02:28.30,1:02:34.74,English,,0,0,0,,Now on all the functions in the standard C library which are enumerated in the back of your k and r texture thread-safe
Dialogue: 0,1:02:28.30,1:02:34.74,Chinese,,0,0,0,,现在介绍标准C库中的所有函数，这些函数在k和r纹理的线程安全的后面进行枚举
Dialogue: 0,1:02:35.66,1:02:37.60,English,,0,0,0,,Okay but not necessarily reentrant
Dialogue: 0,1:02:35.66,1:02:37.60,Chinese,,0,0,0,,好的但不一定是可重入的
Dialogue: 0,1:02:39.36,1:02:44.20,English,,0,0,0,,And most most syscalls are thread safe with a few exceptions that I've listed here
Dialogue: 0,1:02:39.36,1:02:44.20,Chinese,,0,0,0,,大多数系统调用都是线程安全的，除了我在这里列出的一些例外
Dialogue: 0,1:02:44.98,1:02:47.74,English,,0,0,0,,I don't think I don't think this is complete
Dialogue: 0,1:02:44.98,1:02:47.74,Chinese,,0,0,0,,我认为我不认为这是完整的
Dialogue: 0,1:02:47.76,1:02:50.44,English,,0,0,0,,But these are just some examples of some notable ones
Dialogue: 0,1:02:47.76,1:02:50.44,Chinese,,0,0,0,,但这些只是一些值得注意的例子
Dialogue: 0,1:02:51.74,1:02:55.22,English,,0,0,0,,And so for each of these thread unsafe functions
Dialogue: 0,1:02:51.74,1:02:55.22,Chinese,,0,0,0,,因此对于每个线程不安全的函数
Dialogue: 0,1:02:57.30,1:02:59.92,English,,0,0,0,,Linux provides a reentrant version
Dialogue: 0,1:02:57.30,1:02:59.92,Chinese,,0,0,0,,Linux提供了一个可重入的版本
Dialogue: 0,1:03:00.66,1:03:02.88,English,,0,0,0,,Which is denoted by _r
Dialogue: 0,1:03:00.66,1:03:02.88,Chinese,,0,0,0,,用_r表示
Dialogue: 0,1:03:03.76,1:03:08.40,English,,0,0,0,,And then that reentrant version has a different set of parameters typically
Dialogue: 0,1:03:03.76,1:03:08.40,Chinese,,0,0,0,,然后，该可重入版本通常具有不同的参数集
Dialogue: 0,1:03:10.08,1:03:19.90,English,,0,0,0,,The only exception that I know about is inet_ntoa which is an episode of an obsolete network protocol for converting
Dialogue: 0,1:03:10.08,1:03:19.90,Chinese,,0,0,0,,我所知道的唯一例外是inet_ntoa，它是用于转换的过时网络协议的一集
Dialogue: 0,1:03:20.86,1:03:25.14,English,,0,0,0,,Sort of binary network addresses to human readable ascii addresses
Dialogue: 0,1:03:20.86,1:03:25.14,Chinese,,0,0,0,,将二进制网络地址排序为人类可读的ascii地址
Dialogue: 0,1:03:25.66,1:03:30.48,English,,0,0,0,,But this is ops been obsoleted by other calls
Dialogue: 0,1:03:25.66,1:03:30.48,Chinese,,0,0,0,,但这是其他电话已经废弃的
Dialogue: 0,1:03:30.48,1:03:36.02,English,,0,0,0,,So it's I guess they just never bothered to create a reentrant version for it
Dialogue: 0,1:03:30.48,1:03:36.02,Chinese,,0,0,0,,所以我猜他们从不打算为它创建一个可重入的版本
Dialogue: 0,1:03:36.38,1:03:38.96,English,,0,0,0,,Because there's other options alternatives to using that
Dialogue: 0,1:03:36.38,1:03:38.96,Chinese,,0,0,0,,因为还有其他选择可供选择
Dialogue: 0,1:03:41.28,1:03:45.10,English,,0,0,0,,Okay so another thing we have to worry about is we've seen is races
Dialogue: 0,1:03:41.28,1:03:45.10,Chinese,,0,0,0,,好的，我们不得不担心的另一件事是我们看到的是比赛
Dialogue: 0,1:03:46.16,1:03:49.42,English,,0,0,0,,Again this is the real bugaboo in threaded programs
Dialogue: 0,1:03:46.16,1:03:49.42,Chinese,,0,0,0,,再次，这是线程程序中真正的bugaboo
Dialogue: 0,1:03:50.58,1:03:53.82,English,,0,0,0,,And it typically involves some kind of unexpected sharing
Dialogue: 0,1:03:50.58,1:03:53.82,Chinese,,0,0,0,,它通常涉及某种意外的共享
Dialogue: 0,1:03:54.62,1:03:57.24,English,,0,0,0,,So in this case I'm going to revisit this
Dialogue: 0,1:03:54.62,1:03:57.24,Chinese,,0,0,0,,所以在这种情况下，我将重新审视这一点
Dialogue: 0,1:03:58.12,1:04:02.16,English,,0,0,0,,This incorrect threaded program
Dialogue: 0,1:03:58.12,1:04:02.16,Chinese,,0,0,0,,这个错误的线程程序
Dialogue: 0,1:04:03.14,1:04:07.38,English,,0,0,0,,That where we introduce introduced a race by passing when we create the thread
Dialogue: 0,1:04:03.14,1:04:07.38,Chinese,,0,0,0,,我们介绍的地方通过在创建线程时传递引入了竞赛
Dialogue: 0,1:04:08.74,1:04:13.02,English,,0,0,0,,We pass the argument to the thread which is like the local thread id
Dialogue: 0,1:04:08.74,1:04:13.02,Chinese,,0,0,0,,我们将参数传递给类似本地线程id的线程
Dialogue: 0,1:04:14.30,1:04:19.18,English,,0,0,0,,We pass an address of a variable that we have stored on the stack
Dialogue: 0,1:04:14.30,1:04:19.18,Chinese,,0,0,0,,我们传递一个存储在堆栈中的变量的地址
Dialogue: 0,1:04:19.92,1:04:23.66,English,,0,0,0,,And int i that the loop iterator
Dialogue: 0,1:04:19.92,1:04:23.66,Chinese,,0,0,0,,而int我认为循环迭代器
Dialogue: 0,1:04:26.00,1:04:26.68,English,,0,0,0,,And so
Dialogue: 0,1:04:26.00,1:04:26.68,Chinese,,0,0,0,,所以
Dialogue: 0,1:04:29.82,1:04:33.92,English,,0,0,0,,We've seen that this causes this causes a race so
Dialogue: 0,1:04:29.82,1:04:33.92,Chinese,,0,0,0,,我们已经看到这导致这种情况导致比赛
Dialogue: 0,1:04:35.74,1:04:41.26,English,,0,0,0,,We incurred...we set initially i is 0, then we create a new thread which is peer thread 0
Dialogue: 0,1:04:35.74,1:04:41.26,Chinese,,0,0,0,,我们招致...我们最初设置为0，然后我们创建一个新的线程，即对等线程0
Dialogue: 0,1:04:42.14,1:04:51.08,English,,0,0,0,,And then this thread dereferences the pointer to get its local copy of the this sort of local thread id
Dialogue: 0,1:04:42.14,1:04:51.08,Chinese,,0,0,0,,然后这个线程取消引用指针以获取这种本地线程id的本地副本
Dialogue: 0,1:04:53.26,1:04:54.86,English,,0,0,0,,But now we've introduced the race
Dialogue: 0,1:04:53.26,1:04:54.86,Chinese,,0,0,0,,但现在我们已经引入了比赛
Dialogue: 0,1:04:56.88,1:04:58.52,English,,0,0,0,,Between the increment of i
Dialogue: 0,1:04:56.88,1:04:58.52,Chinese,,0,0,0,,在i的增量之间
Dialogue: 0,1:05:00.50,1:05:04.86,English,,0,0,0,,And the dereferencing of the incrementing of i and the main thread
Dialogue: 0,1:05:00.50,1:05:04.86,Chinese,,0,0,0,,并且取消引用i和主线程的递增
Dialogue: 0,1:05:05.30,1:05:08.00,English,,0,0,0,,And the dereferencing of i in the peer thread
Dialogue: 0,1:05:05.30,1:05:08.00,Chinese,,0,0,0,,并在对等线程中取消引用i
Dialogue: 0,1:05:09.12,1:05:13.42,English,,0,0,0,,So if this dereferencing happens before i is incremented then we're good
Dialogue: 0,1:05:09.12,1:05:13.42,Chinese,,0,0,0,,因此，如果在我增加之前发生这种解除引用，那么我们就是好的
Dialogue: 0,1:05:14.68,1:05:17.26,English,,0,0,0,,But if this dereferencing happens after
Dialogue: 0,1:05:14.68,1:05:17.26,Chinese,,0,0,0,,但如果这种解除引用发生在之后
Dialogue: 0,1:05:18.08,1:05:20.96,English,,0,0,0,,We increment i so in other words at when i equal 1
Dialogue: 0,1:05:18.08,1:05:20.96,Chinese,,0,0,0,,换句话说，当我等于1时，我增加i
Dialogue: 0,1:05:22.44,1:05:26.94,English,,0,0,0,,Then we get the wrong value in the peer thread for myid
Dialogue: 0,1:05:22.44,1:05:26.94,Chinese,,0,0,0,,然后我们在myid的对等线程中得到错误的值
Dialogue: 0,1:05:30.46,1:05:32.96,English,,0,0,0,,So you might wonder I think there was a question before about
Dialogue: 0,1:05:30.46,1:05:32.96,Chinese,,0,0,0,,所以你可能想知道我之前有一个问题
Dialogue: 0,1:05:33.98,1:05:39.24,English,,0,0,0,,You know this seems that the odds of this happening seems so low why why are you even worrying about it
Dialogue: 0,1:05:33.98,1:05:39.24,Chinese,,0,0,0,,你知道这似乎发生的可能性似乎很低，为什么你甚至担心它
Dialogue: 0,1:05:40.66,1:05:46.60,English,,0,0,0,,So we actually create just to sort of test this out we wrote a program to see if we could
Dialogue: 0,1:05:40.66,1:05:46.60,Chinese,,0,0,0,,所以我们实际创建只是为了测试这个，我们写了一个程序，看看我们是否可以
Dialogue: 0,1:05:47.78,1:05:52.60,English,,0,0,0,,See if we could actually see this race in practice
Dialogue: 0,1:05:47.78,1:05:52.60,Chinese,,0,0,0,,看看我们是否真的可以在实践中看到这场比赛
Dialogue: 0,1:05:53.68,1:05:58.22,English,,0,0,0,,And that's one of the great things about like 213 is that you we can just try stuff out right so
Dialogue: 0,1:05:53.68,1:05:58.22,Chinese,,0,0,0,,这就是像213这样的伟大事情之一就是你我们可以正确地尝试这样的东西
Dialogue: 0,1:05:58.94,1:05:59.94,English,,0,0,0,,So we just tried it out
Dialogue: 0,1:05:58.94,1:05:59.94,Chinese,,0,0,0,,所以我们试了一下
Dialogue: 0,1:06:01.94,1:06:07.90,English,,0,0,0,,So we wrote a simple main thread that creates a hundred different threads
Dialogue: 0,1:06:01.94,1:06:07.90,Chinese,,0,0,0,,所以我们编写了一个简单的主线程，创建了一百个不同的线程
Dialogue: 0,1:06:08.76,1:06:15.54,English,,0,0,0,,Each with then we passed the art as the argument we passed the address of this local variable i okay
Dialogue: 0,1:06:08.76,1:06:15.54,Chinese,,0,0,0,,然后我们传递艺术作为参数，我们传递了这个局部变量的地址我没关系
Dialogue: 0,1:06:17.76,1:06:21.34,English,,0,0,0,,And then in each peer thread we detach the thread dereference
Dialogue: 0,1:06:17.76,1:06:21.34,Chinese,,0,0,0,,然后在每个对等线程中我们分离线程解除引用
Dialogue: 0,1:06:22.06,1:06:25.46,English,,0,0,0,,And then we have a function that saves the value so we're we're storing
Dialogue: 0,1:06:22.06,1:06:25.46,Chinese,,0,0,0,,然后我们有一个保存价值的功能，所以我们正在存储
Dialogue: 0,1:06:27.14,1:06:31.86,English,,0,0,0,,We're storing that value of i for future reference
Dialogue: 0,1:06:27.14,1:06:31.86,Chinese,,0,0,0,,我们将i的值存储起来供将来参考
Dialogue: 0,1:06:33.90,1:06:35.36,English,,0,0,0,,Okay so now if there's no race
Dialogue: 0,1:06:33.90,1:06:35.36,Chinese,,0,0,0,,好的，现在如果没有比赛的话
Dialogue: 0,1:06:36.52,1:06:40.74,English,,0,0,0,,Each of the 100 threads would get a separate distinct thread id
Dialogue: 0,1:06:36.52,1:06:40.74,Chinese,,0,0,0,,100个线程中的每一个都将获得单独的不同线程ID
Dialogue: 0,1:06:40.98,1:06:43.72,English,,0,0,0,,Right so each value 0 through 99
Dialogue: 0,1:06:40.98,1:06:43.72,Chinese,,0,0,0,,对，所以每个值0到99
Dialogue: 0,1:06:44.16,1:06:45.60,English,,0,0,0,,If we made a histogram of it
Dialogue: 0,1:06:44.16,1:06:45.60,Chinese,,0,0,0,,如果我们做了直方图
Dialogue: 0,1:06:46.34,1:06:50.72,English,,0,0,0,,There would be exactly one instance of each value of i
Dialogue: 0,1:06:46.34,1:06:50.72,Chinese,,0,0,0,,i的每个值都只有一个实例
Dialogue: 0,1:06:52.42,1:06:56.54,English,,0,0,0,,Okay but if there was a race there would be for some values of i
Dialogue: 0,1:06:52.42,1:06:56.54,Chinese,,0,0,0,,好的，但是如果有比赛，我会有一些价值观
Dialogue: 0,1:06:56.54,1:06:59.56,English,,0,0,0,,There would be multiple instances that were encountered in multiple threads
Dialogue: 0,1:06:56.54,1:06:59.56,Chinese,,0,0,0,,在多个线程中会遇到多个实例
Dialogue: 0,1:07:00.76,1:07:02.64,English,,0,0,0,,Okay so you can see if we go back here
Dialogue: 0,1:07:00.76,1:07:02.64,Chinese,,0,0,0,,好的，你可以看看我们是否回到这里
Dialogue: 0,1:07:04.02,1:07:11.62,English,,0,0,0,,If we lose if the peer thread loses the race and I gets incremented before it can dereference
Dialogue: 0,1:07:04.02,1:07:11.62,Chinese,,0,0,0,,如果我们输了，如果对等线程丢失了比赛，我会在它取消引用之前增加
Dialogue: 0,1:07:15.28,1:07:22.08,English,,0,0,0,,Now we've got peer thread 0 actually gets an id of one
Dialogue: 0,1:07:15.28,1:07:22.08,Chinese,,0,0,0,,现在我们有对等线程0实际上得到一个id
Dialogue: 0,1:07:25.70,1:07:27.52,English,,0,0,0,,Okay and then peer thread one
Dialogue: 0,1:07:25.70,1:07:27.52,Chinese,,0,0,0,,好吧，然后同行线程一
Dialogue: 0,1:07:28.32,1:07:34.24,English,,0,0,0,,If there's no race it'll get the correct value of one so now we've got two instances of one okay
Dialogue: 0,1:07:28.32,1:07:34.24,Chinese,,0,0,0,,如果没有比赛，它将得到一个正确的值，所以现在我们有两个一个好的实例
Dialogue: 0,1:07:36.86,1:07:38.36,English,,0,0,0,,So let's look so this is the case
Dialogue: 0,1:07:36.86,1:07:38.36,Chinese,,0,0,0,,所以，让我们看看是这样的
Dialogue: 0,1:07:40.48,1:07:45.58,English,,0,0,0,,So we've plotted the results for a case where there's no race so along the x-axis sorry this is too small
Dialogue: 0,1:07:40.48,1:07:45.58,Chinese,,0,0,0,,因此，我们已经绘制了一个案例的结果，其中没有竞争，所以沿着x轴抱歉这太小了
Dialogue: 0,1:07:46.18,1:07:51.20,English,,0,0,0,,The x-axis gives us all the 100 values of i,0 through 99
Dialogue: 0,1:07:46.18,1:07:51.20,Chinese,,0,0,0,,x轴给出了i，0到99的所有100个值
Dialogue: 0,1:07:51.72,1:08:00.12,English,,0,0,0,,And then the y-axis is the count so this is a hit we're doing a histogram for these all the values 0 through 99
Dialogue: 0,1:07:51.72,1:08:00.12,Chinese,,0,0,0,,然后y轴是计数，所以这是一个命中我们正在为这些所有值0到99做直方图
Dialogue: 0,1:08:01.22,1:08:05.46,English,,0,0,0,,So in this case every value has exactly one instance so no race
Dialogue: 0,1:08:01.22,1:08:05.46,Chinese,,0,0,0,,所以在这种情况下，每个值只有一个实例，所以没有竞争
Dialogue: 0,1:08:06.26,1:08:14.64,English,,0,0,0,,There was no races in involved in all 99 are all 100 instances
Dialogue: 0,1:08:06.26,1:08:14.64,Chinese,,0,0,0,,所有99个实例中都没有参与比赛
Dialogue: 0,1:08:16.52,1:08:18.22,English,,0,0,0,,If we run it on a single core laptop
Dialogue: 0,1:08:16.52,1:08:18.22,Chinese,,0,0,0,,如果我们在单核笔记本电脑上运行它
Dialogue: 0,1:08:18.30,1:08:22.08,English,,0,0,0,,So now each thread is sort of taking its turn on a single core
Dialogue: 0,1:08:18.30,1:08:22.08,Chinese,,0,0,0,,所以现在每个线程都在单个核心上进行
Dialogue: 0,1:08:24.06,1:08:27.40,English,,0,0,0,,It happens a few times right so there's a few times where
Dialogue: 0,1:08:24.06,1:08:27.40,Chinese,,0,0,0,,它发生了好几次，所以有几次
Dialogue: 0,1:08:28.18,1:08:31.50,English,,0,0,0,,The one thread gets preempted and the other thread
Dialogue: 0,1:08:28.18,1:08:31.50,Chinese,,0,0,0,,一个线程被抢占，另一个线程被抢占
Dialogue: 0,1:08:31.98,1:08:33.24,English,,0,0,0,,Begins to run
Dialogue: 0,1:08:31.98,1:08:33.24,Chinese,,0,0,0,,开始跑
Dialogue: 0,1:08:35.84,1:08:36.78,English,,0,0,0,,Before it can...
Dialogue: 0,1:08:35.84,1:08:36.78,Chinese,,0,0,0,,在它之前......
Dialogue: 0,1:08:36.92,1:08:41.74,English,,0,0,0,,So the peers when one thread gets preempted before I can dereference the variable
Dialogue: 0,1:08:36.92,1:08:41.74,Chinese,,0,0,0,,因此，在我可以取消引用变量之前，一个线程被抢占的对等体
Dialogue: 0,1:08:41.74,1:08:44.10,English,,0,0,0,,So it gets the wrong the wrong value
Dialogue: 0,1:08:41.74,1:08:44.10,Chinese,,0,0,0,,所以它错了错误的价值
Dialogue: 0,1:08:44.40,1:08:50.38,English,,0,0,0,,But it's not very common it just it happened 1,2,3,4,5,6,7 times
Dialogue: 0,1:08:44.40,1:08:50.38,Chinese,,0,0,0,,但它并不常见，只发生了1,2,3,4,5,6,7次
Dialogue: 0,1:08:51.46,1:08:54.76,English,,0,0,0,,But now if we run this program on a multi-core server
Dialogue: 0,1:08:51.46,1:08:54.76,Chinese,,0,0,0,,但现在如果我们在多核服务器上运行这个程序
Dialogue: 0,1:08:55.48,1:08:58.30,English,,0,0,0,,You can see it happens a lot in fact it happens most of the time
Dialogue: 0,1:08:55.48,1:08:58.30,Chinese,,0,0,0,,你可以看到它发生了很多事实上它发生在大多数时间
Dialogue: 0,1:08:58.68,1:09:04.60,English,,0,0,0,,So it almost never get the correct value for for myid
Dialogue: 0,1:08:58.68,1:09:04.60,Chinese,,0,0,0,,所以它几乎永远不会得到myid的正确值
Dialogue: 0,1:09:06.80,1:09:11.38,English,,0,0,0,,Okay so this is just another example of some of the create the things that can just drive you crazy
Dialogue: 0,1:09:06.80,1:09:11.38,Chinese,,0,0,0,,好的，所以这只是一些创造可以让你发疯的东西的另一个例子
Dialogue: 0,1:09:12.04,1:09:15.78,English,,0,0,0,,If you're not careful when you program is and threads with threads
Dialogue: 0,1:09:12.04,1:09:15.78,Chinese,,0,0,0,,如果你编程的时候不小心，那么线程就是线程
Dialogue: 0,1:09:18.36,1:09:24.82,English,,0,0,0,,Okay and as so as we saw the the way to eliminate these kind of erases  is to avoid
Dialogue: 0,1:09:18.36,1:09:24.82,Chinese,,0,0,0,,好的，正如我们所看到的，消除这种擦除的方法是避免
Dialogue: 0,1:09:25.82,1:09:30.06,English,,0,0,0,,This the sharing of state and in this case by allocating
Dialogue: 0,1:09:25.82,1:09:30.06,Chinese,,0,0,0,,这是国家的共享，在这种情况下通过分配
Dialogue: 0,1:09:31.08,1:09:35.31,English,,0,0,0,,For each thread allocating a separate block in the heap
Dialogue: 0,1:09:31.08,1:09:35.31,Chinese,,0,0,0,,为每个线程在堆中分配一个单独的块
Dialogue: 0,1:09:35.68,1:09:40.44,English,,0,0,0,,That will hold the local id for that thread
Dialogue: 0,1:09:35.68,1:09:40.44,Chinese,,0,0,0,,这将保存该线程的本地ID
Dialogue: 0,1:09:40.88,1:09:47.60,English,,0,0,0,,And then passing a pointer to that unique block of storage to the thread
Dialogue: 0,1:09:40.88,1:09:47.60,Chinese,,0,0,0,,然后将指向该唯一存储块的指针传递给线程
Dialogue: 0,1:09:51.16,1:09:54.14,English,,0,0,0,,Okay so if that if all of that isn't enough to worry about
Dialogue: 0,1:09:51.16,1:09:54.14,Chinese,,0,0,0,,好的，如果这样的话，如果所有这些都不足以担心
Dialogue: 0,1:09:55.58,1:09:57.22,English,,0,0,0,,And by now you should be losing sleep
Dialogue: 0,1:09:55.58,1:09:57.22,Chinese,,0,0,0,,到现在为止你应该失眠了
Dialogue: 0,1:09:58.60,1:10:01.42,English,,0,0,0,,At the very thought of writing a threaded program
Dialogue: 0,1:09:58.60,1:10:01.42,Chinese,,0,0,0,,在想到编写线程程序时
Dialogue: 0,1:10:02.02,1:10:04.10,English,,0,0,0,,Another thing to worry about is deadlock
Dialogue: 0,1:10:02.02,1:10:04.10,Chinese,,0,0,0,,另一件需要担心的事情是死锁
Dialogue: 0,1:10:06.70,1:10:13.56,English,,0,0,0,,Okay so here a program is deadlocked if it's waiting for some condition to occur that will never occur
Dialogue: 0,1:10:06.70,1:10:13.56,Chinese,,0,0,0,,好的，所以这里的程序如果等待某些条件永远不会发生就会陷入僵局
Dialogue: 0,1:10:18.16,1:10:21.28,English,,0,0,0,,Okay so let's say a typical scenario right p
Dialogue: 0,1:10:18.16,1:10:21.28,Chinese,,0,0,0,,好的，让我们说一个典型的情景吧
Dialogue: 0,1:10:22.30,1:10:26.16,English,,0,0,0,,p is the potential the p operation is a potential problem because it blocks
Dialogue: 0,1:10:22.30,1:10:26.16,Chinese,,0,0,0,,p是p操作潜在的问题，因为它会阻塞
Dialogue: 0,1:10:27.64,1:10:31.70,English,,0,0,0,,Right and it's waiting for that semaphore that it's blocking on to become nonzero
Dialogue: 0,1:10:27.64,1:10:31.70,Chinese,,0,0,0,,是的，它正在等待那个被阻塞的信号量变为非零
Dialogue: 0,1:10:33.84,1:10:36.94,English,,0,0,0,,Well it's not too hard to imagine scenarios where
Dialogue: 0,1:10:33.84,1:10:36.94,Chinese,,0,0,0,,那么想象其中的场景并不难
Dialogue: 0,1:10:37.96,1:10:44.38,English,,0,0,0,,Some there's some combination of pees of pee operations that sort of block each other
Dialogue: 0,1:10:37.96,1:10:44.38,Chinese,,0,0,0,,有些小便操作的小便组合相互阻挡
Dialogue: 0,1:10:44.92,1:10:49.00,English,,0,0,0,,Okay and make it impossible for the condition they're waiting on to occur
Dialogue: 0,1:10:44.92,1:10:49.00,Chinese,,0,0,0,,好吧，让他们等待的情况不可能发生
Dialogue: 0,1:10:49.98,1:10:54.44,English,,0,0,0,,So for example let's say you've got two threads
Dialogue: 0,1:10:49.98,1:10:54.44,Chinese,,0,0,0,,例如，假设你有两个线程
Dialogue: 0,1:10:55.08,1:10:58.56,English,,0,0,0,,That need two threads one and two
Dialogue: 0,1:10:55.08,1:10:58.56,Chinese,,0,0,0,,这需要两个线程一和二
Dialogue: 0,1:10:59.22,1:11:03.18,English,,0,0,0,,That need two different resources A and B in order to proceed
Dialogue: 0,1:10:59.22,1:11:03.18,Chinese,,0,0,0,,这需要两个不同的资源A和B才能继续
Dialogue: 0,1:11:03.18,1:11:06.88,English,,0,0,0,,So they have to acquire they have to do a pee on the mutex
Dialogue: 0,1:11:03.18,1:11:06.88,Chinese,,0,0,0,,因此他们必须获得他们必须对互斥体进行小便
Dialogue: 0,1:11:07.00,1:11:10.76,English,,0,0,0,,That on the mutex that that's associated with
Dialogue: 0,1:11:07.00,1:11:10.76,Chinese,,0,0,0,,这与那与之相关的互斥量有关
Dialogue: 0,1:11:12.16,1:11:14.92,English,,0,0,0,,The mutexes that are associated with these two resources
Dialogue: 0,1:11:12.16,1:11:14.92,Chinese,,0,0,0,,与这两个资源关联的互斥锁
Dialogue: 0,1:11:16.64,1:11:22.32,English,,0,0,0,,So let's say process one acquires A so it does a pee on A mutex
Dialogue: 0,1:11:16.64,1:11:22.32,Chinese,,0,0,0,,因此，假设进程1获取A，因此它会对A互斥量进行小便
Dialogue: 0,1:11:23.94,1:11:28.50,English,,0,0,0,,That's one ,it's okay,so it acquires that resource
Dialogue: 0,1:11:23.94,1:11:28.50,Chinese,,0,0,0,,这是一个，没关系，所以它获得了那个资源
Dialogue: 0,1:11:30.04,1:11:33.38,English,,0,0,0,,And then it gets preempted by thread 2
Dialogue: 0,1:11:30.04,1:11:33.38,Chinese,,0,0,0,,然后它被线程2抢占
Dialogue: 0,1:11:34.06,1:11:35.28,English,,0,0,0,,Which acquires B
Dialogue: 0,1:11:34.06,1:11:35.28,Chinese,,0,0,0,,获得B
Dialogue: 0,1:11:36.74,1:11:41.14,English,,0,0,0,,First instead of acquiring A thread B for some reason acquires B
Dialogue: 0,1:11:36.74,1:11:41.14,Chinese,,0,0,0,,首先取代获取A线程B由于某种原因获得B.
Dialogue: 0,1:11:42.20,1:11:46.06,English,,0,0,0,,So now thread A holds the lock on resource A
Dialogue: 0,1:11:42.20,1:11:46.06,Chinese,,0,0,0,,所以现在线程A保持对资源A的锁定
Dialogue: 0,1:11:47.08,1:11:49.78,English,,0,0,0,,And thread 2 holds the lock on resource B
Dialogue: 0,1:11:47.08,1:11:49.78,Chinese,,0,0,0,,并且线程2保持对资源B的锁定
Dialogue: 0,1:11:52.08,1:11:56.06,English,,0,0,0,,And so now let's say process thread 2 gets preempted so now
Dialogue: 0,1:11:52.08,1:11:56.06,Chinese,,0,0,0,,所以现在让我们说流程线程2现在被抢占了
Dialogue: 0,1:11:56.88,1:11:59.18,English,,0,0,0,,And thread one runs and so now it's waiting
Dialogue: 0,1:11:56.88,1:11:59.18,Chinese,,0,0,0,,线程一运行，所以现在它正在等待
Dialogue: 0,1:12:00.60,1:12:02.32,English,,0,0,0,,It's trying to tries to acquire
Dialogue: 0,1:12:00.60,1:12:02.32,Chinese,,0,0,0,,它试图获得
Dialogue: 0,1:12:03.18,1:12:05.36,English,,0,0,0,,The the lock on resource B
Dialogue: 0,1:12:03.18,1:12:05.36,Chinese,,0,0,0,,资源B的锁定
Dialogue: 0,1:12:07.08,1:12:09.08,English,,0,0,0,,But threat to our holds that lock
Dialogue: 0,1:12:07.08,1:12:09.08,Chinese,,0,0,0,,但对我们持有的威胁锁定
Dialogue: 0,1:12:10.54,1:12:15.02,English,,0,0,0,,And at the same time thread 2 tries to acquire the lock on resource A
Dialogue: 0,1:12:10.54,1:12:15.02,Chinese,,0,0,0,,同时线程2尝试获取资源A上的锁
Dialogue: 0,1:12:17.04,1:12:18.64,English,,0,0,0,,But process one is holding that right
Dialogue: 0,1:12:17.04,1:12:18.64,Chinese,,0,0,0,,但是过程一是坚持这一点
Dialogue: 0,1:12:18.72,1:12:25.22,English,,0,0,0,,So they're each so here's the case where thread A is waiting for this semaphore
Dialogue: 0,1:12:18.72,1:12:25.22,Chinese,,0,0,0,,所以他们每个人都是这样，线程A正在等待这个信号量
Dialogue: 0,1:12:26.02,1:12:28.52,English,,0,0,0,,Associated with B to become nonzero
Dialogue: 0,1:12:26.02,1:12:28.52,Chinese,,0,0,0,,与B相关成为非零
Dialogue: 0,1:12:29.36,1:12:31.46,English,,0,0,0,,So it's blocked in this p operation
Dialogue: 0,1:12:29.36,1:12:31.46,Chinese,,0,0,0,,所以它在这个p操作中被阻止了
Dialogue: 0,1:12:32.10,1:12:39.60,English,,0,0,0,,And at the same time thread 2 is blocked in the p operation for resource A
Dialogue: 0,1:12:32.10,1:12:39.60,Chinese,,0,0,0,,同时，线程2在资源A的p操作中被阻塞
Dialogue: 0,1:12:40.76,1:12:44.22,English,,0,0,0,,Neither of those semaphores will ever be released
Dialogue: 0,1:12:40.76,1:12:44.22,Chinese,,0,0,0,,这些信号量都不会被释放
Dialogue: 0,1:12:44.70,1:12:46.86,English,,0,0,0,,So thread 1 and 2 are deadlocked
Dialogue: 0,1:12:44.70,1:12:46.86,Chinese,,0,0,0,,所以线程1和2都是死锁的
Dialogue: 0,1:12:49.70,1:12:55.38,English,,0,0,0,,Okay and it happened because just there was this innocuous little bug in this case
Dialogue: 0,1:12:49.70,1:12:55.38,Chinese,,0,0,0,,好吧，它发生了，因为在这种情况下只有这个无害的小虫子
Dialogue: 0,1:12:55.92,1:12:59.04,English,,0,0,0,,Where one the threads acquired their resources in different orders
Dialogue: 0,1:12:55.92,1:12:59.04,Chinese,,0,0,0,,其中一个线程以不同的顺序获取其资源
Dialogue: 0,1:13:05.62,1:13:08.78,English,,0,0,0,,So here's an example of a program that deadlocks
Dialogue: 0,1:13:05.62,1:13:08.78,Chinese,,0,0,0,,所以这是一个死锁程序的例子
Dialogue: 0,1:13:08.98,1:13:14.78,English,,0,0,0,,And if you looked at this you know the fact that it's wrong and bug doesn't jump out at you right
Dialogue: 0,1:13:08.98,1:13:14.78,Chinese,,0,0,0,,如果你看着这个，你就会知道这是错误的，并且bug不会向你跳出来
Dialogue: 0,1:13:14.82,1:13:17.86,English,,0,0,0,,So this kind of stuff is very subtle
Dialogue: 0,1:13:14.82,1:13:17.86,Chinese,,0,0,0,,所以这种东西非常微妙
Dialogue: 0,1:13:17.86,1:13:22.22,English,,0,0,0,,So here's a program we're going to create two threads
Dialogue: 0,1:13:17.86,1:13:22.22,Chinese,,0,0,0,,所以这是一个我们要创建两个线程的程序
Dialogue: 0,1:13:24.52,1:13:29.12,English,,0,0,0,,We've got an array so and we have an array of mutexes
Dialogue: 0,1:13:24.52,1:13:29.12,Chinese,,0,0,0,,我们有一个数组，我们有一系列互斥体
Dialogue: 0,1:13:31.64,1:13:33.28,English,,0,0,0,,An array of two mutexes
Dialogue: 0,1:13:31.64,1:13:33.28,Chinese,,0,0,0,,一组两个互斥体
Dialogue: 0,1:13:34.58,1:13:38.62,English,,0,0,0,,So we create two threads and we pass each thread
Dialogue: 0,1:13:34.58,1:13:38.62,Chinese,,0,0,0,,所以我们创建两个线程，然后传递每个线程
Dialogue: 0,1:13:39.16,1:13:42.86,English,,0,0,0,,It's a local thread id so of 0 and 1
Dialogue: 0,1:13:39.16,1:13:42.86,Chinese,,0,0,0,,它是0和1的本地线程ID
Dialogue: 0,1:13:43.70,1:13:49.56,English,,0,0,0,,And so here we're avoiding the race we're just casting this thread id to a pointer okay
Dialogue: 0,1:13:43.70,1:13:49.56,Chinese,,0,0,0,,所以我们在这里避免竞争我们只是将这个线程id转换为指针好了
Dialogue: 0,1:13:49.96,1:13:52.52,English,,0,0,0,,Which is a little strange but it's okay
Dialogue: 0,1:13:49.96,1:13:52.52,Chinese,,0,0,0,,这有点奇怪，但没关系
Dialogue: 0,1:13:53.38,1:13:55.26,English,,0,0,0,,And then we're waiting for those threads to finish
Dialogue: 0,1:13:53.38,1:13:55.26,Chinese,,0,0,0,,然后我们等待那些线程完成
Dialogue: 0,1:13:57.62,1:14:05.60,English,,0,0,0,,Ok each thread is going to acquire two these two semaphores
Dialogue: 0,1:13:57.62,1:14:05.60,Chinese,,0,0,0,,好吧，每个线程将获得两个这两个信号量
Dialogue: 0,1:14:06.18,1:14:07.60,English,,0,0,0,,These two mutexes
Dialogue: 0,1:14:06.18,1:14:07.60,Chinese,,0,0,0,,这两个互斥体
Dialogue: 0,1:14:08.78,1:14:10.78,English,,0,0,0,,But it's going to do it in a different order
Dialogue: 0,1:14:08.78,1:14:10.78,Chinese,,0,0,0,,但它会以不同的顺序进行
Dialogue: 0,1:14:14.94,1:14:18.44,English,,0,0,0,,Okay so it's going to do it as a function it's going to take the id
Dialogue: 0,1:14:14.94,1:14:18.44,Chinese,,0,0,0,,好的，所以它将作为一个功能它将采取id
Dialogue: 0,1:14:18.44,1:14:22.40,English,,0,0,0,,So it's going to...so thread 0 will first acquire a mutex 0
Dialogue: 0,1:14:18.44,1:14:22.40,Chinese,,0,0,0,,所以它将...所以线程0将首先获得互斥锁0
Dialogue: 0,1:14:23.82,1:14:27.68,English,,0,0,0,,And then acquire mutex 1-0
Dialogue: 0,1:14:23.82,1:14:27.68,Chinese,,0,0,0,,然后以1-0获得互斥量
Dialogue: 0,1:14:27.68,1:14:29.70,English,,0,0,0,,So then it will acquire mutex 1
Dialogue: 0,1:14:27.68,1:14:29.70,Chinese,,0,0,0,,那么它将获得互斥锁1
Dialogue: 0,1:14:31.50,1:14:36.20,English,,0,0,0,,And thread 1 will first acquire mutex 1
Dialogue: 0,1:14:31.50,1:14:36.20,Chinese,,0,0,0,,并且线程1将首先获取互斥锁1
Dialogue: 0,1:14:36.98,1:14:38.56,English,,0,0,0,,And then acquire mutex 0
Dialogue: 0,1:14:36.98,1:14:38.56,Chinese,,0,0,0,,然后获取互斥锁0
Dialogue: 0,1:14:41.86,1:14:46.98,English,,0,0,0,,Ok so if we were to draw that diet,and then it will attempt to then it will increment count
Dialogue: 0,1:14:41.86,1:14:46.98,Chinese,,0,0,0,,好的，如果我们要画出那种饮食，那么它会尝试它会增加计数
Dialogue: 0,1:14:47.36,1:14:48.50,English,,0,0,0,,So this is totally bogus
Dialogue: 0,1:14:47.36,1:14:48.50,Chinese,,0,0,0,,所以这完全是假的
Dialogue: 0,1:14:48.66,1:14:51.34,English,,0,0,0,,But it's just to illustrate the problem
Dialogue: 0,1:14:48.66,1:14:51.34,Chinese,,0,0,0,,但这只是为了说明问题
Dialogue: 0,1:14:52.74,1:14:58.08,English,,0,0,0,,So you can see thread 0 does a P semaphore 0 followed by a P semaphore 1
Dialogue: 0,1:14:52.74,1:14:58.08,Chinese,,0,0,0,,所以你可以看到线程0有一个P信号量0后跟一个P信号量1
Dialogue: 0,1:14:58.86,1:15:01.30,English,,0,0,0,,And thread 1 does a P semaphore 1
Dialogue: 0,1:14:58.86,1:15:01.30,Chinese,,0,0,0,,并且线程1执行P信号量1
Dialogue: 0,1:15:01.98,1:15:03.92,English,,0,0,0,,Followed by a P semaphore 0
Dialogue: 0,1:15:01.98,1:15:03.92,Chinese,,0,0,0,,其次是P信号量0
Dialogue: 0,1:15:06.50,1:15:10.22,English,,0,0,0,,And so we can see this,that this is a problem very clearly
Dialogue: 0,1:15:06.50,1:15:10.22,Chinese,,0,0,0,,所以我们可以看到这一点，这是一个非常清楚的问题
Dialogue: 0,1:15:10.42,1:15:12.52,English,,0,0,0,,If we go back to a progress graphs
Dialogue: 0,1:15:10.42,1:15:12.52,Chinese,,0,0,0,,如果我们回到进度图表
Dialogue: 0,1:15:17.08,1:15:19.40,English,,0,0,0,,So if you look at thread 0
Dialogue: 0,1:15:17.08,1:15:19.40,Chinese,,0,0,0,,所以如果你看一下线程0
Dialogue: 0,1:15:20.36,1:15:22.42,English,,0,0,0,,It's doing a P semaphore 1
Dialogue: 0,1:15:20.36,1:15:22.42,Chinese,,0,0,0,,它正在做一个P信号量1
Dialogue: 0,1:15:22.90,1:15:28.22,English,,0,0,0,,And of and it followed a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:22.90,1:15:28.22,Chinese,,0,0,0,,并且它遵循P信号量1，接着是信号量1上的V.
Dialogue: 0,1:15:30.82,1:15:35.94,English,,0,0,0,,And thread 1 is also is doing a P semaphore 1 followed by a V on semaphore 1
Dialogue: 0,1:15:30.82,1:15:35.94,Chinese,,0,0,0,,并且线程1也正在执行P信号量1，然后是信号量1上的V.
Dialogue: 0,1:15:36.64,1:15:44.20,English,,0,0,0,,So if you take the intersection of these two regions
Dialogue: 0,1:15:36.64,1:15:44.20,Chinese,,0,0,0,,所以，如果你采取这两个区域的交集
Dialogue: 0,1:15:45.00,1:15:47.92,English,,0,0,0,,You get the forbidden region for semaphore 1
Dialogue: 0,1:15:45.00,1:15:47.92,Chinese,,0,0,0,,你得到了信号量1的禁区
Dialogue: 0,1:15:48.04,1:15:51.20,English,,0,0,0,,Okay so this is the region that enforces mutual exclusion
Dialogue: 0,1:15:48.04,1:15:51.20,Chinese,,0,0,0,,好的，这是强制互斥的地区
Dialogue: 0,1:15:51.90,1:15:56.00,English,,0,0,0,,So on this the resource associated with semaphore 1
Dialogue: 0,1:15:51.90,1:15:56.00,Chinese,,0,0,0,,所以在这个与信号量1相关的资源上
Dialogue: 0,1:15:58.78,1:16:02.54,English,,0,0,0,,And if you do the same thing for semaphore 0 so here in thread 1
Dialogue: 0,1:15:58.78,1:16:02.54,Chinese,,0,0,0,,如果你对信号量0做同样的事情，那么在线程1中
Dialogue: 0,1:16:03.20,1:16:06.26,English,,0,0,0,,We're acquiring semaphore 0 here and releasing it here
Dialogue: 0,1:16:03.20,1:16:06.26,Chinese,,0,0,0,,我们在这里获取信号量0并在此处发布
Dialogue: 0,1:16:07.72,1:16:12.82,English,,0,0,0,,And in thread 0 we're acquiring it here and releasing it here
Dialogue: 0,1:16:07.72,1:16:12.82,Chinese,,0,0,0,,在线程0中，我们在这里获取并在此处发布它
Dialogue: 0,1:16:13.96,1:16:16.02,English,,0,0,0,,So if you take the intersection of those two
Dialogue: 0,1:16:13.96,1:16:16.02,Chinese,,0,0,0,,所以如果你采取这两者的交集
Dialogue: 0,1:16:16.66,1:16:19.84,English,,0,0,0,,You get this forbidden region for S(0)
Dialogue: 0,1:16:16.66,1:16:19.84,Chinese,,0,0,0,,你得到S（0）这个禁区
Dialogue: 0,1:16:21.66,1:16:22.84,English,,0,0,0,,Ok now the problem
Dialogue: 0,1:16:21.66,1:16:22.84,Chinese,,0,0,0,,好现在问题
Dialogue: 0,1:16:26.86,1:16:31.22,English,,0,0,0,,is right is this region here this so-called deadlock region
Dialogue: 0,1:16:26.86,1:16:31.22,Chinese,,0,0,0,,这是所谓的死锁区域
Dialogue: 0,1:16:33.74,1:16:35.42,English,,0,0,0,,Because by the rules of
Dialogue: 0,1:16:33.74,1:16:35.42,Chinese,,0,0,0,,因为遵守规则
Dialogue: 0,1:16:36.58,1:16:37.98,English,,0,0,0,,You know time can't go backwards
Dialogue: 0,1:16:36.58,1:16:37.98,Chinese,,0,0,0,,你知道时间不能倒退
Dialogue: 0,1:16:40.82,1:16:44.16,English,,0,0,0,,Heart once the trajectory enters into the this deadlock region
Dialogue: 0,1:16:40.82,1:16:44.16,Chinese,,0,0,0,,一旦轨迹进入该死锁区域，就会产生心脏
Dialogue: 0,1:16:45.08,1:16:45.88,English,,0,0,0,,Then it's doomed
Dialogue: 0,1:16:45.08,1:16:45.88,Chinese,,0,0,0,,然后它就注定了
Dialogue: 0,1:16:46.48,1:16:49.68,English,,0,0,0,,Because there's no once it enters this
Dialogue: 0,1:16:46.48,1:16:49.68,Chinese,,0,0,0,,因为没有一次它进入这个
Dialogue: 0,1:16:50.64,1:16:54.54,English,,0,0,0,,Once it enters this deadlock region there's nowhere for it to go eventually
Dialogue: 0,1:16:50.64,1:16:54.54,Chinese,,0,0,0,,一旦它进入这个死锁区域，它最终无处可去
Dialogue: 0,1:16:55.60,1:16:57.26,English,,0,0,0,,No matter how it progresses
Dialogue: 0,1:16:55.60,1:16:57.26,Chinese,,0,0,0,,无论它如何进展
Dialogue: 0,1:16:57.82,1:17:01.24,English,,0,0,0,,Every trajectory will lead to this point here where
Dialogue: 0,1:16:57.82,1:17:01.24,Chinese,,0,0,0,,每条轨迹都会在这里引出这一点
Dialogue: 0,1:17:01.36,1:17:04.66,English,,0,0,0,,It's boxed in and can no longer proceed
Dialogue: 0,1:17:01.36,1:17:04.66,Chinese,,0,0,0,,它装箱了，不能再继续了
Dialogue: 0,1:17:11.20,1:17:12.06,English,,0,0,0,,So
Dialogue: 0,1:17:11.20,1:17:12.06,Chinese,,0,0,0,,所以
Dialogue: 0,1:17:15.34,1:17:19.08,English,,0,0,0,,So interestingly this sort of this region back here
Dialogue: 0,1:17:15.34,1:17:19.08,Chinese,,0,0,0,,有趣的是，这个地区就在这里
Dialogue: 0,1:17:20.02,1:17:24.98,English,,0,0,0,,On the sort of the tail end of the of these two forbidden regions
Dialogue: 0,1:17:20.02,1:17:24.98,Chinese,,0,0,0,,关于这两个禁区的尾端
Dialogue: 0,1:17:25.66,1:17:27.98,English,,0,0,0,,This represents states that can never be reached
Dialogue: 0,1:17:25.66,1:17:27.98,Chinese,,0,0,0,,这表示永远无法达到的状态
Dialogue: 0,1:17:28.26,1:17:32.44,English,,0,0,0,,So these are on unreachable states which may or may not be interesting
Dialogue: 0,1:17:28.26,1:17:32.44,Chinese,,0,0,0,,所以这些是无法接触的状态，可能有趣也可能没有
Dialogue: 0,1:17:33.68,1:17:35.44,English,,0,0,0,,And then what makes this so nasty
Dialogue: 0,1:17:33.68,1:17:35.44,Chinese,,0,0,0,,然后是什么让这么讨厌
Dialogue: 0,1:17:36.96,1:17:37.76,English,,0,0,0,,Is that
Dialogue: 0,1:17:36.96,1:17:37.76,Chinese,,0,0,0,,就是它
Dialogue: 0,1:17:39.26,1:17:42.68,English,,0,0,0,,It's non-deterministic right some programs some trajectories
Dialogue: 0,1:17:39.26,1:17:42.68,Chinese,,0,0,0,,一些程序的某些轨迹是不确定的
Dialogue: 0,1:17:44.28,1:17:47.36,English,,0,0,0,,If they get lucky they'll skirt this deadlock region
Dialogue: 0,1:17:44.28,1:17:47.36,Chinese,,0,0,0,,如果他们幸运的话，他们会绕过这个僵局
Dialogue: 0,1:17:48.44,1:17:50.66,English,,0,0,0,,And then the program will run fine right
Dialogue: 0,1:17:48.44,1:17:50.66,Chinese,,0,0,0,,然后程序运行正常
Dialogue: 0,1:17:52.94,1:17:55.58,English,,0,0,0,,There's okay so if it's trajectory maybe
Dialogue: 0,1:17:52.94,1:17:55.58,Chinese,,0,0,0,,没关系，如果它的轨迹可能
Dialogue: 0,1:17:57.50,1:18:01.56,English,,0,0,0,,Just by some you know just by some arbitrary scheduling decision
Dialogue: 0,1:17:57.50,1:18:01.56,Chinese,,0,0,0,,只是由一些人知道，只是通过一些任意的调度决定
Dialogue: 0,1:18:01.90,1:18:11.66,English,,0,0,0,,Made by the kernel the trajectory gets passed the deadlock region in this direction
Dialogue: 0,1:18:01.90,1:18:11.66,Chinese,,0,0,0,,由内核制作，轨迹在此方向上通过死锁区域
Dialogue: 0,1:18:13.00,1:18:16.98,English,,0,0,0,,And then it'll eventually run without any problem
Dialogue: 0,1:18:13.00,1:18:16.98,Chinese,,0,0,0,,然后它最终会毫无问题地运行
Dialogue: 0,1:18:17.84,1:18:25.46,English,,0,0,0,,So it's just it's only if the trajectory lands it within the deadlock region then there were that we're in trouble
Dialogue: 0,1:18:17.84,1:18:25.46,Chinese,,0,0,0,,因此，只有当轨迹落在死锁区域内时，才会发现我们遇到了麻烦
Dialogue: 0,1:18:26.76,1:18:34.78,English,,0,0,0,,So this is the really nasty, the really nasty part is that you may run your program for a million times and every trajectory
Dialogue: 0,1:18:26.76,1:18:34.78,Chinese,,0,0,0,,所以这真是讨厌，真正令人讨厌的部分是你可以运行你的程序一百万次和每一个轨迹
Dialogue: 0,1:18:36.76,1:18:40.54,English,,0,0,0,,Every one of those million trajectories skirts the deadlock region
Dialogue: 0,1:18:36.76,1:18:40.54,Chinese,,0,0,0,,这些百万条轨道中的每一条都绕过了僵局区域
Dialogue: 0,1:18:41.40,1:18:43.76,English,,0,0,0,,Okay but on the million and first time that you run it
Dialogue: 0,1:18:41.40,1:18:43.76,Chinese,,0,0,0,,好的，但是在第一次运行它的时候是百万
Dialogue: 0,1:18:44.50,1:18:47.50,English,,0,0,0,,It enters the deadlock region and then deadlocks
Dialogue: 0,1:18:44.50,1:18:47.50,Chinese,,0,0,0,,它进入死锁区域然后死锁
Dialogue: 0,1:18:50.60,1:18:53.72,English,,0,0,0,,Okay so it's very it's a very tough problem to deal with
Dialogue: 0,1:18:50.60,1:18:53.72,Chinese,,0,0,0,,好的，这是一个非常难以处理的问题
Dialogue: 0,1:18:55.06,1:18:57.80,English,,0,0,0,,Now fortunately you it's easy to avoid
Dialogue: 0,1:18:55.06,1:18:57.80,Chinese,,0,0,0,,幸运的是，你很容易避免
Dialogue: 0,1:18:58.94,1:19:07.32,English,,0,0,0,,If threads that are acquiring locks on resources acquire all those locks in the same order
Dialogue: 0,1:18:58.94,1:19:07.32,Chinese,,0,0,0,,如果获取资源锁的线程以相同的顺序获取所有这些锁
Dialogue: 0,1:19:07.66,1:19:11.78,English,,0,0,0,,Okay so in our example if we rewrite this program
Dialogue: 0,1:19:07.66,1:19:11.78,Chinese,,0,0,0,,好的，在我们的例子中，如果我们重写这个程序
Dialogue: 0,1:19:11.86,1:19:17.42,English,,0,0,0,,So that each thread 0 and thread 1 acquire their locks in the same order
Dialogue: 0,1:19:11.86,1:19:17.42,Chinese,,0,0,0,,这样每个线程0和线程1以相同的顺序获取它们的锁
Dialogue: 0,1:19:18.36,1:19:22.08,English,,0,0,0,,Semaphore 0 first followed by semaphore 1
Dialogue: 0,1:19:18.36,1:19:22.08,Chinese,,0,0,0,,信号量0首先跟随信号量1
Dialogue: 0,1:19:25.00,1:19:28.72,English,,0,0,0,,Then if that happens and we you can see
Dialogue: 0,1:19:25.00,1:19:28.72,Chinese,,0,0,0,,如果发生这种情况，我们就可以看到
Dialogue: 0,1:19:28.96,1:19:31.70,English,,0,0,0,,It eliminates the potential deadlock region
Dialogue: 0,1:19:28.96,1:19:31.70,Chinese,,0,0,0,,它消除了潜在的死锁区域
Dialogue: 0,1:19:35.76,1:19:39.40,English,,0,0,0,,Okay so now any trajectory that we take 
Dialogue: 0,1:19:35.76,1:19:39.40,Chinese,,0,0,0,,好的，现在我们采取的任何轨迹
Dialogue: 0,1:19:44.78,1:19:49.42,English,,0,0,0,,Will be fine because we've eliminated that that that deadlock region
Dialogue: 0,1:19:44.78,1:19:49.42,Chinese,,0,0,0,,会没事的，因为我们已经消除了那个死锁区域
Dialogue: 0,1:19:50.12,1:19:53.44,English,,0,0,0,,And the order that we release the locks doesn't matter
Dialogue: 0,1:19:50.12,1:19:53.44,Chinese,,0,0,0,,我们释放锁的顺序无关紧要
Dialogue: 0,1:19:53.44,1:19:57.50,English,,0,0,0,,Because that sort of affects the
Dialogue: 0,1:19:53.44,1:19:57.50,Chinese,,0,0,0,,因为那种影响了
Dialogue: 0,1:20:00.38,1:20:06.10,English,,0,0,0,,It affects this or unreachable region you know the size and shape of this unreachable region
Dialogue: 0,1:20:00.38,1:20:06.10,Chinese,,0,0,0,,它会影响这个或无法到达的区域，你知道这个无法到达的区域的大小和形状
Dialogue: 0,1:20:08.02,1:20:13.68,English,,0,0,0,,But it there's never the order that we release the locks can never introduce a deadlock region
Dialogue: 0,1:20:08.02,1:20:13.68,Chinese,,0,0,0,,但是从来没有我们发布锁定的命令永远不会引入死锁区域
Dialogue: 0,1:20:17.66,1:20:19.20,English,,0,0,0,,Okay so that's it for today
Dialogue: 0,1:20:17.66,1:20:19.20,Chinese,,0,0,0,,好的，这就是今天的情况
Dialogue: 0,1:20:22.40,1:20:29.44,English,,0,0,0,,hope you all have a very nice Thanksgiving holiday and we'll see you on Tuesday
Dialogue: 0,1:20:22.40,1:20:29.44,Chinese,,0,0,0,,希望你们都有一个非常愉快的感恩节假期，我们会在周二见到你
