[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video File: ../../../../Desktop/csapp/Lecture 17  Virtual Memory  Concepts.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 742
Active Line: 751
Video Position: 127862

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.44,English,,0,0,0,,Good afternoon everybody
Dialogue: 0,0:00:00.06,0:00:01.44,Chinese,,0,0,0,,大家下午好
Dialogue: 0,0:00:02.24,0:00:03.90,English,,0,0,0,,Welcome good to see you as always
Dialogue: 0,0:00:02.24,0:00:03.90,Chinese,,0,0,0,,欢迎一如既往地见到你
Dialogue: 0,0:00:06.08,0:00:12.46,English,,0,0,0,,Today we're going to learn about a important concept in computer science called virtual memory
Dialogue: 0,0:00:06.08,0:00:12.46,Chinese,,0,0,0,,今天我们将学习计算机科学中一个称为虚拟内存的重要概念
Dialogue: 0,0:00:18.86,0:00:23.43,English,,0,0,0,,So consider a system that uses physical addressing
Dialogue: 0,0:00:18.86,0:00:23.43,Chinese,,0,0,0,,因此，请考虑使用物理寻址的系统
Dialogue: 0,0:00:23.43,0:00:31.34,English,,0,0,0,,Right we've always idea about memory so far has been that it's a contiguous array of physical bytes
Dialogue: 0,0:00:23.43,0:00:31.34,Chinese,,0,0,0,,我们总是对内存有所了解，因为它是一个连续的物理字节数组
Dialogue: 0,0:00:31.90,0:00:37.08,English,,0,0,0,,That we can access just by giving some an offset called an address
Dialogue: 0,0:00:31.90,0:00:37.08,Chinese,,0,0,0,,我们可以通过给出一些称为地址的偏移来访问
Dialogue: 0,0:00:38.38,0:00:41.12,English,,0,0,0,,So in a system that uses physical addressing
Dialogue: 0,0:00:38.38,0:00:41.12,Chinese,,0,0,0,,所以在使用物理寻址的系统中
Dialogue: 0,0:00:43.34,0:00:46.91,English,,0,0,0,,The CPU executes like say a move instruction
Dialogue: 0,0:00:43.34,0:00:46.91,Chinese,,0,0,0,,CPU执行就像移动指令一样
Dialogue: 0,0:00:47.54,0:00:50.74,English,,0,0,0,,Which generates an effective address,the physical address
Dialogue: 0,0:00:47.54,0:00:50.74,Chinese,,0,0,0,,其中生成有效地址，物理地址
Dialogue: 0,0:00:51.12,0:00:55.42,English,,0,0,0,,And this address is actually the offset of a byte in main memory so
Dialogue: 0,0:00:51.12,0:00:55.42,Chinese,,0,0,0,,而这个地址实际上是主存储器中一个字节的偏移量
Dialogue: 0,0:00:56.22,0:01:00.22,English,,0,0,0,,You know here the CPU has generated a physical address of 4
Dialogue: 0,0:00:56.22,0:01:00.22,Chinese,,0,0,0,,你知道CPU在这里生成了4的物理地址
Dialogue: 0,0:01:01.86,0:01:04.06,English,,0,0,0,,Since that address to the memory
Dialogue: 0,0:01:01.86,0:01:04.06,Chinese,,0,0,0,,从那个地址到内存
Dialogue: 0,0:01:05.72,0:01:13.20,English,,0,0,0,,And then the memory fetches the word from at that address and then sends it back to the CPU
Dialogue: 0,0:01:05.72,0:01:13.20,Chinese,,0,0,0,,然后内存从该地址获取该字，然后将其发送回CPU
Dialogue: 0,0:01:15.84,0:01:20.40,English,,0,0,0,,Now this is in fact the way that very simple microcontrollers work
Dialogue: 0,0:01:15.84,0:01:20.40,Chinese,,0,0,0,,实际上，这是非常简单的微控制器工作的方式
Dialogue: 0,0:01:20.96,0:01:27.56,English,,0,0,0,,But it's not the way most systems work including your phones, your desktops,your servers
Dialogue: 0,0:01:20.96,0:01:27.56,Chinese,,0,0,0,,但这并不是大多数系统的工作方式，包括手机，台式机和服务器
Dialogue: 0,0:01:28.60,0:01:33.44,English,,0,0,0,,These systems instead virtualize this main memory
Dialogue: 0,0:01:28.60,0:01:33.44,Chinese,,0,0,0,,这些系统反而虚拟化这个主存储器
Dialogue: 0,0:01:34.88,0:01:39.90,English,,0,0,0,,Now the idea of virtualization is a very important one in computer science
Dialogue: 0,0:01:34.88,0:01:39.90,Chinese,,0,0,0,,现在，虚拟化的概念在计算机科学中是非常重要的
Dialogue: 0,0:01:40.48,0:01:45.24,English,,0,0,0,,And it expands a lot of it applies to, a lot of areas of computer systems
Dialogue: 0,0:01:40.48,0:01:45.24,Chinese,,0,0,0,,它扩展了很多适用于计算机系统的很多领域
Dialogue: 0,0:01:46.10,0:01:48.48,English,,0,0,0,,Now when you virtualize a resource
Dialogue: 0,0:01:46.10,0:01:48.48,Chinese,,0,0,0,,现在，当你虚拟化资源时
Dialogue: 0,0:01:49.26,0:01:54.76,English,,0,0,0,,You present the user of that resource with some different kind of view of that resource
Dialogue: 0,0:01:49.26,0:01:54.76,Chinese,,0,0,0,,你向该资源的用户显示该资源的一些不同类型的视图
Dialogue: 0,0:01:56.30,0:02:01.42,English,,0,0,0,,You present typically some kind of an abstraction or some kind of a different view of the resource
Dialogue: 0,0:01:56.30,0:02:01.42,Chinese,,0,0,0,,你通常会呈现某种抽象或某种不同的资源视图
Dialogue: 0,0:02:03.20,0:02:07.16,English,,0,0,0,,And you do it by interposing on accesses to that resource
Dialogue: 0,0:02:03.20,0:02:07.16,Chinese,,0,0,0,,你可以通过插入对该资源的访问来实现
Dialogue: 0,0:02:08.46,0:02:11.64,English,,0,0,0,,So in all cases there's some resource and you want to virtualize it
Dialogue: 0,0:02:08.46,0:02:11.64,Chinese,,0,0,0,,所以在所有情况下都有一些资源，你想要虚拟化它
Dialogue: 0,0:02:12.48,0:02:17.58,English,,0,0,0,,And you do that by interpting or interposing on the accesses to that resource
Dialogue: 0,0:02:12.48,0:02:17.58,Chinese,,0,0,0,,你通过插入或插入对该资源的访问来实现这一点
Dialogue: 0,0:02:18.94,0:02:25.00,English,,0,0,0,,Okay and then once you...we saw this when we created wrapper functions for like malloc
Dialogue: 0,0:02:18.94,0:02:25.00,Chinese,,0,0,0,,好的，然后一旦你...我们在为malloc创建包装器函数时看到了这一点
Dialogue: 0,0:02:25.00,0:02:26.62,English,,0,0,0,,I will showing you inter positioning
Dialogue: 0,0:02:25.00,0:02:26.62,Chinese,,0,0,0,,我会告诉你inter interposition
Dialogue: 0,0:02:27.14,0:02:30.44,English,,0,0,0,,The same technique is used to virtualize a resource
Dialogue: 0,0:02:27.14,0:02:30.44,Chinese,,0,0,0,,使用相同的技术来虚拟化资源
Dialogue: 0,0:02:31.18,0:02:35.94,English,,0,0,0,,And once you've intercePTEd that access then you can deal with it any way you want
Dialogue: 0,0:02:31.18,0:02:35.94,Chinese,,0,0,0,,一旦你获得了访问权限，那么你就可以以任何你想要的方式处理它
Dialogue: 0,0:02:35.94,0:02:42.70,English,,0,0,0,,So that's how you have sort of full power to change a person to change the view of that resource okay
Dialogue: 0,0:02:35.94,0:02:42.70,Chinese,,0,0,0,,这就是你如何有足够的力量改变一个人来改变那个资源的观点
Dialogue: 0,0:02:43.86,0:02:46.62,English,,0,0,0,,So a good example you saw this when we looked at disks
Dialogue: 0,0:02:43.86,0:02:46.62,Chinese,,0,0,0,,所以当我们查看磁盘时，你看到了这个例子
Dialogue: 0,0:02:48.28,0:02:54.10,English,,0,0,0,,And you know physically disk consists of cylinders tracks sectors platters surfaces
Dialogue: 0,0:02:48.28,0:02:54.10,Chinese,,0,0,0,,而且你知道物理磁盘由气缸轨道扇形盘表面组成
Dialogue: 0,0:02:55.38,0:02:59.58,English,,0,0,0,,And to access a particular sector on of those disks
Dialogue: 0,0:02:55.38,0:02:59.58,Chinese,,0,0,0,,并访问这些磁盘上的特定扇区
Dialogue: 0,0:02:59.58,0:03:03.40,English,,0,0,0,,You have to specify the cylinder and the track and the surface
Dialogue: 0,0:02:59.58,0:03:03.40,Chinese,,0,0,0,,你必须指定圆柱体，轨道和曲面
Dialogue: 0,0:03:04.98,0:03:09.06,English,,0,0,0,,Okay but we saw that the view that disk controller is present is actually different
Dialogue: 0,0:03:04.98,0:03:09.06,Chinese,,0,0,0,,好的，但是我们看到磁盘控制器存在的视图实际上是不同的
Dialogue: 0,0:03:09.06,0:03:11.96,English,,0,0,0,,It's a virtualized view of the disk
Dialogue: 0,0:03:09.06,0:03:11.96,Chinese,,0,0,0,,它是磁盘的虚拟化视图
Dialogue: 0,0:03:12.54,0:03:18.68,English,,0,0,0,,And the controller instead presents to the kernel a view of the disk as a series of a sequence of logical blocks
Dialogue: 0,0:03:12.54,0:03:18.68,Chinese,,0,0,0,,而控制器则将内核视图作为一系列逻辑块提供给内核
Dialogue: 0,0:03:21.04,0:03:27.48,English,,0,0,0,,And it presents that view by intercepting the requests from the kernel for I/O
Dialogue: 0,0:03:21.04,0:03:27.48,Chinese,,0,0,0,,它通过拦截来自内核的I / O请求来呈现该视图
Dialogue: 0,0:03:28.24,0:03:34.58,English,,0,0,0,,And changing those logical block numbers that the kernel sends into the actual physical address
Dialogue: 0,0:03:28.24,0:03:34.58,Chinese,,0,0,0,,并将内核发送的逻辑块号更改为实际的物理地址
Dialogue: 0,0:03:34.76,0:03:43.72,English,,0,0,0,,Ok so that's a very important example of virtualization in a system
Dialogue: 0,0:03:34.76,0:03:43.72,Chinese,,0,0,0,,好的，这是系统中虚拟化的一个非常重要的例子
Dialogue: 0,0:03:44.08,0:03:52.96,English,,0,0,0,,Now the memory is that is a very....is a crucial resource in the system
Dialogue: 0,0:03:44.08,0:03:52.96,Chinese,,0,0,0,,现在内存是非常......是系统中的关键资源
Dialogue: 0,0:03:52.96,0:03:57.94,English,,0,0,0,,And what we found is that it's useful to virtualize that memory resource
Dialogue: 0,0:03:52.96,0:03:57.94,Chinese,,0,0,0,,我们发现，虚拟化内存资源非常有用
Dialogue: 0,0:03:59.76,0:04:01.14,English,,0,0,0,,Okay and the way this is done
Dialogue: 0,0:03:59.76,0:04:01.14,Chinese,,0,0,0,,好的以及这样做的方式
Dialogue: 0,0:04:02.40,0:04:08.50,English,,0,0,0,,Remember before we virtually the disk by having the disk controller intercept request
Dialogue: 0,0:04:02.40,0:04:08.50,Chinese,,0,0,0,,通过磁盘控制器拦截请求记住我们之前的虚拟磁盘
Dialogue: 0,0:04:09.44,0:04:12.00,English,,0,0,0,,In the case of the main memory resource
Dialogue: 0,0:04:09.44,0:04:12.00,Chinese,,0,0,0,,在主存储器资源的情况下
Dialogue: 0,0:04:13.26,0:04:18.90,English,,0,0,0,,The requests are actually intercePTEd by a piece of hardware called the MMU the memory management unit
Dialogue: 0,0:04:13.26,0:04:18.90,Chinese,,0,0,0,,这些请求实际上是由一块称为MMU的内存管理单元的硬件intercePTEd
Dialogue: 0,0:04:19.98,0:04:24.16,English,,0,0,0,,So the way this works is that the CPU executes an instruction
Dialogue: 0,0:04:19.98,0:04:24.16,Chinese,,0,0,0,,所以它的工作方式是CPU执行指令
Dialogue: 0,0:04:24.86,0:04:28.26,English,,0,0,0,,Say it's a move instruction that generates some effect of address
Dialogue: 0,0:04:24.86,0:04:28.26,Chinese,,0,0,0,,说它是一个移动指令，产生一些地址的影响
Dialogue: 0,0:04:29.30,0:04:31.04,English,,0,0,0,,So this is actually a virtual address
Dialogue: 0,0:04:29.30,0:04:31.04,Chinese,,0,0,0,,所以这实际上是一个虚拟地址
Dialogue: 0,0:04:32.36,0:04:36.53,English,,0,0,0,,It's the CPU sends that address to the MMU
Dialogue: 0,0:04:32.36,0:04:36.53,Chinese,,0,0,0,,它是CPU将该地址发送给MMU
Dialogue: 0,0:04:37.38,0:04:42.10,English,,0,0,0,,Which goes through a process called address translation which will study later today
Dialogue: 0,0:04:37.38,0:04:42.10,Chinese,,0,0,0,,这是一个称为地址转换的过程，将在今天晚些时候进行研究
Dialogue: 0,0:04:42.92,0:04:49.96,English,,0,0,0,,And it converts that virtual address in this case 4100 into a physical address 4
Dialogue: 0,0:04:42.92,0:04:49.96,Chinese,,0,0,0,,并且它将该情况下的该虚拟地址4100转换为物理地址4
Dialogue: 0,0:04:50.22,0:04:55.82,English,,0,0,0,,Which actually corresponds to the address of that the data object that we want
Dialogue: 0,0:04:50.22,0:04:55.82,Chinese,,0,0,0,,这实际上对应于我们想要的数据对象的地址
Dialogue: 0,0:04:56.74,0:05:01.28,English,,0,0,0,,Ok so once the MMU translates the virtual address to a physical address
Dialogue: 0,0:04:56.74,0:05:01.28,Chinese,,0,0,0,,好的，一旦MMU将虚拟地址转换为物理地址
Dialogue: 0,0:05:02.94,0:05:06.16,English,,0,0,0,,Then the memory will return the word at that address
Dialogue: 0,0:05:02.94,0:05:06.16,Chinese,,0,0,0,,然后内存将返回该地址的单词
Dialogue: 0,0:05:08.90,0:05:11.14,English,,0,0,0,,So this...
Dialogue: 0,0:05:08.90,0:05:11.14,Chinese,,0,0,0,,所以这...
Dialogue: 0,0:05:12.24,0:05:14.24,English,,0,0,0,,My wonder why in the world would you want to do this
Dialogue: 0,0:05:12.24,0:05:14.24,Chinese,,0,0,0,,我想知道为什么你想在世界上做这件事
Dialogue: 0,0:05:14.24,0:05:19.36,English,,0,0,0,,Well it turns out there's all kinds of good reasons to virtualize the address space
Dialogue: 0,0:05:14.24,0:05:19.36,Chinese,,0,0,0,,事实证明，虚拟化地址空间有各种充分的理由
Dialogue: 0,0:05:20.14,0:05:22.74,English,,0,0,0,,And so before I can explain those to you
Dialogue: 0,0:05:20.14,0:05:22.74,Chinese,,0,0,0,,所以在我向你解释这些之前
Dialogue: 0,0:05:22.86,0:05:27.66,English,,0,0,0,,Let me just define a few terms
Dialogue: 0,0:05:22.86,0:05:27.66,Chinese,,0,0,0,,我来简单定义几个术语
Dialogue: 0,0:05:28.90,0:05:32.26,English,,0,0,0,,So an address space is a set of addresses
Dialogue: 0,0:05:28.90,0:05:32.26,Chinese,,0,0,0,,所以地址空间是一组地址
Dialogue: 0,0:05:32.50,0:05:34.56,English,,0,0,0,,Ok so an address spaces is a set
Dialogue: 0,0:05:32.50,0:05:34.56,Chinese,,0,0,0,,好的，所以地址空间是一组
Dialogue: 0,0:05:35.58,0:05:39.74,English,,0,0,0,,Not of data bytes but of the addresses of those bytes
Dialogue: 0,0:05:35.58,0:05:39.74,Chinese,,0,0,0,,不是数据字节，而是那些字节的地址
Dialogue: 0,0:05:40.64,0:05:48.88,English,,0,0,0,,And a linear address space is a content is a contiguous set of contiguous non-negative integers
Dialogue: 0,0:05:40.64,0:05:48.88,Chinese,,0,0,0,,并且线性地址空间是内容是连续的非负整数集合
Dialogue: 0,0:05:49.68,0:05:53.28,English,,0,0,0,,Okay so just 0,1,2,3,4 and so on
Dialogue: 0,0:05:49.68,0:05:53.28,Chinese,,0,0,0,,好的，只有0,1,2,3,4等等
Dialogue: 0,0:05:54.60,0:06:01.52,English,,0,0,0,,The virtual address space is a set of N=2^n virtual addresses a linear it's a linear address space
Dialogue: 0,0:05:54.60,0:06:01.52,Chinese,,0,0,0,,虚拟地址空间是一组N = 2 ^ n个虚拟地址，线性地是线性地址空间
Dialogue: 0,0:06:02.48,0:06:07.70,English,,0,0,0,,And the physical address space is a set of M=2^m physical addresses ok
Dialogue: 0,0:06:02.48,0:06:07.70,Chinese,,0,0,0,,并且物理地址空间是一组M = 2 ^ m的物理地址ok
Dialogue: 0,0:06:10.22,0:06:19.36,English,,0,0,0,,And so typically the virtual address space is usually much larger than the physical address space
Dialogue: 0,0:06:10.22,0:06:19.36,Chinese,,0,0,0,,因此，通常虚拟地址空间通常比物理地址空间大得多
Dialogue: 0,0:06:19.54,0:06:24.68,English,,0,0,0,,Okay the physical address space corresponds to the amount of DRAM that you actually have in the system
Dialogue: 0,0:06:19.54,0:06:24.68,Chinese,,0,0,0,,好的，物理地址空间对应于系统中实际拥有的DRAM数量
Dialogue: 0,0:06:25.34,0:06:31.52,English,,0,0,0,,The virtual address space is the same for all processes running on that system
Dialogue: 0,0:06:25.34,0:06:31.52,Chinese,,0,0,0,,对于在该系统上运行的所有进程，虚拟地址空间是相同的
Dialogue: 0,0:06:35.30,0:06:38.14,English,,0,0,0,,Okay why do we want to implement virtual memory
Dialogue: 0,0:06:35.30,0:06:38.14,Chinese,,0,0,0,,好的，为什么我们要实现虚拟内存
Dialogue: 0,0:06:38.14,0:06:43.48,English,,0,0,0,,Why do this,why do this level of indirection with the MMU
Dialogue: 0,0:06:38.14,0:06:43.48,Chinese,,0,0,0,,为什么这样，为什么这个级别的间接与MMU
Dialogue: 0,0:06:44.54,0:06:46.68,English,,0,0,0,,Well there's really three big reasons so
Dialogue: 0,0:06:44.54,0:06:46.68,Chinese,,0,0,0,,那么真的有三个重要原因
Dialogue: 0,0:06:47.02,0:06:56.00,English,,0,0,0,,The first is that virtual memory uses the DRAM as a cache for the actual data stored on disk
Dialogue: 0,0:06:47.02,0:06:56.00,Chinese,,0,0,0,,第一个是虚拟内存使用DRAM作为存储在磁盘上的实际数据的缓存
Dialogue: 0,0:06:56.82,0:07:03.14,English,,0,0,0,,Okay so you can think of virtual memory as it as a DRAM cache for data stored on the disk
Dialogue: 0,0:06:56.82,0:07:03.14,Chinese,,0,0,0,,好的，你可以将虚拟内存视为存储在磁盘上的数据的DRAM缓存
Dialogue: 0,0:07:03.66,0:07:08.58,English,,0,0,0,,And this allows us to use the memory much more efficiently
Dialogue: 0,0:07:03.66,0:07:08.58,Chinese,,0,0,0,,这使我们能够更有效地使用内存
Dialogue: 0,0:07:09.04,0:07:12.20,English,,0,0,0,,Because we only need to cache items that are frequently used
Dialogue: 0,0:07:09.04,0:07:12.20,Chinese,,0,0,0,,因为我们只需要缓存经常使用的项目
Dialogue: 0,0:07:12.20,0:07:17.02,English,,0,0,0,,Right just the same idea that we learned when we talked about caches and locality
Dialogue: 0,0:07:12.20,0:07:17.02,Chinese,,0,0,0,,正好与我们在讨论缓存和位置时学到的相同
Dialogue: 0,0:07:19.06,0:07:25.86,English,,0,0,0,,So that's one thing we can use the memory much more efficiently by only using the portions of the virtual address space
Dialogue: 0,0:07:19.06,0:07:25.86,Chinese,,0,0,0,,因此，通过仅使用虚拟地址空间的部分，我们可以更有效地使用内存
Dialogue: 0,0:07:25.94,0:07:30.50,English,,0,0,0,,By only actually storing the portions of the virtual address space in the physical memory
Dialogue: 0,0:07:25.94,0:07:30.50,Chinese,,0,0,0,,通过仅将虚拟地址空间的部分实际存储在物理存储器中
Dialogue: 0,0:07:32.26,0:07:35.16,English,,0,0,0,,Okay the second thing is it greatly simplifies memory management
Dialogue: 0,0:07:32.26,0:07:35.16,Chinese,,0,0,0,,好的第二件事是它大大简化了内存管理
Dialogue: 0,0:07:35.96,0:07:40.48,English,,0,0,0,,So we saw it every process has the same view right
Dialogue: 0,0:07:35.96,0:07:40.48,Chinese,,0,0,0,,所以我们看到它每个进程都有相同的观点
Dialogue: 0,0:07:40.48,0:07:44.18,English,,0,0,0,,There's code loaded at code and data are always loaded at the same address
Dialogue: 0,0:07:40.48,0:07:44.18,Chinese,,0,0,0,,代码中加载了代码，数据总是在同一地址加载
Dialogue: 0,0:07:44.78,0:07:48.44,English,,0,0,0,,The stack is at the top of the user visible address space
Dialogue: 0,0:07:44.78,0:07:48.44,Chinese,,0,0,0,,堆栈位于用户可见地址空间的顶部
Dialogue: 0,0:07:49.50,0:07:54.62,English,,0,0,0,,So every process has the same similar-looking virtual address space
Dialogue: 0,0:07:49.50,0:07:54.62,Chinese,,0,0,0,,因此，每个进程都具有相同的相似外观的虚拟地址空间
Dialogue: 0,0:07:56.00,0:08:02.10,English,,0,0,0,,But in actual in actuality that the memory that corresponds to those
Dialogue: 0,0:07:56.00,0:08:02.10,Chinese,,0,0,0,,但实际上实际上是那些对应的内存
Dialogue: 0,0:08:02.12,0:08:06.16,English,,0,0,0,,Those addresses is actually scattered all over main memory
Dialogue: 0,0:08:02.12,0:08:06.16,Chinese,,0,0,0,,这些地址实际上分散在主存储器中
Dialogue: 0,0:08:06.90,0:08:14.46,English,,0,0,0,,Okay so that's a really important benefit of virtual memory
Dialogue: 0,0:08:06.90,0:08:14.46,Chinese,,0,0,0,,好的，这是虚拟内存的一个非常重要的好处
Dialogue: 0,0:08:15.88,0:08:18.56,English,,0,0,0,,And then finally it allows us to protect accesses
Dialogue: 0,0:08:15.88,0:08:18.56,Chinese,,0,0,0,,最后它允许我们保护访问
Dialogue: 0,0:08:18.66,0:08:23.28,English,,0,0,0,,So remember we had to...
Dialogue: 0,0:08:18.66,0:08:23.28,Chinese,,0,0,0,,所以记住我们必须......
Dialogue: 0,0:08:24.02,0:08:28.24,English,,0,0,0,,A process we saw that a process provides the separate address space
Dialogue: 0,0:08:24.02,0:08:28.24,Chinese,,0,0,0,,我们看到一个进程提供了单独的地址空间
Dialogue: 0,0:08:28.92,0:08:32.06,English,,0,0,0,,That's protected from accesses by other processes
Dialogue: 0,0:08:28.92,0:08:32.06,Chinese,,0,0,0,,这可以防止其他进程访问
Dialogue: 0,0:08:32.54,0:08:39.02,English,,0,0,0,,Okay so virtual memory allows us to create these separate protected private address spaces
Dialogue: 0,0:08:32.54,0:08:39.02,Chinese,,0,0,0,,好的，所以虚拟内存允许我们创建这些单独的受保护私有地址空间
Dialogue: 0,0:08:40.02,0:08:43.68,English,,0,0,0,,Okay and so what we'll do today we'll look in more detail at these three ideas
Dialogue: 0,0:08:40.02,0:08:43.68,Chinese,,0,0,0,,好的，我们今天要做的是，我们将更详细地了解这三个想法
Dialogue: 0,0:08:44.40,0:08:49.36,English,,0,0,0,,And then we'll go into the specifics of address translation
Dialogue: 0,0:08:44.40,0:08:49.36,Chinese,,0,0,0,,然后我们将详细介绍地址转换
Dialogue: 0,0:08:49.36,0:08:54.02,English,,0,0,0,,So I'm going to...for the first part of this lecture
Dialogue: 0,0:08:49.36,0:08:54.02,Chinese,,0,0,0,,所以我要......本讲座的第一部分
Dialogue: 0,0:08:54.02,0:08:57.88,English,,0,0,0,,We're going to talk about address translation just in kind of high-level terms
Dialogue: 0,0:08:54.02,0:08:57.88,Chinese,,0,0,0,,我们将以高级术语来谈论地址转换
Dialogue: 0,0:08:58.40,0:09:02.46,English,,0,0,0,,But then we'll go into the details at the end you can see how it really works
Dialogue: 0,0:08:58.40,0:09:02.46,Chinese,,0,0,0,,但是接下来我们将详细介绍细节，你可以看到它是如何运作的
Dialogue: 0,0:09:03.24,0:09:05.78,English,,0,0,0,,Okay so let's look at VM as a tool for caching
Dialogue: 0,0:09:03.24,0:09:05.78,Chinese,,0,0,0,,好的，让我们看看VM作为缓存工具
Dialogue: 0,0:09:07.00,0:09:13.28,English,,0,0,0,,So conceptually you can think of your virtual memory as a sequence of bytes stored on disk
Dialogue: 0,0:09:07.00,0:09:13.28,Chinese,,0,0,0,,因此，从概念上讲，你可以将虚拟内存视为存储在磁盘上的字节序列
Dialogue: 0,0:09:15.82,0:09:24.54,English,,0,0,0,,And then the contents of that virtual memory stored on disk are cached in DRAM
Dialogue: 0,0:09:15.82,0:09:24.54,Chinese,,0,0,0,,然后存储在磁盘上的虚拟内存的内容缓存在DRAM中
Dialogue: 0,0:09:25.28,0:09:33.70,English,,0,0,0,,Okay so think of the the DRAM is a cache for this array of contiguous bytes stored on the disk
Dialogue: 0,0:09:25.28,0:09:33.70,Chinese,,0,0,0,,好的，所以想想DRAM是存储在磁盘上的这个连续字节数组的缓存
Dialogue: 0,0:09:35.18,0:09:38.44,English,,0,0,0,,And just like any cache the data is broken up into blocks
Dialogue: 0,0:09:35.18,0:09:38.44,Chinese,,0,0,0,,就像任何缓存一样，数据被分解成块
Dialogue: 0,0:09:40.62,0:09:42.72,English,,0,0,0,,Okay and then we have so... so here we have the...
Dialogue: 0,0:09:40.62,0:09:42.72,Chinese,,0,0,0,,好的，然后我们就这样......所以我们在这里......
Dialogue: 0,0:09:43.32,0:09:46.16,English,,0,0,0,,And those blocks for virtual memory systems are called pages
Dialogue: 0,0:09:43.32,0:09:46.16,Chinese,,0,0,0,,虚拟内存系统的那些块称为页面
Dialogue: 0,0:09:47.30,0:09:52.10,English,,0,0,0,,They're typically larger than much larger than the cache blocks
Dialogue: 0,0:09:47.30,0:09:52.10,Chinese,,0,0,0,,它们通常比缓存块大得多
Dialogue: 0,0:09:52.64,0:09:53.64,English,,0,0,0,,That we that we study done
Dialogue: 0,0:09:52.64,0:09:53.64,Chinese,,0,0,0,,我们研究完成了
Dialogue: 0,0:09:54.46,0:09:58.28,English,,0,0,0,,So for k bytes typically instead of the 64 bytes
Dialogue: 0,0:09:54.46,0:09:58.28,Chinese,,0,0,0,,所以对于k字节通常而不是64字节
Dialogue: 0,0:09:58.58,0:10:01.36,English,,0,0,0,,Like that we learned about in when we studied cache memories
Dialogue: 0,0:09:58.58,0:10:01.36,Chinese,,0,0,0,,就像我们在研究缓存记忆时所学到的那样
Dialogue: 0,0:10:02.64,0:10:08.30,English,,0,0,0,,So this virtual memory conceptually you can think of it as being a sequence of pages stored on the disk
Dialogue: 0,0:10:02.64,0:10:08.30,Chinese,,0,0,0,,因此，从概念上讲，这个虚拟内存可以将其视为存储在磁盘上的一系列页面
Dialogue: 0,0:10:09.44,0:10:10.88,English,,0,0,0,,So called virtual pages
Dialogue: 0,0:10:09.44,0:10:10.88,Chinese,,0,0,0,,所谓的虚拟页面
Dialogue: 0,0:10:11.66,0:10:18.86,English,,0,0,0,,And each of these pages will identify with a number so here's virtual page 0,virtual page 1
Dialogue: 0,0:10:11.66,0:10:18.86,Chinese,,0,0,0,,并且这些页面中的每一个都将标识一个数字，因此这里是虚拟页面0，虚拟页面1
Dialogue: 0,0:10:20.00,0:10:25.66,English,,0,0,0,,And then a subset of those pages are stored in the physical memory, in the physical DRAM memory
Dialogue: 0,0:10:20.00,0:10:25.66,Chinese,,0,0,0,,然后，这些页面的子集存储在物理存储器中的物理DRAM存储器中
Dialogue: 0,0:10:27.08,0:10:29.46,English,,0,0,0,,And then there's some mapping function
Dialogue: 0,0:10:27.08,0:10:29.46,Chinese,,0,0,0,,然后有一些映射功能
Dialogue: 0,0:10:30.00,0:10:33.20,English,,0,0,0,,That tells us which pages have been cached
Dialogue: 0,0:10:30.00,0:10:33.20,Chinese,,0,0,0,,这告诉我们哪些页面已被缓存
Dialogue: 0,0:10:33.90,0:10:36.38,English,,0,0,0,,Ok so in this case I've just shown a snapshot
Dialogue: 0,0:10:33.90,0:10:36.38,Chinese,,0,0,0,,好的，在这种情况下，我刚刚展示了一个快照
Dialogue: 0,0:10:36.88,0:10:41.44,English,,0,0,0,,Where we have three virtual pages cached somewhere in DRAM
Dialogue: 0,0:10:36.88,0:10:41.44,Chinese,,0,0,0,,我们在DRAM中的某个地方缓存了三个虚拟页面
Dialogue: 0,0:10:42.50,0:10:49.60,English,,0,0,0,,Okay and there's no relation between the virtual page number and the the physical page number that it's mapped to
Dialogue: 0,0:10:42.50,0:10:49.60,Chinese,,0,0,0,,好的，虚拟页码与它映射到的物理页码之间没有关系
Dialogue: 0,0:10:51.44,0:10:55.52,English,,0,0,0,,Some of these pages are not cached so they're still stored on disk
Dialogue: 0,0:10:51.44,0:10:55.52,Chinese,,0,0,0,,其中一些页面未缓存，因此它们仍存储在磁盘上
Dialogue: 0,0:10:56.54,0:11:00.62,English,,0,0,0,,So in this case VP2 is still stored on disk
Dialogue: 0,0:10:56.54,0:11:00.62,Chinese,,0,0,0,,所以在这种情况下，VP2仍然存储在磁盘上
Dialogue: 0,0:11:00.94,0:11:05.08,English,,0,0,0,,And there's some pages which aren't even allocated,so they don't exist on the disk
Dialogue: 0,0:11:00.94,0:11:05.08,Chinese,,0,0,0,,并且有一些页面甚至没有分配，因此它们不存在于磁盘上
Dialogue: 0,0:11:05.36,0:11:06.42,English,,0,0,0,,It's a way to think of that
Dialogue: 0,0:11:05.36,0:11:06.42,Chinese,,0,0,0,,这是一种思考方式
Dialogue: 0,0:11:06.94,0:11:08.56,English,,0,0,0,,Right we really wouldn't want to store
Dialogue: 0,0:11:06.94,0:11:08.56,Chinese,,0,0,0,,对，我们真的不想存储
Dialogue: 0,0:11:09.06,0:11:13.24,English,,0,0,0,,Every single page in address space with that's to the size to the 48th
Dialogue: 0,0:11:09.06,0:11:13.24,Chinese,,0,0,0,,地址空间中的每一页都是大小到第48位
Dialogue: 0,0:11:13.68,0:11:17.00,English,,0,0,0,,We really wouldn't want to store all those on disk
Dialogue: 0,0:11:13.68,0:11:17.00,Chinese,,0,0,0,,我们真的不想将所有这些存储在磁盘上
Dialogue: 0,0:11:18.50,0:11:21.60,English,,0,0,0,,So most of the address space is unallocated
Dialogue: 0,0:11:18.50,0:11:21.60,Chinese,,0,0,0,,因此大多数地址空间都是未分配的
Dialogue: 0,0:11:28.44,0:11:32.98,English,,0,0,0,,Ok so we can just think of this,so this DRAM is just a cache
Dialogue: 0,0:11:28.44,0:11:32.98,Chinese,,0,0,0,,好的，我们可以想到这一点，所以这个DRAM只是一个缓存
Dialogue: 0,0:11:33.62,0:11:36.22,English,,0,0,0,,But it has a much different organization
Dialogue: 0,0:11:33.62,0:11:36.22,Chinese,,0,0,0,,但它有一个非常不同的组织
Dialogue: 0,0:11:36.44,0:11:38.34,English,,0,0,0,,Than the cache memories we studied earlier
Dialogue: 0,0:11:36.44,0:11:38.34,Chinese,,0,0,0,,比我们之前研究的缓存记忆
Dialogue: 0,0:11:38.72,0:11:43.80,English,,0,0,0,,And the difference is driven by that the enormous miss penalty when you go from
Dialogue: 0,0:11:38.72,0:11:43.80,Chinese,,0,0,0,,而这种差异是由于你离开时的巨大失误惩罚所致
Dialogue: 0,0:11:44.62,0:11:52.26,English,,0,0,0,,If you have a cache and DRAM the miss penalty would to fetch a data item from the disk is huge
Dialogue: 0,0:11:44.62,0:11:52.26,Chinese,,0,0,0,,如果你有一个缓存和DRAM，那么从磁盘中获取数据项的错失将是巨大的
Dialogue: 0,0:11:53.90,0:12:00.08,English,,0,0,0,,So the design of this virtual memory cache is totally driven by this enormous miss penalty
Dialogue: 0,0:11:53.90,0:12:00.08,Chinese,,0,0,0,,因此，这个虚拟内存缓存的设计完全由这个巨大的未命中惩罚驱动
Dialogue: 0,0:12:01.48,0:12:04.14,English,,0,0,0,,And so as a result that blocks are larger
Dialogue: 0,0:12:01.48,0:12:04.14,Chinese,,0,0,0,,因此，块越大
Dialogue: 0,0:12:04.16,0:12:07.46,English,,0,0,0,,So remember we talked about that the block size is kind of a trade-off
Dialogue: 0,0:12:04.16,0:12:07.46,Chinese,,0,0,0,,所以请记住，我们谈到块大小是一种权衡
Dialogue: 0,0:12:08.18,0:12:16.50,English,,0,0,0,,Between sort of useful getting used being able to usefully amortize the cost of fetching that block
Dialogue: 0,0:12:08.18,0:12:16.50,Chinese,,0,0,0,,在某种有用的使用之间能够有效地分摊获取该块的成本
Dialogue: 0,0:12:17.12,0:12:22.38,English,,0,0,0,,Versus sort of consuming too much of this scarce cache space right
Dialogue: 0,0:12:17.12,0:12:22.38,Chinese,,0,0,0,,而且有点过多地消耗这个稀缺的缓存空间
Dialogue: 0,0:12:22.40,0:12:27.54,English,,0,0,0,,So in this case our cache memories were 64 byte blocks
Dialogue: 0,0:12:22.40,0:12:27.54,Chinese,,0,0,0,,所以在这种情况下，我们的缓存存储器是64字节块
Dialogue: 0,0:12:28.94,0:12:36.12,English,,0,0,0,,Virtual most virtual memory systems have like 4k byte blocks with an option to increase to 4 megabytes
Dialogue: 0,0:12:28.94,0:12:36.12,Chinese,,0,0,0,,虚拟大多数虚拟内存系统具有4k字节块，可选择增加到4兆字节
Dialogue: 0,0:12:36.66,0:12:38.56,English,,0,0,0,,In the case of x86
Dialogue: 0,0:12:36.66,0:12:38.56,Chinese,,0,0,0,,在x86的情况下
Dialogue: 0,0:12:40.86,0:12:44.40,English,,0,0,0,,And now this cash and other consequence of the enormous missed penalty is that
Dialogue: 0,0:12:40.86,0:12:44.40,Chinese,,0,0,0,,现在，这笔巨额罚款的现金和其他后果就是这样
Dialogue: 0,0:12:46.48,0:12:49.68,English,,0,0,0,,You really want to have as large associativity as you can
Dialogue: 0,0:12:46.48,0:12:49.68,Chinese,,0,0,0,,你真的希望拥有尽可能大的关联性
Dialogue: 0,0:12:49.78,0:12:54.60,English,,0,0,0,,Remember we saw with direct mapped cache is that were subject to these conflict misses
Dialogue: 0,0:12:49.78,0:12:54.60,Chinese,,0,0,0,,请记住，我们看到直接映射缓存是受到这些冲突未命中的影响
Dialogue: 0,0:12:54.98,0:12:58.16,English,,0,0,0,,And and if you increase the associativity of the cache
Dialogue: 0,0:12:54.98,0:12:58.16,Chinese,,0,0,0,,并且，如果你增加缓存的关联性
Dialogue: 0,0:12:58.16,0:13:01.32,English,,0,0,0,,You reduce the probability of those conflict misses
Dialogue: 0,0:12:58.16,0:13:01.32,Chinese,,0,0,0,,你可以减少这些冲突未命中的可能性
Dialogue: 0,0:13:01.84,0:13:07.44,English,,0,0,0,,But you never completely eliminate them until you have a fully associative cache with just one set
Dialogue: 0,0:13:01.84,0:13:07.44,Chinese,,0,0,0,,但是，除非只有一组完全关联的缓存，否则你永远不会完全消除它们
Dialogue: 0,0:13:08.04,0:13:12.12,English,,0,0,0,,Okay so in a virtual memory,in a virtual memory cache
Dialogue: 0,0:13:08.04,0:13:12.12,Chinese,,0,0,0,,好吧，在虚拟内存中，在虚拟内存缓存中
Dialogue: 0,0:13:14.08,0:13:19.28,English,,0,0,0,,It's fully associative there's one set and each virtual page can go anywhere in the cache
Dialogue: 0,0:13:14.08,0:13:19.28,Chinese,,0,0,0,,它是完全关联的，有一组，每个虚拟页面可以在缓存中的任何位置
Dialogue: 0,0:13:22.14,0:13:25.52,English,,0,0,0,,Okay so this requires a really complicated mapping function
Dialogue: 0,0:13:22.14,0:13:25.52,Chinese,,0,0,0,,好的，这需要一个非常复杂的映射功能
Dialogue: 0,0:13:25.52,0:13:30.46,English,,0,0,0,,Somehow we're going to have to keep track of where all these cached pages are
Dialogue: 0,0:13:25.52,0:13:30.46,Chinese,,0,0,0,,不知何故，我们将不得不跟踪所有这些缓存页面的位置
Dialogue: 0,0:13:32.24,0:13:36.48,English,,0,0,0,,And we can't really do a search that would be way too inexpensive
Dialogue: 0,0:13:32.24,0:13:36.48,Chinese,,0,0,0,,我们不能真正做一个太便宜的搜索
Dialogue: 0,0:13:36.52,0:13:41.68,English,,0,0,0,,So you remember when we with a cache memory the hardware actually did a search within the set
Dialogue: 0,0:13:36.52,0:13:41.68,Chinese,,0,0,0,,所以你记得当我们使用高速缓冲存储器时，硬件实际上在集合中进行了搜索
Dialogue: 0,0:13:42.32,0:13:47.30,English,,0,0,0,,A parallel search to find try to find a cache line
Dialogue: 0,0:13:42.32,0:13:47.30,Chinese,,0,0,0,,并行搜索以查找尝试查找缓存行
Dialogue: 0,0:13:48.26,0:13:51.70,English,,0,0,0,,But with a software cache like this that that's not feasible
Dialogue: 0,0:13:48.26,0:13:51.70,Chinese,,0,0,0,,但是像这样的软件缓存那是不可行的
Dialogue: 0,0:13:52.40,0:13:57.38,English,,0,0,0,,All right so somehow we're going to have to remember where these cached blocks are in this very large set
Dialogue: 0,0:13:52.40,0:13:57.38,Chinese,,0,0,0,,好吧，所以我们不得不记住这些缓存块在这个非常大的集合中的位置
Dialogue: 0,0:13:59.68,0:14:02.88,English,,0,0,0,,And again because it's so expensive if you make a mistake
Dialogue: 0,0:13:59.68,0:14:02.88,Chinese,,0,0,0,,再次因为如果你犯了错误就太贵了
Dialogue: 0,0:14:03.84,0:14:07.86,English,,0,0,0,,When you're trying to identify a victim page
Dialogue: 0,0:14:03.84,0:14:07.86,Chinese,,0,0,0,,当你尝试识别受害者页面时
Dialogue: 0,0:14:08.68,0:14:13.92,English,,0,0,0,,If you make a mistake and you evict a page that then is referenced again in the near future
Dialogue: 0,0:14:08.68,0:14:13.92,Chinese,,0,0,0,,如果你犯了一个错误并且你驱逐了一个页面，那么在不久的将来会再次引用它
Dialogue: 0,0:14:14.30,0:14:16.42,English,,0,0,0,,You pay a big price for it okay
Dialogue: 0,0:14:14.30,0:14:16.42,Chinese,,0,0,0,,你付出了很大的代价还可以
Dialogue: 0,0:14:17.10,0:14:22.88,English,,0,0,0,,So virtual memory caches have much more sophisticated replacement algorithms than like simple lru that
Dialogue: 0,0:14:17.10,0:14:22.88,Chinese,,0,0,0,,因此，虚拟内存缓存具有比简单的lru更复杂的替换算法
Dialogue: 0,0:14:22.94,0:14:24.44,English,,0,0,0,,That we saw with cache memories
Dialogue: 0,0:14:22.94,0:14:24.44,Chinese,,0,0,0,,我们看到了缓存记忆
Dialogue: 0,0:14:25.30,0:14:28.88,English,,0,0,0,,Now they're these replacement algorithms are outside of the scope of this course
Dialogue: 0,0:14:25.30,0:14:28.88,Chinese,,0,0,0,,现在他们这些替换算法超出了本课程的范围
Dialogue: 0,0:14:29.06,0:14:31.00,English,,0,0,0,,You'll learn about them and when you take OS
Dialogue: 0,0:14:29.06,0:14:31.00,Chinese,,0,0,0,,你将了解它们以及何时使用OS
Dialogue: 0,0:14:32.34,0:14:37.68,English,,0,0,0,,But because it's in software we can afford to do very expensive replacement algorithms
Dialogue: 0,0:14:32.34,0:14:37.68,Chinese,,0,0,0,,但是因为它是软件，我们可以负担得起非常昂贵的替代算法
Dialogue: 0,0:14:39.64,0:14:46.67,English,,0,0,0,,And we can take a long fairly relatively long time to execute the code for those algorithms
Dialogue: 0,0:14:39.64,0:14:46.67,Chinese,,0,0,0,,我们可能需要相当长的时间来执行这些算法的代码
Dialogue: 0,0:14:47.32,0:14:57.06,English,,0,0,0,,Because any time we spend figuring out a victim block will be much less than the cost of making a mistake
Dialogue: 0,0:14:47.32,0:14:57.06,Chinese,,0,0,0,,因为任何时候我们花费计算受害者的阻力都会比制造错误的成本低得多
Dialogue: 0,0:14:57.44,0:15:02.58,English,,0,0,0,,And paying the access time,the miss time,the miss penalty to to disk
Dialogue: 0,0:14:57.44,0:15:02.58,Chinese,,0,0,0,,并支付访问时间，未命中时间，错过罚款到磁盘
Dialogue: 0,0:15:03.54,0:15:09.92,English,,0,0,0,,And then also as a result of virtual memory systems never use right through  just  it takes to one
Dialogue: 0,0:15:03.54,0:15:09.92,Chinese,,0,0,0,,然后，由于虚拟内存系统永远不会正确使用它只需一个
Dialogue: 0,0:15:10.62,0:15:17.12,English,,0,0,0,,Right so they always use right back and they try to defer writing anything back to the disk as long as possible
Dialogue: 0,0:15:10.62,0:15:17.12,Chinese,,0,0,0,,对，所以他们总是使用右后卫，他们试图尽可能地推迟将任何东西写回磁盘
Dialogue: 0,0:15:19.74,0:15:21.64,English,,0,0,0,,Alright now how do we keep track
Dialogue: 0,0:15:19.74,0:15:21.64,Chinese,,0,0,0,,好吧，现在我们如何跟踪
Dialogue: 0,0:15:21.64,0:15:26.36,English,,0,0,0,,Somehow we have to keep track of this complicated cache and DRAM
Dialogue: 0,0:15:21.64,0:15:26.36,Chinese,,0,0,0,,不知何故，我们必须跟踪这个复杂的缓存和DRAM
Dialogue: 0,0:15:27.02,0:15:32.52,English,,0,0,0,,And the data structure that keeps track of the location of the virtual pages
Dialogue: 0,0:15:27.02,0:15:32.52,Chinese,,0,0,0,,以及跟踪虚拟页面位置的数据结构
Dialogue: 0,0:15:33.06,0:15:35.82,English,,0,0,0,,In memory is called the page table
Dialogue: 0,0:15:33.06,0:15:35.82,Chinese,,0,0,0,,在内存中称为页表
Dialogue: 0,0:15:37.14,0:15:40.26,English,,0,0,0,,Now a page table is just a data structure in memory
Dialogue: 0,0:15:37.14,0:15:40.26,Chinese,,0,0,0,,现在页表只是内存中的数据结构
Dialogue: 0,0:15:41.02,0:15:44.92,English,,0,0,0,,That the kernel maintains for as part of each process context
Dialogue: 0,0:15:41.02,0:15:44.92,Chinese,,0,0,0,,内核维护为每个进程上下文的一部分
Dialogue: 0,0:15:45.26,0:15:47.42,English,,0,0,0,,Okay so every process has its own page table
Dialogue: 0,0:15:45.26,0:15:47.42,Chinese,,0,0,0,,好的，所以每个进程都有自己的页表
Dialogue: 0,0:15:48.48,0:15:54.70,English,,0,0,0,,And it's just a...it's an array of so called page table entries or PTEs
Dialogue: 0,0:15:48.48,0:15:54.70,Chinese,,0,0,0,,它只是一个......它是一组所谓的页表条目或PTE
Dialogue: 0,0:15:57.32,0:16:04.80,English,,0,0,0,,Where PTE k contains the physical address of physical page k in DRAM okay
Dialogue: 0,0:15:57.32,0:16:04.80,Chinese,,0,0,0,,其中PTE k包含DRAM中物理页面k的物理地址
Dialogue: 0,0:16:09.60,0:16:13.70,English,,0,0,0,,So here's how it works there's this page table in DRAM
Dialogue: 0,0:16:09.60,0:16:13.70,Chinese,,0,0,0,,所以这就是它的工作原理DRAM中的这个页面表
Dialogue: 0,0:16:14.90,0:16:18.04,English,,0,0,0,,There's virtual pages stored on disk
Dialogue: 0,0:16:14.90,0:16:18.04,Chinese,,0,0,0,,存储在磁盘上的虚拟页面
Dialogue: 0,0:16:22.08,0:16:26.38,English,,0,0,0,,And then there's....and then there's physical
Dialogue: 0,0:16:22.08,0:16:26.38,Chinese,,0,0,0,,然后就是....然后就是身体上的
Dialogue: 0,0:16:26.38,0:16:30.60,English,,0,0,0,,There's virtual pages stored in various physical pages in DRAM
Dialogue: 0,0:16:26.38,0:16:30.60,Chinese,,0,0,0,,存储在DRAM中的各种物理页面中的虚拟页面
Dialogue: 0,0:16:31.76,0:16:35.00,English,,0,0,0,,And then the page table keeps track of where those are stored
Dialogue: 0,0:16:31.76,0:16:35.00,Chinese,,0,0,0,,然后页表跟踪存储的位置
Dialogue: 0,0:16:35.48,0:16:41.86,English,,0,0,0,,So here we have a case this PTE 1 corresponds to virtual page 1
Dialogue: 0,0:16:35.48,0:16:41.86,Chinese,,0,0,0,,所以这里我们有一个案例，这个PTE 1对应虚拟页面1
Dialogue: 0,0:16:43.18,0:16:48.60,English,,0,0,0,,And in this case it says that virtual page 1 is mapped into physical page 0
Dialogue: 0,0:16:43.18,0:16:48.60,Chinese,,0,0,0,,在这种情况下，它表示虚拟页面1被映射到物理页面0
Dialogue: 0,0:16:50.12,0:16:55.30,English,,0,0,0,,Virtual page 2 is mapped into physical page 1 and so on
Dialogue: 0,0:16:50.12,0:16:55.30,Chinese,,0,0,0,,虚拟页面2映射到物理页面1，依此类推
Dialogue: 0,0:16:57.30,0:17:05.72,English,,0,0,0,,Ok now some of these the pages that aren't in memory are stored on disks the allocated pages
Dialogue: 0,0:16:57.30,0:17:05.72,Chinese,,0,0,0,,好的，现在其中一些不在内存中的页面存储在已分配页面的磁盘上
Dialogue: 0,0:17:06.72,0:17:12.80,English,,0,0,0,,And so for those pages the page table entry contains a pointer to the location of that that page on disk
Dialogue: 0,0:17:06.72,0:17:12.80,Chinese,,0,0,0,,因此，对于那些页面，页表条目包含指向该页面在磁盘上的位置的指针
Dialogue: 0,0:17:13.26,0:17:17.94,English,,0,0,0,,So think of it as a logical block number where that page can be found on the disk
Dialogue: 0,0:17:13.26,0:17:17.94,Chinese,,0,0,0,,因此，将其视为逻辑块编号，可在磁盘上找到该页面
Dialogue: 0,0:17:18.44,0:17:20.22,English,,0,0,0,,And then some of the pages are
Dialogue: 0,0:17:18.44,0:17:20.22,Chinese,,0,0,0,,然后是一些页面
Dialogue: 0,0:17:21.48,0:17:27.14,English,,0,0,0,,Not allocated so there's a null entry in the page table
Dialogue: 0,0:17:21.48,0:17:27.14,Chinese,,0,0,0,,未分配，因此页表中有一个空条目
Dialogue: 0,0:17:31.52,0:17:32.40,English,,0,0,0,,Now a page hit
Dialogue: 0,0:17:31.52,0:17:32.40,Chinese,,0,0,0,,现在一个页面命中
Dialogue: 0,0:17:32.94,0:17:35.68,English,,0,0,0,,So this is just a cache right,so we have hits and misses
Dialogue: 0,0:17:32.94,0:17:35.68,Chinese,,0,0,0,,所以这只是一个缓存权限，所以我们有点击和未命中
Dialogue: 0,0:17:36.46,0:17:42.20,English,,0,0,0,,So a page hit occurs when there's a reference to a word in the virtual address space
Dialogue: 0,0:17:36.46,0:17:42.20,Chinese,,0,0,0,,因此，当存在对虚拟地址空间中的单词的引用时，会发生页面命中
Dialogue: 0,0:17:42.90,0:17:46.70,English,,0,0,0,,That's contained in a page that's cached in the DRAM
Dialogue: 0,0:17:42.90,0:17:46.70,Chinese,,0,0,0,,这包含在缓存在DRAM中的页面中
Dialogue: 0,0:17:48.94,0:17:55.20,English,,0,0,0,,Okay so let's say that we have you know the CPU execute this and move instruction it generates a virtual address
Dialogue: 0,0:17:48.94,0:17:55.20,Chinese,,0,0,0,,好吧，让我们说我们让你知道CPU执行它并移动指令它生成一个虚拟地址
Dialogue: 0,0:17:56.78,0:17:57.96,English,,0,0,0,,The MMU
Dialogue: 0,0:17:56.78,0:17:57.96,Chinese,,0,0,0,,MMU
Dialogue: 0,0:17:59.44,0:18:07.08,English,,0,0,0,,Looks up in the page table and let's say this virtual address is somewhere within virtual page 2
Dialogue: 0,0:17:59.44,0:18:07.08,Chinese,,0,0,0,,在页面表中查找，假设此虚拟地址位于虚拟页面2中的某个位置
Dialogue: 0,0:18:09.32,0:18:14.94,English,,0,0,0,,Okay so that the MMU looks up the page table entry number 2
Dialogue: 0,0:18:09.32,0:18:14.94,Chinese,,0,0,0,,好的，以便MMU查找页表条目号2
Dialogue: 0,0:18:16.06,0:18:23.52,English,,0,0,0,,And it extracts the physical address of that of that virtual page 2
Dialogue: 0,0:18:16.06,0:18:23.52,Chinese,,0,0,0,,并且它提取该虚拟页面2的物理地址
Dialogue: 0,0:18:25.68,0:18:27.26,English,,0,0,0,,Okay so that's a, so in this case
Dialogue: 0,0:18:25.68,0:18:27.26,Chinese,,0,0,0,,好的，所以这是一个，所以在这种情况下
Dialogue: 0,0:18:30.16,0:18:35.24,English,,0,0,0,,In this case the page is in memory it's cached in memory
Dialogue: 0,0:18:30.16,0:18:35.24,Chinese,,0,0,0,,在这种情况下，页面在内存中，它被缓存在内存中
Dialogue: 0,0:18:35.70,0:18:37.08,English,,0,0,0,,And so we have a hit
Dialogue: 0,0:18:35.70,0:18:37.08,Chinese,,0,0,0,,所以我们受到了打击
Dialogue: 0,0:18:37.54,0:18:48.12,English,,0,0,0,,And now the memory can return that,can return that physical address to the MMU
Dialogue: 0,0:18:37.54,0:18:48.12,Chinese,,0,0,0,,现在内存可以返回，可以将该物理地址返回给MMU
Dialogue: 0,0:18:52.46,0:19:00.94,English,,0,0,0,,Now a miss is a reference to a word that's not cashed in physical memory
Dialogue: 0,0:18:52.46,0:19:00.94,Chinese,,0,0,0,,现在，未命中是对未在物理内存中兑现的单词的引用
Dialogue: 0,0:19:00.94,0:19:08.42,English,,0,0,0,,So in this case virtual page 0,1,2,3 is not cached in DRAM
Dialogue: 0,0:19:00.94,0:19:08.42,Chinese,,0,0,0,,因此，在这种情况下，虚拟页面0,1,2,3不会缓存在DRAM中
Dialogue: 0,0:19:08.42,0:19:10.40,English,,0,0,0,,It's stored on the disk
Dialogue: 0,0:19:08.42,0:19:10.40,Chinese,,0,0,0,,它存储在磁盘上
Dialogue: 0,0:19:13.58,0:19:18.40,English,,0,0,0,,So now that triggers an exception ok page fault exception
Dialogue: 0,0:19:13.58,0:19:18.40,Chinese,,0,0,0,,所以现在触发异常ok页面错误异常
Dialogue: 0,0:19:19.12,0:19:21.34,English,,0,0,0,,In the hardware the hardware triggers the exception
Dialogue: 0,0:19:19.12,0:19:21.34,Chinese,,0,0,0,,在硬件中，硬件触发异常
Dialogue: 0,0:19:21.66,0:19:27.66,English,,0,0,0,,And that causes the transfer of control to a chunk of code in the kernel called the page fault handler
Dialogue: 0,0:19:21.66,0:19:27.66,Chinese,,0,0,0,,这导致控制转移到内核中称为页面错误处理程序的一大块代码
Dialogue: 0,0:19:28.84,0:19:35.54,English,,0,0,0,,Which then selects a victim to be evicted,in this case virtual page 4
Dialogue: 0,0:19:28.84,0:19:35.54,Chinese,,0,0,0,,然后选择要驱逐的受害者，在这种情况下是虚拟页面4
Dialogue: 0,0:19:37.20,0:19:41.12,English,,0,0,0,,And it fetches virtual page 3 from the disk
Dialogue: 0,0:19:37.20,0:19:41.12,Chinese,,0,0,0,,它从磁盘中获取虚拟页面3
Dialogue: 0,0:19:43.46,0:19:45.00,English,,0,0,0,,Loads it up into memory
Dialogue: 0,0:19:43.46,0:19:45.00,Chinese,,0,0,0,,将其加载到内存中
Dialogue: 0,0:19:45.72,0:19:54.80,English,,0,0,0,,And if and then changes,and then updates this page table entry to reflect the fact that virtual page 4 is now stored on disk
Dialogue: 0,0:19:45.72,0:19:54.80,Chinese,,0,0,0,,然后更改，然后更新此页表条目以反映虚拟页面4现在存储在磁盘上的事实
Dialogue: 0,0:19:55.72,0:20:01.64,English,,0,0,0,,And if virtual page 4 had been modified at any time it would have to write the contents of it that to disk as well
Dialogue: 0,0:19:55.72,0:20:01.64,Chinese,,0,0,0,,如果虚拟页面4在任何时候都被修改过，那么它也必须将它的内容写入磁盘
Dialogue: 0,0:20:06.04,0:20:12.52,English,,0,0,0,,So once the handler is copied virtual page 3 into memory
Dialogue: 0,0:20:06.04,0:20:12.52,Chinese,,0,0,0,,因此，一旦处理程序将虚拟页面3复制到内存中
Dialogue: 0,0:20:13.40,0:20:17.95,English,,0,0,0,,The instruction that caused the page fault now can be re-executed
Dialogue: 0,0:20:13.40,0:20:17.95,Chinese,,0,0,0,,现在可以重新执行导致页面错误的指令
Dialogue: 0,0:20:18.82,0:20:25.30,English,,0,0,0,,Okay so once the...so when the page fault handler in the kernel returns it returns to the faulting instruction
Dialogue: 0,0:20:18.82,0:20:25.30,Chinese,,0,0,0,,好的，所以一旦......所以当内核中的页面错误处理程序返回时，它返回到错误指令
Dialogue: 0,0:20:25.72,0:20:26.90,English,,0,0,0,,Which then reacts acutes
Dialogue: 0,0:20:25.72,0:20:26.90,Chinese,,0,0,0,,然后反应急剧
Dialogue: 0,0:20:28.20,0:20:35.84,English,,0,0,0,,And now that page is when the MMU checks that the PTE corresponding to that page
Dialogue: 0,0:20:28.20,0:20:35.84,Chinese,,0,0,0,,现在该页面是MMU检查对应于该页面的PTE的时候
Dialogue: 0,0:20:36.38,0:20:38.26,English,,0,0,0,,It finds that it's indeed cache so
Dialogue: 0,0:20:36.38,0:20:38.26,Chinese,,0,0,0,,它发现它确实缓存了
Dialogue: 0,0:20:38.56,0:20:43.04,English,,0,0,0,,So now the instruction can continue and we can fetch that
Dialogue: 0,0:20:38.56,0:20:43.04,Chinese,,0,0,0,,所以现在指令可以继续，我们可以获取它
Dialogue: 0,0:20:44.80,0:20:49.30,English,,0,0,0,,Whatever word at that virtual address from the DRAM
Dialogue: 0,0:20:44.80,0:20:49.30,Chinese,,0,0,0,,无论来自DRAM的虚拟地址是什么字
Dialogue: 0,0:20:54.58,0:20:57.08,English,,0,0,0,,Okay now we can allocate a new page of memories
Dialogue: 0,0:20:54.58,0:20:57.08,Chinese,,0,0,0,,好的，现在我们可以分配一个新的记忆页面
Dialogue: 0,0:20:57.08,0:21:03.98,English,,0,0,0,,So in this example virtual page 0,1,2,3,4,5 is not allocated
Dialogue: 0,0:20:57.08,0:21:03.98,Chinese,,0,0,0,,因此，在此示例中，未分配虚拟页面0,1,2,3,4,5
Dialogue: 0,0:21:06.48,0:21:12.04,English,,0,0,0,,So if you need to let's say you do malloc of a very large chunk of virtual address space
Dialogue: 0,0:21:06.48,0:21:12.04,Chinese,,0,0,0,,所以，如果你需要让你说你做了一大块虚拟地址空间的malloc
Dialogue: 0,0:21:12.62,0:21:17.54,English,,0,0,0,,If those pages,if one of those pages hasn't been allocated yet then the kernel actually
Dialogue: 0,0:21:12.62,0:21:17.54,Chinese,,0,0,0,,如果这些页面，如果尚未分配其中一个页面，那么实际上是内核
Dialogue: 0,0:21:18.26,0:21:24.16,English,,0,0,0,,Or the malloc function actually has to create allocate that memory by calling a function called s break
Dialogue: 0,0:21:18.26,0:21:24.16,Chinese,,0,0,0,,或者malloc函数实际上必须通过调用一个名为s break的函数来创建分配该内存
Dialogue: 0,0:21:25.38,0:21:29.26,English,,0,0,0,,Okay and then what s break does is actually allocates
Dialogue: 0,0:21:25.38,0:21:29.26,Chinese,,0,0,0,,好吧，然后休息的确实是分配
Dialogue: 0,0:21:29.74,0:21:37.92,English,,0,0,0,,This page and records where it's loaded now would probably actually put it up into
Dialogue: 0,0:21:29.74,0:21:37.92,Chinese,,0,0,0,,这个页面和记录它现在加载的位置实际上可能会把它放入
Dialogue: 0,0:21:40.30,0:21:45.87,English,,0,0,0,,Now I guess it wouldn't actually show up in the DRAM cache until it was that page was touched
Dialogue: 0,0:21:40.30,0:21:45.87,Chinese,,0,0,0,,现在我猜它实际上不会显示在DRAM缓存中，直到触摸该页面为止
Dialogue: 0,0:21:46.48,0:21:51.22,English,,0,0,0,,Okay so just allocating space just changes this page table entry
Dialogue: 0,0:21:46.48,0:21:51.22,Chinese,,0,0,0,,好的，只需分配空间只需更改此页表条目即可
Dialogue: 0,0:21:51.74,0:21:56.22,English,,0,0,0,,And then when that page is actually touched then it'll be brought into the cache
Dialogue: 0,0:21:51.74,0:21:56.22,Chinese,,0,0,0,,然后当实际触摸该页面时，它将被带入缓存
Dialogue: 0,0:21:58.18,0:22:02.72,English,,0,0,0,,So I don't know about you but the first time I learned about this I was
Dialogue: 0,0:21:58.18,0:22:02.72,Chinese,,0,0,0,,所以我不了解你，但我第一次了解到这一点
Dialogue: 0,0:22:02.82,0:22:08.52,English,,0,0,0,,I was pretty appalled it just seemed like the most inefficient terrible idea right
Dialogue: 0,0:22:02.82,0:22:08.52,Chinese,,0,0,0,,我非常震惊，它似乎是最低效的可怕想法
Dialogue: 0,0:22:09.00,0:22:17.94,English,,0,0,0,,How in the world can you afford to on every single instruction that uses memory
Dialogue: 0,0:22:09.00,0:22:17.94,Chinese,,0,0,0,,对于使用内存的每一条指令，你在世界上怎么能负担得起
Dialogue: 0,0:22:18.48,0:22:22.22,English,,0,0,0,,Do all this copying back and forth and looking up in tables
Dialogue: 0,0:22:18.48,0:22:22.22,Chinese,,0,0,0,,做所有这些来回复制并查阅表格
Dialogue: 0,0:22:22.64,0:22:24.08,English,,0,0,0,,And it just seems like an awful idea
Dialogue: 0,0:22:22.64,0:22:24.08,Chinese,,0,0,0,,这似乎是一个糟糕的主意
Dialogue: 0,0:22:24.64,0:22:26.52,English,,0,0,0,,But once again locality saves us
Dialogue: 0,0:22:24.64,0:22:26.52,Chinese,,0,0,0,,但是地方再次拯救了我们
Dialogue: 0,0:22:27.02,0:22:31.48,English,,0,0,0,,Okay and it actually works because programs have locality
Dialogue: 0,0:22:27.02,0:22:31.48,Chinese,,0,0,0,,好吧，它确实有效，因为程序有地方性
Dialogue: 0,0:22:32.44,0:22:35.70,English,,0,0,0,,Okay and it's actually fairly efficient
Dialogue: 0,0:22:32.44,0:22:35.70,Chinese,,0,0,0,,好的，它实际上相当有效
Dialogue: 0,0:22:36.92,0:22:43.34,English,,0,0,0,,And the reason is that at any point of time programs tend to access a set of pages called the working set
Dialogue: 0,0:22:36.92,0:22:43.34,Chinese,,0,0,0,,原因是在任何时候程序都倾向于访问一组称为工作集的页面
Dialogue: 0,0:22:43.88,0:22:51.04,English,,0,0,0,,Okay just by locality right by temporal locality,by the principle of temporal locality and spatial locality
Dialogue: 0,0:22:43.88,0:22:51.04,Chinese,,0,0,0,,通过时间局部性，时间局部性和空间局部性原则，仅仅通过局部性
Dialogue: 0,0:22:51.74,0:22:56.88,English,,0,0,0,,You tend to sort of reuse the same things reuse nearby things okay
Dialogue: 0,0:22:51.74,0:22:56.88,Chinese,,0,0,0,,你往往会重复使用相同的东西重复使用附近的东西
Dialogue: 0,0:22:57.14,0:23:02.42,English,,0,0,0,,And so if that working set is less than the main memory size
Dialogue: 0,0:22:57.14,0:23:02.42,Chinese,,0,0,0,,因此，如果该工作集小于主存储器大小
Dialogue: 0,0:23:02.42,0:23:06.70,English,,0,0,0,,Then all of the pages in the current were that will fit in memory and then things will be great
Dialogue: 0,0:23:02.42,0:23:06.70,Chinese,,0,0,0,,然后当前的所有页面都适合内存，然后事情就会很好
Dialogue: 0,0:23:09.50,0:23:14.92,English,,0,0,0,,Okay but if the some of the working set sizes for for every process right our systems running multiple processes
Dialogue: 0,0:23:09.50,0:23:14.92,Chinese,,0,0,0,,好的但是如果每个流程的一些工作集大小使我们的系统运行多个流程
Dialogue: 0,0:23:15.40,0:23:17.20,English,,0,0,0,,If it exceeds the main memory size
Dialogue: 0,0:23:15.40,0:23:17.20,Chinese,,0,0,0,,如果超过主内存大小
Dialogue: 0,0:23:18.10,0:23:25.56,English,,0,0,0,,Then you have this meltdown where processes are thrashing each other and causing pages to be copied back and forth
Dialogue: 0,0:23:18.10,0:23:25.56,Chinese,,0,0,0,,然后你就会发生这样的崩溃，其中进程互相颠簸并导致页面来回复制
Dialogue: 0,0:23:26.26,0:23:31.08,English,,0,0,0,,So you never ever know process ever gets it's working set fully into memory
Dialogue: 0,0:23:26.26,0:23:31.08,Chinese,,0,0,0,,因此，你永远不会知道进程将其工作集完全放入内存中
Dialogue: 0,0:23:33.58,0:23:36.50,English,,0,0,0,,Okay and we'll look at a technique when we look at address translation
Dialogue: 0,0:23:33.58,0:23:36.50,Chinese,,0,0,0,,好的，当我们查看地址转换时，我们会看一下这种技术
Dialogue: 0,0:23:36.50,0:23:40.62,English,,0,0,0,,We'll look at a little hardware cache called a translation look aside buffer
Dialogue: 0,0:23:36.50,0:23:40.62,Chinese,,0,0,0,,我们将看一个称为转换后备缓冲区的小硬件缓存
Dialogue: 0,0:23:41.00,0:23:44.92,English,,0,0,0,,That further exploits the locality property of programs
Dialogue: 0,0:23:41.00,0:23:44.92,Chinese,,0,0,0,,这进一步利用了程序的局部性
Dialogue: 0,0:23:46.58,0:23:49.34,English,,0,0,0,,Okay so that's virtual memory is a tool for caching
Dialogue: 0,0:23:46.58,0:23:49.34,Chinese,,0,0,0,,好吧，这样虚拟内存就是一种缓存工具
Dialogue: 0,0:23:49.84,0:23:53.00,English,,0,0,0,,It's also a member of tool for memory management
Dialogue: 0,0:23:49.84,0:23:53.00,Chinese,,0,0,0,,它也是内存管理工具的一员
Dialogue: 0,0:23:53.20,0:23:57.32,English,,0,0,0,,And it greatly simplifies all kinds of aspects of memory management for the kernel
Dialogue: 0,0:23:53.20,0:23:57.32,Chinese,,0,0,0,,它极大地简化了内核的各种内存管理方面
Dialogue: 0,0:23:59.72,0:24:04.38,English,,0,0,0,,So the key idea is that each process has its own virtual address space
Dialogue: 0,0:23:59.72,0:24:04.38,Chinese,,0,0,0,,所以关键的想法是每个进程都有自己的虚拟地址空间
Dialogue: 0,0:24:05.60,0:24:11.30,English,,0,0,0,,The kernel implements this by giving each process its own separate page table
Dialogue: 0,0:24:05.60,0:24:11.30,Chinese,,0,0,0,,内核通过为每个进程提供自己独立的页表来实现这一点
Dialogue: 0,0:24:11.92,0:24:15.62,English,,0,0,0,,In the context of that process so it's just a data structure in the kernel
Dialogue: 0,0:24:11.92,0:24:15.62,Chinese,,0,0,0,,在该过程的上下文中，它只是内核中的数据结构
Dialogue: 0,0:24:15.96,0:24:18.74,English,,0,0,0,,That the process key...that the kernel keeps for that process
Dialogue: 0,0:24:15.96,0:24:18.74,Chinese,,0,0,0,,内核为该进程保留的进程密钥
Dialogue: 0,0:24:22.54,0:24:29.84,English,,0,0,0,,And the page table for each process maps the virtual address space for that process
Dialogue: 0,0:24:22.54,0:24:29.84,Chinese,,0,0,0,,每个进程的页表都映射该进程的虚拟地址空间
Dialogue: 0,0:24:32.40,0:24:39.18,English,,0,0,0,,Now what's interesting so you have that these pages contiguous pages in the virtual address space
Dialogue: 0,0:24:32.40,0:24:39.18,Chinese,,0,0,0,,现在有趣的是让你在虚拟地址空间中拥有这些页面连续的页面
Dialogue: 0,0:24:39.54,0:24:44.08,English,,0,0,0,,Can be mapped anywhere in the DRAM,in the physical address space
Dialogue: 0,0:24:39.54,0:24:44.08,Chinese,,0,0,0,,可以映射到DRAM中的任何位置，在物理地址空间中
Dialogue: 0,0:24:44.78,0:24:47.62,English,,0,0,0,,So and they can be scattered all over the place
Dialogue: 0,0:24:44.78,0:24:47.62,Chinese,,0,0,0,,所以他们可以分散在各处
Dialogue: 0,0:24:48.48,0:24:55.30,English,,0,0,0,,And different virtual pages and different processes can be mapped to different physical pages
Dialogue: 0,0:24:48.48,0:24:55.30,Chinese,,0,0,0,,并且可以将不同的虚拟页面和不同的进程映射到不同的物理页面
Dialogue: 0,0:24:55.30,0:24:59.38,English,,0,0,0,,So here we have virtual page one which is mapped to physical page two
Dialogue: 0,0:24:55.30,0:24:59.38,Chinese,,0,0,0,,所以这里我们有虚拟页面1映射到物理页面2
Dialogue: 0,0:25:00.44,0:25:06.02,English,,0,0,0,,In process 1 but in process 2 virtual page one is mapped to physical page 8
Dialogue: 0,0:25:00.44,0:25:06.02,Chinese,,0,0,0,,在过程1中，但在过程2中，虚拟页面1被映射到物理页面8
Dialogue: 0,0:25:06.92,0:25:14.50,English,,0,0,0,,Okay so in this way we can present a view to each,to the programmer and to the tools
Dialogue: 0,0:25:06.92,0:25:14.50,Chinese,,0,0,0,,好的，通过这种方式，我们可以为每个人，程序员和工具提供一个视图
Dialogue: 0,0:25:15.66,0:25:20.54,English,,0,0,0,,That each process has a very similar address space virtual address space
Dialogue: 0,0:25:15.66,0:25:20.54,Chinese,,0,0,0,,每个进程都有一个非常相似的地址空间虚拟地址空间
Dialogue: 0,0:25:20.54,0:25:23.46,English,,0,0,0,,Same size address space code and data start at the same place
Dialogue: 0,0:25:20.54,0:25:23.46,Chinese,,0,0,0,,相同大小的地址空间代码和数据从同一个地方开始
Dialogue: 0,0:25:24.42,0:25:28.48,English,,0,0,0,,But then the actual pages that process used can be scattered in memory
Dialogue: 0,0:25:24.42,0:25:28.48,Chinese,,0,0,0,,但随后处理的实际页面可能会分散在内存中
Dialogue: 0,0:25:30.30,0:25:33.48,English,,0,0,0,,Okay and then it gives us the most efficient way to use the memory
Dialogue: 0,0:25:30.30,0:25:33.48,Chinese,,0,0,0,,好的，然后它为我们提供了使用内存的最有效方式
Dialogue: 0,0:25:35.74,0:25:41.52,English,,0,0,0,,If we didn't have this mechanism think about how would you keep track let's say you had 50 processes running
Dialogue: 0,0:25:35.74,0:25:41.52,Chinese,,0,0,0,,如果我们没有这个机制，请考虑如何跟踪让我们说你有50个进程在运行
Dialogue: 0,0:25:41.82,0:25:43.68,English,,0,0,0,,On the machine at any point in time
Dialogue: 0,0:25:41.82,0:25:43.68,Chinese,,0,0,0,,在任何时间点的机器上
Dialogue: 0,0:25:43.84,0:25:50.36,English,,0,0,0,,How in the world would you keep track of where all of the the data  those processes were using
Dialogue: 0,0:25:43.84,0:25:50.36,Chinese,,0,0,0,,如何在世界上跟踪这些进程使用的所有数据的位置
Dialogue: 0,0:25:51.58,0:25:57.92,English,,0,0,0,,Well one technique that you could imagine in fact it was used in the in the bad old days but before virtual memory
Dialogue: 0,0:25:51.58,0:25:57.92,Chinese,,0,0,0,,那么你可以想象的一种技术实际上它是在过去的糟糕时期但在虚拟内存之前使用的
Dialogue: 0,0:25:58.52,0:26:03.46,English,,0,0,0,,One thing you can imagine is that just give every process its own chunk of the physical address space
Dialogue: 0,0:25:58.52,0:26:03.46,Chinese,,0,0,0,,你可以想象的一件事是，只需为每个进程提供物理地址空间的一部分
Dialogue: 0,0:26:03.98,0:26:06.46,English,,0,0,0,,Just take your physical address space partition it
Dialogue: 0,0:26:03.98,0:26:06.46,Chinese,,0,0,0,,只需将你的物理地址空间分区即可
Dialogue: 0,0:26:07.08,0:26:11.18,English,,0,0,0,,And then each process gets loads and runs and it's own part of the address space
Dialogue: 0,0:26:07.08,0:26:11.18,Chinese,,0,0,0,,然后每个进程都获得加载和运行，它是地址空间的一部分
Dialogue: 0,0:26:12.42,0:26:14.84,English,,0,0,0,,Well this has all kinds of problems right I mean you could
Dialogue: 0,0:26:12.42,0:26:14.84,Chinese,,0,0,0,,嗯这有各种各样的问题，我的意思是你可以
Dialogue: 0,0:26:15.56,0:26:17.88,English,,0,0,0,,If you what do you do if you add a process
Dialogue: 0,0:26:15.56,0:26:17.88,Chinese,,0,0,0,,如果你添加了一个过程，你会怎么做
Dialogue: 0,0:26:19.66,0:26:23.20,English,,0,0,0,,So you really can't partition the address space you really have to sort of say well
Dialogue: 0,0:26:19.66,0:26:23.20,Chinese,,0,0,0,,所以你真的无法对你真正需要的地址空间进行分区
Dialogue: 0,0:26:23.70,0:26:25.64,English,,0,0,0,,Each process gets some little chunk
Dialogue: 0,0:26:23.70,0:26:25.64,Chinese,,0,0,0,,每个进程都有一些小块
Dialogue: 0,0:26:25.88,0:26:30.14,English,,0,0,0,,And I'm going to reserve some of the address space in case there's new processes that need memory
Dialogue: 0,0:26:25.88,0:26:30.14,Chinese,,0,0,0,,而且我会保留一些地址空间，以防新的进程需要内存
Dialogue: 0,0:26:31.94,0:26:34.38,English,,0,0,0,,Another problem is that now you have to write your programs
Dialogue: 0,0:26:31.94,0:26:34.38,Chinese,,0,0,0,,另一个问题是，现在你必须编写你的程序
Dialogue: 0,0:26:35.14,0:26:37.56,English,,0,0,0,,You can't just link your program ahead of time
Dialogue: 0,0:26:35.14,0:26:37.56,Chinese,,0,0,0,,你不能提前链接你的计划
Dialogue: 0,0:26:38.40,0:26:42.06,English,,0,0,0,,Because it has to be relocated when it's loaded right
Dialogue: 0,0:26:38.40,0:26:42.06,Chinese,,0,0,0,,因为它必须在正确加载时重新定位
Dialogue: 0,0:26:42.06,0:26:48.06,English,,0,0,0,,Because you don't...you know a process, you don't know where in the memory it's going to go, it's going to get some chunk
Dialogue: 0,0:26:42.06,0:26:48.06,Chinese,,0,0,0,,因为你没有......你知道一个过程，你不知道它将会在内存中去哪里，它会得到一些大块
Dialogue: 0,0:26:49.12,0:26:52.28,English,,0,0,0,,So you have to either relocate all the the references
Dialogue: 0,0:26:49.12,0:26:52.28,Chinese,,0,0,0,,所以你必须要重新定位所有的引用
Dialogue: 0,0:26:53.52,0:26:57.10,English,,0,0,0,,That the references to global symbols at when it's actually loaded
Dialogue: 0,0:26:53.52,0:26:57.10,Chinese,,0,0,0,,在实际加载时引用全局符号
Dialogue: 0,0:26:58.42,0:27:03.20,English,,0,0,0,,Or you have to create a system where all of the instructions are relative
Dialogue: 0,0:26:58.42,0:27:03.20,Chinese,,0,0,0,,或者你必须创建一个所有指令都是相对的系统
Dialogue: 0,0:27:03.50,0:27:06.22,English,,0,0,0,,So there's no absolute addresses
Dialogue: 0,0:27:03.50,0:27:06.22,Chinese,,0,0,0,,所以没有绝对的地址
Dialogue: 0,0:27:06.86,0:27:10.78,English,,0,0,0,,All addresses are relative to say the start of the program something like that
Dialogue: 0,0:27:06.86,0:27:10.78,Chinese,,0,0,0,,所有地址都相对于程序的开头而言就是这样
Dialogue: 0,0:27:11.79,0:27:14.22,English,,0,0,0,,So anyway all of these things are just terribly complicated
Dialogue: 0,0:27:11.79,0:27:14.22,Chinese,,0,0,0,,所以，无论如何，所有这些事情都非常复杂
Dialogue: 0,0:27:15.24,0:27:20.04,English,,0,0,0,,And they're all solved beautifully by virtual memory
Dialogue: 0,0:27:15.24,0:27:20.04,Chinese,,0,0,0,,它们都被虚拟内存完美地解决了
Dialogue: 0,0:27:26.14,0:27:31.78,English,,0,0,0,,So the each virtual page can be mapped to any physical page so that really helps simplify things
Dialogue: 0,0:27:26.14,0:27:31.78,Chinese,,0,0,0,,因此，每个虚拟页面都可以映射到任何物理页面，这样可以真正帮助简化操作
Dialogue: 0,0:27:32.56,0:27:38.48,English,,0,0,0,,And even at different times the same virtual page can be stored in different physical pages at different times
Dialogue: 0,0:27:32.56,0:27:38.48,Chinese,,0,0,0,,甚至在不同时间，相同的虚拟页面可以在不同的时间存储在不同的物理页面中
Dialogue: 0,0:27:38.90,0:27:42.58,English,,0,0,0,,All right so if a page for it,for a while it might be cached in one physical page
Dialogue: 0,0:27:38.90,0:27:42.58,Chinese,,0,0,0,,好吧，如果它是一个页面，有一段时间可能会缓存在一个物理页面中
Dialogue: 0,0:27:42.94,0:27:45.12,English,,0,0,0,,Then it gets swapped out and the next time it's referenced
Dialogue: 0,0:27:42.94,0:27:45.12,Chinese,,0,0,0,,然后它被换出并在下次引用时
Dialogue: 0,0:27:45.56,0:27:50.36,English,,0,0,0,,It can get cached in a different physical page that if it's no longer available
Dialogue: 0,0:27:45.56,0:27:50.36,Chinese,,0,0,0,,如果它不再可用，它可以缓存在不同的物理页面中
Dialogue: 0,0:27:50.50,0:27:56.12,English,,0,0,0,,Right so it provides so the most flexible scheduling freedom
Dialogue: 0,0:27:50.50,0:27:56.12,Chinese,,0,0,0,,对，因此它提供了最灵活的调度自由度
Dialogue: 0,0:27:58.56,0:28:01.82,English,,0,0,0,,In the way that we in...the way that we manage the memory
Dialogue: 0,0:27:58.56,0:28:01.82,Chinese,,0,0,0,,以我们处理记忆的方式
Dialogue: 0,0:28:03.04,0:28:05.54,English,,0,0,0,,And it also provides this really neat capability
Dialogue: 0,0:28:03.04,0:28:05.54,Chinese,,0,0,0,,它还提供了这种非常巧妙的功能
Dialogue: 0,0:28:05.96,0:28:08.90,English,,0,0,0,,Where you can map virtual pages to the same physical page
Dialogue: 0,0:28:05.96,0:28:08.90,Chinese,,0,0,0,,你可以在哪里将虚拟页面映射到同一物理页面
Dialogue: 0,0:28:09.72,0:28:18.40,English,,0,0,0,,So there's this is a very simple straightforward way for multiple processes to share certain code or data
Dialogue: 0,0:28:09.72,0:28:18.40,Chinese,,0,0,0,,因此，对于多个进程共享某些代码或数据，这是一种非常简单的直接方式
Dialogue: 0,0:28:19.64,0:28:27.48,English,,0,0,0,,Okay and what you do is you just that the page table entry in these different processes
Dialogue: 0,0:28:19.64,0:28:27.48,Chinese,,0,0,0,,好的，你所做的只是这些不同进程中的页表条目
Dialogue: 0,0:28:27.52,0:28:29.56,English,,0,0,0,,Just points to the same physical page
Dialogue: 0,0:28:27.52,0:28:29.56,Chinese,,0,0,0,,只需指向相同的物理页面即可
Dialogue: 0,0:28:29.56,0:28:34.52,English,,0,0,0,,So in this case virtual page 2 points to physical page 6
Dialogue: 0,0:28:29.56,0:28:34.52,Chinese,,0,0,0,,因此，在这种情况下，虚拟页面2指向物理页面6
Dialogue: 0,0:28:34.58,0:28:39.74,English,,0,0,0,,In each of the page tables for process 1 and process 2
Dialogue: 0,0:28:34.58,0:28:39.74,Chinese,,0,0,0,,在流程1和流程2的每个页面表中
Dialogue: 0,0:28:41.04,0:28:44.02,English,,0,0,0,,So this is how shared libraries are implemented
Dialogue: 0,0:28:41.04,0:28:44.02,Chinese,,0,0,0,,这就是共享库的实现方式
Dialogue: 0,0:28:44.62,0:28:48.70,English,,0,0,0,,Right so lib.c is the same code for every process running on the system
Dialogue: 0,0:28:44.62,0:28:48.70,Chinese,,0,0,0,,对，所以lib.c与系统上运行的每个进程的代码相同
Dialogue: 0,0:28:49.66,0:28:54.26,English,,0,0,0,,So lib.c just needs to be loaded once into physical into physical memory
Dialogue: 0,0:28:49.66,0:28:54.26,Chinese,,0,0,0,,所以lib.c只需要一次加载到物理内存中
Dialogue: 0,0:28:54.96,0:28:59.76,English,,0,0,0,,And then processes that want to access functions and data in lib.c just map
Dialogue: 0,0:28:54.96,0:28:59.76,Chinese,,0,0,0,,然后想要访问lib.c中的函数和数据的进程只是映射
Dialogue: 0,0:29:00.42,0:29:05.28,English,,0,0,0,,The pages in their virtual address space to the physical pages where lib.c is actually loaded
Dialogue: 0,0:29:00.42,0:29:05.28,Chinese,,0,0,0,,虚拟地址空间中的页面指向实际加载lib.c的物理页面
Dialogue: 0,0:29:06.34,0:29:09.44,English,,0,0,0,,Ok so now there's only one copy of lib.c everywhere in the system
Dialogue: 0,0:29:06.34,0:29:09.44,Chinese,,0,0,0,,好的，现在系统中只有一个lib.c的副本
Dialogue: 0,0:29:09.92,0:29:12.10,English,,0,0,0,,But every process thinks it's got its own copy
Dialogue: 0,0:29:09.92,0:29:12.10,Chinese,,0,0,0,,但每个过程都认为它有自己的副本
Dialogue: 0,0:29:16.88,0:29:23.12,English,,0,0,0,,Now this virtual memory for...
Dialogue: 0,0:29:16.88,0:29:23.12,Chinese,,0,0,0,,现在这个虚拟内存...
Dialogue: 0,0:29:23.40,0:29:29.04,English,,0,0,0,,Using virtual memory to help simplify memory management greatly simplifies linking and loading
Dialogue: 0,0:29:23.40,0:29:29.04,Chinese,,0,0,0,,使用虚拟内存来帮助简化内存管理可以大大简化链接和加载
Dialogue: 0,0:29:30.16,0:29:31.94,English,,0,0,0,,Ok for the reasons I mentioned before
Dialogue: 0,0:29:30.16,0:29:31.94,Chinese,,0,0,0,,好的，我之前提到的原因
Dialogue: 0,0:29:31.94,0:29:37.70,English,,0,0,0,,Linkers now can assume that every program is going to be loaded at exactly the same place
Dialogue: 0,0:29:31.94,0:29:37.70,Chinese,,0,0,0,,Linkers现在可以假设每个程序都将在完全相同的位置加载
Dialogue: 0,0:29:37.88,0:29:40.40,English,,0,0,0,,So the linker knows ahead of time where everything is going to be
Dialogue: 0,0:29:37.88,0:29:40.40,Chinese,,0,0,0,,所以链接器提前知道所有内容将会是什么
Dialogue: 0,0:29:41.28,0:29:45.72,English,,0,0,0,,And then it can resolve it can relocate all those references accordingly
Dialogue: 0,0:29:41.28,0:29:45.72,Chinese,,0,0,0,,然后它可以解决它可以相应地重新定位所有这些引用
Dialogue: 0,0:29:49.46,0:29:53.60,English,,0,0,0,,Now it really makes loading as simple
Dialogue: 0,0:29:49.46,0:29:53.60,Chinese,,0,0,0,,现在它确实使加载变得简单
Dialogue: 0,0:29:55.90,0:29:58.08,English,,0,0,0,,So what...so execve the loader
Dialogue: 0,0:29:55.90,0:29:58.08,Chinese,,0,0,0,,那么...所以...执行加载器
Dialogue: 0,0:30:00.62,0:30:05.40,English,,0,0,0,,If you want to load a program now execve looks at the elf binary the executable binary
Dialogue: 0,0:30:00.62,0:30:05.40,Chinese,,0,0,0,,如果要加载程序，现在execve查看elf二进制文件的可执行二进制文件
Dialogue: 0,0:30:06.50,0:30:12.80,English,,0,0,0,,Ok it sees how it identifies how big the code and the data sections in that binary are
Dialogue: 0,0:30:06.50,0:30:12.80,Chinese,,0,0,0,,好吧，它看到它如何识别该二进制文件中的代码和数据部分有多大
Dialogue: 0,0:30:14.04,0:30:18.70,English,,0,0,0,,It allocates virtual memory starting at a fixed address for the code and data
Dialogue: 0,0:30:14.04,0:30:18.70,Chinese,,0,0,0,,它从代码和数据的固定地址开始分配虚拟内存
Dialogue: 0,0:30:21.04,0:30:24.38,English,,0,0,0,,It creates PTEs for them and marks each of them is invalid
Dialogue: 0,0:30:21.04,0:30:24.38,Chinese,,0,0,0,,它为它们创建PTE并标记它们中的每一个都是无效的
Dialogue: 0,0:30:26.14,0:30:31.62,English,,0,0,0,,Ok so each PTE contains a valid mapping
Dialogue: 0,0:30:26.14,0:30:31.62,Chinese,,0,0,0,,好的，所以每个PTE都包含一个有效的映射
Dialogue: 0,0:30:31.62,0:30:37.06,English,,0,0,0,,So each PTE that's mapped to code and data contains a valid physical page number
Dialogue: 0,0:30:31.62,0:30:37.06,Chinese,,0,0,0,,因此，映射到代码和数据的每个PTE都包含有效的物理页码
Dialogue: 0,0:30:38.04,0:30:42.88,English,,0,0,0,,But then the it does this trick of setting the valid bit to 0
Dialogue: 0,0:30:38.04,0:30:42.88,Chinese,,0,0,0,,但是它确实将有效位设置为0
Dialogue: 0,0:30:45.46,0:30:50.70,English,,0,0,0,,So when the MMU x encounters a PTE whose valid bit is 0
Dialogue: 0,0:30:45.46,0:30:50.70,Chinese,,0,0,0,,因此，当MMU x遇到有效位为0的PTE时
Dialogue: 0,0:30:51.66,0:30:52.96,English,,0,0,0,,It triggers a page fault
Dialogue: 0,0:30:51.66,0:30:52.96,Chinese,,0,0,0,,它会触发页面错误
Dialogue: 0,0:30:53.30,0:30:57.36,English,,0,0,0,,Right it looks as though that page is not been initialized yet
Dialogue: 0,0:30:53.30,0:30:57.36,Chinese,,0,0,0,,看起来好像该页面尚未初始化
Dialogue: 0,0:30:57.54,0:30:58.36,English,,0,0,0,,So it's kind of a trick
Dialogue: 0,0:30:57.54,0:30:58.36,Chinese,,0,0,0,,所以这是一个伎俩
Dialogue: 0,0:30:59.72,0:31:03.88,English,,0,0,0,,Right and then that triggers a page fault to the kernel
Dialogue: 0,0:30:59.72,0:31:03.88,Chinese,,0,0,0,,正确然后触发内核的页面错误
Dialogue: 0,0:31:06.02,0:31:16.32,English,,0,0,0,,And then the kernel will then can then copy that that page into physical memory
Dialogue: 0,0:31:06.02,0:31:16.32,Chinese,,0,0,0,,然后内核可以将该页面复制到物理内存中
Dialogue: 0,0:31:17.14,0:31:23.86,English,,0,0,0,,Ok so this the loading actually programs and data aren't actually they're not low loaded
Dialogue: 0,0:31:17.14,0:31:23.86,Chinese,,0,0,0,,好的，这样加载实际上程序和数据实际上并不是它们没有低负载
Dialogue: 0,0:31:24.40,0:31:26.36,English,,0,0,0,,You know they're not just like copied into memory
Dialogue: 0,0:31:24.40,0:31:26.36,Chinese,,0,0,0,,你知道他们不只是像复制到记忆中一样
Dialogue: 0,0:31:27.16,0:31:32.52,English,,0,0,0,,It happens as a result of of page faults,it happens as a result of misses
Dialogue: 0,0:31:27.16,0:31:32.52,Chinese,,0,0,0,,它是由于页面错误而发生的，它是由于未命中而发生的
Dialogue: 0,0:31:34.76,0:31:39.44,English,,0,0,0,,When and it's deferred to until a byte in that page is accessed
Dialogue: 0,0:31:34.76,0:31:39.44,Chinese,,0,0,0,,什么时候推迟到该页面中的一个字节被访问
Dialogue: 0,0:31:40.26,0:31:42.02,English,,0,0,0,,Okay so this is called demand paging okay
Dialogue: 0,0:31:40.26,0:31:42.02,Chinese,,0,0,0,,好的，所以这叫做需求分页好吧
Dialogue: 0,0:31:43.26,0:31:46.30,English,,0,0,0,,But it's really just like any of the other caches we've looked at right
Dialogue: 0,0:31:43.26,0:31:46.30,Chinese,,0,0,0,,但它真的就像我们看到的任何其他缓存一样
Dialogue: 0,0:31:46.30,0:31:53.36,English,,0,0,0,,You don't load a block into the cache until a word within that block is accessed okay
Dialogue: 0,0:31:46.30,0:31:53.36,Chinese,,0,0,0,,你不会将块加载到缓存中，直到该块中的单词被访问为止
Dialogue: 0,0:31:55.98,0:32:00.96,English,,0,0,0,,So loading actually...so loading is actually this is a very efficient mechanism right because
Dialogue: 0,0:31:55.98,0:32:00.96,Chinese,,0,0,0,,所以实际加载...所以加载实际上这是一个非常有效的机制，因为
Dialogue: 0,0:32:01.54,0:32:08.42,English,,0,0,0,,You may have a program that contains a huge,say a huge array,a large array
Dialogue: 0,0:32:01.54,0:32:08.42,Chinese,,0,0,0,,你可能有一个程序包含一个巨大的阵列，一个巨大的阵列，一个大阵列
Dialogue: 0,0:32:08.90,0:32:11.32,English,,0,0,0,,But you're only accessing a portion of that array
Dialogue: 0,0:32:08.90,0:32:11.32,Chinese,,0,0,0,,但是你只是访问该数组的一部分
Dialogue: 0,0:32:12.70,0:32:18.90,English,,0,0,0,,So that entire array won't actually be be allocated the pages will only come into DRAM
Dialogue: 0,0:32:12.70,0:32:18.90,Chinese,,0,0,0,,因此，实际上不会分配整个阵列，页面只会进入DRAM
Dialogue: 0,0:32:19.60,0:32:22.04,English,,0,0,0,,When they're...when a word within that page is touched
Dialogue: 0,0:32:19.60,0:32:22.04,Chinese,,0,0,0,,当他们......当触摸该页面中的某个单词时
Dialogue: 0,0:32:23.02,0:32:26.20,English,,0,0,0,,So if you're only accessing a portion of this extremely large array
Dialogue: 0,0:32:23.02,0:32:26.20,Chinese,,0,0,0,,所以如果你只是访问这个极大数组的一部分
Dialogue: 0,0:32:27.24,0:32:31.60,English,,0,0,0,,Only the data that you access gets loaded and used
Dialogue: 0,0:32:27.24,0:32:31.60,Chinese,,0,0,0,,只有你访问的数据才会被加载和使用
Dialogue: 0,0:32:32.02,0:32:38.44,English,,0,0,0,,So it's a very very smart mechanism and extremely helpful for
Dialogue: 0,0:32:32.02,0:32:38.44,Chinese,,0,0,0,,所以这是一个非常非常聪明的机制，非常有用
Dialogue: 0,0:32:38.60,0:32:41.54,English,,0,0,0,,For allowing us to use this precious memory resource
Dialogue: 0,0:32:38.60,0:32:41.54,Chinese,,0,0,0,,允许我们使用这种宝贵的内存资源
Dialogue: 0,0:32:43.58,0:32:54.66,English,,0,0,0,,Okay so the third motivation for virtual memory is that it helps us protect portions of memory
Dialogue: 0,0:32:43.58,0:32:54.66,Chinese,,0,0,0,,好吧，虚拟内存的第三个动机是它可以帮助我们保护内存的一部分
Dialogue: 0,0:32:55.84,0:32:58.72,English,,0,0,0,,So you recall that our processes
Dialogue: 0,0:32:55.84,0:32:58.72,Chinese,,0,0,0,,所以你记得我们的流程
Dialogue: 0,0:32:59.32,0:33:04.56,English,,0,0,0,,You know portions of our virtual address space or read-only like the code section
Dialogue: 0,0:32:59.32,0:33:04.56,Chinese,,0,0,0,,你知道我们的虚拟地址空间的一部分或只是代码部分的只读
Dialogue: 0,0:33:06.60,0:33:10.86,English,,0,0,0,,Okay and there are other portions of the address space that can only be executed by the kernel
Dialogue: 0,0:33:06.60,0:33:10.86,Chinese,,0,0,0,,好的，地址空间的其他部分只能由内核执行
Dialogue: 0,0:33:13.38,0:33:14.30,English,,0,0,0,,So on...
Dialogue: 0,0:33:13.38,0:33:14.30,Chinese,,0,0,0,,所以......
Dialogue: 0,0:33:17.96,0:33:20.98,English,,0,0,0,,On systems like x86-64
Dialogue: 0,0:33:17.96,0:33:20.98,Chinese,,0,0,0,,在像x86-64这样的系统上
Dialogue: 0,0:33:21.68,0:33:24.34,English,,0,0,0,,It's a 64-bit system
Dialogue: 0,0:33:21.68,0:33:24.34,Chinese,,0,0,0,,这是一个64位系统
Dialogue: 0,0:33:24.46,0:33:27.46,English,,0,0,0,,So the pointers and addresses or 64 bits
Dialogue: 0,0:33:24.46,0:33:27.46,Chinese,,0,0,0,,所以指针和地址或64位
Dialogue: 0,0:33:28.56,0:33:32.16,English,,0,0,0,,But in actuality the real virtual address space is 48 bits
Dialogue: 0,0:33:28.56,0:33:32.16,Chinese,,0,0,0,,但实际上，真正的虚拟地址空间是48位
Dialogue: 0,0:33:33.28,0:33:35.40,English,,0,0,0,,Okay so it's only..it's 2^48
Dialogue: 0,0:33:33.28,0:33:35.40,Chinese,,0,0,0,,好的，所以它只是..这是2 ^ 48
Dialogue: 0,0:33:36.44,0:33:42.85,English,,0,0,0,,And then the high-order bits after bit 48 are either all zeros or all ones
Dialogue: 0,0:33:36.44,0:33:42.85,Chinese,,0,0,0,,然后，位48之后的高位比特全部为零或全部为1
Dialogue: 0,0:33:43.74,0:33:44.40,English,,0,0,0,,Okay so
Dialogue: 0,0:33:43.74,0:33:44.40,Chinese,,0,0,0,,可以，然后呢
Dialogue: 0,0:33:46.22,0:33:51.14,English,,0,0,0,,And that's the that sort of intel's rule
Dialogue: 0,0:33:46.22,0:33:51.14,Chinese,,0,0,0,,这就是那种英特尔的规则
Dialogue: 0,0:33:53.16,0:33:58.58,English,,0,0,0,,And so the addresses where the high order bits are all ones are reserved for the kernel
Dialogue: 0,0:33:53.16,0:33:58.58,Chinese,,0,0,0,,因此，高位比特都是1的地址是为内核保留的
Dialogue: 0,0:33:58.80,0:34:01.18,English,,0,0,0,,The kernels code and the kernels data
Dialogue: 0,0:33:58.80,0:34:01.18,Chinese,,0,0,0,,内核代码和内核数据
Dialogue: 0,0:34:02.58,0:34:05.78,English,,0,0,0,,Okay the addresses were all the bits are zero or reserved for user code
Dialogue: 0,0:34:02.58,0:34:05.78,Chinese,,0,0,0,,好的地址是所有位都为零或保留用户代码
Dialogue: 0,0:34:06.66,0:34:11.98,English,,0,0,0,,Okay so any reference,any address that contains all ones in those higher order bits
Dialogue: 0,0:34:06.66,0:34:11.98,Chinese,,0,0,0,,好的任何引用，包含那些更高阶位的所有地址的任何地址
Dialogue: 0,0:34:12.62,0:34:16.38,English,,0,0,0,,Is by definition either code or data in the kernel
Dialogue: 0,0:34:12.62,0:34:16.38,Chinese,,0,0,0,,根据定义，内核中的代码或数据
Dialogue: 0,0:34:17.24,0:34:22.48,English,,0,0,0,,And so you can add bits to the PTE
Dialogue: 0,0:34:17.24,0:34:22.48,Chinese,,0,0,0,,因此你可以向PTE添加位
Dialogue: 0,0:34:23.20,0:34:28.66,English,,0,0,0,,That specify whether certain virtual pages can be accessed by user code
Dialogue: 0,0:34:23.20,0:34:28.66,Chinese,,0,0,0,,这指定了用户代码是否可以访问某些虚拟页面
Dialogue: 0,0:34:28.66,0:34:33.18,English,,0,0,0,,Or if they have to be accessed by the kernel,so this so-called supervisor mode
Dialogue: 0,0:34:28.66,0:34:33.18,Chinese,,0,0,0,,或者如果它们必须由内核访问，那么这就是所谓的管理员模式
Dialogue: 0,0:34:33.62,0:34:41.38,English,,0,0,0,,And you can also add bits that control whether that page can be read written or executed
Dialogue: 0,0:34:33.62,0:34:41.38,Chinese,,0,0,0,,你还可以添加控制该页面是否可以读取或执行的位
Dialogue: 0,0:34:42.12,0:34:49.44,English,,0,0,0,,Okay so this executes bit is new with x86-64,it didn't exist in 32-bit x86 systems
Dialogue: 0,0:34:42.12,0:34:49.44,Chinese,,0,0,0,,好的，所以这个执行位是x86-64的新功能，它在32位x86系统中不存在
Dialogue: 0,0:34:50.50,0:35:00.48,English,,0,0,0,,And this is the technique that's used now to try to prevent against attack lab code injection style attacks
Dialogue: 0,0:34:50.50,0:35:00.48,Chinese,,0,0,0,,这是现在用来试图防止攻击实验室代码注入风格攻击的技术
Dialogue: 0,0:35:01.00,0:35:02.30,English,,0,0,0,,Because it makes it impossible
Dialogue: 0,0:35:01.00,0:35:02.30,Chinese,,0,0,0,,因为它使它变得不可能
Dialogue: 0,0:35:02.64,0:35:09.30,English,,0,0,0,,If this bit is set you can't load instructions from any byte within that page
Dialogue: 0,0:35:02.64,0:35:09.30,Chinese,,0,0,0,,如果设置此位，则无法从该页面中的任何字节加载指令
Dialogue: 0,0:35:10.86,0:35:14.92,English,,0,0,0,,And so in fact it was this the introduction of this execute bit
Dialogue: 0,0:35:10.86,0:35:14.92,Chinese,,0,0,0,,事实上，正是这个引入了这个执行位
Dialogue: 0,0:35:14.92,0:35:20.12,English,,0,0,0,,That's or led to things like return-oriented programming attacks like you did in your attack lab
Dialogue: 0,0:35:14.92,0:35:20.12,Chinese,,0,0,0,,这或者像你在攻击实验室那样导致了面向回归的编程攻击
Dialogue: 0,0:35:22.88,0:35:30.12,English,,0,0,0,,Okay so this by just the simple technique of adding bits to the PTE
Dialogue: 0,0:35:22.88,0:35:30.12,Chinese,,0,0,0,,好的，这只是通过向PTE添加位的简单技术
Dialogue: 0,0:35:30.72,0:35:33.82,English,,0,0,0,,We provide a way attic way to protect
Dialogue: 0,0:35:30.72,0:35:33.82,Chinese,,0,0,0,,我们提供了一种阁楼保护方式
Dialogue: 0,0:35:34.36,0:35:40.70,English,,0,0,0,,Different parts of our virtual address space from unauthorized accesses
Dialogue: 0,0:35:34.36,0:35:40.70,Chinese,,0,0,0,,我们的虚拟地址空间的不同部分来自未经授权的访问
Dialogue: 0,0:35:41.60,0:35:44.84,English,,0,0,0,,And then the the MMU actually checks these bits on each access
Dialogue: 0,0:35:41.60,0:35:44.84,Chinese,,0,0,0,,然后MMU实际上在每次访问时检查这些位
Dialogue: 0,0:35:44.88,0:35:49.50,English,,0,0,0,,And if there's a problem you know if you're trying to do a right and the right
Dialogue: 0,0:35:44.88,0:35:49.50,Chinese,,0,0,0,,如果有问题，你知道你是否正在努力做正确的事
Dialogue: 0,0:35:50.84,0:35:56.48,English,,0,0,0,,The right that's not enabled then it throws an exception which then the kernel the colonel deals with
Dialogue: 0,0:35:50.84,0:35:56.48,Chinese,,0,0,0,,没有启用的权限然后它抛出一个异常，然后是上校处理的内核
Dialogue: 0,0:36:00.42,0:36:05.44,English,,0,0,0,,Ok so so far I've been talking about address translation it kind of high-level terms
Dialogue: 0,0:36:00.42,0:36:05.44,Chinese,,0,0,0,,好吧到目前为止我一直在讨论地址翻译这种高级术语
Dialogue: 0,0:36:05.44,0:36:08.66,English,,0,0,0,,So let's get down to details and see how it really works
Dialogue: 0,0:36:05.44,0:36:08.66,Chinese,,0,0,0,,所以让我们深入了解细节，看看它是如何运作的
Dialogue: 0,0:36:10.86,0:36:17.88,English,,0,0,0,,Okay so we're given a virtual address of N elements physical address of M elements
Dialogue: 0,0:36:10.86,0:36:17.88,Chinese,,0,0,0,,好的，我们给出了M个元素的N个元素物理地址的虚拟地址
Dialogue: 0,0:36:19.70,0:36:23.93,English,,0,0,0,,Like I said before N is usually larger than M but it doesn't have to be
Dialogue: 0,0:36:19.70,0:36:23.93,Chinese,,0,0,0,,就像我之前说的那样，N通常比M大，但并非如此
Dialogue: 0,0:36:25.64,0:36:29.62,English,,0,0,0,,Okay it's perfectly there's no reason M could be much larger than N
Dialogue: 0,0:36:25.64,0:36:29.62,Chinese,,0,0,0,,好吧，这完全没有理由M可能比N大得多
Dialogue: 0,0:36:30.76,0:36:34.06,English,,0,0,0,,And there it's typically not but it could be
Dialogue: 0,0:36:30.76,0:36:34.06,Chinese,,0,0,0,,它通常不是，但它可能是
Dialogue: 0,0:36:35.52,0:36:40.84,English,,0,0,0,,And so given these two address spaces we have a map function that takes that maps from V to P
Dialogue: 0,0:36:35.52,0:36:40.84,Chinese,,0,0,0,,因此，给定这两个地址空间，我们有一个map函数，可以将映射从V映射到P.
Dialogue: 0,0:36:41.30,0:36:45.78,English,,0,0,0,,With an optional empty set or with an additional empty set
Dialogue: 0,0:36:41.30,0:36:45.78,Chinese,,0,0,0,,使用可选的空集或附加的空集
Dialogue: 0,0:36:46.80,0:36:51.28,English,,0,0,0,,And so for virtual address a,MAP(a)=a'
Dialogue: 0,0:36:46.80,0:36:51.28,Chinese,,0,0,0,,对于虚拟地址a，MAP（a）= a'
Dialogue: 0,0:36:51.72,0:36:55.76,English,,0,0,0,,If the data at virtual address a is a physical address a'
Dialogue: 0,0:36:51.72,0:36:55.76,Chinese,,0,0,0,,如果虚拟地址a处的数据是物理地址a'
Dialogue: 0,0:36:55.78,0:36:59.70,English,,0,0,0,,Okay so I mean that's just what we...it's just a little more formal way to say
Dialogue: 0,0:36:55.78,0:36:59.70,Chinese,,0,0,0,,好的，所以我的意思是，这就是我们......这只是一种更正式的说法
Dialogue: 0,0:36:59.84,0:37:03.48,English,,0,0,0,,What we've been talking about before with our diagrams
Dialogue: 0,0:36:59.84,0:37:03.48,Chinese,,0,0,0,,我们之前用图表谈过的是什么
Dialogue: 0,0:37:04.60,0:37:09.96,English,,0,0,0,,And then map a is the empty set if the data at virtual address a is not in physical memory
Dialogue: 0,0:37:04.60,0:37:09.96,Chinese,,0,0,0,,如果虚拟地址a处的数据不在物理内存中，则映射a为空集
Dialogue: 0,0:37:13.92,0:37:20.12,English,,0,0,0,,Okay so just for a summary I'm going to put up a list of all the symbols we're going to be using in address translation
Dialogue: 0,0:37:13.92,0:37:20.12,Chinese,,0,0,0,,好的，只是为了总结我将列出我们将在地址转换中使用的所有符号
Dialogue: 0,0:37:20.48,0:37:25.32,English,,0,0,0,,But this is just for summary,this is just for reference if you're using the slides later on
Dialogue: 0,0:37:20.48,0:37:25.32,Chinese,,0,0,0,,但这只是为了总结，如果你稍后使用幻灯片，这仅供参考
Dialogue: 0,0:37:28.76,0:37:31.62,English,,0,0,0,,Okay so here's how address translation where the page table works
Dialogue: 0,0:37:28.76,0:37:31.62,Chinese,,0,0,0,,好的，这就是页面表工作的地址转换方式
Dialogue: 0,0:37:34.84,0:37:36.44,English,,0,0,0,,So we're given some virtual address
Dialogue: 0,0:37:34.84,0:37:36.44,Chinese,,0,0,0,,所以我们给了一些虚拟地址
Dialogue: 0,0:37:38.48,0:37:40.10,English,,0,0,0,,That consists of n bits
Dialogue: 0,0:37:38.48,0:37:40.10,Chinese,,0,0,0,,它由n位组成
Dialogue: 0,0:37:42.80,0:37:48.52,English,,0,0,0,,And we have blocks that consists of whose size can be represented with p bits
Dialogue: 0,0:37:42.80,0:37:48.52,Chinese,,0,0,0,,我们有块，其大小可以用p位表示
Dialogue: 0,0:37:53.42,0:37:55.02,English,,0,0,0,,Okay so think about this now there
Dialogue: 0,0:37:53.42,0:37:55.02,Chinese,,0,0,0,,好的，现在想想这个
Dialogue: 0,0:37:56.48,0:38:01.32,English,,0,0,0,,So this is very similar to what we looked at when we did caching you know the address bits for a cache
Dialogue: 0,0:37:56.48,0:38:01.32,Chinese,,0,0,0,,因此，这与我们在进行缓存时所看到的非常类似，你知道缓存的地址位
Dialogue: 0,0:38:02.46,0:38:06.82,English,,0,0,0,,So these first p bits correspond to the page offset
Dialogue: 0,0:38:02.46,0:38:06.82,Chinese,,0,0,0,,所以这些前p位对应于页面偏移
Dialogue: 0,0:38:06.82,0:38:10.42,English,,0,0,0,,So this is analogous to the blocks offsets that we saw with caches
Dialogue: 0,0:38:06.82,0:38:10.42,Chinese,,0,0,0,,所以这类似于我们在缓存中看到的块偏移量
Dialogue: 0,0:38:13.92,0:38:18.12,English,,0,0,0,,And then the remaining bits correspond to the virtual page number
Dialogue: 0,0:38:13.92,0:38:18.12,Chinese,,0,0,0,,然后剩余的位对应于虚拟页码
Dialogue: 0,0:38:19.06,0:38:23.62,English,,0,0,0,,This is so member this is fully associative right so there's only one set
Dialogue: 0,0:38:19.06,0:38:23.62,Chinese,,0,0,0,,这是成员，这是完全关联的权利所以只有一组
Dialogue: 0,0:38:24.20,0:38:28.86,English,,0,0,0,,So in a fully associative cache everything after the block offset is tagged
Dialogue: 0,0:38:24.20,0:38:28.86,Chinese,,0,0,0,,因此，在完全关联的缓存中，标记了块偏移之后的所有内容
Dialogue: 0,0:38:29.30,0:38:30.78,English,,0,0,0,,So think of this as like a tag
Dialogue: 0,0:38:29.30,0:38:30.78,Chinese,,0,0,0,,所以把它想象成一个标签
Dialogue: 0,0:38:30.96,0:38:34.60,English,,0,0,0,,This is the...this is what uniquely identifies this block
Dialogue: 0,0:38:30.96,0:38:34.60,Chinese,,0,0,0,,这是...这是唯一标识此块的内容
Dialogue: 0,0:38:36.88,0:38:41.00,English,,0,0,0,,And we in virtual memory parlance we refer to it as a virtual page number
Dialogue: 0,0:38:36.88,0:38:41.00,Chinese,,0,0,0,,我们在虚拟内存的说法中将它称为虚拟页码
Dialogue: 0,0:38:43.16,0:38:49.34,English,,0,0,0,,Now the page table the beginning of the page table is pointed to by this page table based register
Dialogue: 0,0:38:43.16,0:38:49.34,Chinese,,0,0,0,,现在页面表的页面表的开头是由这个基于页面表的寄存器指向的
Dialogue: 0,0:38:49.36,0:38:53.70,English,,0,0,0,,On intel systems  that's it's called CR3 control register 3
Dialogue: 0,0:38:49.36,0:38:53.70,Chinese,,0,0,0,,在英特尔系统上，它被称为CR3控制寄存器3
Dialogue: 0,0:38:54.60,0:39:00.43,English,,0,0,0,,But this register contains the physical address of the page table in memory
Dialogue: 0,0:38:54.60,0:39:00.43,Chinese,,0,0,0,,但是该寄存器包含内存中页表的物理地址
Dialogue: 0,0:39:01.34,0:39:02.44,English,,0,0,0,,The beginning of that...
Dialogue: 0,0:39:01.34,0:39:02.44,Chinese,,0,0,0,,那个开始......
Dialogue: 0,0:39:04.50,0:39:10.62,English,,0,0,0,,And so when the when the CPU presents a virtual page,a virtual address to the MMU
Dialogue: 0,0:39:04.50,0:39:10.62,Chinese,,0,0,0,,因此，当CPU呈现虚拟页面时，MMU的虚拟地址
Dialogue: 0,0:39:11.98,0:39:14.28,English,,0,0,0,,It takes the virtual page number
Dialogue: 0,0:39:11.98,0:39:14.28,Chinese,,0,0,0,,它需要虚拟页码
Dialogue: 0,0:39:15.16,0:39:18.38,English,,0,0,0,,And uses that as an index into the page table
Dialogue: 0,0:39:15.16,0:39:18.38,Chinese,,0,0,0,,并将其用作页表的索引
Dialogue: 0,0:39:20.98,0:39:28.68,English,,0,0,0,,Ok and then it...and that identifies a page table entry which contains if this is mapped into memory
Dialogue: 0,0:39:20.98,0:39:28.68,Chinese,,0,0,0,,好然后它......它标识一个页表条目，其中包含是否映射到内存中
Dialogue: 0,0:39:29.02,0:39:33.24,English,,0,0,0,,I contains the physical address of the corresponding physical page
Dialogue: 0,0:39:29.02,0:39:33.24,Chinese,,0,0,0,,我包含相应物理页面的物理地址
Dialogue: 0,0:39:36.48,0:39:40.60,English,,0,0,0,,Ok so the whole purpose of address translation is to come up you're given a virtual address
Dialogue: 0,0:39:36.48,0:39:40.60,Chinese,,0,0,0,,好吧，地址转换的全部目的是为了给你一个虚拟地址
Dialogue: 0,0:39:41.44,0:39:43.86,English,,0,0,0,,And you want to come up with a corresponding physical address
Dialogue: 0,0:39:41.44,0:39:43.86,Chinese,,0,0,0,,而你想要提出一个相应的物理地址
Dialogue: 0,0:39:46.42,0:39:54.00,English,,0,0,0,,Ok so the physical address,the physical page number portion of the physical address comes out of the page table entry
Dialogue: 0,0:39:46.42,0:39:54.00,Chinese,,0,0,0,,确定物理地址，物理地址的物理页码部分来自页表条目
Dialogue: 0,0:39:55.52,0:40:02.96,English,,0,0,0,,And this is interesting the the physical page offset portion of the physical address comes out of the virtual page offset
Dialogue: 0,0:39:55.52,0:40:02.96,Chinese,,0,0,0,,有趣的是，物理地址的物理页面偏移部分来自虚拟页面偏移
Dialogue: 0,0:40:03.02,0:40:04.58,English,,0,0,0,,And it those bits are identical
Dialogue: 0,0:40:03.02,0:40:04.58,Chinese,,0,0,0,,而那些位是相同的
Dialogue: 0,0:40:06.44,0:40:11.94,English,,0,0,0,,Okay so now you should convince yourself that this is true right
Dialogue: 0,0:40:06.44,0:40:11.94,Chinese,,0,0,0,,好的，现在你应该说服自己这是对的
Dialogue: 0,0:40:13.96,0:40:18.80,English,,0,0,0,,The offset in a virtual block is going to be the same as the offset in a physical block
Dialogue: 0,0:40:13.96,0:40:18.80,Chinese,,0,0,0,,虚拟块中的偏移量将与物理块中的偏移量相同
Dialogue: 0,0:40:19.26,0:40:20.66,English,,0,0,0,,They're the same size blocks
Dialogue: 0,0:40:19.26,0:40:20.66,Chinese,,0,0,0,,它们的大小相同
Dialogue: 0,0:40:26.00,0:40:28.50,English,,0,0,0,,And you can also see why this virtual page number
Dialogue: 0,0:40:26.00,0:40:28.50,Chinese,,0,0,0,,而且你也可以看到为什么这个虚拟页码
Dialogue: 0,0:40:29.74,0:40:35.66,English,,0,0,0,,It identifies the page number in the page table
Dialogue: 0,0:40:29.74,0:40:35.66,Chinese,,0,0,0,,它标识页表中的页码
Dialogue: 0,0:40:36.56,0:40:40.78,English,,0,0,0,,So imagine a virtual address that's all zeros
Dialogue: 0,0:40:36.56,0:40:40.78,Chinese,,0,0,0,,所以想象一下全部为零的虚拟地址
Dialogue: 0,0:40:42.60,0:40:43.60,English,,0,0,0,,Okay all zeros
Dialogue: 0,0:40:42.60,0:40:43.60,Chinese,,0,0,0,,好吧全是零
Dialogue: 0,0:40:44.70,0:40:46.16,English,,0,0,0,,So it's virtual address zero
Dialogue: 0,0:40:44.70,0:40:46.16,Chinese,,0,0,0,,所以它的虚拟地址为零
Dialogue: 0,0:40:47.84,0:40:52.10,English,,0,0,0,,And now that will have a virtual page number of zero
Dialogue: 0,0:40:47.84,0:40:52.10,Chinese,,0,0,0,,现在，虚拟页面数将为零
Dialogue: 0,0:40:53.76,0:40:56.40,English,,0,0,0,,And the byte at that address will be at offset zero
Dialogue: 0,0:40:53.76,0:40:56.40,Chinese,,0,0,0,,并且该地址处的字节将在偏移零处
Dialogue: 0,0:40:58.80,0:41:01.32,English,,0,0,0,,Okay now increment by one virtual address one
Dialogue: 0,0:40:58.80,0:41:01.32,Chinese,,0,0,0,,好的，现在增加一个虚拟地址
Dialogue: 0,0:41:02.58,0:41:07.54,English,,0,0,0,,So that will be in an offset of 1 and it will be in the same virtual page of zero
Dialogue: 0,0:41:02.58,0:41:07.54,Chinese,,0,0,0,,因此，它将在1的偏移量中，并且它将在零的相同虚拟页面中
Dialogue: 0,0:41:08.12,0:41:13.18,English,,0,0,0,,Right now keep incrementing until all of the bits in the virtual page offset are ones
Dialogue: 0,0:41:08.12,0:41:13.18,Chinese,,0,0,0,,现在继续递增，直到虚拟页面偏移中的所有位都是1
Dialogue: 0,0:41:14.22,0:41:16.38,English,,0,0,0,,And the virtual page numbers is zero
Dialogue: 0,0:41:14.22,0:41:16.38,Chinese,,0,0,0,,虚拟页码为零
Dialogue: 0,0:41:16.50,0:41:20.88,English,,0,0,0,,Okay so this is the last byte in that virtual page zero
Dialogue: 0,0:41:16.50,0:41:20.88,Chinese,,0,0,0,,好的，这是该虚拟页面零的最后一个字节
Dialogue: 0,0:41:21.84,0:41:23.42,English,,0,0,0,,Now increment one more time
Dialogue: 0,0:41:21.84,0:41:23.42,Chinese,,0,0,0,,现在再增加一次
Dialogue: 0,0:41:26.16,0:41:30.90,English,,0,0,0,,The one bit carries over to the virtual page number so now we go to the next virtual page
Dialogue: 0,0:41:26.16,0:41:30.90,Chinese,,0,0,0,,一位继承到虚拟页码，现在我们转到下一个虚拟页面
Dialogue: 0,0:41:31.86,0:41:34.24,English,,0,0,0,,And it's at an offset of zero okay so
Dialogue: 0,0:41:31.86,0:41:34.24,Chinese,,0,0,0,,它的偏移量为零，所以
Dialogue: 0,0:41:35.30,0:41:39.38,English,,0,0,0,,So can you see it's sort of sort of obvious when you think about it like that
Dialogue: 0,0:41:35.30,0:41:39.38,Chinese,,0,0,0,,所以，当你这么想的时候，你能看到它有点明显吗？
Dialogue: 0,0:41:40.30,0:41:46.86,English,,0,0,0,,You know why we can just take these bits after the virtual page offset and use them to uniquely identify
Dialogue: 0,0:41:40.30,0:41:46.86,Chinese,,0,0,0,,你知道为什么我们可以在虚拟页面偏移之后获取这些位并使用它们进行唯一标识
Dialogue: 0,0:41:47.14,0:41:50.20,English,,0,0,0,,What virtual page were we're working with
Dialogue: 0,0:41:47.14,0:41:50.20,Chinese,,0,0,0,,我们正在使用什么虚拟页面
Dialogue: 0,0:41:51.46,0:41:53.66,English,,0,0,0,,Okay so let's see how I
Dialogue: 0,0:41:51.46,0:41:53.66,Chinese,,0,0,0,,好的，让我们看看我是怎么回事
Dialogue: 0,0:41:53.78,0:41:56.32,English,,0,0,0,,Let's see how it works in this system in more detail
Dialogue: 0,0:41:53.78,0:41:56.32,Chinese,,0,0,0,,让我们更详细地了解它在该系统中的工作原理
Dialogue: 0,0:41:57.48,0:42:02.40,English,,0,0,0,,So our system our CPU sends a virtual address to the MMU as a result of executing
Dialogue: 0,0:41:57.48,0:42:02.40,Chinese,,0,0,0,,因此，我们的系统CPU会在执行结果时向MMU发送虚拟地址
Dialogue: 0,0:42:02.64,0:42:08.78,English,,0,0,0,,A move instruction or call or return or any kind of control transfer
Dialogue: 0,0:42:02.64,0:42:08.78,Chinese,,0,0,0,,移动指令或呼叫或返回或任何类型的控制转移
Dialogue: 0,0:42:09.50,0:42:10.70,English,,0,0,0,,The MMU
Dialogue: 0,0:42:09.50,0:42:10.70,Chinese,,0,0,0,,MMU
Dialogue: 0,0:42:13.62,0:42:19.64,English,,0,0,0,,Looks up the PTE, so it fetches the PTE from the page cable stored in memory
Dialogue: 0,0:42:13.62,0:42:19.64,Chinese,,0,0,0,,查找PTE，因此它从存储在内存中的页面电缆中获取PTE
Dialogue: 0,0:42:20.04,0:42:25.52,English,,0,0,0,,So this is actually going off the chip onto memory into this PTE stored in memory
Dialogue: 0,0:42:20.04,0:42:25.52,Chinese,,0,0,0,,所以这实际上是将芯片从存储器中移入存储在存储器中的PTE中
Dialogue: 0,0:42:26.50,0:42:34.50,English,,0,0,0,,It gets the it fetches the PTE extracts the and uses that PTE to construct the physical address
Dialogue: 0,0:42:26.50,0:42:34.50,Chinese,,0,0,0,,它获取PTE提取并使用该PTE构造物理地址
Dialogue: 0,0:42:35.90,0:42:40.88,English,,0,0,0,,Okay and then it sends that physical address to the cache and memory system
Dialogue: 0,0:42:35.90,0:42:40.88,Chinese,,0,0,0,,好的，然后它将该物理地址发送到缓存和内存系统
Dialogue: 0,0:42:41.34,0:42:44.98,English,,0,0,0,,Which eventually results in the data being returned back to the CPU
Dialogue: 0,0:42:41.34,0:42:44.98,Chinese,,0,0,0,,这最终会导致数据返回到CPU
Dialogue: 0,0:42:46.10,0:42:50.30,English,,0,0,0,,Okay so even for a hit,we still have memory references
Dialogue: 0,0:42:46.10,0:42:50.30,Chinese,,0,0,0,,好的，即使是热门，我们仍然有内存参考
Dialogue: 0,0:42:50.72,0:42:53.58,English,,0,0,0,,Right because we have to fetch that page table entry
Dialogue: 0,0:42:50.72,0:42:53.58,Chinese,,0,0,0,,是的，因为我们必须获取该页表项
Dialogue: 0,0:42:57.86,0:43:02.22,English,,0,0,0,,Now miss is in this parlance is called a page fault
Dialogue: 0,0:42:57.86,0:43:02.22,Chinese,,0,0,0,,现在想念就是这个用语被称为页面错误
Dialogue: 0,0:43:02.96,0:43:08.94,English,,0,0,0,,So in this case the same thing happens as before that the CPU sends the virtual address to the MMU
Dialogue: 0,0:43:02.96,0:43:08.94,Chinese,,0,0,0,,因此，在这种情况下，同样的事情发生在CPU之前将虚拟地址发送到MMU
Dialogue: 0,0:43:09.44,0:43:12.86,English,,0,0,0,,The MMU fetches that the PTE for memory
Dialogue: 0,0:43:09.44,0:43:12.86,Chinese,,0,0,0,,MMU获取PTE作为内存
Dialogue: 0,0:43:13.40,0:43:16.54,English,,0,0,0,,But then when it looks then when the MMU looks at the PTE
Dialogue: 0,0:43:13.40,0:43:16.54,Chinese,,0,0,0,,但是当它看起来然后当MMU看PTE时
Dialogue: 0,0:43:16.78,0:43:22.14,English,,0,0,0,,It sees that there's either an invalid valid bit or a zero valid bit or the
Dialogue: 0,0:43:16.78,0:43:22.14,Chinese,,0,0,0,,它看到有无效的有效位或零有效位或
Dialogue: 0,0:43:23.54,0:43:26.56,English,,0,0,0,,The it's indicated that the data stored on disk
Dialogue: 0,0:43:23.54,0:43:26.56,Chinese,,0,0,0,,它表明数据存储在磁盘上
Dialogue: 0,0:43:30.10,0:43:35.90,English,,0,0,0,,And so in that case it the MMU triggers a page fault exception
Dialogue: 0,0:43:30.10,0:43:35.90,Chinese,,0,0,0,,因此，在这种情况下，MMU会触发页面错误异常
Dialogue: 0,0:43:36.62,0:43:39.14,English,,0,0,0,,Which transfers control to this page fault handler
Dialogue: 0,0:43:36.62,0:43:39.14,Chinese,,0,0,0,,将控制转移到此页面错误处理程序
Dialogue: 0,0:43:40.94,0:43:43.40,English,,0,0,0,,The handler identifies a victim and
Dialogue: 0,0:43:40.94,0:43:43.40,Chinese,,0,0,0,,处理程序识别受害者和
Dialogue: 0,0:43:44.66,0:43:47.80,English,,0,0,0,,If it's been modified copies it out to disk
Dialogue: 0,0:43:44.66,0:43:47.80,Chinese,,0,0,0,,如果已被修改，则将其复制到磁盘
Dialogue: 0,0:43:50.12,0:43:55.94,English,,0,0,0,,Then it fetches the new page from disk into memory and up through the cache hierarchy
Dialogue: 0,0:43:50.12,0:43:55.94,Chinese,,0,0,0,,然后，它将新页面从磁盘提取到内存中，然后通过缓存层次结构
Dialogue: 0,0:43:57.42,0:43:57.90,English,,0,0,0,,OK
Dialogue: 0,0:43:57.42,0:43:57.90,Chinese,,0,0,0,,好
Dialogue: 0,0:43:59.42,0:44:00.96,English,,0,0,0,,And then it did...
Dialogue: 0,0:43:59.42,0:44:00.96,Chinese,,0,0,0,,然后它确实......
Dialogue: 0,0:44:01.42,0:44:07.00,English,,0,0,0,,And then it causes that the then the handler returns to the to the process
Dialogue: 0,0:44:01.42,0:44:07.00,Chinese,,0,0,0,,然后它导致然后处理程序返回到进程
Dialogue: 0,0:44:08.80,0:44:11.32,English,,0,0,0,,And when a handler for a fault returns
Dialogue: 0,0:44:08.80,0:44:11.32,Chinese,,0,0,0,,并且当故障的处理程序返回时
Dialogue: 0,0:44:11.70,0:44:14.96,English,,0,0,0,,It causes the faulting instruction to re-execute
Dialogue: 0,0:44:11.70,0:44:14.96,Chinese,,0,0,0,,它导致错误指令重新执行
Dialogue: 0,0:44:15.00,0:44:21.56,English,,0,0,0,,So now the move instruction that faulted is re-execute,but this time there's a page hit
Dialogue: 0,0:44:15.00,0:44:21.56,Chinese,,0,0,0,,所以现在出现故障的移动指令会重新执行，但这次有一个页面命中
Dialogue: 0,0:44:27.78,0:44:32.46,English,,0,0,0,,Now you may be interested how the cash is integrated into all of this
Dialogue: 0,0:44:27.78,0:44:32.46,Chinese,,0,0,0,,现在你可能会对现金如何融入所有这些感兴趣
Dialogue: 0,0:44:34.00,0:44:39.66,English,,0,0,0,,So the MMU send fetches page table entries
Dialogue: 0,0:44:34.00,0:44:39.66,Chinese,,0,0,0,,因此MMU发送提取页表条目
Dialogue: 0,0:44:40.20,0:44:43.14,English,,0,0,0,,So it passes page table addresses to the cash
Dialogue: 0,0:44:40.20,0:44:43.14,Chinese,,0,0,0,,所以它将页面表地址传递给现金
Dialogue: 0,0:44:44.08,0:44:46.24,English,,0,0,0,,If those missed those go to memory
Dialogue: 0,0:44:44.08,0:44:46.24,Chinese,,0,0,0,,如果那些错过那些去记忆
Dialogue: 0,0:44:48.16,0:44:51.92,English,,0,0,0,,The memory returns those page table entries to the cache
Dialogue: 0,0:44:48.16,0:44:51.92,Chinese,,0,0,0,,内存将这些页表条目返回到缓存
Dialogue: 0,0:44:52.80,0:44:55.88,English,,0,0,0,,And then ultimately to the MMU
Dialogue: 0,0:44:52.80,0:44:55.88,Chinese,,0,0,0,,然后最终到了MMU
Dialogue: 0,0:44:56.66,0:45:02.26,English,,0,0,0,,The MMU constructs that physical address and then its sense that physical address to the cache
Dialogue: 0,0:44:56.66,0:45:02.26,Chinese,,0,0,0,,MMU构造该物理地址，然后将其感知到物理地址到缓存
Dialogue: 0,0:45:02.36,0:45:07.66,English,,0,0,0,,Right so with caching the way we've been caching is done using physical addresses
Dialogue: 0,0:45:02.36,0:45:07.66,Chinese,,0,0,0,,正确地使用物理地址来缓存我们已经缓存的方式
Dialogue: 0,0:45:10.52,0:45:15.70,English,,0,0,0,,Okay in this case it's also possible to construct caches that work with virtual addresses but yes
Dialogue: 0,0:45:10.52,0:45:15.70,Chinese,,0,0,0,,好的，在这种情况下，也可以构建使用虚拟地址的缓存，但是
Dialogue: 0,0:45:15.70,0:45:25.08,English,,0,0,0,,[student speaking]
Dialogue: 0,0:45:15.70,0:45:25.08,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:45:25.18,0:45:27.30,English,,0,0,0,,Yeah so, it will get into that...
Dialogue: 0,0:45:25.18,0:45:27.30,Chinese,,0,0,0,,是的，它会进入......
Dialogue: 0,0:45:27.30,0:45:32.24,English,,0,0,0,,Okay so the question is how is the virtual address space implemented on disk
Dialogue: 0,0:45:27.30,0:45:32.24,Chinese,,0,0,0,,好的，问题是如何在磁盘上实现虚拟地址空间
Dialogue: 0,0:45:33.16,0:45:39.86,English,,0,0,0,,And it when it actually does a much more efficient thing than the sort of a abstract model that I described
Dialogue: 0,0:45:33.16,0:45:39.86,Chinese,,0,0,0,,它实际上比我描述的那种抽象模型更有效
Dialogue: 0,0:45:40.38,0:45:44.92,English,,0,0,0,,So most pages there's an option when you allocate a new virtual memory page
Dialogue: 0,0:45:40.38,0:45:44.92,Chinese,,0,0,0,,因此，当你分配新的虚拟内存页面时，大多数页面都有一个选项
Dialogue: 0,0:45:45.44,0:45:47.94,English,,0,0,0,,You can allocate it,so that it's all zeros
Dialogue: 0,0:45:45.44,0:45:47.94,Chinese,,0,0,0,,你可以分配它，所以它都是零
Dialogue: 0,0:45:49.58,0:45:54.32,English,,0,0,0,,Okay so there's a special you can say I want this I want to allocate a page of all zeros
Dialogue: 0,0:45:49.58,0:45:54.32,Chinese,,0,0,0,,好的，所以有一个特殊的你可以说我想要这个我想要分配一个全零的页面
Dialogue: 0,0:45:54.82,0:45:57.50,English,,0,0,0,,In that case you know that page doesn't need to ever get stored on disk
Dialogue: 0,0:45:54.82,0:45:57.50,Chinese,,0,0,0,,在这种情况下，你知道该页面不需要存储在磁盘上
Dialogue: 0,0:45:57.94,0:46:02.58,English,,0,0,0,,Right it's just the memory it's as though it was created on disk and then loaded into memory
Dialogue: 0,0:45:57.94,0:46:02.58,Chinese,,0,0,0,,它只是内存，就好像它是在磁盘上创建然后加载到内存中一样
Dialogue: 0,0:46:03.28,0:46:07.57,English,,0,0,0,,So those pages that are all zeros don't exist on disk
Dialogue: 0,0:46:03.28,0:46:07.57,Chinese,,0,0,0,,因此，磁盘上不存在全零的页面
Dialogue: 0,0:46:08.50,0:46:10.80,English,,0,0,0,,You know when pages are modified
Dialogue: 0,0:46:08.50,0:46:10.80,Chinese,,0,0,0,,你知道何时修改页面
Dialogue: 0,0:46:13.72,0:46:21.70,English,,0,0,0,,It's a little more pages can be mapped to particular files for example when we load an elf binary
Dialogue: 0,0:46:13.72,0:46:21.70,Chinese,,0,0,0,,例如，当我们加载elf二进制文件时，可以将更多页面映射到特定文件
Dialogue: 0,0:46:22.64,0:46:27.70,English,,0,0,0,,The pages that correspond to the code are actually mapped to the bytes in the binary
Dialogue: 0,0:46:22.64,0:46:27.70,Chinese,,0,0,0,,与代码对应的页面实际上映射到二进制文件中的字节
Dialogue: 0,0:46:28.73,0:46:30.60,English,,0,0,0,,That contain the code
Dialogue: 0,0:46:28.73,0:46:30.60,Chinese,,0,0,0,,那包含代码
Dialogue: 0,0:46:31.66,0:46:35.36,English,,0,0,0,,So that when you miss on that page it fed it brings in those code pages
Dialogue: 0,0:46:31.66,0:46:35.36,Chinese,,0,0,0,,所以，当你错过了那个页面时，它会输入它带来的那些代码页
Dialogue: 0,0:46:35.86,0:46:41.58,English,,0,0,0,,Okay so pages can be mapped to user level files on disk
Dialogue: 0,0:46:35.86,0:46:41.58,Chinese,,0,0,0,,好的，所以页面可以映射到磁盘上的用户级文件
Dialogue: 0,0:46:42.64,0:46:45.53,English,,0,0,0,,Or not they can be anonymous and not mapped
Dialogue: 0,0:46:42.64,0:46:45.53,Chinese,,0,0,0,,或者不是他们可以匿名而不是映射
Dialogue: 0,0:46:46.50,0:46:48.82,English,,0,0,0,,So if they're mapped to user level
Dialogue: 0,0:46:46.50,0:46:48.82,Chinese,,0,0,0,,因此，如果他们被映射到用户级别
Dialogue: 0,0:46:50.70,0:46:53.68,English,,0,0,0,,If they're mapped to user level files and you write to a page
Dialogue: 0,0:46:50.70,0:46:53.68,Chinese,,0,0,0,,如果它们映射到用户级文件并且你写入页面
Dialogue: 0,0:46:54.02,0:47:00.04,English,,0,0,0,,Then it will get written back to the page that it's mapped to
Dialogue: 0,0:46:54.02,0:47:00.04,Chinese,,0,0,0,,然后它将被写回到它映射到的页面
Dialogue: 0,0:47:00.58,0:47:06.90,English,,0,0,0,,If it's not mapped to any page it's stored in this area called the swap area or the swap file okay
Dialogue: 0,0:47:00.58,0:47:06.90,Chinese,,0,0,0,,如果它没有映射到任何页面，它存储在这个称为交换区域或交换文件的区域中
Dialogue: 0,0:47:07.30,0:47:07.70,English,,0,0,0,,yes
Dialogue: 0,0:47:07.30,0:47:07.70,Chinese,,0,0,0,,是
Dialogue: 0,0:47:07.70,0:47:18.98,English,,0,0,0,,[student speaking]
Dialogue: 0,0:47:07.70,0:47:18.98,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:47:18.98,0:47:23.28,English,,0,0,0,,Oh yeah so the question is when you load a page from disk into memory
Dialogue: 0,0:47:18.98,0:47:23.28,Chinese,,0,0,0,,哦是的所以问题是当你从磁盘加载一个页面到内存
Dialogue: 0,0:47:23.28,0:47:26.92,English,,0,0,0,,Does it also get cached in the cache memory hierarchy and the answer is yes
Dialogue: 0,0:47:23.28,0:47:26.92,Chinese,,0,0,0,,它是否也缓存在缓存内存层次结构中，答案是肯定的
Dialogue: 0,0:47:27.66,0:47:29.18,English,,0,0,0,,So if you load an entire page
Dialogue: 0,0:47:27.66,0:47:29.18,Chinese,,0,0,0,,因此，如果你加载整个页面
Dialogue: 0,0:47:29.92,0:47:33.68,English,,0,0,0,,That page will be broken up into blocks 64 byte blocks
Dialogue: 0,0:47:29.92,0:47:33.68,Chinese,,0,0,0,,该页面将被分成64字节块
Dialogue: 0,0:47:34.28,0:47:37.32,English,,0,0,0,,And and load it into the cache
Dialogue: 0,0:47:34.28,0:47:37.32,Chinese,,0,0,0,,并将其加载到缓存中
Dialogue: 0,0:47:37.94,0:47:41.90,English,,0,0,0,,So everything that you fetch from the cache goes through
Dialogue: 0,0:47:37.94,0:47:41.90,Chinese,,0,0,0,,因此，你从缓存中获取的所有内容都会通过
Dialogue: 0,0:47:42.40,0:47:45.64,English,,0,0,0,,The from the memory goes through the cache hierarchy
Dialogue: 0,0:47:42.40,0:47:45.64,Chinese,,0,0,0,,内存中的内容通过缓存层次结构
Dialogue: 0,0:47:52.92,0:48:01.02,English,,0,0,0,,Okay so I claim that virtual memory works
Dialogue: 0,0:47:52.92,0:48:01.02,Chinese,,0,0,0,,好的，所以我声称虚拟内存有效
Dialogue: 0,0:48:01.94,0:48:05.48,English,,0,0,0,,Because of locality and that's true but if we still had to fetch
Dialogue: 0,0:48:01.94,0:48:05.48,Chinese,,0,0,0,,因为地方性，这是真的，但如果我们仍然需要取
Dialogue: 0,0:48:06.46,0:48:08.92,English,,0,0,0,,If every time we had a miss we still had to go to memory
Dialogue: 0,0:48:06.46,0:48:08.92,Chinese,,0,0,0,,如果我们每次怀念，我们仍然需要记忆
Dialogue: 0,0:48:09.22,0:48:10.66,English,,0,0,0,,It would be too inefficient
Dialogue: 0,0:48:09.22,0:48:10.66,Chinese,,0,0,0,,效率太低了
Dialogue: 0,0:48:11.74,0:48:20.20,English,,0,0,0,,Okay so the the MMU speeds up this translation process by caching page table entries
Dialogue: 0,0:48:11.74,0:48:20.20,Chinese,,0,0,0,,好吧，MMU通过缓存页表条目来加速这个翻译过程
Dialogue: 0,0:48:21.18,0:48:27.02,English,,0,0,0,,In a hardware cache within the MMU called the translation look aside buffer or TLB
Dialogue: 0,0:48:21.18,0:48:27.02,Chinese,,0,0,0,,在MMU内的硬件缓存中，称为转换后备缓冲区或TLB
Dialogue: 0,0:48:28.34,0:48:35.08,English,,0,0,0,,So the TLB is a hardware cache that caches is PTEs page table entries
Dialogue: 0,0:48:28.34,0:48:35.08,Chinese,,0,0,0,,因此TLB是一个硬件缓存，缓存是PTE页表条目
Dialogue: 0,0:48:37.06,0:48:40.90,English,,0,0,0,,And it contains like it contains a cache of the most recently
Dialogue: 0,0:48:37.06,0:48:40.90,Chinese,,0,0,0,,它包含它包含最近的缓存
Dialogue: 0,0:48:41.58,0:48:47.22,English,,0,0,0,,You know it's just like any other cache so it contains a cache of the most recently used page table entries
Dialogue: 0,0:48:41.58,0:48:47.22,Chinese,,0,0,0,,你知道它就像任何其他缓存一样，因此它包含最近使用的页表条目的缓存
Dialogue: 0,0:48:49.20,0:48:57.74,English,,0,0,0,,And so the the MMU remember the the unique part of a virtual address that defines a virtual page is the virtual page number bits
Dialogue: 0,0:48:49.20,0:48:57.74,Chinese,,0,0,0,,因此，MMU记住定义虚拟页面的虚拟地址的唯一部分是虚拟页面编号位
Dialogue: 0,0:48:58.86,0:49:09.10,English,,0,0,0,,Okay so the the the TLB uses the the VPN portion of the virtual address  to access it
Dialogue: 0,0:48:58.86,0:49:09.10,Chinese,,0,0,0,,好的，TLB使用虚拟地址的VPN部分来访问它
Dialogue: 0,0:49:09.54,0:49:15.98,English,,0,0,0,,And so that just like any other set it has a set index a set of set index bits which are just determined by how many
Dialogue: 0,0:49:09.54,0:49:15.98,Chinese,,0,0,0,,因此，就像任何其他集合一样，它有一个集合索引，一组设置的索引位，它们只取决于多少
Dialogue: 0,0:49:16.28,0:49:19.98,English,,0,0,0,,How many entries that or how many sets that the TLB has
Dialogue: 0,0:49:16.28,0:49:19.98,Chinese,,0,0,0,,TLB具有多少个条目或多少个条目
Dialogue: 0,0:49:21.62,0:49:30.26,English,,0,0,0,,And it has a tag with for the remaining bits to disambiguate any and to disambiguate any cash lines or PTEs
Dialogue: 0,0:49:21.62,0:49:30.26,Chinese,,0,0,0,,并且它有一个标记，其余位用于消除歧义，并消除任何现金线或PTE的歧义
Dialogue: 0,0:49:30.82,0:49:32.18,English,,0,0,0,,The map to the same set
Dialogue: 0,0:49:30.82,0:49:32.18,Chinese,,0,0,0,,地图到同一套
Dialogue: 0,0:49:33.78,0:49:40.64,English,,0,0,0,,Okay so the the VON or the TLBI(TLB index) maps to this particular set
Dialogue: 0,0:49:33.78,0:49:40.64,Chinese,,0,0,0,,好的，所以VON或TLBI（TLB索引）映射到这个特定的集合
Dialogue: 0,0:49:42.18,0:49:45.12,English,,0,0,0,,And then it uses the...
Dialogue: 0,0:49:42.18,0:49:45.12,Chinese,,0,0,0,,然后它使用...
Dialogue: 0,0:49:45.44,0:49:59.20,English,,0,0,0,,The TLB uses the TLBT bits to disambiguate and determine if the PTE that it's looking for is,it is really stored in the cache
Dialogue: 0,0:49:45.44,0:49:59.20,Chinese,,0,0,0,,TLB使用TLBT位消除歧义并确定它正在寻找的PTE是否真的存储在缓存中
Dialogue: 0,0:50:00.90,0:50:02.50,English,,0,0,0,,Okay so the way this works is
Dialogue: 0,0:50:00.90,0:50:02.50,Chinese,,0,0,0,,好的，这样做的方式是
Dialogue: 0,0:50:03.68,0:50:06.74,English,,0,0,0,,CPU generates a virtual address it goes through the MMU
Dialogue: 0,0:50:03.68,0:50:06.74,Chinese,,0,0,0,,CPU生成一个通过MMU的虚拟地址
Dialogue: 0,0:50:07.06,0:50:12.66,English,,0,0,0,,The MMU instead of looking in memory and directly going to the page table entry
Dialogue: 0,0:50:07.06,0:50:12.66,Chinese,,0,0,0,,MMU而不是查看内存并直接转到页表条目
Dialogue: 0,0:50:13.56,0:50:17.24,English,,0,0,0,,It first asks the TLB if it has that it sends it the VPN
Dialogue: 0,0:50:13.56,0:50:17.24,Chinese,,0,0,0,,它首先询问TLB是否有将其发送给VPN的情况
Dialogue: 0,0:50:17.44,0:50:21.38,English,,0,0,0,,And so do you have this virtual page the PTE for this virtual page
Dialogue: 0,0:50:17.44,0:50:21.38,Chinese,,0,0,0,,那么这个虚拟页面是否为此虚拟页面的PTE
Dialogue: 0,0:50:22.76,0:50:25.08,English,,0,0,0,,And if it does the TLB returns a hit
Dialogue: 0,0:50:22.76,0:50:25.08,Chinese,,0,0,0,,如果确实如此，则TLB返回命中
Dialogue: 0,0:50:25.32,0:50:30.72,English,,0,0,0,,And it returns that page table entry which the MMU can then use to construct the physical address
Dialogue: 0,0:50:25.32,0:50:30.72,Chinese,,0,0,0,,然后它返回MMU可用于构造物理地址的页表条目
Dialogue: 0,0:50:31.26,0:50:34.24,English,,0,0,0,,To send to the cache and memory system
Dialogue: 0,0:50:31.26,0:50:34.24,Chinese,,0,0,0,,发送到缓存和内存系统
Dialogue: 0,0:50:35.10,0:50:37.66,English,,0,0,0,,Eventually I result in that the data being sent back
Dialogue: 0,0:50:35.10,0:50:37.66,Chinese,,0,0,0,,最终我导致数据被发回
Dialogue: 0,0:50:39.82,0:50:46.00,English,,0,0,0,,Now when you have a miss then there's this one the MMU checks with the TLB for the PTE
Dialogue: 0,0:50:39.82,0:50:46.00,Chinese,,0,0,0,,现在，当你有一个未命中时，MMU会检查这个PTB的TLB
Dialogue: 0,0:50:46.64,0:50:50.88,English,,0,0,0,,It misses so then the MMU has to go to memory just like before okay so this is
Dialogue: 0,0:50:46.64,0:50:50.88,Chinese,,0,0,0,,它错过了，所以MMU必须像以前一样去记忆，所以这是
Dialogue: 0,0:50:51.92,0:50:59.66,English,,0,0,0,,And then everything is the same the memory returns the PTE to the MMU which stashes it in the TLB
Dialogue: 0,0:50:51.92,0:50:59.66,Chinese,,0,0,0,,然后一切都是相同的，内存将PTE返回到MMU，并将其存储在TLB中
Dialogue: 0,0:51:00.88,0:51:04.04,English,,0,0,0,,And just like before if there's no room in the
Dialogue: 0,0:51:00.88,0:51:04.04,Chinese,,0,0,0,,就像以前一样，如果没有空间的话
Dialogue: 0,0:51:07.14,0:51:13.98,English,,0,0,0,,If yeah if a PTE has been modified then it has to be written back out okay just like any other cache
Dialogue: 0,0:51:07.14,0:51:13.98,Chinese,,0,0,0,,如果是的话，如果PTE已被修改，则必须将其写回，就像任何其他缓存一样
Dialogue: 0,0:51:15.78,0:51:20.58,English,,0,0,0,,And eventually the MMU uses that to construct a physical address and then the data gets sent back
Dialogue: 0,0:51:15.78,0:51:20.58,Chinese,,0,0,0,,最终，MMU使用它来构建物理地址，然后将数据发回
Dialogue: 0,0:51:24.16,0:51:28.44,English,,0,0,0,,Okay if you've been paying attention unlike a couple people
Dialogue: 0,0:51:24.16,0:51:28.44,Chinese,,0,0,0,,好吧，如果你一直在注意不像一对人
Dialogue: 0,0:51:31.76,0:51:33.12,English,,0,0,0,,If you've been paying attention
Dialogue: 0,0:51:31.76,0:51:33.12,Chinese,,0,0,0,,如果你一直在关注
Dialogue: 0,0:51:34.14,0:51:37.60,English,,0,0,0,,You're going to be very concerned about the size of these page tables
Dialogue: 0,0:51:34.14,0:51:37.60,Chinese,,0,0,0,,你将非常关注这些页表的大小
Dialogue: 0,0:51:38.20,0:51:40.68,English,,0,0,0,,Right that I mean
Dialogue: 0,0:51:38.20,0:51:40.68,Chinese,,0,0,0,,对，我的意思是
Dialogue: 0,0:51:41.90,0:51:46.76,English,,0,0,0,,We've got 4kbytes suppose we have 4kbytes pages
Dialogue: 0,0:51:41.90,0:51:46.76,Chinese,,0,0,0,,我们有4千字节，假设我们有4千字节的页面
Dialogue: 0,0:51:47.58,0:51:52.76,English,,0,0,0,,And our effective address space is 48 bits like it is with an x86-64 system
Dialogue: 0,0:51:47.58,0:51:52.76,Chinese,,0,0,0,,我们的有效地址空间是48位，就像使用x86-64系统一样
Dialogue: 0,0:51:54.38,0:51:58.36,English,,0,0,0,,Then and we have an 8-byte page table entry
Dialogue: 0,0:51:54.38,0:51:58.36,Chinese,,0,0,0,,然后，我们有一个8字节的页表条目
Dialogue: 0,0:51:59.70,0:52:03.60,English,,0,0,0,,We need a page table 512 gigabytes
Dialogue: 0,0:51:59.70,0:52:03.60,Chinese,,0,0,0,,我们需要一个512千兆字节的页表
Dialogue: 0,0:52:04.84,0:52:08.54,English,,0,0,0,,Okay the address space 2^48 bytes
Dialogue: 0,0:52:04.84,0:52:08.54,Chinese,,0,0,0,,好的地址空间2 ^ 48个字节
Dialogue: 0,0:52:10.48,0:52:13.94,English,,0,0,0,,Divided by 2^12 bytes per page
Dialogue: 0,0:52:10.48,0:52:13.94,Chinese,,0,0,0,,每页除以2 ^ 12个字节
Dialogue: 0,0:52:14.22,0:52:17.00,English,,0,0,0,,Okay so that's the number of page table entries that we need
Dialogue: 0,0:52:14.22,0:52:17.00,Chinese,,0,0,0,,好的，这就是我们需要的页表条目数
Dialogue: 0,0:52:17.42,0:52:20.00,English,,0,0,0,,And then the size of each page table entry is 8 bytes
Dialogue: 0,0:52:17.42,0:52:20.00,Chinese,,0,0,0,,然后每个页表项的大小为8个字节
Dialogue: 0,0:52:21.67,0:52:27.66,English,,0,0,0,,So we need almost a terabyte of of DRAM just to hold the page table right so
Dialogue: 0,0:52:21.67,0:52:27.66,Chinese,,0,0,0,,因此，我们需要几乎1TB的DRAM来保持页面表的正确性
Dialogue: 0,0:52:28.56,0:52:29.92,English,,0,0,0,,So then obviously it's not going to work
Dialogue: 0,0:52:28.56,0:52:29.92,Chinese,,0,0,0,,那么显然它不会起作用
Dialogue: 0,0:52:31.32,0:52:34.98,English,,0,0,0,,And it's obviously not how their page tables are really implemented
Dialogue: 0,0:52:31.32,0:52:34.98,Chinese,,0,0,0,,而且显然不是他们的页表真正实现的方式
Dialogue: 0,0:52:35.82,0:52:39.54,English,,0,0,0,,So the solution is to to use a hierarchy of page tables
Dialogue: 0,0:52:35.82,0:52:39.54,Chinese,,0,0,0,,所以解决方案是使用页表的层次结构
Dialogue: 0,0:52:41.24,0:52:44.92,English,,0,0,0,,So in it so we if we have a two level page table
Dialogue: 0,0:52:41.24,0:52:44.92,Chinese,,0,0,0,,所以在我们这里，如果我们有一个两级页表
Dialogue: 0,0:52:46.12,0:52:50.64,English,,0,0,0,,The there's a top of first level page table called the level 1 table
Dialogue: 0,0:52:46.12,0:52:50.64,Chinese,,0,0,0,,第一级页面表的顶部称为级别1表
Dialogue: 0,0:52:51.00,0:52:54.12,English,,0,0,0,,Which is always in memory ok it's never never page down
Dialogue: 0,0:52:51.00,0:52:54.12,Chinese,,0,0,0,,这总是在记忆中确定它永远不会丢失
Dialogue: 0,0:52:55.00,0:53:00.54,English,,0,0,0,,And then there's a suit a sequence of level 2 page tables and they're all the same size
Dialogue: 0,0:52:55.00,0:53:00.54,Chinese,,0,0,0,,然后就是一套2级页面表的序列，它们的大小都相同
Dialogue: 0,0:53:03.66,0:53:09.18,English,,0,0,0,,Right and the first level 1 table points to the beginning of the first level 2 table
Dialogue: 0,0:53:03.66,0:53:09.18,Chinese,,0,0,0,,右侧和第一级1表指向第一级2表的开头
Dialogue: 0,0:53:09.68,0:53:12.86,English,,0,0,0,,So it contains a physical address that points to the base
Dialogue: 0,0:53:09.68,0:53:12.86,Chinese,,0,0,0,,因此它包含指向基础的物理地址
Dialogue: 0,0:53:14.18,0:53:20.32,English,,0,0,0,,The second level 1 table points to the second level 2 table and so on okay
Dialogue: 0,0:53:14.18,0:53:20.32,Chinese,,0,0,0,,第二级1表指向第二级2表，依此类推
Dialogue: 0,0:53:23.82,0:53:28.76,English,,0,0,0,,So if we have this kind of system remember most of the virtual address space is unused
Dialogue: 0,0:53:23.82,0:53:28.76,Chinese,,0,0,0,,因此，如果我们有这种系统，请记住大部分虚拟地址空间未使用
Dialogue: 0,0:53:30.60,0:53:36.28,English,,0,0,0,,Right so if we have this kind of system we can avoid creating many unnecessary page tables
Dialogue: 0,0:53:30.60,0:53:36.28,Chinese,,0,0,0,,是的，如果我们有这种系统，我们可以避免创建许多不必要的页表
Dialogue: 0,0:53:38.24,0:53:40.38,English,,0,0,0,,Okay so imagine if we have a two level hierarchy
Dialogue: 0,0:53:38.24,0:53:40.38,Chinese,,0,0,0,,好的，想象一下，如果我们有一个两级层次结构
Dialogue: 0,0:53:42.30,0:53:46.92,English,,0,0,0,,So let's look at our virtual address space in this example
Dialogue: 0,0:53:42.30,0:53:46.92,Chinese,,0,0,0,,所以让我们看一下这个例子中的虚拟地址空间
Dialogue: 0,0:53:47.64,0:53:52.48,English,,0,0,0,,And what I've allocated two k pages for code and data for this program
Dialogue: 0,0:53:47.64,0:53:52.48,Chinese,,0,0,0,,我为这个程序分配了两个k页的代码和数据
Dialogue: 0,0:53:53.74,0:53:57.32,English,,0,0,0,,And then there's their 6k unallocated pages
Dialogue: 0,0:53:53.74,0:53:57.32,Chinese,,0,0,0,,然后是他们的6k未分配页面
Dialogue: 0,0:53:58.66,0:54:02.64,English,,0,0,0,,And then the stack then there's a page that's allocated for the stack
Dialogue: 0,0:53:58.66,0:54:02.64,Chinese,,0,0,0,,然后堆栈然后有一个分配给堆栈的页面
Dialogue: 0,0:54:05.08,0:54:11.00,English,,0,0,0,,I'm sorry there's a thousand 24 pages allocated for the stack
Dialogue: 0,0:54:05.08,0:54:11.00,Chinese,,0,0,0,,对不起，这个堆栈分配了24个页面
Dialogue: 0,0:54:11.56,0:54:18.00,English,,0,0,0,,Most of which are...I'm sorry...there's a region of memory that
Dialogue: 0,0:54:11.56,0:54:18.00,Chinese,,0,0,0,,其中大部分都是......我很抱歉......有一个记忆区域
Dialogue: 0,0:54:18.88,0:54:22.86,English,,0,0,0,,That's the size of a thousand 24 pages
Dialogue: 0,0:54:18.88,0:54:22.86,Chinese,,0,0,0,,这是一个24页的大小
Dialogue: 0,0:54:22.86,0:54:28.90,English,,0,0,0,,But most of them are unallocated and I've only allocated one for the top of the stack
Dialogue: 0,0:54:22.86,0:54:28.90,Chinese,,0,0,0,,但是大多数都是未分配的，我只为堆栈顶部分配了一个
Dialogue: 0,0:54:30.46,0:54:33.62,English,,0,0,0,,Okay so given this layout for my process
Dialogue: 0,0:54:30.46,0:54:33.62,Chinese,,0,0,0,,好的，所以给我的过程这个布局
Dialogue: 0,0:54:35.48,0:54:38.50,English,,0,0,0,,I only need three level to page tables
Dialogue: 0,0:54:35.48,0:54:38.50,Chinese,,0,0,0,,我只需要三个级别的页面表
Dialogue: 0,0:54:39.36,0:54:44.92,English,,0,0,0,,Okay the first page table covers this region of my code and data
Dialogue: 0,0:54:39.36,0:54:44.92,Chinese,,0,0,0,,好的，第一页表格涵盖了我的代码和数据的这个区域
Dialogue: 0,0:54:45.86,0:54:47.94,English,,0,0,0,,The first thousand 24 pages
Dialogue: 0,0:54:45.86,0:54:47.94,Chinese,,0,0,0,,第一千页24页
Dialogue: 0,0:54:48.86,0:54:53.54,English,,0,0,0,,The next page table covers the remaining thousand 24 pages
Dialogue: 0,0:54:48.86,0:54:53.54,Chinese,,0,0,0,,下一页表格涵盖剩余的一千二十四页
Dialogue: 0,0:54:54.38,0:54:59.66,English,,0,0,0,,Okay so these two level two page tables cover all of the code and data
Dialogue: 0,0:54:54.38,0:54:59.66,Chinese,,0,0,0,,好的，所以这两个二级页表涵盖了所有的代码和数据
Dialogue: 0,0:55:02.06,0:55:05.98,English,,0,0,0,,Okay and similarly the what I need for my stack I just need one page table
Dialogue: 0,0:55:02.06,0:55:05.98,Chinese,,0,0,0,,好吧，类似我需要的堆栈我只需要一个页面表
Dialogue: 0,0:55:06.76,0:55:11.27,English,,0,0,0,,And it only has one valid PTE it's the very last one
Dialogue: 0,0:55:06.76,0:55:11.27,Chinese,,0,0,0,,它只有一个有效的PTE，这是最后一个
Dialogue: 0,0:55:12.10,0:55:17.12,English,,0,0,0,,Okay and then I have a single level one table that points to the three level two tables
Dialogue: 0,0:55:12.10,0:55:17.12,Chinese,,0,0,0,,好的，然后我有一个单一的表，指向三个二级表
Dialogue: 0,0:55:18.18,0:55:22.80,English,,0,0,0,,Okay so I've...with four page tables I've covered the entire virtual address space
Dialogue: 0,0:55:18.18,0:55:22.80,Chinese,,0,0,0,,好的，所以我...有四个页面表我已经覆盖了整个虚拟地址空间
Dialogue: 0,0:55:24.80,0:55:34.22,English,,0,0,0,,Now the way that the MMU uses these multiple page tables to do address translation is as follows
Dialogue: 0,0:55:24.80,0:55:34.22,Chinese,,0,0,0,,现在，MMU使用这些多页表进行地址转换的方式如下
Dialogue: 0,0:55:35.38,0:55:40.42,English,,0,0,0,,Again we have a virtual page offset which consists of the first p bit
Dialogue: 0,0:55:35.38,0:55:40.42,Chinese,,0,0,0,,我们再次有一个虚拟页面偏移量，它由第一个p位组成
Dialogue: 0,0:55:41.98,0:55:47.52,English,,0,0,0,,And then the VPN the remaining bits give the VPN
Dialogue: 0,0:55:41.98,0:55:47.52,Chinese,,0,0,0,,然后VPN剩下的比特给VPN
Dialogue: 0,0:55:48.68,0:55:53.73,English,,0,0,0,,For a k level page table are broken up into k sub vpns
Dialogue: 0,0:55:48.68,0:55:53.73,Chinese,,0,0,0,,对于k级页面表被分解为k个子vpns
Dialogue: 0,0:55:55.40,0:55:57.88,English,,0,0,0,,Okay and each is the same size
Dialogue: 0,0:55:55.40,0:55:57.88,Chinese,,0,0,0,,好的，每个都是相同的大小
Dialogue: 0,0:56:00.28,0:56:06.72,English,,0,0,0,,And so now in this system the upper VPN one which consists of the uppermost bits of the VPN
Dialogue: 0,0:56:00.28,0:56:06.72,Chinese,,0,0,0,,现在在这个系统中，上层VPN由VPN的最高位组成
Dialogue: 0,0:56:07.82,0:56:11.02,English,,0,0,0,,Are an offset into the level 1 table
Dialogue: 0,0:56:07.82,0:56:11.02,Chinese,,0,0,0,,是1级表的偏移量
Dialogue: 0,0:56:11.58,0:56:15.56,English,,0,0,0,,Which is as before is pointed to by the page table base register
Dialogue: 0,0:56:11.58,0:56:15.56,Chinese,,0,0,0,,页表基址寄存器指向的是前面的内容
Dialogue: 0,0:56:16.44,0:56:21.58,English,,0,0,0,,Okay so VPN1 is the index into the level 1 page table
Dialogue: 0,0:56:16.44,0:56:21.58,Chinese,,0,0,0,,好的，所以VPN1是1级页面表的索引
Dialogue: 0,0:56:22.56,0:56:25.92,English,,0,0,0,,Remember the level 1 page table points to the address of the level 2
Dialogue: 0,0:56:22.56,0:56:25.92,Chinese,,0,0,0,,请记住，1级页面表指向级别2的地址
Dialogue: 0,0:56:26.66,0:56:29.58,English,,0,0,0,,That are an entry a PTE in the level 1 table
Dialogue: 0,0:56:26.66,0:56:29.58,Chinese,,0,0,0,,这是1级表中的PTE条目
Dialogue: 0,0:56:30.04,0:56:33.62,English,,0,0,0,,Points to the address of some level 2 page table
Dialogue: 0,0:56:30.04,0:56:33.62,Chinese,,0,0,0,,指向某个2级页面表的地址
Dialogue: 0,0:56:34.04,0:56:37.40,English,,0,0,0,,Or it contains the address of some level 2 page table
Dialogue: 0,0:56:34.04,0:56:37.40,Chinese,,0,0,0,,或者它包含某些2级页表的地址
Dialogue: 0,0:56:39.26,0:56:42.34,English,,0,0,0,,So that points to the base of this level 2 page table
Dialogue: 0,0:56:39.26,0:56:42.34,Chinese,,0,0,0,,所以指向这个2级页面表的基础
Dialogue: 0,0:56:42.34,0:56:49.06,English,,0,0,0,,And then the vpn 2 bits are used as an index into that level 2 table right and so on
Dialogue: 0,0:56:42.34,0:56:49.06,Chinese,,0,0,0,,然后将vpn 2位用作该2级表的索引，依此类推
Dialogue: 0,0:56:50.64,0:56:58.06,English,,0,0,0,,Ok so eventually you get at the a PTE and the level k-1 table
Dialogue: 0,0:56:50.64,0:56:58.06,Chinese,,0,0,0,,好吧，所以最终你得到了一个PTE和k-1级表
Dialogue: 0,0:56:58.38,0:57:01.08,English,,0,0,0,,Points to the beginning of the level k page table
Dialogue: 0,0:56:58.38,0:57:01.08,Chinese,,0,0,0,,指向级别k页面表的开头
Dialogue: 0,0:57:01.72,0:57:06.58,English,,0,0,0,,And VPN k points to an offset within that table
Dialogue: 0,0:57:01.72,0:57:06.58,Chinese,,0,0,0,,VPN k指向该表中的偏移量
Dialogue: 0,0:57:07.32,0:57:12.06,English,,0,0,0,,Which finally contains the physical address of the page that we want to access
Dialogue: 0,0:57:07.32,0:57:12.06,Chinese,,0,0,0,,最后包含我们要访问的页面的物理地址
Dialogue: 0,0:57:13.06,0:57:19.80,English,,0,0,0,,Okay and then that physical address is used to form the PPN portion of the physical address
Dialogue: 0,0:57:13.06,0:57:19.80,Chinese,,0,0,0,,好的，然后该物理地址用于形成物理地址的PPN部分
Dialogue: 0,0:57:20.30,0:57:26.44,English,,0,0,0,,And just like before the virtual page offset is just copied directly unchanged to the physical page offset
Dialogue: 0,0:57:20.30,0:57:26.44,Chinese,,0,0,0,,就像之前虚拟页面偏移直接复制一样，直接复制到物理页面偏移量
Dialogue: 0,0:57:29.36,0:57:30.46,English,,0,0,0,,So is that clear to everybody
Dialogue: 0,0:57:29.36,0:57:30.46,Chinese,,0,0,0,,所有人都清楚这一点
Dialogue: 0,0:57:31.08,0:57:31.78,English,,0,0,0,,Yes question
Dialogue: 0,0:57:31.08,0:57:31.78,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:57:31.78,0:57:41.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:57:31.78,0:57:41.66,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:57:41.66,0:57:44.36,English,,0,0,0,,Let's see is it always a power of two yes
Dialogue: 0,0:57:41.66,0:57:44.36,Chinese,,0,0,0,,让我们看看它总是两个是的力量
Dialogue: 0,0:57:44.72,0:57:49.02,English,,0,0,0,,At least and it's defined by the architecture,so for intel it's a four level system
Dialogue: 0,0:57:44.72,0:57:49.02,Chinese,,0,0,0,,至少它是由架构定义的，因此对于intel来说它是一个四级系统
Dialogue: 0,0:57:50.06,0:57:55.64,English,,0,0,0,,Now why would it be and then the quick could it will...it always be less than 6
Dialogue: 0,0:57:50.06,0:57:55.64,Chinese,,0,0,0,,现在为什么会这样，然后它会快速...它总是小于6
Dialogue: 0,0:58:03.94,0:58:06.42,English,,0,0,0,,Oh give us a 64-bit system yeah
Dialogue: 0,0:58:03.94,0:58:06.42,Chinese,,0,0,0,,哦，给我们一个64位系统是啊
Dialogue: 0,0:58:06.74,0:58:11.58,English,,0,0,0,,Yeah there's only the block size is fixed
Dialogue: 0,0:58:06.74,0:58:11.58,Chinese,,0,0,0,,是的，只有块大小是固定的
Dialogue: 0,0:58:12.40,0:58:16.46,English,,0,0,0,,Right so that there's 12 bits here 2^12 is 4k
Dialogue: 0,0:58:12.40,0:58:16.46,Chinese,,0,0,0,,正确，这里有12位，2 ^ 12是4k
Dialogue: 0,0:58:17.34,0:58:22.08,English,,0,0,0,,So the remaining it's that you actually have 48 bits to play with
Dialogue: 0,0:58:17.34,0:58:22.08,Chinese,,0,0,0,,所以剩下的就是你实际上有48位可以玩
Dialogue: 0,0:58:24.74,0:58:32.66,English,,0,0,0,,So the remaining 48 bits could that's right so if it was 4 if it was 8  it would be 6 so you're right
Dialogue: 0,0:58:24.74,0:58:32.66,Chinese,,0,0,0,,所以剩下的48位可能是正确的，如果它是4，如果它是8那么它将是6所以你是对的
Dialogue: 0,0:58:34.06,0:58:38.60,English,,0,0,0,,In this scheme it could be at most 6 turns out in practice it's set at 4
Dialogue: 0,0:58:34.06,0:58:38.60,Chinese,,0,0,0,,在这个方案中，它实际上最多可以是6转，它设置为4
Dialogue: 0,0:58:40.12,0:58:41.48,English,,0,0,0,,And there was a question over here
Dialogue: 0,0:58:40.12,0:58:41.48,Chinese,,0,0,0,,这里有一个问题
Dialogue: 0,0:58:41.50,0:58:50.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:58:41.50,0:58:50.42,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:58:50.44,0:58:52.34,English,,0,0,0,,Have it like this multi-level system
Dialogue: 0,0:58:50.44,0:58:52.34,Chinese,,0,0,0,,有它像这个多级系统
Dialogue: 0,0:58:52.88,0:58:54.86,English,,0,0,0,,Oh okay so the question
Dialogue: 0,0:58:52.88,0:58:54.86,Chinese,,0,0,0,,哦好的，所以问题
Dialogue: 0,0:58:59.08,0:59:00.86,English,,0,0,0,,Is yeah the question is how does it save you space
Dialogue: 0,0:58:59.08,0:59:00.86,Chinese,,0,0,0,,是的问题是它是如何为你节省空间的
Dialogue: 0,0:59:01.30,0:59:07.70,English,,0,0,0,,So the reason it saves you space is you go back to this other figure maybe I didn't explain this well enough
Dialogue: 0,0:59:01.30,0:59:07.70,Chinese,,0,0,0,,所以它为你节省空间的原因是你回到这个其他的数字，也许我没有解释得这么好
Dialogue: 0,0:59:16.96,0:59:20.18,English,,0,0,0,,So you see this
Dialogue: 0,0:59:16.96,0:59:20.18,Chinese,,0,0,0,,所以你看到了这个
Dialogue: 0,0:59:25.64,0:59:31.04,English,,0,0,0,,If we...okay so let's say we wanted to map this virtual address space with a single page table
Dialogue: 0,0:59:25.64,0:59:31.04,Chinese,,0,0,0,,如果我们......好吧那就让我们说我们想用一个页面表来映射这个虚拟地址空间
Dialogue: 0,0:59:32.36,0:59:35.54,English,,0,0,0,,We would need a PTE for every page within that address
Dialogue: 0,0:59:32.36,0:59:35.54,Chinese,,0,0,0,,我们需要为该地址内的每个页面提供PTE
Dialogue: 0,0:59:36.34,0:59:37.62,English,,0,0,0,,Whether it was used or not
Dialogue: 0,0:59:36.34,0:59:37.62,Chinese,,0,0,0,,是否使用过
Dialogue: 0,0:59:39.76,0:59:47.56,English,,0,0,0,,Okay it goes back if we had a 48-bit address space
Dialogue: 0,0:59:39.76,0:59:47.56,Chinese,,0,0,0,,好吧，如果我们有一个48位的地址空间，它会回来
Dialogue: 0,0:59:49.12,0:59:57.08,English,,0,0,0,,We'd need enough,we need a page table entry for each page virtual page in that address space
Dialogue: 0,0:59:49.12,0:59:57.08,Chinese,,0,0,0,,我们需要足够的，我们需要在该地址空间中的每个页面虚拟页面的页表条目
Dialogue: 0,1:00:00.82,1:00:08.50,English,,0,0,0,,Okay whether that page was used or not,so let me think about it 2^48 is a x several exabytes
Dialogue: 0,1:00:00.82,1:00:08.50,Chinese,,0,0,0,,好的，不管是否使用过这个页面，让我想一想2 ^ 48是x几个exabytes
Dialogue: 0,1:00:10.44,1:00:14.72,English,,0,0,0,,We need a page table that would have an entry for each virtual page
Dialogue: 0,1:00:10.44,1:00:14.72,Chinese,,0,0,0,,我们需要一个页表，每个虚拟页面都有一个条目
Dialogue: 0,1:00:15.28,1:00:17.20,English,,0,0,0,,In that to the 48th bit address space
Dialogue: 0,1:00:15.28,1:00:17.20,Chinese,,0,0,0,,在那到第48位地址空间
Dialogue: 0,1:00:18.48,1:00:22.36,English,,0,0,0,,And most of those pages by far the vast majority would never ever be used
Dialogue: 0,1:00:18.48,1:00:22.36,Chinese,,0,0,0,,到目前为止，大多数这些页面绝大多数都不会被使用
Dialogue: 0,1:00:23.58,1:00:25.16,English,,0,0,0,,Okay so that's where the waste comes in
Dialogue: 0,1:00:23.58,1:00:25.16,Chinese,,0,0,0,,好的，这就是垃圾进来的地方
Dialogue: 0,1:00:26.40,1:00:32.22,English,,0,0,0,,Okay so here with a multi-level page system with this multi-level scheme
Dialogue: 0,1:00:26.40,1:00:32.22,Chinese,,0,0,0,,好的，这里有一个多级页面系统，这个多级方案
Dialogue: 0,1:00:32.96,1:00:37.92,English,,0,0,0,,You only need to generate in this case these level two if it's a two-level system
Dialogue: 0,1:00:32.96,1:00:37.92,Chinese,,0,0,0,,如果是两级系统，你只需要在这种情况下生成这两级
Dialogue: 0,1:00:38.36,1:00:40.82,English,,0,0,0,,You only need to generate level two page tables
Dialogue: 0,1:00:38.36,1:00:40.82,Chinese,,0,0,0,,你只需要生成二级页表
Dialogue: 0,1:00:40.90,1:00:45.78,English,,0,0,0,,Enough level two pages to cover the portion of the virtual address space that you're actually using
Dialogue: 0,1:00:40.90,1:00:45.78,Chinese,,0,0,0,,足够的两级页面来覆盖你实际使用的虚拟地址空间部分
Dialogue: 0,1:00:46.34,1:00:50.96,English,,0,0,0,,Okay and that portion of the virtual address space that you're not using at this gap right here
Dialogue: 0,1:00:46.34,1:00:50.96,Chinese,,0,0,0,,好的，你在这个空白处没有使用的那部分虚拟地址空间就在这里
Dialogue: 0,1:00:51.96,1:00:53.92,English,,0,0,0,,There's no need to have a page table is
Dialogue: 0,1:00:51.96,1:00:53.92,Chinese,,0,0,0,,没有必要有一个页表
Dialogue: 0,1:00:57.65,1:01:04.04,English,,0,0,0,,Is that clear?that that's a really good important question,but you look unconvinced
Dialogue: 0,1:00:57.65,1:01:04.04,Chinese,,0,0,0,,那是否清楚？这是一个非常重要的问题，但你看起来并不相信
Dialogue: 0,1:01:04.08,1:01:14.00,English,,0,0,0,,[student speaking]
Dialogue: 0,1:01:04.08,1:01:14.00,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:01:14.02,1:01:17.82,English,,0,0,0,,Well yeah yeah you still need you still need a page table that has
Dialogue: 0,1:01:14.02,1:01:17.82,Chinese,,0,0,0,,好吧是的是的你仍然需要你仍然需要一个页面表
Dialogue: 0,1:01:22.70,1:01:27.22,English,,0,0,0,,Let's see in this case there's 4k bite pages 4 bit PTE
Dialogue: 0,1:01:22.70,1:01:27.22,Chinese,,0,0,0,,让我们看看在这种情况下有4k咬页4位PTE
Dialogue: 0,1:01:27.24,1:01:31.86,English,,0,0,0,,So there's 1k you have 1k PTEs
Dialogue: 0,1:01:27.24,1:01:31.86,Chinese,,0,0,0,,所以有1k你有1k PTE
Dialogue: 0,1:01:32.44,1:01:39.62,English,,0,0,0,,So you still need you still need a level 1 page table that has 1k PTEs
Dialogue: 0,1:01:32.44,1:01:39.62,Chinese,,0,0,0,,因此，你仍然需要一个具有1k PTE的1级页表
Dialogue: 0,1:01:40.18,1:01:42.16,English,,0,0,0,,But those are only 8 bytes right I mean
Dialogue: 0,1:01:40.18,1:01:42.16,Chinese,,0,0,0,,但是我的意思是那些只有8个字节
Dialogue: 0,1:01:43.92,1:01:46.28,English,,0,0,0,,So you still need to you still need to have space
Dialogue: 0,1:01:43.92,1:01:46.28,Chinese,,0,0,0,,所以你仍然需要你还需要空间
Dialogue: 0,1:01:46.38,1:01:51.94,English,,0,0,0,,Because you don't know you know you're not sure which of these which reason of the address space you're going to need to cover
Dialogue: 0,1:01:46.38,1:01:51.94,Chinese,,0,0,0,,因为你不知道你知道你不确定这些地址空间的哪个原因需要覆盖
Dialogue: 0,1:01:53.02,1:01:54.52,English,,0,0,0,,Ok and it's the same thing for
Dialogue: 0,1:01:53.02,1:01:54.52,Chinese,,0,0,0,,好的，这是一回事
Dialogue: 0,1:01:55.78,1:02:00.00,English,,0,0,0,,Here in this case, in these first two PTEs these first two level 2 page tables
Dialogue: 0,1:01:55.78,1:02:00.00,Chinese,,0,0,0,,在这种情况下，在前两个PTE中，前两个2级页表
Dialogue: 0,1:02:02.06,1:02:05.40,English,,0,0,0,,They're portion of the address space was actually all being used
Dialogue: 0,1:02:02.06,1:02:05.40,Chinese,,0,0,0,,它们是地址空间的一部分实际上都在使用
Dialogue: 0,1:02:06.02,1:02:13.44,English,,0,0,0,,Right so each one of these PTEs at level 2 had to be allocated had to be initialized and used
Dialogue: 0,1:02:06.02,1:02:13.44,Chinese,,0,0,0,,正确，因此必须分配第2级的这些PTE中的每一个必须被初始化和使用
Dialogue: 0,1:02:14.22,1:02:18.78,English,,0,0,0,,Right but in this portion of the address space that contain the stack
Dialogue: 0,1:02:14.22,1:02:18.78,Chinese,,0,0,0,,正确但是在包含堆栈的地址空间的这一部分中
Dialogue: 0,1:02:19.80,1:02:25.48,English,,0,0,0,,This third level 2 page table has most of its PTEs or no
Dialogue: 0,1:02:19.80,1:02:25.48,Chinese,,0,0,0,,这个第三级2页表有大部分的PTE或没有
Dialogue: 0,1:02:28.62,1:02:31.08,English,,0,0,0,,You still have to allocate space for them but they're there no
Dialogue: 0,1:02:28.62,1:02:31.08,Chinese,,0,0,0,,你仍然需要为他们分配空间，但他们没有
Dialogue: 0,1:02:35.68,1:02:40.24,English,,0,0,0,,Ok that's a really good question it's important that I hope that's clear
Dialogue: 0,1:02:35.68,1:02:40.24,Chinese,,0,0,0,,好的，这是一个非常好的问题，重要的是我希望这一点很清楚
Dialogue: 0,1:02:44.10,1:02:47.74,English,,0,0,0,,Any other questions will we go on
Dialogue: 0,1:02:44.10,1:02:47.74,Chinese,,0,0,0,,我们会继续提出任何其他问题
Dialogue: 0,1:02:51.38,1:02:52.76,English,,0,0,0,,Sorry oh okay question
Dialogue: 0,1:02:51.38,1:02:52.76,Chinese,,0,0,0,,对不起，好的问题
Dialogue: 0,1:02:52.86,1:03:06.46,English,,0,0,0,,[student speaking]
Dialogue: 0,1:02:52.86,1:03:06.46,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:03:06.46,1:03:07.28,English,,0,0,0,,Exactly just
Dialogue: 0,1:03:06.46,1:03:07.28,Chinese,,0,0,0,,完全正确
Dialogue: 0,1:03:08.32,1:03:12.16,English,,0,0,0,,Just like here the MMU members doing all of this this is all hardware logic
Dialogue: 0,1:03:08.32,1:03:12.16,Chinese,,0,0,0,,就像这里MMU成员所做的一切都是硬件逻辑
Dialogue: 0,1:03:13.76,1:03:20.16,English,,0,0,0,,So it and the art the number of page tables levels is defined by the architecture okay
Dialogue: 0,1:03:13.76,1:03:20.16,Chinese,,0,0,0,,所以它和艺术的页面表级别的数量是由架构定义好的
Dialogue: 0,1:03:21.98,1:03:27.74,English,,0,0,0,,So the MMU takes the virtual address that's presented to it
Dialogue: 0,1:03:21.98,1:03:27.74,Chinese,,0,0,0,,因此，MMU获取呈现给它的虚拟地址
Dialogue: 0,1:03:29.12,1:03:37.02,English,,0,0,0,,And it uses a portion a subset of those bits to access each page table okay
Dialogue: 0,1:03:29.12,1:03:37.02,Chinese,,0,0,0,,并且它使用这些位的子集的一部分来访问每个页表
Dialogue: 0,1:03:38.88,1:03:40.74,English,,0,0,0,,So it's just like...did I answer your question?okay
Dialogue: 0,1:03:38.88,1:03:40.74,Chinese,,0,0,0,,所以就像......我回答你的问题了吗？好的
Dialogue: 0,1:03:42.04,1:03:43.48,English,,0,0,0,,So it's just like before that
Dialogue: 0,1:03:42.04,1:03:43.48,Chinese,,0,0,0,,所以就像那之前一样
Dialogue: 0,1:03:44.54,1:03:53.80,English,,0,0,0,,The level k,VPN k is used to compute an index into the level k page table yes
Dialogue: 0,1:03:44.54,1:03:53.80,Chinese,,0,0,0,,级别k，VPN k用于计算级别k页表中的索引是
Dialogue: 0,1:03:53.80,1:04:04.40,English,,0,0,0,,[student speaking]
Dialogue: 0,1:03:53.80,1:04:04.40,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:04.40,1:04:08.28,English,,0,0,0,,Okay the question is why are the indices arranged right to left on which diagram
Dialogue: 0,1:04:04.40,1:04:08.28,Chinese,,0,0,0,,好的问题是为什么索引从右到左排列在哪个图表上
Dialogue: 0,1:04:08.28,1:04:13.16,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:08.28,1:04:13.16,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:13.18,1:04:16.66,English,,0,0,0,,Oh these are the bits,this is the least significant bit it's always bit zero
Dialogue: 0,1:04:13.18,1:04:16.66,Chinese,,0,0,0,,哦，这些是位，这是最不重要的位，它总是位为零
Dialogue: 0,1:04:17.84,1:04:20.08,English,,0,0,0,,Yeah that's a good question,so the question was why do these
Dialogue: 0,1:04:17.84,1:04:20.08,Chinese,,0,0,0,,是的，这是一个很好的问题，所以问题是为什么这些
Dialogue: 0,1:04:20.94,1:04:25.52,English,,0,0,0,,In this diagram why are these these bits labeled right to left starting at zero
Dialogue: 0,1:04:20.94,1:04:25.52,Chinese,,0,0,0,,在此图中，为什么这些位从零开始从右到左标记
Dialogue: 0,1:04:26.10,1:04:29.82,English,,0,0,0,,And the answer is that we're indicating the bit position
Dialogue: 0,1:04:26.10,1:04:29.82,Chinese,,0,0,0,,答案是我们正在指出比特位置
Dialogue: 0,1:04:30.42,1:04:35.88,English,,0,0,0,,So zero is the least significant bit and n-1 is the most significant bit
Dialogue: 0,1:04:30.42,1:04:35.88,Chinese,,0,0,0,,因此，零是最低有效位，n-1是最高有效位
Dialogue: 0,1:04:38.04,1:04:38.64,English,,0,0,0,,Yes question
Dialogue: 0,1:04:38.04,1:04:38.64,Chinese,,0,0,0,,是的问题
Dialogue: 0,1:04:38.66,1:04:47.58,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:38.66,1:04:47.58,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:04:47.58,1:04:51.98,English,,0,0,0,,Yeah so the question is what's the overhead involved in these when you have these multiple levels
Dialogue: 0,1:04:47.58,1:04:51.98,Chinese,,0,0,0,,是的，所以问题是当你有这些多个级别时，这些开销涉及到什么
Dialogue: 0,1:04:52.38,1:04:54.94,English,,0,0,0,,Now are you talking about overhead to
Dialogue: 0,1:04:52.38,1:04:54.94,Chinese,,0,0,0,,现在你在谈论开销
Dialogue: 0,1:04:54.96,1:05:03.58,English,,0,0,0,,[student speaking]
Dialogue: 0,1:04:54.96,1:05:03.58,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:05:03.58,1:05:09.06,English,,0,0,0,,Yeah well so there's clearly if you don't get TLB hits
Dialogue: 0,1:05:03.58,1:05:09.06,Chinese,,0,0,0,,是的，所以如果你没有获得TLB点击，那就很明显了
Dialogue: 0,1:05:10.52,1:05:11.93,English,,0,0,0,,It would be a lot of overhead
Dialogue: 0,1:05:10.52,1:05:11.93,Chinese,,0,0,0,,这将是一个很大的开销
Dialogue: 0,1:05:12.60,1:05:17.88,English,,0,0,0,,Because it would be you would be fetching PTEs from multiple page tables for memory
Dialogue: 0,1:05:12.60,1:05:17.88,Chinese,,0,0,0,,因为你将从多个页表中获取内存中的PTE
Dialogue: 0,1:05:19.22,1:05:24.06,English,,0,0,0,,So that but because of locality the chances are almost the...
Dialogue: 0,1:05:19.22,1:05:24.06,Chinese,,0,0,0,,所以，但由于地方的原因，机会几乎是......
Dialogue: 0,1:05:24.38,1:05:27.52,English,,0,0,0,,The chances this level one table covers the entire address space
Dialogue: 0,1:05:24.38,1:05:27.52,Chinese,,0,0,0,,这一级表覆盖整个地址空间的可能性很大
Dialogue: 0,1:05:28.08,1:05:31.84,English,,0,0,0,,So it's always going to be in the in the PTE, in the TLB
Dialogue: 0,1:05:28.08,1:05:31.84,Chinese,,0,0,0,,所以它总是会出现在PTE中的TLB中
Dialogue: 0,1:05:32.64,1:05:38.88,English,,0,0,0,,These level two tables are covering a huge swath of the address space
Dialogue: 0,1:05:32.64,1:05:38.88,Chinese,,0,0,0,,这两级表覆盖了大量的地址空间
Dialogue: 0,1:05:39.66,1:05:43.70,English,,0,0,0,,So chances are they're going to be in the TLB too right so
Dialogue: 0,1:05:39.66,1:05:43.70,Chinese,,0,0,0,,所以他们很有可能在TLB中也是如此
Dialogue: 0,1:05:44.42,1:05:49.24,English,,0,0,0,,So as long as your program has reasonable locality
Dialogue: 0,1:05:44.42,1:05:49.24,Chinese,,0,0,0,,所以只要你的程序有合理的位置
Dialogue: 0,1:05:49.70,1:05:55.24,English,,0,0,0,,Most of these lookups are going to hit in the TLB
Dialogue: 0,1:05:49.70,1:05:55.24,Chinese,,0,0,0,,大多数这些查找都会在TLB中出现
Dialogue: 0,1:05:56.30,1:06:03.16,English,,0,0,0,,Okay so it turns out that the overhead with reasonably written programs is negligible
Dialogue: 0,1:05:56.30,1:06:03.16,Chinese,,0,0,0,,好的，事实证明合理编写程序的开销可以忽略不计
Dialogue: 0,1:06:06.74,1:06:09.72,English,,0,0,0,,But that's a very it's a very important consideration
Dialogue: 0,1:06:06.74,1:06:09.72,Chinese,,0,0,0,,但这是一个非常重要的考虑因素
Dialogue: 0,1:06:10.62,1:06:16.10,English,,0,0,0,,You know maybe that's maybe that speaks against increasing at some point if you had too many page tables
Dialogue: 0,1:06:10.62,1:06:16.10,Chinese,,0,0,0,,你知道，如果你有太多的页表，也许这可能会反对在某些方面增加
Dialogue: 0,1:06:16.94,1:06:20.26,English,,0,0,0,,You might increase the probability of misses in the TLB
Dialogue: 0,1:06:16.94,1:06:20.26,Chinese,,0,0,0,,你可能会增加TLB中未命中的可能性
Dialogue: 0,1:06:20.26,1:06:24.42,English,,0,0,0,,So it's probably something they very carefully considered
Dialogue: 0,1:06:20.26,1:06:24.42,Chinese,,0,0,0,,所以这可能是他们非常仔细考虑的事情
Dialogue: 0,1:06:27.78,1:06:29.78,English,,0,0,0,,Okay any other questions yeah
Dialogue: 0,1:06:27.78,1:06:29.78,Chinese,,0,0,0,,好的，还有其他任何问题
Dialogue: 0,1:06:29.90,1:06:39.94,English,,0,0,0,,[student speaking]Yeah so if we use segmentation plus paging,so it is the addresses page table the recommended linear address of our real
Dialogue: 0,1:06:29.90,1:06:39.94,Chinese,,0,0,0,,[学生说话]是的，如果我们使用分段加分页，那么地址页表就是我们真实的推荐线性地址
Dialogue: 0,1:06:39.96,1:06:45.24,English,,0,0,0,,Ho boy the question was how does segmentation fit into this and
Dialogue: 0,1:06:39.96,1:06:45.24,Chinese,,0,0,0,,何男孩的问题是分割如何适应这个和
Dialogue: 0,1:06:46.56,1:06:50.08,English,,0,0,0,,We're not going to go there
Dialogue: 0,1:06:46.56,1:06:50.08,Chinese,,0,0,0,,我们不会去那里
Dialogue: 0,1:06:50.48,1:06:53.20,English,,0,0,0,,So in earlier intel systems
Dialogue: 0,1:06:50.48,1:06:53.20,Chinese,,0,0,0,,所以在早期的英特尔系统
Dialogue: 0,1:06:56.08,1:07:01.60,English,,0,0,0,,Such as the actually the first intel system I programs it was a 286
Dialogue: 0,1:06:56.08,1:07:01.60,Chinese,,0,0,0,,比如实际上我编程的第一个英特尔系统是286
Dialogue: 0,1:07:03.00,1:07:06.65,English,,0,0,0,,So the 286 no is neat it was the 8086
Dialogue: 0,1:07:03.00,1:07:06.65,Chinese,,0,0,0,,所以286没有它是8086的整洁
Dialogue: 0,1:07:07.28,1:07:11.00,English,,0,0,0,,Anyway in earlier intel systems had 16-bit addresses
Dialogue: 0,1:07:07.28,1:07:11.00,Chinese,,0,0,0,,无论如何，在早期的英特尔系统中有16位地址
Dialogue: 0,1:07:11.82,1:07:13.02,English,,0,0,0,,Which is tiny right
Dialogue: 0,1:07:11.82,1:07:13.02,Chinese,,0,0,0,,哪个很小
Dialogue: 0,1:07:13.04,1:07:16.38,English,,0,0,0,,It's only 2^16 for your address space
Dialogue: 0,1:07:13.04,1:07:16.38,Chinese,,0,0,0,,你的地址空间只有2 ^ 16
Dialogue: 0,1:07:17.12,1:07:22.41,English,,0,0,0,,And so as a hack to try to increase the effective size of the
Dialogue: 0,1:07:17.12,1:07:22.41,Chinese,,0,0,0,,因此，作为一个黑客，试图增加有效的大小
Dialogue: 0,1:07:23.10,1:07:26.74,English,,0,0,0,,Of this address space the introduced the notion of segmentation
Dialogue: 0,1:07:23.10,1:07:26.74,Chinese,,0,0,0,,在这个地址空间中引入了分割的概念
Dialogue: 0,1:07:27.90,1:07:31.78,English,,0,0,0,,And so there were four segments 4-bit
Dialogue: 0,1:07:27.90,1:07:31.78,Chinese,,0,0,0,,所以有四个4位段
Dialogue: 0,1:07:32.64,1:07:38.40,English,,0,0,0,,There was a register segment registers that contain 4 bits that could be applied to the address
Dialogue: 0,1:07:32.64,1:07:38.40,Chinese,,0,0,0,,寄存器段寄存器包含4位可应用于该地址的寄存器
Dialogue: 0,1:07:39.36,1:07:45.64,English,,0,0,0,,So an address was the combination of the segment knows more than
Dialogue: 0,1:07:39.36,1:07:45.64,Chinese,,0,0,0,,所以一个地址是段的组合知道更多
Dialogue: 0,1:07:49.16,1:07:51.56,English,,0,0,0,,Yeah you need the segment formed
Dialogue: 0,1:07:49.16,1:07:51.56,Chinese,,0,0,0,,是的，你需要形成的部分
Dialogue: 0,1:07:52.46,1:07:56.76,English,,0,0,0,,The address then was a combination of the segment bits plus the address
Dialogue: 0,1:07:52.46,1:07:56.76,Chinese,,0,0,0,,然后地址是段位加地址的组合
Dialogue: 0,1:07:57.48,1:08:00.70,English,,0,0,0,,So you could use the segment bits to create an offset
Dialogue: 0,1:07:57.48,1:08:00.70,Chinese,,0,0,0,,因此，你可以使用段位来创建偏移量
Dialogue: 0,1:08:01.12,1:08:05.62,English,,0,0,0,,So it was a - it wasn't effectively a 20 bit address space
Dialogue: 0,1:08:01.12,1:08:05.62,Chinese,,0,0,0,,所以它是 - 它实际上不是一个20位的地址空间
Dialogue: 0,1:08:06.22,1:08:11.56,English,,0,0,0,,But you can only address,you can only access it in 2^16 chunks right so the
Dialogue: 0,1:08:06.22,1:08:11.56,Chinese,,0,0,0,,但你只能解决，你只能在2 ^ 16块中访问它，所以
Dialogue: 0,1:08:12.74,1:08:22.50,English,,0,0,0,,The segment would determine an offset into the that this 20-bit address space
Dialogue: 0,1:08:12.74,1:08:22.50,Chinese,,0,0,0,,该段将确定该20位地址空间的偏移量
Dialogue: 0,1:08:22.50,1:08:25.98,English,,0,0,0,,And then from that you could address 16 bits
Dialogue: 0,1:08:22.50,1:08:25.98,Chinese,,0,0,0,,然后从那里你可以解决16位
Dialogue: 0,1:08:27.20,1:08:33.16,English,,0,0,0,,So it was this very unsatisfying devilishly hard to program thing because
Dialogue: 0,1:08:27.20,1:08:33.16,Chinese,,0,0,0,,因此，这是非常令人不满意的非常难以编程的事情
Dialogue: 0,1:08:33.82,1:08:36.50,English,,0,0,0,,You can only access 16 bit chunks at a time
Dialogue: 0,1:08:33.82,1:08:36.50,Chinese,,0,0,0,,你一次只能访问16位块
Dialogue: 0,1:08:37.94,1:08:46.72,English,,0,0,0,,So anyway we're not going to a few years later they came to their senses and just created a real virtual memory system with linear drill spaces
Dialogue: 0,1:08:37.94,1:08:46.72,Chinese,,0,0,0,,所以无论如何我们不会在几年后他们开始意识到他们只是创建了一个带有线性钻孔空间的真实虚拟内存系统
Dialogue: 0,1:08:50.54,1:08:54.30,English,,0,0,0,,But you know really there
Dialogue: 0,1:08:50.54,1:08:54.30,Chinese,,0,0,0,,但你知道的确如此
Dialogue: 0,1:09:02.20,1:09:03.62,English,,0,0,0,,Yeah I don't know we're just did
Dialogue: 0,1:09:02.20,1:09:03.62,Chinese,,0,0,0,,是的我不知道我们刚才做到了
Dialogue: 0,1:09:06.66,1:09:11.40,English,,0,0,0,,I'm not even sure if they do address translation on those actually
Dialogue: 0,1:09:06.66,1:09:11.40,Chinese,,0,0,0,,我甚至不确定他们是否确实解决了这些问题
Dialogue: 0,1:09:11.58,1:09:14.08,English,,0,0,0,,So I'm not sure but you really don't want to go there
Dialogue: 0,1:09:11.58,1:09:14.08,Chinese,,0,0,0,,所以我不确定，但你真的不想去那里
Dialogue: 0,1:09:14.88,1:09:17.98,English,,0,0,0,,[student speaking]
Dialogue: 0,1:09:14.88,1:09:17.98,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,1:09:18.02,1:09:21.71,English,,0,0,0,,Yeah oh it does it does so the question is it doesn't exist anymore
Dialogue: 0,1:09:18.02,1:09:21.71,Chinese,,0,0,0,,是的哦它确实如此，问题是它不再存在了
Dialogue: 0,1:09:22.08,1:09:28.88,English,,0,0,0,,Everything intel's been incredibly good about maintaining backward compatibility
Dialogue: 0,1:09:22.08,1:09:28.88,Chinese,,0,0,0,,英特尔在保持向后兼容性方面一直非常出色
Dialogue: 0,1:09:29.74,1:09:31.90,English,,0,0,0,,So that stuff's all in there
Dialogue: 0,1:09:29.74,1:09:31.90,Chinese,,0,0,0,,那些东西都在那里
Dialogue: 0,1:09:33.88,1:09:39.14,English,,0,0,0,,But there's a mode bit when you boot your system up you set a bit that says I want a linear address space
Dialogue: 0,1:09:33.88,1:09:39.14,Chinese,,0,0,0,,但是当你启动系统时有一个模式位，你设置了一点我想要一个线性地址空间
Dialogue: 0,1:09:43.38,1:09:56.28,English,,0,0,0,,Okay any other question
Dialogue: 0,1:09:43.38,1:09:56.28,Chinese,,0,0,0,,还有其他任何问题
Dialogue: 0,1:09:56.46,1:09:58.52,English,,0,0,0,,Oh no VPN to is the offset
Dialogue: 0,1:09:56.46,1:09:58.52,Chinese,,0,0,0,,哦没有VPN是抵消
Dialogue: 0,1:10:01.54,1:10:07.48,English,,0,0,0,,Okay so the question is why do we care about VPN2 since that it points to the level 2 table
Dialogue: 0,1:10:01.54,1:10:07.48,Chinese,,0,0,0,,好吧，问题是为什么我们关心VPN2，因为它指向2级表
Dialogue: 0,1:10:08.00,1:10:15.68,English,,0,0,0,,So what gives you the beginning of the level 2 table is the PTE entry in the level 1 table
Dialogue: 0,1:10:08.00,1:10:15.68,Chinese,,0,0,0,,那么为你提供2级表开头的是1级表中的PTE条目
Dialogue: 0,1:10:17.28,1:10:22.06,English,,0,0,0,,Okay so the level 1 table points to the beginning of that level 2 table
Dialogue: 0,1:10:17.28,1:10:22.06,Chinese,,0,0,0,,好的，所以1级表指向该2级表的开头
Dialogue: 0,1:10:22.68,1:10:27.58,English,,0,0,0,,And VPN to gives you the offset into that the level 2 table
Dialogue: 0,1:10:22.68,1:10:27.58,Chinese,,0,0,0,,并且VPN为你提供了2级表的偏移量
Dialogue: 0,1:10:28.58,1:10:32.34,English,,0,0,0,,So the it finds the address by taking the base address
Dialogue: 0,1:10:28.58,1:10:32.34,Chinese,,0,0,0,,所以它通过取基地址找到地址
Dialogue: 0,1:10:33.10,1:10:35.64,English,,0,0,0,,And then VPN2 times the PTE sighs
Dialogue: 0,1:10:33.10,1:10:35.64,Chinese,,0,0,0,,然后VPN2倍PTE叹息
Dialogue: 0,1:10:39.28,1:10:41.80,English,,0,0,0,,Okay good good any other questions
Dialogue: 0,1:10:39.28,1:10:41.80,Chinese,,0,0,0,,好的，还有其他任何问题
Dialogue: 0,1:10:49.82,1:10:52.96,English,,0,0,0,,Okay well that'll do it for today
Dialogue: 0,1:10:49.82,1:10:52.96,Chinese,,0,0,0,,好的，那就是为今天做的
Dialogue: 0,1:10:54.02,1:10:57.16,English,,0,0,0,,Next week or on Thursday we'll look at
Dialogue: 0,1:10:54.02,1:10:57.16,Chinese,,0,0,0,,下周或周四我们会看一下
Dialogue: 0,1:10:57.94,1:11:03.78,English,,0,0,0,,How how virtual memory is implemented in real systems and in Linux
Dialogue: 0,1:10:57.94,1:11:03.78,Chinese,,0,0,0,,虚拟内存如何在实际系​​统和Linux中实现
