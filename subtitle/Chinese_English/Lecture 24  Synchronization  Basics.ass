[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video File: ../../../../Desktop/csapp/Lecture 24  Synchronization  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 635
Active Line: 643
Video Position: 101393

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.90,0:00:04.74,English,,0,0,0,,All right well good afternoon everybody good to see you welcome
Dialogue: 0,0:00:01.90,0:00:04.74,Chinese,,0,0,0,,好的，下午好，每个人都很高兴看到你的欢迎
Dialogue: 0,0:00:06.54,0:00:09.10,English,,0,0,0,,Welcome to all those students watching on video as well
Dialogue: 0,0:00:06.54,0:00:09.10,Chinese,,0,0,0,,欢迎所有观看视频的学生
Dialogue: 0,0:00:11.68,0:00:17.18,English,,0,0,0,,Before we start we were talking about joinable and detached threads
Dialogue: 0,0:00:11.68,0:00:17.18,Chinese,,0,0,0,,在我们开始之前，我们讨论的是可连接和分离的线程
Dialogue: 0,0:00:17.36,0:00:23.96,English,,0,0,0,,And you asked the question about why you would ever want to have threads running in non detached mode
Dialogue: 0,0:00:17.36,0:00:23.96,Chinese,,0,0,0,,并且你询问了为什么你希望线程在非分离模式下运行的问题
Dialogue: 0,0:00:24.00,0:00:27.12,English,,0,0,0,,You know why you'd ever run in want to have him running joinable
Dialogue: 0,0:00:24.00,0:00:27.12,Chinese,,0,0,0,,你知道为什么你曾经想要让他跑步加入
Dialogue: 0,0:00:27.74,0:00:32.04,English,,0,0,0,,And I didn't give you a very good answer so I want to try to to answer that for you better
Dialogue: 0,0:00:27.74,0:00:32.04,Chinese,,0,0,0,,而且我没有给你一个很好的答案，所以我想尽力回答你
Dialogue: 0,0:00:33.86,0:00:39.64,English,,0,0,0,,Turns out there's an important class of sort of parallel programming
Dialogue: 0,0:00:33.86,0:00:39.64,Chinese,,0,0,0,,事实证明，这是一类重要的并行编程
Dialogue: 0,0:00:40.02,0:00:43.60,English,,0,0,0,,There's an important parallel programming model called fork and join
Dialogue: 0,0:00:40.02,0:00:43.60,Chinese,,0,0,0,,有一个重要的并行编程模型叫做fork和join
Dialogue: 0,0:00:44.38,0:00:47.84,English,,0,0,0,,Where program consists of a series of phases
Dialogue: 0,0:00:44.38,0:00:47.84,Chinese,,0,0,0,,程序由一系列阶段组成
Dialogue: 0,0:00:50.56,0:00:56.56,English,,0,0,0,,In each phase you have a worker or a master sorry
Dialogue: 0,0:00:50.56,0:00:56.56,Chinese,,0,0,0,,在每个阶段，你都有一个工人或一个主人抱歉
Dialogue: 0,0:00:57.66,0:01:00.54,English,,0,0,0,,And it creates a bunch of worker threads
Dialogue: 0,0:00:57.66,0:01:00.54,Chinese,,0,0,0,,它创建了一堆工作线程
Dialogue: 0,0:01:05.90,0:01:10.12,English,,0,0,0,,And then each of those worker threads solve some part of the problem for that phase
Dialogue: 0,0:01:05.90,0:01:10.12,Chinese,,0,0,0,,然后，每个工作线程解决该阶段的某些问题
Dialogue: 0,0:01:10.48,0:01:15.02,English,,0,0,0,,Like some maybe you take your data structure and you break it up into chunks
Dialogue: 0,0:01:10.48,0:01:15.02,Chinese,,0,0,0,,像某些人可能会采用你的数据结构，然后将其分解为块
Dialogue: 0,0:01:15.04,0:01:19.82,English,,0,0,0,,And then each thread updates the its own chunk of that data structure
Dialogue: 0,0:01:15.04,0:01:19.82,Chinese,,0,0,0,,然后每个线程更新其自己的数据结构块
Dialogue: 0,0:01:21.54,0:01:28.20,English,,0,0,0,,But for whatever reason the master then has to wait for the worker threads to finish before it can go on to the next phase
Dialogue: 0,0:01:21.54,0:01:28.20,Chinese,,0,0,0,,但无论出于何种原因，主人必须等待工作线程完成才能进入下一阶段
Dialogue: 0,0:01:28.94,0:01:32.10,English,,0,0,0,,So it does join, so this is called the fork
Dialogue: 0,0:01:28.94,0:01:32.10,Chinese,,0,0,0,,所以它确实加入了，所以这就叫做fork
Dialogue: 0,0:01:33.26,0:01:35.60,English,,0,0,0,,And then it waits for all the threads to finish
Dialogue: 0,0:01:33.26,0:01:35.60,Chinese,,0,0,0,,然后它等待所有线程完成
Dialogue: 0,0:01:37.32,0:01:40.00,English,,0,0,0,,By doing a join okay so this is called
Dialogue: 0,0:01:37.32,0:01:40.00,Chinese,,0,0,0,,通过连接好，所以这被称为
Dialogue: 0,0:01:41.20,0:01:43.50,English,,0,0,0,,This is called the fork and this is called the join
Dialogue: 0,0:01:41.20,0:01:43.50,Chinese,,0,0,0,,这称为fork，这称为连接
Dialogue: 0,0:01:44.32,0:01:47.26,English,,0,0,0,,And only when all of the threads have finished
Dialogue: 0,0:01:44.32,0:01:47.26,Chinese,,0,0,0,,并且只有当所有线程都完成时
Dialogue: 0,0:01:47.96,0:01:51.28,English,,0,0,0,,Can it go and do the next do the next phase
Dialogue: 0,0:01:47.96,0:01:51.28,Chinese,,0,0,0,,可以去做下一阶段的下一阶段
Dialogue: 0,0:01:56.12,0:02:00.40,English,,0,0,0,,Okay so this model is really important in things like scientific computing where
Dialogue: 0,0:01:56.12,0:02:00.40,Chinese,,0,0,0,,好的，所以这个模型在科学计算等方面非常重要
Dialogue: 0,0:02:01.22,0:02:06.76,English,,0,0,0,,You might...you're simulating some domain,you're simulating nature
Dialogue: 0,0:02:01.22,0:02:06.76,Chinese,,0,0,0,,你可能......你在模拟一些领域，你在模拟自然
Dialogue: 0,0:02:07.40,0:02:10.76,English,,0,0,0,,So you represent that as some domain like maybe you're simulating
Dialogue: 0,0:02:07.40,0:02:10.76,Chinese,,0,0,0,,所以你表示像某些域一样，你可能正在模拟
Dialogue: 0,0:02:11.36,0:02:15.04,English,,0,0,0,,How heat flows over a plate you know metal plate
Dialogue: 0,0:02:11.36,0:02:15.04,Chinese,,0,0,0,,如何热量流过你知道金属板的板块
Dialogue: 0,0:02:15.90,0:02:20.20,English,,0,0,0,,And so you might have these workers
Dialogue: 0,0:02:15.90,0:02:20.20,Chinese,,0,0,0,,所以你可能有这些工人
Dialogue: 0,0:02:21.30,0:02:24.04,English,,0,0,0,,You might partition the domain amongst a set of those workers
Dialogue: 0,0:02:21.30,0:02:24.04,Chinese,,0,0,0,,你可以在一组这些工作程序中对域进行分区
Dialogue: 0,0:02:24.84,0:02:27.90,English,,0,0,0,,And then each one of these phases is a time step
Dialogue: 0,0:02:24.84,0:02:27.90,Chinese,,0,0,0,,然后，这些阶段中的每一阶段都是一个时间步骤
Dialogue: 0,0:02:28.94,0:02:34.24,English,,0,0,0,,And then so once all the workers have finished a time step then they can advance to the next time step
Dialogue: 0,0:02:28.94,0:02:34.24,Chinese,,0,0,0,,然后，一旦所有工人完成了一个时间步骤，他们就可以前进到下一个时间步骤
Dialogue: 0,0:02:36.30,0:02:39.00,English,,0,0,0,,And so sorry I don't know why,I didn't think of it
Dialogue: 0,0:02:36.30,0:02:39.00,Chinese,,0,0,0,,对不起，我不知道为什么，我没想到
Dialogue: 0,0:02:39.52,0:02:41.76,English,,0,0,0,,That's a that's an important reason why you'd want this
Dialogue: 0,0:02:39.52,0:02:41.76,Chinese,,0,0,0,,这就是你想要这个的重要原因
Dialogue: 0,0:02:44.04,0:02:45.16,English,,0,0,0,,Okay so we saw
Dialogue: 0,0:02:44.04,0:02:45.16,Chinese,,0,0,0,,好的，所以我们看到了
Dialogue: 0,0:02:46.36,0:02:50.30,English,,0,0,0,,We've seen the threaded programs are nice
Dialogue: 0,0:02:46.36,0:02:50.30,Chinese,,0,0,0,,我们已经看到线程程序很好
Dialogue: 0,0:02:50.30,0:02:53.04,English,,0,0,0,,Because you they you can share all the global variables
Dialogue: 0,0:02:50.30,0:02:53.04,Chinese,,0,0,0,,因为你可以共享所有全局变量
Dialogue: 0,0:02:55.02,0:02:58.54,English,,0,0,0,,But this the sharing can have unintended consequences
Dialogue: 0,0:02:55.02,0:02:58.54,Chinese,,0,0,0,,但这种共享可能会产生意想不到的后果
Dialogue: 0,0:02:59.36,0:03:02.98,English,,0,0,0,,So somehow we need a mechanism where we can control
Dialogue: 0,0:02:59.36,0:03:02.98,Chinese,,0,0,0,,所以我们需要一种我们可以控制的机制
Dialogue: 0,0:03:02.98,0:03:07.08,English,,0,0,0,,How the flows of each individual thread are interleaved
Dialogue: 0,0:03:02.98,0:03:07.08,Chinese,,0,0,0,,每个单独线程的流如何交错
Dialogue: 0,0:03:08.28,0:03:12.52,English,,0,0,0,,So that bad things don't happen when we share data structures
Dialogue: 0,0:03:08.28,0:03:12.52,Chinese,,0,0,0,,因此，当我们共享数据结构时，不会发生坏事
Dialogue: 0,0:03:12.78,0:03:17.74,English,,0,0,0,,Okay so this this process of controlling the interleaving is called synchronization
Dialogue: 0,0:03:12.78,0:03:17.74,Chinese,,0,0,0,,好的，这个控制交织的过程称为同步
Dialogue: 0,0:03:17.74,0:03:24.68,English,,0,0,0,,So we're going to look at techniques that you can use to write correct threaded programs by properly synchronizing them
Dialogue: 0,0:03:17.74,0:03:24.68,Chinese,,0,0,0,,因此，我们将通过正确同步它们来查看可用于编写正确的线程程序的技术
Dialogue: 0,0:03:27.28,0:03:29.56,English,,0,0,0,,Now first though we need to have a clear idea
Dialogue: 0,0:03:27.28,0:03:29.56,Chinese,,0,0,0,,现在首先我们需要有一个清晰的想法
Dialogue: 0,0:03:30.10,0:03:34.78,English,,0,0,0,,So sharing is the issue right if we have threads that aren't sharing any resources
Dialogue: 0,0:03:30.10,0:03:34.78,Chinese,,0,0,0,,因此，如果我们拥有不共享任何资源的线程，那么共享是正确的问题
Dialogue: 0,0:03:35.90,0:03:37.08,English,,0,0,0,,Then there's no problem right
Dialogue: 0,0:03:35.90,0:03:37.08,Chinese,,0,0,0,,那就没问题吧
Dialogue: 0,0:03:37.16,0:03:42.02,English,,0,0,0,,That we saw this when we looked at it processes there's no shared data structures with processes
Dialogue: 0,0:03:37.16,0:03:42.02,Chinese,,0,0,0,,当我们查看它时，我们看到了这个过程，没有与进程共享的数据结构
Dialogue: 0,0:03:42.72,0:03:49.28,English,,0,0,0,,So we process these just run independently we don't really care how they're interleaved note no worries okay
Dialogue: 0,0:03:42.72,0:03:49.28,Chinese,,0,0,0,,所以我们处理这些只是独立运行我们并不真正关心他们是如何交错注意没有担心好
Dialogue: 0,0:03:49.80,0:03:54.14,English,,0,0,0,,But as soon as they introduce sharing then we have to be careful
Dialogue: 0,0:03:49.80,0:03:54.14,Chinese,,0,0,0,,但是一旦他们介绍共享，我们就必须小心
Dialogue: 0,0:03:56.24,0:04:00.58,English,,0,0,0,,Okay so to understand how to synchronize threads we first need to have a clear idea
Dialogue: 0,0:03:56.24,0:04:00.58,Chinese,,0,0,0,,好的，要了解如何同步线程我们首先需要有一个清晰的想法
Dialogue: 0,0:04:01.02,0:04:05.20,English,,0,0,0,,Of what we mean by sharing in in threaded C programs
Dialogue: 0,0:04:01.02,0:04:05.20,Chinese,,0,0,0,,通过在线程C程序中共享我们的意思
Dialogue: 0,0:04:06.54,0:04:13.96,English,,0,0,0,,So the answer is not as simple as global variables are shared and stack variables are not shared
Dialogue: 0,0:04:06.54,0:04:13.96,Chinese,,0,0,0,,所以答案并不像共享全局变量那样简单，也不会共享堆栈变量
Dialogue: 0,0:04:18.70,0:04:23.66,English,,0,0,0,,Okay so with instead what we x is shared
Dialogue: 0,0:04:18.70,0:04:23.66,Chinese,,0,0,0,,好的，相反我们共享的是x
Dialogue: 0,0:04:23.66,0:04:28.50,English,,0,0,0,,If only multiple threads reference some instance so that that variable x
Dialogue: 0,0:04:23.66,0:04:28.50,Chinese,,0,0,0,,如果只有多个线程引用某个实例，那么该变量为x
Dialogue: 0,0:04:29.51,0:04:34.00,English,,0,0,0,,All right so if only one thread is accessing a particular variable
Dialogue: 0,0:04:29.51,0:04:34.00,Chinese,,0,0,0,,好吧，如果只有一个线程正在访问特定变量
Dialogue: 0,0:04:35.64,0:04:37.06,English,,0,0,0,,Then it's not shared
Dialogue: 0,0:04:35.64,0:04:37.06,Chinese,,0,0,0,,然后它没有被分享
Dialogue: 0,0:04:38.26,0:04:38.76,English,,0,0,0,,Okay so...
Dialogue: 0,0:04:38.26,0:04:38.76,Chinese,,0,0,0,,可以，然后呢...
Dialogue: 0,0:04:40.32,0:04:45.24,English,,0,0,0,,In order to know exactly what we mean by shared we need to answer three questions
Dialogue: 0,0:04:40.32,0:04:45.24,Chinese,,0,0,0,,为了确切地知道共享的含义，我们需要回答三个问题
Dialogue: 0,0:04:46.00,0:04:48.70,English,,0,0,0,,Okay first what is the memory model for threads
Dialogue: 0,0:04:46.00,0:04:48.70,Chinese,,0,0,0,,好的，首先是线程的内存模型是什么
Dialogue: 0,0:04:50.06,0:04:53.38,English,,0,0,0,,Okay second how are instances of variables mapped to memory
Dialogue: 0,0:04:50.06,0:04:53.38,Chinese,,0,0,0,,好的第二个变量实例如何映射到内存
Dialogue: 0,0:04:55.24,0:05:00.35,English,,0,0,0,,And then third how many threads might be referencing those the instances of those variables
Dialogue: 0,0:04:55.24,0:05:00.35,Chinese,,0,0,0,,然后是第三个线程可能引用那些变量的实例
Dialogue: 0,0:05:00.64,0:05:03.84,English,,0,0,0,,Okay so we'll look at each of those now in turn each of those three questions
Dialogue: 0,0:05:00.64,0:05:03.84,Chinese,,0,0,0,,好的，我们现在依次看看这三个问题中的每个问题
Dialogue: 0,0:05:05.62,0:05:07.48,English,,0,0,0,,Okay so first is that the memory model
Dialogue: 0,0:05:05.62,0:05:07.48,Chinese,,0,0,0,,好吧首先是内存模型
Dialogue: 0,0:05:10.32,0:05:15.23,English,,0,0,0,,The conceptual model is a little bit different from the operational model the way it really works
Dialogue: 0,0:05:10.32,0:05:15.23,Chinese,,0,0,0,,概念模型与实际运作方式略有不同
Dialogue: 0,0:05:15.56,0:05:16.78,English,,0,0,0,,Okay so conceptually
Dialogue: 0,0:05:15.56,0:05:16.78,Chinese,,0,0,0,,好吧，从概念上讲
Dialogue: 0,0:05:17.42,0:05:21.40,English,,0,0,0,,We have multiple threads that run in the context of a single process
Dialogue: 0,0:05:17.42,0:05:21.40,Chinese,,0,0,0,,我们有多个线程在单个进程的上下文中运行
Dialogue: 0,0:05:22.38,0:05:26.90,English,,0,0,0,,Okay and some of that context is shared and some of its not shared
Dialogue: 0,0:05:22.38,0:05:26.90,Chinese,,0,0,0,,好吧，有些上下文是共享的，有些是不共享的
Dialogue: 0,0:05:27.02,0:05:35.30,English,,0,0,0,,So each thread has its own separate thread id,stack,stack pointer,program counter,condition codes,general-purpose registers
Dialogue: 0,0:05:27.02,0:05:35.30,Chinese,,0,0,0,,因此每个线程都有自己独立的线程id，堆栈，堆栈指针，程序计数器，条件代码，通用寄存器
Dialogue: 0,0:05:36.60,0:05:43.78,English,,0,0,0,,And then they all share the remaining process context which is data structures that the kernel maintains
Dialogue: 0,0:05:36.60,0:05:43.78,Chinese,,0,0,0,,然后它们共享剩余的进程上下文，这是内核维护的数据结构
Dialogue: 0,0:05:44.34,0:05:53.74,English,,0,0,0,,For the threads the virtual data structures to support the virtual memory system open files install signal handlers and so forth
Dialogue: 0,0:05:44.34,0:05:53.74,Chinese,,0,0,0,,对于线程，虚拟数据结构支持虚拟内存系统打开文件安装信号处理程序等等
Dialogue: 0,0:05:55.24,0:05:59.24,English,,0,0,0,,So that's the conceptual model and that if that were really enforced
Dialogue: 0,0:05:55.24,0:05:59.24,Chinese,,0,0,0,,这就是概念模型，如果真的得到了强制执行
Dialogue: 0,0:05:59.26,0:06:01.36,English,,0,0,0,,It would be nice it would make things simpler for us
Dialogue: 0,0:05:59.26,0:06:01.36,Chinese,,0,0,0,,它会让我们的事情更简单，这样会很好
Dialogue: 0,0:06:01.42,0:06:05.60,English,,0,0,0,,But unfortunately in real life this model is not strictly enforced
Dialogue: 0,0:06:01.42,0:06:05.60,Chinese,,0,0,0,,但不幸的是，在现实生活中，这种模式并没有严格执行
Dialogue: 0,0:06:07.30,0:06:13.00,English,,0,0,0,,Now although register values are really separate right the kernel maintains separate context for all the registers
Dialogue: 0,0:06:07.30,0:06:13.00,Chinese,,0,0,0,,现在虽然寄存器值实际上是独立的，但内核为所有寄存器维护单独的上下文
Dialogue: 0,0:06:13.02,0:06:14.42,English,,0,0,0,,So that part is good
Dialogue: 0,0:06:13.02,0:06:14.42,Chinese,,0,0,0,,那部分是好的
Dialogue: 0,0:06:15.72,0:06:21.64,English,,0,0,0,,But since the threads share the address space,a thread can access the the memory the stack
Dialogue: 0,0:06:15.72,0:06:21.64,Chinese,,0,0,0,,但由于线程共享地址空间，因此线程可以访问堆栈的内存
Dialogue: 0,0:06:21.90,0:06:24.86,English,,0,0,0,,One thread can access the stack of an another thread
Dialogue: 0,0:06:21.90,0:06:24.86,Chinese,,0,0,0,,一个线程可以访问另一个线程的堆栈
Dialogue: 0,0:06:25.18,0:06:32.76,English,,0,0,0,,Okay so although conceptually these stacks are separate and distinct and in private they're really not
Dialogue: 0,0:06:25.18,0:06:32.76,Chinese,,0,0,0,,好的，所以虽然从概念上讲这些堆栈是分开的和不同的，但在私下它们实际上并非如此
Dialogue: 0,0:06:36.56,0:06:38.18,English,,0,0,0,,And so this can create some problems
Dialogue: 0,0:06:36.56,0:06:38.18,Chinese,,0,0,0,,所以这可能会产生一些问题
Dialogue: 0,0:06:38.18,0:06:42.28,English,,0,0,0,,So here's an example of that we'll come back to later
Dialogue: 0,0:06:38.18,0:06:42.28,Chinese,,0,0,0,,所以这是一个例子，我们将在稍后回来
Dialogue: 0,0:06:42.96,0:06:47.88,English,,0,0,0,,Of how this one thread can access the stack of another thread
Dialogue: 0,0:06:42.96,0:06:47.88,Chinese,,0,0,0,,这个线程如何访问另一个线程的堆栈
Dialogue: 0,0:06:48.54,0:06:51.54,English,,0,0,0,,So here we're defining a global variable called pointer
Dialogue: 0,0:06:48.54,0:06:51.54,Chinese,,0,0,0,,所以这里我们定义一个名为pointer的全局变量
Dialogue: 0,0:06:52.62,0:06:54.10,English,,0,0,0,,Which is a char **
Dialogue: 0,0:06:52.62,0:06:54.10,Chinese,,0,0,0,,哪个是char **
Dialogue: 0,0:06:55.26,0:07:01.62,English,,0,0,0,,And then in the main routine on were declaring a local variable called messages which contains
Dialogue: 0,0:06:55.26,0:07:01.62,Chinese,,0,0,0,,然后在主例程中声明一个名为messages的局部变量包含
Dialogue: 0,0:07:02.32,0:07:05.30,English,,0,0,0,,It's a two element array which contains a couple strings
Dialogue: 0,0:07:02.32,0:07:05.30,Chinese,,0,0,0,,它是一个包含两个字符串的双元素数组
Dialogue: 0,0:07:07.20,0:07:11.18,English,,0,0,0,,Which these will be printed out by the threads that we're going to create
Dialogue: 0,0:07:07.20,0:07:11.18,Chinese,,0,0,0,,哪些将由我们将要创建的线程打印出来
Dialogue: 0,0:07:12.22,0:07:17.28,English,,0,0,0,,And then we assign the global pointer to the address of the array messages
Dialogue: 0,0:07:12.22,0:07:17.28,Chinese,,0,0,0,,然后我们将全局指针分配给数组消息的地址
Dialogue: 0,0:07:17.92,0:07:21.16,English,,0,0,0,,Okay so now pointer points to messages
Dialogue: 0,0:07:17.92,0:07:21.16,Chinese,,0,0,0,,好的，现在指针指向消息
Dialogue: 0,0:07:22.66,0:07:25.56,English,,0,0,0,,And then we create in a loop we create two threads
Dialogue: 0,0:07:22.66,0:07:25.56,Chinese,,0,0,0,,然后我们在循环中创建我们创建两个线程
Dialogue: 0,0:07:27.66,0:07:30.76,English,,0,0,0,,Each of which executes this routine called thread
Dialogue: 0,0:07:27.66,0:07:30.76,Chinese,,0,0,0,,每个执行此例程称为线程
Dialogue: 0,0:07:31.64,0:07:34.24,English,,0,0,0,,And and we're passing an argument
Dialogue: 0,0:07:31.64,0:07:34.24,Chinese,,0,0,0,,而且我们正在通过一个论点
Dialogue: 0,0:07:35.00,0:07:41.94,English,,0,0,0,,So the Pthreads will assign a thread id but in this case we're going to assign our own local thread id
Dialogue: 0,0:07:35.00,0:07:41.94,Chinese,,0,0,0,,因此Pthreads将分配一个线程ID，但在这种情况下，我们将分配我们自己的本地线程ID
Dialogue: 0,0:07:42.16,0:07:43.58,English,,0,0,0,,By passing this loop index
Dialogue: 0,0:07:42.16,0:07:43.58,Chinese,,0,0,0,,通过传递这个循环索引
Dialogue: 0,0:07:44.32,0:07:47.66,English,,0,0,0,,Okay so this is an example we talked about this last time
Dialogue: 0,0:07:44.32,0:07:47.66,Chinese,,0,0,0,,好的，这是我们上次谈到的一个例子
Dialogue: 0,0:07:49.24,0:07:51.76,English,,0,0,0,,It's kind of...it's this is perfectly okay there's no race
Dialogue: 0,0:07:49.24,0:07:51.76,Chinese,,0,0,0,,这有点......这是完全可以的，没有比赛
Dialogue: 0,0:07:52.38,0:07:58.82,English,,0,0,0,,But it's a little weird because we're going to take this index i and cast it to a generic pointer
Dialogue: 0,0:07:52.38,0:07:58.82,Chinese,,0,0,0,,但它有点奇怪，因为我们将采用这个索引并将其转换为通用指针
Dialogue: 0,0:08:03.22,0:08:07.02,English,,0,0,0,,Okay and then after we create these threads then we'll exit the main thread
Dialogue: 0,0:08:03.22,0:08:07.02,Chinese,,0,0,0,,好的，然后在我们创建这些线程之后，我们将退出主线程
Dialogue: 0,0:08:09.44,0:08:17.08,English,,0,0,0,,Now each the thread routine dereferences its argument to get the local the local thread id
Dialogue: 0,0:08:09.44,0:08:17.08,Chinese,,0,0,0,,现在每个线程例程都取消引用它的参数，以获取本地的本地线程id
Dialogue: 0,0:08:17.96,0:08:21.40,English,,0,0,0,,And then it declares a static variable count
Dialogue: 0,0:08:17.96,0:08:21.40,Chinese,,0,0,0,,然后它声明了一个静态变量计数
Dialogue: 0,0:08:21.42,0:08:25.68,English,,0,0,0,,That we're going to use to count how many times this thread routine is called inside of a thread
Dialogue: 0,0:08:21.42,0:08:25.68,Chinese,,0,0,0,,我们将使用它来计算在线程内部调用此线程例程的次数
Dialogue: 0,0:08:27.38,0:08:33.66,English,,0,0,0,,And then it just prints a simple message from identifying that giving the local thread id
Dialogue: 0,0:08:27.38,0:08:33.66,Chinese,,0,0,0,,然后它只是打印一个简单的消息，从识别给出本地线程ID
Dialogue: 0,0:08:35.04,0:08:40.42,English,,0,0,0,,And then the message indexed by myid
Dialogue: 0,0:08:35.04,0:08:40.42,Chinese,,0,0,0,,然后由myid索引的消息
Dialogue: 0,0:08:40.90,0:08:42.90,English,,0,0,0,,So pointer points to messages
Dialogue: 0,0:08:40.90,0:08:42.90,Chinese,,0,0,0,,所以指针指向消息
Dialogue: 0,0:08:43.00,0:08:46.40,English,,0,0,0,,So thread zero will print "hello from foo"
Dialogue: 0,0:08:43.00,0:08:46.40,Chinese,,0,0,0,,所以线程零将打印“hello from foo”
Dialogue: 0,0:08:47.32,0:08:50.44,English,,0,0,0,,And thread 1 will print "hello from bar"
Dialogue: 0,0:08:47.32,0:08:50.44,Chinese,,0,0,0,,并且线程1将打印“hello from bar”
Dialogue: 0,0:08:51.86,0:08:55.92,English,,0,0,0,,And then we increment the pre increment the counter variable
Dialogue: 0,0:08:51.86,0:08:55.92,Chinese,,0,0,0,,然后我们增加计数器变量的预增量
Dialogue: 0,0:08:58.80,0:08:59.46,English,,0,0,0,,Okay so
Dialogue: 0,0:08:58.80,0:08:59.46,Chinese,,0,0,0,,可以，然后呢
Dialogue: 0,0:09:02.36,0:09:07.62,English,,0,0,0,,Although it doesn't you would it looks like we're accessing this global variable pointer
Dialogue: 0,0:09:02.36,0:09:07.62,Chinese,,0,0,0,,虽然它不是你看起来我们正在访问这个全局变量指针
Dialogue: 0,0:09:08.02,0:09:14.46,English,,0,0,0,,But since that was assigned to be the address of the local variable on the main thread stack
Dialogue: 0,0:09:08.02,0:09:14.46,Chinese,,0,0,0,,但是因为那被分配为主线程堆栈上的局部变量的地址
Dialogue: 0,0:09:15.10,0:09:23.26,English,,0,0,0,,We've got this these peer threads accessing local variables on the main thread stack okay
Dialogue: 0,0:09:15.10,0:09:23.26,Chinese,,0,0,0,,我们已经让这些对等线程访问主线程堆栈上的局部变量了
Dialogue: 0,0:09:23.36,0:09:28.22,English,,0,0,0,,So that I just this is not it you never want to do this as a very bad practice
Dialogue: 0,0:09:23.36,0:09:28.22,Chinese,,0,0,0,,所以我只是这不是你从来不想做这个非常糟糕的做法
Dialogue: 0,0:09:28.22,0:09:30.96,English,,0,0,0,,But I...it's a kind of thing that can happen sometimes
Dialogue: 0,0:09:28.22,0:09:30.96,Chinese,,0,0,0,,但是我......有时会发生这种事情
Dialogue: 0,0:09:33.84,0:09:39.28,English,,0,0,0,,By accident you know if you forget that pointer actually was assigned to you know some stack address
Dialogue: 0,0:09:33.84,0:09:39.28,Chinese,,0,0,0,,偶然你知道你是否忘记了指针实际上被分配给你知道一些堆栈地址
Dialogue: 0,0:09:41.08,0:09:46.60,English,,0,0,0,,Okay so the second question that is how do we map variable instances to memory
Dialogue: 0,0:09:41.08,0:09:46.60,Chinese,,0,0,0,,好的第二个问题是我们如何将变量实例映射到内存
Dialogue: 0,0:09:47.10,0:09:50.16,English,,0,0,0,,Now we looked at this when we studied linking
Dialogue: 0,0:09:47.10,0:09:50.16,Chinese,,0,0,0,,现在我们在研究链接时看了这个
Dialogue: 0,0:09:50.16,0:09:54.78,English,,0,0,0,,But let's just review this quickly again to make sure that it's clear to you
Dialogue: 0,0:09:50.16,0:09:54.78,Chinese,,0,0,0,,但是，让我们再次快速回顾一下，以确保你清楚
Dialogue: 0,0:09:56.80,0:10:01.38,English,,0,0,0,,So global variables are variables that are referenced outside of a function
Dialogue: 0,0:09:56.80,0:10:01.38,Chinese,,0,0,0,,因此全局变量是在函数外引用的变量
Dialogue: 0,0:10:03.00,0:10:08.08,English,,0,0,0,,And virtual memory the linker when it does symbol resolution make sure that
Dialogue: 0,0:10:03.00,0:10:08.08,Chinese,,0,0,0,,链接器在进行符号解析时的虚拟内存确保了
Dialogue: 0,0:10:08.08,0:10:12.50,English,,0,0,0,,There's exactly one instance of every global variable in virtual memory
Dialogue: 0,0:10:08.08,0:10:12.50,Chinese,,0,0,0,,虚拟内存中的每个全局变量都只有一个实例
Dialogue: 0,0:10:16.50,0:10:20.14,English,,0,0,0,,Now local variables are declared on the stack inside of a function
Dialogue: 0,0:10:16.50,0:10:20.14,Chinese,,0,0,0,,现在局部变量在函数内部的堆栈上声明
Dialogue: 0,0:10:23.26,0:10:24.94,English,,0,0,0,,Without the static attribute
Dialogue: 0,0:10:23.26,0:10:24.94,Chinese,,0,0,0,,没有静态属性
Dialogue: 0,0:10:26.28,0:10:32.46,English,,0,0,0,,And so in this case each the stack for each thread will contain one instance of that local variable
Dialogue: 0,0:10:26.28,0:10:32.46,Chinese,,0,0,0,,因此，在这种情况下，每个线程的每个堆栈将包含该局部变量的一个实例
Dialogue: 0,0:10:37.60,0:10:37.94,English,,0,0,0,,Now
Dialogue: 0,0:10:37.60,0:10:37.94,Chinese,,0,0,0,,现在
Dialogue: 0,0:10:39.30,0:10:42.70,English,,0,0,0,,If variables are declared inside of a function with the static attribute
Dialogue: 0,0:10:39.30,0:10:42.70,Chinese,,0,0,0,,如果变量是使用static属性在函数内声明的
Dialogue: 0,0:10:44.28,0:10:49.06,English,,0,0,0,,Then the scope of that variable is limited to that function meaning no other function can access it
Dialogue: 0,0:10:44.28,0:10:49.06,Chinese,,0,0,0,,然后该变量的范围仅限于该函数，这意味着没有其他函数可以访问它
Dialogue: 0,0:10:50.56,0:10:55.66,English,,0,0,0,,But that static variable is stored along with all the other local variables
Dialogue: 0,0:10:50.56,0:10:55.66,Chinese,,0,0,0,,但是，该静态变量与所有其他局部变量一起存储
Dialogue: 0,0:10:55.70,0:11:04.14,English,,0,0,0,,So there's any static variable declared inside of a function has exactly one instance in memory
Dialogue: 0,0:10:55.70,0:11:04.14,Chinese,,0,0,0,,因此，在函数内部声明的任何静态变量在内存中只有一个实例
Dialogue: 0,0:11:04.96,0:11:10.66,English,,0,0,0,,And if you were to have say multiple functions that declared (the same) a static variable with the same name
Dialogue: 0,0:11:04.96,0:11:10.66,Chinese,,0,0,0,,如果你要说多个函数声明（相同）一个具有相同名称的静态变量
Dialogue: 0,0:11:11.30,0:11:14.44,English,,0,0,0,,The compiler would disambiguate those somehow
Dialogue: 0,0:11:11.30,0:11:14.44,Chinese,,0,0,0,,编译器会以某种方式消除歧义
Dialogue: 0,0:11:14.44,0:11:17.24,English,,0,0,0,,It would append some kind of unique
Dialogue: 0,0:11:14.44,0:11:17.24,Chinese,,0,0,0,,它会附加某种独特的
Dialogue: 0,0:11:19.10,0:11:20.80,English,,0,0,0,,It would somehow make that name unique
Dialogue: 0,0:11:19.10,0:11:20.80,Chinese,,0,0,0,,它会以某种方式使这个名字独一无二
Dialogue: 0,0:11:24.48,0:11:30.14,English,,0,0,0,,Okay so what recall how all these different types of variable instances are mapped into memory
Dialogue: 0,0:11:24.48,0:11:30.14,Chinese,,0,0,0,,那么回想一下所有这些不同类型的变量实例是如何映射到内存的
Dialogue: 0,0:11:31.86,0:11:35.38,English,,0,0,0,,Okay pointer is a global variable
Dialogue: 0,0:11:31.86,0:11:35.38,Chinese,,0,0,0,,好的指针是一个全局变量
Dialogue: 0,0:11:35.38,0:11:40.16,English,,0,0,0,,So there's one instance of pointer in the address space
Dialogue: 0,0:11:35.38,0:11:40.16,Chinese,,0,0,0,,所以地址空间中有一个指针实例
Dialogue: 0,0:11:42.72,0:11:45.56,English,,0,0,0,,And it's stored in the data segment
Dialogue: 0,0:11:42.72,0:11:45.56,Chinese,,0,0,0,,它存储在数据段中
Dialogue: 0,0:11:50.54,0:11:57.40,English,,0,0,0,,i and messages are examples of local variables to main
Dialogue: 0,0:11:50.54,0:11:57.40,Chinese,,0,0,0,,我和消息是main的局部变量的例子
Dialogue: 0,0:11:58.44,0:12:05.12,English,,0,0,0,,So there's one instance of these stored on the stack of main stack
Dialogue: 0,0:11:58.44,0:12:05.12,Chinese,,0,0,0,,所以这些存储在主堆栈堆栈中的一个实例
Dialogue: 0,0:12:06.22,0:12:12.08,English,,0,0,0,,And we'll denote those with this notation we'll say variable i
Dialogue: 0,0:12:06.22,0:12:12.08,Chinese,,0,0,0,,而且我们会用这种表示法表示我们会说变量i
Dialogue: 0,0:12:12.70,0:12:17.04,English,,0,0,0,,i.m means variable i is stored on main stack
Dialogue: 0,0:12:12.70,0:12:17.04,Chinese,,0,0,0,,i.m表示变量i存储在主堆栈中
Dialogue: 0,0:12:18.32,0:12:20.78,English,,0,0,0,,And messages is stored on the stack of main
Dialogue: 0,0:12:18.32,0:12:20.78,Chinese,,0,0,0,,消息存储在main堆栈中
Dialogue: 0,0:12:23.52,0:12:28.86,English,,0,0,0,,Okay now myid is a local variable defined in this thread routine
Dialogue: 0,0:12:23.52,0:12:28.86,Chinese,,0,0,0,,好的，现在myid是在这个线程例程中定义的局部变量
Dialogue: 0,0:12:30.34,0:12:32.48,English,,0,0,0,,And so there's actually since there's two of these threads
Dialogue: 0,0:12:30.34,0:12:32.48,Chinese,,0,0,0,,实际上，因为有两个这样的线程
Dialogue: 0,0:12:32.74,0:12:39.62,English,,0,0,0,,There's there's now there are in memory there's there's two instances of myid one for each stack
Dialogue: 0,0:12:32.74,0:12:39.62,Chinese,,0,0,0,,现在有内存，每个堆栈都有两个myid实例
Dialogue: 0,0:12:40.54,0:12:43.38,English,,0,0,0,,Okay associated with the stack associated with each thread
Dialogue: 0,0:12:40.54,0:12:43.38,Chinese,,0,0,0,,好的与每个线程关联的堆栈相关联
Dialogue: 0,0:12:45.28,0:12:49.52,English,,0,0,0,,So myid.p0 is stored on peer thread 0's stack
Dialogue: 0,0:12:45.28,0:12:49.52,Chinese,,0,0,0,,所以myid.p0存储在对等线程0的堆栈中
Dialogue: 0,0:12:50.26,0:12:54.64,English,,0,0,0,,And myid.p1 is stored on peer thread 1's stack
Dialogue: 0,0:12:50.26,0:12:54.64,Chinese,,0,0,0,,并且myid.p1存储在对等线程1的堆栈中
Dialogue: 0,0:12:59.20,0:13:07.68,English,,0,0,0,,Ok and now this counter variable the static counter variable has just exactly one instance in virtual memory
Dialogue: 0,0:12:59.20,0:13:07.68,Chinese,,0,0,0,,好了，现在这个计数器变量静态计数器变量只有一个虚拟内存实例
Dialogue: 0,0:13:07.98,0:13:13.02,English,,0,0,0,,And it sits in the data segment along with the other global variables like like pointer
Dialogue: 0,0:13:07.98,0:13:13.02,Chinese,,0,0,0,,它和其他全局变量一样位于数据段中，如指针
Dialogue: 0,0:13:17.34,0:13:18.62,English,,0,0,0,,Okay now so the question is
Dialogue: 0,0:13:17.34,0:13:18.62,Chinese,,0,0,0,,好的，现在问题是
Dialogue: 0,0:13:20.78,0:13:23.24,English,,0,0,0,,Which of these variables are shared and which are not
Dialogue: 0,0:13:20.78,0:13:23.24,Chinese,,0,0,0,,哪些变量是共享的，哪些不是
Dialogue: 0,0:13:25.66,0:13:26.32,English,,0,0,0,,Okay so we can
Dialogue: 0,0:13:25.66,0:13:26.32,Chinese,,0,0,0,,好的，我们可以
Dialogue: 0,0:13:28.50,0:13:36.88,English,,0,0,0,,Remember what we said is it's shared if more than one thread is accessing an instance of that variable
Dialogue: 0,0:13:28.50,0:13:36.88,Chinese,,0,0,0,,记住，如果有多个线程正在访问该变量的实例，我们所说的是共享的
Dialogue: 0,0:13:38.98,0:13:42.82,English,,0,0,0,,Okay so let's just list all the different variables
Dialogue: 0,0:13:38.98,0:13:42.82,Chinese,,0,0,0,,好吧，让我们列出所有不同的变量
Dialogue: 0,0:13:44.20,0:13:48.62,English,,0,0,0,,And then let's look at each of these threads and see if it's referenced by that thread
Dialogue: 0,0:13:44.20,0:13:48.62,Chinese,,0,0,0,,然后让我们看看每个线程，看看它是否被该线程引用
Dialogue: 0,0:13:50.26,0:13:52.66,English,,0,0,0,,Okay so what about,what about pointer
Dialogue: 0,0:13:50.26,0:13:52.66,Chinese,,0,0,0,,好的，那么指针呢
Dialogue: 0,0:13:54.80,0:13:59.45,English,,0,0,0,,Right there's just it's referenced by the main thread right
Dialogue: 0,0:13:54.80,0:13:59.45,Chinese,,0,0,0,,正确的是主线程正确引用它
Dialogue: 0,0:14:00.80,0:14:02.80,English,,0,0,0,,And what about peer threads zero
Dialogue: 0,0:14:00.80,0:14:02.80,Chinese,,0,0,0,,对等线程零如何呢？
Dialogue: 0,0:14:07.38,0:14:10.20,English,,0,0,0,,Yeah it's referenced by peer thread zero right here
Dialogue: 0,0:14:07.38,0:14:10.20,Chinese,,0,0,0,,是的，它在这里由对等线程零引用
Dialogue: 0,0:14:12.88,0:14:14.14,English,,0,0,0,,Right here
Dialogue: 0,0:14:12.88,0:14:14.14,Chinese,,0,0,0,,就在这儿
Dialogue: 0,0:14:15.80,0:14:17.56,English,,0,0,0,,And similarly for peer thread one
Dialogue: 0,0:14:15.80,0:14:17.56,Chinese,,0,0,0,,同样对于同伴线程一
Dialogue: 0,0:14:18.64,0:14:21.72,English,,0,0,0,,Okay so pointer is referenced by all three threads
Dialogue: 0,0:14:18.64,0:14:21.72,Chinese,,0,0,0,,好的，所以三个线程都引用了指针
Dialogue: 0,0:14:25.02,0:14:25.90,English,,0,0,0,,Now what about count
Dialogue: 0,0:14:25.02,0:14:25.90,Chinese,,0,0,0,,那怎么算数
Dialogue: 0,0:14:29.32,0:14:31.78,English,,0,0,0,,Counts not referenced by the main thread
Dialogue: 0,0:14:29.32,0:14:31.78,Chinese,,0,0,0,,计数未被主线程引用
Dialogue: 0,0:14:32.96,0:14:36.00,English,,0,0,0,,But it is referenced by the two peer threads
Dialogue: 0,0:14:32.96,0:14:36.00,Chinese,,0,0,0,,但它由两个对等线程引用
Dialogue: 0,0:14:38.44,0:14:40.16,English,,0,0,0,,Now what about i in main
Dialogue: 0,0:14:38.44,0:14:40.16,Chinese,,0,0,0,,那我在主要的是什么呢
Dialogue: 0,0:14:42.62,0:14:44.28,English,,0,0,0,,That's referenced by main of course
Dialogue: 0,0:14:42.62,0:14:44.28,Chinese,,0,0,0,,那当然是主要参考
Dialogue: 0,0:14:44.30,0:14:49.04,English,,0,0,0,,But not by but not by either of the two threads
Dialogue: 0,0:14:44.30,0:14:49.04,Chinese,,0,0,0,,但不是两个线程中的任何一个，而是两个线程之一
Dialogue: 0,0:14:50.74,0:14:52.84,English,,0,0,0,,Now we're about messages, the messages array
Dialogue: 0,0:14:50.74,0:14:52.84,Chinese,,0,0,0,,现在我们关于消息，消息数组
Dialogue: 0,0:14:54.62,0:14:57.92,English,,0,0,0,,Okay so that's accessed by main
Dialogue: 0,0:14:54.62,0:14:57.92,Chinese,,0,0,0,,好的，所以这是由主访问
Dialogue: 0,0:14:58.74,0:15:00.92,English,,0,0,0,,And indirectly through pointer
Dialogue: 0,0:14:58.74,0:15:00.92,Chinese,,0,0,0,,并间接通过指针
Dialogue: 0,0:15:01.52,0:15:05.56,English,,0,0,0,,It's referenced by each of these two peer threads
Dialogue: 0,0:15:01.52,0:15:05.56,Chinese,,0,0,0,,它由这两个对等线程中的每一个引用
Dialogue: 0,0:15:07.66,0:15:12.24,English,,0,0,0,,Now what about myid defined in peer thread zero
Dialogue: 0,0:15:07.66,0:15:12.24,Chinese,,0,0,0,,那么在对等线程零中定义的myid怎么样呢
Dialogue: 0,0:15:14.20,0:15:16.54,English,,0,0,0,,Okay so that's referenced that's a local variable
Dialogue: 0,0:15:14.20,0:15:16.54,Chinese,,0,0,0,,好的，所以引用它是一个局部变量
Dialogue: 0,0:15:16.54,0:15:21.06,English,,0,0,0,,So it's only referenced by peer thread zero right it's not referenced by either the other threads
Dialogue: 0,0:15:16.54,0:15:21.06,Chinese,,0,0,0,,所以它只被对等线程零引用，它没有被其他线程引用
Dialogue: 0,0:15:21.08,0:15:29.00,English,,0,0,0,,And similarly for myid and in peer threat one
Dialogue: 0,0:15:21.08,0:15:29.00,Chinese,,0,0,0,,同样适用于myid和同伴威胁之一
Dialogue: 0,0:15:33.12,0:15:36.32,English,,0,0,0,,Okay so given that definition then
Dialogue: 0,0:15:33.12,0:15:36.32,Chinese,,0,0,0,,那么鉴于那个定义呢
Dialogue: 0,0:15:37.60,0:15:39.90,English,,0,0,0,,Which of these variables is shared
Dialogue: 0,0:15:37.60,0:15:39.90,Chinese,,0,0,0,,这些变量中的哪一个是共享的
Dialogue: 0,0:15:42.28,0:15:44.74,English,,0,0,0,,So it's really straightforward with yeah
Dialogue: 0,0:15:42.28,0:15:44.74,Chinese,,0,0,0,,是的，这真的很直白
Dialogue: 0,0:15:50.56,0:15:55.88,English,,0,0,0,,Okay so the question is discount count as a share variable and answer is yes
Dialogue: 0,0:15:50.56,0:15:55.88,Chinese,,0,0,0,,好吧，问题是折扣计数作为一个共享变量，答案是肯定的
Dialogue: 0,0:15:56.70,0:15:59.10,English,,0,0,0,,Because it's declared static
Dialogue: 0,0:15:56.70,0:15:59.10,Chinese,,0,0,0,,因为它被宣布为静态的
Dialogue: 0,0:15:59.86,0:16:03.66,English,,0,0,0,,It's there's one instance of it in virtual memory
Dialogue: 0,0:15:59.86,0:16:03.66,Chinese,,0,0,0,,它是虚拟内存中的一个实例
Dialogue: 0,0:16:04.94,0:16:08.82,English,,0,0,0,,And each of the threads references that instance
Dialogue: 0,0:16:04.94,0:16:08.82,Chinese,,0,0,0,,每个线程都引用该实例
Dialogue: 0,0:16:09.40,0:16:13.12,English,,0,0,0,,Okay so it's shared,it's really like a global variable
Dialogue: 0,0:16:09.40,0:16:13.12,Chinese,,0,0,0,,好的，所以它是共享的，它真的像一个全局变量
Dialogue: 0,0:16:13.76,0:16:16.86,English,,0,0,0,,It's just a scope is limited to the...
Dialogue: 0,0:16:13.76,0:16:16.86,Chinese,,0,0,0,,这只是一个范围仅限于......
Dialogue: 0,0:16:18.30,0:16:22.98,English,,0,0,0,,It stored the same way a global variable is but its scope is limited to the function that it's defined in
Dialogue: 0,0:16:18.30,0:16:22.98,Chinese,,0,0,0,,它以与全局变量相同的方式存储，但其范围仅限于其定义的函数
Dialogue: 0,0:16:24.48,0:16:27.26,English,,0,0,0,,Okay so to determine if each one of these is whether
Dialogue: 0,0:16:24.48,0:16:27.26,Chinese,,0,0,0,,好的，以确定这些中的每一个是否是
Dialogue: 0,0:16:27.48,0:16:30.14,English,,0,0,0,,Which of these variables are shared in which one's not we just
Dialogue: 0,0:16:27.48,0:16:30.14,Chinese,,0,0,0,,这些变量中的哪一个是共享的，哪一个不是我们的
Dialogue: 0,0:16:30.66,0:16:39.00,English,,0,0,0,,We just look go across and for any variable with its shared by more than,more than one thread then it's shared
Dialogue: 0,0:16:30.66,0:16:39.00,Chinese,,0,0,0,,我们只是看看并且对于任何变量，它由多个，多个线程共享，然后它被共享
Dialogue: 0,0:16:39.68,0:16:40.78,English,,0,0,0,,So pointer shared
Dialogue: 0,0:16:39.68,0:16:40.78,Chinese,,0,0,0,,所以指针共享
Dialogue: 0,0:16:44.98,0:16:48.38,English,,0,0,0,,So pointer is shared count is not shared
Dialogue: 0,0:16:44.98,0:16:48.38,Chinese,,0,0,0,,所以指针是共享计数不共享
Dialogue: 0,0:16:50.92,0:16:56.10,English,,0,0,0,,Oh no count is shared because it's it's referenced by peer thread zero and peer thread one
Dialogue: 0,0:16:50.92,0:16:56.10,Chinese,,0,0,0,,哦，没有共享计数，因为它是由对等线程零和对等线程1引用的
Dialogue: 0,0:16:58.42,0:17:01.62,English,,0,0,0,,I's not shared because it's only referenced by main
Dialogue: 0,0:16:58.42,0:17:01.62,Chinese,,0,0,0,,我没有分享，因为它仅由main引用
Dialogue: 0,0:17:02.98,0:17:03.38,English,,0,0,0,,So
Dialogue: 0,0:17:02.98,0:17:03.38,Chinese,,0,0,0,,所以
Dialogue: 0,0:17:07.94,0:17:11.76,English,,0,0,0,,Messages is access referenced by all three threads so it's shared
Dialogue: 0,0:17:07.94,0:17:11.76,Chinese,,0,0,0,,消息是由所有三个线程引用的访问，因此它是共享的
Dialogue: 0,0:17:12.78,0:17:18.60,English,,0,0,0,,But myid is not shared because it's only referenced by exactly one thread
Dialogue: 0,0:17:12.78,0:17:18.60,Chinese,,0,0,0,,但myid没有共享，因为它只由一个线程引用
Dialogue: 0,0:17:19.02,0:17:28.22,English,,0,0,0,,Okay so pointer count and messages are the shared variables in this program and the others are run share
Dialogue: 0,0:17:19.02,0:17:28.22,Chinese,,0,0,0,,好的，所以指针计数和消息是这个程序中的共享变量，其他的是运行共享
Dialogue: 0,0:17:28.66,0:17:28.86,English,,0,0,0,,Yes
Dialogue: 0,0:17:28.66,0:17:28.86,Chinese,,0,0,0,,是
Dialogue: 0,0:17:29.32,0:17:35.74,English,,0,0,0,,[student speaking]
Dialogue: 0,0:17:35.74,0:17:37.86,English,,0,0,0,,So declared my ideas static
Dialogue: 0,0:17:35.74,0:17:37.86,Chinese,,0,0,0,,所以我的想法是静态的
Dialogue: 0,0:17:38.82,0:17:41.92,English,,0,0,0,,With the second process of overridden it yeah that would be a race
Dialogue: 0,0:17:38.82,0:17:41.92,Chinese,,0,0,0,,第二个被覆盖的过程是的，那将是一场比赛
Dialogue: 0,0:17:43.44,0:17:47.44,English,,0,0,0,,Okay so that would...we just depend on which thread executed first
Dialogue: 0,0:17:43.44,0:17:47.44,Chinese,,0,0,0,,好的，那样......我们只依赖于首先执行的线程
Dialogue: 0,0:17:48.16,0:17:50.32,English,,0,0,0,,So you would really wouldn't want to do that
Dialogue: 0,0:17:48.16,0:17:50.32,Chinese,,0,0,0,,所以你真的不想那样做
Dialogue: 0,0:17:55.38,0:18:00.26,English,,0,0,0,,Okay so we have a very clear notion now of what we mean by sharing
Dialogue: 0,0:17:55.38,0:18:00.26,Chinese,,0,0,0,,好的，我们现在对共享意味着一个非常明确的概念
Dialogue: 0,0:18:08.32,0:18:12.64,English,,0,0,0,,So these being able to share variables like this in this ways is very handy
Dialogue: 0,0:18:08.32,0:18:12.64,Chinese,,0,0,0,,因此，能够以这种方式共享这样的变量是非常方便的
Dialogue: 0,0:18:14.12,0:18:16.54,English,,0,0,0,,But you can run into some really nasty problems
Dialogue: 0,0:18:14.12,0:18:16.54,Chinese,,0,0,0,,但是你可能遇到一些非常讨厌的问题
Dialogue: 0,0:18:17.76,0:18:20.88,English,,0,0,0,,That are very surprising,so let me show you an example
Dialogue: 0,0:18:17.76,0:18:20.88,Chinese,,0,0,0,,这是非常令人惊讶的，所以让我给你举个例子
Dialogue: 0,0:18:23.28,0:18:24.34,English,,0,0,0,,This is a program
Dialogue: 0,0:18:23.28,0:18:24.34,Chinese,,0,0,0,,这是一个程序
Dialogue: 0,0:18:25.72,0:18:29.72,English,,0,0,0,,Called bad count so obviously there's something wrong with this I'm giving you a little clue
Dialogue: 0,0:18:25.72,0:18:29.72,Chinese,,0,0,0,,被称为坏计数所以显然这有什么问题我给你一点线索
Dialogue: 0,0:18:31.28,0:18:39.58,English,,0,0,0,,But what we want to do is we want to create a bunch of threads or a number of threads
Dialogue: 0,0:18:31.28,0:18:39.58,Chinese,,0,0,0,,但我们想要做的是创建一堆线程或多个线程
Dialogue: 0,0:18:40.46,0:18:44.18,English,,0,0,0,,And each of those threads will increment a global variable called count
Dialogue: 0,0:18:40.46,0:18:44.18,Chinese,,0,0,0,,每个线程都会增加一个名为count的全局变量
Dialogue: 0,0:18:45.00,0:18:47.04,English,,0,0,0,,Some number of times the same number of times
Dialogue: 0,0:18:45.00,0:18:47.04,Chinese,,0,0,0,,有些次数相同的次数
Dialogue: 0,0:18:49.26,0:18:55.02,English,,0,0,0,,Okay so we pass in the number of iterations as the first argument
Dialogue: 0,0:18:49.26,0:18:55.02,Chinese,,0,0,0,,好的，我们将迭代次数作为第一个参数传递
Dialogue: 0,0:18:56.16,0:18:59.54,English,,0,0,0,,And here's our well here's our global globally shared variable
Dialogue: 0,0:18:56.16,0:18:59.54,Chinese,,0,0,0,,以下是我们的全球共享变量
Dialogue: 0,0:19:02.02,0:19:03.84,English,,0,0,0,,And you remember what volatile means
Dialogue: 0,0:19:02.02,0:19:03.84,Chinese,,0,0,0,,而且你还记得挥发性的意思
Dialogue: 0,0:19:04.92,0:19:06.10,English,,0,0,0,,Everybody remember what that means
Dialogue: 0,0:19:04.92,0:19:06.10,Chinese,,0,0,0,,每个人都记得这意味着什么
Dialogue: 0,0:19:07.68,0:19:10.30,English,,0,0,0,,So what is volatile,what is volatile tell the compiler
Dialogue: 0,0:19:07.68,0:19:10.30,Chinese,,0,0,0,,什么是volatile，什么是volatile告诉编译器
Dialogue: 0,0:19:10.98,0:19:11.48,English,,0,0,0,,Yes
Dialogue: 0,0:19:10.98,0:19:11.48,Chinese,,0,0,0,,是
Dialogue: 0,0:19:11.60,0:19:22.66,English,,0,0,0,,[student speaking]
Dialogue: 0,0:19:24.72,0:19:32.92,English,,0,0,0,,It actually you're on in the right direction actually tells,it tells the compiler never to put that variable in a register
Dialogue: 0,0:19:24.72,0:19:32.92,Chinese,,0,0,0,,它实际上是你正确的方向，它告诉编译器永远不要把该变量放在寄存器中
Dialogue: 0,0:19:33.72,0:19:38.96,English,,0,0,0,,Okay so it always read that value from memory or store it to memory and
Dialogue: 0,0:19:33.72,0:19:38.96,Chinese,,0,0,0,,好的，所以它总是从内存中读取该值或将其存储到内存中
Dialogue: 0,0:19:39.54,0:19:44.64,English,,0,0,0,,You do that because of exactly the kind of possibility that you mentioned
Dialogue: 0,0:19:39.54,0:19:44.64,Chinese,,0,0,0,,你这样做是因为你提到的那种可能性
Dialogue: 0,0:19:46.90,0:19:50.60,English,,0,0,0,,So in this case we have
Dialogue: 0,0:19:46.90,0:19:50.60,Chinese,,0,0,0,,所以在这种情况下我们有
Dialogue: 0,0:19:50.98,0:19:55.88,English,,0,0,0,,We create two threads by with two distinct calls to two pthread create
Dialogue: 0,0:19:50.98,0:19:55.88,Chinese,,0,0,0,,我们通过对两个pthread_create的两个不同调用来创建两个线程
Dialogue: 0,0:19:57.42,0:20:02.76,English,,0,0,0,,Each of these threads will run the the thread routine called thread
Dialogue: 0,0:19:57.42,0:20:02.76,Chinese,,0,0,0,,每个线程都将运行名为thread的线程例程
Dialogue: 0,0:20:03.36,0:20:08.50,English,,0,0,0,,And it will pass and as an argument the address of the number of iterations that it should
Dialogue: 0,0:20:03.36,0:20:08.50,Chinese,,0,0,0,,并且它将作为参数传递它应该的迭代次数的地址
Dialogue: 0,0:20:09.34,0:20:10.18,English,,0,0,0,,That it should iterate
Dialogue: 0,0:20:09.34,0:20:10.18,Chinese,,0,0,0,,它应该迭代
Dialogue: 0,0:20:11.66,0:20:15.56,English,,0,0,0,,Now you remember when we were looking when we were passing connected file descriptors
Dialogue: 0,0:20:11.66,0:20:15.56,Chinese,,0,0,0,,现在你还记得当我们传递连接文件描述符的时候
Dialogue: 0,0:20:16.76,0:20:18.70,English,,0,0,0,,If we pass an address that was a race
Dialogue: 0,0:20:16.76,0:20:18.70,Chinese,,0,0,0,,如果我们传递的是一个种族的地址
Dialogue: 0,0:20:20.10,0:20:22.86,English,,0,0,0,,Okay but in this case there's no race this is fine
Dialogue: 0,0:20:20.10,0:20:22.86,Chinese,,0,0,0,,好的但是在这种情况下没有比赛这没关系
Dialogue: 0,0:20:22.86,0:20:25.88,English,,0,0,0,,It's fine just to pass the address of number of iterations
Dialogue: 0,0:20:22.86,0:20:25.88,Chinese,,0,0,0,,只传递迭代次数的地址就好了
Dialogue: 0,0:20:26.46,0:20:32.52,English,,0,0,0,,So why is it okay in this case but it wasn't okay when we were passing the connected file descriptor
Dialogue: 0,0:20:26.46,0:20:32.52,Chinese,,0,0,0,,那么为什么在这种情况下它没问题，但是当我们传递连接文件描述符时它并不合适
Dialogue: 0,0:20:32.88,0:20:35.28,English,,0,0,0,,That we got from acceptant to our thread routine
Dialogue: 0,0:20:32.88,0:20:35.28,Chinese,,0,0,0,,我们从接受到我们的线程例程
Dialogue: 0,0:20:49.06,0:20:51.98,English,,0,0,0,,Yes
Dialogue: 0,0:20:49.06,0:20:51.98,Chinese,,0,0,0,,是
Dialogue: 0,0:20:52.00,0:20:54.40,English,,0,0,0,,Exactly because the thread doesn't modify the value
Dialogue: 0,0:20:52.00,0:20:54.40,Chinese,,0,0,0,,正是因为线程没有修改该值
Dialogue: 0,0:20:54.60,0:21:01.82,English,,0,0,0,,And that the problem we had before was that our main thread was modifying that connected descriptor on the next call to accept
Dialogue: 0,0:20:54.60,0:21:01.82,Chinese,,0,0,0,,我们之前遇到的问题是我们的主要线程是在下一次调用accept时修改连接的描述符
Dialogue: 0,0:21:02.56,0:21:04.76,English,,0,0,0,,But here it's just a read-only variable so we're okay
Dialogue: 0,0:21:02.56,0:21:04.76,Chinese,,0,0,0,,但这里它只是一个只读变量，所以我们没事
Dialogue: 0,0:21:06.58,0:21:08.90,English,,0,0,0,,But you see the how tricky the reasoning can get right there's
Dialogue: 0,0:21:06.58,0:21:08.90,Chinese,,0,0,0,,但是你看到推理能够得到的有多么棘手
Dialogue: 0,0:21:09.46,0:21:13.78,English,,0,0,0,,You can't do pattern matching to determine whether you've got races or not races
Dialogue: 0,0:21:09.46,0:21:13.78,Chinese,,0,0,0,,你无法进​​行模式匹配来确定你是否参加过比赛
Dialogue: 0,0:21:14.40,0:21:16.02,English,,0,0,0,,Right so you can't just say well
Dialogue: 0,0:21:14.40,0:21:16.02,Chinese,,0,0,0,,对，所以你不能只说好
Dialogue: 0,0:21:16.52,0:21:23.24,English,,0,0,0,,It's always bad to pass the address of some variable to a thread routine
Dialogue: 0,0:21:16.52,0:21:23.24,Chinese,,0,0,0,,将某个变量的地址传递给线程例程总是不好的
Dialogue: 0,0:21:23.78,0:21:25.72,English,,0,0,0,,Okay because it's not it just depends on the context
Dialogue: 0,0:21:23.78,0:21:25.72,Chinese,,0,0,0,,好的，因为它不仅仅取决于上下文
Dialogue: 0,0:21:27.37,0:21:31.40,English,,0,0,0,,Okay so in this case we're passing the number of iterations and to each thread and
Dialogue: 0,0:21:27.37,0:21:31.40,Chinese,,0,0,0,,好的，在这种情况下，我们将迭代次数传递给每个线程和
Dialogue: 0,0:21:33.52,0:21:36.88,English,,0,0,0,,Then we're waiting for each of those threads to finish
Dialogue: 0,0:21:33.52,0:21:36.88,Chinese,,0,0,0,,然后我们等待每个线程完成
Dialogue: 0,0:21:36.90,0:21:43.26,English,,0,0,0,,So this is an example of why you need why you might want to have a non detached thread
Dialogue: 0,0:21:36.90,0:21:43.26,Chinese,,0,0,0,,所以这是一个为什么你需要为什么你想要一个非分离线程的例子
Dialogue: 0,0:21:43.30,0:21:43.98,English,,0,0,0,,Because you can't
Dialogue: 0,0:21:43.30,0:21:43.98,Chinese,,0,0,0,,因为你做不到
Dialogue: 0,0:21:46.62,0:21:50.16,English,,0,0,0,,We want when we check when we check the value of count
Dialogue: 0,0:21:46.62,0:21:50.16,Chinese,,0,0,0,,在检查计数值的时候检查的时候想要
Dialogue: 0,0:21:50.16,0:21:54.18,English,,0,0,0,,We have to make sure that every thread is finished before we check whether we got the right value or not
Dialogue: 0,0:21:50.16,0:21:54.18,Chinese,,0,0,0,,在检查我们是否得到正确的值之前，我们必须确保每个线程都已完成
Dialogue: 0,0:21:55.28,0:21:56.96,English,,0,0,0,,Okay so we wait for each thread to finish
Dialogue: 0,0:21:55.28,0:21:56.96,Chinese,,0,0,0,,好的，我们等待每个线程完成
Dialogue: 0,0:21:58.00,0:22:03.10,English,,0,0,0,,And now since we've created two threads each of which is incrementing count editors time
Dialogue: 0,0:21:58.00,0:22:03.10,Chinese,,0,0,0,,现在，因为我们已经创建了两个线程，每个线程都会增加计数编辑器的时间
Dialogue: 0,0:22:04.10,0:22:07.06,English,,0,0,0,,We expect count to be equal to two times and niters
Dialogue: 0,0:22:04.10,0:22:07.06,Chinese,,0,0,0,,我们期望计数等于两倍和niters
Dialogue: 0,0:22:07.06,0:22:10.44,English,,0,0,0,,And if it's not we print my favorite error message
Dialogue: 0,0:22:07.06,0:22:10.44,Chinese,,0,0,0,,如果不是，我们打印我最喜欢的错误消息
Dialogue: 0,0:22:11.90,0:22:19.04,English,,0,0,0,,Otherwise we with the value of count,otherwise we print OK also with the value of count
Dialogue: 0,0:22:11.90,0:22:19.04,Chinese,,0,0,0,,否则我们使用count的值，否则我们也会使用count的值打印OK
Dialogue: 0,0:22:20.68,0:22:22.64,English,,0,0,0,,Okay so now what's going on in the thread routine
Dialogue: 0,0:22:20.68,0:22:22.64,Chinese,,0,0,0,,好的，现在线程例程中发生了什么
Dialogue: 0,0:22:23.78,0:22:24.54,English,,0,0,0,,Very simple
Dialogue: 0,0:22:23.78,0:22:24.54,Chinese,,0,0,0,,很简单
Dialogue: 0,0:22:26.32,0:22:33.46,English,,0,0,0,,It dereferences the argument that was passed in and stores it in the local copy of entities
Dialogue: 0,0:22:26.32,0:22:33.46,Chinese,,0,0,0,,它取消引用传入的参数并将其存储在实体的本地副本中
Dialogue: 0,0:22:34.84,0:22:36.44,English,,0,0,0,,And then it loop senators time
Dialogue: 0,0:22:34.84,0:22:36.44,Chinese,,0,0,0,,然后循环参议员的时间
Dialogue: 0,0:22:37.42,0:22:39.04,English,,0,0,0,,In can increments count each time
Dialogue: 0,0:22:37.42,0:22:39.04,Chinese,,0,0,0,,每次都可以增加计数
Dialogue: 0,0:22:40.20,0:22:41.22,English,,0,0,0,,So and then returns
Dialogue: 0,0:22:40.20,0:22:41.22,Chinese,,0,0,0,,所以然后返回
Dialogue: 0,0:22:42.38,0:22:45.32,English,,0,0,0,,So this is very innocuous what could go wrong
Dialogue: 0,0:22:42.38,0:22:45.32,Chinese,,0,0,0,,所以这是非常无害的，可能会出错
Dialogue: 0,0:22:47.64,0:22:53.22,English,,0,0,0,,And since this is threading,since this is concurrent concurrent programming,especially since it's threaded programming
Dialogue: 0,0:22:47.64,0:22:53.22,Chinese,,0,0,0,,因为这是线程，因为这是并发并发编程，特别是因为它是线程编程
Dialogue: 0,0:22:53.56,0:22:56.98,English,,0,0,0,,What there's the odd lots of subtle things can go wrong
Dialogue: 0,0:22:53.56,0:22:56.98,Chinese,,0,0,0,,什么是奇怪的微妙的事情可能会出错
Dialogue: 0,0:22:56.98,0:23:00.30,English,,0,0,0,,So it turns out this program has a really serious bug
Dialogue: 0,0:22:56.98,0:23:00.30,Chinese,,0,0,0,,事实证明这个程序有一个非常严重的错误
Dialogue: 0,0:23:01.52,0:23:03.48,English,,0,0,0,,Okay because when we run it
Dialogue: 0,0:23:01.52,0:23:03.48,Chinese,,0,0,0,,好的，因为当我们运行它
Dialogue: 0,0:23:06.24,0:23:08.40,English,,0,0,0,,When we run it on a Linux box
Dialogue: 0,0:23:06.24,0:23:08.40,Chinese,,0,0,0,,当我们在Linux机器上运行它时
Dialogue: 0,0:23:08.96,0:23:12.80,English,,0,0,0,,Sometimes if we call it with an argument of ten thousand
Dialogue: 0,0:23:08.96,0:23:12.80,Chinese,,0,0,0,,有时如果我们用一万个参数来称呼它
Dialogue: 0,0:23:13.40,0:23:17.90,English,,0,0,0,,Sometimes we get the correct answer 2*10,000 or 20,000
Dialogue: 0,0:23:13.40,0:23:17.90,Chinese,,0,0,0,,有时我们得到2 * 10,000或20,000的正确答案
Dialogue: 0,0:23:18.54,0:23:19.66,English,,0,0,0,,But then the next time we run it
Dialogue: 0,0:23:18.54,0:23:19.66,Chinese,,0,0,0,,但是下次我们运行它
Dialogue: 0,0:23:20.36,0:23:23.76,English,,0,0,0,,We get some weird number 13051
Dialogue: 0,0:23:20.36,0:23:23.76,Chinese,,0,0,0,,我们得到一些奇怪的数字13051
Dialogue: 0,0:23:25.18,0:23:25.94,English,,0,0,0,,Completely wrong
Dialogue: 0,0:23:25.18,0:23:25.94,Chinese,,0,0,0,,完全错了
Dialogue: 0,0:23:27.28,0:23:30.18,English,,0,0,0,,And so what the hack is going on here
Dialogue: 0,0:23:27.28,0:23:30.18,Chinese,,0,0,0,,那么黑客在这里发生了什么
Dialogue: 0,0:23:32.74,0:23:35.90,English,,0,0,0,,Okay so to understand that we have to look at the assembly language
Dialogue: 0,0:23:32.74,0:23:35.90,Chinese,,0,0,0,,好的，要理解我们必须查看汇编语言
Dialogue: 0,0:23:37.60,0:23:39.64,English,,0,0,0,,For this counter loop so that
Dialogue: 0,0:23:37.60,0:23:39.64,Chinese,,0,0,0,,对于这个计数器循环这样
Dialogue: 0,0:23:41.06,0:23:45.94,English,,0,0,0,,We want to...we need to look at the the assembly language for this counter loop in the thread routine
Dialogue: 0,0:23:41.06,0:23:45.94,Chinese,,0,0,0,,我们想...我们需要在线程例程中查看此计数器循环的汇编语言
Dialogue: 0,0:23:48.22,0:23:50.34,English,,0,0,0,,So we'll break it up into three chunks that
Dialogue: 0,0:23:48.22,0:23:50.34,Chinese,,0,0,0,,所以我们将它分成三个块
Dialogue: 0,0:23:51.12,0:23:53.90,English,,0,0,0,,The first chunk is sort of getting ready for the loop
Dialogue: 0,0:23:51.12,0:23:53.90,Chinese,,0,0,0,,第一个块有点为循环做好准备
Dialogue: 0,0:23:54.26,0:24:01.60,English,,0,0,0,,We'll call that the head and we'll denote it as H(i)  for thread i
Dialogue: 0,0:23:54.26,0:24:01.60,Chinese,,0,0,0,,我们称之为头部，我们将其称为线程i的H（i）
Dialogue: 0,0:24:04.94,0:24:12.84,English,,0,0,0,,And then we'll isolate on these three instructions that are directly related to incrementing count
Dialogue: 0,0:24:04.94,0:24:12.84,Chinese,,0,0,0,,然后我们将隔离这三个与递增计数直接相关的指令
Dialogue: 0,0:24:14.08,0:24:16.22,English,,0,0,0,,Okay so you see the first instruction moves
Dialogue: 0,0:24:14.08,0:24:16.22,Chinese,,0,0,0,,好的，所以你看到第一条指令移动了
Dialogue: 0,0:24:16.66,0:24:22.50,English,,0,0,0,,It loads the global of the value and global variable count into register %rdx
Dialogue: 0,0:24:16.66,0:24:22.50,Chinese,,0,0,0,,它将值的全局值和全局变量计数加载到寄存器％rdx中
Dialogue: 0,0:24:24.14,0:24:25.72,English,,0,0,0,,So will denote that as L(i)
Dialogue: 0,0:24:24.14,0:24:25.72,Chinese,,0,0,0,,所以将表示为L（i）
Dialogue: 0,0:24:27.54,0:24:30.18,English,,0,0,0,,Next it increments %rdx
Dialogue: 0,0:24:27.54,0:24:30.18,Chinese,,0,0,0,,接下来它增加％rdx
Dialogue: 0,0:24:31.52,0:24:35.98,English,,0,0,0,,And we'll denote that U(i) for update so it updates %rdx
Dialogue: 0,0:24:31.52,0:24:35.98,Chinese,,0,0,0,,我们将表示U（i）进行更新，以便更新％rdx
Dialogue: 0,0:24:37.14,0:24:42.92,English,,0,0,0,,And then it stores the value the updated value of %rdx into count
Dialogue: 0,0:24:37.14,0:24:42.92,Chinese,,0,0,0,,然后它将％rdx的更新值存储到count中
Dialogue: 0,0:24:43.42,0:24:48.06,English,,0,0,0,,Okay so into the location associated with the global variable count
Dialogue: 0,0:24:43.42,0:24:48.06,Chinese,,0,0,0,,好的，进入与全局变量计数相关的位置
Dialogue: 0,0:24:50.00,0:24:50.44,English,,0,0,0,,And
Dialogue: 0,0:24:50.00,0:24:50.44,Chinese,,0,0,0,,和
Dialogue: 0,0:24:53.32,0:24:58.94,English,,0,0,0,,And then the rest of...the rest of this loop is getting ready for the to do the next iteration
Dialogue: 0,0:24:53.32,0:24:58.94,Chinese,,0,0,0,,然后剩下的......这个循环的其余部分已准备好进行下一次迭代
Dialogue: 0,0:24:59.70,0:25:02.32,English,,0,0,0,,It's not directly related to incrementing count
Dialogue: 0,0:24:59.70,0:25:02.32,Chinese,,0,0,0,,它与递增计数没有直接关系
Dialogue: 0,0:25:02.32,0:25:06.38,English,,0,0,0,,So we'll just sort of group this all together and refer to it as T(i) for tail
Dialogue: 0,0:25:02.32,0:25:06.38,Chinese,,0,0,0,,所以我们只是将这一切组合在一起并将其称为尾部的T（i）
Dialogue: 0,0:25:07.68,0:25:07.86,English,,0,0,0,,Okay
Dialogue: 0,0:25:07.68,0:25:07.86,Chinese,,0,0,0,,好的
Dialogue: 0,0:25:13.60,0:25:17.56,English,,0,0,0,,Now let's look at...let's look at...
Dialogue: 0,0:25:13.60,0:25:17.56,Chinese,,0,0,0,,现在让我们来看看......让我们来看......
Dialogue: 0,0:25:18.22,0:25:21.94,English,,0,0,0,,How this how these two threads might be executed
Dialogue: 0,0:25:18.22,0:25:21.94,Chinese,,0,0,0,,如何执行这两个线程的方式
Dialogue: 0,0:25:22.12,0:25:27.38,English,,0,0,0,,And remember in general we can't assume that there's any specific interleaving
Dialogue: 0,0:25:22.12,0:25:27.38,Chinese,,0,0,0,,记住，一般来说，我们不能假设有任何特定的交错
Dialogue: 0,0:25:27.40,0:25:30.08,English,,0,0,0,,So any interleaving of these two threads is possible
Dialogue: 0,0:25:27.40,0:25:30.08,Chinese,,0,0,0,,因此，这两个线程的任何交错都是可能的
Dialogue: 0,0:25:30.18,0:25:33.32,English,,0,0,0,,No matter how remote it might seem
Dialogue: 0,0:25:30.18,0:25:33.32,Chinese,,0,0,0,,无论它看起来多么遥远
Dialogue: 0,0:25:34.90,0:25:38.80,English,,0,0,0,,So let's look at one example let's say we're executing on a single core
Dialogue: 0,0:25:34.90,0:25:38.80,Chinese,,0,0,0,,让我们看一个例子，假设我们在一个核心上执行
Dialogue: 0,0:25:38.80,0:25:40.98,English,,0,0,0,,So we're only going to do one instruction at a time
Dialogue: 0,0:25:38.80,0:25:40.98,Chinese,,0,0,0,,所以我们一次只会做一个指令
Dialogue: 0,0:25:43.00,0:25:43.54,English,,0,0,0,,And
Dialogue: 0,0:25:43.00,0:25:43.54,Chinese,,0,0,0,,和
Dialogue: 0,0:25:45.84,0:25:50.36,English,,0,0,0,,In this column will show which thread is executing so either thread 1 or thread 2
Dialogue: 0,0:25:45.84,0:25:50.36,Chinese,,0,0,0,,在此列中将显示正在执行的线程，因此线程1或线程2
Dialogue: 0,0:25:53.28,0:25:56.42,English,,0,0,0,,And then we'll to know which instruction in that thread is executing
Dialogue: 0,0:25:53.28,0:25:56.42,Chinese,,0,0,0,,然后我们将知道该线程中的哪条指令正在执行
Dialogue: 0,0:25:57.90,0:26:00.28,English,,0,0,0,,Either H,L,U,S or T
Dialogue: 0,0:25:57.90,0:26:00.28,Chinese,,0,0,0,,H，L，U，S或T
Dialogue: 0,0:26:02.02,0:26:07.20,English,,0,0,0,,And then this column shows the value of %rdx for thread number 1
Dialogue: 0,0:26:02.02,0:26:07.20,Chinese,,0,0,0,,然后此列显示线程编号1的％rdx的值
Dialogue: 0,0:26:08.34,0:26:11.46,English,,0,0,0,,And this column shows the value of %rdx for thread number 2
Dialogue: 0,0:26:08.34,0:26:11.46,Chinese,,0,0,0,,此列显示线程编号2的％rdx值
Dialogue: 0,0:26:11.66,0:26:19.28,English,,0,0,0,,Right since that the kernel keeps separate copies of all the general-purpose registers the for each thread these can be different
Dialogue: 0,0:26:11.66,0:26:19.28,Chinese,,0,0,0,,正因为内核保留了所有通用寄存器的单独副本，因此对于每个线程，这些副本可以是不同的
Dialogue: 0,0:26:22.60,0:26:25.56,English,,0,0,0,,Okay and then this last column shows the value of count in memory
Dialogue: 0,0:26:22.60,0:26:25.56,Chinese,,0,0,0,,好的，然后最后一列显示内存中count的值
Dialogue: 0,0:26:27.90,0:26:30.82,English,,0,0,0,,So let's start executing
Dialogue: 0,0:26:27.90,0:26:30.82,Chinese,,0,0,0,,所以让我们开始执行
Dialogue: 0,0:26:30.92,0:26:33.06,English,,0,0,0,,So initially count is equal to 0
Dialogue: 0,0:26:30.92,0:26:33.06,Chinese,,0,0,0,,所以最初count等于0
Dialogue: 0,0:26:34.16,0:26:38.90,English,,0,0,0,,And thread one gets the kernel schedules thread 1
Dialogue: 0,0:26:34.16,0:26:38.90,Chinese,,0,0,0,,并且线程1获取内核调度线程1
Dialogue: 0,0:26:38.92,0:26:41.94,English,,0,0,0,,So it executes say H(1) that has no impact on count
Dialogue: 0,0:26:38.92,0:26:41.94,Chinese,,0,0,0,,所以它执行说H（1）对计数没有影响
Dialogue: 0,0:26:43.34,0:26:47.20,English,,0,0,0,,Then thread 1 loads the value of count into its copy of %rdx
Dialogue: 0,0:26:43.34,0:26:47.20,Chinese,,0,0,0,,然后，线程1将count的值加载到其％rdx的副本中
Dialogue: 0,0:26:48.52,0:26:49.34,English,,0,0,0,,Updates it
Dialogue: 0,0:26:48.52,0:26:49.34,Chinese,,0,0,0,,更新它
Dialogue: 0,0:26:50.74,0:26:58.90,English,,0,0,0,,So now %rdx is equal to 1 and then stores that value in %rdx back to count so now count is equal to 1
Dialogue: 0,0:26:50.74,0:26:58.90,Chinese,,0,0,0,,所以现在％rdx等于1，然后将％rdx中的值存储回计数，所以现在count等于1
Dialogue: 0,0:27:00.84,0:27:04.20,English,,0,0,0,,Now at this point the kernel decides to schedule thread 2
Dialogue: 0,0:27:00.84,0:27:04.20,Chinese,,0,0,0,,此时内核决定调度线程2
Dialogue: 0,0:27:04.90,0:27:10.76,English,,0,0,0,,So thread 2 begins executing and when it begins executing value of count is 1
Dialogue: 0,0:27:04.90,0:27:10.76,Chinese,,0,0,0,,因此线程2开始执行，当它开始执行时，count的值为1
Dialogue: 0,0:27:11.86,0:27:14.20,English,,0,0,0,,So it executes H(i)
Dialogue: 0,0:27:11.86,0:27:14.20,Chinese,,0,0,0,,所以它执行H（i）
Dialogue: 0,0:27:16.26,0:27:22.62,English,,0,0,0,,Then it loads count into thread 2 copy of %rdx
Dialogue: 0,0:27:16.26,0:27:22.62,Chinese,,0,0,0,,然后它将count加载到％rdx的线程2副本中
Dialogue: 0,0:27:23.32,0:27:28.08,English,,0,0,0,,So now %rdx equals 1,updates it,now it's equal to 2
Dialogue: 0,0:27:23.32,0:27:28.08,Chinese,,0,0,0,,所以现在％rdx等于1，更新它，现在它等于2
Dialogue: 0,0:27:28.68,0:27:31.40,English,,0,0,0,,And then stores that value back to count
Dialogue: 0,0:27:28.68,0:27:31.40,Chinese,,0,0,0,,然后将这些价值存储回来计算
Dialogue: 0,0:27:33.20,0:27:41.44,English,,0,0,0,,The kernel then decides oh and then it finishes executing the tail instruction
Dialogue: 0,0:27:33.20,0:27:41.44,Chinese,,0,0,0,,然后内核决定哦然后它完成执行尾指令
Dialogue: 0,0:27:42.44,0:27:44.36,English,,0,0,0,,And let's say we're just doing one iteration of this
Dialogue: 0,0:27:42.44,0:27:44.36,Chinese,,0,0,0,,而且，假设我们只是对此进行了一次迭代
Dialogue: 0,0:27:45.64,0:27:51.22,English,,0,0,0,,And then at this point the kernel decides to schedule thread 1 since thread 2 is finished so
Dialogue: 0,0:27:45.64,0:27:51.22,Chinese,,0,0,0,,然后在这一点上，内核决定调度线程1，因为线程2已完成
Dialogue: 0,0:27:51.86,0:27:55.38,English,,0,0,0,,Thread 1 executes the remaining statement that it has to execute
Dialogue: 0,0:27:51.86,0:27:55.38,Chinese,,0,0,0,,线程1执行必须执行的剩余语句
Dialogue: 0,0:27:57.06,0:27:58.82,English,,0,0,0,,And at this point both threads have finished
Dialogue: 0,0:27:57.06,0:27:58.82,Chinese,,0,0,0,,此时两个线程都已完成
Dialogue: 0,0:28:00.50,0:28:03.84,English,,0,0,0,,And count is equal to 2 which is the value we would expect
Dialogue: 0,0:28:00.50,0:28:03.84,Chinese,,0,0,0,,而count等于2，这是我们期望的值
Dialogue: 0,0:28:04.18,0:28:06.74,English,,0,0,0,,Ok so this so this is ok
Dialogue: 0,0:28:04.18,0:28:06.74,Chinese,,0,0,0,,好的，所以这样就可以了
Dialogue: 0,0:28:07.38,0:28:11.60,English,,0,0,0,,And notice how...so this is actually this is an inner leaving that works
Dialogue: 0,0:28:07.38,0:28:11.60,Chinese,,0,0,0,,并注意如何...所以这实际上是一个内在的离开是有效的
Dialogue: 0,0:28:11.88,0:28:13.08,English,,0,0,0,,Ok we get the correct value
Dialogue: 0,0:28:11.88,0:28:13.08,Chinese,,0,0,0,,好的，我们得到正确的价值
Dialogue: 0,0:28:14.12,0:28:16.02,English,,0,0,0,,And notice how I...
Dialogue: 0,0:28:14.12,0:28:16.02,Chinese,,0,0,0,,请注意我...
Dialogue: 0,0:28:19.08,0:28:23.14,English,,0,0,0,,I grouped the 3 instructions that are actually involved in updating count together
Dialogue: 0,0:28:19.08,0:28:23.14,Chinese,,0,0,0,,我将实际参与更新计数的3条指令分组在一起
Dialogue: 0,0:28:24.66,0:28:29.76,English,,0,0,0,,And it will call that,we'll call those 3 instructions a critical section and I've color-coded them
Dialogue: 0,0:28:24.66,0:28:29.76,Chinese,,0,0,0,,它会称之为，我们将这3条指令称为关键部分，并对其进行颜色编码
Dialogue: 0,0:28:29.78,0:28:32.02,English,,0,0,0,,So you can easily keep track of them
Dialogue: 0,0:28:29.78,0:28:32.02,Chinese,,0,0,0,,因此，你可以轻松跟踪它们
Dialogue: 0,0:28:34.08,0:28:39.10,English,,0,0,0,,Alright let's look...now let's look at another another interleaving which is feasible right
Dialogue: 0,0:28:34.08,0:28:39.10,Chinese,,0,0,0,,好吧，让我们看看......现在让我们看看另一个可行的交错
Dialogue: 0,0:28:40.24,0:28:43.04,English,,0,0,0,,But in this case it results in the wrong value
Dialogue: 0,0:28:40.24,0:28:43.04,Chinese,,0,0,0,,但在这种情况下，它会导致错误的价值
Dialogue: 0,0:28:44.98,0:28:47.98,English,,0,0,0,,Ok so here we start with thread 1 again
Dialogue: 0,0:28:44.98,0:28:47.98,Chinese,,0,0,0,,好的，我们再次从线程1开始
Dialogue: 0,0:28:50.16,0:28:55.52,English,,0,0,0,,It loads it's the value of count into its copy of %rdx updates it
Dialogue: 0,0:28:50.16,0:28:55.52,Chinese,,0,0,0,,它将count的值加载到％rdx的副本中更新它
Dialogue: 0,0:28:56.14,0:28:57.62,English,,0,0,0,,But then before it can store it
Dialogue: 0,0:28:56.14,0:28:57.62,Chinese,,0,0,0,,但在此之前它可以存储它
Dialogue: 0,0:28:59.08,0:29:01.44,English,,0,0,0,,The kernel decides to schedule thread 2
Dialogue: 0,0:28:59.08,0:29:01.44,Chinese,,0,0,0,,内核决定调度线程2
Dialogue: 0,0:29:02.46,0:29:04.84,English,,0,0,0,,So thread 2 begins x executing
Dialogue: 0,0:29:02.46,0:29:04.84,Chinese,,0,0,0,,所以线程2开始执行x
Dialogue: 0,0:29:05.86,0:29:09.28,English,,0,0,0,,It loads count into its copy of %rdx too
Dialogue: 0,0:29:05.86,0:29:09.28,Chinese,,0,0,0,,它也会将count加载到％rdx的副本中
Dialogue: 0,0:29:10.18,0:29:14.24,English,,0,0,0,,And notice count is still 0 right it's 1
Dialogue: 0,0:29:10.18,0:29:14.24,Chinese,,0,0,0,,并且通知计数仍为0，它是1
Dialogue: 0,0:29:15.84,0:29:19.64,English,,0,0,0,,In the value of in thread 1 in the %rdx
Dialogue: 0,0:29:15.84,0:29:19.64,Chinese,,0,0,0,,在％rdx中的线程1中的值
Dialogue: 0,0:29:20.12,0:29:24.02,English,,0,0,0,,The copy of %rdx and thread 1 but it hasn't been updated in memory so
Dialogue: 0,0:29:20.12,0:29:24.02,Chinese,,0,0,0,,％rdx和线程1的副本，但它没有在内存中更新
Dialogue: 0,0:29:24.98,0:29:29.92,English,,0,0,0,,When thread 2 loads its value of count
Dialogue: 0,0:29:24.98,0:29:29.92,Chinese,,0,0,0,,当线程2加载其count值时
Dialogue: 0,0:29:29.92,0:29:33.44,English,,0,0,0,,Now it's copy and %rdx is 0
Dialogue: 0,0:29:29.92,0:29:33.44,Chinese,,0,0,0,,现在它的副本和％rdx为0
Dialogue: 0,0:29:34.60,0:29:39.72,English,,0,0,0,,Now at this point the kernel reschedules thread 1 to execute so thread 1 does it store
Dialogue: 0,0:29:34.60,0:29:39.72,Chinese,,0,0,0,,现在，此时内核重新安排线程1执行，因此线程1会存储它
Dialogue: 0,0:29:40.88,0:29:43.98,English,,0,0,0,,Of its copy of %rdx into count
Dialogue: 0,0:29:40.88,0:29:43.98,Chinese,,0,0,0,,其％rdx的副本计入计数
Dialogue: 0,0:29:44.96,0:29:48.16,English,,0,0,0,,And then finishes executing it the tail instruction
Dialogue: 0,0:29:44.96,0:29:48.16,Chinese,,0,0,0,,然后完成尾部指令的执行
Dialogue: 0,0:29:49.44,0:29:54.72,English,,0,0,0,,The colonel reschedules thread 2 which picks up where it left off it updates
Dialogue: 0,0:29:49.44,0:29:54.72,Chinese,,0,0,0,,上校重新安排线程2，它从它停止的地方开始更新
Dialogue: 0,0:29:55.90,0:29:58.36,English,,0,0,0,,Its copy of count
Dialogue: 0,0:29:55.90,0:29:58.36,Chinese,,0,0,0,,它的计数副本
Dialogue: 0,0:29:58.46,0:30:01.60,English,,0,0,0,,So now %rdx goes from 0 to 1
Dialogue: 0,0:29:58.46,0:30:01.60,Chinese,,0,0,0,,所以现在％rdx从0变为1
Dialogue: 0,0:30:03.18,0:30:06.12,English,,0,0,0,,And then it stores that value into count
Dialogue: 0,0:30:03.18,0:30:06.12,Chinese,,0,0,0,,然后它将该值存储到计数中
Dialogue: 0,0:30:06.80,0:30:10.44,English,,0,0,0,,So all we've done is we've overwritten count out a value 1
Dialogue: 0,0:30:06.80,0:30:10.44,Chinese,,0,0,0,,所以我们所做的就是我们已经覆盖了数值1
Dialogue: 0,0:30:11.06,0:30:12.80,English,,0,0,0,,And we've overwritten it with a value of 1
Dialogue: 0,0:30:11.06,0:30:12.80,Chinese,,0,0,0,,我们用值1覆盖了它
Dialogue: 0,0:30:13.82,0:30:17.72,English,,0,0,0,,So when we finish execution of these two threads count has the wrong value
Dialogue: 0,0:30:13.82,0:30:17.72,Chinese,,0,0,0,,所以当我们完成这两个线程的执行时，count有错误的值
Dialogue: 0,0:30:20.58,0:30:21.18,English,,0,0,0,,Okay in the
Dialogue: 0,0:30:20.58,0:30:21.18,Chinese,,0,0,0,,好的
Dialogue: 0,0:30:22.58,0:30:27.96,English,,0,0,0,,That then the general like,the general thing to notice is you see how these critical sections have been interleaved
Dialogue: 0,0:30:22.58,0:30:27.96,Chinese,,0,0,0,,那就是一般情况，一般要注意的是你看到这些关键部分是如何交错的
Dialogue: 0,0:30:28.64,0:30:30.72,English,,0,0,0,,Right in this case
Dialogue: 0,0:30:28.64,0:30:30.72,Chinese,,0,0,0,,就在这种情况下
Dialogue: 0,0:30:32.14,0:30:37.60,English,,0,0,0,,This is the first the critical section for thread 1 executed before the critical section for thread 2
Dialogue: 0,0:30:32.14,0:30:37.60,Chinese,,0,0,0,,这是线程1在线程2的临界区之前执行的第一个临界区
Dialogue: 0,0:30:39.52,0:30:42.88,English,,0,0,0,,Okay but in this case the two critical sections interleaved okay
Dialogue: 0,0:30:39.52,0:30:42.88,Chinese,,0,0,0,,好的但是在这种情况下，两个关键部分交错了
Dialogue: 0,0:30:46.24,0:30:48.30,English,,0,0,0,,So let's see another example of that
Dialogue: 0,0:30:46.24,0:30:48.30,Chinese,,0,0,0,,那么让我们看看另一个例子
Dialogue: 0,0:30:48.70,0:30:50.78,English,,0,0,0,,So here you can see that these are interleaved so
Dialogue: 0,0:30:48.70,0:30:50.78,Chinese,,0,0,0,,所以在这里你可以看到它们是交错的
Dialogue: 0,0:30:53.60,0:30:55.10,English,,0,0,0,,Probably suggest there might be a problem.Yes!
Dialogue: 0,0:30:53.60,0:30:55.10,Chinese,,0,0,0,,可能暗示可能存在问题。是的！
Dialogue: 0,0:30:55.12,0:31:00.68,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:00.68,0:31:01.98,English,,0,0,0,,So I'm sorry excuse me
Dialogue: 0,0:31:00.68,0:31:01.98,Chinese,,0,0,0,,对不起，对不起
Dialogue: 0,0:31:02.04,0:31:11.32,English,,0,0,0,,[student speaking]
Dialogue: 0,0:31:11.34,0:31:13.72,English,,0,0,0,,Well no okay so the question is would would
Dialogue: 0,0:31:11.34,0:31:13.72,Chinese,,0,0,0,,好吧不行，所以问题就是
Dialogue: 0,0:31:14.90,0:31:15.60,English,,0,0,0,,I or count count
Dialogue: 0,0:31:14.90,0:31:15.60,Chinese,,0,0,0,,我还算数
Dialogue: 0,0:31:22.10,0:31:26.10,English,,0,0,0,,If we...okay it is defined as volatile
Dialogue: 0,0:31:22.10,0:31:26.10,Chinese,,0,0,0,,如果我们......好吧它被定义为volatile
Dialogue: 0,0:31:28.52,0:31:37.68,English,,0,0,0,,Yeah so that that's why...I mean there's actually and the compiler could have compiled this code in different ways right
Dialogue: 0,0:31:28.52,0:31:37.68,Chinese,,0,0,0,,是的，这就是为什么......我的意思是实际上，编译器可以用不同的方式编译这段代码
Dialogue: 0,0:31:38.10,0:31:42.96,English,,0,0,0,,There is actually an increment instruction that you will increment a variable in memory
Dialogue: 0,0:31:38.10,0:31:42.96,Chinese,,0,0,0,,实际上有一个增量指令，你将在内存中增加一个变量
Dialogue: 0,0:31:43.16,0:31:44.36,English,,0,0,0,,So you could have done
Dialogue: 0,0:31:43.16,0:31:44.36,Chinese,,0,0,0,,所以你可以做到
Dialogue: 0,0:31:45.60,0:31:47.10,English,,0,0,0,,The compiler could have generated this
Dialogue: 0,0:31:45.60,0:31:47.10,Chinese,,0,0,0,,编译器可能已经生成了这个
Dialogue: 0,0:31:47.36,0:31:51.10,English,,0,0,0,,This 3 instruction sequence is one instruction and then we wouldn't have this problem
Dialogue: 0,0:31:47.36,0:31:51.10,Chinese,,0,0,0,,这3个指令序列是一条指令，然后我们就不会遇到这个问题
Dialogue: 0,0:31:51.64,0:31:52.62,English,,0,0,0,,But the problem is that
Dialogue: 0,0:31:51.64,0:31:52.62,Chinese,,0,0,0,,但问题是
Dialogue: 0,0:31:53.68,0:31:59.86,English,,0,0,0,,It's loading into register then incrementing and then saving
Dialogue: 0,0:31:53.68,0:31:59.86,Chinese,,0,0,0,,它加载到寄存器然后递增然后保存
Dialogue: 0,0:31:59.88,0:32:01.78,English,,0,0,0,,So that the problem comes about because
Dialogue: 0,0:31:59.88,0:32:01.78,Chinese,,0,0,0,,因此，问题就出现了
Dialogue: 0,0:32:02.26,0:32:02.64,English,,0,0,0,,We can
Dialogue: 0,0:32:02.26,0:32:02.64,Chinese,,0,0,0,,我们可以
Dialogue: 0,0:32:05.08,0:32:10.02,English,,0,0,0,,This thread can be interrupted before it finishes this three-step sequence
Dialogue: 0,0:32:05.08,0:32:10.02,Chinese,,0,0,0,,在完成这个三步序列之前，可以中断该线程
Dialogue: 0,0:32:10.02,0:32:12.20,English,,0,0,0,,This load modify store sequence
Dialogue: 0,0:32:10.02,0:32:12.20,Chinese,,0,0,0,,此加载修改存储序列
Dialogue: 0,0:32:12.98,0:32:13.28,English,,0,0,0,,Yes
Dialogue: 0,0:32:12.98,0:32:13.28,Chinese,,0,0,0,,是
Dialogue: 0,0:32:13.66,0:32:21.36,English,,0,0,0,,[student speaking]
Dialogue: 0,0:32:21.36,0:32:24.86,English,,0,0,0,,It would wait yeah so it that's right yeah I guess I wasn't clear it
Dialogue: 0,0:32:21.36,0:32:24.86,Chinese,,0,0,0,,它会等待，所以这是正确的是的，我想我不清楚它
Dialogue: 0,0:32:25.63,0:32:28.66,English,,0,0,0,,It prevents it from being stored permanently in a register right so
Dialogue: 0,0:32:25.63,0:32:28.66,Chinese,,0,0,0,,它可以防止它永久存储在寄存器中
Dialogue: 0,0:32:29.42,0:32:34.24,English,,0,0,0,,It may have to be loaded into a register but then it'll be written back
Dialogue: 0,0:32:29.42,0:32:34.24,Chinese,,0,0,0,,它可能必须加载到寄存器中，然后它将被写回
Dialogue: 0,0:32:36.02,0:32:39.52,English,,0,0,0,,Okay whereas the the compiler would have the option like we've seen it with local variables
Dialogue: 0,0:32:36.02,0:32:39.52,Chinese,,0,0,0,,好吧，而编译器会有像我们用局部变量看到它的选项
Dialogue: 0,0:32:40.16,0:32:43.44,English,,0,0,0,,Right the compiler just it never allocates stack space
Dialogue: 0,0:32:40.16,0:32:43.44,Chinese,,0,0,0,,对编译器来说，它永远不会分配堆栈空间
Dialogue: 0,0:32:43.44,0:32:45.88,English,,0,0,0,,It just keeps that local variable in a register all the time
Dialogue: 0,0:32:43.44,0:32:45.88,Chinese,,0,0,0,,它只是将局部变量保存在寄存器中
Dialogue: 0,0:32:46.12,0:32:50.02,English,,0,0,0,,Okay so this prevent the volatile attribute prevents the compiler from doing that
Dialogue: 0,0:32:46.12,0:32:50.02,Chinese,,0,0,0,,好的，这样可以防止volatile属性阻止编译器这样做
Dialogue: 0,0:32:55.58,0:32:57.19,English,,0,0,0,,Okay so let's look at another example
Dialogue: 0,0:32:55.58,0:32:57.19,Chinese,,0,0,0,,好的，让我们看看另一个例子
Dialogue: 0,0:32:58.20,0:33:00.58,English,,0,0,0,,So here thread 1 starts
Dialogue: 0,0:32:58.20,0:33:00.58,Chinese,,0,0,0,,所以这里线程1开始了
Dialogue: 0,0:33:01.08,0:33:04.24,English,,0,0,0,,It loads count into %rdx
Dialogue: 0,0:33:01.08,0:33:04.24,Chinese,,0,0,0,,它将计数加载到％rdx
Dialogue: 0,0:33:05.08,0:33:06.28,English,,0,0,0,,Then thread 2 starts
Dialogue: 0,0:33:05.08,0:33:06.28,Chinese,,0,0,0,,然后线程2开始
Dialogue: 0,0:33:07.36,0:33:11.44,English,,0,0,0,,And it loads a count which is still 0 into %rdx(2)
Dialogue: 0,0:33:07.36,0:33:11.44,Chinese,,0,0,0,,它加载的计数仍为0到％rdx（2）
Dialogue: 0,0:33:12.18,0:33:15.80,English,,0,0,0,,Updates it and then stores it so now count equal to 1
Dialogue: 0,0:33:12.18,0:33:15.80,Chinese,,0,0,0,,更新它然后存储它，所以现在计数等于1
Dialogue: 0,0:33:16.38,0:33:25.56,English,,0,0,0,,When thread 1 resumes it updates its value of count and %rdx and stores that back to count
Dialogue: 0,0:33:16.38,0:33:25.56,Chinese,,0,0,0,,当线程1恢复时，它会更新count和％rdx的值并将其存储回计数
Dialogue: 0,0:33:25.92,0:33:28.22,English,,0,0,0,,And so again we have the same problem
Dialogue: 0,0:33:25.92,0:33:28.22,Chinese,,0,0,0,,所以我们再次遇到同样的问题
Dialogue: 0,0:33:30.58,0:33:31.34,English,,0,0,0,,Okay so the...
Dialogue: 0,0:33:30.58,0:33:31.34,Chinese,,0,0,0,,好的，所以......
Dialogue: 0,0:33:32.52,0:33:36.22,English,,0,0,0,,The problem here is that we're interleaving these these critical sections
Dialogue: 0,0:33:32.52,0:33:36.22,Chinese,,0,0,0,,这里的问题是我们正在交错这些关键部分
Dialogue: 0,0:33:36.92,0:33:39.62,English,,0,0,0,,And you can understand why this is bad
Dialogue: 0,0:33:36.92,0:33:39.62,Chinese,,0,0,0,,你可以理解为什么这很糟糕
Dialogue: 0,0:33:40.74,0:33:43.60,English,,0,0,0,,With a nice or graphical technique called a progress graph
Dialogue: 0,0:33:40.74,0:33:43.60,Chinese,,0,0,0,,使用称为进度图的漂亮或图形技术
Dialogue: 0,0:33:48.38,0:33:49.96,English,,0,0,0,,So in a progress graph
Dialogue: 0,0:33:48.38,0:33:49.96,Chinese,,0,0,0,,所以在进度图中
Dialogue: 0,0:33:52.60,0:33:56.20,English,,0,0,0,,If we have 4n threads it's an n dimensional cartesian grid
Dialogue: 0,0:33:52.60,0:33:56.20,Chinese,,0,0,0,,如果我们有4n个线程，它就是一个n维笛卡尔网格
Dialogue: 0,0:33:57.98,0:34:03.88,English,,0,0,0,,That characterizes the execution state space of a concurrent threaded program
Dialogue: 0,0:33:57.98,0:34:03.88,Chinese,,0,0,0,,这表示并发线程程序的执行状态空间
Dialogue: 0,0:34:05.06,0:34:07.58,English,,0,0,0,,So in this case each here we have two threads
Dialogue: 0,0:34:05.06,0:34:07.58,Chinese,,0,0,0,,所以在这种情况下，每个人都有两个线程
Dialogue: 0,0:34:07.60,0:34:12.06,English,,0,0,0,,So it's a 2d coordinate system
Dialogue: 0,0:34:07.60,0:34:12.06,Chinese,,0,0,0,,所以它是一个二维坐标系
Dialogue: 0,0:34:13.04,0:34:18.36,English,,0,0,0,,So each axis represents the progress the execution progress of some threads
Dialogue: 0,0:34:13.04,0:34:18.36,Chinese,,0,0,0,,因此每个轴代表一些线程执行进度的进度
Dialogue: 0,0:34:18.44,0:34:22.52,English,,0,0,0,,So the x axis here is thread 1
Dialogue: 0,0:34:18.44,0:34:22.52,Chinese,,0,0,0,,所以这里的x轴是线程1
Dialogue: 0,0:34:23.08,0:34:25.72,English,,0,0,0,,And the y axis corresponds to thread 2
Dialogue: 0,0:34:23.08,0:34:25.72,Chinese,,0,0,0,,并且y轴对应于线程2
Dialogue: 0,0:34:27.40,0:34:32.16,English,,0,0,0,,And then each one of these edges corresponds to the execution of an instruction
Dialogue: 0,0:34:27.40,0:34:32.16,Chinese,,0,0,0,,然后，这些边缘中的每一个对应于指令的执行
Dialogue: 0,0:34:32.88,0:34:35.34,English,,0,0,0,,Ok so we start out in an initial state
Dialogue: 0,0:34:32.88,0:34:35.34,Chinese,,0,0,0,,好的，我们从初始状态开始
Dialogue: 0,0:34:36.12,0:34:38.50,English,,0,0,0,,And then the first thing we execute is H(1)
Dialogue: 0,0:34:36.12,0:34:38.50,Chinese,,0,0,0,,然后我们执行的第一件事是H（1）
Dialogue: 0,0:34:39.70,0:34:42.21,English,,0,0,0,,So that's represented by this ACK here
Dialogue: 0,0:34:39.70,0:34:42.21,Chinese,,0,0,0,,所以这就是这个ACK所代表的
Dialogue: 0,0:34:43.18,0:34:47.64,English,,0,0,0,,So this position this point right here represents the state where
Dialogue: 0,0:34:43.18,0:34:47.64,Chinese,,0,0,0,,所以这个位置在这里就代表了这里的状态
Dialogue: 0,0:34:48.26,0:34:52.94,English,,0,0,0,,We've executed H,we finished executing H(1) in thread 1
Dialogue: 0,0:34:48.26,0:34:52.94,Chinese,,0,0,0,,我们已经执行了H，我们在线程1中完成了H（1）的执行
Dialogue: 0,0:34:52.94,0:34:56.18,English,,0,0,0,,But we haven't yet executed any instructions in thread 2
Dialogue: 0,0:34:52.94,0:34:56.18,Chinese,,0,0,0,,但是我们还没有在线程2中执行任何指令
Dialogue: 0,0:34:57.56,0:35:00.30,English,,0,0,0,,Ok so in general each one of these points represents
Dialogue: 0,0:34:57.56,0:35:00.30,Chinese,,0,0,0,,好的，所以通常这些点中的每一个都代表
Dialogue: 0,0:35:01.98,0:35:05.08,English,,0,0,0,,Sort of the current progress of the program or the execution state
Dialogue: 0,0:35:01.98,0:35:05.08,Chinese,,0,0,0,,排序程序的当前进度或执行状态
Dialogue: 0,0:35:06.06,0:35:11.02,English,,0,0,0,,So for example this state right here represents the state where thread 1
Dialogue: 0,0:35:06.06,0:35:11.02,Chinese,,0,0,0,,所以例如这里的状态表示线程1的状态
Dialogue: 0,0:35:11.34,0:35:13.60,English,,0,0,0,,Has completed a completed L1
Dialogue: 0,0:35:11.34,0:35:13.60,Chinese,,0,0,0,,已经完成了L1
Dialogue: 0,0:35:14.24,0:35:17.16,English,,0,0,0,,And thread 2 is completed S(2)
Dialogue: 0,0:35:14.24,0:35:17.16,Chinese,,0,0,0,,线程2完成S（2）
Dialogue: 0,0:35:22.30,0:35:28.16,English,,0,0,0,,And now the execution of a program is modeled as a transition from one state to the other
Dialogue: 0,0:35:22.30,0:35:28.16,Chinese,,0,0,0,,现在，程序的执行被建模为从一个状态到另一个状态的转换
Dialogue: 0,0:35:28.78,0:35:33.66,English,,0,0,0,,And there's some,so from this and there's constraints on how
Dialogue: 0,0:35:28.78,0:35:33.66,Chinese,,0,0,0,,还有一些，所以从这一点来看，如何限制
Dialogue: 0,0:35:34.82,0:35:39.00,English,,0,0,0,,On how these states can advance so
Dialogue: 0,0:35:34.82,0:35:39.00,Chinese,,0,0,0,,关于这些国家如何能够如此发展
Dialogue: 0,0:35:39.74,0:35:41.62,English,,0,0,0,,From this state(L1, S2)
Dialogue: 0,0:35:39.74,0:35:41.62,Chinese,,0,0,0,,从这个状态（L1，S2）
Dialogue: 0,0:35:42.56,0:35:50.10,English,,0,0,0,,Obviously time can't go backwards right so we can't go backwards like in this direction to the left and we can't go down
Dialogue: 0,0:35:42.56,0:35:50.10,Chinese,,0,0,0,,显然时间不能倒退，所以我们不能像往左那样向后退，我们也不能倒
Dialogue: 0,0:35:50.78,0:35:53.48,English,,0,0,0,,Okay so we can only go to the right and up
Dialogue: 0,0:35:50.78,0:35:53.48,Chinese,,0,0,0,,好的，所以我们只能向右和向上走
Dialogue: 0,0:35:54.56,0:35:56.96,English,,0,0,0,,And since we're assuming that each instruction executes
Dialogue: 0,0:35:54.56,0:35:56.96,Chinese,,0,0,0,,因为我们假设每条指令都执行了
Dialogue: 0,0:35:57.58,0:36:00.18,English,,0,0,0,,There's only one instruction executing at a time
Dialogue: 0,0:35:57.58,0:36:00.18,Chinese,,0,0,0,,一次只执行一条指令
Dialogue: 0,0:36:00.58,0:36:03.12,English,,0,0,0,,We can't go diagonally that would be two instructions
Dialogue: 0,0:36:00.58,0:36:03.12,Chinese,,0,0,0,,我们不能对角地说是两条指令
Dialogue: 0,0:36:03.62,0:36:05.26,English,,0,0,0,,All right so from (L1,S2)
Dialogue: 0,0:36:03.62,0:36:05.26,Chinese,,0,0,0,,好的，从（L1，S2）
Dialogue: 0,0:36:05.90,0:36:08.08,English,,0,0,0,,The next execution state is either
Dialogue: 0,0:36:05.90,0:36:08.08,Chinese,,0,0,0,,下一个执行状态是
Dialogue: 0,0:36:09.46,0:36:15.26,English,,0,0,0,,Here if thread one execute or here if thread of thread to execute
Dialogue: 0,0:36:09.46,0:36:15.26,Chinese,,0,0,0,,这里如果线程一执行或在这里执行线程的线程
Dialogue: 0,0:36:17.54,0:36:20.28,English,,0,0,0,,Okay so you can put all these together to form a trajectory
Dialogue: 0,0:36:17.54,0:36:20.28,Chinese,,0,0,0,,好的，你可以把所有这些放在一起形成一个轨迹
Dialogue: 0,0:36:20.92,0:36:24.02,English,,0,0,0,,Which characterizes one execution of the program
Dialogue: 0,0:36:20.92,0:36:24.02,Chinese,,0,0,0,,其中表征了程序的一次执行
Dialogue: 0,0:36:25.86,0:36:32.76,English,,0,0,0,,Right and any feasible set of transitions from one state to the next corresponds to a feasible trajectory
Dialogue: 0,0:36:25.86,0:36:32.76,Chinese,,0,0,0,,从一个状态到下一个状态的右和任何可行的转换对应于可行的轨迹
Dialogue: 0,0:36:34.46,0:36:50.60,English,,0,0,0,,So for example H(1),L(1),U(1),H(2),L(2),S(1),T(1),U(2),S(2),T(2)
Dialogue: 0,0:36:34.46,0:36:50.60,Chinese,,0,0,0,,所以例如H（1），L（1），U（1），H（2），L（2），S（1），T（1），U（2），S（2），T（ 2）
Dialogue: 0,0:36:51.42,0:36:52.58,English,,0,0,0,,That's a feasible
Dialogue: 0,0:36:51.42,0:36:52.58,Chinese,,0,0,0,,那是可行的
Dialogue: 0,0:36:55.20,0:36:56.52,English,,0,0,0,,That's a feasible trajectory
Dialogue: 0,0:36:55.20,0:36:56.52,Chinese,,0,0,0,,这是一条可行的轨迹
Dialogue: 0,0:36:57.58,0:37:06.38,English,,0,0,0,,And it's one possible it represents one possible execution or so one set of inter leavings for this program
Dialogue: 0,0:36:57.58,0:37:06.38,Chinese,,0,0,0,,并且它可能代表一个可能的执行，或者说这个程序的一组间隔
Dialogue: 0,0:37:10.42,0:37:16.82,English,,0,0,0,,Now these L these three instructions L,U and S that operate on that manipulate count
Dialogue: 0,0:37:10.42,0:37:16.82,Chinese,,0,0,0,,现在这些L这三个指令L，U和S对操作计数进行操作
Dialogue: 0,0:37:17.40,0:37:20.66,English,,0,0,0,,Form what we call a critical section with respect to count
Dialogue: 0,0:37:17.40,0:37:20.66,Chinese,,0,0,0,,形成我们称之为计数的关键部分
Dialogue: 0,0:37:25.18,0:37:29.20,English,,0,0,0,,And the idea is that instructions inside
Dialogue: 0,0:37:25.18,0:37:29.20,Chinese,,0,0,0,,而这个想法就是里面的指示
Dialogue: 0,0:37:29.54,0:37:36.50,English,,0,0,0,,These critical sections this with receivership with respect to the same global variable shouldn't be interleaved
Dialogue: 0,0:37:29.54,0:37:36.50,Chinese,,0,0,0,,这些具有相同全局变量的接收性的关键部分不应交错
Dialogue: 0,0:37:38.28,0:37:43.70,English,,0,0,0,,So we can capture this geometrically by taking the intersection of these critical sections
Dialogue: 0,0:37:38.28,0:37:43.70,Chinese,,0,0,0,,因此，我们可以通过获取这些关键部分的交集来捕获这种几何形状
Dialogue: 0,0:37:44.48,0:37:47.18,English,,0,0,0,,To form what we call an unsafe region
Dialogue: 0,0:37:44.48,0:37:47.18,Chinese,,0,0,0,,形成我们称之为不安全的地区
Dialogue: 0,0:37:48.90,0:37:53.10,English,,0,0,0,,So in this an unsafe region is...
Dialogue: 0,0:37:48.90,0:37:53.10,Chinese,,0,0,0,,所以在这个不安全的地区是......
Dialogue: 0,0:37:53.66,0:38:01.66,English,,0,0,0,,The points within an unsafe region are those points in an execution where the critical sections are being or interleaved
Dialogue: 0,0:37:53.66,0:38:01.66,Chinese,,0,0,0,,不安全区域内的点是执行中关键部分正在或交错的那些点
Dialogue: 0,0:38:03.26,0:38:07.32,English,,0,0,0,,Okay so for this particular example there's four points within the unsafe region
Dialogue: 0,0:38:03.26,0:38:07.32,Chinese,,0,0,0,,好的，对于这个特殊的例子，不安全区域内有四个点
Dialogue: 0,0:38:08.24,0:38:10.72,English,,0,0,0,,And if a trajectory ever touches one of those points
Dialogue: 0,0:38:08.24,0:38:10.72,Chinese,,0,0,0,,如果一个轨迹触及其中一个点
Dialogue: 0,0:38:10.72,0:38:13.70,English,,0,0,0,,Then we've interleaved critical section and we're going to get the wrong answer
Dialogue: 0,0:38:10.72,0:38:13.70,Chinese,,0,0,0,,然后我们交错了临界区，我们将得到错误的答案
Dialogue: 0,0:38:17.12,0:38:19.90,English,,0,0,0,,Okay so the idea is to try to stay out of these unsafe regions
Dialogue: 0,0:38:17.12,0:38:19.90,Chinese,,0,0,0,,好的，所以我的想法是试图远离这些不安全的地区
Dialogue: 0,0:38:25.28,0:38:28.40,English,,0,0,0,,And if we do we say that trajectory is safe so
Dialogue: 0,0:38:25.28,0:38:28.40,Chinese,,0,0,0,,如果我们这样做，我们说轨迹是安全的
Dialogue: 0,0:38:29.50,0:38:31.96,English,,0,0,0,,Here's an example of a trajectory that's safe
Dialogue: 0,0:38:29.50,0:38:31.96,Chinese,,0,0,0,,这是一个安全的轨迹示例
Dialogue: 0,0:38:33.20,0:38:37.04,English,,0,0,0,,Now this is okay,right this point right here is not in the unsafe region
Dialogue: 0,0:38:33.20,0:38:37.04,Chinese,,0,0,0,,现在这没关系，这一点就在这里，不在不安全的地区
Dialogue: 0,0:38:37.82,0:38:40.62,English,,0,0,0,,Because we haven't executed we only executed H(1) here
Dialogue: 0,0:38:37.82,0:38:40.62,Chinese,,0,0,0,,因为我们还没有执行，所以我们这里只执行了H（1）
Dialogue: 0,0:38:41.16,0:38:43.42,English,,0,0,0,,Remember a point corresponds to
Dialogue: 0,0:38:41.16,0:38:43.42,Chinese,,0,0,0,,记住一点对应
Dialogue: 0,0:38:43.88,0:38:48.82,English,,0,0,0,,And it's the instruction that we've completed that instruction
Dialogue: 0,0:38:43.88,0:38:48.82,Chinese,,0,0,0,,这是我们完成该指令的指令
Dialogue: 0,0:38:51.10,0:38:51.86,English,,0,0,0,,So then
Dialogue: 0,0:38:51.10,0:38:51.86,Chinese,,0,0,0,,那么
Dialogue: 0,0:38:53.12,0:38:55.08,English,,0,0,0,,So here we're skirting the unsafe region
Dialogue: 0,0:38:53.12,0:38:55.08,Chinese,,0,0,0,,所以我们在这里避开不安全的地区
Dialogue: 0,0:38:55.08,0:38:58.88,English,,0,0,0,,But it's still okay,so this is a safe trajectory we'll get the right answer for this one
Dialogue: 0,0:38:55.08,0:38:58.88,Chinese,,0,0,0,,但它仍然可以，所以这是一个安全的轨迹，我们将得到正确的答案
Dialogue: 0,0:39:00.00,0:39:00.82,English,,0,0,0,,However
Dialogue: 0,0:39:00.00,0:39:00.82,Chinese,,0,0,0,,然而
Dialogue: 0,0:39:03.58,0:39:05.52,English,,0,0,0,,This trajectory is unsafe because it
Dialogue: 0,0:39:03.58,0:39:05.52,Chinese,,0,0,0,,这条轨迹是不安全的，因为它
Dialogue: 0,0:39:07.82,0:39:11.10,English,,0,0,0,,It enters the unsafe region at this point here
Dialogue: 0,0:39:07.82,0:39:11.10,Chinese,,0,0,0,,此时它进入不安全的区域
Dialogue: 0,0:39:12.66,0:39:20.40,English,,0,0,0,,And even though it quickly exited the there's an interleaving there that creates a potential for a correct answer
Dialogue: 0,0:39:12.66,0:39:20.40,Chinese,,0,0,0,,即使它很快就会退出，但那里的交错会产生正确答案的可能性
Dialogue: 0,0:39:27.54,0:39:31.50,English,,0,0,0,,Okay so the question is how do we guarantee a safe trajectory
Dialogue: 0,0:39:27.54,0:39:31.50,Chinese,,0,0,0,,好的，问题是我们如何保证安全的轨迹
Dialogue: 0,0:39:31.58,0:39:33.98,English,,0,0,0,,And this is the this is what we call synchronization
Dialogue: 0,0:39:31.58,0:39:33.98,Chinese,,0,0,0,,这就是我们所说的同步
Dialogue: 0,0:39:34.00,0:39:39.67,English,,0,0,0,,So somehow we want to sort of configure the kernel
Dialogue: 0,0:39:34.00,0:39:39.67,Chinese,,0,0,0,,所以我们想以某种方式配置内核
Dialogue: 0,0:39:40.58,0:39:43.10,English,,0,0,0,,So that'll never schedule an unsafe trajectory
Dialogue: 0,0:39:40.58,0:39:43.10,Chinese,,0,0,0,,因此，永远不会安排不安全的轨迹
Dialogue: 0,0:39:45.86,0:39:46.78,English,,0,0,0,,So how do we do that
Dialogue: 0,0:39:45.86,0:39:46.78,Chinese,,0,0,0,,那我们该怎么做呢
Dialogue: 0,0:39:47.88,0:39:50.20,English,,0,0,0,,So somehow
Dialogue: 0,0:39:47.88,0:39:50.20,Chinese,,0,0,0,,所以不知何故
Dialogue: 0,0:39:51.52,0:39:54.98,English,,0,0,0,,We we have to synchronize the execution of those threads
Dialogue: 0,0:39:51.52,0:39:54.98,Chinese,,0,0,0,,我们必须同步这些线程的执行
Dialogue: 0,0:39:55.66,0:40:02.44,English,,0,0,0,,And another way to think of this is that we need to guarantee mutually exclusive access to the critical sections
Dialogue: 0,0:39:55.66,0:40:02.44,Chinese,,0,0,0,,另一种思考方式是我们需要保证对关键部分的互斥访问
Dialogue: 0,0:40:03.22,0:40:10.48,English,,0,0,0,,All right so once the kernel begins,once the thread starts executing the first instruction is critical section
Dialogue: 0,0:40:03.22,0:40:10.48,Chinese,,0,0,0,,好吧所以一旦内核开始，一旦线程开始执行第一条指令就是关键部分
Dialogue: 0,0:40:10.88,0:40:16.14,English,,0,0,0,,We don't want it to be interrupted by another thread that has a similar critical section
Dialogue: 0,0:40:10.88,0:40:16.14,Chinese,,0,0,0,,我们不希望它被另一个具有类似临界区的线程打断
Dialogue: 0,0:40:16.32,0:40:17.76,English,,0,0,0,,Okay we don't want it to be interrupted
Dialogue: 0,0:40:16.32,0:40:17.76,Chinese,,0,0,0,,好的，我们不希望它被打断
Dialogue: 0,0:40:18.14,0:40:22.22,English,,0,0,0,,We don't want...one critical section with respect to a certain global variable
Dialogue: 0,0:40:18.14,0:40:22.22,Chinese,,0,0,0,,我们不希望......关于某个全局变量的一个关键部分
Dialogue: 0,0:40:23.16,0:40:29.36,English,,0,0,0,,To be interrupted by another thread that has all right that's currently within that same critical section okay
Dialogue: 0,0:40:23.16,0:40:29.36,Chinese,,0,0,0,,要被另一个当前在同一个关键部分内的所有权利打断
Dialogue: 0,0:40:30.62,0:40:31.50,English,,0,0,0,,Sorry yes question
Dialogue: 0,0:40:30.62,0:40:31.50,Chinese,,0,0,0,,抱歉，是的问题
Dialogue: 0,0:40:31.50,0:40:45.08,English,,0,0,0,,Seems unlikely for me that
Dialogue: 0,0:40:31.50,0:40:45.08,Chinese,,0,0,0,,对我来说似乎不太可能
Dialogue: 0,0:40:45.08,0:40:48.44,English,,0,0,0,,Okay so the question is how likely is it that you get a correct trajectory
Dialogue: 0,0:40:45.08,0:40:48.44,Chinese,,0,0,0,,好吧，问题是你获得正确轨迹的可能性有多大
Dialogue: 0,0:40:48.48,0:40:51.02,English,,0,0,0,,And it happens right you can run it sometimes you do
Dialogue: 0,0:40:48.48,0:40:51.02,Chinese,,0,0,0,,它发生在你有时你可以运行它
Dialogue: 0,0:40:51.54,0:40:55.20,English,,0,0,0,,It just depends usually it's wrong sometimes it's right
Dialogue: 0,0:40:51.54,0:40:55.20,Chinese,,0,0,0,,这通常取决于有时它是对的
Dialogue: 0,0:40:57.96,0:41:03.92,English,,0,0,0,,And it just depends on how the kernel scheduled it and you can't assume any particular scheduling
Dialogue: 0,0:40:57.96,0:41:03.92,Chinese,,0,0,0,,它只取决于内核如何安排它，你不能假设任何特定的调度
Dialogue: 0,0:41:04.80,0:41:09.86,English,,0,0,0,,Right so if you say, if you want to claim that you would never get the right answer
Dialogue: 0,0:41:04.80,0:41:09.86,Chinese,,0,0,0,,是的，如果你说，如果你想声称你永远得不到正确的答案
Dialogue: 0,0:41:10.48,0:41:15.04,English,,0,0,0,,Then you're assuming that the kernel is always going to schedule the unsafe trajectory but
Dialogue: 0,0:41:10.48,0:41:15.04,Chinese,,0,0,0,,然后你假设内核总是要安排不安全的轨迹但是
Dialogue: 0,0:41:15.68,0:41:18.72,English,,0,0,0,,You can't assume that in fact it doesn't sometimes you just get lucky
Dialogue: 0,0:41:15.68,0:41:18.72,Chinese,,0,0,0,,你不能认为事实上它有时候你没有幸运
Dialogue: 0,0:41:23.70,0:41:29.96,English,,0,0,0,,And it turns out you have to call this function with a pretty big number in order to trip it up
Dialogue: 0,0:41:23.70,0:41:29.96,Chinese,,0,0,0,,事实证明，你必须用一个相当大的数字来调用这个函数才能将它绊倒
Dialogue: 0,0:41:32.06,0:41:33.92,English,,0,0,0,,So the it makes sense right
Dialogue: 0,0:41:32.06,0:41:33.92,Chinese,,0,0,0,,所以它是正确的
Dialogue: 0,0:41:34.92,0:41:39.14,English,,0,0,0,,If usually what the kernel does is that
Dialogue: 0,0:41:34.92,0:41:39.14,Chinese,,0,0,0,,通常，内核所做的就是那个
Dialogue: 0,0:41:40.30,0:41:42.28,English,,0,0,0,,I we can only schedule
Dialogue: 0,0:41:40.30,0:41:42.28,Chinese,,0,0,0,,我只能安排
Dialogue: 0,0:41:43.12,0:41:47.48,English,,0,0,0,,We can only reschedule a thread you know swap it out and schedule another thread in
Dialogue: 0,0:41:43.12,0:41:47.48,Chinese,,0,0,0,,我们只能重新安排你知道的线程交换它并安排另一个线程
Dialogue: 0,0:41:47.96,0:41:52.92,English,,0,0,0,,When there's some exception okay so that that passes control back to the kernel
Dialogue: 0,0:41:47.96,0:41:52.92,Chinese,,0,0,0,,当有一些异常可以将控制权传递给内核时
Dialogue: 0,0:41:54.70,0:41:59.76,English,,0,0,0,,So these exceptions are in two forms either calling system making system calls
Dialogue: 0,0:41:54.70,0:41:59.76,Chinese,,0,0,0,,因此，这些异常有两种形式，即调用系统进行系统调用
Dialogue: 0,0:41:59.96,0:42:03.38,English,,0,0,0,,So that'll trap into the kernel so that's a form of exception
Dialogue: 0,0:41:59.96,0:42:03.38,Chinese,,0,0,0,,所以这将陷入内核，这是一种异常形式
Dialogue: 0,0:42:03.86,0:42:09.50,English,,0,0,0,,Or the timer interrupts goes off which transfers control back to the kernel
Dialogue: 0,0:42:03.86,0:42:09.50,Chinese,,0,0,0,,或者定时器中断关闭，将控制权转移回内核
Dialogue: 0,0:42:10.36,0:42:14.88,English,,0,0,0,,So the timer is going off on intervals of like milliseconds
Dialogue: 0,0:42:10.36,0:42:14.88,Chinese,,0,0,0,,所以计时器会以相同的毫秒间隔开始运行
Dialogue: 0,0:42:16.44,0:42:20.76,English,,0,0,0,,Right so if we're just doing one iteration it in each thread
Dialogue: 0,0:42:16.44,0:42:20.76,Chinese,,0,0,0,,是的，如果我们只是在每个线程中进行一次迭代
Dialogue: 0,0:42:20.94,0:42:26.10,English,,0,0,0,,When a thread gets executed the chances are very low that the timer is going to go off
Dialogue: 0,0:42:20.94,0:42:26.10,Chinese,,0,0,0,,当线程被执行时，计时器即将关闭的可能性非常低
Dialogue: 0,0:42:27.14,0:42:30.56,English,,0,0,0,,While that thread is executing you know it's its little loop
Dialogue: 0,0:42:27.14,0:42:30.56,Chinese,,0,0,0,,当该线程正在执行时，你知道它是它的小循环
Dialogue: 0,0:42:32.86,0:42:35.12,English,,0,0,0,,But as we...and we're not making any system calls
Dialogue: 0,0:42:32.86,0:42:35.12,Chinese,,0,0,0,,但是，正如我们......我们没有进行任何系统调用
Dialogue: 0,0:42:35.28,0:42:42.30,English,,0,0,0,,Right so there's nothing that, there's nothing...we're not passing control back into the kernel ourselves
Dialogue: 0,0:42:35.28,0:42:42.30,Chinese,,0,0,0,,对，所以什么都没有，什么都没有......我们自己并没有将控制权传回内核
Dialogue: 0,0:42:43.14,0:42:47.68,English,,0,0,0,,So the only way the kernel is going to get access is if the timer interrupts goes off
Dialogue: 0,0:42:43.14,0:42:47.68,Chinese,,0,0,0,,因此，内核进入访问权限的唯一方法是定时器中断是否会中断
Dialogue: 0,0:42:48.86,0:42:51.28,English,,0,0,0,,So if we're doing a very small number of iterations
Dialogue: 0,0:42:48.86,0:42:51.28,Chinese,,0,0,0,,因此，如果我们进行的迭代次数非常少
Dialogue: 0,0:42:52.22,0:42:57.00,English,,0,0,0,,The probability that you know say here's the timer interval it's going off at intervals like this
Dialogue: 0,0:42:52.22,0:42:57.00,Chinese,,0,0,0,,你知道的概率在这里说的是它会以这样的间隔发生的定时器间隔
Dialogue: 0,0:42:58.10,0:43:01.86,English,,0,0,0,,Here this the probability we'd have to
Dialogue: 0,0:42:58.10,0:43:01.86,Chinese,,0,0,0,,这就是我们必须达到的概率
Dialogue: 0,0:43:02.60,0:43:08.94,English,,0,0,0,,That's thread would have to been scheduled right before a timer interrupts will go off or to interrupt that one or two iterations
Dialogue: 0,0:43:02.60,0:43:08.94,Chinese,,0,0,0,,在计时器中断将关闭或中断一次或两次迭代之前，必须安排该线程
Dialogue: 0,0:43:09.86,0:43:11.36,English,,0,0,0,,So it turns out we have to schedule
Dialogue: 0,0:43:09.86,0:43:11.36,Chinese,,0,0,0,,事实证明我们必须安排
Dialogue: 0,0:43:12.12,0:43:16.70,English,,0,0,0,,We have to call this function with a lot of within interrupts being fairly large
Dialogue: 0,0:43:12.12,0:43:16.70,Chinese,,0,0,0,,我们必须调用这个函数，其中很多中断都相当大
Dialogue: 0,0:43:17.28,0:43:22.52,English,,0,0,0,,So that the probability of the timer interrupts going off during that
Dialogue: 0,0:43:17.28,0:43:22.52,Chinese,,0,0,0,,这样定时器中断的概率会在此期间中断
Dialogue: 0,0:43:23.34,0:43:28.60,English,,0,0,0,,During that during that loop but gets increasingly large,that makes sense
Dialogue: 0,0:43:23.34,0:43:28.60,Chinese,,0,0,0,,在那个循环期间，但是变得越来越大，这是有道理的
Dialogue: 0,0:43:36.16,0:43:39.26,English,,0,0,0,,So the classic solution from this comes from the early 1960s
Dialogue: 0,0:43:36.16,0:43:39.26,Chinese,,0,0,0,,所以这个经典的解决方案来自20世纪60年代早期
Dialogue: 0,0:43:39.26,0:43:46.38,English,,0,0,0,,One of the most famous computer scientists is a dutchman named as Edsger Dijkstra
Dialogue: 0,0:43:39.26,0:43:46.38,Chinese,,0,0,0,,最着名的计算机科学家之一是荷兰人，名叫Edsger Dijkstra
Dialogue: 0,0:43:47.38,0:43:53.38,English,,0,0,0,,And he came up with the classical first solution to this problem which is what we're going to look at
Dialogue: 0,0:43:47.38,0:43:53.38,Chinese,,0,0,0,,他想出了这个问题的经典第一解决方案，这就是我们要看的内容
Dialogue: 0,0:43:54.18,0:43:57.60,English,,0,0,0,,Okay and it's still the first it's it's fundamental and very general purpose
Dialogue: 0,0:43:54.18,0:43:57.60,Chinese,,0,0,0,,好吧，它仍然是第一个它的基本和非常一般的目的
Dialogue: 0,0:43:57.60,0:44:01.76,English,,0,0,0,,And there's been many iterations and variations on this idea
Dialogue: 0,0:43:57.60,0:44:01.76,Chinese,,0,0,0,,这个想法有很多次迭代和变化
Dialogue: 0,0:44:02.74,0:44:08.00,English,,0,0,0,,But semaphores were the first and classic solution which we'll look at
Dialogue: 0,0:44:02.74,0:44:08.00,Chinese,,0,0,0,,但信号量是我们将要看到的第一个也是经典的解决方案
Dialogue: 0,0:44:11.38,0:44:17.58,English,,0,0,0,,Okay so a semaphore is a non-negative global integer
Dialogue: 0,0:44:11.38,0:44:17.58,Chinese,,0,0,0,,好的，所以信号量是一个非负的全局整数
Dialogue: 0,0:44:17.68,0:44:24.14,English,,0,0,0,,That's used as a synchronization variable by to kernel functions called P and V
Dialogue: 0,0:44:17.68,0:44:24.14,Chinese,,0,0,0,,它被用作称为P和V的内核函数的同步变量
Dialogue: 0,0:44:27.12,0:44:28.98,English,,0,0,0,,Our two system calls called P and V
Dialogue: 0,0:44:27.12,0:44:28.98,Chinese,,0,0,0,,我们的两个系统调用叫做P和V.
Dialogue: 0,0:44:32.38,0:44:36.60,English,,0,0,0,,These P and V are correspond to the dutch words
Dialogue: 0,0:44:32.38,0:44:36.60,Chinese,,0,0,0,,这些P和V对应于荷兰语
Dialogue: 0,0:44:38.74,0:44:43.72,English,,0,0,0,,But we just call them P and V right you just have to learn what they do
Dialogue: 0,0:44:38.74,0:44:43.72,Chinese,,0,0,0,,但我们只是称他们为P和V，你只需要了解他们的所作所为
Dialogue: 0,0:44:46.74,0:44:51.06,English,,0,0,0,,So each of these takes as an argument a semaphore
Dialogue: 0,0:44:46.74,0:44:51.06,Chinese,,0,0,0,,因此，每一个都以信号量作为参数
Dialogue: 0,0:44:52.84,0:44:56.82,English,,0,0,0,,And the P operation has the following semantics
Dialogue: 0,0:44:52.84,0:44:56.82,Chinese,,0,0,0,,并且P操作具有以下语义
Dialogue: 0,0:44:58.28,0:45:00.54,English,,0,0,0,,If s is nonzero
Dialogue: 0,0:44:58.28,0:45:00.54,Chinese,,0,0,0,,如果s不为零
Dialogue: 0,0:45:02.30,0:45:04.96,English,,0,0,0,,Then decrement it by 1 and return immediately
Dialogue: 0,0:45:02.30,0:45:04.96,Chinese,,0,0,0,,然后将其减1并立即返回
Dialogue: 0,0:45:07.68,0:45:10.60,English,,0,0,0,,And this test if it that it's nonzero
Dialogue: 0,0:45:07.68,0:45:10.60,Chinese,,0,0,0,,如果它是非零的，那么这个测试
Dialogue: 0,0:45:11.38,0:45:13.16,English,,0,0,0,,And the decrement occur atomically
Dialogue: 0,0:45:11.38,0:45:13.16,Chinese,,0,0,0,,并且减量以原子方式发生
Dialogue: 0,0:45:13.92,0:45:15.54,English,,0,0,0,,Okay so they'll never be interrupted
Dialogue: 0,0:45:13.92,0:45:15.54,Chinese,,0,0,0,,好的，所以他们永远不会被打断
Dialogue: 0,0:45:20.28,0:45:21.96,English,,0,0,0,,However if s is zero
Dialogue: 0,0:45:20.28,0:45:21.96,Chinese,,0,0,0,,但是如果s为零
Dialogue: 0,0:45:24.10,0:45:25.58,English,,0,0,0,,Then suspend this thread
Dialogue: 0,0:45:24.10,0:45:25.58,Chinese,,0,0,0,,然后暂停这个帖子
Dialogue: 0,0:45:26.84,0:45:29.40,English,,0,0,0,,Until s becomes nonzero
Dialogue: 0,0:45:26.84,0:45:29.40,Chinese,,0,0,0,,直到s变为非零
Dialogue: 0,0:45:31.10,0:45:34.26,English,,0,0,0,,And that thread then is restarted by a V operation
Dialogue: 0,0:45:31.10,0:45:34.26,Chinese,,0,0,0,,然后通过V操作重新启动该线程
Dialogue: 0,0:45:36.94,0:45:41.86,English,,0,0,0,,Okay so if p if the semaphore is zero,P just blocks
Dialogue: 0,0:45:36.94,0:45:41.86,Chinese,,0,0,0,,好的，如果p，如果信号量为零，P就会阻塞
Dialogue: 0,0:45:42.32,0:45:46.74,English,,0,0,0,,It just gets suspended until it gets restarted by a V operation
Dialogue: 0,0:45:42.32,0:45:46.74,Chinese,,0,0,0,,它会被暂停，直到它被V操作重新启动
Dialogue: 0,0:45:48.10,0:45:49.44,English,,0,0,0,,And then after it restarts
Dialogue: 0,0:45:48.10,0:45:49.44,Chinese,,0,0,0,,然后重新启动
Dialogue: 0,0:45:50.18,0:45:57.20,English,,0,0,0,,The P operation now can decrement s by one and return control to the caller
Dialogue: 0,0:45:50.18,0:45:57.20,Chinese,,0,0,0,,P操作现在可以减1并将控制权返回给调用者
Dialogue: 0,0:46:03.26,0:46:06.00,English,,0,0,0,,Okay the V operation just increments s by one
Dialogue: 0,0:46:03.26,0:46:06.00,Chinese,,0,0,0,,好吧，V操作只增加1
Dialogue: 0,0:46:06.92,0:46:13.60,English,,0,0,0,,And this increment unlike that count++ that we looked at just looked at this that increment occurs atomically
Dialogue: 0,0:46:06.92,0:46:13.60,Chinese,,0,0,0,,而且这个增量不同于我们看过的那个计数，只是看着这个增量以原子方式发生
Dialogue: 0,0:46:14.60,0:46:16.12,English,,0,0,0,,Okay so it can never be interrupted
Dialogue: 0,0:46:14.60,0:46:16.12,Chinese,,0,0,0,,好的，它永远不会被打断
Dialogue: 0,0:46:18.02,0:46:19.98,English,,0,0,0,,And then after it increments s
Dialogue: 0,0:46:18.02,0:46:19.98,Chinese,,0,0,0,,然后在它增加s之后
Dialogue: 0,0:46:21.06,0:46:24.84,English,,0,0,0,,It checks to see if there's any threads that are blocked in a P operation
Dialogue: 0,0:46:21.06,0:46:24.84,Chinese,,0,0,0,,它会检查是否有任何线程在P操作中被阻止
Dialogue: 0,0:46:25.26,0:46:30.66,English,,0,0,0,,So you can think of the kernel just keeps a queue of threads that are blocked in a P operation
Dialogue: 0,0:46:25.26,0:46:30.66,Chinese,,0,0,0,,所以你可以想到内核只保留一个在P操作中被阻塞的线程队列
Dialogue: 0,0:46:31.40,0:46:37.38,English,,0,0,0,,And the V operation after it increments s it checks that queue for any threads that were blocked
Dialogue: 0,0:46:31.40,0:46:37.38,Chinese,,0,0,0,,并且在V操作增加之后，它会检查该队列是否有被阻塞的线程
Dialogue: 0,0:46:38.50,0:46:41.44,English,,0,0,0,,Because when they did the P operation the semaphore was zero
Dialogue: 0,0:46:38.50,0:46:41.44,Chinese,,0,0,0,,因为当他们进行P操作时，信号量为零
Dialogue: 0,0:46:43.06,0:46:47.32,English,,0,0,0,,And then it restarts exactly one of those threads in some indeterminate order
Dialogue: 0,0:46:43.06,0:46:47.32,Chinese,,0,0,0,,然后它以某种不确定的顺序重新启动其中一个线程
Dialogue: 0,0:46:47.44,0:46:50.68,English,,0,0,0,,Okay in some order that you can't,you can't assume
Dialogue: 0,0:46:47.44,0:46:50.68,Chinese,,0,0,0,,好吧，按照某种顺序，你不能，你不能假设
Dialogue: 0,0:46:51.10,0:46:54.90,English,,0,0,0,,It just picks one using some selection algorithm
Dialogue: 0,0:46:51.10,0:46:54.90,Chinese,,0,0,0,,它只使用一些选择算法选择一个
Dialogue: 0,0:46:56.38,0:47:05.64,English,,0,0,0,,And it and then it it it unblocks the suspended  the suspended process
Dialogue: 0,0:46:56.38,0:47:05.64,Chinese,,0,0,0,,它然后它解除暂停的暂停过程
Dialogue: 0,0:47:07.88,0:47:11.16,English,,0,0,0,,Okay which then completes its P operation by decrementing yes
Dialogue: 0,0:47:07.88,0:47:11.16,Chinese,,0,0,0,,好的，然后通过递减是完成其P操作
Dialogue: 0,0:47:17.62,0:47:22.68,English,,0,0,0,,Okay this seems like really simple but it can be kind of hard to get your head around the first time you see it
Dialogue: 0,0:47:17.62,0:47:22.68,Chinese,,0,0,0,,好吧，这看起来很简单但是第一次看到它时可能很难让你头脑发热
Dialogue: 0,0:47:23.62,0:47:26.64,English,,0,0,0,,So are there any questions about P and V
Dialogue: 0,0:47:23.62,0:47:26.64,Chinese,,0,0,0,,关于P和V有什么问题吗？
Dialogue: 0,0:47:34.72,0:47:41.62,English,,0,0,0,,Okay so that the key idea that these definitions of P and V
Dialogue: 0,0:47:34.72,0:47:41.62,Chinese,,0,0,0,,好的，这就是P和V的这些定义的关键思想
Dialogue: 0,0:47:42.40,0:47:46.08,English,,0,0,0,,Is that it imposes an invariant on the semaphores
Dialogue: 0,0:47:42.40,0:47:46.08,Chinese,,0,0,0,,是不是它对信号量施加了不变量
Dialogue: 0,0:47:46.84,0:47:50.68,English,,0,0,0,,Called the semaphore invariant which is s which is that for a semaphore s
Dialogue: 0,0:47:46.84,0:47:50.68,Chinese,,0,0,0,,称为信号量不变量，这是信号量的信号量
Dialogue: 0,0:47:52.66,0:47:55.10,English,,0,0,0,,Being operated on by P and V operations
Dialogue: 0,0:47:52.66,0:47:55.10,Chinese,,0,0,0,,通过P和V操作进行操作
Dialogue: 0,0:47:55.64,0:47:57.52,English,,0,0,0,,s is always greater than or equal to zero
Dialogue: 0,0:47:55.64,0:47:57.52,Chinese,,0,0,0,,s总是大于或等于零
Dialogue: 0,0:48:01.12,0:48:02.66,English,,0,0,0,,And that doesn't seem very exciting
Dialogue: 0,0:48:01.12,0:48:02.66,Chinese,,0,0,0,,这似乎并不令人兴奋
Dialogue: 0,0:48:03.82,0:48:11.40,English,,0,0,0,,But it turns out this is a very useful property that will allow us to enforce mutual exclusion on these critical sections
Dialogue: 0,0:48:03.82,0:48:11.40,Chinese,,0,0,0,,但事实证明，这是一个非常有用的属性，可以让我们在这些关键部分强制互斥
Dialogue: 0,0:48:13.64,0:48:18.24,English,,0,0,0,,So the P and V operations are provided by P threads
Dialogue: 0,0:48:13.64,0:48:18.24,Chinese,,0,0,0,,所以P和V操作由P线程提供
Dialogue: 0,0:48:19.24,0:48:21.28,English,,0,0,0,,In the form of three functions
Dialogue: 0,0:48:19.24,0:48:21.28,Chinese,,0,0,0,,以三种功能的形式
Dialogue: 0,0:48:21.42,0:48:25.50,English,,0,0,0,,There's a sem_init functions which initializes the semaphore to some value
Dialogue: 0,0:48:21.42,0:48:25.50,Chinese,,0,0,0,,有一个sem_init函数可以将信号量初始化为某个值
Dialogue: 0,0:48:26.22,0:48:31.92,English,,0,0,0,,Okay so semaphore is can be initialized to any value greater than or equal to zero
Dialogue: 0,0:48:26.22,0:48:31.92,Chinese,,0,0,0,,好的，所以信号量可以初始化为任何大于或等于零的值
Dialogue: 0,0:48:34.04,0:48:39.86,English,,0,0,0,,sem_wait is the P operation and sem_post is the V operation
Dialogue: 0,0:48:34.04,0:48:39.86,Chinese,,0,0,0,,sem_wait是P操作，sem_post是V操作
Dialogue: 0,0:48:41.88,0:48:44.38,English,,0,0,0,,Okay and because I'm old-school
Dialogue: 0,0:48:41.88,0:48:44.38,Chinese,,0,0,0,,好的，因为我老了
Dialogue: 0,0:48:45.38,0:48:51.48,English,,0,0,0,,I provide wrapper functions for those in your cssapp.h file called P and V
Dialogue: 0,0:48:45.38,0:48:51.48,Chinese,,0,0,0,,我为你的cssapp.h文件中的P和V提供了包装函数
Dialogue: 0,0:48:52.72,0:48:53.86,English,,0,0,0,,Okay it's also more compact to
Dialogue: 0,0:48:52.72,0:48:53.86,Chinese,,0,0,0,,好吧，它也更紧凑
Dialogue: 0,0:49:00.20,0:49:07.02,English,,0,0,0,,Okay so recall a buggy program called badcnt.c
Dialogue: 0,0:49:00.20,0:49:07.02,Chinese,,0,0,0,,好的，回想起一个名为badcnt.c的错误程序
Dialogue: 0,0:49:07.80,0:49:11.76,English,,0,0,0,,Which was giving us the wrong answers for count
Dialogue: 0,0:49:07.80,0:49:11.76,Chinese,,0,0,0,,这给了我们错误的答案
Dialogue: 0,0:49:13.30,0:49:15.82,English,,0,0,0,,So how do we use semaphores to fix this program
Dialogue: 0,0:49:13.30,0:49:15.82,Chinese,,0,0,0,,那么我们如何使用信号量来修复这个程序
Dialogue: 0,0:49:18.92,0:49:21.46,English,,0,0,0,,So the basic idea is to create a semaphore
Dialogue: 0,0:49:18.92,0:49:21.46,Chinese,,0,0,0,,所以基本的想法是创建一个信号量
Dialogue: 0,0:49:22.20,0:49:23.86,English,,0,0,0,,Which is initialized to 1
Dialogue: 0,0:49:22.20,0:49:23.86,Chinese,,0,0,0,,哪个被初始化为1
Dialogue: 0,0:49:25.70,0:49:29.80,English,,0,0,0,,And so by definition we'll call any semaphore which is initialized to 1
Dialogue: 0,0:49:25.70,0:49:29.80,Chinese,,0,0,0,,因此根据定义，我们将调用任何初始化为1的信号量
Dialogue: 0,0:49:29.82,0:49:33.36,English,,0,0,0,,That's used for to provide mutual exclusion we'll call that a mutex
Dialogue: 0,0:49:29.82,0:49:33.36,Chinese,,0,0,0,,这用于提供互斥，我们称之为互斥
Dialogue: 0,0:49:34.98,0:49:38.06,English,,0,0,0,,Okay and this goes back to the early Dijkstra papers
Dialogue: 0,0:49:34.98,0:49:38.06,Chinese,,0,0,0,,好的，这可以追溯到Dijkstra早期的论文
Dialogue: 0,0:49:39.62,0:49:47.62,English,,0,0,0,,So we'll associate a unique mutex initialize to 1 for each shared variable in our program
Dialogue: 0,0:49:39.62,0:49:47.62,Chinese,,0,0,0,,因此，我们将为程序中的每个共享变量将唯一的互斥锁初始化关联为1
Dialogue: 0,0:49:48.98,0:49:53.80,English,,0,0,0,,So in this case count,we have count,so we have one shared variable that we're concerned about
Dialogue: 0,0:49:48.98,0:49:53.80,Chinese,,0,0,0,,所以在这种情况下，我们有计数，所以我们有一个我们关注的共享变量
Dialogue: 0,0:49:54.42,0:49:57.76,English,,0,0,0,,So we'll create one new text that will call mutex
Dialogue: 0,0:49:54.42,0:49:57.76,Chinese,,0,0,0,,因此，我们将创建一个称为互斥锁的新文本
Dialogue: 0,0:49:59.00,0:50:03.48,English,,0,0,0,,And then you surround the critical section with respect to count
Dialogue: 0,0:49:59.00,0:50:03.48,Chinese,,0,0,0,,然后围绕计数围绕关键部分
Dialogue: 0,0:50:04.20,0:50:10.94,English,,0,0,0,,With P, you call P then you execute the critical section and then you call V
Dialogue: 0,0:50:04.20,0:50:10.94,Chinese,,0,0,0,,使用P，你调用P然后执行临界区，然后调用V.
Dialogue: 0,0:50:15.44,0:50:19.20,English,,0,0,0,,Now there's some terminology we'll use when we talk about semaphores
Dialogue: 0,0:50:15.44,0:50:19.20,Chinese,,0,0,0,,现在我们在讨论信号量时会使用一些术语
Dialogue: 0,0:50:20.08,0:50:25.26,English,,0,0,0,,So a binary semaphore is the semaphore whose value is always 0 1
Dialogue: 0,0:50:20.08,0:50:25.26,Chinese,,0,0,0,,所以二进制信号量是信号量，其值始终为0 1
Dialogue: 0,0:50:25.72,0:50:31.08,English,,0,0,0,,And then a mutex is this sort is a binary semaphore that's being used to for mutual exclusion
Dialogue: 0,0:50:25.72,0:50:31.08,Chinese,,0,0,0,,然后一个互斥量就是这种二进制信号量，它被用来互斥
Dialogue: 0,0:50:33.42,0:50:35.44,English,,0,0,0,,The P operation is called locking the mutex
Dialogue: 0,0:50:33.42,0:50:35.44,Chinese,,0,0,0,,P操作称为锁定互斥锁
Dialogue: 0,0:50:37.74,0:50:41.32,English,,0,0,0,,Will refer to a V is sometimes unlocking or releasing the mutex
Dialogue: 0,0:50:37.74,0:50:41.32,Chinese,,0,0,0,,将参考V有时解锁或释放互斥锁
Dialogue: 0,0:50:42.52,0:50:50.38,English,,0,0,0,,And if a process is holding the mutex then that means it's been locked but not released
Dialogue: 0,0:50:42.52,0:50:50.38,Chinese,,0,0,0,,如果进程持有互斥锁，那么这意味着它已被锁定但未被释放
Dialogue: 0,0:50:53.26,0:50:56.80,English,,0,0,0,,So mutexes and binary semaphore s are always initialized to 1
Dialogue: 0,0:50:53.26,0:50:56.80,Chinese,,0,0,0,,因此，互斥量和二进制信号量始终初始化为1
Dialogue: 0,0:50:57.20,0:51:02.98,English,,0,0,0,,Accounting semaphore and the mutex is used for mutual exclusion
Dialogue: 0,0:50:57.20,0:51:02.98,Chinese,,0,0,0,,会计信号量和互斥量用于互斥
Dialogue: 0,0:51:03.00,0:51:06.58,English,,0,0,0,,But you can also use semaphores to count sort of events in the system
Dialogue: 0,0:51:03.00,0:51:06.58,Chinese,,0,0,0,,但你也可以使用信号量来计算系统中的各种事件
Dialogue: 0,0:51:07.80,0:51:15.98,English,,0,0,0,,And often times for those accounting semaphores have sort of non values that are greater than 1
Dialogue: 0,0:51:07.80,0:51:15.98,Chinese,,0,0,0,,对于那些会计信号量，通常有一些非大于1的非值
Dialogue: 0,0:51:19.74,0:51:21.30,English,,0,0,0,,Okay so for mutual exclusion
Dialogue: 0,0:51:19.74,0:51:21.30,Chinese,,0,0,0,,好吧，互相排斥
Dialogue: 0,0:51:23.66,0:51:28.94,English,,0,0,0,,We'll to fix our program we create a new program called goodcnt.c
Dialogue: 0,0:51:23.66,0:51:28.94,Chinese,,0,0,0,,我们将修复我们的程序，我们创建一个名为goodcnt.c的新程序
Dialogue: 0,0:51:30.46,0:51:32.70,English,,0,0,0,,And here we initialize a mutex
Dialogue: 0,0:51:30.46,0:51:32.70,Chinese,,0,0,0,,在这里我们初始化一个互斥锁
Dialogue: 0,0:51:33.72,0:51:36.40,English,,0,0,0,,Or we create a mutex and initialize it to 1
Dialogue: 0,0:51:33.72,0:51:36.40,Chinese,,0,0,0,,或者我们创建一个互斥锁并将其初始化为1
Dialogue: 0,0:51:38.72,0:51:43.88,English,,0,0,0,,And then we surround the critical section which is the 3 assembly language instructions
Dialogue: 0,0:51:38.72,0:51:43.88,Chinese,,0,0,0,,然后我们围绕着关键部分，即3个汇编语言指令
Dialogue: 0,0:51:44.36,0:51:47.68,English,,0,0,0,,Embodied that implement this cnt++ instruction
Dialogue: 0,0:51:44.36,0:51:47.68,Chinese,,0,0,0,,体现了实现这个cnt ++指令
Dialogue: 0,0:51:48.42,0:51:51.36,English,,0,0,0,,We surround it with a P followed by it by a V
Dialogue: 0,0:51:48.42,0:51:51.36,Chinese,,0,0,0,,我们用一个P围绕它，然后用V围绕它
Dialogue: 0,0:51:54.28,0:51:57.24,English,,0,0,0,,And if we do that we always get the right answer
Dialogue: 0,0:51:54.28,0:51:57.24,Chinese,,0,0,0,,如果我们这样做，我们总能得到正确的答案
Dialogue: 0,0:52:00.52,0:52:03.46,English,,0,0,0,,But you know P&V are system calls
Dialogue: 0,0:52:00.52,0:52:03.46,Chinese,,0,0,0,,但是你知道P＆V是系统调用
Dialogue: 0,0:52:03.99,0:52:05.46,English,,0,0,0,,So there's overhead associated with these
Dialogue: 0,0:52:03.99,0:52:05.46,Chinese,,0,0,0,,因此，与这些相关的开销
Dialogue: 0,0:52:05.46,0:52:06.28,English,,0,0,0,,So they're not free
Dialogue: 0,0:52:05.46,0:52:06.28,Chinese,,0,0,0,,所以他们不是自由的
Dialogue: 0,0:52:06.48,0:52:11.84,English,,0,0,0,,In fact they're orders of magnitude this program runs two orders of magnitude slower than the incorrect buggy version
Dialogue: 0,0:52:06.48,0:52:11.84,Chinese,,0,0,0,,事实上，这个程序比不正确的错误版本慢了两个数量级
Dialogue: 0,0:52:13.56,0:52:15.60,English,,0,0,0,,All right so so why do these mutex work
Dialogue: 0,0:52:13.56,0:52:15.60,Chinese,,0,0,0,,好吧那么为什么这些互斥体会起作用呢
Dialogue: 0,0:52:19.98,0:52:26.34,English,,0,0,0,,So here we've got a progress graph now where we've decorated a program with P and V operations
Dialogue: 0,0:52:19.98,0:52:26.34,Chinese,,0,0,0,,所以现在我们已经有了一个进度图，我们用P和V操作装饰了一个程序
Dialogue: 0,0:52:26.34,0:52:33.86,English,,0,0,0,,So we put the P before the critical section we execute the critical section and then we call V
Dialogue: 0,0:52:26.34,0:52:33.86,Chinese,,0,0,0,,所以我们把P放在临界区之前我们执行临界区然后我们调用V.
Dialogue: 0,0:52:35.96,0:52:39.22,English,,0,0,0,,And now if you were to look you remember P and V,P increments
Dialogue: 0,0:52:35.96,0:52:39.22,Chinese,,0,0,0,,现在，如果你看起来你记得P和V，P会增加
Dialogue: 0,0:52:40.52,0:52:44.72,English,,0,0,0,,The sum of P decrement the semaphore V increments of semaphore
Dialogue: 0,0:52:40.52,0:52:44.72,Chinese,,0,0,0,,P的总和递减信号量的信号量V增量
Dialogue: 0,0:52:45.68,0:52:53.54,English,,0,0,0,,So if you were just to look at the value of that semaphore for every point  in the execution state space
Dialogue: 0,0:52:45.68,0:52:53.54,Chinese,,0,0,0,,因此，如果你只是查看执行状态空间中每个点的信号量值
Dialogue: 0,0:52:54.90,0:52:57.94,English,,0,0,0,,You'd get these,you'd get these values
Dialogue: 0,0:52:54.90,0:52:57.94,Chinese,,0,0,0,,你会得到这些，你会得到这些价值
Dialogue: 0,0:52:57.96,0:53:03.12,English,,0,0,0,,So here we initialize the semaphore at the origin we initialized it to 1
Dialogue: 0,0:52:57.96,0:53:03.12,Chinese,,0,0,0,,所以在这里我们初始化我们初始化为1的原点的信号量
Dialogue: 0,0:53:03.14,0:53:10.16,English,,0,0,0,,So the value of a semaphore at the origin is 1
Dialogue: 0,0:53:03.14,0:53:10.16,Chinese,,0,0,0,,因此，原点信号量的值为1
Dialogue: 0,0:53:11.38,0:53:13.10,English,,0,0,0,,And let's say we just move along
Dialogue: 0,0:53:11.38,0:53:13.10,Chinese,,0,0,0,,让我们说我们只是继续前进
Dialogue: 0,0:53:13.12,0:53:14.78,English,,0,0,0,,So we're just executing thread 1
Dialogue: 0,0:53:13.12,0:53:14.78,Chinese,,0,0,0,,所以我们只是执行线程1
Dialogue: 0,0:53:14.78,0:53:17.18,English,,0,0,0,,So after H(1) the semaphore is 1
Dialogue: 0,0:53:14.78,0:53:17.18,Chinese,,0,0,0,,因此，在H（1）之后，信号量为1
Dialogue: 0,0:53:19.02,0:53:25.04,English,,0,0,0,,We do the P the semaphore is 1,so P just decrement sit and it proceeds
Dialogue: 0,0:53:19.02,0:53:25.04,Chinese,,0,0,0,,我们做P信号量是1，所以P只是递减坐下来继续
Dialogue: 0,0:53:25.50,0:53:28.76,English,,0,0,0,,So now the semaphore value becomes 0
Dialogue: 0,0:53:25.50,0:53:28.76,Chinese,,0,0,0,,所以现在信号量值变为0
Dialogue: 0,0:53:29.56,0:53:33.02,English,,0,0,0,,And it remains zero until we execute the V
Dialogue: 0,0:53:29.56,0:53:33.02,Chinese,,0,0,0,,在我们执行V之前它一直保持为零
Dialogue: 0,0:53:33.72,0:53:35.60,English,,0,0,0,,And when we finished executing the V
Dialogue: 0,0:53:33.72,0:53:35.60,Chinese,,0,0,0,,当我们完成执行V
Dialogue: 0,0:53:36.44,0:53:38.38,English,,0,0,0,,The semaphore now is 1 again
Dialogue: 0,0:53:36.44,0:53:38.38,Chinese,,0,0,0,,信号量现在又是1
Dialogue: 0,0:53:40.10,0:53:42.10,English,,0,0,0,,Okay so if we go through a similar reasoning
Dialogue: 0,0:53:40.10,0:53:42.10,Chinese,,0,0,0,,好的，如果我们经历类似的推理
Dialogue: 0,0:53:42.90,0:53:48.18,English,,0,0,0,,If we look at the trajectory to get to any point in this state space
Dialogue: 0,0:53:42.90,0:53:48.18,Chinese,,0,0,0,,如果我们看一下这个状态空间中任何一点的轨迹
Dialogue: 0,0:53:48.22,0:53:52.34,English,,0,0,0,,So let's say this point right here
Dialogue: 0,0:53:48.22,0:53:52.34,Chinese,,0,0,0,,所以我们在这里说这一点
Dialogue: 0,0:53:54.86,0:54:02.78,English,,0,0,0,,So to get there we could execute thread 1 up to this point  finish the L(1)
Dialogue: 0,0:53:54.86,0:54:02.78,Chinese,,0,0,0,,所以到那里我们可以执行线程1到此为止完成L（1）
Dialogue: 0,0:54:04.10,0:54:06.02,English,,0,0,0,,And then execute H(2)
Dialogue: 0,0:54:04.10,0:54:06.02,Chinese,,0,0,0,,然后执行H（2）
Dialogue: 0,0:54:07.38,0:54:10.68,English,,0,0,0,,And then do the at this point the semaphore is 0
Dialogue: 0,0:54:07.38,0:54:10.68,Chinese,,0,0,0,,然后在这一点上做信号量为0
Dialogue: 0,0:54:13.00,0:54:17.04,English,,0,0,0,,And then P decrements the semaphore so now it's -1
Dialogue: 0,0:54:13.00,0:54:17.04,Chinese,,0,0,0,,然后P减少信号量，所以现在它是-1
Dialogue: 0,0:54:17.86,0:54:20.38,English,,0,0,0,,But that's impossible that can't happen
Dialogue: 0,0:54:17.86,0:54:20.38,Chinese,,0,0,0,,但那不可能发生
Dialogue: 0,0:54:21.04,0:54:25.62,English,,0,0,0,,Because P blocks, remember if the semaphore is 0 P blocks
Dialogue: 0,0:54:21.04,0:54:25.62,Chinese,,0,0,0,,因为P阻塞，请记住信号量是否为0 P块
Dialogue: 0,0:54:26.36,0:54:27.28,English,,0,0,0,,It doesn't decrement
Dialogue: 0,0:54:26.36,0:54:27.28,Chinese,,0,0,0,,它没有减少
Dialogue: 0,0:54:28.40,0:54:35.70,English,,0,0,0,,It okay so the semantics of the P operation prohibits this transition
Dialogue: 0,0:54:28.40,0:54:35.70,Chinese,,0,0,0,,没关系，所以P操作的语义禁止这种转换
Dialogue: 0,0:54:36.34,0:54:43.06,English,,0,0,0,,It prohibits this transition to the state where the semaphore is zero to a state where it would be -1
Dialogue: 0,0:54:36.34,0:54:43.06,Chinese,,0,0,0,,它禁止向信号量为零的状态转换到-1为-1的状态
Dialogue: 0,0:54:46.78,0:54:53.82,English,,0,0,0,,And so it creates what we call a forbidden region so these points in the state space
Dialogue: 0,0:54:46.78,0:54:53.82,Chinese,,0,0,0,,因此它创造了我们所谓的禁区，因此这些指向了状态空间
Dialogue: 0,0:54:54.84,0:55:01.20,English,,0,0,0,,Where the semaphore would have a value of -1 are are infeasible
Dialogue: 0,0:54:54.84,0:55:01.20,Chinese,,0,0,0,,信号量值为-1的地方是不可行的
Dialogue: 0,0:55:01.92,0:55:06.30,English,,0,0,0,,That can never be reached by the definition of P and V
Dialogue: 0,0:55:01.92,0:55:06.30,Chinese,,0,0,0,,P和V的定义永远无法达到
Dialogue: 0,0:55:07.92,0:55:13.34,English,,0,0,0,,Ok so this forms a forbidden region around the unsafe region
Dialogue: 0,0:55:07.92,0:55:13.34,Chinese,,0,0,0,,好的，这就形成了一个不安全区域周围的禁区
Dialogue: 0,0:55:13.88,0:55:20.92,English,,0,0,0,,And in doing so provides mutually exclusive access to the critical sections in each thread
Dialogue: 0,0:55:13.88,0:55:20.92,Chinese,,0,0,0,,这样做可以提供对每个线程中关键部分的互斥访问
Dialogue: 0,0:55:22.04,0:55:22.58,English,,0,0,0,,Okay so if
Dialogue: 0,0:55:22.04,0:55:22.58,Chinese,,0,0,0,,好的，如果
Dialogue: 0,0:55:25.50,0:55:33.10,English,,0,0,0,,So this is the fundamental reason why P(s) and V(s)  can be used to provide mutually exclusive access
Dialogue: 0,0:55:25.50,0:55:33.10,Chinese,,0,0,0,,因此，这是P（s）和V（s）可用于提供互斥访问的根本原因
Dialogue: 0,0:55:36.96,0:55:37.98,English,,0,0,0,,So many questions on this
Dialogue: 0,0:55:36.96,0:55:37.98,Chinese,,0,0,0,,这么多问题
Dialogue: 0,0:55:41.20,0:55:43.60,English,,0,0,0,,I explained it so clearly that there's no questions
Dialogue: 0,0:55:41.20,0:55:43.60,Chinese,,0,0,0,,我解释得很清楚，没有问题
Dialogue: 0,0:55:48.50,0:55:54.02,English,,0,0,0,,All right good well you get to go...you get to leave early then work on your malloc lab
Dialogue: 0,0:55:48.50,0:55:54.02,Chinese,,0,0,0,,好的，你可以去...你早点离开然后在你的malloc实验室工作
Dialogue: 0,0:55:54.86,0:55:55.52,English,,0,0,0,,So
Dialogue: 0,0:55:54.86,0:55:55.52,Chinese,,0,0,0,,所以
Dialogue: 0,0:55:57.56,0:55:58.80,English,,0,0,0,,All right so
Dialogue: 0,0:55:57.56,0:55:58.80,Chinese,,0,0,0,,好的
Dialogue: 0,0:55:59.64,0:56:04.04,English,,0,0,0,,We'll see you Monday we're going to look at sort of some advanced topics
Dialogue: 0,0:55:59.64,0:56:04.04,Chinese,,0,0,0,,我们将在周一见到你，我们将会看到一些高级主题
Dialogue: 0,0:56:04.06,0:56:06.92,English,,0,0,0,,This was like, first introduction to synchronization
Dialogue: 0,0:56:04.06,0:56:06.92,Chinese,,0,0,0,,这就像首先介绍同步一样
Dialogue: 0,0:56:07.36,0:56:12.10,English,,0,0,0,,On Tuesday we'll look at more advanced topics in synchronization in ways
Dialogue: 0,0:56:07.36,0:56:12.10,Chinese,,0,0,0,,周二，我们将以同步方式查看更高级的主题
Dialogue: 0,0:56:12.20,0:56:13.96,English,,0,0,0,,Ways that you can use semaphores for to
Dialogue: 0,0:56:12.20,0:56:13.96,Chinese,,0,0,0,,你可以使用信号量的方式
Dialogue: 0,0:56:14.50,0:56:19.20,English,,0,0,0,,Provide other more interests other interesting kinds of synchronization for your programs
Dialogue: 0,0:56:14.50,0:56:19.20,Chinese,,0,0,0,,为你的程序提供其他有趣的同步其他更多兴趣
Dialogue: 0,0:56:19.76,0:56:20.54,English,,0,0,0,,Okay
Dialogue: 0,0:56:19.76,0:56:20.54,Chinese,,0,0,0,,好的
