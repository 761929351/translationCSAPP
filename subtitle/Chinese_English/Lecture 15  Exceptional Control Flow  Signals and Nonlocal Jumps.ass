[Script Info]
; Script generated by Aegisub r8942
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video File: ../../../../Desktop/csapp/Lecture 15  Exceptional Control Flow  Signals and Nonlocal Jumps.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 845
Active Line: 858
Video Position: 142535

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.06,0:00:01.94,English,,0,0,0,,Good afternoon everybody welcome
Dialogue: 0,0:00:00.06,0:00:01.94,Chinese,,0,0,0,,大家下午好，欢迎大家
Dialogue: 0,0:00:02.86,0:00:03.68,English,,0,0,0,,Good to see you
Dialogue: 0,0:00:02.86,0:00:03.68,Chinese,,0,0,0,,很高兴见到你
Dialogue: 0,0:00:05.02,0:00:08.52,English,,0,0,0,,Today we're going to continue our study of exceptional control flow
Dialogue: 0,0:00:05.02,0:00:08.52,Chinese,,0,0,0,,今天我们将继续研究特殊的控制流程
Dialogue: 0,0:00:09.56,0:00:16.24,English,,0,0,0,,By looking at some higher level mechanisms known as Linux signals and C nonlocal jumps
Dialogue: 0,0:00:09.56,0:00:16.24,Chinese,,0,0,0,,通过查看一些称为Linux信号和C非本地跳转的更高级别机制
Dialogue: 0,0:00:16.90,0:00:21.42,English,,0,0,0,,Now we're going to spend most of our time looking at signals
Dialogue: 0,0:00:16.90,0:00:21.42,Chinese,,0,0,0,,现在我们将花费大部分时间来研究信号
Dialogue: 0,0:00:21.62,0:00:26.60,English,,0,0,0,,Because they have a lot of subtleties the semantics can be kind of confusing
Dialogue: 0,0:00:21.62,0:00:26.60,Chinese,,0,0,0,,因为它们有很多细微之处，语义可能会让人感到困惑
Dialogue: 0,0:00:26.60,0:00:28.62,English,,0,0,0,,So we're going to we're going to spend most of our time there
Dialogue: 0,0:00:26.60,0:00:28.62,Chinese,,0,0,0,,所以我们要去那里度过大部分时间
Dialogue: 0,0:00:29.36,0:00:33.70,English,,0,0,0,,And I'll mention the idea of nonlocal jumps but
Dialogue: 0,0:00:29.36,0:00:33.70,Chinese,,0,0,0,,我会提到非局部跳跃的想法但是
Dialogue: 0,0:00:36.08,0:00:38.70,English,,0,0,0,,For details on those you'll want to look in your textbook
Dialogue: 0,0:00:36.08,0:00:38.70,Chinese,,0,0,0,,有关你希望在教​​科书中查看的内容的详细信息
Dialogue: 0,0:00:38.84,0:00:43.40,English,,0,0,0,,And in the slides at the supplemental slides at the end of this the slide deck
Dialogue: 0,0:00:38.84,0:00:43.40,Chinese,,0,0,0,,并在幻灯片底部的补充幻灯片的幻灯片中
Dialogue: 0,0:00:45.64,0:00:48.06,English,,0,0,0,,Now to motivate the notion of signals
Dialogue: 0,0:00:45.64,0:00:48.06,Chinese,,0,0,0,,现在要激发信号的概念
Dialogue: 0,0:00:49.00,0:00:54.40,English,,0,0,0,,I want to talk a little bit about shell programs
Dialogue: 0,0:00:49.00,0:00:54.40,Chinese,,0,0,0,,我想谈谈shell程序
Dialogue: 0,0:00:56.08,0:01:01.54,English,,0,0,0,,Now as we mentioned last time there's only one way to create processes on a Linux system
Dialogue: 0,0:00:56.08,0:01:01.54,Chinese,,0,0,0,,现在正如我们上次提到的，只有一种方法可以在Linux系统上创建进程
Dialogue: 0,0:01:01.56,0:01:03.24,English,,0,0,0,,And that's using the fork call
Dialogue: 0,0:01:01.56,0:01:03.24,Chinese,,0,0,0,,那就是使用fork调用
Dialogue: 0,0:01:04.14,0:01:09.84,English,,0,0,0,,In fact the all of the processes on the system actually form a hierarchy
Dialogue: 0,0:01:04.14,0:01:09.84,Chinese,,0,0,0,,实际上，系统上的所有进程实际上构成了一个层次结构
Dialogue: 0,0:01:09.88,0:01:15.68,English,,0,0,0,,So that the very first process created when you boot the system up is the init process
Dialogue: 0,0:01:09.88,0:01:15.68,Chinese,,0,0,0,,因此，启动系统时创建的第一个进程是init进程
Dialogue: 0,0:01:16.08,0:01:17.92,English,,0,0,0,,Which has a process id of 1
Dialogue: 0,0:01:16.08,0:01:17.92,Chinese,,0,0,0,,其进程ID为1
Dialogue: 0,0:01:18.48,0:01:23.81,English,,0,0,0,,And then all other processes on the system are descendants of that of that init process
Dialogue: 0,0:01:18.48,0:01:23.81,Chinese,,0,0,0,,然后系统上的所有其他进程都是该init进程的后代
Dialogue: 0,0:01:24.68,0:01:29.04,English,,0,0,0,,Now the init process when it starts up it creates daemons
Dialogue: 0,0:01:24.68,0:01:29.04,Chinese,,0,0,0,,现在init进程启动时会创建守护进程
Dialogue: 0,0:01:29.76,0:01:33.38,English,,0,0,0,,Which are long-running programs that provide services typically
Dialogue: 0,0:01:29.76,0:01:33.38,Chinese,,0,0,0,,哪些是长期运行的程序，通常提供服务
Dialogue: 0,0:01:33.42,0:01:41.44,English,,0,0,0,,So for example web server it other kinds of services that you always want running on the system
Dialogue: 0,0:01:33.42,0:01:41.44,Chinese,,0,0,0,,因此，例如Web服务器，你总是希望在系统上运行的其他类型的服务
Dialogue: 0,0:01:42.26,0:01:45.90,English,,0,0,0,,And then eventually it creates login so called login shells
Dialogue: 0,0:01:42.26,0:01:45.90,Chinese,,0,0,0,,然后最终它创建登录所谓的登录shell
Dialogue: 0,0:01:46.50,0:01:49.34,English,,0,0,0,,Which provide the command-line interface to users
Dialogue: 0,0:01:46.50,0:01:49.34,Chinese,,0,0,0,,其中为用户提供命令行界面
Dialogue: 0,0:01:50.10,0:01:52.48,English,,0,0,0,,So when you login a Linux system
Dialogue: 0,0:01:50.10,0:01:52.48,Chinese,,0,0,0,,所以当你登录Linux系统时
Dialogue: 0,0:01:53.10,0:01:55.84,English,,0,0,0,,What you eventually get to is a login shell
Dialogue: 0,0:01:53.10,0:01:55.84,Chinese,,0,0,0,,你最终得到的是一个登录shell
Dialogue: 0,0:01:56.12,0:01:58.98,English,,0,0,0,,That's expecting you to type commands
Dialogue: 0,0:01:56.12,0:01:58.98,Chinese,,0,0,0,,那是期待你输入命令
Dialogue: 0,0:02:01.72,0:02:07.36,English,,0,0,0,,Now the login shells execute programs on your behalf
Dialogue: 0,0:02:01.72,0:02:07.36,Chinese,,0,0,0,,现在登录shell代表你执行程序
Dialogue: 0,0:02:08.52,0:02:11.92,English,,0,0,0,,So when we type something into the shell
Dialogue: 0,0:02:08.52,0:02:11.92,Chinese,,0,0,0,,所以当我们在shell中输入内容时
Dialogue: 0,0:02:13.00,0:02:21.62,English,,0,0,0,,Say we type the ls command we're asking the shell to run the executable program called ls
Dialogue: 0,0:02:13.00,0:02:21.62,Chinese,,0,0,0,,假设我们输入ls命令，我们要求shell运行名为ls的可执行程序
Dialogue: 0,0:02:22.80,0:02:25.68,English,,0,0,0,,And so what the shell will do,is it will create a child
Dialogue: 0,0:02:22.80,0:02:25.68,Chinese,,0,0,0,,那么shell会做什么，它会创造一个孩子
Dialogue: 0,0:02:26.38,0:02:30.16,English,,0,0,0,,And then it will execute ls within that child process
Dialogue: 0,0:02:26.38,0:02:30.16,Chinese,,0,0,0,,然后它将在该子进程中执行ls
Dialogue: 0,0:02:31.12,0:02:37.28,English,,0,0,0,,And it's possible that that process may create other child processes
Dialogue: 0,0:02:31.12,0:02:37.28,Chinese,,0,0,0,,并且该过程可能会创建其他子进程
Dialogue: 0,0:02:40.36,0:02:44.34,English,,0,0,0,,So a shell is an application program no different from any other program
Dialogue: 0,0:02:40.36,0:02:44.34,Chinese,,0,0,0,,所以shell是一个与任何其他程序没有区别的应用程序
Dialogue: 0,0:02:45.02,0:02:47.78,English,,0,0,0,,That executes programs on the behalf of users
Dialogue: 0,0:02:45.02,0:02:47.78,Chinese,,0,0,0,,这代表用户执行程序
Dialogue: 0,0:02:49.62,0:02:52.56,English,,0,0,0,,Okay the default shell for Linux is called bash
Dialogue: 0,0:02:49.62,0:02:52.56,Chinese,,0,0,0,,好的Linux的默认shell叫做bash
Dialogue: 0,0:02:52.72,0:03:01.66,English,,0,0,0,,But there's other shells that that were created on earlier with earlier versions of UNIX
Dialogue: 0,0:02:52.72,0:03:01.66,Chinese,,0,0,0,,但是早期版本的UNIX早期创建了其他shell
Dialogue: 0,0:03:02.26,0:03:07.38,English,,0,0,0,,Sh was the original shell called the Bourne shell because it was created by Stephen Bourne
Dialogue: 0,0:03:02.26,0:03:07.38,Chinese,,0,0,0,,Sh是原始的shell，称为Bourne shell，因为它是由Stephen Bourne创建的
Dialogue: 0,0:03:07.82,0:03:10.26,English,,0,0,0,,And when Berkeley came out with their distribution of UNIX
Dialogue: 0,0:03:07.82,0:03:10.26,Chinese,,0,0,0,,当伯克利推出他们的UNIX发行版时
Dialogue: 0,0:03:10.72,0:03:13.18,English,,0,0,0,,They created a shell called the csh
Dialogue: 0,0:03:10.72,0:03:13.18,Chinese,,0,0,0,,他们创建了一个名为csh的shell
Dialogue: 0,0:03:14.68,0:03:21.90,English,,0,0,0,,Now the execution is in a shell is a sequence of read and evaluate steps
Dialogue: 0,0:03:14.68,0:03:21.90,Chinese,,0,0,0,,现在执行shell是一系列读取和评估步骤
Dialogue: 0,0:03:22.80,0:03:24.96,English,,0,0,0,,So first a shell prints out a prompt
Dialogue: 0,0:03:22.80,0:03:24.96,Chinese,,0,0,0,,所以首先shell打印出一个提示
Dialogue: 0,0:03:25.84,0:03:30.96,English,,0,0,0,,And then it waits for it waits for you to type something in on the command line and hit return
Dialogue: 0,0:03:25.84,0:03:30.96,Chinese,,0,0,0,,然后等待它等待你在命令行输入内容并点击返回
Dialogue: 0,0:03:32.24,0:03:38.14,English,,0,0,0,,Okay and typically what you're typing in is a command which is just the
Dialogue: 0,0:03:32.24,0:03:38.14,Chinese,,0,0,0,,好的，通常你输入的是一个命令就是
Dialogue: 0,0:03:38.74,0:03:44.10,English,,0,0,0,,So the first thing you type is a command and then you follow that with optional arguments separated by spaces
Dialogue: 0,0:03:38.74,0:03:44.10,Chinese,,0,0,0,,所以你键入的第一件事是一个命令，然后你用可选参数用空格分隔
Dialogue: 0,0:03:44.90,0:03:50.90,English,,0,0,0,,Okay so once you hit once you type in a command and those optional arguments and hit return
Dialogue: 0,0:03:44.90,0:03:50.90,Chinese,,0,0,0,,好的，所以一旦你输入一个命令和那些可选参数并点击返回，你就会命中
Dialogue: 0,0:03:51.72,0:04:00.36,English,,0,0,0,,The shell checks for the end of file character which is a ctrl-d to terminal
Dialogue: 0,0:03:51.72,0:04:00.36,Chinese,,0,0,0,,shell检查文件结束字符，它是一个ctrl-d到终端
Dialogue: 0,0:04:00.60,0:04:04.56,English,,0,0,0,,And if so it exits otherwise it evaluates that command line
Dialogue: 0,0:04:00.60,0:04:04.56,Chinese,,0,0,0,,如果是这样，它退出，否则它会评估该命令行
Dialogue: 0,0:04:05.46,0:04:06.96,English,,0,0,0,,And the evaluation consists
Dialogue: 0,0:04:05.46,0:04:06.96,Chinese,,0,0,0,,评估包括
Dialogue: 0,0:04:10.48,0:04:14.14,English,,0,0,0,,And then when it returns from the evaluation it just does the same thing over in it
Dialogue: 0,0:04:10.48,0:04:14.14,Chinese,,0,0,0,,然后当它从评估中返回时，它就会在其中做同样的事情
Dialogue: 0,0:04:14.66,0:04:21.40,English,,0,0,0,,Now the evaluation consists of the following kinds of steps first
Dialogue: 0,0:04:14.66,0:04:21.40,Chinese,,0,0,0,,现在，评估首先包括以下几种步骤
Dialogue: 0,0:04:22.50,0:04:24.18,English,,0,0,0,,It parses the command line
Dialogue: 0,0:04:22.50,0:04:24.18,Chinese,,0,0,0,,它解析命令行
Dialogue: 0,0:04:25.92,0:04:32.76,English,,0,0,0,,And in the process so it takes the command-line which in this example is in buff
Dialogue: 0,0:04:25.92,0:04:32.76,Chinese,,0,0,0,,并且在此过程中，它采用命令行，在此示例中为buff
Dialogue: 0,0:04:33.10,0:04:37.46,English,,0,0,0,,And it produces argv array okay where argv[0] is a command
Dialogue: 0,0:04:33.10,0:04:37.46,Chinese,,0,0,0,,并且它产生argv数组，其中argv [0]是一个命令
Dialogue: 0,0:04:37.92,0:04:41.16,English,,0,0,0,,And then argv[1] and argv[2] and so on are the optional arguments
Dialogue: 0,0:04:37.92,0:04:41.16,Chinese,,0,0,0,,然后argv [1]和argv [2]等是可选参数
Dialogue: 0,0:04:42.82,0:04:48.24,English,,0,0,0,,And the convention in a shell is that if the command line is terminated
Dialogue: 0,0:04:42.82,0:04:48.24,Chinese,,0,0,0,,shell中的约定是命令行终止
Dialogue: 0,0:04:49.56,0:04:55.14,English,,0,0,0,,By an ampersand then you're asking the shell to run that job,to run that command in the background
Dialogue: 0,0:04:49.56,0:04:55.14,Chinese,,0,0,0,,通过＆符号然后你要求shell运行该作业，在后台运行该命令
Dialogue: 0,0:04:56.02,0:04:58.18,English,,0,0,0,,Meaning the shell won't wait for that job to finish
Dialogue: 0,0:04:56.02,0:04:58.18,Chinese,,0,0,0,,这意味着shell不会等待该作业完成
Dialogue: 0,0:04:58.78,0:05:00.68,English,,0,0,0,,Before it goes through its next read stub
Dialogue: 0,0:04:58.78,0:05:00.68,Chinese,,0,0,0,,在它通过下一个读取存根之前
Dialogue: 0,0:05:01.44,0:05:05.72,English,,0,0,0,,If the line that you type doesn't have an ampersand
Dialogue: 0,0:05:01.44,0:05:05.72,Chinese,,0,0,0,,如果你键入的行没有＆符号
Dialogue: 0,0:05:05.72,0:05:10.38,English,,0,0,0,,Then you're asking the shell to run that job in the foreground which means the shell will wait
Dialogue: 0,0:05:05.72,0:05:10.38,Chinese,,0,0,0,,然后你要求shell在前台运行该作业，这意味着shell将等待
Dialogue: 0,0:05:13.56,0:05:19.38,English,,0,0,0,,So first we parse this command line into an argv array
Dialogue: 0,0:05:13.56,0:05:19.38,Chinese,,0,0,0,,首先，我们将此命令行解析为argv数组
Dialogue: 0,0:05:19.42,0:05:25.46,English,,0,0,0,,And we return whether or not it was terminated by an ampersand, so bg for background
Dialogue: 0,0:05:19.42,0:05:25.46,Chinese,,0,0,0,,我们返回它是否被一个＆符号终止，所以bg作为背景
Dialogue: 0,0:05:26.42,0:05:31.90,English,,0,0,0,,If argv[0] is null then that means we just hit a we just hit return right so as an empty line
Dialogue: 0,0:05:26.42,0:05:31.90,Chinese,,0,0,0,,如果argv [0]为null，那么这意味着我们只需点击一个，我们只需返回右边的空行即可
Dialogue: 0,0:05:32.58,0:05:35.04,English,,0,0,0,,So we'll just return and just ignore those
Dialogue: 0,0:05:32.58,0:05:35.04,Chinese,,0,0,0,,所以我们只会回来而忽略那些
Dialogue: 0,0:05:36.54,0:05:41.66,English,,0,0,0,,Now a shell also implements what are called built-in commands
Dialogue: 0,0:05:36.54,0:05:41.66,Chinese,,0,0,0,,现在shell也实现了所谓的内置命令
Dialogue: 0,0:05:41.90,0:05:47.36,English,,0,0,0,,So various things like jobs bg, fg
Dialogue: 0,0:05:41.90,0:05:47.36,Chinese,,0,0,0,,所以各种各样的事情，比如job bg，fg
Dialogue: 0,0:05:47.82,0:05:51.96,English,,0,0,0,,Are examples of built-in commands which are just implemented in the shell itself
Dialogue: 0,0:05:47.82,0:05:51.96,Chinese,,0,0,0,,是内置命令的示例，它们只是在shell本身中实现的
Dialogue: 0,0:05:53.14,0:05:55.32,English,,0,0,0,,So if you type...if the first thing you type
Dialogue: 0,0:05:53.14,0:05:55.32,Chinese,,0,0,0,,所以如果你键入...如果你键入的第一件事
Dialogue: 0,0:05:56.20,0:05:58.48,English,,0,0,0,,If the command you enter is a built in
Dialogue: 0,0:05:56.20,0:05:58.48,Chinese,,0,0,0,,如果你输入的命令是内置的
Dialogue: 0,0:05:59.24,0:06:06.02,English,,0,0,0,,Then the shell will check that,it will check argv[0] for a to see if it's a built-in command
Dialogue: 0,0:05:59.24,0:06:06.02,Chinese,,0,0,0,,然后shell将检查它，它将检查argv [0]以查看它是否是内置命令
Dialogue: 0,0:06:06.64,0:06:11.70,English,,0,0,0,,And if it is it'll just execute it whatever it is you asked it to do
Dialogue: 0,0:06:06.64,0:06:11.70,Chinese,,0,0,0,,如果它是它只是执行它你要求它做什么
Dialogue: 0,0:06:13.76,0:06:20.14,English,,0,0,0,,Okay otherwise if it's not a built-in then that means that you're asking the shell to run some program
Dialogue: 0,0:06:13.76,0:06:20.14,Chinese,,0,0,0,,好吧否则，如果它不是内置的那么这意味着你要求shell运行一些程序
Dialogue: 0,0:06:22.42,0:06:24.92,English,,0,0,0,,Okay so in that case the shell will fork a child
Dialogue: 0,0:06:22.42,0:06:24.92,Chinese,,0,0,0,,好的，在这种情况下，shell会分叉一个孩子
Dialogue: 0,0:06:26.34,0:06:31.60,English,,0,0,0,,And then the child will execute that program by calling execve
Dialogue: 0,0:06:26.34,0:06:31.60,Chinese,,0,0,0,,然后孩子将通过调用execve来执行该程序
Dialogue: 0,0:06:32.98,0:06:35.50,English,,0,0,0,,Passing as the first argument the name of the command
Dialogue: 0,0:06:32.98,0:06:35.50,Chinese,,0,0,0,,作为第一个参数传递命令的名称
Dialogue: 0,0:06:36.18,0:06:41.24,English,,0,0,0,,And as the second and third argv and and the environment respectively
Dialogue: 0,0:06:36.18,0:06:41.24,Chinese,,0,0,0,,并分别作为第二和第三argv和环境
Dialogue: 0,0:06:42.10,0:06:46.86,English,,0,0,0,,Now execve if you recall from last time never returns unless there's an error
Dialogue: 0,0:06:42.10,0:06:46.86,Chinese,,0,0,0,,现在，如果你从上次回忆起来，那就永远不会回来，除非出现错误
Dialogue: 0,0:06:47.37,0:06:51.48,English,,0,0,0,,So it checks so we check it the return value for execve
Dialogue: 0,0:06:47.37,0:06:51.48,Chinese,,0,0,0,,所以它检查所以我们检查execve的返回值
Dialogue: 0,0:06:52.70,0:06:56.98,English,,0,0,0,,And if it returns less than zero fact the only time it will return
Dialogue: 0,0:06:52.70,0:06:56.98,Chinese,,0,0,0,,如果它返回小于零的事实，它将返回的唯一时间
Dialogue: 0,0:06:57.54,0:07:01.90,English,,0,0,0,,If it does return it will always return -1
Dialogue: 0,0:06:57.54,0:07:01.90,Chinese,,0,0,0,,如果它确实返回它将始终返回-1
Dialogue: 0,0:07:02.32,0:07:04.56,English,,0,0,0,,But we're just being careful here
Dialogue: 0,0:07:02.32,0:07:04.56,Chinese,,0,0,0,,但我们在这里要小心
Dialogue: 0,0:07:05.24,0:07:12.32,English,,0,0,0,,So we check that for an error and in print and error message if we find an error and then exit
Dialogue: 0,0:07:05.24,0:07:12.32,Chinese,,0,0,0,,因此，如果我们发现错误然后退出，我们会检查是否存在错误以及打印和错误消息
Dialogue: 0,0:07:15.26,0:07:22.06,English,,0,0,0,,So once the parent gets control again
Dialogue: 0,0:07:15.26,0:07:22.06,Chinese,,0,0,0,,一旦父母再次获得控制权
Dialogue: 0,0:07:22.76,0:07:25.20,English,,0,0,0,,Then it waits for that foreground job to terminate
Dialogue: 0,0:07:22.76,0:07:25.20,Chinese,,0,0,0,,然后它等待该前台作业终止
Dialogue: 0,0:07:26.22,0:07:28.52,English,,0,0,0,,Okay so if it's not a background job
Dialogue: 0,0:07:26.22,0:07:28.52,Chinese,,0,0,0,,好的，如果它不是后台工作
Dialogue: 0,0:07:29.30,0:07:32.18,English,,0,0,0,,Then it waits for it to terminate by calling waitpid
Dialogue: 0,0:07:29.30,0:07:32.18,Chinese,,0,0,0,,然后它通过调用waitpid等待它终止
Dialogue: 0,0:07:33.34,0:07:38.70,English,,0,0,0,,And waiting for that child that foreground job to terminate and then and reaping it
Dialogue: 0,0:07:33.34,0:07:38.70,Chinese,,0,0,0,,并等待前台工作终止然后收获的那个孩子
Dialogue: 0,0:07:39.44,0:07:43.96,English,,0,0,0,,Otherwise if it's a background job it just prints say a message and goes on
Dialogue: 0,0:07:39.44,0:07:43.96,Chinese,,0,0,0,,否则，如果它是后台工作，它只是打印说出一条消息然后继续
Dialogue: 0,0:07:44.82,0:07:46.44,English,,0,0,0,,So this is really interesting right that
Dialogue: 0,0:07:44.82,0:07:46.44,Chinese,,0,0,0,,所以这非常有趣
Dialogue: 0,0:07:46.74,0:07:50.98,English,,0,0,0,,There's really the only difference between a foreground job and a background job is just that the shell
Dialogue: 0,0:07:46.74,0:07:50.98,Chinese,,0,0,0,,前台作业和后台作业之间的唯一区别就在于shell
Dialogue: 0,0:07:51.76,0:07:53.62,English,,0,0,0,,Does a waitpid on that job or not
Dialogue: 0,0:07:51.76,0:07:53.62,Chinese,,0,0,0,,是否对该工作进行了等待
Dialogue: 0,0:07:54.02,0:07:57.46,English,,0,0,0,,Right so there otherwise there's really no difference
Dialogue: 0,0:07:54.02,0:07:57.46,Chinese,,0,0,0,,是的，否则就没有区别了
Dialogue: 0,0:07:58.78,0:08:03.68,English,,0,0,0,,Now what's the problem? there's a problem with our example show
Dialogue: 0,0:07:58.78,0:08:03.68,Chinese,,0,0,0,,现在问题是什么？我们的示例节目有问题
Dialogue: 0,0:08:05.88,0:08:09.88,English,,0,0,0,,And that the problem is that we're doing the right thing for the foreground job
Dialogue: 0,0:08:05.88,0:08:09.88,Chinese,,0,0,0,,问题是我们正在为前台工作做正确的事情
Dialogue: 0,0:08:10.40,0:08:13.72,English,,0,0,0,,We always have to reap these children so they they so that
Dialogue: 0,0:08:10.40,0:08:13.72,Chinese,,0,0,0,,我们总是要收养这些孩子，以便他们这样做
Dialogue: 0,0:08:15.10,0:08:17.54,English,,0,0,0,,They're their state can be released
Dialogue: 0,0:08:15.10,0:08:17.54,Chinese,,0,0,0,,他们的状态可以被释放
Dialogue: 0,0:08:19.82,0:08:23.62,English,,0,0,0,,But we're not doing anything to reap any background jobs
Dialogue: 0,0:08:19.82,0:08:23.62,Chinese,,0,0,0,,但我们没有做任何事情来收获任何后勤工作
Dialogue: 0,0:08:23.80,0:08:26.78,English,,0,0,0,,Right when if the background job so if not bg
Dialogue: 0,0:08:23.80,0:08:26.78,Chinese,,0,0,0,,正确，如果后台工作，所以如果不是bg
Dialogue: 0,0:08:27.26,0:08:29.38,English,,0,0,0,,We're just printing a message and then we're returning
Dialogue: 0,0:08:27.26,0:08:29.38,Chinese,,0,0,0,,我们只是打印一条消息，然后我们又回来了
Dialogue: 0,0:08:30.30,0:08:32.80,English,,0,0,0,,And then we're continuing with this read evaluate step
Dialogue: 0,0:08:30.30,0:08:32.80,Chinese,,0,0,0,,然后我们继续这个读取评估步骤
Dialogue: 0,0:08:33.58,0:08:38.82,English,,0,0,0,,And never going back and and taking care of that background job
Dialogue: 0,0:08:33.58,0:08:38.82,Chinese,,0,0,0,,永远不会回去并照顾那份背景工作
Dialogue: 0,0:08:40.40,0:08:44.24,English,,0,0,0,,So this is a problem because that the background job will eventually become
Dialogue: 0,0:08:40.40,0:08:44.24,Chinese,,0,0,0,,所以这是一个问题，因为后台工作最终会成为
Dialogue: 0,0:08:45.82,0:08:51.46,English,,0,0,0,,If we have enough of those jobs we create a memory leak that could crash the system right so this is an error
Dialogue: 0,0:08:45.82,0:08:51.46,Chinese,,0,0,0,,如果我们有足够的这些工作，我们会创建一个内存泄漏，可能会使系统崩溃，所以这是一个错误
Dialogue: 0,0:08:52.36,0:08:53.72,English,,0,0,0,,So what are we going to do about this
Dialogue: 0,0:08:52.36,0:08:53.72,Chinese,,0,0,0,,那么我们该怎么办呢
Dialogue: 0,0:08:54.38,0:08:59.10,English,,0,0,0,,Well it turns out that exceptional control flow will help us solve this problem
Dialogue: 0,0:08:54.38,0:08:59.10,Chinese,,0,0,0,,事实证明，卓越的控制流程将帮助我们解决这个问题
Dialogue: 0,0:09:00.08,0:09:04.72,English,,0,0,0,,And what happens is that the kernel will notify
Dialogue: 0,0:09:00.08,0:09:04.72,Chinese,,0,0,0,,会发生什么是内核会通知
Dialogue: 0,0:09:05.18,0:09:08.54,English,,0,0,0,,The shell when a any of its children terminate
Dialogue: 0,0:09:05.18,0:09:08.54,Chinese,,0,0,0,,当任何一个孩子终止时的shell
Dialogue: 0,0:09:09.78,0:09:14.82,English,,0,0,0,,Okay and then the shell can then react to that and issue a waitpid
Dialogue: 0,0:09:09.78,0:09:14.82,Chinese,,0,0,0,,好的，然后shell可以对此做出反应并发出waitpid
Dialogue: 0,0:09:15.46,0:09:21.18,English,,0,0,0,,Okay and this notification mechanism that the kernel uses is something called a signal
Dialogue: 0,0:09:15.46,0:09:21.18,Chinese,,0,0,0,,好的，内核使用的这种通知机制叫做信号
Dialogue: 0,0:09:25.92,0:09:28.22,English,,0,0,0,,So a signal is a small message
Dialogue: 0,0:09:25.92,0:09:28.22,Chinese,,0,0,0,,所以信号是一个小信息
Dialogue: 0,0:09:29.98,0:09:36.82,English,,0,0,0,,That the kernel delivers to a process to notify it that there's been some event in the system
Dialogue: 0,0:09:29.98,0:09:36.82,Chinese,,0,0,0,,内核传递给进程以通知它系统中存在某些事件
Dialogue: 0,0:09:37.66,0:09:44.18,English,,0,0,0,,Now so this is very similar to the exceptions that we studied the last time
Dialogue: 0,0:09:37.66,0:09:44.18,Chinese,,0,0,0,,现在，这与我们上次研究的例外非常相似
Dialogue: 0,0:09:44.34,0:09:47.52,English,,0,0,0,,Right except it's all implemented in software
Dialogue: 0,0:09:44.34,0:09:47.52,Chinese,,0,0,0,,没错，除了它全部用软件实现
Dialogue: 0,0:09:49.12,0:09:53.02,English,,0,0,0,,Now kernel signals are always sent from the kernel
Dialogue: 0,0:09:49.12,0:09:53.02,Chinese,,0,0,0,,现在内核信号总是从内核发送
Dialogue: 0,0:09:53.02,0:09:56.38,English,,0,0,0,,But sometimes they're sent at the request of another process
Dialogue: 0,0:09:53.02,0:09:56.38,Chinese,,0,0,0,,但有时它们是在另一个进程的请求下发送的
Dialogue: 0,0:09:56.82,0:10:00.42,English,,0,0,0,,Right sometimes the kernel will notice that there's some event
Dialogue: 0,0:09:56.82,0:10:00.42,Chinese,,0,0,0,,对，有时内核会注意到有一些事件
Dialogue: 0,0:10:01.22,0:10:07.06,English,,0,0,0,,Other times another process will ask the kernel to send a message to some other process
Dialogue: 0,0:10:01.22,0:10:07.06,Chinese,,0,0,0,,其他时候，另一个进程会要求内核向其他进程发送消息
Dialogue: 0,0:10:08.52,0:10:11.52,English,,0,0,0,,Now that we say that it's a small message
Dialogue: 0,0:10:08.52,0:10:11.52,Chinese,,0,0,0,,现在我们说这是一个小消息
Dialogue: 0,0:10:12.22,0:10:15.42,English,,0,0,0,,Because the only information that's contained in a signal
Dialogue: 0,0:10:12.22,0:10:15.42,Chinese,,0,0,0,,因为信号中包含的唯一信息
Dialogue: 0,0:10:16.00,0:10:18.66,English,,0,0,0,,It's a unique integer id
Dialogue: 0,0:10:16.00,0:10:18.66,Chinese,,0,0,0,,它是一个唯一的整数id
Dialogue: 0,0:10:19.66,0:10:23.50,English,,0,0,0,,And the fact that it was delivered okay so
Dialogue: 0,0:10:19.66,0:10:23.50,Chinese,,0,0,0,,事实上，它是如此的好
Dialogue: 0,0:10:24.34,0:10:27.94,English,,0,0,0,,That's so there's nothing else in a signal except that it arrived
Dialogue: 0,0:10:24.34,0:10:27.94,Chinese,,0,0,0,,就是这样，除了它到达之外，信号中没有别的东西
Dialogue: 0,0:10:28.18,0:10:31.88,English,,0,0,0,,And that it has some unique id
Dialogue: 0,0:10:28.18,0:10:31.88,Chinese,,0,0,0,,它有一些独特的身份
Dialogue: 0,0:10:33.04,0:10:37.26,English,,0,0,0,,Now examples of these are the sigint
Dialogue: 0,0:10:33.04,0:10:37.26,Chinese,,0,0,0,,现在这些例子就是sigint
Dialogue: 0,0:10:37.48,0:10:41.60,English,,0,0,0,,So signals have this ... this unique id and then they also have a name
Dialogue: 0,0:10:37.48,0:10:41.60,Chinese,,0,0,0,,所以信号有这个...这个唯一的id然后他们也有一个名字
Dialogue: 0,0:10:44.80,0:10:51.32,English,,0,0,0,,So the sigint is what the when you type ctrl-C at on the command line
Dialogue: 0,0:10:44.80,0:10:51.32,Chinese,,0,0,0,,所以当你在命令行输入ctrl-C时，sigint是什么
Dialogue: 0,0:10:51.64,0:10:56.90,English,,0,0,0,,The kernel sends a signal to every any processes in the foreground
Dialogue: 0,0:10:51.64,0:10:56.90,Chinese,,0,0,0,,内核向前台的每个进程发送一个信号
Dialogue: 0,0:10:57.26,0:11:00.52,English,,0,0,0,,And the default action of receiving a sigint is to terminate right
Dialogue: 0,0:10:57.26,0:11:00.52,Chinese,,0,0,0,,接收sigint的默认操作是终止正确
Dialogue: 0,0:11:00.52,0:11:04.06,English,,0,0,0,,So this is how if you're running a foreground job you hit ctrl-c
Dialogue: 0,0:11:00.52,0:11:04.06,Chinese,,0,0,0,,所以这就是如果你运行一个前台作业，你点击ctrl-c
Dialogue: 0,0:11:04.52,0:11:07.08,English,,0,0,0,,You get the prompt back because it kills that job
Dialogue: 0,0:11:04.52,0:11:07.08,Chinese,,0,0,0,,你得到提示，因为它杀死了那份工作
Dialogue: 0,0:11:08.36,0:11:13.84,English,,0,0,0,,Sigkill number 9 can be used to kill terminate any program
Dialogue: 0,0:11:08.36,0:11:13.84,Chinese,,0,0,0,,Sigkill编号9可用于终止任何程序终止
Dialogue: 0,0:11:15.78,0:11:22.74,English,,0,0,0,,So these two have sigint and sigkill have the same effect on the programs me that they kill the program
Dialogue: 0,0:11:15.78,0:11:22.74,Chinese,,0,0,0,,所以这两个有sigint和sigkill对程序我有同样的效果，他们杀了程序
Dialogue: 0,0:11:23.02,0:11:30.36,English,,0,0,0,,The the unique aspect of sigkill is that there's no way to ignore it or override it
Dialogue: 0,0:11:23.02,0:11:30.36,Chinese,,0,0,0,,sigkill的独特之处在于无法忽略它或覆盖它
Dialogue: 0,0:11:30.89,0:11:32.18,English,,0,0,0,,Okay so this is like the failsafe
Dialogue: 0,0:11:30.89,0:11:32.18,Chinese,,0,0,0,,好的，这就像故障保险
Dialogue: 0,0:11:33.36,0:11:38.48,English,,0,0,0,,As we'll see there are there are ways to catch and ignore other signals like sigint
Dialogue: 0,0:11:33.36,0:11:38.48,Chinese,,0,0,0,,正如我们所看到的那样，有一些方法可以捕捉并忽略其他信号，例如sigint
Dialogue: 0,0:11:40.22,0:11:43.32,English,,0,0,0,,Sigsegv is the our favorite segment
Dialogue: 0,0:11:40.22,0:11:43.32,Chinese,,0,0,0,,Sigsegv是我们最喜欢的部分
Dialogue: 0,0:11:43.54,0:11:51.24,English,,0,0,0,,Segmentation violation so if you access a region of memory that's protected or not legal
Dialogue: 0,0:11:43.54,0:11:51.24,Chinese,,0,0,0,,如果你访问受保护或不合法的内存区域，则会出现分段违规
Dialogue: 0,0:11:52.48,0:11:57.74,English,,0,0,0,,Then your program will ,the kernel will send your that process a sigsegv
Dialogue: 0,0:11:52.48,0:11:57.74,Chinese,,0,0,0,,然后你的程序将，内核将发送你的进程一个sigsegv
Dialogue: 0,0:11:58.46,0:12:06.40,English,,0,0,0,,Okay signal and the default  the default effective that is to terminate the program
Dialogue: 0,0:11:58.46,0:12:06.40,Chinese,,0,0,0,,好的信号和默认有效的终止程序
Dialogue: 0,0:12:07.08,0:12:11.72,English,,0,0,0,,Sigalrm is a way within your program you can arrange for a signal to be sent to yourself
Dialogue: 0,0:12:07.08,0:12:11.72,Chinese,,0,0,0,,Sigalrm是你计划中的一种方式，你可以安排将信号发送给自己
Dialogue: 0,0:12:12.32,0:12:18.94,English,,0,0,0,,So you can say inside your program send me a sigalrm signal in three seconds
Dialogue: 0,0:12:12.32,0:12:18.94,Chinese,,0,0,0,,所以你可以在程序里面说三秒内给我一个sigalrm信号
Dialogue: 0,0:12:21.58,0:12:27.00,English,,0,0,0,,So this is a way to do things like you can set up timers,you can set up timeouts like if you want to
Dialogue: 0,0:12:21.58,0:12:27.00,Chinese,,0,0,0,,因此，这是一种可以设置定时器的方法，你可以设置超时，就像你想要的那样
Dialogue: 0,0:12:27.60,0:12:32.88,English,,0,0,0,,If you want to set a timeout value and you're doing some some some work and
Dialogue: 0,0:12:27.60,0:12:32.88,Chinese,,0,0,0,,如果你想设置一个超时值，你正在做一些工作和
Dialogue: 0,0:12:33.28,0:12:39.76,English,,0,0,0,,You want to guard against that that work taking exceptionally long time, you can use sigalrm to set a timeout
Dialogue: 0,0:12:33.28,0:12:39.76,Chinese,,0,0,0,,你想要防止那项工作需要特别长的时间，你可以使用sigalrm来设置超时
Dialogue: 0,0:12:40.64,0:12:46.72,English,,0,0,0,,And then a very important one is as we'll see that would be very important for our shell is the sigchild signal
Dialogue: 0,0:12:40.64,0:12:46.72,Chinese,,0,0,0,,然后一个非常重要的是因为我们将看到对我们的shell来说非常重要的是sigchild信号
Dialogue: 0,0:12:47.30,0:12:54.48,English,,0,0,0,,Which the colonel sends to a parent every time one of its children terminates or stops
Dialogue: 0,0:12:47.30,0:12:54.48,Chinese,,0,0,0,,每当其中一个孩子终止或停止时，上校就会向其发送
Dialogue: 0,0:12:55.48,0:12:57.90,English,,0,0,0,,Okay so this as we'll see now
Dialogue: 0,0:12:55.48,0:12:57.90,Chinese,,0,0,0,,好的，我们现在就看到了
Dialogue: 0,0:12:58.44,0:13:02.58,English,,0,0,0,,We'll see this is how we're going...this is how a shell that is going to actually reap
Dialogue: 0,0:12:58.44,0:13:02.58,Chinese,,0,0,0,,我们会看到这就是我们的目标......这就是一个真正意义上的外壳
Dialogue: 0,0:13:02.66,0:13:08.40,English,,0,0,0,,It's all of its children right is by taking advantage of the sigchild signal
Dialogue: 0,0:13:02.66,0:13:08.40,Chinese,,0,0,0,,它的所有孩子都是利用sigchld信号
Dialogue: 0,0:13:09.78,0:13:11.92,English,,0,0,0,,But before I can show you that
Dialogue: 0,0:13:09.78,0:13:11.92,Chinese,,0,0,0,,但在我告诉你之前
Dialogue: 0,0:13:12.46,0:13:18.58,English,,0,0,0,,We need to go through a number of concepts around signals
Dialogue: 0,0:13:12.46,0:13:18.58,Chinese,,0,0,0,,我们需要围绕信号进行一些概念
Dialogue: 0,0:13:20.00,0:13:24.32,English,,0,0,0,,Okay like I said the semantics of signals
Dialogue: 0,0:13:20.00,0:13:24.32,Chinese,,0,0,0,,好的，就像我说的信号的语义
Dialogue: 0,0:13:24.74,0:13:27.54,English,,0,0,0,,It's probably one of the thorniest aspects of Linux
Dialogue: 0,0:13:24.74,0:13:27.54,Chinese,,0,0,0,,它可能是Linux最棘手的方面之一
Dialogue: 0,0:13:28.94,0:13:40.98,English,,0,0,0,,It was developed very early in the the lifespan of Linux when and it maybe wasn't as clean as it could be right so
Dialogue: 0,0:13:28.94,0:13:40.98,Chinese,,0,0,0,,它是在Linux的生命周期的早期开发的，它可能并不像它那样干净
Dialogue: 0,0:13:41.44,0:13:47.24,English,,0,0,0,,In order to get a handle on signals we're going to be very careful about defining terms and very careful about the way
Dialogue: 0,0:13:41.44,0:13:47.24,Chinese,,0,0,0,,为了掌握信号，我们将非常谨慎地定义术语并非常小心
Dialogue: 0,0:13:47.62,0:13:48.88,English,,0,0,0,,We talk about them
Dialogue: 0,0:13:47.62,0:13:48.88,Chinese,,0,0,0,,我们谈论它们
Dialogue: 0,0:13:50.26,0:13:57.46,English,,0,0,0,,So we say that the kernel sends or delivers a signal to some destination process
Dialogue: 0,0:13:50.26,0:13:57.46,Chinese,,0,0,0,,所以我们说内核向某个目标进程发送或发送信号
Dialogue: 0,0:13:58.52,0:14:04.98,English,,0,0,0,,And it does this by setting some state in the context of the destination process
Dialogue: 0,0:13:58.52,0:14:04.98,Chinese,,0,0,0,,它通过在目标进程的上下文中设置一些状态来实现此目的
Dialogue: 0,0:14:05.76,0:14:14.00,English,,0,0,0,,Now nothing happens except that some bits get changed in the destination process context
Dialogue: 0,0:14:05.76,0:14:14.00,Chinese,,0,0,0,,现在没有任何事情发生，除了在目标进程上下文中更改了一些位
Dialogue: 0,0:14:14.32,0:14:19.02,English,,0,0,0,,Okay there's no impact of, immediate impact of sending a signal
Dialogue: 0,0:14:14.32,0:14:19.02,Chinese,,0,0,0,,好的，没有影响，发送信号的直接影响
Dialogue: 0,0:14:22.94,0:14:24.80,English,,0,0,0,,Now a kernel sends a signal
Dialogue: 0,0:14:22.94,0:14:24.80,Chinese,,0,0,0,,现在内核发送一个信号
Dialogue: 0,0:14:25.92,0:14:29.68,English,,0,0,0,,Either because it detected some event in the system like
Dialogue: 0,0:14:25.92,0:14:29.68,Chinese,,0,0,0,,或者是因为它在系统中检测到某些事件
Dialogue: 0,0:14:30.38,0:14:33.02,English,,0,0,0,,That like a child process is terminated for example
Dialogue: 0,0:14:30.38,0:14:33.02,Chinese,,0,0,0,,例如，就像子进程一样终止
Dialogue: 0,0:14:34.66,0:14:41.42,English,,0,0,0,,Or another process has asked the kernel (to send) to deliver a process on a signal on its behalf
Dialogue: 0,0:14:34.66,0:14:41.42,Chinese,,0,0,0,,或者另一个进程要求内核（发送）代表它发送信号进程
Dialogue: 0,0:14:43.38,0:14:47.04,English,,0,0,0,,And there's a number of ways to do that one of them is with the kill system call
Dialogue: 0,0:14:43.38,0:14:47.04,Chinese,,0,0,0,,并且有很多方法可以做到这一点，其中一个是使用kill系统调用
Dialogue: 0,0:14:48.88,0:14:51.48,English,,0,0,0,,It's kind of an unfortunate tournament
Dialogue: 0,0:14:48.88,0:14:51.48,Chinese,,0,0,0,,这是一场不幸的比赛
Dialogue: 0,0:14:52.18,0:14:55.50,English,,0,0,0,,I mean the so kill is a general way to send signals
Dialogue: 0,0:14:52.18,0:14:55.50,Chinese,,0,0,0,,我的意思是杀戮是发送信号的一般方式
Dialogue: 0,0:14:56.10,0:15:01.50,English,,0,0,0,,And the impact is sometimes not to kill the program right
Dialogue: 0,0:14:56.10,0:15:01.50,Chinese,,0,0,0,,而影响有时并不是为了扼杀程序
Dialogue: 0,0:15:01.52,0:15:04.36,English,,0,0,0,,But for some reason they chose to call it kill
Dialogue: 0,0:15:01.52,0:15:04.36,Chinese,,0,0,0,,但出于某种原因，他们选择称之为杀人
Dialogue: 0,0:15:07.72,0:15:11.70,English,,0,0,0,,Now the destination process receives a signal
Dialogue: 0,0:15:07.72,0:15:11.70,Chinese,,0,0,0,,现在目标进程收到一个信号
Dialogue: 0,0:15:13.08,0:15:20.54,English,,0,0,0,,When it's forced by the kernel to act in some way to react in some way to the delivery of a signal
Dialogue: 0,0:15:13.08,0:15:20.54,Chinese,,0,0,0,,当内核强制以某种方式采取行动以某种方式对信号的传递做出反应时
Dialogue: 0,0:15:22.34,0:15:29.02,English,,0,0,0,,Okay so these are two very different things sending a signal set state in the context of the destination process
Dialogue: 0,0:15:22.34,0:15:29.02,Chinese,,0,0,0,,好吧，这些是在目标进程的上下文中发送信号集状态的两个非常不同的事情
Dialogue: 0,0:15:29.84,0:15:36.82,English,,0,0,0,,Receiving a signal is what happens when the destination process is finally
Dialogue: 0,0:15:29.84,0:15:36.82,Chinese,,0,0,0,,接收信号是目标进程最终发生的情况
Dialogue: 0,0:15:37.16,0:15:40.90,English,,0,0,0,,Forced by the kernel to act in some way to react in some way
Dialogue: 0,0:15:37.16,0:15:40.90,Chinese,,0,0,0,,由内核强制以某种方式行动以某种方式作出反应
Dialogue: 0,0:15:41.82,0:15:45.70,English,,0,0,0,,Now some possible ways to react are to just ignore the signal
Dialogue: 0,0:15:41.82,0:15:45.70,Chinese,,0,0,0,,现在一些可能的反应方式是忽略信号
Dialogue: 0,0:15:49.14,0:15:50.46,English,,0,0,0,,Okay to terminate the process
Dialogue: 0,0:15:49.14,0:15:50.46,Chinese,,0,0,0,,好的，可以终止这个过程
Dialogue: 0,0:15:52.98,0:15:58.50,English,,0,0,0,,Or to catch the signal by executing a user level function called a signal handler
Dialogue: 0,0:15:52.98,0:15:58.50,Chinese,,0,0,0,,或者通过执行称为信号处理程序的用户级函数来捕获信号
Dialogue: 0,0:15:59.10,0:16:04.18,English,,0,0,0,,So in this case when we catch signals it's very similar to the...
Dialogue: 0,0:15:59.10,0:16:04.18,Chinese,,0,0,0,,所以在这种情况下，当我们捕获信号时，它与...非常相似
Dialogue: 0,0:16:04.94,0:16:06.38,English,,0,0,0,,And executes a signal handle
Dialogue: 0,0:16:04.94,0:16:06.38,Chinese,,0,0,0,,并执行信号句柄
Dialogue: 0,0:16:06.38,0:16:13.74,English,,0,0,0,,It's very similar to executing an exception handler in response to some kind of event in the system
Dialogue: 0,0:16:06.38,0:16:13.74,Chinese,,0,0,0,,它与执行异常处理程序以响应系统中的某种事件非常相似
Dialogue: 0,0:16:14.20,0:16:17.52,English,,0,0,0,,Now the difference is that exception handlers are in the kernel
Dialogue: 0,0:16:14.20,0:16:17.52,Chinese,,0,0,0,,现在区别在于异常处理程序在内核中
Dialogue: 0,0:16:18.18,0:16:21.28,English,,0,0,0,,Signal handlers are actually just in your C code okay there
Dialogue: 0,0:16:18.18,0:16:21.28,Chinese,,0,0,0,,信号处理程序实际上就在你的C代码中
Dialogue: 0,0:16:22.74,0:16:25.31,English,,0,0,0,,And they execute in your process
Dialogue: 0,0:16:22.74,0:16:25.31,Chinese,,0,0,0,,它们会在你的过程中执行
Dialogue: 0,0:16:26.86,0:16:34.66,English,,0,0,0,,So the way to think about if we catch a signal by executing a signal handler
Dialogue: 0,0:16:26.86,0:16:34.66,Chinese,,0,0,0,,因此，考虑我们是否通过执行信号处理程序捕获信号的方式
Dialogue: 0,0:16:35.20,0:16:37.72,English,,0,0,0,,We have our process executing instructions
Dialogue: 0,0:16:35.20,0:16:37.72,Chinese,,0,0,0,,我们有我们的流程执行指令
Dialogue: 0,0:16:39.00,0:16:41.72,English,,0,0,0,,And then the signal is received by that process
Dialogue: 0,0:16:39.00,0:16:41.72,Chinese,,0,0,0,,然后该过程接收信号
Dialogue: 0,0:16:43.02,0:16:47.10,English,,0,0,0,,So the kernel passes control to a signal handler
Dialogue: 0,0:16:43.02,0:16:47.10,Chinese,,0,0,0,,因此内核将控制权传递给信号处理程序
Dialogue: 0,0:16:47.10,0:16:55.14,English,,0,0,0,,Which is also just in the code that's executing in the current process, it's just a function in our C code
Dialogue: 0,0:16:47.10,0:16:55.14,Chinese,,0,0,0,,这也只是在当前进程中执行的代码中，它只是我们C代码中的一个函数
Dialogue: 0,0:16:56.18,0:17:01.52,English,,0,0,0,,The signal handler runs and when it returns,it eventually returns back to the next instruction
Dialogue: 0,0:16:56.18,0:17:01.52,Chinese,,0,0,0,,信号处理程序运行，当它返回时，它最终返回到下一条指令
Dialogue: 0,0:17:02.22,0:17:04.00,English,,0,0,0,,And then we continue
Dialogue: 0,0:17:02.22,0:17:04.00,Chinese,,0,0,0,,然后我们继续
Dialogue: 0,0:17:04.24,0:17:08.70,English,,0,0,0,,Okay so it's just like kind of like an interrupt right we just temporarily pause
Dialogue: 0,0:17:04.24,0:17:08.70,Chinese,,0,0,0,,好的，就像中断一样，我们只是暂时暂停
Dialogue: 0,0:17:09.36,0:17:16.22,English,,0,0,0,,What we're doing in our code to execute this handler before just continuing on
Dialogue: 0,0:17:09.36,0:17:16.22,Chinese,,0,0,0,,在继续之前，我们在代码中执行此处理程序的操作
Dialogue: 0,0:17:18.98,0:17:21.16,English,,0,0,0,,Okay now we say that a signal is pending
Dialogue: 0,0:17:18.98,0:17:21.16,Chinese,,0,0,0,,好的，现在我们说信号正在等待处理
Dialogue: 0,0:17:21.80,0:17:25.98,English,,0,0,0,,If it's been sent by the colonel but not you have received
Dialogue: 0,0:17:21.80,0:17:25.98,Chinese,,0,0,0,,如果它是由上校发送但你没有收到
Dialogue: 0,0:17:27.98,0:17:34.92,English,,0,0,0,,Okay so if at any given point in time there can only be one pending signal of any particular type
Dialogue: 0,0:17:27.98,0:17:34.92,Chinese,,0,0,0,,好吧，如果在任何给定的时间点，只能有一个任何特定类型的待处理信号
Dialogue: 0,0:17:36.84,0:17:40.70,English,,0,0,0,,Okay so this has very important consequences for using signals
Dialogue: 0,0:17:36.84,0:17:40.70,Chinese,,0,0,0,,好的，这对使用信号有非常重要的影响
Dialogue: 0,0:17:40.70,0:17:47.32,English,,0,0,0,,Because you can't cue signals up right at any point in time there's there can only be one pending sigchild
Dialogue: 0,0:17:40.70,0:17:47.32,Chinese,,0,0,0,,因为你无法在任何时间点提示信号，所以只能有一个待定的sigchild
Dialogue: 0,0:17:47.66,0:17:51.02,English,,0,0,0,,Signal for example or sigint signal
Dialogue: 0,0:17:47.66,0:17:51.02,Chinese,,0,0,0,,例如信号或信号信号
Dialogue: 0,0:17:51.84,0:17:55.38,English,,0,0,0,,And if a subsequent sigchild signals say is sent
Dialogue: 0,0:17:51.84,0:17:55.38,Chinese,,0,0,0,,并且如果后续的sigchild信号发送
Dialogue: 0,0:17:55.94,0:18:00.51,English,,0,0,0,,It just over writes well you can think of it,it has no impact
Dialogue: 0,0:17:55.94,0:18:00.51,Chinese,,0,0,0,,它只是写得很好，你可以想到它，它没有影响
Dialogue: 0,0:18:00.78,0:18:04.04,English,,0,0,0,,It's just discarded right if there's already a pending signal
Dialogue: 0,0:18:00.78,0:18:04.04,Chinese,,0,0,0,,如果已经存在未决信号，它就会被丢弃
Dialogue: 0,0:18:04.04,0:18:06.66,English,,0,0,0,,So they don't queue up in any meaningful way
Dialogue: 0,0:18:04.04,0:18:06.66,Chinese,,0,0,0,,所以他们不会以任何有意义的方式排队
Dialogue: 0,0:18:09.58,0:18:12.50,English,,0,0,0,,Now our process can block the receipt of certain signals
Dialogue: 0,0:18:09.58,0:18:12.50,Chinese,,0,0,0,,现在我们的流程可以阻止某些信号的接收
Dialogue: 0,0:18:13.62,0:18:16.42,English,,0,0,0,,Okay now it can't stop signals from being delivered
Dialogue: 0,0:18:13.62,0:18:16.42,Chinese,,0,0,0,,好的，它现在无法阻止信号传递
Dialogue: 0,0:18:17.04,0:18:23.76,English,,0,0,0,,But it can stop the process from having to react to the route to that signal when it's received
Dialogue: 0,0:18:17.04,0:18:23.76,Chinese,,0,0,0,,但它可以阻止该过程在收到信号时对该信号的路径做出反应
Dialogue: 0,0:18:27.84,0:18:34.10,English,,0,0,0,,Okay so block signals can be delivered but they won't be received until the signals unblocked
Dialogue: 0,0:18:27.84,0:18:34.10,Chinese,,0,0,0,,好的，所以可以传递阻塞信号，但是在信号解除阻塞之前不会接收到它们
Dialogue: 0,0:18:38.88,0:18:41.30,English,,0,0,0,,And pending signals are received at most once
Dialogue: 0,0:18:38.88,0:18:41.30,Chinese,,0,0,0,,待处理的信号最多只能收到一次
Dialogue: 0,0:18:46.34,0:18:49.36,English,,0,0,0,,Now the colonel keeps track of these pending and blocked
Dialogue: 0,0:18:46.34,0:18:49.36,Chinese,,0,0,0,,现在，上校跟踪这些待处理和阻止
Dialogue: 0,0:18:49.90,0:18:54.42,English,,0,0,0,,Signals in bit vectors that will call pending and blocked
Dialogue: 0,0:18:49.90,0:18:54.42,Chinese,,0,0,0,,位向量中的信号将调用挂起和阻止
Dialogue: 0,0:18:55.24,0:18:58.62,English,,0,0,0,,And pending represents the set of pending signals
Dialogue: 0,0:18:55.24,0:18:58.62,Chinese,,0,0,0,,pending表示待处理信号的集合
Dialogue: 0,0:18:58.74,0:19:04.24,English,,0,0,0,,Right where each bit in the pending bit vector corresponds to some particular signal
Dialogue: 0,0:18:58.74,0:19:04.24,Chinese,,0,0,0,,正在等待位向量中的每个位对应于某个特定信号的位置
Dialogue: 0,0:19:04.84,0:19:07.06,English,,0,0,0,,Okay so this is why they can't be queued right because
Dialogue: 0,0:19:04.84,0:19:07.06,Chinese,,0,0,0,,好的，这就是为什么他们不能排队等候的原因
Dialogue: 0,0:19:08.18,0:19:12.38,English,,0,0,0,,There's only one bit for any signal key,there's only one bit in the bit vector
Dialogue: 0,0:19:08.18,0:19:12.38,Chinese,,0,0,0,,任何信号键只有一位，位向量中只有一位
Dialogue: 0,0:19:12.84,0:19:18.00,English,,0,0,0,,And if we...and when we deliver a signal we're just setting will set that bit the colonel will set that bit
Dialogue: 0,0:19:12.84,0:19:18.00,Chinese,,0,0,0,,如果我们......当我们发出信号时，我们只是设置将设置该位上校将设置该位
Dialogue: 0,0:19:18.30,0:19:24.26,English,,0,0,0,,We deliver another signal of the same type, it'll just set that bit again which has no effect
Dialogue: 0,0:19:18.30,0:19:24.26,Chinese,,0,0,0,,我们提供相同类型的另一个信号，它只会再次设置该位，但没有效果
Dialogue: 0,0:19:26.80,0:19:32.68,English,,0,0,0,,Now the kernel sets that the bit in pending when the signals delivered and it clears it
Dialogue: 0,0:19:26.80,0:19:32.68,Chinese,,0,0,0,,现在，内核在传递信号时将该位设置为挂起并清除它
Dialogue: 0,0:19:32.80,0:19:34.18,English,,0,0,0,,When the signals received
Dialogue: 0,0:19:32.80,0:19:34.18,Chinese,,0,0,0,,收到信号时
Dialogue: 0,0:19:35.68,0:19:43.22,English,,0,0,0,,And the kernel also provides mechanism for users to block signals with blocked bit vector
Dialogue: 0,0:19:35.68,0:19:43.22,Chinese,,0,0,0,,内核还为用户提供了阻止位向量阻塞信号的机制
Dialogue: 0,0:19:43.22,0:19:49.34,English,,0,0,0,,So the block bit vector is the same size as the pending bit vector turns out it's just a 32 bit int
Dialogue: 0,0:19:43.22,0:19:49.34,Chinese,,0,0,0,,所以块位向量与待处理位向量的大小相同，结果只是32位int
Dialogue: 0,0:19:51.86,0:19:54.32,English,,0,0,0,,Okay and it can be set and cleared the bits
Dialogue: 0,0:19:51.86,0:19:54.32,Chinese,,0,0,0,,好的，它可以设置和清除位
Dialogue: 0,0:19:54.46,0:19:58.10,English,,0,0,0,,And that can be set and cleared using the sigprocmask system call
Dialogue: 0,0:19:54.46,0:19:58.10,Chinese,,0,0,0,,这可以使用sigprocmask系统调用进行设置和清除
Dialogue: 0,0:19:59.10,0:20:05.18,English,,0,0,0,,Okay now that the blocked in the Linux literature the blocked bit vector is also called the signal mask
Dialogue: 0,0:19:59.10,0:20:05.18,Chinese,,0,0,0,,好了，现在Linux文献中阻塞的阻塞位向量也被称为信号掩码
Dialogue: 0,0:20:10.28,0:20:14.40,English,,0,0,0,,Okay now we want to look in a little more detail about sending and receiving signals
Dialogue: 0,0:20:10.28,0:20:14.40,Chinese,,0,0,0,,好的，现在我们想了解一下发送和接收信号的更多细节
Dialogue: 0,0:20:14.40,0:20:16.76,English,,0,0,0,,So let's start first with sending signals
Dialogue: 0,0:20:14.40,0:20:16.76,Chinese,,0,0,0,,所以让我们首先发送信号
Dialogue: 0,0:20:18.56,0:20:21.34,English,,0,0,0,,First we need to understand the idea of a process group
Dialogue: 0,0:20:18.56,0:20:21.34,Chinese,,0,0,0,,首先，我们需要了解流程组的想法
Dialogue: 0,0:20:22.48,0:20:25.84,English,,0,0,0,,So every process belongs to exactly one process group
Dialogue: 0,0:20:22.48,0:20:25.84,Chinese,,0,0,0,,因此，每个流程都属于一个流程组
Dialogue: 0,0:20:28.38,0:20:31.48,English,,0,0,0,,And those so here I'm showing a shell that's in process
Dialogue: 0,0:20:28.38,0:20:31.48,Chinese,,0,0,0,,那些在这里我正在展示一个正在进行中的shell
Dialogue: 0,0:20:31.88,0:20:35.38,English,,0,0,0,,It has a process id of 10 and a process group id of 10
Dialogue: 0,0:20:31.88,0:20:35.38,Chinese,,0,0,0,,它的进程ID为10，进程组ID为10
Dialogue: 0,0:20:36.82,0:20:38.92,English,,0,0,0,,The shell created a foreground job
Dialogue: 0,0:20:36.82,0:20:38.92,Chinese,,0,0,0,,shell创建了一个前台作业
Dialogue: 0,0:20:41.12,0:20:44.80,English,,0,0,0,,Which has a process id of 20 and a process group id of 20
Dialogue: 0,0:20:41.12,0:20:44.80,Chinese,,0,0,0,,其进程ID为20，进程组ID为20
Dialogue: 0,0:20:45.34,0:20:51.88,English,,0,0,0,,And then all of the children that this foreground job created have the same process group id of 20
Dialogue: 0,0:20:45.34,0:20:51.88,Chinese,,0,0,0,,然后，此前台作业创建的所有子项具有相同的进程组ID 20
Dialogue: 0,0:20:53.94,0:20:59.20,English,,0,0,0,,So these process groups can be set by a system call set called the set process group id(setpgid())
Dialogue: 0,0:20:53.94,0:20:59.20,Chinese,,0,0,0,,因此，可以通过称为set process group id（setpgid（））的系统调用集来设置这些进程组。
Dialogue: 0,0:21:01.30,0:21:06.96,English,,0,0,0,,And you can fetch that process group using the get process group system call
Dialogue: 0,0:21:01.30,0:21:06.96,Chinese,,0,0,0,,你可以使用get process group系统调用来获取该进程组
Dialogue: 0,0:21:07.62,0:21:14.04,English,,0,0,0,,So you can see in this example what this shell is done is it created a foreground child
Dialogue: 0,0:21:07.62,0:21:14.04,Chinese,,0,0,0,,所以你可以在这个例子中看到这个shell做了什么，它创建了一个前景子
Dialogue: 0,0:21:14.04,0:21:22.42,English,,0,0,0,,So it created this child and it changed the process group id to be equal to the process id of the child
Dialogue: 0,0:21:14.04,0:21:22.42,Chinese,,0,0,0,,因此它创建了这个子节点，并将进程组ID更改为等于子节点的进程ID
Dialogue: 0,0:21:24.06,0:21:27.04,English,,0,0,0,,And then when this child created other child children
Dialogue: 0,0:21:24.06,0:21:27.04,Chinese,,0,0,0,,然后当这个孩子创造了其他孩子的时候
Dialogue: 0,0:21:27.68,0:21:30.52,English,,0,0,0,,They just inherited the same process group id
Dialogue: 0,0:21:27.68,0:21:30.52,Chinese,,0,0,0,,他们只是继承了相同的进程组ID
Dialogue: 0,0:21:34.74,0:21:37.34,English,,0,0,0,,Okay now this notion of a process group is useful
Dialogue: 0,0:21:34.74,0:21:37.34,Chinese,,0,0,0,,好的，现在这个过程组的概念很有用
Dialogue: 0,0:21:37.78,0:21:43.26,English,,0,0,0,,Because it allows you to send signals to groups of processes at the same time
Dialogue: 0,0:21:37.78,0:21:43.26,Chinese,,0,0,0,,因为它允许你同时向进程组发送信号
Dialogue: 0,0:21:43.74,0:21:46.08,English,,0,0,0,,And you can do that with a program called kill
Dialogue: 0,0:21:43.74,0:21:46.08,Chinese,,0,0,0,,你可以用一个名为kill的程序来做到这一点
Dialogue: 0,0:21:46.64,0:21:49.46,English,,0,0,0,,Which is typically in /bin directory
Dialogue: 0,0:21:46.64,0:21:49.46,Chinese,,0,0,0,,这通常位于/ bin目录中
Dialogue: 0,0:21:50.56,0:21:55.60,English,,0,0,0,,And that the kill program you can use the kill program to send an arbitrary signal to
Dialogue: 0,0:21:50.56,0:21:55.60,Chinese,,0,0,0,,而kill程序你可以使用kill程序发送任意信号
Dialogue: 0,0:21:55.78,0:22:00.56,English,,0,0,0,,Either an individual process or all the processes in one process group
Dialogue: 0,0:21:55.78,0:22:00.56,Chinese,,0,0,0,,单个流程或一个流程组中的所有流程
Dialogue: 0,0:22:02.88,0:22:10.46,English,,0,0,0,,So let's look at an example this program,this forks program creates two children
Dialogue: 0,0:22:02.88,0:22:10.46,Chinese,,0,0,0,,让我们看一下这个程序的例子，这个forks程序创建了两个孩子
Dialogue: 0,0:22:13.70,0:22:17.96,English,,0,0,0,,And with each of which has a process group of 24817
Dialogue: 0,0:22:13.70,0:22:17.96,Chinese,,0,0,0,,并且每个都有一个24817的过程组
Dialogue: 0,0:22:18.86,0:22:21.86,English,,0,0,0,,And of course they have different process they have different process ids
Dialogue: 0,0:22:18.86,0:22:21.86,Chinese,,0,0,0,,当然，他们有不同的流程，他们有不同的流程ID
Dialogue: 0,0:22:23.36,0:22:29.58,English,,0,0,0,,And so if we do a ps we see these two processes running
Dialogue: 0,0:22:23.36,0:22:29.58,Chinese,,0,0,0,,因此，如果我们执行ps，我们会看到这两个进程正在运行
Dialogue: 0,0:22:30.90,0:22:34.50,English,,0,0,0,,And these just go into loop so they'll just run continuously
Dialogue: 0,0:22:30.90,0:22:34.50,Chinese,,0,0,0,,而这些只是进入循环所以他们将继续运行
Dialogue: 0,0:22:36.10,0:22:37.50,English,,0,0,0,,Okay now we can
Dialogue: 0,0:22:36.10,0:22:37.50,Chinese,,0,0,0,,好的，我们现在可以
Dialogue: 0,0:22:40.30,0:22:43.48,English,,0,0,0,,We can use kill to kill an individual process
Dialogue: 0,0:22:40.30,0:22:43.48,Chinese,,0,0,0,,我们可以使用kill来杀死一个单独的进程
Dialogue: 0,0:22:44.00,0:22:51.08,English,,0,0,0,,For example so if we call it the first argument indicates what signal you want to send
Dialogue: 0,0:22:44.00,0:22:51.08,Chinese,,0,0,0,,例如，如果我们调用它，则第一个参数指示你要发送的信号
Dialogue: 0,0:22:51.08,0:22:55.30,English,,0,0,0,,So in this case it's signal 9 which is the sigkill signal
Dialogue: 0,0:22:51.08,0:22:55.30,Chinese,,0,0,0,,所以在这种情况下，它是信号9，它是sigkill信号
Dialogue: 0,0:22:55.88,0:23:02.98,English,,0,0,0,,So kill -9 is a very typical,usually if you want to kill processes you just kill -9
Dialogue: 0,0:22:55.88,0:23:02.98,Chinese,,0,0,0,,所以kill -9是一个非常典型的，通常如果你想杀死你刚刚杀死的进程-9
Dialogue: 0,0:23:03.94,0:23:13.10,English,,0,0,0,,And actually one of my favorite auto lab nicknames for 213 was the nickname was kill - 9 15-213
Dialogue: 0,0:23:03.94,0:23:13.10,Chinese,,0,0,0,,实际上，我最喜欢的一个213汽车实验室昵称就是绰号 -  9 15-213
Dialogue: 0,0:23:16.10,0:23:23.20,English,,0,0,0,,So but then the second argument is the if it's is the process id
Dialogue: 0,0:23:16.10,0:23:23.20,Chinese,,0,0,0,,所以，然后第二个参数是if它是进程id
Dialogue: 0,0:23:23.22,0:23:29.54,English,,0,0,0,,So this is asking the kernel to kill process id 24818
Dialogue: 0,0:23:23.22,0:23:29.54,Chinese,,0,0,0,,所以这要求内核杀死进程ID 24818
Dialogue: 0,0:23:30.12,0:23:32.44,English,,0,0,0,,By sending it a sigkill signal
Dialogue: 0,0:23:30.12,0:23:32.44,Chinese,,0,0,0,,发送一个sigkill信号
Dialogue: 0,0:23:33.64,0:23:38.58,English,,0,0,0,,Now if the process id is is preceded by a dash
Dialogue: 0,0:23:33.64,0:23:38.58,Chinese,,0,0,0,,现在，如果进程ID前面有破折号
Dialogue: 0,0:23:40.86,0:23:45.12,English,,0,0,0,,Then it sends a signal to every process in process group
Dialogue: 0,0:23:40.86,0:23:45.12,Chinese,,0,0,0,,然后它向进程组中的每个进程发送一个信号
Dialogue: 0,0:23:45.64,0:23:48.30,English,,0,0,0,,Then it treats this argument as a process group
Dialogue: 0,0:23:45.64,0:23:48.30,Chinese,,0,0,0,,然后它将此参数视为进程组
Dialogue: 0,0:23:48.78,0:23:52.46,English,,0,0,0,,And it sends a signal to every process in that process group
Dialogue: 0,0:23:48.78,0:23:52.46,Chinese,,0,0,0,,它会向该进程组中的每个进程发送一个信号
Dialogue: 0,0:23:52.96,0:23:58.82,English,,0,0,0,,So in this case it will send a signal to both of these children processes
Dialogue: 0,0:23:52.96,0:23:58.82,Chinese,,0,0,0,,因此，在这种情况下，它将向这两个子进程发送信号
Dialogue: 0,0:24:00.48,0:24:05.40,English,,0,0,0,,And then afterwards we if we do a ps we see that those processes are gone
Dialogue: 0,0:24:00.48,0:24:05.40,Chinese,,0,0,0,,然后我们如果我们做ps，我们就会发现这些过程已经消失了
Dialogue: 0,0:24:05.62,0:24:07.90,English,,0,0,0,,Okay that it really did work that way
Dialogue: 0,0:24:05.62,0:24:07.90,Chinese,,0,0,0,,好的，它确实以这种方式工作
Dialogue: 0,0:24:09.78,0:24:15.24,English,,0,0,0,,Now another way to send signals is by typing either ctrl-c or ctrl-z
Dialogue: 0,0:24:09.78,0:24:15.24,Chinese,,0,0,0,,现在另一种发送信号的方法是输入ctrl-c或ctrl-z
Dialogue: 0,0:24:15.62,0:24:18.26,English,,0,0,0,,At the to the command line
Dialogue: 0,0:24:15.62,0:24:18.26,Chinese,,0,0,0,,在命令行
Dialogue: 0,0:24:19.44,0:24:25.50,English,,0,0,0,,Ctrl-c causes the kernel to send a signal to every job in the foreground process group
Dialogue: 0,0:24:19.44,0:24:25.50,Chinese,,0,0,0,,Ctrl-c使内核向前台进程组中的每个作业发送信号
Dialogue: 0,0:24:25.84,0:24:35.58,English,,0,0,0,,And ctrl-z causes it to send a sigtstp signal to every job in the foreground process group
Dialogue: 0,0:24:25.84,0:24:35.58,Chinese,,0,0,0,,并且ctrl-z使它向前台进程组中的每个作业发送sigtstp信号
Dialogue: 0,0:24:36.38,0:24:39.28,English,,0,0,0,,The default action for sigint is to terminate the process
Dialogue: 0,0:24:36.38,0:24:39.28,Chinese,,0,0,0,,sigint的默认操作是终止进程
Dialogue: 0,0:24:39.28,0:24:43.88,English,,0,0,0,,The default action for the sigtstp is to suspend the process stop it
Dialogue: 0,0:24:39.28,0:24:43.88,Chinese,,0,0,0,,sigtstp的默认操作是暂停进程停止它
Dialogue: 0,0:24:44.34,0:24:48.24,English,,0,0,0,,Until it receives a sig cont a signal
Dialogue: 0,0:24:44.34,0:24:48.24,Chinese,,0,0,0,,直到收到sig信号
Dialogue: 0,0:24:54.90,0:24:58.58,English,,0,0,0,,So you can see an example of this here we have a program that
Dialogue: 0,0:24:54.90,0:24:58.58,Chinese,,0,0,0,,所以你可以在这里看到一个例子我们有一个程序
Dialogue: 0,0:25:00.90,0:25:07.27,English,,0,0,0,,Creates a parent and a child running in the foreground so the parents running in the foreground
Dialogue: 0,0:25:00.90,0:25:07.27,Chinese,,0,0,0,,创建在前台运行的父级和子级，以便父级在前台运行
Dialogue: 0,0:25:08.10,0:25:11.04,English,,0,0,0,,Now when we type ctrl-z to the command line
Dialogue: 0,0:25:08.10,0:25:11.04,Chinese,,0,0,0,,现在我们在命令行输入ctrl-z
Dialogue: 0,0:25:12.70,0:25:16.36,English,,0,0,0,,The shell notifies us that it's suspended that process
Dialogue: 0,0:25:12.70,0:25:16.36,Chinese,,0,0,0,,shell通知我们它已暂停该进程
Dialogue: 0,0:25:16.80,0:25:23.90,English,,0,0,0,,And if we do a ps we can see the parent and the child indeed are suspended
Dialogue: 0,0:25:16.80,0:25:23.90,Chinese,,0,0,0,,如果我们做ps，我们可以看到父母和孩子确实被暂停了
Dialogue: 0,0:25:23.94,0:25:28.72,English,,0,0,0,,So the ps indicates that it's suspended or stopped using T
Dialogue: 0,0:25:23.94,0:25:28.72,Chinese,,0,0,0,,因此ps表示它使用T暂停或停止
Dialogue: 0,0:25:33.04,0:25:37.04,English,,0,0,0,,Now next we type in the built in the shell built in which is fg
Dialogue: 0,0:25:33.04,0:25:37.04,Chinese,,0,0,0,,接下来我们输入内置的shell内置的fg
Dialogue: 0,0:25:37.16,0:25:42.36,English,,0,0,0,,And fg restores those suspended jobs to the foreground
Dialogue: 0,0:25:37.16,0:25:42.36,Chinese,,0,0,0,,并且fg将这些暂停的作业恢复到前台
Dialogue: 0,0:25:44.70,0:25:50.06,English,,0,0,0,,So after typing fg now we're running this our program again in the foreground
Dialogue: 0,0:25:44.70,0:25:50.06,Chinese,,0,0,0,,所以在输入fg之后我们再次在前台运行这个程序
Dialogue: 0,0:25:51.58,0:25:54.28,English,,0,0,0,,And then we can kill it by typing ctrl-c
Dialogue: 0,0:25:51.58,0:25:54.28,Chinese,,0,0,0,,然后我们可以通过输入ctrl-c来杀死它
Dialogue: 0,0:25:54.78,0:25:58.84,English,,0,0,0,,Which elicits a sigint whose default action is to terminate
Dialogue: 0,0:25:54.78,0:25:58.84,Chinese,,0,0,0,,这会引出一个sigint，其默认操作是终止
Dialogue: 0,0:25:59.18,0:26:03.30,English,,0,0,0,,And then when we do a ps we see that indeed that's that they're gone
Dialogue: 0,0:25:59.18,0:26:03.30,Chinese,,0,0,0,,然后，当我们做ps时，我们确实看到它们已经消失了
Dialogue: 0,0:26:06.96,0:26:11.40,English,,0,0,0,,Now the third way that we can send signals is by using the kill system call
Dialogue: 0,0:26:06.96,0:26:11.40,Chinese,,0,0,0,,现在我们发送信号的第三种方法是使用kill系统调用
Dialogue: 0,0:26:15.44,0:26:17.60,English,,0,0,0,,So here's an example of how that works
Dialogue: 0,0:26:15.44,0:26:17.60,Chinese,,0,0,0,,所以这是一个如何工作的例子
Dialogue: 0,0:26:18.04,0:26:21.82,English,,0,0,0,,So in this example we're creating N children
Dialogue: 0,0:26:18.04,0:26:21.82,Chinese,,0,0,0,,所以在这个例子中我们创造了N个孩子
Dialogue: 0,0:26:23.00,0:26:25.14,English,,0,0,0,,Now each of which goes into an infinite loop
Dialogue: 0,0:26:23.00,0:26:25.14,Chinese,,0,0,0,,现在每个都进入无限循环
Dialogue: 0,0:26:25.84,0:26:29.90,English,,0,0,0,,And we're recording this the process id of each child that we create
Dialogue: 0,0:26:25.84,0:26:29.90,Chinese,,0,0,0,,我们正在记录我们创建的每个孩子的进程ID
Dialogue: 0,0:26:31.92,0:26:34.90,English,,0,0,0,,And then in it we go in...another loop we go through
Dialogue: 0,0:26:31.92,0:26:34.90,Chinese,,0,0,0,,然后我们进入...我们经历的另一个循环
Dialogue: 0,0:26:34.90,0:26:40.02,English,,0,0,0,,And we kill each of those child processes with by using the kill function
Dialogue: 0,0:26:34.90,0:26:40.02,Chinese,,0,0,0,,我们使用kill函数杀死每个子进程
Dialogue: 0,0:26:40.74,0:26:45.56,English,,0,0,0,,Passing it the process id and the signal that we want sent to that process
Dialogue: 0,0:26:40.74,0:26:45.56,Chinese,,0,0,0,,将过程ID和我们想要发送的信号传递给该过程
Dialogue: 0,0:26:47.72,0:26:52.24,English,,0,0,0,,Okay and then we do our due diligence and reap each one of those
Dialogue: 0,0:26:47.72,0:26:52.24,Chinese,,0,0,0,,好的，然后我们尽职尽责并收获其中的每一个
Dialogue: 0,0:26:52.64,0:26:54.64,English,,0,0,0,,Children that we've terminated
Dialogue: 0,0:26:52.64,0:26:54.64,Chinese,,0,0,0,,我们已经终止的孩子
Dialogue: 0,0:26:55.56,0:27:02.28,English,,0,0,0,,Now this isn't strictly necessary because we're going to exit as soon as this fork12 function
Dialogue: 0,0:26:55.56,0:27:02.28,Chinese,,0,0,0,,现在这不是绝对必要的，因为我们将在fork12函数发布后立即退出
Dialogue: 0,0:27:02.80,0:27:06.58,English,,0,0,0,,Returns we're going to exit the code so but we're just being
Dialogue: 0,0:27:02.80,0:27:06.58,Chinese,,0,0,0,,返回我们将退出代码，但我们只是存在
Dialogue: 0,0:27:07.38,0:27:11.90,English,,0,0,0,,You know careful here and maybe a little pedantic but
Dialogue: 0,0:27:07.38,0:27:11.90,Chinese,,0,0,0,,你在这里小心谨慎，也许有点迂腐但是
Dialogue: 0,0:27:16.02,0:27:20.26,English,,0,0,0,,Okay now let's look at how we process receive signals
Dialogue: 0,0:27:16.02,0:27:20.26,Chinese,,0,0,0,,好的，现在让我们来看看我们如何处理接收信号
Dialogue: 0,0:27:22.58,0:27:29.72,English,,0,0,0,,Now suppose process A is running along executing its user code and then
Dialogue: 0,0:27:22.58,0:27:29.72,Chinese,,0,0,0,,现在假设进程A正在执行其用户代码然后运行
Dialogue: 0,0:27:30.48,0:27:34.94,English,,0,0,0,,There's a control passes into the kernel because of some exception
Dialogue: 0,0:27:30.48,0:27:34.94,Chinese,,0,0,0,,由于某些异常，有一个控件进入内核
Dialogue: 0,0:27:36.12,0:27:40.36,English,,0,0,0,,Now that exception can be either a timer going off
Dialogue: 0,0:27:36.12,0:27:40.36,Chinese,,0,0,0,,现在该异常可以是计时器关闭
Dialogue: 0,0:27:40.90,0:27:45.12,English,,0,0,0,,They've been interrupts or it can be a trap user calls a system call
Dialogue: 0,0:27:40.90,0:27:45.12,Chinese,,0,0,0,,它们是中断，或者它可以是用户调用系统调用的陷阱
Dialogue: 0,0:27:45.76,0:27:50.50,English,,0,0,0,,Okay but it's always caused that the trap into the
Dialogue: 0,0:27:45.76,0:27:50.50,Chinese,,0,0,0,,好吧，但它总是导致陷阱进入
Dialogue: 0,0:27:51.20,0:27:54.26,English,,0,0,0,,Or the transferring control into the kernel is always caused by some exception
Dialogue: 0,0:27:51.20,0:27:54.26,Chinese,,0,0,0,,或者将控制转移到内核总是由一些异常引起
Dialogue: 0,0:27:56.18,0:27:59.48,English,,0,0,0,,So at this point the kernel calls its scheduler function
Dialogue: 0,0:27:56.18,0:27:59.48,Chinese,,0,0,0,,所以此时内核调用其调度程序函数
Dialogue: 0,0:28:00.12,0:28:07.34,English,,0,0,0,,And it decides do a context switch from process A to process B
Dialogue: 0,0:28:00.12,0:28:07.34,Chinese,,0,0,0,,它决定从进程A到进程B进行上下文切换
Dialogue: 0,0:28:09.46,0:28:15.50,English,,0,0,0,,And it gets processed B all set up and right before it returns from that exception
Dialogue: 0,0:28:09.46,0:28:15.50,Chinese,,0,0,0,,并且它会在从该异常返回之前立即进行处理
Dialogue: 0,0:28:16.26,0:28:24.24,English,,0,0,0,,And right before it's ready to pass control back to process the user code and process B
Dialogue: 0,0:28:16.26,0:28:24.24,Chinese,,0,0,0,,就在它准备好将控制权传回处理用户代码和处理B之前
Dialogue: 0,0:28:25.30,0:28:29.34,English,,0,0,0,,It checks for any signals that any pending signals
Dialogue: 0,0:28:25.30,0:28:29.34,Chinese,,0,0,0,,它检查任何待处理信号的任何信号
Dialogue: 0,0:28:32.58,0:28:38.50,English,,0,0,0,,Okay and it does this by computing a bit vector pnb so pending nonblocked
Dialogue: 0,0:28:32.58,0:28:38.50,Chinese,,0,0,0,,好吧，它通过计算一个位向量非阻塞的位向量pnb来做到这一点
Dialogue: 0,0:28:39.42,0:28:42.58,English,,0,0,0,,Which is the logical and of the pending bit vector
Dialogue: 0,0:28:39.42,0:28:42.58,Chinese,,0,0,0,,哪个是逻辑和未决位向量
Dialogue: 0,0:28:44.00,0:28:46.48,English,,0,0,0,,And the inverse of the blocked bit vector
Dialogue: 0,0:28:44.00,0:28:46.48,Chinese,,0,0,0,,和阻塞位向量的倒数
Dialogue: 0,0:28:47.74,0:28:52.10,English,,0,0,0,,Okay so pnb is a list of all the pending signals that aren't blocked
Dialogue: 0,0:28:47.74,0:28:52.10,Chinese,,0,0,0,,好的，所以pnb是未阻止的所有待处理信号的列表
Dialogue: 0,0:28:53.34,0:28:56.08,English,,0,0,0,,Okay so these are all the pending signals that should be received
Dialogue: 0,0:28:53.34,0:28:56.08,Chinese,,0,0,0,,好的，这些都是应该收到的待处理信号
Dialogue: 0,0:28:59.12,0:29:02.84,English,,0,0,0,,Now if pnb is all zeros then there's no pending signals
Dialogue: 0,0:28:59.12,0:29:02.84,Chinese,,0,0,0,,现在，如果pnb全为零，那么就没有未决信号
Dialogue: 0,0:29:03.04,0:29:05.86,English,,0,0,0,,So it just returns it passes control back
Dialogue: 0,0:29:03.04,0:29:05.86,Chinese,,0,0,0,,所以它只是返回它通过控制回来
Dialogue: 0,0:29:07.18,0:29:10.98,English,,0,0,0,,It passes control back to process B which can continue executing
Dialogue: 0,0:29:07.18,0:29:10.98,Chinese,,0,0,0,,它将控制权传递回进程B，进程B可以继续执行
Dialogue: 0,0:29:11.64,0:29:14.18,English,,0,0,0,,However if pnb is nonzero then
Dialogue: 0,0:29:11.64,0:29:14.18,Chinese,,0,0,0,,但是，如果pnb非零
Dialogue: 0,0:29:15.10,0:29:19.70,English,,0,0,0,,It chooses the smallest nonzero bit in pnb
Dialogue: 0,0:29:15.10,0:29:19.70,Chinese,,0,0,0,,它选择pnb中最小的非零位
Dialogue: 0,0:29:19.70,0:29:24.56,English,,0,0,0,,And it forces process p to receive that signal the corresponding signal
Dialogue: 0,0:29:19.70,0:29:24.56,Chinese,,0,0,0,,并且它强制进程p接收该信号相应的信号
Dialogue: 0,0:29:27.74,0:29:32.20,English,,0,0,0,,The receipt of the signal triggers some action in the process
Dialogue: 0,0:29:27.74,0:29:32.20,Chinese,,0,0,0,,收到信号会在此过程中触发一些操作
Dialogue: 0,0:29:36.24,0:29:44.34,English,,0,0,0,,And then we repeat that for all the nonzero signals k that are nonzero bits that are set in pnb
Dialogue: 0,0:29:36.24,0:29:44.34,Chinese,,0,0,0,,然后我们重复所有非零信号k，它们是在pnb中设置的非零位
Dialogue: 0,0:29:44.78,0:29:47.60,English,,0,0,0,,And finally when we've gone all through all the nonzero bits
Dialogue: 0,0:29:44.78,0:29:47.60,Chinese,,0,0,0,,最后，当我们完成所有非零位时
Dialogue: 0,0:29:48.14,0:29:56.70,English,,0,0,0,,Then we pass control to the next instruction in process p
Dialogue: 0,0:29:48.14,0:29:56.70,Chinese,,0,0,0,,然后我们将控制传递给过程p中的下一条指令
Dialogue: 0,0:30:00.72,0:30:03.96,English,,0,0,0,,So the receipt of a signal always triggers some action
Dialogue: 0,0:30:00.72,0:30:03.96,Chinese,,0,0,0,,因此，接收信号总是会触发一些动作
Dialogue: 0,0:30:04.46,0:30:06.93,English,,0,0,0,,Which is either the process terminates
Dialogue: 0,0:30:04.46,0:30:06.93,Chinese,,0,0,0,,哪个过程终止
Dialogue: 0,0:30:07.86,0:30:11.40,English,,0,0,0,,The process stops until it's restarted by a sick can't signal
Dialogue: 0,0:30:07.86,0:30:11.40,Chinese,,0,0,0,,该过程停止，直到病人重新启动无法发出信号
Dialogue: 0,0:30:12.42,0:30:14.52,English,,0,0,0,,The process ignores the signal
Dialogue: 0,0:30:12.42,0:30:14.52,Chinese,,0,0,0,,该过程忽略了信号
Dialogue: 0,0:30:15.36,0:30:18.42,English,,0,0,0,,Ok so that's there's always some predefined default action
Dialogue: 0,0:30:15.36,0:30:18.42,Chinese,,0,0,0,,好的，总是有一些预定义的默认动作
Dialogue: 0,0:30:21.72,0:30:29.72,English,,0,0,0,,But we can modify that default action by using a function system call called signal
Dialogue: 0,0:30:21.72,0:30:29.72,Chinese,,0,0,0,,但我们可以通过使用名为signal的函数系统调用来修改该默认操作
Dialogue: 0,0:30:31.66,0:30:37.28,English,,0,0,0,,Ok so we can...now signals a little that's another sort of misleading kind of term just like kill right because when we
Dialogue: 0,0:30:31.66,0:30:37.28,Chinese,,0,0,0,,好的，我们可以...现在发出一点点信息，这是另一种误导性的术语，就像杀人权一样，因为当我们这样做时
Dialogue: 0,0:30:37.74,0:30:40.50,English,,0,0,0,,When we send a signal to a process we don't always want to kill it
Dialogue: 0,0:30:37.74,0:30:40.50,Chinese,,0,0,0,,当我们向进程发送信号时，我们并不总是想要杀死它
Dialogue: 0,0:30:41.74,0:30:44.02,English,,0,0,0,,And signal doesn't actually signal anything
Dialogue: 0,0:30:41.74,0:30:44.02,Chinese,,0,0,0,,并且信号实际上并不发出任何信号
Dialogue: 0,0:30:44.40,0:30:49.22,English,,0,0,0,,It just modifies the default action associated with some something
Dialogue: 0,0:30:44.40,0:30:49.22,Chinese,,0,0,0,,它只是修改了与某些东西相关的默认动作
Dialogue: 0,0:30:50.74,0:30:55.02,English,,0,0,0,,Okay so if the signal function takes out a signal number(signum)
Dialogue: 0,0:30:50.74,0:30:55.02,Chinese,,0,0,0,,好的，如果信号功能取出一个信号编号（signum）
Dialogue: 0,0:30:56.90,0:31:01.98,English,,0,0,0,,And then specifies a change in the default action for that signal
Dialogue: 0,0:30:56.90,0:31:01.98,Chinese,,0,0,0,,然后指定该信号的默认操作的更改
Dialogue: 0,0:31:04.16,0:31:07.46,English,,0,0,0,,And those default actions can be either to ignore the signal(sig_ign)
Dialogue: 0,0:31:04.16,0:31:07.46,Chinese,,0,0,0,,这些默认操作可以是忽略信号（sig_ign）
Dialogue: 0,0:31:08.30,0:31:14.96,English,,0,0,0,,Ok ignore signals of type signal,revert to the default behavior for that signal
Dialogue: 0,0:31:08.30,0:31:14.96,Chinese,,0,0,0,,好的，忽略信号类型的信号，恢复到该信号的默认行为
Dialogue: 0,0:31:17.48,0:31:21.96,English,,0,0,0,,Or we can give it...or it can be the address of a user level signal handler
Dialogue: 0,0:31:17.48,0:31:21.96,Chinese,,0,0,0,,或者我们可以给它......或者它可以是用户级信号处理程序的地址
Dialogue: 0,0:31:22.64,0:31:26.38,English,,0,0,0,,Which is a function that we've declared in our C program
Dialogue: 0,0:31:22.64,0:31:26.38,Chinese,,0,0,0,,这是我们在C程序中声明的函数
Dialogue: 0,0:31:26.76,0:31:32.92,English,,0,0,0,,Ok there's nothing special about the function it has a certain prototype that has it takes a single argument
Dialogue: 0,0:31:26.76,0:31:32.92,Chinese,,0,0,0,,好吧，它有一个特定原型的函数没有什么特别之处，只需要一个参数
Dialogue: 0,0:31:33.60,0:31:40.06,English,,0,0,0,,Which is the signal number so when that function gets called in response to receiving a signal
Dialogue: 0,0:31:33.60,0:31:40.06,Chinese,,0,0,0,,当响应接收信号调用该函数时，这是信号编号
Dialogue: 0,0:31:41.24,0:31:44.02,English,,0,0,0,,That argument will be set to the signal number
Dialogue: 0,0:31:41.24,0:31:44.02,Chinese,,0,0,0,,该参数将被设置为信号编号
Dialogue: 0,0:31:47.80,0:31:54.54,English,,0,0,0,,So calling signal with a specifying a signal handler is called installing a handler
Dialogue: 0,0:31:47.80,0:31:54.54,Chinese,,0,0,0,,因此，使用指定信号处理程序的调用信号称为安装处理程序
Dialogue: 0,0:31:55.42,0:31:59.68,English,,0,0,0,,And then executing the handlers referred to as catching or executing
Dialogue: 0,0:31:55.42,0:31:59.68,Chinese,,0,0,0,,然后执行称为捕获或执行的处理程序
Dialogue: 0,0:31:59.68,0:32:01.52,English,,0,0,0,,They were handling the signal
Dialogue: 0,0:31:59.68,0:32:01.52,Chinese,,0,0,0,,他们正在处理信号
Dialogue: 0,0:32:03.78,0:32:06.64,English,,0,0,0,,And and this handler then is just like an exception handler
Dialogue: 0,0:32:03.78,0:32:06.64,Chinese,,0,0,0,,而且这个处理程序就像一个异常处理程序
Dialogue: 0,0:32:06.66,0:32:12.56,English,,0,0,0,,When it returns it will be when it's executed it will interrupt the
Dialogue: 0,0:32:06.66,0:32:12.56,Chinese,,0,0,0,,当它返回时它将被执行时它会中断
Dialogue: 0,0:32:13.16,0:32:16.66,English,,0,0,0,,Whatever is currently executing in the process when it returns
Dialogue: 0,0:32:13.16,0:32:16.66,Chinese,,0,0,0,,当它返回时当前正在执行的任何事情
Dialogue: 0,0:32:16.92,0:32:19.94,English,,0,0,0,,It will return back to that point and continue executing
Dialogue: 0,0:32:16.92,0:32:19.94,Chinese,,0,0,0,,它将返回到该点并继续执行
Dialogue: 0,0:32:22.74,0:32:26.74,English,,0,0,0,,Okay so here's a simple example of installing a handler
Dialogue: 0,0:32:22.74,0:32:26.74,Chinese,,0,0,0,,好的，这是一个安装处理程序的简单示例
Dialogue: 0,0:32:28.62,0:32:32.48,English,,0,0,0,,So here in main where we're going to install a sigint handler
Dialogue: 0,0:32:28.62,0:32:32.48,Chinese,,0,0,0,,所以这里主要是我们要安装一个sigint处理程序
Dialogue: 0,0:32:34.92,0:32:38.80,English,,0,0,0,,Which is called sigint_handler which is defined up here
Dialogue: 0,0:32:34.92,0:32:38.80,Chinese,,0,0,0,,这里定义的是sigint_handler
Dialogue: 0,0:32:39.80,0:32:43.12,English,,0,0,0,,And the prototype for this function is returns nothing
Dialogue: 0,0:32:39.80,0:32:43.12,Chinese,,0,0,0,,并且这个函数的原型没有返回
Dialogue: 0,0:32:43.80,0:32:48.12,English,,0,0,0,,And it takes a single integer argument which is the signal number and returns nothing
Dialogue: 0,0:32:43.80,0:32:48.12,Chinese,,0,0,0,,它需要一个整数参数，即信号编号，不返回任何内容
Dialogue: 0,0:32:50.76,0:32:52.42,English,,0,0,0,,Okay and after we install that handler
Dialogue: 0,0:32:50.76,0:32:52.42,Chinese,,0,0,0,,好的，在我们安装该处理程序之后
Dialogue: 0,0:32:53.12,0:32:59.24,English,,0,0,0,,Then we're going to execute the pause this call which just waits for a signal handler to execute
Dialogue: 0,0:32:53.12,0:32:59.24,Chinese,,0,0,0,,然后我们将执行暂停此调用，该调用只是等待信号处理程序执行
Dialogue: 0,0:32:59.48,0:33:03.20,English,,0,0,0,,Ok so pause terminates the current or suspends the current process
Dialogue: 0,0:32:59.48,0:33:03.20,Chinese,,0,0,0,,好的，所以暂停会终止当前进程或暂停当前进程
Dialogue: 0,0:33:04.28,0:33:08.38,English,,0,0,0,,Until a signal is received and a handler executes in that process
Dialogue: 0,0:33:04.28,0:33:08.38,Chinese,,0,0,0,,直到收到信号并且在该过程中执行处理程序
Dialogue: 0,0:33:08.92,0:33:10.68,English,,0,0,0,,And then pause then pause returns
Dialogue: 0,0:33:08.92,0:33:10.68,Chinese,,0,0,0,,然后暂停然后暂停返回
Dialogue: 0,0:33:13.36,0:33:16.36,English,,0,0,0,,So we're going to wait until the sigint happens
Dialogue: 0,0:33:13.36,0:33:16.36,Chinese,,0,0,0,,所以我们要等到sigint发生
Dialogue: 0,0:33:16.40,0:33:19.54,English,,0,0,0,,So sigint entry call is when we type ctrl-c
Dialogue: 0,0:33:16.40,0:33:19.54,Chinese,,0,0,0,,因此，当我们输入ctrl-c时，sigint条目调用
Dialogue: 0,0:33:21.98,0:33:27.04,English,,0,0,0,,So when you're doing your bombs did you panic at some point and try to hit ctrl-c to get out of it
Dialogue: 0,0:33:21.98,0:33:27.04,Chinese,,0,0,0,,所以，当你做你的炸弹时，你是否在某些时候感到恐慌并试图按下ctrl-c来摆脱它
Dialogue: 0,0:33:28.50,0:33:30.86,English,,0,0,0,,Okay so that snarky message you got that was
Dialogue: 0,0:33:28.50,0:33:30.86,Chinese,,0,0,0,,好的，这就是你得到的讽刺信息
Dialogue: 0,0:33:32.04,0:33:37.20,English,,0,0,0,,We did that by installing a sigint handler in your bomb
Dialogue: 0,0:33:32.04,0:33:37.20,Chinese,,0,0,0,,我们通过在你的炸弹中安装一个sigint处理程序来做到这一点
Dialogue: 0,0:33:38.78,0:33:43.14,English,,0,0,0,,Okay so when you type ctrl-c that elicits a sigint
Dialogue: 0,0:33:38.78,0:33:43.14,Chinese,,0,0,0,,好吧，当你输入引发sigint的ctrl-c时
Dialogue: 0,0:33:43.60,0:33:51.60,English,,0,0,0,,When that sigint is received,we printed this message and then eventually let you exit
Dialogue: 0,0:33:43.60,0:33:51.60,Chinese,,0,0,0,,收到该sigint后，我们打印此消息，然后最终让你退出
Dialogue: 0,0:33:56.90,0:34:01.38,English,,0,0,0,,Now signals are another examples of concurrency
Dialogue: 0,0:33:56.90,0:34:01.38,Chinese,,0,0,0,,现在信号是并发的另一个例子
Dialogue: 0,0:34:02.16,0:34:06.92,English,,0,0,0,,Now we've seen concurrency earlier in the form of processes
Dialogue: 0,0:34:02.16,0:34:06.92,Chinese,,0,0,0,,现在我们早先以流程的形式看到了并发性
Dialogue: 0,0:34:07.84,0:34:12.90,English,,0,0,0,,Right concurrent flows overlapping in time
Dialogue: 0,0:34:07.84,0:34:12.90,Chinese,,0,0,0,,正确的并发流程在时间上重叠
Dialogue: 0,0:34:14.14,0:34:19.32,English,,0,0,0,,Okay logical flows overlapping in time by definition are concurrent
Dialogue: 0,0:34:14.14,0:34:19.32,Chinese,,0,0,0,,按定义，时间重叠的逻辑流是并发的
Dialogue: 0,0:34:20.58,0:34:26.62,English,,0,0,0,,Now with processes the because they have separate address spaces
Dialogue: 0,0:34:20.58,0:34:26.62,Chinese,,0,0,0,,现在有了进程，因为它们有单独的地址空间
Dialogue: 0,0:34:26.84,0:34:29.46,English,,0,0,0,,Those concurrent flows never interfere with each other
Dialogue: 0,0:34:26.84,0:34:29.46,Chinese,,0,0,0,,这些并发流量永远不会相互干扰
Dialogue: 0,0:34:29.58,0:34:33.62,English,,0,0,0,,Right so in some sense processes are very easy to deal with
Dialogue: 0,0:34:29.58,0:34:33.62,Chinese,,0,0,0,,对，因此在某种意义上，流程很容易处理
Dialogue: 0,0:34:34.10,0:34:40.18,English,,0,0,0,,And we don't really have to worry one process doesn't have to worry about being interfered with by another process
Dialogue: 0,0:34:34.10,0:34:40.18,Chinese,,0,0,0,,而且我们真的不必担心一个过程不必担心受到另一个过程的干扰
Dialogue: 0,0:34:42.02,0:34:47.46,English,,0,0,0,,In fact you have to go to great lengths to share like to share things between processes
Dialogue: 0,0:34:42.02,0:34:47.46,Chinese,,0,0,0,,事实上，你必须竭尽全力分享，以便在流程之间分享
Dialogue: 0,0:34:47.46,0:34:53.78,English,,0,0,0,,You have to use specific system calls in order to say share memory between two processes
Dialogue: 0,0:34:47.46,0:34:53.78,Chinese,,0,0,0,,你必须使用特定的系统调用才能说两个进程之间共享内存
Dialogue: 0,0:34:55.22,0:34:59.90,English,,0,0,0,,Now signals are another form of concurrency this is the second time in this class that
Dialogue: 0,0:34:55.22,0:34:59.90,Chinese,,0,0,0,,现在信号是另一种并发形式，这是本课程中的第二次
Dialogue: 0,0:35:01.42,0:35:03.08,English,,0,0,0,,That you've experienced concurrency
Dialogue: 0,0:35:01.42,0:35:03.08,Chinese,,0,0,0,,你经历过并发
Dialogue: 0,0:35:03.98,0:35:08.22,English,,0,0,0,,And so a signal is just a concurrent flow,it's just a logical flow a sit
Dialogue: 0,0:35:03.98,0:35:08.22,Chinese,,0,0,0,,所以信号只是一个并发流，它只是一个逻辑流程
Dialogue: 0,0:35:08.86,0:35:13.82,English,,0,0,0,,So a handler is just another logical flow that runs concurrently with your program
Dialogue: 0,0:35:08.86,0:35:13.82,Chinese,,0,0,0,,因此，处理程序只是与程序同时运行的另一个逻辑流程
Dialogue: 0,0:35:14.92,0:35:19.28,English,,0,0,0,,Right so we're...let's say we're executing a while loop in process A
Dialogue: 0,0:35:14.92,0:35:19.28,Chinese,,0,0,0,,对，所以我们......让我们说我们在进程A中执行while循环
Dialogue: 0,0:35:20.76,0:35:22.90,English,,0,0,0,,Okay that while loop is executing
Dialogue: 0,0:35:20.76,0:35:22.90,Chinese,,0,0,0,,好的，循环正在执行
Dialogue: 0,0:35:23.46,0:35:25.56,English,,0,0,0,,And in process a receives the signal
Dialogue: 0,0:35:23.46,0:35:25.56,Chinese,,0,0,0,,并且在过程中接收信号
Dialogue: 0,0:35:26.54,0:35:29.22,English,,0,0,0,,Which causes a transfer of control to this handler
Dialogue: 0,0:35:26.54,0:35:29.22,Chinese,,0,0,0,,这导致控制权转移到此处理程序
Dialogue: 0,0:35:31.84,0:35:35.30,English,,0,0,0,,This handler executes so this is a concurrent flow
Dialogue: 0,0:35:31.84,0:35:35.30,Chinese,,0,0,0,,此处理程序执行，因此这是一个并发流
Dialogue: 0,0:35:36.12,0:35:42.24,English,,0,0,0,,That overlaps in time with the while loop in process A eventually this handler returns
Dialogue: 0,0:35:36.12,0:35:42.24,Chinese,,0,0,0,,这与进程A中的while循环在时间上重叠，最终这个处理程序返回
Dialogue: 0,0:35:43.24,0:35:48.42,English,,0,0,0,,And we return for the back tip to back to process A
Dialogue: 0,0:35:43.24,0:35:48.42,Chinese,,0,0,0,,然后我们返回后端回到进程A.
Dialogue: 0,0:35:50.34,0:35:58.26,English,,0,0,0,,Now one of the reasons signals are so tricky is because of this overlapping concurrent flow
Dialogue: 0,0:35:50.34,0:35:58.26,Chinese,,0,0,0,,现在信号之所以如此棘手的原因之一是因为这种重叠的并发流
Dialogue: 0,0:35:59.86,0:36:06.06,English,,0,0,0,,This concurrency because the signal handler runs in the same process  as the main program
Dialogue: 0,0:35:59.86,0:36:06.06,Chinese,,0,0,0,,这种并发性是因为信号处理程序在与主程序相同的进程中运行
Dialogue: 0,0:36:06.68,0:36:10.12,English,,0,0,0,,So it shares all the global variables of that program
Dialogue: 0,0:36:06.68,0:36:10.12,Chinese,,0,0,0,,因此它共享该程序的所有全局变量
Dialogue: 0,0:36:11.76,0:36:15.26,English,,0,0,0,,Okay so you're that signal handler is a function
Dialogue: 0,0:36:11.76,0:36:15.26,Chinese,,0,0,0,,好的，所以你是信号处理程序是一个功能
Dialogue: 0,0:36:15.26,0:36:21.54,English,,0,0,0,,That you've declared and it has access to all the state,all the global state in the program
Dialogue: 0,0:36:15.26,0:36:21.54,Chinese,,0,0,0,,你已声明并且它可以访问所有状态，即程序中的所有全局状态
Dialogue: 0,0:36:23.40,0:36:27.86,English,,0,0,0,,Okay and the existence of the shared global state can create real problems
Dialogue: 0,0:36:23.40,0:36:27.86,Chinese,,0,0,0,,好的，共享全球状态的存在可能会产生真正的问题
Dialogue: 0,0:36:37.50,0:36:40.48,English,,0,0,0,,And we'll get into more details about some of those problems
Dialogue: 0,0:36:37.50,0:36:40.48,Chinese,,0,0,0,,我们将详细介绍其中一些问题
Dialogue: 0,0:36:42.08,0:36:49.90,English,,0,0,0,,So another way to look at these signal handlers disking as concurrent flows is using this context switch diagram
Dialogue: 0,0:36:42.08,0:36:49.90,Chinese,,0,0,0,,因此，另一种将这些信号处理程序视为并发流的方法是使用此上下文切换图
Dialogue: 0,0:36:50.62,0:36:53.32,English,,0,0,0,,So suppose we're executing in process A
Dialogue: 0,0:36:50.62,0:36:53.32,Chinese,,0,0,0,,所以假设我们正在进程A中执行
Dialogue: 0,0:36:54.50,0:37:00.85,English,,0,0,0,,And now at some point a signal delivered to process A
Dialogue: 0,0:36:54.50,0:37:00.85,Chinese,,0,0,0,,现在在某个时刻，信号传递给过程A.
Dialogue: 0,0:37:01.70,0:37:06.78,English,,0,0,0,,Now nothing happens right just the pending bit gets set in process A at this point
Dialogue: 0,0:37:01.70,0:37:06.78,Chinese,,0,0,0,,现在没有任何事情发生，只是在此过程中在进程A中设置了挂起位
Dialogue: 0,0:37:08.64,0:37:12.52,English,,0,0,0,,Now at some point there's a transfer of control into the kernel
Dialogue: 0,0:37:08.64,0:37:12.52,Chinese,,0,0,0,,现在，在某些时候，控制权已转移到内核中
Dialogue: 0,0:37:13.44,0:37:17.20,English,,0,0,0,,And the kernel decides to do a context switch from A to B
Dialogue: 0,0:37:13.44,0:37:17.20,Chinese,,0,0,0,,内核决定从A到B进行上下文切换
Dialogue: 0,0:37:18.08,0:37:22.34,English,,0,0,0,,And now B gets to run for a while there's another transfer of control to the kernel
Dialogue: 0,0:37:18.08,0:37:22.34,Chinese,,0,0,0,,现在B运行了一段时间，还有另一个控制权转移到内核
Dialogue: 0,0:37:24.30,0:37:27.02,English,,0,0,0,,And the kernel decides to schedule process A
Dialogue: 0,0:37:24.30,0:37:27.02,Chinese,,0,0,0,,内核决定安排进程A.
Dialogue: 0,0:37:28.62,0:37:32.90,English,,0,0,0,,And now right before it returns control to process A
Dialogue: 0,0:37:28.62,0:37:32.90,Chinese,,0,0,0,,现在就在它将控制权返回给流程A之前
Dialogue: 0,0:37:33.26,0:37:37.36,English,,0,0,0,,It notices that the pending bit for this signal is set
Dialogue: 0,0:37:33.26,0:37:37.36,Chinese,,0,0,0,,它注意到该信号的待定位已设置
Dialogue: 0,0:37:37.76,0:37:40.38,English,,0,0,0,,So it causes process A to receive that signal
Dialogue: 0,0:37:37.76,0:37:40.38,Chinese,,0,0,0,,因此它使进程A接收该信号
Dialogue: 0,0:37:41.00,0:37:42.88,English,,0,0,0,,So that executes the handler code
Dialogue: 0,0:37:41.00,0:37:42.88,Chinese,,0,0,0,,这样就执行了处理程序代码
Dialogue: 0,0:37:43.68,0:37:48.12,English,,0,0,0,,When the handler returns, it returns for brief briefly to the kernel
Dialogue: 0,0:37:43.68,0:37:48.12,Chinese,,0,0,0,,当处理程序返回时，它会简要地返回内核
Dialogue: 0,0:37:48.18,0:37:53.76,English,,0,0,0,,Which then transfers control back to the the next instruction that the process was going to execute
Dialogue: 0,0:37:48.18,0:37:53.76,Chinese,,0,0,0,,然后将控制权转移回进程将要执行的下一条指令
Dialogue: 0,0:37:56.48,0:38:00.56,English,,0,0,0,,Now handlers are also tricky because they can be interrupted by other handlers
Dialogue: 0,0:37:56.48,0:38:00.56,Chinese,,0,0,0,,现在处理程序也很棘手，因为它们可能被其他处理程序打断
Dialogue: 0,0:38:01.34,0:38:06.56,English,,0,0,0,,So suppose we have our main program that catches a signal s
Dialogue: 0,0:38:01.34,0:38:06.56,Chinese,,0,0,0,,因此，假设我们的主程序捕获了一个信号
Dialogue: 0,0:38:08.00,0:38:10.70,English,,0,0,0,,Which causes a transfer of control to handler S
Dialogue: 0,0:38:08.00,0:38:10.70,Chinese,,0,0,0,,这导致控制权转移到处理程序S.
Dialogue: 0,0:38:11.44,0:38:13.76,English,,0,0,0,,And then we'll handler S did you have a question okay
Dialogue: 0,0:38:11.44,0:38:13.76,Chinese,,0,0,0,,然后我们处理S你有问题吗？
Dialogue: 0,0:38:15.24,0:38:19.00,English,,0,0,0,,Well handler S is executing
Dialogue: 0,0:38:15.24,0:38:19.00,Chinese,,0,0,0,,井处理程序S正在执行
Dialogue: 0,0:38:22.96,0:38:28.28,English,,0,0,0,,The program catches a signal t
Dialogue: 0,0:38:22.96,0:38:28.28,Chinese,,0,0,0,,该程序捕获信号t
Dialogue: 0,0:38:30.62,0:38:35.78,English,,0,0,0,,Which causes a transfer of control to the handler first for t
Dialogue: 0,0:38:30.62,0:38:35.78,Chinese,,0,0,0,,这导致首先将控制权转移给处理程序
Dialogue: 0,0:38:36.38,0:38:39.30,English,,0,0,0,,And when at handler returns,it returns to the point to the
Dialogue: 0,0:38:36.38,0:38:39.30,Chinese,,0,0,0,,当处理程序返回时，它返回到指向的位置
Dialogue: 0,0:38:40.36,0:38:45.80,English,,0,0,0,,To the to the instruction and handle or else that was where it was interrupted
Dialogue: 0,0:38:40.36,0:38:45.80,Chinese,,0,0,0,,对于指令和处理或者它被中断的地方
Dialogue: 0,0:38:46.36,0:38:50.50,English,,0,0,0,,And then handle or us continues its execution and eventually
Dialogue: 0,0:38:46.36,0:38:50.50,Chinese,,0,0,0,,然后处理或我们继续执行并最终
Dialogue: 0,0:38:50.50,0:38:54.34,English,,0,0,0,,Return back to the the point in the main program where it was interrupted
Dialogue: 0,0:38:50.50,0:38:54.34,Chinese,,0,0,0,,返回到主程序中断的位置
Dialogue: 0,0:38:58.70,0:39:02.61,English,,0,0,0,,Now signals that the colonel always blocks
Dialogue: 0,0:38:58.70,0:39:02.61,Chinese,,0,0,0,,现在发出上校始终阻止的信号
Dialogue: 0,0:39:03.32,0:39:06.44,English,,0,0,0,,Pending signals of the type currently being handled right so
Dialogue: 0,0:39:03.32,0:39:06.44,Chinese,,0,0,0,,正在处理的类型的待处理信号就是这样
Dialogue: 0,0:39:07.56,0:39:12.46,English,,0,0,0,,A handler for a signal of type t can't be interrupted
Dialogue: 0,0:39:07.56,0:39:12.46,Chinese,,0,0,0,,类型为t的信号的处理程序不能被中断
Dialogue: 0,0:39:13.20,0:39:16.16,English,,0,0,0,,By the receipt of another signal of that same type
Dialogue: 0,0:39:13.20,0:39:16.16,Chinese,,0,0,0,,通过接收相同类型的另一个信号
Dialogue: 0,0:39:16.96,0:39:20.98,English,,0,0,0,,Okay can be as I showed in the previous slide it can be interrupted by a signal of another type
Dialogue: 0,0:39:16.96,0:39:20.98,Chinese,,0,0,0,,好的，就像我在上一张幻灯片中所显示的那样，它可以被另一种类型的信号打断
Dialogue: 0,0:39:21.46,0:39:23.42,English,,0,0,0,,But not by a signal of the same type
Dialogue: 0,0:39:21.46,0:39:23.42,Chinese,,0,0,0,,但不是相同类型的信号
Dialogue: 0,0:39:23.88,0:39:28.12,English,,0,0,0,,So that's sort of an implicit form of blocking
Dialogue: 0,0:39:23.88,0:39:28.12,Chinese,,0,0,0,,所以这就是一种隐含的阻塞形式
Dialogue: 0,0:39:29.22,0:39:36.70,English,,0,0,0,,But there's the kernel also provides a system call that allows you to explicitly block and unblock signals
Dialogue: 0,0:39:29.22,0:39:36.70,Chinese,,0,0,0,,但是内核还提供了一个系统调用，允许你明确地阻止和解除阻塞信号
Dialogue: 0,0:39:37.30,0:39:40.01,English,,0,0,0,,In the form of the sigprocmask function
Dialogue: 0,0:39:37.30,0:39:40.01,Chinese,,0,0,0,,以sigprocmask函数的形式
Dialogue: 0,0:39:41.96,0:39:48.66,English,,0,0,0,,And then there's associated so this allows you to block and unblock a set of signals
Dialogue: 0,0:39:41.96,0:39:48.66,Chinese,,0,0,0,,然后相关联，这样就可以阻止和取消阻止一组信号
Dialogue: 0,0:39:49.42,0:39:54.04,English,,0,0,0,,And then there some support functions that allow you to create those sets
Dialogue: 0,0:39:49.42,0:39:54.04,Chinese,,0,0,0,,然后有一些支持函数，允许你创建这些集
Dialogue: 0,0:39:55.40,0:39:58.34,English,,0,0,0,,So just think of these as bit vectors
Dialogue: 0,0:39:55.40,0:39:58.34,Chinese,,0,0,0,,所以只需将这些视为位向量
Dialogue: 0,0:39:58.38,0:40:05.34,English,,0,0,0,,And these functions will set in set and reset the bits and those those bit vectors
Dialogue: 0,0:39:58.38,0:40:05.34,Chinese,,0,0,0,,并且这些函数将置位并重置位和那些位向量
Dialogue: 0,0:40:07.16,0:40:12.72,English,,0,0,0,,So let's see how we can use sigprocmasks to temporarily block and unblock a signal
Dialogue: 0,0:40:07.16,0:40:12.72,Chinese,,0,0,0,,因此，让我们看看如何使用sigprocmasks临时阻止和解除阻塞信号
Dialogue: 0,0:40:13.32,0:40:16.00,English,,0,0,0,,So this is going to turn out to be very important for you
Dialogue: 0,0:40:13.32,0:40:16.00,Chinese,,0,0,0,,所以这对你来说非常重要
Dialogue: 0,0:40:16.00,0:40:21.24,English,,0,0,0,,When you working on your shells that which is your next lab assignment okay
Dialogue: 0,0:40:16.00,0:40:21.24,Chinese,,0,0,0,,当你处理你的下一个实验室任务的shell时，你可以
Dialogue: 0,0:40:25.98,0:40:31.34,English,,0,0,0,,So what we do...we'll use sigemptyset to create an empty mask so this is a mask with all zeros
Dialogue: 0,0:40:25.98,0:40:31.34,Chinese,,0,0,0,,那么我们做什么...我们将使用sigemptyset创建一个空掩码，这样这是一个全零的掩码
Dialogue: 0,0:40:31.96,0:40:33.80,English,,0,0,0,,Okay with no elements in the set
Dialogue: 0,0:40:31.96,0:40:33.80,Chinese,,0,0,0,,好的，集合中没有元素
Dialogue: 0,0:40:34.80,0:40:39.46,English,,0,0,0,,And then we're going to add a single element to this set which is sigint
Dialogue: 0,0:40:34.80,0:40:39.46,Chinese,,0,0,0,,然后我们将在这个集合中添加一个单元素，即sigint
Dialogue: 0,0:40:42.46,0:40:47.88,English,,0,0,0,,And now we temp...we have some code that we don't want to be interrupted by the seed of sigint
Dialogue: 0,0:40:42.46,0:40:47.88,Chinese,,0,0,0,,现在我们临时......我们有一些代码，我们不希望被sigint的种子打断
Dialogue: 0,0:40:49.36,0:40:53.08,English,,0,0,0,,Okay so we want to temporarily block the receipt of sig n signals
Dialogue: 0,0:40:49.36,0:40:53.08,Chinese,,0,0,0,,好的，我们想暂时阻止接收信号
Dialogue: 0,0:40:54.08,0:40:58.70,English,,0,0,0,,And we do it by calling sigprocmask with the command
Dialogue: 0,0:40:54.08,0:40:58.70,Chinese,,0,0,0,,我们通过使用命令调用sigprocmask来完成它
Dialogue: 0,0:40:59.20,0:41:02.56,English,,0,0,0,,Say I want to block I want to block the signals
Dialogue: 0,0:40:59.20,0:41:02.56,Chinese,,0,0,0,,说我想阻止我想阻止信号
Dialogue: 0,0:41:03.84,0:41:08.78,English,,0,0,0,,That are spent that are in the set specified by mask
Dialogue: 0,0:41:03.84,0:41:08.78,Chinese,,0,0,0,,花费在mask指定的集合中
Dialogue: 0,0:41:12.36,0:41:16.22,English,,0,0,0,,And I'll assign the so this will become my new mask
Dialogue: 0,0:41:12.36,0:41:16.22,Chinese,,0,0,0,,而且我会分配所以这将成为我的新面具
Dialogue: 0,0:41:16.64,0:41:19.72,English,,0,0,0,,So this becomes the new blocked bit vector
Dialogue: 0,0:41:16.64,0:41:19.72,Chinese,,0,0,0,,所以这成为新的阻塞位向量
Dialogue: 0,0:41:20.68,0:41:24.52,English,,0,0,0,,Okay or the not the this the new signal mask
Dialogue: 0,0:41:20.68,0:41:24.52,Chinese,,0,0,0,,好的或不是这个新的信号掩码
Dialogue: 0,0:41:24.62,0:41:31.28,English,,0,0,0,,And it makes a copy of the old one and stores it at the address specified in the third argument
Dialogue: 0,0:41:24.62,0:41:31.28,Chinese,,0,0,0,,它会复制旧的副本并将其存储在第三个参数中指定的地址
Dialogue: 0,0:41:32.82,0:41:35.50,English,,0,0,0,,So at this point after we returned from sigprocmask
Dialogue: 0,0:41:32.82,0:41:35.50,Chinese,,0,0,0,,所以在我们从sigprocmask返回之后的这一点上
Dialogue: 0,0:41:36.04,0:41:38.50,English,,0,0,0,,Sigint signals are blocked and they won't be received
Dialogue: 0,0:41:36.04,0:41:38.50,Chinese,,0,0,0,,Sigint信号被阻止，不会收到它们
Dialogue: 0,0:41:40.94,0:41:47.02,English,,0,0,0,,And then we...so we can execute this code knowing that we won't be interrupted by receipt of a sigint
Dialogue: 0,0:41:40.94,0:41:47.02,Chinese,,0,0,0,,然后我们......所以我们可以执行此代码，因为我们知道不会因收到sigint而中断
Dialogue: 0,0:41:49.56,0:41:57.20,English,,0,0,0,,And then we can restore the previous block set by using the sig_setmask in stopper ation
Dialogue: 0,0:41:49.56,0:41:57.20,Chinese,,0,0,0,,然后我们可以通过在塞子中使用sig_setmask来恢复先前的块集
Dialogue: 0,0:41:57.78,0:42:03.44,English,,0,0,0,,And passing in the previous mask that we saved up here when we initially blocks again
Dialogue: 0,0:41:57.78,0:42:03.44,Chinese,,0,0,0,,当我们最初再次阻止时，传入我们在这里保存的先前掩码
Dialogue: 0,0:42:09.96,0:42:15.12,English,,0,0,0,,Okay so signals and signal handling is a really tricky business
Dialogue: 0,0:42:09.96,0:42:15.12,Chinese,,0,0,0,,好的，所以信号和信号处理是一件非常棘手的事情
Dialogue: 0,0:42:15.54,0:42:17.48,English,,0,0,0,,And there's sort of three things that make them
Dialogue: 0,0:42:15.54,0:42:17.48,Chinese,,0,0,0,,并且有三种东西可以使它们成为现实
Dialogue: 0,0:42:18.82,0:42:21.44,English,,0,0,0,,So tricky and kind of nasty really
Dialogue: 0,0:42:18.82,0:42:21.44,Chinese,,0,0,0,,真的很棘手，有点讨厌
Dialogue: 0,0:42:21.88,0:42:26.80,English,,0,0,0,,One is that you have to be very careful to write handlers that are safe
Dialogue: 0,0:42:21.88,0:42:26.80,Chinese,,0,0,0,,一个是你必须非常小心地编写安全的处理程序
Dialogue: 0,0:42:27.54,0:42:33.96,English,,0,0,0,,Okay so there's you can write signal handlers that are unsafe in the sense that they'll create a deadlock in your program
Dialogue: 0,0:42:27.54,0:42:33.96,Chinese,,0,0,0,,好吧那么你可以编写不安全的信号处理程序，因为它们会在你的程序中造成死锁
Dialogue: 0,0:42:36.68,0:42:41.68,English,,0,0,0,,Okay or you can write signal handlers that will corrupt a global data structure
Dialogue: 0,0:42:36.68,0:42:41.68,Chinese,,0,0,0,,好的，或者你可以编写会破坏全局数据结构的信号处理程序
Dialogue: 0,0:42:42.58,0:42:46.24,English,,0,0,0,,That's being modified by the main program
Dialogue: 0,0:42:42.58,0:42:46.24,Chinese,,0,0,0,,这是由主程序修改的
Dialogue: 0,0:42:46.24,0:42:54.06,English,,0,0,0,,So I mean imagine your main programming is updating some data structure like a linked list
Dialogue: 0,0:42:46.24,0:42:54.06,Chinese,,0,0,0,,所以我的意思是想象你的主要编程是更新一些数据结构，如链表
Dialogue: 0,0:42:54.84,0:42:59.72,English,,0,0,0,,And right in the middle of updating that data structure when it's no longer consistent
Dialogue: 0,0:42:54.84,0:42:59.72,Chinese,,0,0,0,,当数据结构不再一致时，正在更新数据结构
Dialogue: 0,0:43:01.44,0:43:04.02,English,,0,0,0,,The program gets interrupted by the receipt of a signal
Dialogue: 0,0:43:01.44,0:43:04.02,Chinese,,0,0,0,,程序因收到信号而中断
Dialogue: 0,0:43:05.22,0:43:11.54,English,,0,0,0,,And if that signal handler is updating that same data structure reading that structure or modifying it
Dialogue: 0,0:43:05.22,0:43:11.54,Chinese,,0,0,0,,如果该信号处理程序正在更新读取该结构或修改它的相同数据结构
Dialogue: 0,0:43:12.62,0:43:17.18,English,,0,0,0,,Then it's going to encounter it in an inconsistent state and and you're in trouble
Dialogue: 0,0:43:12.62,0:43:17.18,Chinese,,0,0,0,,然后它会以不一致的状态遇到它并且你遇到了麻烦
Dialogue: 0,0:43:19.92,0:43:27.28,English,,0,0,0,,Okay so this the fact that it's easy to write signal handlers
Dialogue: 0,0:43:19.92,0:43:27.28,Chinese,,0,0,0,,好的，这就是编写信号处理程序很容易的事实
Dialogue: 0,0:43:27.30,0:43:32.04,English,,0,0,0,,That are unsafe is is is one aspect of that makes them tough to deal with
Dialogue: 0,0:43:27.30,0:43:32.04,Chinese,,0,0,0,,这是不安全的，这是一个让他们难以应对的方面
Dialogue: 0,0:43:32.66,0:43:37.16,English,,0,0,0,,Another aspect is they have this funny semantics that signals aren't cued
Dialogue: 0,0:43:32.66,0:43:37.16,Chinese,,0,0,0,,另一个方面是他们有这种有趣的语义，信号没有提示
Dialogue: 0,0:43:38.04,0:43:40.60,English,,0,0,0,,And so if you're not really careful about this
Dialogue: 0,0:43:38.04,0:43:40.60,Chinese,,0,0,0,,所以，如果你对此并不十分谨慎
Dialogue: 0,0:43:41.12,0:43:45.68,English,,0,0,0,,It's very easy to use the receipt of signals to count events
Dialogue: 0,0:43:41.12,0:43:45.68,Chinese,,0,0,0,,使用信号接收来计算事件非常容易
Dialogue: 0,0:43:46.76,0:43:49.94,English,,0,0,0,,And you can't do that if signals were cued you could use
Dialogue: 0,0:43:46.76,0:43:49.94,Chinese,,0,0,0,,如果你可以使用信号提示你就不能这样做
Dialogue: 0,0:43:50.12,0:43:54.34,English,,0,0,0,,You could use the receipt of a signal to count events in the system but you can't do it because
Dialogue: 0,0:43:50.12,0:43:54.34,Chinese,,0,0,0,,你可以使用信号的接收来计算系统中的事件，但是你不能这样做，因为
Dialogue: 0,0:43:54.80,0:43:56.08,English,,0,0,0,,Their signals aren't cued
Dialogue: 0,0:43:54.80,0:43:56.08,Chinese,,0,0,0,,他们的信号没有提示
Dialogue: 0,0:43:57.28,0:44:00.82,English,,0,0,0,,And then a third aspect of signals which makes them tough is that
Dialogue: 0,0:43:57.28,0:44:00.82,Chinese,,0,0,0,,然后，使信号变得艰难的信号的第三个方面是
Dialogue: 0,0:44:01.66,0:44:05.18,English,,0,0,0,,They're not even portable across different versions of Linux
Dialogue: 0,0:44:01.66,0:44:05.18,Chinese,,0,0,0,,它们甚至不能在不同版本的Linux上移植
Dialogue: 0,0:44:07.52,0:44:12.94,English,,0,0,0,,Okay so if you use solaris or some form of bsd it's not necessarily
Dialogue: 0,0:44:07.52,0:44:12.94,Chinese,,0,0,0,,好的，如果你使用solaris或某种形式的bsd，它不一定
Dialogue: 0,0:44:13.24,0:44:16.70,English,,0,0,0,,The single handling semantics aren't necessarily the same as they are in Linux
Dialogue: 0,0:44:13.24,0:44:16.70,Chinese,,0,0,0,,单一处理语义不一定与Linux中的相同
Dialogue: 0,0:44:17.82,0:44:21.36,English,,0,0,0,,Okay so we'll look at all three of these in a little more detail
Dialogue: 0,0:44:17.82,0:44:21.36,Chinese,,0,0,0,,好的，我们将更详细地介绍这三个方面
Dialogue: 0,0:44:21.36,0:44:24.34,English,,0,0,0,,And first we'll start with writing safe handlers
Dialogue: 0,0:44:21.36,0:44:24.34,Chinese,,0,0,0,,首先，我们将从编写安全处理程序开始
Dialogue: 0,0:44:26.94,0:44:32.40,English,,0,0,0,,So let me give you some guidelines for how to write safe handlers
Dialogue: 0,0:44:26.94,0:44:32.40,Chinese,,0,0,0,,那么，让我给你一些如何编写安全处理程序的指南
Dialogue: 0,0:44:33.24,0:44:38.16,English,,0,0,0,,And this is just a collection of...
Dialogue: 0,0:44:33.24,0:44:38.16,Chinese,,0,0,0,,这只是......的集合
Dialogue: 0,0:44:39.16,0:44:43.78,English,,0,0,0,,Collection of sort of collected wisdom from various sources
Dialogue: 0,0:44:39.16,0:44:43.78,Chinese,,0,0,0,,收集各种来源收集的智慧
Dialogue: 0,0:44:44.16,0:44:48.58,English,,0,0,0,,But it covers a lot of aspects of signal handlers
Dialogue: 0,0:44:44.16,0:44:48.58,Chinese,,0,0,0,,但它涵盖了信号处理程序的许多方面
Dialogue: 0,0:44:49.34,0:44:53.66,English,,0,0,0,,So the first guideline is to keep your handlers as simple as possible for example
Dialogue: 0,0:44:49.34,0:44:53.66,Chinese,,0,0,0,,因此，第一个准则是让你的处理程序尽可能简单
Dialogue: 0,0:44:54.04,0:44:58.94,English,,0,0,0,,The simplest possible handle I can think of just sets a global variable and then it returns
Dialogue: 0,0:44:54.04,0:44:58.94,Chinese,,0,0,0,,我能想到的最简单的句柄只是设置一个全局变量，然后返回
Dialogue: 0,0:45:00.52,0:45:10.62,English,,0,0,0,,Okay and in fact cert the CMU cert provides guidelines for sort of compliant programs
Dialogue: 0,0:45:00.52,0:45:10.62,Chinese,,0,0,0,,好的，事实上，CMU证书提供了一系列合规程序的指南
Dialogue: 0,0:45:11.38,0:45:17.88,English,,0,0,0,,And this is the only signal handler that they allow this is the only compliant signal handler
Dialogue: 0,0:45:11.38,0:45:17.88,Chinese,,0,0,0,,这是唯一的信号处理程序，它们允许这是唯一的兼容信号处理程序
Dialogue: 0,0:45:18.10,0:45:20.64,English,,0,0,0,,One that just sets a global variable and then returns
Dialogue: 0,0:45:18.10,0:45:20.64,Chinese,,0,0,0,,一个只设置一个全局变量然后返回
Dialogue: 0,0:45:26.26,0:45:33.24,English,,0,0,0,,Okay guideline number one call only functions in your handlers that are that have this property of async-signals-safety
Dialogue: 0,0:45:26.26,0:45:33.24,Chinese,,0,0,0,,好的准则第一号呼叫仅在具有async-signals-safety属性的处理程序中起作用
Dialogue: 0,0:45:35.82,0:45:41.16,English,,0,0,0,,We'll look at this in a second but I want to point out that printf, sprintf,malloc,exit
Dialogue: 0,0:45:35.82,0:45:41.16,Chinese,,0,0,0,,我们将在一秒钟内看一下，但我想指出printf，sprintf，malloc，退出
Dialogue: 0,0:45:42.18,0:45:45.64,English,,0,0,0,,Functions that are very common and commonly used are not safe
Dialogue: 0,0:45:42.18,0:45:45.64,Chinese,,0,0,0,,非常常见且常用的功能并不安全
Dialogue: 0,0:45:48.88,0:45:54.80,English,,0,0,0,,Okay guideline number two is to always save and restore errno on entry and exit
Dialogue: 0,0:45:48.88,0:45:54.80,Chinese,,0,0,0,,好的准则二是在进入和退出时始终保存和恢复errno
Dialogue: 0,0:45:55.14,0:45:56.62,English,,0,0,0,,So you know errno is a global
Dialogue: 0,0:45:55.14,0:45:56.62,Chinese,,0,0,0,,所以你知道errno是一个全球性的
Dialogue: 0,0:45:57.40,0:46:01.44,English,,0,0,0,,Global variable that's set when there's whenever there's an error in a system-level function
Dialogue: 0,0:45:57.40,0:46:01.44,Chinese,,0,0,0,,当系统级函数出现错误时设置的全局变量
Dialogue: 0,0:46:02.56,0:46:06.42,English,,0,0,0,,So you need to save and restore it on entry and exit
Dialogue: 0,0:46:02.56,0:46:06.42,Chinese,,0,0,0,,因此，你需要在进入和退出时保存并恢复它
Dialogue: 0,0:46:06.70,0:46:10.86,English,,0,0,0,,So that it doesn't get overwritten if you're interrupted by another handler
Dialogue: 0,0:46:06.70,0:46:10.86,Chinese,,0,0,0,,因此，如果你被另一个处理程序打断，它就不会被覆盖
Dialogue: 0,0:46:15.92,0:46:18.32,English,,0,0,0,,Okay if you're accessing any shared data structures
Dialogue: 0,0:46:15.92,0:46:18.32,Chinese,,0,0,0,,好的，如果你正在访问任何共享数据结构
Dialogue: 0,0:46:19.00,0:46:25.24,English,,0,0,0,,Inside a signal handler that are also accessed by your main routine
Dialogue: 0,0:46:19.00,0:46:25.24,Chinese,,0,0,0,,在主程序也可访问的信号处理程序内部
Dialogue: 0,0:46:25.34,0:46:29.16,English,,0,0,0,,Then you need to temporarily block signals while you access that data structure
Dialogue: 0,0:46:25.34,0:46:29.16,Chinese,,0,0,0,,然后，你需要在访问该数据结构时临时阻止信号
Dialogue: 0,0:46:29.80,0:46:31.98,English,,0,0,0,,Both in the main routine and your signal handler
Dialogue: 0,0:46:29.80,0:46:31.98,Chinese,,0,0,0,,主程序和信号处理程序都有
Dialogue: 0,0:46:32.86,0:46:35.43,English,,0,0,0,,Right and the reason for this is what I described earlier
Dialogue: 0,0:46:32.86,0:46:35.43,Chinese,,0,0,0,,对，这就是我之前描述的原因
Dialogue: 0,0:46:36.04,0:46:39.88,English,,0,0,0,,If your main routine is updating that global data structure and then it gets interrupted
Dialogue: 0,0:46:36.04,0:46:39.88,Chinese,,0,0,0,,如果你的主例程正在更新该全局数据结构，那么它将被中断
Dialogue: 0,0:46:40.40,0:46:44.46,English,,0,0,0,,And the signal handler is reading that data structure it's going to find it in an inconsistent state
Dialogue: 0,0:46:40.40,0:46:44.46,Chinese,,0,0,0,,并且信号处理程序正在读取它将在不一致状态下找到它的数据结构
Dialogue: 0,0:46:44.88,0:46:46.40,English,,0,0,0,,And bad things will happen
Dialogue: 0,0:46:44.88,0:46:46.40,Chinese,,0,0,0,,坏事会发生
Dialogue: 0,0:46:50.88,0:46:55.76,English,,0,0,0,,Okay you want to be sure to declare your any global variables that are shared between signal handlers
Dialogue: 0,0:46:50.88,0:46:55.76,Chinese,,0,0,0,,好的，你希望确保声明信号处理程序之间共享的任何全局变量
Dialogue: 0,0:46:55.96,0:46:57.94,English,,0,0,0,,And the main routine as volatile
Dialogue: 0,0:46:55.96,0:46:57.94,Chinese,,0,0,0,,并且主要例程为volatile
Dialogue: 0,0:46:58.56,0:47:04.38,English,,0,0,0,,Okay the volatile attribute will prevent the compiler from putting that value in a register
Dialogue: 0,0:46:58.56,0:47:04.38,Chinese,,0,0,0,,好的volatile属性将阻止编译器将该值放入寄存器中
Dialogue: 0,0:47:07.62,0:47:09.96,English,,0,0,0,,So if you declare a global variable as volatile
Dialogue: 0,0:47:07.62,0:47:09.96,Chinese,,0,0,0,,因此，如果将全局变量声明为volatile
Dialogue: 0,0:47:10.58,0:47:14.58,English,,0,0,0,,It will always be reads and writes will always go to and from memory
Dialogue: 0,0:47:10.58,0:47:14.58,Chinese,,0,0,0,,始终是读取和写入将始终进出内存
Dialogue: 0,0:47:15.94,0:47:22.76,English,,0,0,0,,Okay so this is very important right you might if you don't declare these global variables at volatile
Dialogue: 0,0:47:15.94,0:47:22.76,Chinese,,0,0,0,,好的，如果你没有在volatile中声明这些全局变量，那么这非常重要
Dialogue: 0,0:47:22.86,0:47:28.22,English,,0,0,0,,And the compiler chooses to put one of those in a register
Dialogue: 0,0:47:22.86,0:47:28.22,Chinese,,0,0,0,,编译器选择将其中一个放入寄存器中
Dialogue: 0,0:47:29.64,0:47:33.04,English,,0,0,0,,Then you may miss that variable being updated
Dialogue: 0,0:47:29.64,0:47:33.04,Chinese,,0,0,0,,那么你可能会错过正在更新的变量
Dialogue: 0,0:47:33.06,0:47:37.68,English,,0,0,0,,So suppose your signal handlers is setting a global variable
Dialogue: 0,0:47:33.06,0:47:37.68,Chinese,,0,0,0,,因此，假设你的信号处理程序正在设置全局变量
Dialogue: 0,0:47:39.26,0:47:44.74,English,,0,0,0,,And now suppose your main routine is spinning waiting for that global variable to get set
Dialogue: 0,0:47:39.26,0:47:44.74,Chinese,,0,0,0,,现在假设你的主例程正在旋转，等待该全局变量被设置
Dialogue: 0,0:47:46.56,0:47:51.82,English,,0,0,0,,Well if it's in a register the write to that variable will just update the register
Dialogue: 0,0:47:46.56,0:47:51.82,Chinese,,0,0,0,,好吧，如果它在寄存器中，写入该变量只会更新寄存器
Dialogue: 0,0:47:51.92,0:47:58.70,English,,0,0,0,,Right and so your main routine is in danger of just of spinning forever not seeing the change right
Dialogue: 0,0:47:51.92,0:47:58.70,Chinese,,0,0,0,,是的，所以你的主要程序有永远旋转的危险，没有看到正确的变化
Dialogue: 0,0:48:00.54,0:48:04.62,English,,0,0,0,,Okay so always use volatility so that they're not stored in registers
Dialogue: 0,0:48:00.54,0:48:04.62,Chinese,,0,0,0,,好的，所以总是使用波动性，这样它们就不会存储在寄存器中
Dialogue: 0,0:48:06.22,0:48:10.60,English,,0,0,0,,And then if you have fun if you have a special kind of global called a flag
Dialogue: 0,0:48:06.22,0:48:10.60,Chinese,,0,0,0,,如果你有一种特殊的全球称为旗帜，那么如果你玩得开心
Dialogue: 0,0:48:11.18,0:48:19.22,English,,0,0,0,,Which by definition is a variable it's only read or written not incremented or updated it's just read or written
Dialogue: 0,0:48:11.18,0:48:19.22,Chinese,,0,0,0,,根据定义，它是一个变量，它只是读取或写入而不是递增或更新它只是读取或写入
Dialogue: 0,0:48:20.64,0:48:27.18,English,,0,0,0,,If you have a variable with that property then you can declare it with this sig_atomic_t tribute
Dialogue: 0,0:48:20.64,0:48:27.18,Chinese,,0,0,0,,如果你有一个具有该属性的变量，那么你可以使用此sig_atomic_t致敬声明它
Dialogue: 0,0:48:28.72,0:48:34.46,English,,0,0,0,,And if you do that then the system guarantees that reads and writes to that variable will be atomic
Dialogue: 0,0:48:28.72,0:48:34.46,Chinese,,0,0,0,,如果你这样做，那么系统保证对该变量的读写将是原子的
Dialogue: 0,0:48:34.68,0:48:39.22,English,,0,0,0,,So you don't have to in other words you don't have to protect accesses to the shared
Dialogue: 0,0:48:34.68,0:48:39.22,Chinese,,0,0,0,,换句话说，你不必保护对共享的访问
Dialogue: 0,0:48:39.82,0:48:43.58,English,,0,0,0,,To accesses or references to those global variables
Dialogue: 0,0:48:39.82,0:48:43.58,Chinese,,0,0,0,,访问或引用这些全局变量
Dialogue: 0,0:48:44.52,0:48:53.56,English,,0,0,0,,Okay and so by atomic which means that the read or write of that flag will always happen in one uninterruptible step
Dialogue: 0,0:48:44.52,0:48:53.56,Chinese,,0,0,0,,好的，所以原子意味着该标志的读或写将始终在一个不间断的步骤中发生
Dialogue: 0,0:48:54.86,0:48:58.12,English,,0,0,0,,Okay one uninterruptible load or store particular
Dialogue: 0,0:48:54.86,0:48:58.12,Chinese,,0,0,0,,好吧，一个不间断的负载或存储特别
Dialogue: 0,0:49:00.16,0:49:03.94,English,,0,0,0,,Now in practice on most systems this sig_atomic_t is an int
Dialogue: 0,0:49:00.16,0:49:03.94,Chinese,,0,0,0,,现在在大多数系统的实践中，这个sig_atomic_t是一个int
Dialogue: 0,0:49:05.80,0:49:12.00,English,,0,0,0,,So you can read or write an int with one one instruction okay so it's atomic
Dialogue: 0,0:49:05.80,0:49:12.00,Chinese,,0,0,0,,所以你可以用一个指令来读或写一个int，所以它是原子的
Dialogue: 0,0:49:12.62,0:49:16.06,English,,0,0,0,,But if you want to be portable you declare it with sig_atomic_t
Dialogue: 0,0:49:12.62,0:49:16.06,Chinese,,0,0,0,,但是如果你想要便于携带，你可以使用sig_atomic_t声明它
Dialogue: 0,0:49:16.30,0:49:21.94,English,,0,0,0,,And then it'll work on none it will work on all systems
Dialogue: 0,0:49:16.30,0:49:21.94,Chinese,,0,0,0,,然后它将无效，它将适用于所有系统
Dialogue: 0,0:49:24.78,0:49:27.44,English,,0,0,0,,Okay we mentioned this property of a sync signal safety
Dialogue: 0,0:49:24.78,0:49:27.44,Chinese,,0,0,0,,好的，我们提到了同步信号安全的这个属性
Dialogue: 0,0:49:28.66,0:49:32.66,English,,0,0,0,,Now a function is safe to be used inside of a signal handler
Dialogue: 0,0:49:28.66,0:49:32.66,Chinese,,0,0,0,,现在，一个函数可以安全地在信号处理程序中使用
Dialogue: 0,0:49:33.56,0:49:38.54,English,,0,0,0,,If it's either reentrant or if it can't be interrupted by signals
Dialogue: 0,0:49:33.56,0:49:38.54,Chinese,,0,0,0,,如果它是可重入的或者它不能被信号中断
Dialogue: 0,0:49:39.30,0:49:44.62,English,,0,0,0,,And will...a reentrant function as we'll see when we study threads is a function where all of its
Dialogue: 0,0:49:39.30,0:49:44.62,Chinese,,0,0,0,,并且......将在我们研究线程时看到的可重入函数是一个函数所在的函数
Dialogue: 0,0:49:45.16,0:49:48.20,English,,0,0,0,,All of the data that it accesses is on its own stack
Dialogue: 0,0:49:45.16,0:49:48.20,Chinese,,0,0,0,,它访问的所有数据都在自己的堆栈中
Dialogue: 0,0:49:50.64,0:49:56.06,English,,0,0,0,,Okay so no global variables no pointers to global variables everything's stored on the stack locally
Dialogue: 0,0:49:50.64,0:49:56.06,Chinese,,0,0,0,,好的，所以没有全局变量没有指向全局变量的指针，所有内容都存储在本地堆栈中
Dialogue: 0,0:49:58.00,0:50:00.42,English,,0,0,0,,Okay so that means you can be it's called reentrant
Dialogue: 0,0:49:58.00,0:50:00.42,Chinese,,0,0,0,,好的，这意味着你可以被称为可重入
Dialogue: 0,0:50:00.42,0:50:03.36,English,,0,0,0,,Because you can write have multiple instances of that function
Dialogue: 0,0:50:00.42,0:50:03.36,Chinese,,0,0,0,,因为你可以编写具有该功能的多个实例
Dialogue: 0,0:50:03.36,0:50:08.52,English,,0,0,0,,And they all have their own separate copies of all of the variables that they're using
Dialogue: 0,0:50:03.36,0:50:08.52,Chinese,,0,0,0,,它们都有自己独立的所有变量副本
Dialogue: 0,0:50:10.02,0:50:16.58,English,,0,0,0,,Now the posix standard guarantees 117 different functions to be a sync-signal-safe
Dialogue: 0,0:50:10.02,0:50:16.58,Chinese,,0,0,0,,现在posix标准保证117种不同的功能是同步信号安全的
Dialogue: 0,0:50:19.80,0:50:24.42,English,,0,0,0,,These include _exit,write,wait,waitpid,sleep,kill
Dialogue: 0,0:50:19.80,0:50:24.42,Chinese,,0,0,0,,这些包括_exit，write，wait，waitpid，sleep，kill
Dialogue: 0,0:50:25.52,0:50:30.81,English,,0,0,0,,But unfortunately there's some very popular functions that aren't on this list printf,sprintf
Dialogue: 0,0:50:25.52,0:50:30.81,Chinese,,0,0,0,,但不幸的是，有一些非常受欢迎的功能，不在这个列表printf，sprintf
Dialogue: 0,0:50:31.28,0:50:32.70,English,,0,0,0,,Things that you really want to use
Dialogue: 0,0:50:31.28,0:50:32.70,Chinese,,0,0,0,,你真正想要使用的东西
Dialogue: 0,0:50:33.14,0:50:37.84,English,,0,0,0,,And in fact write is the only output function that's async-signal-safe
Dialogue: 0,0:50:33.14,0:50:37.84,Chinese,,0,0,0,,事实上，write是唯一一个异步信号安全的输出函数
Dialogue: 0,0:50:41.06,0:50:43.14,English,,0,0,0,,So this is kind of a problem because
Dialogue: 0,0:50:41.06,0:50:43.14,Chinese,,0,0,0,,所以这是一个问题，因为
Dialogue: 0,0:50:44.34,0:50:50.52,English,,0,0,0,,Especially when you know you something you'd often like your signal handlers to output information
Dialogue: 0,0:50:44.34,0:50:50.52,Chinese,,0,0,0,,特别是当你认识某些东西时，你经常喜欢你的信号处理程序来输出信息
Dialogue: 0,0:50:51.52,0:50:56.38,English,,0,0,0,,But you can't if you want to really be pedantic and careful you can't use printf in fact
Dialogue: 0,0:50:51.52,0:50:56.38,Chinese,,0,0,0,,但是如果你真的想要迂腐而小心你就不能使用printf
Dialogue: 0,0:50:57.48,0:50:59.28,English,,0,0,0,,It's possible to write a program
Dialogue: 0,0:50:57.48,0:50:59.28,Chinese,,0,0,0,,编写程序是可能的
Dialogue: 0,0:51:00.46,0:51:04.16,English,,0,0,0,,And I'll try to...it's possible to write a program
Dialogue: 0,0:51:00.46,0:51:04.16,Chinese,,0,0,0,,我会尝试......编写一个程序是可能的
Dialogue: 0,0:51:05.12,0:51:09.24,English,,0,0,0,,That does a tight loop of printouts in the main routine
Dialogue: 0,0:51:05.12,0:51:09.24,Chinese,,0,0,0,,这样可以在主程序中完成打印输出
Dialogue: 0,0:51:10.96,0:51:18.32,English,,0,0,0,,And then a steady stream of interrupts which execute a handler which also does a printf
Dialogue: 0,0:51:10.96,0:51:18.32,Chinese,,0,0,0,,然后是稳定的中断流，它们执行一个也执行printf的处理程序
Dialogue: 0,0:51:22.94,0:51:28.70,English,,0,0,0,,The printf call has to acquire what's called a lock on the terminal
Dialogue: 0,0:51:22.94,0:51:28.70,Chinese,,0,0,0,,printf调用必须获取终端上所谓的锁定
Dialogue: 0,0:51:29.24,0:51:32.88,English,,0,0,0,,Okay each printf inside that library function
Dialogue: 0,0:51:29.24,0:51:32.88,Chinese,,0,0,0,,好的，那个库函数里面的每个printf
Dialogue: 0,0:51:33.70,0:51:40.06,English,,0,0,0,,It acquires a lock which means only one instance of printf can write to the terminal at a point in time
Dialogue: 0,0:51:33.70,0:51:40.06,Chinese,,0,0,0,,它获取一个锁，这意味着只有一个printf实例可以在某个时间点写入终端
Dialogue: 0,0:51:40.90,0:51:44.94,English,,0,0,0,,If another function tries to acquire that lock it has to wait
Dialogue: 0,0:51:40.90,0:51:44.94,Chinese,,0,0,0,,如果另一个函数试图获取该锁，则必须等待
Dialogue: 0,0:51:46.28,0:51:50.12,English,,0,0,0,,Until whatever function owns the lock releases it
Dialogue: 0,0:51:46.28,0:51:50.12,Chinese,,0,0,0,,直到任何函数拥有锁释放它
Dialogue: 0,0:51:50.84,0:51:58.30,English,,0,0,0,,Okay so a lock prevents a lock is a way for to get mutually exclusive access to two shared resources
Dialogue: 0,0:51:50.84,0:51:58.30,Chinese,,0,0,0,,好的，所以锁可以防止锁是一种获得对两个共享资源的互斥访问的方法
Dialogue: 0,0:51:59.68,0:52:04.90,English,,0,0,0,,So if we have a tight loop in our main routine with executing printf
Dialogue: 0,0:51:59.68,0:52:04.90,Chinese,,0,0,0,,因此，如果我们在执行printf的主程序中有一个紧密的循环
Dialogue: 0,0:52:05.66,0:52:10.22,English,,0,0,0,,Imagine what happens if one of those printfs acquires a lock on the terminal
Dialogue: 0,0:52:05.66,0:52:10.22,Chinese,,0,0,0,,想象一下，如果其中一个printfs获得了终端上的锁定会发生什么
Dialogue: 0,0:52:10.68,0:52:16.18,English,,0,0,0,,And then gets interrupted not by the receipt of a signal
Dialogue: 0,0:52:10.68,0:52:16.18,Chinese,,0,0,0,,然后不是通过接收信号而中断
Dialogue: 0,0:52:16.88,0:52:20.58,English,,0,0,0,,Now within the signal handler it calls another printf
Dialogue: 0,0:52:16.88,0:52:20.58,Chinese,,0,0,0,,现在在信号处理程序中它调用另一个printf
Dialogue: 0,0:52:22.08,0:52:26.88,English,,0,0,0,,And that printf tries to acquire that lock and it blocks forever
Dialogue: 0,0:52:22.08,0:52:26.88,Chinese,,0,0,0,,而且printf试图获得那个锁，它会永远阻止
Dialogue: 0,0:52:27.10,0:52:32.28,English,,0,0,0,,Because nothing's going to release that lock because the main routine was interrupted by the handler
Dialogue: 0,0:52:27.10,0:52:32.28,Chinese,,0,0,0,,因为主程序被处理程序中断所以没有任何东西会释放锁定
Dialogue: 0,0:52:35.28,0:52:40.48,English,,0,0,0,,So you have what's called a classical condition called deadlock
Dialogue: 0,0:52:35.28,0:52:40.48,Chinese,,0,0,0,,所以你有一个叫做死锁的经典条件
Dialogue: 0,0:52:41.06,0:52:44.32,English,,0,0,0,,Which is we have a process waiting for an event that will never occur
Dialogue: 0,0:52:41.06,0:52:44.32,Chinese,,0,0,0,,我们有一个进程在等待永远不会发生的事件
Dialogue: 0,0:52:44.36,0:52:50.48,English,,0,0,0,,In this case the the printf and the signal handler is waiting for a lock to be released that will never be released
Dialogue: 0,0:52:44.36,0:52:50.48,Chinese,,0,0,0,,在这种情况下，printf和信号处理程序正在等待一个永远不会被释放的锁定
Dialogue: 0,0:52:51.70,0:52:56.66,English,,0,0,0,,So it's interesting you can try this it's
Dialogue: 0,0:52:51.70,0:52:56.66,Chinese,,0,0,0,,所以有趣的是你可以试试这个
Dialogue: 0,0:52:57.42,0:53:01.40,English,,0,0,0,,It's not too hard to to create this deadlock situation
Dialogue: 0,0:52:57.42,0:53:01.40,Chinese,,0,0,0,,创建这种死锁情况并不难
Dialogue: 0,0:53:02.90,0:53:05.74,English,,0,0,0,,So to deal with this I really didn't want to tell you guys
Dialogue: 0,0:53:02.90,0:53:05.74,Chinese,,0,0,0,,所以为了解决这个问题，我真的不想告诉你们
Dialogue: 0,0:53:05.74,0:53:09.92,English,,0,0,0,,That you couldn't have any output in your programs and writes a very difficult thing to deal with
Dialogue: 0,0:53:05.74,0:53:09.92,Chinese,,0,0,0,,你无法在程序中输出任何内容，并且编写一个非常难以处理的内容
Dialogue: 0,0:53:11.10,0:53:16.84,English,,0,0,0,,So I created a small little library called the safe I/O library
Dialogue: 0,0:53:11.10,0:53:16.84,Chinese,,0,0,0,,所以我创建了一个名为安全I / O库的小型库
Dialogue: 0,0:53:18.50,0:53:25.46,English,,0,0,0,,Consists of three routines and they're available to you in the csapp.c file
Dialogue: 0,0:53:18.50,0:53:25.46,Chinese,,0,0,0,,由三个例程组成，它们可以在csapp.c文件中使用
Dialogue: 0,0:53:25.46,0:53:28.02,English,,0,0,0,,Which is distributed on the website
Dialogue: 0,0:53:25.46,0:53:28.02,Chinese,,0,0,0,,哪个是在网站上发布的
Dialogue: 0,0:53:28.94,0:53:31.42,English,,0,0,0,,And it consists of three reentrant routines
Dialogue: 0,0:53:28.94,0:53:31.42,Chinese,,0,0,0,,它由三个可重入的例程组成
Dialogue: 0,0:53:33.64,0:53:37.50,English,,0,0,0,,sio_puts prints string
Dialogue: 0,0:53:33.64,0:53:37.50,Chinese,,0,0,0,,sio_puts打印字符串
Dialogue: 0,0:53:38.84,0:53:41.48,English,,0,0,0,,(sio_)putl prints a long
Dialogue: 0,0:53:38.84,0:53:41.48,Chinese,,0,0,0,,（sio_）putl打印很长
Dialogue: 0,0:53:42.82,0:53:48.04,English,,0,0,0,,And sio_error prints a message and then exits
Dialogue: 0,0:53:42.82,0:53:48.04,Chinese,,0,0,0,,并且sio_error会打印一条消息然后退出
Dialogue: 0,0:53:50.82,0:53:55.92,English,,0,0,0,,Okay so you can safely use take my word for it you can safely use this in your signal handlers
Dialogue: 0,0:53:50.82,0:53:55.92,Chinese,,0,0,0,,好的，所以你可以安全地使用我的话，你可以安全地在信号处理程序中使用它
Dialogue: 0,0:53:56.54,0:54:01.94,English,,0,0,0,,So if we were going to rewrite our sigint_handler from the binary bomb
Dialogue: 0,0:53:56.54,0:54:01.94,Chinese,,0,0,0,,所以，如果我们要从二进制炸弹中重写我们的sigint_handler
Dialogue: 0,0:54:02.60,0:54:08.38,English,,0,0,0,,We could rewrite it like this and now we have every function is async-signal-safe
Dialogue: 0,0:54:02.60,0:54:08.38,Chinese,,0,0,0,,我们可以像这样重写它，现在我们每个函数都是异步信号安全的
Dialogue: 0,0:54:11.60,0:54:16.58,English,,0,0,0,,All right now signals are also tucked because of this funky non cueing semantics
Dialogue: 0,0:54:11.60,0:54:16.58,Chinese,,0,0,0,,由于这种时髦的非提示语义，所有现在的信号也都隐藏起来
Dialogue: 0,0:54:19.56,0:54:21.70,English,,0,0,0,,And so it's really easy to make mistakes
Dialogue: 0,0:54:19.56,0:54:21.70,Chinese,,0,0,0,,所以犯错很容易
Dialogue: 0,0:54:23.92,0:54:26.14,English,,0,0,0,,When you have an implicit assumption that
Dialogue: 0,0:54:23.92,0:54:26.14,Chinese,,0,0,0,,当你有一个隐含的假设时
Dialogue: 0,0:54:27.94,0:54:33.18,English,,0,0,0,,The that the receipt of a signal it can be used to count the occurrence of an event
Dialogue: 0,0:54:27.94,0:54:33.18,Chinese,,0,0,0,,它可以用来接收信号来计算事件的发生
Dialogue: 0,0:54:34.82,0:54:38.32,English,,0,0,0,,So let's look at this, let's look at this example program
Dialogue: 0,0:54:34.82,0:54:38.32,Chinese,,0,0,0,,让我们看看这个，让我们来看看这个示例程序
Dialogue: 0,0:54:40.88,0:54:42.92,English,,0,0,0,,We install a sick child handler
Dialogue: 0,0:54:40.88,0:54:42.92,Chinese,,0,0,0,,我们安装了一个生病的孩子处理
Dialogue: 0,0:54:43.92,0:54:49.40,English,,0,0,0,,Okay and this is actually this sort of close the loop member we talked about our example shell
Dialogue: 0,0:54:43.92,0:54:49.40,Chinese,,0,0,0,,好的，这实际上是关于我们谈论我们的示例shell的循环成员
Dialogue: 0,0:54:49.96,0:54:53.38,English,,0,0,0,,We're wondering how are we going to reap those background children
Dialogue: 0,0:54:49.96,0:54:53.38,Chinese,,0,0,0,,我们想知道如何收获那些背景儿童
Dialogue: 0,0:54:53.76,0:54:57.42,English,,0,0,0,,Well we do it by installing a sick child handle like we're doing in this example
Dialogue: 0,0:54:53.76,0:54:57.42,Chinese,,0,0,0,,好吧，我们通过像我们在这个例子中所做的那样安装一个生病的子句柄来做到这一点
Dialogue: 0,0:54:58.26,0:55:03.62,English,,0,0,0,,So this here we have a program that installs this sig child handler
Dialogue: 0,0:54:58.26,0:55:03.62,Chinese,,0,0,0,,所以这里我们有一个安装这个sig子处理程序的程序
Dialogue: 0,0:55:04.28,0:55:08.86,English,,0,0,0,,And then it creates N different child processes
Dialogue: 0,0:55:04.28,0:55:08.86,Chinese,,0,0,0,,然后它创建N个不同的子进程
Dialogue: 0,0:55:09.64,0:55:12.86,English,,0,0,0,,Where each child sleeps for a little bit and exits
Dialogue: 0,0:55:09.64,0:55:12.86,Chinese,,0,0,0,,每个孩子睡一会儿就会出口
Dialogue: 0,0:55:17.02,0:55:22.16,English,,0,0,0,,And then it spins until the ccount variable becomes zero
Dialogue: 0,0:55:17.02,0:55:22.16,Chinese,,0,0,0,,然后它旋转直到ccount变量变为零
Dialogue: 0,0:55:23.86,0:55:29.16,English,,0,0,0,,That the parent, I'm sorry, the parent spins until the ccount variable becomes zero
Dialogue: 0,0:55:23.86,0:55:29.16,Chinese,,0,0,0,,那个父母，对不起，父母旋转直到count变量变为零
Dialogue: 0,0:55:30.76,0:55:40.32,English,,0,0,0,,Now in our child handler we have a global that's initialized to zero ccount
Dialogue: 0,0:55:30.76,0:55:40.32,Chinese,,0,0,0,,现在在我们的子处理程序中，我们有一个初始化为零帐户的全局
Dialogue: 0,0:55:43.94,0:55:48.40,English,,0,0,0,,And then we wait,we're going to wait so this child,when the child handler gets called that means
Dialogue: 0,0:55:43.94,0:55:48.40,Chinese,,0,0,0,,然后我们等待，我们将等待这个孩子，当子处理程序被调用时意味着
Dialogue: 0,0:55:48.84,0:55:51.14,English,,0,0,0,,It's called because we received a sig_child signal
Dialogue: 0,0:55:48.84,0:55:51.14,Chinese,,0,0,0,,这是因为我们收到了一个sig_child信号
Dialogue: 0,0:55:53.30,0:55:58.52,English,,0,0,0,,Okay so in our handler we're going to reap that child by calling weight
Dialogue: 0,0:55:53.30,0:55:58.52,Chinese,,0,0,0,,好吧，在我们的处理程序中，我们将通过调用体重来收获那个孩子
Dialogue: 0,0:56:00.04,0:56:03.60,English,,0,0,0,,And we're going to dec...will decrement ccount
Dialogue: 0,0:56:00.04,0:56:03.60,Chinese,,0,0,0,,而且我们将会减少......会减少数量
Dialogue: 0,0:56:04.00,0:56:10.56,English,,0,0,0,,Okay so once all of the children if then have been reaped ccount will be zero
Dialogue: 0,0:56:04.00,0:56:10.56,Chinese,,0,0,0,,好的，所以一旦所有的孩子都被收获，ccount将为零
Dialogue: 0,0:56:10.56,0:56:13.88,English,,0,0,0,,And then the parent can exit this while loop
Dialogue: 0,0:56:10.56,0:56:13.88,Chinese,,0,0,0,,然后父进程可以在while循环中退出
Dialogue: 0,0:56:15.54,0:56:18.48,English,,0,0,0,,Okay now in this particular example N was 5
Dialogue: 0,0:56:15.54,0:56:18.48,Chinese,,0,0,0,,好的，现在在这个特殊的例子中，N是5
Dialogue: 0,0:56:20.20,0:56:26.72,English,,0,0,0,,But will you run this code,we only the handle or only gets called twice
Dialogue: 0,0:56:20.20,0:56:26.72,Chinese,,0,0,0,,但是你会运行这个代码，我们只有句柄或只被调用两次
Dialogue: 0,0:56:29.46,0:56:35.38,English,,0,0,0,,Okay so the the message handler reap child only gets executed twice right
Dialogue: 0,0:56:29.46,0:56:35.38,Chinese,,0,0,0,,好的，所以消息处理程序reap child只会被执行两次
Dialogue: 0,0:56:35.38,0:56:37.76,English,,0,0,0,,Which means the handler was only called twice
Dialogue: 0,0:56:35.38,0:56:37.76,Chinese,,0,0,0,,这意味着处理程序只被调用两次
Dialogue: 0,0:56:38.04,0:56:42.62,English,,0,0,0,,We created five children,we terminated five children
Dialogue: 0,0:56:38.04,0:56:42.62,Chinese,,0,0,0,,我们创造了五个孩子，我们终止了五个孩子
Dialogue: 0,0:56:43.58,0:56:45.16,English,,0,0,0,,But we only reaped two
Dialogue: 0,0:56:43.58,0:56:45.16,Chinese,,0,0,0,,但我们只收获了两个
Dialogue: 0,0:56:47.26,0:56:51.94,English,,0,0,0,,Okay so that the problem is that when we the problem is that we assumed
Dialogue: 0,0:56:47.26,0:56:51.94,Chinese,,0,0,0,,好吧，问题在于，当我们问题是我们假设的时候
Dialogue: 0,0:56:52.76,0:56:54.84,English,,0,0,0,,That the receipt...
Dialogue: 0,0:56:52.76,0:56:54.84,Chinese,,0,0,0,,收据......
Dialogue: 0,0:56:56.94,0:57:03.36,English,,0,0,0,,The execution of the child handled our correspondent to the single receipt of a single sig_child signal
Dialogue: 0,0:56:56.94,0:57:03.36,Chinese,,0,0,0,,孩子的执行使我们的记者处理了单个sig_child信号的单一收据
Dialogue: 0,0:57:04.78,0:57:09.38,English,,0,0,0,,Okay when in reality there signals are true
Dialogue: 0,0:57:04.78,0:57:09.38,Chinese,,0,0,0,,好的，实际上信号是真的
Dialogue: 0,0:57:10.40,0:57:15.90,English,,0,0,0,,We had in reality multiple sig_child signals were delivered to that child
Dialogue: 0,0:57:10.40,0:57:15.90,Chinese,,0,0,0,,实际上，我们已经向该孩子发送了多个sig_child信号
Dialogue: 0,0:57:15.90,0:57:19.10,English,,0,0,0,,Which kept overriding that at bit in the pending bit vector
Dialogue: 0,0:57:15.90,0:57:19.10,Chinese,,0,0,0,,在未决位向量中，它一直保持在位
Dialogue: 0,0:57:20.26,0:57:26.68,English,,0,0,0,,And the delivery of those signals didn't cause any reaction in the process
Dialogue: 0,0:57:20.26,0:57:26.68,Chinese,,0,0,0,,并且这些信号的传递不会在该过程中引起任何反应
Dialogue: 0,0:57:26.68,0:57:30.00,English,,0,0,0,,Until that process was just about ready to be rescheduled
Dialogue: 0,0:57:26.68,0:57:30.00,Chinese,,0,0,0,,直到那个过程准备好重新安排
Dialogue: 0,0:57:30.44,0:57:33.02,English,,0,0,0,,And only then was where was a signal received
Dialogue: 0,0:57:30.44,0:57:33.02,Chinese,,0,0,0,,只有到那时才收到信号
Dialogue: 0,0:57:33.92,0:57:37.84,English,,0,0,0,,But even though like say three signals were delivered only one was received
Dialogue: 0,0:57:33.92,0:57:37.84,Chinese,,0,0,0,,但即使像三个信号一样，只收到了一个信号
Dialogue: 0,0:57:41.04,0:57:43.80,English,,0,0,0,,Okay so you can't use events in this case we're using event
Dialogue: 0,0:57:41.04,0:57:43.80,Chinese,,0,0,0,,好的，所以你不能在这种情况下使用事件我们正在使用事件
Dialogue: 0,0:57:44.58,0:57:50.40,English,,0,0,0,,We're using signals to count events which in this case is the termination of a child
Dialogue: 0,0:57:44.58,0:57:50.40,Chinese,,0,0,0,,我们使用信号来计算在这种情况下终止孩子的事件
Dialogue: 0,0:57:51.30,0:57:55.52,English,,0,0,0,,Okay so the receipt of a signal in this case
Dialogue: 0,0:57:51.30,0:57:55.52,Chinese,,0,0,0,,好的，所以在这种情况下收到一个信号
Dialogue: 0,0:57:55.62,0:58:00.04,English,,0,0,0,,It only indicates that at least one child terminated
Dialogue: 0,0:57:55.62,0:58:00.04,Chinese,,0,0,0,,它仅表示至少有一个孩子被终止
Dialogue: 0,0:58:00.40,0:58:04.06,English,,0,0,0,,Right not one child terminated
Dialogue: 0,0:58:00.40,0:58:04.06,Chinese,,0,0,0,,对不是一个孩子被终止了
Dialogue: 0,0:58:05.36,0:58:10.60,English,,0,0,0,,All we can infer from the receipt of that signal is that at least one child has terminated
Dialogue: 0,0:58:05.36,0:58:10.60,Chinese,,0,0,0,,我们从收到该信号可以推断出至少有一个孩子已经终止
Dialogue: 0,0:58:11.70,0:58:17.88,English,,0,0,0,,Okay so to fix that when we receive a sigchild
Dialogue: 0,0:58:11.70,0:58:17.88,Chinese,,0,0,0,,好的，所以当我们收到一个sigchld时解决这个问题
Dialogue: 0,0:58:18.68,0:58:23.80,English,,0,0,0,,We have to put we have to put the wait,that's reaping on our children
Dialogue: 0,0:58:18.68,0:58:23.80,Chinese,,0,0,0,,我们必须把等待，这是在我们的孩子们收获
Dialogue: 0,0:58:24.36,0:58:26.62,English,,0,0,0,,We have to put that in a loop
Dialogue: 0,0:58:24.36,0:58:26.62,Chinese,,0,0,0,,我们必须把它放在一个循环中
Dialogue: 0,0:58:27.30,0:58:29.48,English,,0,0,0,,So we have to assume that the receipt of a sigchild
Dialogue: 0,0:58:27.30,0:58:29.48,Chinese,,0,0,0,,所以我们必须假设收到一个sigchld
Dialogue: 0,0:58:29.80,0:58:34.16,English,,0,0,0,,If we get a sigchild there could be multiple terminated children
Dialogue: 0,0:58:29.80,0:58:34.16,Chinese,,0,0,0,,如果我们得到一个sigchild，可能会有多个被终止的孩子
Dialogue: 0,0:58:34.82,0:58:37.92,English,,0,0,0,,That we have to that we have to reap
Dialogue: 0,0:58:34.82,0:58:37.92,Chinese,,0,0,0,,我们必须要收获
Dialogue: 0,0:58:38.68,0:58:42.78,English,,0,0,0,,And so we put that in this loop and we execute this loop
Dialogue: 0,0:58:38.68,0:58:42.78,Chinese,,0,0,0,,所以我们把它放在这个循环中，然后我们执行这个循环
Dialogue: 0,0:58:43.08,0:58:48.78,English,,0,0,0,,Until there's no more terminated children in which case wait will...
Dialogue: 0,0:58:43.08,0:58:48.78,Chinese,,0,0,0,,直到没有更多终止的孩子，在这种情况下等待...
Dialogue: 0,0:58:49.24,0:58:53.22,English,,0,0,0,,Will exit with an error code of -1 and a error know of a child
Dialogue: 0,0:58:49.24,0:58:53.22,Chinese,,0,0,0,,将以错误代码-1退出并且错误知道孩子
Dialogue: 0,0:58:53.80,0:58:58.00,English,,0,0,0,,So this isn't really an error it's just means there's no more terminated children
Dialogue: 0,0:58:53.80,0:58:58.00,Chinese,,0,0,0,,所以这不是一个真正的错误，只是意味着没有更多的终止孩子
Dialogue: 0,0:58:58.00,0:59:03.30,English,,0,0,0,,So we check as long as if our errno naughty child then we have an error
Dialogue: 0,0:58:58.00,0:59:03.30,Chinese,,0,0,0,,所以我们检查，如果我们的顽皮顽皮的孩子，那么我们有一个错误
Dialogue: 0,0:59:03.82,0:59:06.72,English,,0,0,0,,Otherwise we terminated normally as we expect it
Dialogue: 0,0:59:03.82,0:59:06.72,Chinese,,0,0,0,,否则我们会按照预期正常终止
Dialogue: 0,0:59:07.54,0:59:09.12,English,,0,0,0,,Now if we run this code
Dialogue: 0,0:59:07.54,0:59:09.12,Chinese,,0,0,0,,现在，如果我们运行此代码
Dialogue: 0,0:59:10.46,0:59:15.94,English,,0,0,0,,Now we we see that we reap all five children as as we should
Dialogue: 0,0:59:10.46,0:59:15.94,Chinese,,0,0,0,,现在我们看到我们应该按照自己的意愿收获所有五个孩子
Dialogue: 0,0:59:18.70,0:59:23.30,English,,0,0,0,,Okay so let's the litany of problems with signals first
Dialogue: 0,0:59:18.70,0:59:23.30,Chinese,,0,0,0,,好吧，让我们先了解信号问题
Dialogue: 0,0:59:24.14,0:59:27.18,English,,0,0,0,,It's easy to write handlers that aren't safe
Dialogue: 0,0:59:24.14,0:59:27.18,Chinese,,0,0,0,,编写不安全的处理程序很容易
Dialogue: 0,0:59:27.72,0:59:31.02,English,,0,0,0,,Second it's easy to get the semantics wrong third
Dialogue: 0,0:59:27.72,0:59:31.02,Chinese,,0,0,0,,其次，很容易让语义错误第三
Dialogue: 0,0:59:32.30,0:59:35.88,English,,0,0,0,,They're often not even portable across different versions of UNIX
Dialogue: 0,0:59:32.30,0:59:35.88,Chinese,,0,0,0,,它们通常甚至不能在不同版本的UNIX上移植
Dialogue: 0,0:59:36.82,0:59:39.86,English,,0,0,0,,So there's some older systems I don't know if any
Dialogue: 0,0:59:36.82,0:59:39.86,Chinese,,0,0,0,,所以有一些我不知道的旧系统
Dialogue: 0,0:59:40.68,0:59:47.74,English,,0,0,0,,There's some earlier versions of UNIX that after you catch a signal it restores the default action
Dialogue: 0,0:59:40.68,0:59:47.74,Chinese,,0,0,0,,有一些早期版本的UNIX在捕获信号后会恢复默认操作
Dialogue: 0,0:59:47.82,0:59:50.70,English,,0,0,0,,So you have to reinstall the handler every time
Dialogue: 0,0:59:47.82,0:59:50.70,Chinese,,0,0,0,,所以你必须每次都重新安装处理程序
Dialogue: 0,0:59:51.64,0:59:57.64,English,,0,0,0,,Well every time a handler gets called you have to reinstall that handler by calling signal inside the handler itself
Dialogue: 0,0:59:51.64,0:59:57.64,Chinese,,0,0,0,,好每次调用处理程序时，都必须通过调用处理程序本身内部的信号来重新安装该处理程序
Dialogue: 0,0:59:58.62,1:00:00.88,English,,0,0,0,,We don't have to do that for Linux systems
Dialogue: 0,0:59:58.62,1:00:00.88,Chinese,,0,0,0,,我们不必为Linux系统这样做
Dialogue: 0,1:00:03.22,1:00:08.52,English,,0,0,0,,On some systems when you have so-called slow syscalls
Dialogue: 0,1:00:03.22,1:00:08.52,Chinese,,0,0,0,,在某些系统上，当你有所谓的慢速系统调用时
Dialogue: 0,1:00:09.66,1:00:10.70,English,,0,0,0,,For example read
Dialogue: 0,1:00:09.66,1:00:10.70,Chinese,,0,0,0,,例如阅读
Dialogue: 0,1:00:11.96,1:00:13.54,English,,0,0,0,,You know if you do a read system call
Dialogue: 0,1:00:11.96,1:00:13.54,Chinese,,0,0,0,,你知道你是否进行了系统调用
Dialogue: 0,1:00:15.38,1:00:18.68,English,,0,0,0,,The kernel doesn't wait around for that data to arrive
Dialogue: 0,1:00:15.38,1:00:18.68,Chinese,,0,0,0,,内核不会等待数据到达
Dialogue: 0,1:00:20.48,1:00:25.46,English,,0,0,0,,It you know it sends a request to the disk controller and that schedules another process
Dialogue: 0,1:00:20.48,1:00:25.46,Chinese,,0,0,0,,它知道它向磁盘控制器发送请求并安排另一个进程
Dialogue: 0,1:00:26.70,1:00:31.22,English,,0,0,0,,Right so in a way that the read call is sort of and then only when the data arrives
Dialogue: 0,1:00:26.70,1:00:31.22,Chinese,,0,0,0,,这样做的方式是读取调用是一种，然后只有当数据到达时
Dialogue: 0,1:00:31.54,1:00:34.64,English,,0,0,0,,And the interrupt comes in announcing that the data arrives
Dialogue: 0,1:00:31.54,1:00:34.64,Chinese,,0,0,0,,并且中断声明数据到达
Dialogue: 0,1:00:35.14,1:00:38.92,English,,0,0,0,,Does that read call finish and then restore and return
Dialogue: 0,1:00:35.14,1:00:38.92,Chinese,,0,0,0,,是否读取完成然后恢复并返回
Dialogue: 0,1:00:39.58,1:00:43.86,English,,0,0,0,,So you can think of read is actually kind of broken up into two parts right
Dialogue: 0,1:00:39.58,1:00:43.86,Chinese,,0,0,0,,所以你可以认为阅读实际上是分为两部分
Dialogue: 0,1:00:45.90,1:00:54.14,English,,0,0,0,,Then and so that functions like read these kind of functions are called slow syscalls
Dialogue: 0,1:00:45.90,1:00:54.14,Chinese,,0,0,0,,然后，所以读取这些函数的函数称为慢速系统调用
Dialogue: 0,1:00:55.36,1:00:59.68,English,,0,0,0,,And on some systems if the process receives a signal
Dialogue: 0,1:00:55.36,1:00:59.68,Chinese,,0,0,0,,并且在某些系统上，如果进程收到信号
Dialogue: 0,1:01:00.16,1:01:02.54,English,,0,0,0,,Before a slow system calls has finished
Dialogue: 0,1:01:00.16,1:01:02.54,Chinese,,0,0,0,,在慢速系统调用完成之前
Dialogue: 0,1:01:04.24,1:01:09.22,English,,0,0,0,,The kernel will just abort that system call and return from that system call with an error
Dialogue: 0,1:01:04.24,1:01:09.22,Chinese,,0,0,0,,内核将中止该系统调用并从该系统调用返回错误
Dialogue: 0,1:01:09.92,1:01:14.54,English,,0,0,0,,Okay so from users point of view you're doing a read call
Dialogue: 0,1:01:09.92,1:01:14.54,Chinese,,0,0,0,,好的，从用户的角度来看，你正在进行阅读
Dialogue: 0,1:01:15.22,1:01:19.64,English,,0,0,0,,And it returns with this e enter signal this e enter error
Dialogue: 0,1:01:15.22,1:01:19.64,Chinese,,0,0,0,,并且它返回此e输入信号，此输入错误
Dialogue: 0,1:01:20.72,1:01:24.82,English,,0,0,0,,You did nothing wrong you just happen to have the bad luck of being interrupted by some signal
Dialogue: 0,1:01:20.72,1:01:24.82,Chinese,,0,0,0,,你没有做错什么，你碰巧遇到被某些信号打断的坏运气
Dialogue: 0,1:01:25.14,1:01:27.26,English,,0,0,0,,And so in your user code you have to check for that
Dialogue: 0,1:01:25.14,1:01:27.26,Chinese,,0,0,0,,因此，在你的用户代码中，你必须检查它
Dialogue: 0,1:01:27.32,1:01:33.34,English,,0,0,0,,And if a slow system call like read is interrupted by signal you have to redo it
Dialogue: 0,1:01:27.32,1:01:33.34,Chinese,,0,0,0,,如果像读取这样的慢速系统调用被信号中断，则必须重做它
Dialogue: 0,1:01:33.82,1:01:39.04,English,,0,0,0,,So you have to put which is really a pain right because you have to put these read calls in a loop
Dialogue: 0,1:01:33.82,1:01:39.04,Chinese,,0,0,0,,因此，你必须将这些读取调用置于循环中，因此你必须确定哪个是非常痛苦的
Dialogue: 0,1:01:39.04,1:01:41.72,English,,0,0,0,,And keep looping until it succeeds
Dialogue: 0,1:01:39.04,1:01:41.72,Chinese,,0,0,0,,并保持循环直到成功
Dialogue: 0,1:01:42.90,1:01:46.90,English,,0,0,0,,And finally some systems don't block signals of the type being handled right
Dialogue: 0,1:01:42.90,1:01:46.90,Chinese,,0,0,0,,最后，一些系统不会阻止正确处理的类型的信号
Dialogue: 0,1:01:48.92,1:01:52.32,English,,0,0,0,,So that the solution for this is a replacement for signal
Dialogue: 0,1:01:48.92,1:01:52.32,Chinese,,0,0,0,,因此，解决方案就是替代信号
Dialogue: 0,1:01:52.32,1:01:54.32,English,,0,0,0,,So the problem is with the signal syscall
Dialogue: 0,1:01:52.32,1:01:54.32,Chinese,,0,0,0,,所以问题在于信号系统调用
Dialogue: 0,1:01:54.94,1:01:58.52,English,,0,0,0,,And the solution is a newer syscall called sigaction
Dialogue: 0,1:01:54.94,1:01:58.52,Chinese,,0,0,0,,解决方案是一个更新的系统调用，称为sigaction
Dialogue: 0,1:01:59.00,1:02:02.32,English,,0,0,0,,Which provides a mechanism a replacement for signal
Dialogue: 0,1:01:59.00,1:02:02.32,Chinese,,0,0,0,,这提供了一种替代信号的机制
Dialogue: 0,1:02:02.80,1:02:06.70,English,,0,0,0,,That provides a mechanism for portable and predictable signal handling
Dialogue: 0,1:02:02.80,1:02:06.70,Chinese,,0,0,0,,这为便携式和可预测的信号处理提供了一种机制
Dialogue: 0,1:02:07.54,1:02:14.18,English,,0,0,0,,And so what I've done is created a rapper called uppercase signal
Dialogue: 0,1:02:07.54,1:02:14.18,Chinese,,0,0,0,,所以我所做的就是创造一个叫做大写信号的说唱歌手
Dialogue: 0,1:02:15.76,1:02:19.56,English,,0,0,0,,That takes the same arguments as that the signal call
Dialogue: 0,1:02:15.76,1:02:19.56,Chinese,,0,0,0,,它采用与信号调用相同的参数
Dialogue: 0,1:02:20.88,1:02:26.04,English,,0,0,0,,But inside it calls the sigaction function to get portable signal handling
Dialogue: 0,1:02:20.88,1:02:26.04,Chinese,,0,0,0,,但它内部调用sigaction函数来获取便携式信号处理
Dialogue: 0,1:02:27.44,1:02:32.22,English,,0,0,0,,And so it's not really important to go into detail about this
Dialogue: 0,1:02:27.44,1:02:32.22,Chinese,,0,0,0,,因此，详细了解这一点并不重要
Dialogue: 0,1:02:34.22,1:02:42.78,English,,0,0,0,,The point is in your code you always want to call Signal using the  rapper that provided in csapp.c
Dialogue: 0,1:02:34.22,1:02:42.78,Chinese,,0,0,0,,关键在于你始终希望使用csapp.c中提供的说唱歌手调用Signal
Dialogue: 0,1:02:43.28,1:02:47.26,English,,0,0,0,,And then if you do that then you'll always block signals of the typing
Dialogue: 0,1:02:43.28,1:02:47.26,Chinese,,0,0,0,,然后，如果你这样做，那么你将始终阻止打字的信号
Dialogue: 0,1:02:47.70,1:02:50.84,English,,0,0,0,,Handle the system will automatically restart
Dialogue: 0,1:02:47.70,1:02:50.84,Chinese,,0,0,0,,处理系统将自动重启
Dialogue: 0,1:02:52.02,1:02:55.28,English,,0,0,0,,Slow syscalls that have been interrupted by by signals
Dialogue: 0,1:02:52.02,1:02:55.28,Chinese,,0,0,0,,被信号中断的慢速系统调用
Dialogue: 0,1:02:58.60,1:03:00.84,English,,0,0,0,,Okay so fortunately there's an easy fix for this
Dialogue: 0,1:02:58.60,1:03:00.84,Chinese,,0,0,0,,好吧幸运的是，有一个简单的解决方案
Dialogue: 0,1:03:04.48,1:03:06.74,English,,0,0,0,,Now let's finish up with them
Dialogue: 0,1:03:04.48,1:03:06.74,Chinese,,0,0,0,,现在让我们完成他们
Dialogue: 0,1:03:08.78,1:03:11.60,English,,0,0,0,,There's some interesting I mentioned that signals are difficult
Dialogue: 0,1:03:08.78,1:03:11.60,Chinese,,0,0,0,,有一些有趣的我提到信号很难
Dialogue: 0,1:03:11.60,1:03:14.56,English,,0,0,0,,Because of these the fact that they're concurrent flows
Dialogue: 0,1:03:11.60,1:03:14.56,Chinese,,0,0,0,,因为这些事实是它们是并发流动
Dialogue: 0,1:03:15.10,1:03:20.36,English,,0,0,0,,So I want to look at some sort of subtle issues that you can run into because of this concurrency
Dialogue: 0,1:03:15.10,1:03:20.36,Chinese,,0,0,0,,所以我想看看由于这种并发性而可能遇到的某些微妙问题
Dialogue: 0,1:03:21.98,1:03:26.56,English,,0,0,0,,And I want to talk about how to identify those errors and how to fix them
Dialogue: 0,1:03:21.98,1:03:26.56,Chinese,,0,0,0,,我想谈谈如何识别这些错误以及如何解决这些错误
Dialogue: 0,1:03:31.20,1:03:35.60,English,,0,0,0,,So here's a program that this is like a simple shell program
Dialogue: 0,1:03:31.20,1:03:35.60,Chinese,,0,0,0,,所以这是一个程序，这就像一个简单的shell程序
Dialogue: 0,1:03:36.40,1:03:41.58,English,,0,0,0,,That maintains a jobs list right so every time it creates a new child
Dialogue: 0,1:03:36.40,1:03:41.58,Chinese,,0,0,0,,这样就可以保持一份工作清单，这样每次创建一个新的孩子
Dialogue: 0,1:03:42.30,1:03:48.04,English,,0,0,0,,It adds it to the jobs list and every time that child terminates it removes it from the jobs list
Dialogue: 0,1:03:42.30,1:03:48.04,Chinese,,0,0,0,,它将它添加到作业列表中，每次该子句终止时，都会将其从作业列表中删除
Dialogue: 0,1:03:51.06,1:04:01.76,English,,0,0,0,,Okay so our simple show just in a loop it just creates a child and then executes the program within that child
Dialogue: 0,1:03:51.06,1:04:01.76,Chinese,,0,0,0,,好的，所以我们的简单节目只是在一个循环中它只是创建一个孩子，然后在该孩子中执行该程序
Dialogue: 0,1:04:02.46,1:04:09.72,English,,0,0,0,,And then in the parent it correctly blocks all of the signals temporarily while it adds the job to the job queue
Dialogue: 0,1:04:02.46,1:04:09.72,Chinese,,0,0,0,,然后在父级中，它会在将作业添加到作业队列时正确地阻止所有信号
Dialogue: 0,1:04:12.60,1:04:16.26,English,,0,0,0,,And then it unblocks and then it unblocks those signals
Dialogue: 0,1:04:12.60,1:04:16.26,Chinese,,0,0,0,,然后它解锁，然后解锁这些信号
Dialogue: 0,1:04:17.78,1:04:22.76,English,,0,0,0,,Okay so this is correct and that it's protecting access to this the shared job queue
Dialogue: 0,1:04:17.78,1:04:22.76,Chinese,,0,0,0,,好的，这是正确的，并且它保护对共享作业队列的访问
Dialogue: 0,1:04:25.76,1:04:31.88,English,,0,0,0,,Because job queue is also manipulated by the sick child handler
Dialogue: 0,1:04:25.76,1:04:31.88,Chinese,,0,0,0,,因为作业队列也由生病的子处理程序操纵
Dialogue: 0,1:04:32.06,1:04:37.68,English,,0,0,0,,So when a child terminates and the parent receives the sigchild
Dialogue: 0,1:04:32.06,1:04:37.68,Chinese,,0,0,0,,因此当孩子终止并且父母收到sigchld时
Dialogue: 0,1:04:38.26,1:04:40.54,English,,0,0,0,,This handler runs
Dialogue: 0,1:04:38.26,1:04:40.54,Chinese,,0,0,0,,这个处理程序运行
Dialogue: 0,1:04:41.98,1:04:47.02,English,,0,0,0,,And this handler goes through and it reaps all of the children potentially terminated children
Dialogue: 0,1:04:41.98,1:04:47.02,Chinese,,0,0,0,,而且这个处理程序会通过并收回所有可能终止孩子的孩子
Dialogue: 0,1:04:47.82,1:04:52.42,English,,0,0,0,,And then for each one it deletes that job from the job queue
Dialogue: 0,1:04:47.82,1:04:52.42,Chinese,,0,0,0,,然后对于每一个它从作业队列中删除该作业
Dialogue: 0,1:04:52.92,1:04:57.66,English,,0,0,0,,All right so here's a classic case we have two concurrent flows our main routine
Dialogue: 0,1:04:52.92,1:04:57.66,Chinese,,0,0,0,,好吧所以这是一个经典案例，我们有两个并发流程，我们的主要例程
Dialogue: 0,1:04:58.44,1:05:00.74,English,,0,0,0,,And our signal handler
Dialogue: 0,1:04:58.44,1:05:00.74,Chinese,,0,0,0,,我们的信号处理程序
Dialogue: 0,1:05:01.82,1:05:06.50,English,,0,0,0,,They're each accessing a shared data structure in this case the job queue
Dialogue: 0,1:05:01.82,1:05:06.50,Chinese,,0,0,0,,他们每个人都访问共享数据结构，在这种情况下是作业队列
Dialogue: 0,1:05:08.78,1:05:16.62,English,,0,0,0,,Okay and they're there correctly blocking signals while they update this this job queue
Dialogue: 0,1:05:08.78,1:05:16.62,Chinese,,0,0,0,,好的，他们在更新此作业队列时正确阻止了信号
Dialogue: 0,1:05:19.12,1:05:23.26,English,,0,0,0,,But this program has a really subtle and nasty bug in it
Dialogue: 0,1:05:19.12,1:05:23.26,Chinese,,0,0,0,,但是这个程序中有一个非常微妙和令人讨厌的错误
Dialogue: 0,1:05:25.42,1:05:26.58,English,,0,0,0,,Can you see what it is
Dialogue: 0,1:05:25.42,1:05:26.58,Chinese,,0,0,0,,你能看出它是什么吗？
Dialogue: 0,1:05:30.60,1:05:32.26,English,,0,0,0,,What's the sequence of events that would
Dialogue: 0,1:05:30.60,1:05:32.26,Chinese,,0,0,0,,会发生什么样的事件
Dialogue: 0,1:05:33.58,1:05:36.50,English,,0,0,0,,Cause this program to fail
Dialogue: 0,1:05:33.58,1:05:36.50,Chinese,,0,0,0,,导致此程序失败
Dialogue: 0,1:05:40.82,1:05:41.34,English,,0,0,0,,Yes
Dialogue: 0,1:05:40.82,1:05:41.34,Chinese,,0,0,0,,是
Dialogue: 0,1:05:47.22,1:05:52.58,English,,0,0,0,,Exactly that's exactly it,so is it possible that the the child process
Dialogue: 0,1:05:47.22,1:05:52.58,Chinese,,0,0,0,,正是这就是它，所以子进程可能也是如此
Dialogue: 0,1:05:53.34,1:05:58.02,English,,0,0,0,,Could terminate before the parent has a chance to add that job to the queue and the answer is yes
Dialogue: 0,1:05:53.34,1:05:58.02,Chinese,,0,0,0,,可以在父有机会将该作业添加到队列之前终止，答案是肯定的
Dialogue: 0,1:05:58.66,1:06:04.78,English,,0,0,0,,Right we you cannot make any assumptions about the execution ordering of the child in the process
Dialogue: 0,1:05:58.66,1:06:04.78,Chinese,,0,0,0,,对，我们你不能对这个过程中孩子的执行顺序做出任何假设
Dialogue: 0,1:06:05.14,1:06:06.40,English,,0,0,0,,Or about how long they run right
Dialogue: 0,1:06:05.14,1:06:06.40,Chinese,,0,0,0,,或者说他们跑多久了
Dialogue: 0,1:06:06.78,1:06:09.42,English,,0,0,0,,So it's very possible
Dialogue: 0,1:06:06.78,1:06:09.42,Chinese,,0,0,0,,所以这很有可能
Dialogue: 0,1:06:10.10,1:06:16.20,English,,0,0,0,,That the child can connect after the four control returns to the child instead of the parent
Dialogue: 0,1:06:10.10,1:06:16.20,Chinese,,0,0,0,,在四个控件返回到子节点而不是父节点之后，子节点可以连接
Dialogue: 0,1:06:16.76,1:06:22.90,English,,0,0,0,,And then the child terminates before the parent ever has a chance to add that job to the job queue
Dialogue: 0,1:06:16.76,1:06:22.90,Chinese,,0,0,0,,然后，在父母有机会将该作业添加到作业队列之前，子进程终止
Dialogue: 0,1:06:23.38,1:06:30.10,English,,0,0,0,,So now what's happened is that the child is deleting
Dialogue: 0,1:06:23.38,1:06:30.10,Chinese,,0,0,0,,所以现在发生的事情是孩子正在删除
Dialogue: 0,1:06:30.92,1:06:35.43,English,,0,0,0,,A deleting a job that hasn't been added to the job queue right
Dialogue: 0,1:06:30.92,1:06:35.43,Chinese,,0,0,0,,删除尚未添加到作业队列的作业
Dialogue: 0,1:06:35.62,1:06:40.30,English,,0,0,0,,Now when the parent finally gets around to running it adds that job to the job queue
Dialogue: 0,1:06:35.62,1:06:40.30,Chinese,,0,0,0,,现在，当父母最终开始运行时，它将该作业添加到作业队列中
Dialogue: 0,1:06:40.58,1:06:42.06,English,,0,0,0,,And that job will never be deleted
Dialogue: 0,1:06:40.58,1:06:42.06,Chinese,,0,0,0,,而且这项工作永远不会被删除
Dialogue: 0,1:06:43.96,1:06:50.42,English,,0,0,0,,Right so this is the kind of subtle nasty horrible kind of bug that you run into
Dialogue: 0,1:06:43.96,1:06:50.42,Chinese,,0,0,0,,对，所以这就是你遇到的一种微妙的令人讨厌的可怕的虫子
Dialogue: 0,1:06:50.78,1:06:52.46,English,,0,0,0,,When you're dealing with concurrency
Dialogue: 0,1:06:50.78,1:06:52.46,Chinese,,0,0,0,,当你处理并发时
Dialogue: 0,1:06:53.00,1:06:56.06,English,,0,0,0,,Trying to keep track of all of these interleaving of events
Dialogue: 0,1:06:53.00,1:06:56.06,Chinese,,0,0,0,,试图跟踪所有这些事件的交错
Dialogue: 0,1:06:56.82,1:06:58.78,English,,0,0,0,,Can just make your head explode all right
Dialogue: 0,1:06:56.82,1:06:58.78,Chinese,,0,0,0,,可以让你的头爆炸好吧
Dialogue: 0,1:06:59.62,1:07:04.90,English,,0,0,0,,Now and it happens and sig... it happens with any kind of concurrency
Dialogue: 0,1:06:59.62,1:07:04.90,Chinese,,0,0,0,,现在它发生了并且sig ......它发生在任何类型的并发中
Dialogue: 0,1:07:05.30,1:07:09.82,English,,0,0,0,,Where you have concurrent flows accessing shared resources and signal handlers are no different
Dialogue: 0,1:07:05.30,1:07:09.82,Chinese,,0,0,0,,在哪里有并发流访问共享资源和信号处理程序没有什么不同
Dialogue: 0,1:07:10.68,1:07:15.88,English,,0,0,0,,Now we'll look at principled ways where we can deal with this kind of sharing when we study threads later on
Dialogue: 0,1:07:10.68,1:07:15.88,Chinese,,0,0,0,,现在我们将看一下在我们稍后研究线程时可以处理这种共享的原则性方法
Dialogue: 0,1:07:17.34,1:07:22.16,English,,0,0,0,,But I just want to point this out to him scare you a little bit
Dialogue: 0,1:07:17.34,1:07:22.16,Chinese,,0,0,0,,但我只想指出这一点让他吓唬你一点
Dialogue: 0,1:07:23.34,1:07:24.96,English,,0,0,0,,All right so here's how we would fix that
Dialogue: 0,1:07:23.34,1:07:24.96,Chinese,,0,0,0,,好的，这就是我们如何解决这个问题
Dialogue: 0,1:07:27.28,1:07:37.74,English,,0,0,0,,What we have to do is somehow avoid the possibility of the child handle or executing
Dialogue: 0,1:07:27.28,1:07:37.74,Chinese,,0,0,0,,我们要做的是以某种方式避免孩子处理或执行的可能性
Dialogue: 0,1:07:38.38,1:07:43.28,English,,0,0,0,,Before the parent can add the corresponding job to the job queue
Dialogue: 0,1:07:38.38,1:07:43.28,Chinese,,0,0,0,,在父级可以将相应的作业添加到作业队列之前
Dialogue: 0,1:07:44.18,1:07:48.54,English,,0,0,0,,Now we can't control whether the child executes first or the parent execute first
Dialogue: 0,1:07:44.18,1:07:48.54,Chinese,,0,0,0,,现在我们无法控制子进程是先执行还是先执行父进程
Dialogue: 0,1:07:49.62,1:07:51.74,English,,0,0,0,,And we can't control how long the child runs
Dialogue: 0,1:07:49.62,1:07:51.74,Chinese,,0,0,0,,我们无法控制孩子跑多久
Dialogue: 0,1:07:52.50,1:07:58.10,English,,0,0,0,,But we can control when the the sigchild handler runs because we can block signals
Dialogue: 0,1:07:52.50,1:07:58.10,Chinese,,0,0,0,,但是我们可以控制sigchild处理程序何时运行，因为我们可以阻止信号
Dialogue: 0,1:07:58.81,1:08:00.84,English,,0,0,0,,Okay so what we'll do
Dialogue: 0,1:07:58.81,1:08:00.84,Chinese,,0,0,0,,好的，我们会做什么
Dialogue: 0,1:08:02.44,1:08:04.34,English,,0,0,0,,We'll modify our program
Dialogue: 0,1:08:02.44,1:08:04.34,Chinese,,0,0,0,,我们将修改我们的计划
Dialogue: 0,1:08:07.36,1:08:12.88,English,,0,0,0,,We'll use sigprocmask to block sigchild signals before we create the child
Dialogue: 0,1:08:07.36,1:08:12.88,Chinese,,0,0,0,,在创建子节点之前，我们将使用sigprocmask来阻止sigchild信号
Dialogue: 0,1:08:14.50,1:08:19.44,English,,0,0,0,,Okay so at this point after this invocation of sigproc,sigchild, signals are blocked
Dialogue: 0,1:08:14.50,1:08:19.44,Chinese,,0,0,0,,好的，在调用sigproc，sigchild之后，此时信号被阻止了
Dialogue: 0,1:08:21.64,1:08:23.32,English,,0,0,0,,Okay then we create the child
Dialogue: 0,1:08:21.64,1:08:23.32,Chinese,,0,0,0,,好的，然后我们创造了孩子
Dialogue: 0,1:08:24.68,1:08:27.54,English,,0,0,0,,And before we do execev
Dialogue: 0,1:08:24.68,1:08:27.54,Chinese,,0,0,0,,在我们做execev之前
Dialogue: 0,1:08:27.90,1:08:34.30,English,,0,0,0,,Since we don't know that child may may need to reap its children right we don't know if it
Dialogue: 0,1:08:27.90,1:08:34.30,Chinese,,0,0,0,,由于我们不知道孩子可能需要收养孩子，我们不知道是否
Dialogue: 0,1:08:34.82,1:08:42.82,English,,0,0,0,,By default children inherit the the blocked a bit vector of their parents okay so when this child runs
Dialogue: 0,1:08:34.82,1:08:42.82,Chinese,,0,0,0,,默认情况下，子项继承了父母的阻止了一点矢量，所以当这个孩子运行时
Dialogue: 0,1:08:44.60,1:08:51.74,English,,0,0,0,,After it returns from fork at this point right after the fork sigchild is blocked in the child as well right
Dialogue: 0,1:08:44.60,1:08:51.74,Chinese,,0,0,0,,之后，当叉子sigchild在孩子中被阻挡之后，它从fork返回
Dialogue: 0,1:08:52.34,1:08:55.28,English,,0,0,0,,So if we didn't do anything if and the child created children
Dialogue: 0,1:08:52.34,1:08:55.28,Chinese,,0,0,0,,所以如果我们没有做任何事情，如果孩子创造了孩子
Dialogue: 0,1:08:56.74,1:09:01.58,English,,0,0,0,,And tried to reap you know reap them with a sick child handle that sick child handler wouldn't run right
Dialogue: 0,1:08:56.74,1:09:01.58,Chinese,,0,0,0,,并试图收获你知道收获他们生病的孩子处理，生病的孩子处理程序不能正常运行
Dialogue: 0,1:09:01.60,1:09:02.44,English,,0,0,0,,So that would be a problem
Dialogue: 0,1:09:01.60,1:09:02.44,Chinese,,0,0,0,,这将是一个问题
Dialogue: 0,1:09:03.42,1:09:08.30,English,,0,0,0,,So in the child before we execute that the program itself we unblock sigchild
Dialogue: 0,1:09:03.42,1:09:08.30,Chinese,,0,0,0,,所以在我们执行程序本身之前的孩子，我们解锁sigchld
Dialogue: 0,1:09:09.16,1:09:11.60,English,,0,0,0,,And this was an example that I was alluding to last time
Dialogue: 0,1:09:09.16,1:09:11.60,Chinese,,0,0,0,,这是我上次提到的一个例子
Dialogue: 0,1:09:12.40,1:09:19.44,English,,0,0,0,,How it's useful sometimes to separate creating processes with executing programs right then
Dialogue: 0,1:09:12.40,1:09:19.44,Chinese,,0,0,0,,有时如何将创建进程与执行程序分开是有用的
Dialogue: 0,1:09:20.72,1:09:27.52,English,,0,0,0,,So this allows us to get our signal mask set up the way we want it before we run our program in the child
Dialogue: 0,1:09:20.72,1:09:27.52,Chinese,,0,0,0,,因此，这允许我们在孩子中运行程序之前，以我们想要的方式设置信号掩码
Dialogue: 0,1:09:29.34,1:09:33.82,English,,0,0,0,,So now even if the child terminates early
Dialogue: 0,1:09:29.34,1:09:33.82,Chinese,,0,0,0,,所以现在即使孩子提前结束
Dialogue: 0,1:09:36.26,1:09:43.94,English,,0,0,0,,The sigchild handler won't run until after we've added the job to the to the job queue
Dialogue: 0,1:09:36.26,1:09:43.94,Chinese,,0,0,0,,在将作业添加到作业队列之后，sigchld处理程序才会运行
Dialogue: 0,1:09:44.42,1:09:49.74,English,,0,0,0,,Because we don't unblock sigchild until after the until after we call a job
Dialogue: 0,1:09:44.42,1:09:49.74,Chinese,,0,0,0,,因为我们直到我们打电话给工作之后才解除对sigchild的阻止
Dialogue: 0,1:09:57.82,1:09:58.98,English,,0,0,0,,Okay now there's another
Dialogue: 0,1:09:57.82,1:09:58.98,Chinese,,0,0,0,,好的，现在还有另一个
Dialogue: 0,1:09:59.26,1:10:04.40,English,,0,0,0,,So this sort of scenario be very relevant to you when you do your shell lab
Dialogue: 0,1:09:59.26,1:10:04.40,Chinese,,0,0,0,,因此，当你进行shell实验时，这种情况与你非常相关
Dialogue: 0,1:10:05.10,1:10:08.52,English,,0,0,0,,Okay so you want to be careful not to make that mistake
Dialogue: 0,1:10:05.10,1:10:08.52,Chinese,,0,0,0,,好的，所以你要注意不要犯这个错误
Dialogue: 0,1:10:12.28,1:10:15.84,English,,0,0,0,,Another thing that you're going to need to do in your shell lab
Dialogue: 0,1:10:12.28,1:10:15.84,Chinese,,0,0,0,,你在shell实验室中需要做的另一件事
Dialogue: 0,1:10:16.92,1:10:20.22,English,,0,0,0,,Now you remember in our simple our simple shell example we did the wait
Dialogue: 0,1:10:16.92,1:10:20.22,Chinese,,0,0,0,,现在你记得我们在简单的shell示例中做了等待
Dialogue: 0,1:10:20.74,1:10:24.65,English,,0,0,0,,Inside the main routine so we waited for foreground jobs using wait
Dialogue: 0,1:10:20.74,1:10:24.65,Chinese,,0,0,0,,在主例程中，我们使用wait等待前台作业
Dialogue: 0,1:10:25.48,1:10:31.28,English,,0,0,0,,But now in a real shell we're going to have our sigchild handler do all the all the wait call all the waits
Dialogue: 0,1:10:25.48,1:10:31.28,Chinese,,0,0,0,,但是现在在一个真正的shell中，我们将让你的sigchld处理程序完成所有等待的所有等待调用
Dialogue: 0,1:10:32.28,1:10:37.58,English,,0,0,0,,And so we can't put the weight has to go in the sigchild handler can't go in the main routine
Dialogue: 0,1:10:32.28,1:10:37.58,Chinese,,0,0,0,,所以我们不能把重量放在sigchld处理程序不能进入主程序
Dialogue: 0,1:10:40.48,1:10:45.66,English,,0,0,0,,Okay so high if we can't put a weight in the main routine
Dialogue: 0,1:10:40.48,1:10:45.66,Chinese,,0,0,0,,如果我们不能在主程序中加重，那么这么高
Dialogue: 0,1:10:46.88,1:10:50.88,English,,0,0,0,,How are we going to detect that our foreground job is finished
Dialogue: 0,1:10:46.88,1:10:50.88,Chinese,,0,0,0,,我们如何检测我们的前台工作已经完成
Dialogue: 0,1:10:56.50,1:11:01.42,English,,0,0,0,,Okay so somehow so what we could do?we could define in the sigchild handler
Dialogue: 0,1:10:56.50,1:11:01.42,Chinese,,0,0,0,,好的，所以我们可以做什么？我们可以在sigchld处理程序中定义
Dialogue: 0,1:11:03.00,1:11:05.16,English,,0,0,0,,When we read the foreground job
Dialogue: 0,1:11:03.00,1:11:05.16,Chinese,,0,0,0,,当我们阅读前台工作时
Dialogue: 0,1:11:06.84,1:11:10.42,English,,0,0,0,,Right we've created a foreground job when we read that foreground job
Dialogue: 0,1:11:06.84,1:11:10.42,Chinese,,0,0,0,,对，我们在读取前台作业时创建了一个前台作业
Dialogue: 0,1:11:11.18,1:11:14.92,English,,0,0,0,,We could set this global flag
Dialogue: 0,1:11:11.18,1:11:14.92,Chinese,,0,0,0,,我们可以设置这个全球旗帜
Dialogue: 0,1:11:16.02,1:11:18.48,English,,0,0,0,,We could declare the process this process id
Dialogue: 0,1:11:16.02,1:11:18.48,Chinese,,0,0,0,,我们可以声明此进程id的进程
Dialogue: 0,1:11:19.14,1:11:21.98,English,,0,0,0,,A variable pid as a global flag
Dialogue: 0,1:11:19.14,1:11:21.98,Chinese,,0,0,0,,变量pid作为全局标志
Dialogue: 0,1:11:22.64,1:11:27.86,English,,0,0,0,,And then just assign the process id of the foreground job
Dialogue: 0,1:11:22.64,1:11:27.86,Chinese,,0,0,0,,然后只需分配前台作业的进程ID
Dialogue: 0,1:11:29.50,1:11:34.06,English,,0,0,0,,Okay so this is an example of a handler it just all it does it sets a flag and then exits
Dialogue: 0,1:11:29.50,1:11:34.06,Chinese,,0,0,0,,好的，所以这是一个处理程序的例子，它只是设置一个标志，然后退出
Dialogue: 0,1:11:38.92,1:11:45.56,English,,0,0,0,,And then in our main routine,okay we want to block sigchild just by just like before
Dialogue: 0,1:11:38.92,1:11:45.56,Chinese,,0,0,0,,然后在我们的主程序中，好吧我们想要像之前一样阻止sigchild
Dialogue: 0,1:11:45.94,1:11:51.24,English,,0,0,0,,Okay to avoid that race condition between the parent and the child
Dialogue: 0,1:11:45.94,1:11:51.24,Chinese,,0,0,0,,好的，以避免父母和孩子之间的竞争条件
Dialogue: 0,1:11:53.48,1:11:55.42,English,,0,0,0,,And then we create the child
Dialogue: 0,1:11:53.48,1:11:55.42,Chinese,,0,0,0,,然后我们创造了孩子
Dialogue: 0,1:11:57.40,1:12:01.54,English,,0,0,0,,And then in the and then the parent we set pid to zero
Dialogue: 0,1:11:57.40,1:12:01.54,Chinese,,0,0,0,,然后在父母那时我们将pid设置为零
Dialogue: 0,1:12:03.92,1:12:05.70,English,,0,0,0,,Okay then we unblock sigchild
Dialogue: 0,1:12:03.92,1:12:05.70,Chinese,,0,0,0,,那么我们取消阻止sigchld
Dialogue: 0,1:12:07.30,1:12:11.76,English,,0,0,0,,And then we wait for the sick child handler to run and set pid to nonzero
Dialogue: 0,1:12:07.30,1:12:11.76,Chinese,,0,0,0,,然后我们等待生病的子处理程序运行并将pid设置为非零
Dialogue: 0,1:12:15.56,1:12:18.34,English,,0,0,0,,Okay everybody see that I mean this so this is correct right
Dialogue: 0,1:12:15.56,1:12:18.34,Chinese,,0,0,0,,好的，每个人都看到我的意思是这样，这是正确的
Dialogue: 0,1:12:19.70,1:12:21.30,English,,0,0,0,,But it's extremely wasteful right
Dialogue: 0,1:12:19.70,1:12:21.30,Chinese,,0,0,0,,但这非常浪费
Dialogue: 0,1:12:21.64,1:12:29.96,English,,0,0,0,,We're spinning...we're using valuable processor cycles in this tight spin loop
Dialogue: 0,1:12:21.64,1:12:29.96,Chinese,,0,0,0,,我们正在旋转...我们在这个紧密的旋转循环中使用了宝贵的处理器周期
Dialogue: 0,1:12:30.14,1:12:33.74,English,,0,0,0,,Just executing over and over and over and over and over and over, for who knows how long
Dialogue: 0,1:12:30.14,1:12:33.74,Chinese,,0,0,0,,只是一遍又一遍地执行，一遍又一遍地执行，为谁知道多久
Dialogue: 0,1:12:35.14,1:12:38.72,English,,0,0,0,,Okay so that's not a good solution alright
Dialogue: 0,1:12:35.14,1:12:38.72,Chinese,,0,0,0,,好的，这不是一个好的解决方案
Dialogue: 0,1:12:38.80,1:12:41.86,English,,0,0,0,,So let's look at a couple other things we might consider
Dialogue: 0,1:12:38.80,1:12:41.86,Chinese,,0,0,0,,那么让我们来看看我们可能会考虑的其他一些事情
Dialogue: 0,1:12:42.64,1:12:46.30,English,,0,0,0,,And that have been considered by generations of 213 students
Dialogue: 0,1:12:42.64,1:12:46.30,Chinese,,0,0,0,,213名学生已经考虑过这一点
Dialogue: 0,1:12:49.70,1:12:54.92,English,,0,0,0,,So one thing you might think well I'll just instead of just putting a semicolon here
Dialogue: 0,1:12:49.70,1:12:54.92,Chinese,,0,0,0,,所以有一点你可能会认为我只是在这里而不是只添加一个分号
Dialogue: 0,1:12:55.50,1:12:56.62,English,,0,0,0,,I'll pause
Dialogue: 0,1:12:55.50,1:12:56.62,Chinese,,0,0,0,,我会停下来
Dialogue: 0,1:12:58.56,1:13:02.06,English,,0,0,0,,And then I'll wait for the sigchild handler to run
Dialogue: 0,1:12:58.56,1:13:02.06,Chinese,,0,0,0,,然后我会等待sigchild处理程序运行
Dialogue: 0,1:13:03.44,1:13:05.34,English,,0,0,0,,And then I'll go back up and I'll check
Dialogue: 0,1:13:03.44,1:13:05.34,Chinese,,0,0,0,,然后我会回去，我会检查
Dialogue: 0,1:13:06.26,1:13:07.44,English,,0,0,0,,I'll check pid again
Dialogue: 0,1:13:06.26,1:13:07.44,Chinese,,0,0,0,,我会再检查一下pid
Dialogue: 0,1:13:08.80,1:13:11.64,English,,0,0,0,,Now you have to put this in a loop it still has to be in a loop
Dialogue: 0,1:13:08.80,1:13:11.64,Chinese,,0,0,0,,现在你必须把它放在循环中它仍然必须在循环中
Dialogue: 0,1:13:12.56,1:13:16.72,English,,0,0,0,,Because we have other signal handlers in our program we have a sigint handler
Dialogue: 0,1:13:12.56,1:13:16.72,Chinese,,0,0,0,,因为我们的程序中有其他信号处理程序，所以我们有一个sigint处理程序
Dialogue: 0,1:13:17.72,1:13:22.50,English,,0,0,0,,So it might be if we do the pause here and this again comes in and say get sigint handler runs
Dialogue: 0,1:13:17.72,1:13:22.50,Chinese,,0,0,0,,所以可能是我们在这里做暂停，然后又进来并说让sigint处理程序运行
Dialogue: 0,1:13:24.02,1:13:27.14,English,,0,0,0,,That would cause us to exit the pause function and go back up
Dialogue: 0,1:13:24.02,1:13:27.14,Chinese,,0,0,0,,这将导致我们退出暂停功能并重新启动
Dialogue: 0,1:13:27.36,1:13:29.80,English,,0,0,0,,So we have to keep checking pid because we're not sure
Dialogue: 0,1:13:27.36,1:13:29.80,Chinese,,0,0,0,,所以我们必须继续检查pid因为我们不确定
Dialogue: 0,1:13:30.66,1:13:37.66,English,,0,0,0,,We have to keep checking for the specific signal handler sigchild handler to run instead of other handlers that might run
Dialogue: 0,1:13:30.66,1:13:37.66,Chinese,,0,0,0,,我们必须继续检查特定的信号处理程序sigchld处理程序，而不是可能运行的其他处理程序
Dialogue: 0,1:13:39.32,1:13:41.28,English,,0,0,0,,But this is actually wrong
Dialogue: 0,1:13:39.32,1:13:41.28,Chinese,,0,0,0,,但这实际上是错误的
Dialogue: 0,1:13:44.36,1:13:47.74,English,,0,0,0,,Because it has a race can you see what the race is
Dialogue: 0,1:13:44.36,1:13:47.74,Chinese,,0,0,0,,因为它有比赛你能看到比赛是什么
Dialogue: 0,1:13:54.54,1:13:58.62,English,,0,0,0,,What's wrong with this there's a good chance that this thing will block forever
Dialogue: 0,1:13:54.54,1:13:58.62,Chinese,,0,0,0,,这有什么不对，这件事很有可能永远阻止
Dialogue: 0,1:14:03.50,1:14:15.92,English,,0,0,0,,Yes
Dialogue: 0,1:14:03.50,1:14:15.92,Chinese,,0,0,0,,是
Dialogue: 0,1:14:16.06,1:14:20.46,English,,0,0,0,,Yeah that's so the problem with this is like
Dialogue: 0,1:14:16.06,1:14:20.46,Chinese,,0,0,0,,是的，这就是问题所在
Dialogue: 0,1:14:20.90,1:14:26.12,English,,0,0,0,,So if the signal is received after pid is checked
Dialogue: 0,1:14:20.90,1:14:26.12,Chinese,,0,0,0,,因此，如果在检查pid后收到信号
Dialogue: 0,1:14:27.00,1:14:28.66,English,,0,0,0,,But before the pause executes
Dialogue: 0,1:14:27.00,1:14:28.66,Chinese,,0,0,0,,但在暂停执行之前
Dialogue: 0,1:14:29.54,1:14:31.82,English,,0,0,0,,Okay which is possible right
Dialogue: 0,1:14:29.54,1:14:31.82,Chinese,,0,0,0,,好的，这是正确的
Dialogue: 0,1:14:33.14,1:14:35.76,English,,0,0,0,,It's unlikely but it's possible
Dialogue: 0,1:14:33.14,1:14:35.76,Chinese,,0,0,0,,这不太可能但是有可能
Dialogue: 0,1:14:37.54,1:14:41.52,English,,0,0,0,,If that signal is arrives here
Dialogue: 0,1:14:37.54,1:14:41.52,Chinese,,0,0,0,,如果那个信号到达这里
Dialogue: 0,1:14:42.62,1:14:45.36,English,,0,0,0,,Then the handler will set pid to nonzero and
Dialogue: 0,1:14:42.62,1:14:45.36,Chinese,,0,0,0,,然后处理程序将pid设置为非零和
Dialogue: 0,1:14:46.08,1:14:47.82,English,,0,0,0,,Then we'll execute the pause
Dialogue: 0,1:14:46.08,1:14:47.82,Chinese,,0,0,0,,然后我们将执行暂停
Dialogue: 0,1:14:49.00,1:14:53.32,English,,0,0,0,,And the pause will be blocked forever waiting for a signal that will never arrive right
Dialogue: 0,1:14:49.00,1:14:53.32,Chinese,,0,0,0,,暂停将永远被阻止等待一个永远不会到达的信号
Dialogue: 0,1:14:53.84,1:14:56.14,English,,0,0,0,,Because the sigchild signal already already came
Dialogue: 0,1:14:53.84,1:14:56.14,Chinese,,0,0,0,,因为sigchld信号已经来了
Dialogue: 0,1:14:57.56,1:14:58.80,English,,0,0,0,,Very subtle right
Dialogue: 0,1:14:57.56,1:14:58.80,Chinese,,0,0,0,,非常微妙的权利
Dialogue: 0,1:15:00.28,1:15:03.42,English,,0,0,0,,So this code looks okay it looks benign but it's wrong
Dialogue: 0,1:15:00.28,1:15:03.42,Chinese,,0,0,0,,所以这段代码看起来不错，看起来很温和，但这是错误的
Dialogue: 0,1:15:04.46,1:15:08.48,English,,0,0,0,,And your program would just hang forever
Dialogue: 0,1:15:04.46,1:15:08.48,Chinese,,0,0,0,,而你的程序将永远挂起
Dialogue: 0,1:15:09.60,1:15:11.26,English,,0,0,0,,So we say well okay that's no good
Dialogue: 0,1:15:09.60,1:15:11.26,Chinese,,0,0,0,,所以我们说好的没关系
Dialogue: 0,1:15:11.80,1:15:16.36,English,,0,0,0,,We could replace the pause with asleep so we could say let's check pid
Dialogue: 0,1:15:11.80,1:15:16.36,Chinese,,0,0,0,,我们可以用睡眠取代暂停，所以我们可以说让我们检查一下pid
Dialogue: 0,1:15:17.26,1:15:22.52,English,,0,0,0,,And then sleep for some predetermined amount of time in this case one second
Dialogue: 0,1:15:17.26,1:15:22.52,Chinese,,0,0,0,,然后在这种情况下睡一段预定的时间一秒钟
Dialogue: 0,1:15:24.68,1:15:26.98,English,,0,0,0,,And then go back up and check pid again
Dialogue: 0,1:15:24.68,1:15:26.98,Chinese,,0,0,0,,然后再回来检查pid
Dialogue: 0,1:15:28.42,1:15:34.00,English,,0,0,0,,So this while this is correct it's way too slow right we're asking the system to wait for a second which is an eternity
Dialogue: 0,1:15:28.42,1:15:34.00,Chinese,,0,0,0,,所以这虽然这是正确的，但它太慢了我们要求系统等待一秒钟，这是永恒的
Dialogue: 0,1:15:35.10,1:15:40.02,English,,0,0,0,,And there's forms of sleep nanosecond where you can wait instead of units of seconds
Dialogue: 0,1:15:35.10,1:15:40.02,Chinese,,0,0,0,,还有睡眠纳秒的形式，你可以等待而不是几秒钟
Dialogue: 0,1:15:40.02,1:15:41.76,English,,0,0,0,,You can wait in units of nanoseconds
Dialogue: 0,1:15:40.02,1:15:41.76,Chinese,,0,0,0,,你可以以纳秒为单位等待
Dialogue: 0,1:15:42.26,1:15:44.32,English,,0,0,0,,But that what value do you use right
Dialogue: 0,1:15:42.26,1:15:44.32,Chinese,,0,0,0,,但是，你使用什么价值吧
Dialogue: 0,1:15:45.16,1:15:51.48,English,,0,0,0,,If it's it that so that's if you choose a value that's too large then you have this problem the slowness problem
Dialogue: 0,1:15:45.16,1:15:51.48,Chinese,,0,0,0,,如果它就是这样那么如果你选择一个太大的值那么你就会遇到这个问题慢的问题
Dialogue: 0,1:15:51.82,1:15:54.90,English,,0,0,0,,If you choose a sleep time that's too small
Dialogue: 0,1:15:51.82,1:15:54.90,Chinese,,0,0,0,,如果你选择一个太小的睡眠时间
Dialogue: 0,1:15:55.30,1:15:57.64,English,,0,0,0,,Then you have the other problem that it's inefficient
Dialogue: 0,1:15:55.30,1:15:57.64,Chinese,,0,0,0,,然后你有另一个问题，那就是效率低下
Dialogue: 0,1:15:59.20,1:16:01.14,English,,0,0,0,,So the solution is to use sigsuspend
Dialogue: 0,1:15:59.20,1:16:01.14,Chinese,,0,0,0,,所以解决方案是使用sigsuspend
Dialogue: 0,1:16:03.04,1:16:05.70,English,,0,0,0,,Which is the last thing we're going to look at today
Dialogue: 0,1:16:03.04,1:16:05.70,Chinese,,0,0,0,,这是我们今天要看的最后一件事
Dialogue: 0,1:16:06.84,1:16:11.58,English,,0,0,0,,So sigsuspend is a function that takes a signal mask
Dialogue: 0,1:16:06.84,1:16:11.58,Chinese,,0,0,0,,所以sigsuspend是一个采用信号掩码的函数
Dialogue: 0,1:16:12.94,1:16:17.64,English,,0,0,0,,And it's equivalent to an uninterruptible version of these three statements
Dialogue: 0,1:16:12.94,1:16:17.64,Chinese,,0,0,0,,它相当于这三个陈述的不间断版本
Dialogue: 0,1:16:18.88,1:16:23.40,English,,0,0,0,,So we block the signals that are specified in the signal mask
Dialogue: 0,1:16:18.88,1:16:23.40,Chinese,,0,0,0,,因此，我们阻止信号掩码中指定的信号
Dialogue: 0,1:16:25.18,1:16:27.46,English,,0,0,0,,And then it's atomic in the sense that
Dialogue: 0,1:16:25.18,1:16:27.46,Chinese,,0,0,0,,然后它在某种意义上是原子的
Dialogue: 0,1:16:30.28,1:16:36.22,English,,0,0,0,,After that this these two statements can't be interrupted they're always executed together
Dialogue: 0,1:16:30.28,1:16:36.22,Chinese,,0,0,0,,在此之后，这两个语句不能被中断，它们总是一起执行
Dialogue: 0,1:16:37.28,1:16:39.34,English,,0,0,0,,Okay so we blocked these signals
Dialogue: 0,1:16:37.28,1:16:39.34,Chinese,,0,0,0,,好的，我们阻止了这些信号
Dialogue: 0,1:16:40.34,1:16:41.84,English,,0,0,0,,And then we execute the pause
Dialogue: 0,1:16:40.34,1:16:41.84,Chinese,,0,0,0,,然后我们执行暂停
Dialogue: 0,1:16:44.08,1:16:45.30,English,,0,0,0,,Okay so there's no chance
Dialogue: 0,1:16:44.08,1:16:45.30,Chinese,,0,0,0,,好的，所以没有机会
Dialogue: 0,1:16:46.18,1:16:51.60,English,,0,0,0,,Of a signal interrupting this program in between the sigprocmask and the pause
Dialogue: 0,1:16:46.18,1:16:51.60,Chinese,,0,0,0,,在sigprocmask和暂停之间中断该程序的信号
Dialogue: 0,1:16:54.58,1:16:58.74,English,,0,0,0,,Okay and then when a signal does come in and
Dialogue: 0,1:16:54.58,1:16:58.74,Chinese,,0,0,0,,好的，然后当信号进来时
Dialogue: 0,1:17:00.28,1:17:05.80,English,,0,0,0,,The execution of the handle or causes pause to exit then we set the mask back to what it was before
Dialogue: 0,1:17:00.28,1:17:05.80,Chinese,,0,0,0,,执行句柄或导致暂停退出然后我们将掩码设置回原来的状态
Dialogue: 0,1:17:08.34,1:17:10.82,English,,0,0,0,,Okay so the proper way then to wait for a signal
Dialogue: 0,1:17:08.34,1:17:10.82,Chinese,,0,0,0,,好的，那么等待信号的正确方法
Dialogue: 0,1:17:11.74,1:17:13.88,English,,0,0,0,,Is to use sigsuspend in the following way
Dialogue: 0,1:17:11.74,1:17:13.88,Chinese,,0,0,0,,是以下列方式使用sigsuspend
Dialogue: 0,1:17:14.82,1:17:16.52,English,,0,0,0,,So here's our here's our program again
Dialogue: 0,1:17:14.82,1:17:16.52,Chinese,,0,0,0,,所以这是我们这里的程序
Dialogue: 0,1:17:17.82,1:17:20.80,English,,0,0,0,,We before we create the child we block sigchild
Dialogue: 0,1:17:17.82,1:17:20.80,Chinese,,0,0,0,,在我们创建孩子之前，我们阻止了sigchld
Dialogue: 0,1:17:21.54,1:17:22.78,English,,0,0,0,,Then we create the child
Dialogue: 0,1:17:21.54,1:17:22.78,Chinese,,0,0,0,,然后我们创造了孩子
Dialogue: 0,1:17:23.96,1:17:26.42,English,,0,0,0,,And now we're going to wait for the sigchild to be received
Dialogue: 0,1:17:23.96,1:17:26.42,Chinese,,0,0,0,,现在我们要等待收到sigchild
Dialogue: 0,1:17:27.72,1:17:29.48,English,,0,0,0,,Now sigchild is still blocked
Dialogue: 0,1:17:27.72,1:17:29.48,Chinese,,0,0,0,,现在sigchild仍被阻止
Dialogue: 0,1:17:30.26,1:17:34.90,English,,0,0,0,,Okay so there's no danger of the sigchild handler running
Dialogue: 0,1:17:30.26,1:17:34.90,Chinese,,0,0,0,,好的，所以没有sigchld处理程序运行的危险
Dialogue: 0,1:17:35.42,1:17:38.26,English,,0,0,0,,Okay so we set that global variable to zero
Dialogue: 0,1:17:35.42,1:17:38.26,Chinese,,0,0,0,,好的，我们将全局变量设置为零
Dialogue: 0,1:17:39.74,1:17:44.52,English,,0,0,0,,And then while it's while it's nonzero we repeatedly call sigsuspend
Dialogue: 0,1:17:39.74,1:17:44.52,Chinese,,0,0,0,,然后，虽然它是非零的，但我们反复调用sigsuspend
Dialogue: 0,1:17:46.22,1:17:48.48,English,,0,0,0,,And sigsuspend is using the previous mask
Dialogue: 0,1:17:46.22,1:17:48.48,Chinese,,0,0,0,,并且sigsuspend使用以前的面具
Dialogue: 0,1:17:49.02,1:17:51.76,English,,0,0,0,,That was set up here so sigsuspend is using the mask
Dialogue: 0,1:17:49.02,1:17:51.76,Chinese,,0,0,0,,这是在这里设置的，所以sigsuspend正在使用面具
Dialogue: 0,1:17:52.50,1:17:54.53,English,,0,0,0,,Where sigchild is unblocked
Dialogue: 0,1:17:52.50,1:17:54.53,Chinese,,0,0,0,,sigchld未被阻止的地方
Dialogue: 0,1:17:55.42,1:18:01.48,English,,0,0,0,,Okay when we entered this first sigprocmask,sigchild was unblocked
Dialogue: 0,1:17:55.42,1:18:01.48,Chinese,,0,0,0,,好的，当我们输入第一个sigprocmask时，sigchild被解除阻塞
Dialogue: 0,1:18:03.32,1:18:08.70,English,,0,0,0,,So this allows inside the sigsuspend sigchild is unblocked
Dialogue: 0,1:18:03.32,1:18:08.70,Chinese,,0,0,0,,所以这允许sigsuspend sigchld内部被解锁
Dialogue: 0,1:18:09.80,1:18:15.42,English,,0,0,0,,Okay so it allows for the handler now to be received or to be executed
Dialogue: 0,1:18:09.80,1:18:15.42,Chinese,,0,0,0,,好的，它允许现在接收或执行处理程序
Dialogue: 0,1:18:17.16,1:18:21.20,English,,0,0,0,,Okay so in and it does it safely because of the...
Dialogue: 0,1:18:17.16,1:18:21.20,Chinese,,0,0,0,,好的，因为......
Dialogue: 0,1:18:21.72,1:18:24.84,English,,0,0,0,, The atomic nature of those those first two instructions
Dialogue: 0,1:18:21.72,1:18:24.84,Chinese,,0,0,0,,那些前两个指令的原子性质
Dialogue: 0,1:18:27.44,1:18:33.16,English,,0,0,0,,So once the so it's possible that implicit pause inside of sigchild
Dialogue: 0,1:18:27.44,1:18:33.16,Chinese,,0,0,0,,所以一旦这样，sigchld内部的隐式暂停就有可能
Dialogue: 0,1:18:33.16,1:18:37.02,English,,0,0,0,,Could be interrupted by say another signal like sigint
Dialogue: 0,1:18:33.16,1:18:37.02,Chinese,,0,0,0,,可以通过说出像sigint这样的另一个信号来打断
Dialogue: 0,1:18:38.28,1:18:42.60,English,,0,0,0,,Okay in which case we'd loop back up we notice that pid was still zero
Dialogue: 0,1:18:38.28,1:18:42.60,Chinese,,0,0,0,,好吧，在这种情况下，我们会重新启动，我们注意到pid仍为零
Dialogue: 0,1:18:42.96,1:18:47.18,English,,0,0,0,,And we go back into sigsuspend with sigchild unblocked
Dialogue: 0,1:18:42.96,1:18:47.18,Chinese,,0,0,0,,我们回到sigsuspend与sigchild畅通无阻
Dialogue: 0,1:18:47.56,1:18:50.16,English,,0,0,0,,Okay so that makes sense to everybody
Dialogue: 0,1:18:47.56,1:18:50.16,Chinese,,0,0,0,,好的，这对每个人都有意义
Dialogue: 0,1:18:50.16,1:18:55.42,English,,0,0,0,,And now so this is exactly the behavior we want where we're not wasting resources but we've eliminated the race
Dialogue: 0,1:18:50.16,1:18:55.42,Chinese,,0,0,0,,而现在这正是我们想要的行为，我们不会浪费资源，但我们已经取消了比赛
Dialogue: 0,1:18:59.28,1:19:04.44,English,,0,0,0,,Okay so that's it for today if you're interested nonlocal jumps are this weird thing in C
Dialogue: 0,1:18:59.28,1:19:04.44,Chinese,,0,0,0,,好的，所以今天如果你对非本地跳跃感兴趣，这就是C中的这个奇怪的事情
Dialogue: 0,1:19:04.94,1:19:08.92,English,,0,0,0,,That allows a function to return to some other function that didn't call it
Dialogue: 0,1:19:04.94,1:19:08.92,Chinese,,0,0,0,,这允许函数返回到其他没有调用它的函数
Dialogue: 0,1:19:11.14,1:19:17.37,English,,0,0,0,,Okay but it's described in your textbook and also in some additional slides here if you if you're interested
Dialogue: 0,1:19:11.14,1:19:17.37,Chinese,,0,0,0,,好的，但如果你感兴趣的话，它会在你的教科书中以及其他一些幻灯片中进行描述
