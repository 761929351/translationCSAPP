[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video File: ../../../Desktop/csapp/Lecture 09  Machine Level Programming V  Advanced Topics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 843
Active Line: 849
Video Position: 141524

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:04.82,csapp,,0,0,0,,this come this will be the last lecture on machine level programming
Dialogue: 0,0:00:05.42,0:00:09.94,csapp,,0,0,0,, we call it advanced topics but think of it more as miscellaneous topics
Dialogue: 0,0:00:10.70,0:00:16.00,csapp,,0,0,0,,and I think most to you of course you know that your bomb webs are due tonight
Dialogue: 0,0:00:16.00,0:00:20.72,csapp,,0,0,0,,so you most year probably well into that or hopefully through it
Dialogue: 0,0:00:21.08,0:00:26.44,csapp,,0,0,0,,and then at midnight tonight the next web will come out which is called a tack lab
Dialogue: 0,0:00:26.96,0:00:28.98,csapp,,0,0,0,,and there is a recitation about that yesterday
Dialogue: 0,0:00:28.98,0:00:32.90,csapp,,0,0,0,,but this is a lab that's  a new to the course
Dialogue: 0,0:00:33.36,0:00:37.50,csapp,,0,0,0,, it's a similar to one that we used to use at this point in the course
Dialogue: 0,0:00:37.64,0:00:41.60,csapp,,0,0,0,,but it's been updated and changed in significant ways
Dialogue: 0,0:00:41.70,0:00:49.88,csapp,,0,0,0,,so we're actually when you have labs like we do in this course with this many students
Dialogue: 0,0:00:49.88,0:00:51.90,csapp,,0,0,0,,there's a lot of things that go can go wrong
Dialogue: 0,0:00:51.90,0:00:55.96,csapp,,0,0,0,,so we're going to keep a close eye on on how things are going
Dialogue: 0,0:00:55.96,0:00:59.70,csapp,,0,0,0,, but I'd encourage you you only have a week and a half to do this next lab
Dialogue: 0,0:01:00.10,0:01:05.10,csapp,,0,0,0,, to get started soon and partly by having some people start sooner
Dialogue: 0,0:01:05.10,0:01:07.88,csapp,,0,0,0,,you'll start breaking things for us that we can track down
Dialogue: 0,0:01:09.56,0:01:16.94,csapp,,0,0,0,,so today what we'll talk about is a couple like I said it's miscellaneous topics but important topics
Dialogue: 0,0:01:17.00,0:01:21.92,csapp,,0,0,0,,one is just sort of where what does the memory look like ah
Dialogue: 0,0:01:21.92,0:01:25.52,csapp,,0,0,0,,when you're running x86-64 programs
Dialogue: 0,0:01:26.00,0:01:31.34,csapp,,0,0,0,,the other is a very important topic on security vulnerability called buffer overflows
Dialogue: 0,0:01:31.86,0:01:37.44,csapp,,0,0,0,,and in fact at a collab will be precisely exploiting those security vulnerabilities
Dialogue: 0,0:01:37.96,0:01:43.02,csapp,,0,0,0,,and then we'll look at unions so far you've booked it arrays and structs and how they're organized
Dialogue: 0,0:01:43.72,0:01:45.90,csapp,,0,0,0,,and I want to compare that to unions
Dialogue: 0,0:01:47.88,0:01:53.82,csapp,,0,0,0,,so let's talk about memory  then as I said at the beginning early in the course
Dialogue: 0,0:01:54.26,0:01:57.68,csapp,,0,0,0,,conceptually a memory is just a big array of bytes
Dialogue: 0,0:01:58.46,0:02:03.44,csapp,,0,0,0,,and that's the view of this the machine level programmer
Dialogue: 0,0:02:03.72,0:02:05.70,csapp,,0,0,0,,even though it's not the actual implementation
Dialogue: 0,0:02:05.70,0:02:08.70,csapp,,0,0,0,,there's a whole part that we'll talk about later in the course
Dialogue: 0,0:02:09.58,0:02:11.84,csapp,,0,0,0,, of this is called virtual memory
Dialogue: 0,0:02:12.92,0:02:16.14,csapp,,0,0,0,,this organization is very simple organization
Dialogue: 0,0:02:16.60,0:02:20.28,csapp,,0,0,0,,but the underlying implementation is this complex management of
Dialogue: 0,0:02:20.88,0:02:27.52,csapp,,0,0,0,,various different memory types from disk memories to solid state disks
Dialogue: 0,0:02:28.00,0:02:32.60,csapp,,0,0,0,,and to what's called DRAM which stands for dynamic Ram the
Dialogue: 0,0:02:32.80,0:02:35.88,csapp,,0,0,0,,when you buy memory for your processor its DRAM
Dialogue: 0,0:02:36.98,0:02:43.96,csapp,,0,0,0,, um so as you know in x86-64 we're working with machines that nominally are
Dialogue: 0,0:02:44.78,0:02:48.27,csapp,,0,0,0,,have addresses can be up to 64 bits long
Dialogue: 0,0:02:48.66,0:02:52.22,csapp,,0,0,0,,and if you work out the numbers remember I told you at the beginning of the course
Dialogue: 0,0:02:52.22,0:03:00.28,csapp,,0,0,0,,you can estimate how big a number like to the 64 is  by remembering that 1024
Dialogue: 0,0:03:00.82,0:03:03.22,csapp,,0,0,0,,and a thousand are very close to each other
Dialogue: 0,0:03:03.22,0:03:07.66,csapp,,0,0,0,,so 2^10 is roughly the same as 10^3
Dialogue: 0,0:03:08.52,0:03:11.48,csapp,,0,0,0,,so you take 64 and you.thank 60
Dialogue: 0,0:03:11.48,0:03:15.78,csapp,,0,0,0,,so how big is two to the sixty well that's six times ten
Dialogue: 0,0:03:17.44,0:03:21.04,csapp,,0,0,0,,and therefore it's six times three it's like ten to the eighteenth
Dialogue: 0,0:03:22.28,0:03:27.00,csapp,,0,0,0,,and then you add the four to that that's two to the fourth and 16
Dialogue: 0,0:03:27.00,0:03:30.58,csapp,,0,0,0,,so it's around 16 times 10 to the 18th fights
Dialogue: 0,0:03:31.64,0:03:40.26,csapp,,0,0,0,,so if you were to go off and look online on Amazon for DRAM chips
Dialogue: 0,0:03:40.26,0:03:44.74,csapp,,0,0,0,,and try to buy that much memory you'd find you're spending a lot of money
Dialogue: 0,0:03:45.66,0:03:52.60,csapp,,0,0,0,,more than you I don't know the numbers but it would be a lot of memory money
Dialogue: 0,0:03:53.06,0:03:55.16,csapp,,0,0,0,,and so you basically can't do it nowadays
Dialogue: 0,0:03:56.12,0:04:00.48,csapp,,0,0,0,,tend to the and so
Dialogue: 0,0:04:02.28,0:04:09.72,csapp,,0,0,0,,right now the machines limit you to actually only 47 bits worth of address  in the address space
Dialogue: 0,0:04:10.54,0:04:19.28,csapp,,0,0,0,,I'll and so 2 to the 47th again work that out that's like 10 to the 12th times 256 times 10 to the 12th
Dialogue: 0,0:04:19.28,0:04:21.82,csapp,,0,0,0,,so it's 256 terabytes
Dialogue: 0,0:04:23.16,0:04:26.86,csapp,,0,0,0,,and as you know you can buy a disk drive now that has 8 air bites
Dialogue: 0,0:04:26.86,0:04:28.36,csapp,,0,0,0,,so it doesn't seem like that much
Dialogue: 0,0:04:28.36,0:04:37.54,csapp,,0,0,0,,but if you tried to buy that much DRAM again you'd have to have a pretty big credit-card limit
Dialogue: 0,0:04:38.12,0:04:45.70,csapp,,0,0,0,, and so even that's a huge number and modern super computer installations actually will have  almost that much memory
Dialogue: 0,0:04:45.70,0:04:51.76,csapp,,0,0,0,, but the point is that the hardware of today limits you to 47 bits worth of address
Dialogue: 0,0:04:52.56,0:04:58.18,csapp,,0,0,0,,but that's not really a real limitation in terms of of of actual machines
Dialogue: 0,0:04:58.32,0:05:03.12,csapp,,0,0,0,,and what will happen is memory prices get cheaper and the technology gets better
Dialogue: 0,0:05:03.46,0:05:08.10,csapp,,0,0,0,,they'll slowly start adding as succeeding generations of processors come along
Dialogue: 0,0:05:08.78,0:05:11.62,csapp,,0,0,0,,let you have bigger and bigger range of addresses
Dialogue: 0,0:05:12.52,0:05:17.30,csapp,,0,0,0,, so all that is to say that's why
Dialogue: 0,0:05:19.58,0:05:23.84,csapp,,0,0,0,,this number shows up which is a seven	 followed by eleven FS
Dialogue: 0,0:05:27.76,0:05:32.68,csapp,,0,0,0,,I can tell I need to scribble some numbers you guys
Dialogue: 0,0:05:32.68,0:05:35.56,csapp,,0,0,0,,aren't just saying numbers in the air is not working here
Dialogue: 0,0:05:36.88,0:05:49.88,csapp,,0,0,0,,so let's try
Dialogue: 0,0:05:50.20,0:05:53.96,csapp,,0,0,0,,ok
Dialogue: 0,0:05:55.32,0:06:06.21,csapp,,0,0,0,,okay so remember I said before to 264 is about equal to 16 times 10 to the 18th
Dialogue: 0,0:06:09.20,0:06:17.82,csapp,,0,0,0,,and 2 to the 47th is 128 times 10 to the 12th
Dialogue: 0,0:06:19.24,0:06:21.14,csapp,,0,0,0,,so it's 128 terabytes
Dialogue: 0,0:06:29.26,0:06:33.56,csapp,,0,0,0,,so what's the number after a terabyte you know 10 to the 15th
Dialogue: 0,0:06:36.78,0:06:40.74,csapp,,0,0,0,,how many but yes petabytes right
Dialogue: 0,0:06:44.82,0:06:48.58,csapp,,0,0,0,,and you know what 10v 18th is exha
Dialogue: 0,0:06:53.40,0:07:00.02,csapp,,0,0,0,,so just as a reference a company like Google roughly
Dialogue: 0,0:07:00.46,0:07:04.10,csapp,,0,0,0,,it's probably it's total storage across the whole
Dialogue: 0,0:07:04.90,0:07:08.70,csapp,,0,0,0,,enterprise is measured in some small number of X bytes
Dialogue: 0,0:07:09.80,0:07:18.00,csapp,,0,0,0,,and it every day is getting several petabytes I don't know the numbers are of course secret
Dialogue: 0,0:07:18.04,0:07:25.52,csapp,,0,0,0,,but maybe 10 petabytes or more per day of new data that it's ingesting into its system so
Dialogue: 0,0:07:26.02,0:07:30.54,csapp,,0,0,0,,these numbers are pretty huge but not just totally off the charts
Dialogue: 0,0:07:30.54,0:07:39.20,csapp,,0,0,0,,do you know what 10 to the 21st is it's called a zettabyte  with two T's
Dialogue: 0,0:07:41.54,0:07:45.90,csapp,,0,0,0,,and it's estimated if you add up all the digital content in the world
Dialogue: 0,0:07:45.90,0:07:49.90,csapp,,0,0,0,, that gets created everybody's cell phone camera every video
Dialogue: 0,0:07:50.40,0:07:55.92,csapp,,0,0,0,,taken by anyone anywhere  all year long is a couple of zettabytes a year
Dialogue: 0,0:07:55.96,0:08:02.30,csapp,,0,0,0,, so it'll be a while before we're really having to deal with that kind of memory
Dialogue: 0,0:08:03.18,0:08:10.36,csapp,,0,0,0,,so just just to give you an idea so 128 terabytes is the address limit on these systems
Dialogue: 0,0:08:10.70,0:08:17.52,csapp,,0,0,0,,and so that's why you have to have seven because you remember that's one two three
Dialogue: 0,0:08:18.22,0:08:26.10,csapp,,0,0,0,,and then there's F but there's 11 of them and this is one one one times 11
Dialogue: 0,0:08:26.10,0:08:31.32,csapp,,0,0,0,,so that's 44 ones and this is three ones
Dialogue: 0,0:08:33.44,0:08:36.44,csapp,,0,0,0,,and that's where you get 47
Dialogue: 0,0:08:37.58,0:08:41.86,csapp,,0,0,0,,and that's the address of the in Linux
Dialogue: 0,0:08:42.32,0:08:46.94,csapp,,0,0,0,,that's where they put the stack  is up at the very top of the address space
Dialogue: 0,0:08:47.14,0:08:53.58,csapp,,0,0,0,,and I should tell you this picture is not at all to scale it would be impossible to draw this picture to scale
Dialogue: 0,0:08:54.30,0:08:59.10,csapp,,0,0,0,, for example it shows that the stack starts way up at the top
Dialogue: 0,0:08:59.10,0:09:05.86,csapp,,0,0,0,,and remember stacks grow to smaller addresses when you're pushing and also we show the
Dialogue: 0,0:09:06.30,0:09:09.54,csapp,,0,0,0,,them upside down just to make everything confusing
Dialogue: 0,0:09:10.08,0:09:17.01,csapp,,0,0,0,,so the the stack starts there and it grows towards lower addresses
Dialogue: 0,0:09:17.32,0:09:20.50,csapp,,0,0,0,,and on a typical system it will be limited to 8 megabytes
Dialogue: 0,0:09:20.78,0:09:23.98,csapp,,0,0,0,,and you can tell that on a Linux system at least
Dialogue: 0,0:09:25.38,0:09:28.78,csapp,,0,0,0,, with the the limit command
Dialogue: 0,0:09:30.06,0:09:38.30,csapp,,0,0,0,,which used to be more interesting than it was is now because a lot of things are unlimited
Dialogue: 0,0:09:38.76,0:09:43.76,csapp,,0,0,0,, but you see it says the stack size is limited to 8192 K bytes or kilobytes
Dialogue: 0,0:09:43.76,0:09:46.12,csapp,,0,0,0,,so it's 8 megabytes
Dialogue: 0,0:09:49.96,0:10:00.77,csapp,,0,0,0,,and what that means is if you tried to access any memory  via the stack pointer
Dialogue: 0,0:10:01.60,0:10:09.10,csapp,,0,0,0,,that was outside of the range of this 8 megabyte range you'd get a segmentation fault
Dialogue: 0,0:10:10.40,0:10:17.74,csapp,,0,0,0,,and then down at the lower addresses what comes in what gets put into your program are the parts of the code
Dialogue: 0,0:10:17.74,0:10:20.60,csapp,,0,0,0,,that that come out of the executable file
Dialogue: 0,0:10:20.94,0:10:25.10,csapp,,0,0,0,,and so there's a section and we'll talk more when we talk about linking actually
Dialogue: 0,0:10:25.10,0:10:28.36,csapp,,0,0,0,,about the way out of the memory and the different regions of it
Dialogue: 0,0:10:28.82,0:10:36.80,csapp,,0,0,0,,but for some obscure reason they they call where the code is sitting the executable program  the text segment
Dialogue: 0,0:10:36.81,0:10:41.90,csapp,,0,0,0,,I don't know why that's true but it's the way it is and that's across many machines
Dialogue: 0,0:10:42.30,0:10:49.89,csapp,,0,0,0,,and then the data is first of all there'll be a section for the data that's allocated at the program begins
Dialogue: 0,0:10:49.89,0:10:55.54,csapp,,0,0,0,,so any global variables that you've declared will be in that section
Dialogue: 0,0:10:56.26,0:11:02.86,csapp,,0,0,0,,and then the heap is the part of memory that is X is allocated via call to malloc
Dialogue: 0,0:11:02.86,0:11:05.04,csapp,,0,0,0,, or one of its related functions
Dialogue: 0,0:11:05.06,0:11:08.16,csapp,,0,0,0,, and so that varies dynamically as the program runs
Dialogue: 0,0:11:08.72,0:11:13.30,csapp,,0,0,0,,it starts off with a very small allocation and every time you call malloc
Dialogue: 0,0:11:14.08,0:11:19.96,csapp,,0,0,0,,if you're not freeing memory and so your memory requirements keep growing
Dialogue: 0,0:11:20.20,0:11:25.68,csapp,,0,0,0,,it will crease keep up moving up larger and larger addresses
Dialogue: 0,0:11:26.16,0:11:30.18,csapp,,0,0,0,,and then somewhere in the code - and this can vary by system is
Dialogue: 0,0:11:30.50,0:11:37.76,csapp,,0,0,0,,the code that gets brought in that represents the library functions things like printf and malloc itself
Dialogue: 0,0:11:38.28,0:11:40.98,csapp,,0,0,0,,our own library code they're stored off on disk
Dialogue: 0,0:11:40.98,0:11:44.32,csapp,,0,0,0,,and they get brought in they get linked into your program
Dialogue: 0,0:11:44.32,0:11:48.16,csapp,,0,0,0,,when it first starts executing by a process known as dynamic linking
Dialogue: 0,0:11:48.32,0:11:51.74,csapp,,0,0,0,,which we'll talk about later in the course too with the linking
Dialogue: 0,0:11:52.38,0:11:55.01,csapp,,0,0,0,,and what you'll find in general is that
Dialogue: 0,0:11:55.30,0:11:59.02,csapp,,0,0,0,,allocations will tend to be either at these very low addresses
Dialogue: 0,0:11:59.38,0:12:03.74,csapp,,0,0,0,,or these very high addresses as your program is running
Dialogue: 0,0:12:06.72,0:12:09.44,csapp,,0,0,0,,so just as an example here is some code
Dialogue: 0,0:12:09.84,0:12:15.08,csapp,,0,0,0,, um that it's only value is to show you different  where things get located
Dialogue: 0,0:12:15.50,0:12:19.50,csapp,,0,0,0,, and so you'll see I allocated some a fairly large arrays here
Dialogue: 0,0:12:19.50,0:12:26.60,csapp,,0,0,0,,this one is there all cares but this is 2 to the 24th so it's 16
Dialogue: 0,0:12:27.20,0:12:31.10,csapp,,0,0,0,,a megabyte array and this one is 2<<31
Dialogue: 0,0:12:31.88,0:12:37.10,csapp,,0,0,0,,so it's 2 gigabytes worth of array
Dialogue: 0,0:12:37.10,0:12:43.84,csapp,,0,0,0,,I found that if I tried to allocate larger ones it the program wouldn't run
Dialogue: 0,0:12:44.82,0:12:51.92,csapp,,0,0,0,,and I also do some here's just a sort of global variable and here's a function
Dialogue: 0,0:12:52.90,0:12:56.94,csapp,,0,0,0,, and then there's a single function here with some local variable
Dialogue: 0,0:12:56.94,0:12:59.60,csapp,,0,0,0,,and that will be allocated somewhere on the stack
Dialogue: 0,0:13:00.38,0:13:05.72,csapp,,0,0,0,,and then there's several calls to milk some of which are for some very small chunks of memory
Dialogue: 0,0:13:06.04,0:13:08.94,csapp,,0,0,0,, and somewhere for some very large chunks of memory
Dialogue: 0,0:13:09.52,0:13:15.87,csapp,,0,0,0,,and so we can run this program and see what addresses pop out of it
Dialogue: 0,0:13:16.34,0:13:19.08,csapp,,0,0,0,,and what you'll see is the stack
Dialogue: 0,0:13:19.48,0:13:24.94,csapp,,0,0,0,, this local variable is somewhere up with an address in the range of the stack
Dialogue: 0,0:13:24.94,0:13:28.44,csapp,,0,0,0,,and you see the 7 and a couple FS and then it goes to something else
Dialogue: 0,0:13:29.40,0:13:35.54,csapp,,0,0,0,,and you'll see also interestingly enough that the code and then looking down at the bottom
Dialogue: 0,0:13:36.60,0:13:42.62,csapp,,0,0,0,,of this yellow color is things get relegated to the text segment the main function
Dialogue: 0,0:13:42.94,0:13:46.50,csapp,,0,0,0,,and this function I called I declared called useless
Dialogue: 0,0:13:47.10,0:13:49.42,csapp,,0,0,0,, and then the predefined arrays
Dialogue: 0,0:13:50.58,0:13:55.16,csapp,,0,0,0,,that were in other words globally declared not declared by malloc
Dialogue: 0,0:13:55.16,0:14:02.18,csapp,,0,0,0,,they're declared as part of the program itself are down here in this data section
Dialogue: 0,0:14:02.75,0:14:08.52,csapp,,0,0,0,, and because it's a very large array, the huge array you actually get some fairly large addresses
Dialogue: 0,0:14:09.26,0:14:11.12,csapp,,0,0,0,,and then interestingly enough
Dialogue: 0,0:14:11.66,0:14:15.56,csapp,,0,0,0,,or I don't know why it's interesting but for one reason or another
Dialogue: 0,0:14:16.46,0:14:22.02,csapp,,0,0,0,,it happen that the smaller chunks of memory allocations
Dialogue: 0,0:14:22.34,0:14:28.74,csapp,,0,0,0,,are down here at addresses that are actually just a little bit above  the the pink section right
Dialogue: 0,0:14:29.06,0:14:32.30,csapp,,0,0,0,, and similarly the really big chunks of memory I a located
Dialogue: 0,0:14:32.48,0:14:38.62,csapp,,0,0,0,,are way up here near the stack limit
Dialogue: 0,0:14:39.28,0:14:43.60,csapp,,0,0,0,,and they are
Dialogue: 0,0:14:43.68,0:14:47.94,csapp,,0,0,0,, and so they're there and in general what's happening is if I were to try and reference
Dialogue: 0,0:14:48.50,0:14:53.07,csapp,,0,0,0,,a memory address in this empty range I'd get a segmentation fault
Dialogue: 0,0:14:53.46,0:14:57.96,csapp,,0,0,0,,it's a valid address in terms of its bit of properties
Dialogue: 0,0:14:57.96,0:15:03.10,csapp,,0,0,0,,but it hasn't actually been set up and allocated by the memory the virtual memory allocator
Dialogue: 0,0:15:03.10,0:15:06.10,csapp,,0,0,0,, so at any given time the valid addresses
Dialogue: 0,0:15:06.46,0:15:12.00,csapp,,0,0,0,, are just those in the lower portion or the upper portion of this address ranges
Dialogue: 0,0:15:12.24,0:15:14.16,csapp,,0,0,0,, and the middle is sort of no-man's land
Dialogue: 0,0:15:14.38,0:15:17.44,csapp,,0,0,0,,and then what happens is you keep allocating more with malloc
Dialogue: 0,0:15:17.86,0:15:22.46,csapp,,0,0,0,,and it will push the limits of what's addressable in toward it
Dialogue: 0,0:15:22.86,0:15:29.46,csapp,,0,0,0,,and in principle if you ever got too much of a memory request
Dialogue: 0,0:15:29.48,0:15:35.26,csapp,,0,0,0,, if these two would hit each other and you and Malik would return zero at that point
Dialogue: 0,0:15:35.64,0:15:43.26,csapp,,0,0,0,,but it's highly unlikely given that you have 128 terabytes of memory address range here
Dialogue: 0,0:15:44.06,0:15:46.94,csapp,,0,0,0,,so that just and you've probably seen this when you're running
Dialogue: 0,0:15:47.48,0:15:50.50,csapp,,0,0,0,,you're looking at disassembled code with gdb
Dialogue: 0,0:15:50.50,0:15:56.76,csapp,,0,0,0,,you're seeing some addresses that are way up here with the 7 and some F so they're stack addresses
Dialogue: 0,0:15:57.20,0:15:58.82,csapp,,0,0,0,,and you see these fours
Dialogue: 0,0:15:59.56,0:16:03.90,csapp,,0,0,0,,you know a lot of zeros and some fours those tend to be where the code is going
Dialogue: 0,0:16:04.32,0:16:09.28,csapp,,0,0,0,,to question
Dialogue: 0,0:16:09.42,0:16:12.34,csapp,,0,0,0,,why doesn't the heat proceed in one direction I actually don't know
Dialogue: 0,0:16:13.04,0:16:18.32,csapp,,0,0,0,, I'll just observe that it was had a strategy of putting big things here in small things here
Dialogue: 0,0:16:18.32,0:16:22.88,csapp,,0,0,0,,and it probably uses different slightly different management strategies for those two
Dialogue: 0,0:16:33.10,0:16:38.74,csapp,,0,0,0,,okay so that I think you'll find that kind of useful to have some sense when you're looking at
Dialogue: 0,0:16:39.20,0:16:42.40,csapp,,0,0,0,,when you're running gdb it helps to just have some idea of
Dialogue: 0,0:16:42.40,0:16:45.20,csapp,,0,0,0,,what's going on when you're looking at these different addresses
Dialogue: 0,0:16:47.36,0:16:50.44,csapp,,0,0,0,,okay now let's talk about buffer overflow
Dialogue: 0,0:16:50.92,0:16:55.34,csapp,,0,0,0,,and we'll start this you remember on the very first class
Dialogue: 0,0:16:55.34,0:16:58.48,csapp,,0,0,0,,and I think we might have reviewed this part way along
Dialogue: 0,0:16:58.80,0:17:04.78,csapp,,0,0,0,,we showed this example of some programs where if you do an out-of-bounds
Dialogue: 0,0:17:06.18,0:17:10.08,csapp,,0,0,0,,reference and write a value that's out of bounds in particular
Dialogue: 0,0:17:10.96,0:17:14.60,csapp,,0,0,0,,I only have a array of two elements here
Dialogue: 0,0:17:15.00,0:17:18.20,csapp,,0,0,0,,but this function will take an arbitrary value of i
Dialogue: 0,0:17:18.54,0:17:23.04,csapp,,0,0,0,,and assign some magic number to ailment i of the array
Dialogue: 0,0:17:24.06,0:17:25.86,csapp,,0,0,0,,and it has the possibility of
Dialogue: 0,0:17:27.88,0:17:30.28,csapp,,0,0,0,,and we saw that when you do that
Dialogue: 0,0:17:30.38,0:17:33.24,csapp,,0,0,0,,if I gets too big it will first
Dialogue: 0,0:17:33.98,0:17:39.12,csapp,,0,0,0,,corrupt the the double that stored is part of the struct
Dialogue: 0,0:17:39.52,0:17:42.42,csapp,,0,0,0,,and then when it gets bigger it seems to
Dialogue: 0,0:17:42.92,0:17:47.16,csapp,,0,0,0,,not have any effect until it gets too big and then you start corrupting memory
Dialogue: 0,0:17:47.74,0:17:54.20,csapp,,0,0,0,,so the basic point is that it's very easy in a program  a C program in particular
Dialogue: 0,0:17:54.56,0:17:59.60,csapp,,0,0,0,, to a reference memory that's not part of the sort of intent of the program
Dialogue: 0,0:18:02.20,0:18:09.50,csapp,,0,0,0,,and this can happen in programs that aren't properly written that
Dialogue: 0,0:18:10.32,0:18:19.66,csapp,,0,0,0,, and it becomes a security vulnerability if there's some way for an outsider to overflow a buffer
Dialogue: 0,0:18:20.24,0:18:25.20,csapp,,0,0,0,, for example if there is some way for an outsider to give a larger value of i and ask that
Dialogue: 0,0:18:25.70,0:18:28.42,csapp,,0,0,0,,that value be stored there it could crash the program
Dialogue: 0,0:18:29.34,0:18:33.98,csapp,,0,0,0,, and so in general when you write in code you try to think about  can I trust this value
Dialogue: 0,0:18:33.98,0:18:39.84,csapp,,0,0,0,,this a value that's been computed by my program and I'm sure that it's within bounds
Dialogue: 0,0:18:40.20,0:18:43.36,csapp,,0,0,0,,or is it something that's come from an external source
Dialogue: 0,0:18:43.36,0:18:48.16,csapp,,0,0,0,,and there is potentially that risk of being a vulnerability
Dialogue: 0,0:18:49.58,0:18:53.22,csapp,,0,0,0,,and so in particular there's a lot a huge class of errors
Dialogue: 0,0:18:53.22,0:18:57.68,csapp,,0,0,0,,that have to do with overflowing buffers where
Dialogue: 0,0:18:58.16,0:19:04.94,csapp,,0,0,0,,where they're trying to store a string of some type that's been read from a message
Dialogue: 0,0:19:05.70,0:19:10.38,csapp,,0,0,0,,and without knowing in advance how big that string is
Dialogue: 0,0:19:10.38,0:19:14.90,csapp,,0,0,0,, it's possible that it will be too big for the buffer that's been allocated
Dialogue: 0,0:19:15.48,0:19:21.72,csapp,,0,0,0,,and so one of the culprits is there's a whole class of library functions that
Dialogue: 0,0:19:22.32,0:19:30.04,csapp,,0,0,0,,let you store something a string somewhere without any kind of bounds checking even being possible
Dialogue: 0,0:19:30.73,0:19:34.70,csapp,,0,0,0,, so the sort of worst one is one called gets
Dialogue: 0,0:19:35.20,0:19:39.58,csapp,,0,0,0,, and the purpose of gets is normally it's used to read a string from
Dialogue: 0,0:19:40.18,0:19:46.00,csapp,,0,0,0,,an input from a terminal input something that somebody's typed into a terminal
Dialogue: 0,0:19:46.38,0:19:50.14,csapp,,0,0,0,,and so what it's doing is it's scanning this input string
Dialogue: 0,0:19:50.46,0:19:54.76,csapp,,0,0,0,,and looking for a character that represents the end of the line
Dialogue: 0,0:19:54.94,0:19:59.14,csapp,,0,0,0,,which we write in of CEA's is backslash n
Dialogue: 0,0:19:59.48,0:20:02.94,csapp,,0,0,0,, and it has a character code at hex of 0 a
Dialogue: 0,0:20:04.58,0:20:11.28,csapp,,0,0,0,,and so gets this is sort of an approximate version of what the code for gets looks like
Dialogue: 0,0:20:11.78,0:20:17.02,csapp,,0,0,0,, that and it's as an argument it's just given a destination of where to store the result
Dialogue: 0,0:20:17.48,0:20:20.76,csapp,,0,0,0,,and all it does is it reads one character at a time
Dialogue: 0,0:20:21.16,0:20:27.63,csapp,,0,0,0,,looks for an end-of-file meaning that the input stream is closed  or an end-of-line
Dialogue: 0,0:20:27.66,0:20:34.80,csapp,,0,0,0,,but as long as it until it sees that it just keeps adding more things to the end of this buffer
Dialogue: 0,0:20:37.66,0:20:39.28,csapp,,0,0,0,, and so typically
Dialogue: 0,0:20:43.98,0:20:50.66,csapp,,0,0,0,,when somebody calls gets they'll pass it a pointer to some buffer that they've allocated
Dialogue: 0,0:20:51.36,0:20:56.00,csapp,,0,0,0,,but the function and it will just get us we'll just fill that buffer up
Dialogue: 0,0:20:56.80,0:21:00.76,csapp,,0,0,0,,but it can potentially just keep going there's nothing in the function
Dialogue: 0,0:21:00.96,0:21:03.44,csapp,,0,0,0,,there's not even an argument to the function
Dialogue: 0,0:21:03.90,0:21:08.28,csapp,,0,0,0,,that tells the function when when it has to stop
Dialogue: 0,0:21:08.56,0:21:10.26,csapp,,0,0,0,,when it's reached the limit of it
Dialogue: 0,0:21:10.58,0:21:13.30,csapp,,0,0,0,,so it was written it actually get us is
Dialogue: 0,0:21:13.30,0:21:17.62,csapp,,0,0,0,,if you try to compile code would get us it will flash up a big warning that says
Dialogue: 0,0:21:17.62,0:21:21.10,csapp,,0,0,0,,this is really an unsafe function you probably shouldn't even be using it
Dialogue: 0,0:21:21.50,0:21:28.74,csapp,,0,0,0,,because it it has it was written in an era in the 1970s 
Dialogue: 0,0:21:28.74,0:21:31.40,csapp,,0,0,0,,even be using it  the early UNIX distributions were coming out
Dialogue: 0,0:21:31.76,0:21:34.60,csapp,,0,0,0,,where people just weren't worried about security vulnerabilities
Dialogue: 0,0:21:34.78,0:21:40.94,csapp,,0,0,0,,and they just assumed that if you allocated a big enough buffer
Dialogue: 0,0:21:41.32,0:21:46.44,csapp,,0,0,0,,that there's no reason why a string should be bigger than what you've allocated
Dialogue: 0,0:21:47.90,0:21:53.16,csapp,,0,0,0,,and that's actually true with other functions like strcpy
Dialogue: 0,0:21:53.68,0:21:58.80,csapp,,0,0,0,,you recall strcpy has two arguments
Dialogue: 0,0:21:59.40,0:22:02.86,csapp,,0,0,0,,excuse me a destination and a source
Dialogue: 0,0:22:03.78,0:22:08.64,csapp,,0,0,0,, and its purpose is to copy the string at the source into the destination
Dialogue: 0,0:22:09.08,0:22:13.14,csapp,,0,0,0,,and the way it determines the end of the string and the source is when it hits a null character
Dialogue: 0,0:22:13.60,0:22:17.86,csapp,,0,0,0,,that just keeps copying one by one well until it hits it
Dialogue: 0,0:22:18.10,0:22:22.38,csapp,,0,0,0,,but it has no way of knowing there's nothing no information there about how much
Dialogue: 0,0:22:22.76,0:22:27.38,csapp,,0,0,0,, how big is the the buffer allocated at the destination
Dialogue: 0,0:22:27.70,0:22:29.66,csapp,,0,0,0,,and so it can easily overrun that
Dialogue: 0,0:22:29.92,0:22:36.66,csapp,,0,0,0,,that a similar one called stir cat which is used to concatenate two strings  copy amasian
Dialogue: 0,0:22:37.34,0:22:44.30,csapp,,0,0,0,,and the scanf functions also have possible in the format string
Dialogue: 0,0:22:44.30,0:22:46.06,csapp,,0,0,0,,you can give the %s
Dialogue: 0,0:22:46.82,0:22:52.84,csapp,,0,0,0,, a directive to the format string which says read in a string  and store it someplace
Dialogue: 0,0:22:53.56,0:22:56.74,csapp,,0,0,0,, and it doesn't say how long the string is limited to be
Dialogue: 0,0:22:56.74,0:23:00.52,csapp,,0,0,0,,and it doesn't say how much memory is available at the destination
Dialogue: 0,0:23:00.78,0:23:04.52,csapp,,0,0,0,, so again it can easily just write over that a buffer
Dialogue: 0,0:23:05.72,0:23:10.84,csapp,,0,0,0,,so these are real vulnerabilities and they we'll talk in a minute a little later about
Dialogue: 0,0:23:11.22,0:23:14.74,csapp,,0,0,0,,how you as a programmer can be a little smarter than this
Dialogue: 0,0:23:15.12,0:23:22.50,csapp,,0,0,0,, but in their suit of raw form as presented they have this vulnerability to them
Dialogue: 0,0:23:23.68,0:23:29.30,csapp,,0,0,0,, so let's look at an example of what this can what can happen there
Dialogue: 0,0:23:29.74,0:23:34.96,csapp,,0,0,0,,so imagine for example we want a to implement echo function
Dialogue: 0,0:23:34.96,0:23:40.02,csapp,,0,0,0,,so an echo function is one that you just type something in and it prints it back out
Dialogue: 0,0:23:40.02,0:23:43.80,csapp,,0,0,0,,it's very uninteresting function except it's very useful to demonstrate things
Dialogue: 0,0:23:44.58,0:23:49.32,csapp,,0,0,0,,so the idea is it has this little buffer it's only enough to hold four characters
Dialogue: 0,0:23:49.78,0:23:55.44,csapp,,0,0,0,,because get us to read a string from the input and then it calls puts
Dialogue: 0,0:23:56.06,0:23:59.78,csapp,,0,0,0,,which simply writes back out the output
Dialogue: 0,0:24:00.72,0:24:08.96,csapp,,0,0,0,,and
Dialogue: 0,0:24:09.38,0:24:14.06,csapp,,0,0,0,,and so let me just demo this not very interesting function
Dialogue: 0,0:24:21.14,0:24:24.98,csapp,,0,0,0,,so I call here buff demo-NSP
Dialogue: 0,0:24:26.74,0:24:31.04,csapp,,0,0,0,,meaning as no stack protector we'll see in a minute what a stack protector is
Dialogue: 0,0:24:31.46,0:24:35.60,csapp,,0,0,0,,but you see if you type a reasonably strong small string
Dialogue: 0,0:24:41.92,0:24:47.08,csapp,,0,0,0,,let's see what remember it can handle more than four
Dialogue: 0,0:24:48.04,0:24:50.98,csapp,,0,0,0,,actually as written it can't handle more than three right
Dialogue: 0,0:24:50.98,0:24:55.26,csapp,,0,0,0,,because there should be room for the null character - on terminator
Dialogue: 0,0:25:02.00,0:25:07.92,csapp,,0,0,0,, so it turns out with this particular one if I type in a string of 24 characters
Dialogue: 0,0:25:09.72,0:25:11.04,csapp,,0,0,0,,it'll be okay
Dialogue: 0,0:25:22.36,0:25:24.86,csapp,,0,0,0,,but if I type in a string of 24 characters
Dialogue: 0,0:25:27.52,0:25:30.02,csapp,,0,0,0,,it will hit a segmentation fault
Dialogue: 0,0:25:33.12,0:25:35.90,csapp,,0,0,0,,so where do those numbers 23 and 24 come in
Dialogue: 0,0:25:35.90,0:25:39.04,csapp,,0,0,0,,well that's something we can learn by looking at the assembly code
Dialogue: 0,0:25:56.22,0:25:59.18,csapp,,0,0,0,,so here's and we'll go through this code
Dialogue: 0,0:26:00.08,0:26:04.70,csapp,,0,0,0,,so first of all this is the code for echo then
Dialogue: 0,0:26:05.58,0:26:09.18,csapp,,0,0,0,,and you see the echo calls gets and it calls puts
Dialogue: 0,0:26:13.34,0:26:19.56,csapp,,0,0,0,,and here's the part of the code where you can tell how much memory got allocated for the buffer
Dialogue: 0,0:26:20.06,0:26:29.34,csapp,,0,0,0,,and x18 is what in decimal and you
Dialogue: 0,0:26:34.04,0:26:34.98,csapp,,0,0,0,,24 right
Dialogue: 0,0:26:39.64,0:26:45.54,csapp,,0,0,0,,and just saw that the thing actually segfaults with a input string of 24
Dialogue: 0,0:26:45.54,0:26:46.60,csapp,,0,0,0,, so we'll see that in a minute
Dialogue: 0,0:26:47.50,0:26:55.28,csapp,,0,0,0,,but anyways you can see here that it's allocating on the stack a region of 24 bytes
Dialogue: 0,0:26:56.00,0:27:04.14,csapp,,0,0,0,, and it's copying that into RDI which is of course the argument forget us
Dialogue: 0,0:27:04.20,0:27:10.46,csapp,,0,0,0,,so get us is being called with a pointer to a buffer of size 24
Dialogue: 0,0:27:11.46,0:27:16.62,csapp,,0,0,0,,of maximum 24 even though you saw the original declaration was just four four
Dialogue: 0,0:27:20.20,0:27:25.84,csapp,,0,0,0,,um and then it calls gets and then get us does it thing i
Dialogue: 0,0:27:26.44,0:27:30.10,csapp,,0,0,0,,and just one last little bit to keep in mind is
Dialogue: 0,0:27:31.16,0:27:32.72,csapp,,0,0,0,,we'll get back to them
Dialogue: 0,0:27:33.14,0:27:36.10,csapp,,0,0,0,,oh yes and remember echo
Dialogue: 0,0:27:38.36,0:27:42.74,csapp,,0,0,0,,I there's a function called call echo which is the thing that calls echo
Dialogue: 0,0:27:43.46,0:27:48.84,csapp,,0,0,0,,and just to keep in mind this red is the return address  for call echo
Dialogue: 0,0:27:49.94,0:27:51.88,csapp,,0,0,0,,and that's going to be important
Dialogue: 0,0:27:55.94,0:27:59.66,csapp,,0,0,0,,so what we see then is the memory way out is
Dialogue: 0,0:28:01.22,0:28:05.86,csapp,,0,0,0,,the buff is normally big enough for four characters
Dialogue: 0,0:28:06.58,0:28:10.60,csapp,,0,0,0,,there's a sort of 20 bytes of unused or wasted space here
Dialogue: 0,0:28:10.96,0:28:17.86,csapp,,0,0,0,,and then the actual return address which is the return address for back to call echo is stored on the stack
Dialogue: 0,0:28:23.56,0:28:28.80,csapp,,0,0,0,,so when this program int begins running when echo starts to run
Dialogue: 0,0:28:29.12,0:28:34.38,csapp,,0,0,0,,we'll find that this is the value on the stack for the return pointer
Dialogue: 0,0:28:35.98,0:28:43.04,csapp,,0,0,0,,and if we type in a string of up here of 23 characters
Dialogue: 0,0:28:43.88,0:28:50.22,csapp,,0,0,0,,you'll see that it uses up this entire buffer and remember a string is terminated with a 0 0
Dialogue: 0,0:28:51.10,0:28:57.40,csapp,,0,0,0,,but it still hasn't it's still within the region that was allocated on the stack for that
Dialogue: 0,0:28:57.48,0:29:01.60,csapp,,0,0,0,,so it just barely fits into the the stack
Dialogue: 0,0:29:02.18,0:29:06.20,csapp,,0,0,0,,and that's why we technically we overflowed the buffer
Dialogue: 0,0:29:06.20,0:29:10.40,csapp,,0,0,0,,but we didn't really cause any harm because there was this extra space available
Dialogue: 0,0:29:11.38,0:29:17.96,csapp,,0,0,0,,and so that's why I could type in that string of 23 characters and  and it worked fine
Dialogue: 0,0:29:18.96,0:29:31.24,csapp,,0,0,0,, but now if I type in this is an example showing actually 25 characters
Dialogue: 0,0:29:32.74,0:29:39.58,csapp,,0,0,0,, so once I go beyond the 23 characters plus the null character
Dialogue: 0,0:29:39.58,0:29:42.12,csapp,,0,0,0,,you'll see what I'm slowly starting to do is
Dialogue: 0,0:29:42.68,0:29:49.72,csapp,,0,0,0,,is corrupt the the the byte representation of the return address
Dialogue: 0,0:29:50.38,0:29:52.64,csapp,,0,0,0,,and so what happens for example here
Dialogue: 0,0:29:53.00,0:29:57.94,csapp,,0,0,0,,is that rather than trying to return back to the where call echo
Dialogue: 0,0:29:58.34,0:30:00.98,csapp,,0,0,0,,was supposed to where it was supposed to go back to
Dialogue: 0,0:30:01.32,0:30:03.74,csapp,,0,0,0,, it goes back to some other part of your code
Dialogue: 0,0:30:04.20,0:30:08.08,csapp,,0,0,0,,that may or may not be a valid address or
Dialogue: 0,0:30:08.22,0:30:11.00,csapp,,0,0,0,,might not have anything to do with the program you're trying to run
Dialogue: 0,0:30:12.56,0:30:16.56,csapp,,0,0,0,,so this example shows it and if I typed in the 24
Dialogue: 0,0:30:22.10,0:30:26.04,csapp,,0,0,0,,let's see.before I got it to run
Dialogue: 0,0:30:26.04,0:30:29.94,csapp,,0,0,0,,like this you know this thing depends on the what happens
Dialogue: 0,0:30:31.04,0:30:33.48,csapp,,0,0,0,,how the code happens to get compiled
Dialogue: 0,0:30:36.04,0:30:42.70,csapp,,0,0,0,,oh yeah so okay so actually you see here
Dialogue: 0,0:30:43.90,0:30:49.12,csapp,,0,0,0,, this first string I typed is actually 24 characters long plus the null pointer
Dialogue: 0,0:30:49.80,0:30:54.12,csapp,,0,0,0,,so uh and we'll see why it didn't it should have crashed
Dialogue: 0,0:30:54.38,0:30:58.86,csapp,,0,0,0,,because we actually overwrite wrote the low order byte of the return address
Dialogue: 0,0:30:59.68,0:31:02.10,csapp,,0,0,0,,here we typed in this is 25 characters
Dialogue: 0,0:31:02.10,0:31:07.46,csapp,,0,0,0,,and so that's the one I just showed where it really whacked the two bytes of the return address
Dialogue: 0,0:31:08.02,0:31:10.22,csapp,,0,0,0,,so here we actually did overflow the buffer
Dialogue: 0,0:31:11.24,0:31:17.22,csapp,,0,0,0,,and let's try and figure out why that didn't harm the the program execution
Dialogue: 0,0:31:17.22,0:31:22.78,csapp,,0,0,0,, I see a question
Dialogue: 0,0:31:22.78,0:31:25.58,csapp,,0,0,0,,yes it could have been various other things could have there's nothing
Dialogue: 0,0:31:26.26,0:31:28.68,csapp,,0,0,0,, it hit a segmentation fault
Dialogue: 0,0:31:28.98,0:31:33.14,csapp,,0,0,0,,because it probably went to some weird part of the code and just started executing some random stuff
Dialogue: 0,0:31:33.48,0:31:35.14,csapp,,0,0,0,,and just got itself into trouble
Dialogue: 0,0:31:35.58,0:31:40.48,csapp,,0,0,0,,but that's the point is it's not predictable exactly what will happen when you do this
Dialogue: 0,0:31:52.40,0:31:56.10,csapp,,0,0,0,,so this is that the example of what actually happened the first time
Dialogue: 0,0:31:56.42,0:31:59.84,csapp,,0,0,0,,when I typed in a string that had 24 characters
Dialogue: 0,0:32:00.24,0:32:04.02,csapp,,0,0,0,,and so this null byte at the end actually corrupted the return address
Dialogue: 0,0:32:05.68,0:32:12.30,csapp,,0,0,0,,and so it was supposed to return back to this address 4006f6
Dialogue: 0,0:32:12.92,0:32:16.98,csapp,,0,0,0,,and instead it will return back to the address 400600
Dialogue: 0,0:32:18.04,0:32:21.64,csapp,,0,0,0,,which happens to be in some other weird function that's there
Dialogue: 0,0:32:21.94,0:32:26.16,csapp,,0,0,0,,and it just sort of landed at some place here
Dialogue: 0,0:32:26.16,0:32:33.28,csapp,,0,0,0,,and it's doing various things but somehow it didn't really didn't crash the program
Dialogue: 0,0:32:33.28,0:32:38.62,csapp,,0,0,0,,and that's one of the frustrating things about this is that  things can go wrong in a program
Dialogue: 0,0:32:39.12,0:32:41.80,csapp,,0,0,0,,and they don't always cause a crash
Dialogue: 0,0:32:42.14,0:32:47.36,csapp,,0,0,0,,and so often a bug that's working there might be doing some weird stuff that you don't even know about
Dialogue: 0,0:32:51.44,0:32:56.90,csapp,,0,0,0,,so that's all a fine if it's just a way of crashing programs and
Dialogue: 0,0:32:57.26,0:33:01.54,csapp,,0,0,0,,I mean that's not great if it's controlling your pacemaker or something like that
Dialogue: 0,0:33:01.54,0:33:08.42,csapp,,0,0,0,,but if it's just a homework assignment it's like not a big deal so
Dialogue: 0,0:33:09.72,0:33:15.78,csapp,,0,0,0,,I'll but what actually and this is sort of only happened since
Dialogue: 0,0:33:16.00,0:33:22.22,csapp,,0,0,0,,attacking became a normal activity which has only been the last 30 years
Dialogue: 0,0:33:22.62,0:33:27.18,csapp,,0,0,0,, is that it gives an opportunity for a hacker or a attacker
Dialogue: 0,0:33:27.80,0:33:32.48,csapp,,0,0,0,,to inject code into the program and execute it
Dialogue: 0,0:33:32.48,0:33:35.52,csapp,,0,0,0,,and that's what's called a code injection attack
Dialogue: 0,0:33:36.34,0:33:43.18,csapp,,0,0,0,, and so that the general scheme of it is I have this buffer that I can fill up with whatever bytes I want
Dialogue: 0,0:33:43.52,0:33:47.68,csapp,,0,0,0,,by feeding them to get s or whatever function is doing this copying
Dialogue: 0,0:33:48.00,0:33:51.36,csapp,,0,0,0,,and what I can do then is set up and pass to it
Dialogue: 0,0:33:51.46,0:33:57.48,csapp,,0,0,0,,some bytes of actually that encode an executable a little bit of executable code
Dialogue: 0,0:33:57.48,0:34:03.32,csapp,,0,0,0,,you've seen an object dump it's printing out these byte code representations of instructions
Dialogue: 0,0:34:03.32,0:34:09.24,csapp,,0,0,0,, so imagine you fed some of those bites into your string
Dialogue: 0,0:34:09.26,0:34:11.90,csapp,,0,0,0,,you encoded them in the string that you pass to get us
Dialogue: 0,0:34:13.04,0:34:20.56,csapp,,0,0,0,,and then you might have to add some more sort of padding characters
Dialogue: 0,0:34:20.56,0:34:22.56,csapp,,0,0,0,, that characters whose value doesn't matter
Dialogue: 0,0:34:23.03,0:34:30.14,csapp,,0,0,0,, in order to then get a number back into the position where the return pointer is supposed to be
Dialogue: 0,0:34:30.64,0:34:33.76,csapp,,0,0,0,,and so what's call that number B  it's going to be an address
Dialogue: 0,0:34:34.20,0:34:39.22,csapp,,0,0,0,,one of these ones with the you know that represents a stack location
Dialogue: 0,0:34:39.58,0:34:44.24,csapp,,0,0,0,,and that value B that is the the starting address of the buffer
Dialogue: 0,0:34:44.72,0:34:50.52,csapp,,0,0,0,,which happens to be where your exploit code remember this is just executable instructions
Dialogue: 0,0:34:51.12,0:34:53.52,csapp,,0,0,0,,of words stored here
Dialogue: 0,0:34:53.78,0:35:00.46,csapp,,0,0,0,,so now what will happen is when the program does its return here
Dialogue: 0,0:35:01.54,0:35:06.12,csapp,,0,0,0,,it was supposed to return back to wherever it got called from P
Dialogue: 0,0:35:11.18,0:35:14.58,csapp,,0,0,0,,this is a typo P calls Q not the bar
Dialogue: 0,0:35:18.25,0:35:20.62,csapp,,0,0,0,,so it's supposed to return back to P
Dialogue: 0,0:35:21.46,0:35:26.66,csapp,,0,0,0,, and we're and the address the return address was stored here
Dialogue: 0,0:35:26.66,0:35:31.54,csapp,,0,0,0,,but now I've overwritten that return address  with this buffer position
Dialogue: 0,0:35:31.54,0:35:37.40,csapp,,0,0,0,, so what will happen is the the program counter will happily jump to this spot
Dialogue: 0,0:35:37.40,0:35:43.04,csapp,,0,0,0,,and see start executing whatever it encounters which are the instructions that you've inserted
Dialogue: 0,0:35:43.70,0:35:49.78,csapp,,0,0,0,,and by that means  then you can inject code into a machine potentially
Dialogue: 0,0:35:50.20,0:35:53.72,csapp,,0,0,0,,somewhere else in the Internet if you could set up a scheme like this
Dialogue: 0,0:35:53.72,0:35:58.28,csapp,,0,0,0,,that would feed these bytes into that machine
Dialogue: 0,0:35:58.54,0:36:01.06,csapp,,0,0,0,, and it would read it in with a function like gets
Dialogue: 0,0:36:01.44,0:36:05.28,csapp,,0,0,0,, and then it would try to do its return but it would start executing your code
Dialogue: 0,0:36:06.22,0:36:09.24,csapp,,0,0,0,,so that's a classic code injection attack
Dialogue: 0,0:36:09.54,0:36:14.36,csapp,,0,0,0,,and in fact in this lab that you're going to start to comes out at midnight
Dialogue: 0,0:36:14.68,0:36:20.34,csapp,,0,0,0,,it's called the attack lab because you're going to do this yourself
Dialogue: 0,0:36:21.22,0:36:26.80,csapp,,0,0,0,, for part of the lab and I think you'll find it pretty interesting
Dialogue: 0,0:36:31.64,0:36:35.20,csapp,,0,0,0,,so this used to be a huge problem  on programs
Dialogue: 0,0:36:35.20,0:36:46.44,csapp,,0,0,0,, -yes \n-so when you're trying to replace read how do you make sure that your new submitted read provides that exact line
Dialogue: 0,0:36:46.46,0:36:49.04,csapp,,0,0,0,,well that's part of the cleverness of being a hacker
Dialogue: 0,0:36:49.70,0:36:51.92,csapp,,0,0,0,,you have to make sure it's in the right spot
Dialogue: 0,0:36:51.92,0:36:54.40,csapp,,0,0,0,,but it's that's actually one of the easier parts
Dialogue: 0,0:36:54.98,0:36:59.02,csapp,,0,0,0,,because for example we did you know you have to know the binary code
Dialogue: 0,0:36:59.92,0:37:03.72,csapp,,0,0,0,,to be able to do this or be able to guess
Dialogue: 0,0:37:04.44,0:37:09.44,csapp,,0,0,0,, so for example in that previous one I could tell that it was allocating 24 bytes for that buffer
Dialogue: 0,0:37:10.20,0:37:15.58,csapp,,0,0,0,,and so if I just made sure that the length of my exploit code plus the padding is 24 bytes
Dialogue: 0,0:37:16.30,0:37:18.96,csapp,,0,0,0,, then right after that comes the return address
Dialogue: 0,0:37:18.96,0:37:20.60,csapp,,0,0,0,,so that's actually pretty easy to do
Dialogue: 0,0:37:20.60,0:37:24.02,csapp,,0,0,0,,there was certainly how much memory program is that no you have to have access
Dialogue: 0,0:37:24.04,0:37:29.72,csapp,,0,0,0,, you have to what the reason why this works is
Dialogue: 0,0:37:30.84,0:37:35.90,csapp,,0,0,0,, it works if you have enough knowledge about the operating system that's running at the other end
Dialogue: 0,0:37:36.30,0:37:37.84,csapp,,0,0,0,,for example you know it's Linux
Dialogue: 0,0:37:38.18,0:37:44.10,csapp,,0,0,0,,you know that you can look at you know what GCC tends to allocate for
Dialogue: 0,0:37:44.10,0:37:47.40,csapp,,0,0,0,, it you somehow have access to information about the code itself
Dialogue: 0,0:37:48.18,0:37:50.14,csapp,,0,0,0,,let's you do this
Dialogue: 0,0:37:56.48,0:37:59.14,csapp,,0,0,0,,oh so anyways this used to be a huge problem
Dialogue: 0,0:37:59.16,0:38:05.32,csapp,,0,0,0,,and it started way back in 1988 the first internet attack with called the Morris worm
Dialogue: 0,0:38:05.86,0:38:10.24,csapp,,0,0,0,,and it at the time the internet was not a very big place
Dialogue: 0,0:38:11.16,0:38:14.08,csapp,,0,0,0,, and it basically brought down a huge fraction of the machines
Dialogue: 0,0:38:14.48,0:38:17.00,csapp,,0,0,0,,that were on the Internet at the time
Dialogue: 0,0:38:17.00,0:38:22.18,csapp,,0,0,0,,interestingly enough CMU did not fall victim to this attack
Dialogue: 0,0:38:22.18,0:38:28.48,csapp,,0,0,0,,because we'd patched already the vulnerabilities that this particular program exploited
Dialogue: 0,0:38:32.22,0:38:37.90,csapp,,0,0,0,,and that was the cause that the software engineering Institute runs an organization called cert the
Dialogue: 0,0:38:37.90,0:38:39.96,csapp,,0,0,0,,computer emergency response team
Dialogue: 0,0:38:40.34,0:38:46.76,csapp,,0,0,0,, and that team was set up in response to this attack the Morris worm attack
Dialogue: 0,0:38:48.10,0:38:56.03,csapp,,0,0,0,,will also see an interesting example  between two companies in in messaging services
Dialogue: 0,0:38:56.38,0:39:02.54,csapp,,0,0,0,,and many others it's been the sort of standard attack mechanism for many years
Dialogue: 0,0:39:03.06,0:39:09.36,csapp,,0,0,0,,and fortunately nowadays there's a few things that make the attacking a less likely to be successful
Dialogue: 0,0:39:09.86,0:39:12.22,csapp,,0,0,0,,and so it's not as huge a problem as it used to be
Dialogue: 0,0:39:12.52,0:39:17.04,csapp,,0,0,0,,but still it's a source of many vulnerabilities in programs
Dialogue: 0,0:39:18.90,0:39:22.58,csapp,,0,0,0,,so let's see I won't talk too much about this
Dialogue: 0,0:39:22.64,0:39:25.84,csapp,,0,0,0,, but it used to be in the original implementation of
Dialogue: 0,0:39:26.42,0:39:30.70,csapp,,0,0,0,,there's a command that most systems have now disabled that
Dialogue: 0,0:39:30.70,0:39:33.96,csapp,,0,0,0,,you could finger you could across to information about
Dialogue: 0,0:39:34.36,0:39:38.66,csapp,,0,0,0,,somebody in some remote location it would send a message to that location
Dialogue: 0,0:39:39.48,0:39:41.28,csapp,,0,0,0,, and then it would reply back
Dialogue: 0,0:39:41.74,0:39:46.70,csapp,,0,0,0,,and it used get us the honor the actual original implementation called Geddes
Dialogue: 0,0:39:47.24,0:39:51.40,csapp,,0,0,0,, to read the input string from that was being sent to it
Dialogue: 0,0:39:55.82,0:39:57.84,csapp,,0,0,0,,and then there is an interesting one
Dialogue: 0,0:39:57.84,0:40:01.26,csapp,,0,0,0,,you guys don't remember messaging instant messaging
Dialogue: 0,0:40:01.26,0:40:08.52,csapp,,0,0,0,,but before it used to be that people would talk to each other on their computers  by sending messages
Dialogue: 0,0:40:08.86,0:40:11.18,csapp,,0,0,0,,sort of like you send text messages today
Dialogue: 0,0:40:11.70,0:40:14.56,csapp,,0,0,0,,but there is an interesting thing that
Dialogue: 0,0:40:15.78,0:40:19.00,csapp,,0,0,0,,there's a company still exists
Dialogue: 0,0:40:19.00,0:40:23.02,csapp,,0,0,0,,but it's a shadow of its former self called AOL
Dialogue: 0,0:40:23.36,0:40:28.88,csapp,,0,0,0,,which ran the most popular Internet services and had the most popular instant messaging program
Dialogue: 0,0:40:29.38,0:40:32.36,csapp,,0,0,0,,and Microsoft came out with its own client
Dialogue: 0,0:40:32.78,0:40:35.20,csapp,,0,0,0,, its own program that you could run on your machine
Dialogue: 0,0:40:35.48,0:40:40.06,csapp,,0,0,0,,and communicate to other people on this a messaging system
Dialogue: 0,0:40:40.06,0:40:42.52,csapp,,0,0,0,, so the Microsoft code was running on your machine
Dialogue: 0,0:40:42.90,0:40:49.74,csapp,,0,0,0,,but it would use the servers that were being run by AOL  to manage this messaging traffic
Dialogue: 0,0:40:50.38,0:40:57.62,csapp,,0,0,0,,and the funny story was over the
Dialogue: 0,0:40:59.18,0:41:01.78,csapp,,0,0,0,,the this Microsoft program would work fine
Dialogue: 0,0:41:02.54,0:41:08.94,csapp,,0,0,0,,you can communicate with your friends who had different messaging clients  and it all seemed compatible
Dialogue: 0,0:41:09.34,0:41:12.74,csapp,,0,0,0,, but then suddenly the people that were running the Microsoft version of the software
Dialogue: 0,0:41:13.18,0:41:16.96,csapp,,0,0,0,, it wouldn't work and then Microsoft people figured out how to patch it
Dialogue: 0,0:41:17.68,0:41:20.00,csapp,,0,0,0,,and then it would work for a while and then it wouldn't work
Dialogue: 0,0:41:20.00,0:41:24.64,csapp,,0,0,0,,and the way what was happening was AOL was using a bug in its own code
Dialogue: 0,0:41:25.30,0:41:33.86,csapp,,0,0,0,, to be able to determine who's basically peek into the the machines on the client side
Dialogue: 0,0:41:34.44,0:41:39.90,csapp,,0,0,0,,and do a buffer overflow attack on your code that you're running on your machine
Dialogue: 0,0:41:40.22,0:41:44.70,csapp,,0,0,0,,and then basically peek around and see does this look like AOL code
Dialogue: 0,0:41:44.70,0:41:46.95,csapp,,0,0,0,,or is it something or is it some foreign code
Dialogue: 0,0:41:47.38,0:41:54.80,csapp,,0,0,0,,and so is basic be able to use its own security weakness to figure out this information
Dialogue: 0,0:41:56.28,0:42:01.90,csapp,,0,0,0,, and that got disclosed by a sort of funny message
Dialogue: 0,0:42:02.42,0:42:06.26,csapp,,0,0,0,,from somebody who called himself Phil bucking
Dialogue: 0,0:42:07.02,0:42:12.36,csapp,,0,0,0,,and it was determined that this email originated from somewhere within Microsoft
Dialogue: 0,0:42:15.86,0:42:21.52,csapp,,0,0,0,, so anyways that and you can read more about it in the book around the slide fun choice
Dialogue: 0,0:42:21.78,0:42:26.78,csapp,,0,0,0,,so in general in the security world you're supposed to distinguish between the idea of a worm and a virus
Dialogue: 0,0:42:26.78,0:42:28.70,csapp,,0,0,0,,although people aren't very good at doing that
Dialogue: 0,0:42:29.06,0:42:35.58,csapp,,0,0,0,,so worm is a program that can run on its own and propagate itself from one place to the other replicated
Dialogue: 0,0:42:35.96,0:42:40.80,csapp,,0,0,0,,a virus is like a biological virus it doesn't live on its own
Dialogue: 0,0:42:40.90,0:42:45.78,csapp,,0,0,0,,it works by attacking a program and basically modifying that program's behavior
Dialogue: 0,0:42:51.30,0:42:56.72,csapp,,0,0,0,,so that gives you the basic idea of buffer overflows and you'll see it more first hand
Dialogue: 0,0:42:57.20,0:43:02.44,csapp,,0,0,0,,so let's look at it techniques that machines can use to avoid
Dialogue: 0,0:43:02.72,0:43:05.12,csapp,,0,0,0,,to make themself less vulnerable to these attacks
Dialogue: 0,0:43:05.60,0:43:11.20,csapp,,0,0,0,,well first of all you the application or the cert the writer on the server-side
Dialogue: 0,0:43:11.58,0:43:13.38,csapp,,0,0,0,,can write code that's more secure
Dialogue: 0,0:43:14.90,0:43:18.32,csapp,,0,0,0,,so for example what you're supposed to do instead of gets
Dialogue: 0,0:43:18.84,0:43:20.76,csapp,,0,0,0,,is use a function called fgets
Dialogue: 0,0:43:21.28,0:43:26.18,csapp,,0,0,0,, and fgets has a property that it it passes a parameter
Dialogue: 0,0:43:26.48,0:43:31.40,csapp,,0,0,0,,which is the maximum number of bytes that the program should read
Dialogue: 0,0:43:31.84,0:43:37.86,csapp,,0,0,0,,and if there's more bytes than that in the input it will just truncate the input
Dialogue: 0,0:43:38.62,0:43:43.40,csapp,,0,0,0,,so you're really supposed to use fgets and give a limit
Dialogue: 0,0:43:43.92,0:43:49.16,csapp,,0,0,0,,similarly a strncpy there is a version of it called strncopy  where you can give a limit
Dialogue: 0,0:43:49.98,0:43:55.22,csapp,,0,0,0,,and with a scanf you're supposed to be careful about using the percent s
Dialogue: 0,0:43:55.62,0:43:59.28,csapp,,0,0,0,,there's even a terminology you can say percent give a number
Dialogue: 0,0:43:59.84,0:44:03.58,csapp,,0,0,0,,that's the maximum length of the string it should read
Dialogue: 0,0:44:03.58,0:44:09.39,csapp,,0,0,0,,so these various places you can protect your code  to make sure it won't overflow buffers
Dialogue: 0,0:44:09.80,0:44:15.00,csapp,,0,0,0,,unfortunately a lot of code has been you'd call it hardening
Dialogue: 0,0:44:15.14,0:44:18.94,csapp,,0,0,0,,it's been people have gone through it and it's a lot of work
Dialogue: 0,0:44:19.04,0:44:23.64,csapp,,0,0,0,,because there's a lot of places in programs where you're copying strings from one place to another
Dialogue: 0,0:44:24.14,0:44:31.56,csapp,,0,0,0,,and there are a lot of real subtleties like when you're converting from Unicode to bytes and so forth
Dialogue: 0,0:44:31.56,0:44:34.68,csapp,,0,0,0,, that you're going back and forth between different character encodings
Dialogue: 0,0:44:35.20,0:44:42.70,csapp,,0,0,0,, but for the large part and there's tools that the code developers have created to help  track down these bugs
Dialogue: 0,0:44:43.24,0:44:47.72,csapp,,0,0,0,,so it's become a little bit safer out there but there's still vulnerabilities
Dialogue: 0,0:44:48.50,0:44:53.80,csapp,,0,0,0,, so then there's other parts where you just try to build in safeguards into the system
Dialogue: 0,0:44:54.22,0:44:59.38,csapp,,0,0,0,,that would make it much harder to do a buffer overflow exploit like I showed you
Dialogue: 0,0:45:00.04,0:45:03.20,csapp,,0,0,0,,and so one of them is called stack randomization
Dialogue: 0,0:45:03.68,0:45:05.64,csapp,,0,0,0,, where it goes by a more general term
Dialogue: 0,0:45:09.34,0:45:12.06,csapp,,0,0,0,,that's abbreviated a SLR
Dialogue: 0,0:45:12.86,0:45:25.04,csapp,,0,0,0,,which stands for address space layout randomization
Dialogue: 0,0:45:25.50,0:45:29.04,csapp,,0,0,0,,and the idea of it is to make it so every time a program runs
Dialogue: 0,0:45:29.54,0:45:33.84,csapp,,0,0,0,,the addresses change  a little bit or a lot
Dialogue: 0,0:45:34.24,0:45:39.50,csapp,,0,0,0,,so that you can't reliably know where things are going to be in the code
Dialogue: 0,0:45:39.96,0:45:45.84,csapp,,0,0,0,,so imagine for example the and the way it's implemented is before
Dialogue: 0,0:45:46.10,0:45:49.52,csapp,,0,0,0,,in the sort of run-up of your program when it first starts up
Dialogue: 0,0:45:50.24,0:45:52.76,csapp,,0,0,0,,but before your main routine gets called
Dialogue: 0,0:45:53.92,0:45:58.72,csapp,,0,0,0,, it will just do a allocation on the stack of some random number of bytes of storage
Dialogue: 0,0:45:59.36,0:46:05.70,csapp,,0,0,0,, a fair amount like maybe a megabyte roughly of storage where the exact number is randomly chosen
Dialogue: 0,0:46:06.70,0:46:10.50,csapp,,0,0,0,, and what that means is that the the dress of the stack
Dialogue: 0,0:46:10.66,0:46:14.66,csapp,,0,0,0,,of all the different positions of your ear
Dialogue: 0,0:46:15.26,0:46:20.04,csapp,,0,0,0,,all the local storage on the stack will shift up and down from one run to another
Dialogue: 0,0:46:20.92,0:46:22.62,csapp,,0,0,0,,and we can actually see that
Dialogue: 0,0:46:24.54,0:46:27.54,csapp,,0,0,0,,in this example I showed
Dialogue: 0,0:46:33.30,0:46:38.22,csapp,,0,0,0,,so I have a program here it's not a very interesting program I'll show you
Dialogue: 0,0:46:39.44,0:46:41.40,csapp,,0,0,0,,except to demonstrate these ideas
Dialogue: 0,0:46:45.40,0:46:50.42,csapp,,0,0,0,, all it's doing is there's some code it's based on that one
Dialogue: 0,0:46:50.42,0:46:51.92,csapp,,0,0,0,,I already showed called locate
Dialogue: 0,0:46:51.92,0:46:54.72,csapp,,0,0,0,,but this one there's a global variable
Dialogue: 0,0:46:55.40,0:47:00.51,csapp,,0,0,0,,there's some functions there's something that gets allocated by malloc
Dialogue: 0,0:47:00.92,0:47:04.98,csapp,,0,0,0,,and there's something that is a local variable stored on the stack
Dialogue: 0,0:47:05.58,0:47:09.10,csapp,,0,0,0,,and so what I'll do is show addresses that are chosen
Dialogue: 0,0:47:09.46,0:47:15.66,csapp,,0,0,0,, the address of this variable then will be  a stack address a local of a local variable
Dialogue: 0,0:47:16.30,0:47:19.34,csapp,,0,0,0,,global will be this one that gets allocated globally
Dialogue: 0,0:47:19.94,0:47:22.10,csapp,,0,0,0,,the heap is something allocated with malloc
Dialogue: 0,0:47:22.82,0:47:27.38,csapp,,0,0,0,,and then the this function useless will count as a code address
Dialogue: 0,0:47:29.08,0:47:30.32,csapp,,0,0,0,, and now when I run it
Dialogue: 0,0:47:34.56,0:47:39.62,csapp,,0,0,0,,you'll see from one run to another that if some of these stay the same and some of them change
Dialogue: 0,0:47:40.36,0:47:46.02,csapp,,0,0,0,,so in particular the global variable  is the same 60102c
Dialogue: 0,0:47:47.70,0:47:56.22,csapp,,0,0,0,,and the code is the same 0x400590 is the same every execution
Dialogue: 0,0:47:56.66,0:48:00.80,csapp,,0,0,0,,but you'll see this local variable it's on its a stack address
Dialogue: 0,0:48:01.50,0:48:07.34,csapp,,0,0,0,,but you see that the lower half dozen or so bytes are actually changing from one run to another
Dialogue: 0,0:48:07.84,0:48:12.88,csapp,,0,0,0,,1 2 3 4 5 so 5 bytes so that's
Dialogue: 0,0:48:15.92,0:48:17.68,csapp,,0,0,0,,what 5 hex digits I'm sorry
Dialogue: 0,0:48:17.68,0:48:20.10,csapp,,0,0,0,,so that's 2 to the 20th
Dialogue: 0,0:48:20.70,0:48:25.26,csapp,,0,0,0,,so roughly a megabyte of variation is going on in stack addresses there
Dialogue: 0,0:48:25.80,0:48:32.06,csapp,,0,0,0,,and similarly you'll see that the heap addresses are also varying from one to another
Dialogue: 0,0:48:32.26,0:48:33.76,csapp,,0,0,0,, from one execution to the other
Dialogue: 0,0:48:33.78,0:48:38.62,csapp,,0,0,0,,so malloc has built into it some amount of randomness to in its allocation
Dialogue: 0,0:48:39.34,0:48:43.38,csapp,,0,0,0,,so why is that ik you know what's the purpose of that well
Dialogue: 0,0:48:45.46,0:48:49.14,csapp,,0,0,0,, as I told you this code injection vulnerability
Dialogue: 0,0:48:51.42,0:48:57.30,csapp,,0,0,0,,relies on the fact that you can you can load up this buffer with some executable code
Dialogue: 0,0:48:57.74,0:49:03.38,csapp,,0,0,0,,but somehow you have to know how to get to the start of that code
Dialogue: 0,0:49:04.00,0:49:08.32,csapp,,0,0,0,, and so this is relying the attack is relying on the fact
Dialogue: 0,0:49:08.32,0:49:13.28,csapp,,0,0,0,, that it can somehow predict what the this address of the buffer is
Dialogue: 0,0:49:14.36,0:49:18.04,csapp,,0,0,0,,and so that it can store it in the right part of the string
Dialogue: 0,0:49:18.16,0:49:22.98,csapp,,0,0,0,,put it encode it in the right part of the string so it will show up where the return pointer is supposed to be
Dialogue: 0,0:49:24.36,0:49:26.52,csapp,,0,0,0,,and and have it jump to that location
Dialogue: 0,0:49:26.92,0:49:28.66,csapp,,0,0,0,,but now with this randomization
Dialogue: 0,0:49:29.26,0:49:33.24,csapp,,0,0,0,,this number is varying by quite a bit
Dialogue: 0,0:49:33.40,0:49:37.50,csapp,,0,0,0,,sort of million over a range of a million or so values
Dialogue: 0,0:49:37.88,0:49:39.24,csapp,,0,0,0,,so there's no way in advance
Dialogue: 0,0:49:39.48,0:49:44.41,csapp,,0,0,0,,even if I have an exact copy of the code not even had access to the system itself
Dialogue: 0,0:49:44.72,0:49:46.13,csapp,,0,0,0,,and could run it
Dialogue: 0,0:49:46.54,0:49:50.04,csapp,,0,0,0,,I can't predict from one run to the next where it's going to be
Dialogue: 0,0:49:50.68,0:49:54.82,csapp,,0,0,0,, so that gives it sort of thoughts this particular attack
Dialogue: 0,0:49:55.40,0:49:59.86,csapp,,0,0,0,,to to make it using this randomization
Dialogue: 0,0:50:03.14,0:50:07.24,csapp,,0,0,0,,another idea that's fairly straightforward
Dialogue: 0,0:50:07.24,0:50:11.32,csapp,,0,0,0,,but it took a long time for the hardware people to implement this
Dialogue: 0,0:50:12.04,0:50:16.74,csapp,,0,0,0,, is well why why is there supposed to be code on the stack
Dialogue: 0,0:50:16.74,0:50:21.10,csapp,,0,0,0,, in the first place isn't the code supposed to be located down in the text segment
Dialogue: 0,0:50:21.70,0:50:25.82,csapp,,0,0,0,,where it can be sort of specially identified as being executable
Dialogue: 0,0:50:26.58,0:50:29.02,csapp,,0,0,0,,so in the original x86
Dialogue: 0,0:50:29.64,0:50:33.44,csapp,,0,0,0,,there's a one bit flag for each region of memory
Dialogue: 0,0:50:34.20,0:50:37.08,csapp,,0,0,0,,saying is it actually - one bit flags
Dialogue: 0,0:50:37.62,0:50:40.04,csapp,,0,0,0,,one is can this be written to
Dialogue: 0,0:50:41.04,0:50:45.46,csapp,,0,0,0,,so that you can prevent over writes of things like string constants
Dialogue: 0,0:50:46.88,0:50:50.59,csapp,,0,0,0,, and so and then the other is am I can I read it
Dialogue: 0,0:50:51.32,0:50:53.46,csapp,,0,0,0,,and read means access those bytes and
Dialogue: 0,0:50:53.46,0:50:57.18,csapp,,0,0,0,, it was interpreted that readable and executable were the same thing
Dialogue: 0,0:50:57.66,0:51:01.30,csapp,,0,0,0,, I can read it I can execute it and that was the rules
Dialogue: 0,0:51:02.48,0:51:08.78,csapp,,0,0,0,,in a sort of last 10 years or so starting first with AMD and then Intel
Dialogue: 0,0:51:09.06,0:51:12.54,csapp,,0,0,0,,have added a third bit that says is this executable or not
Dialogue: 0,0:51:13.02,0:51:18.16,csapp,,0,0,0,,similarly to the permissions you have on a file on UNIX is it readable writable executable
Dialogue: 0,0:51:18.58,0:51:21.30,csapp,,0,0,0,,those are three separate permission bits that are alone
Dialogue: 0,0:51:22.72,0:51:26.50,csapp,,0,0,0,,so by simply marking the stack is not executable
Dialogue: 0,0:51:26.84,0:51:29.22,csapp,,0,0,0,,it'll also fort this particular attack
Dialogue: 0,0:51:29.22,0:51:34.04,csapp,,0,0,0,,because I have to be able to execute these bytes that I've injected into the system
Dialogue: 0,0:51:37.18,0:51:41.76,csapp,,0,0,0,,and then there's the final idea which is actually fairly effective -
Dialogue: 0,0:51:42.24,0:51:45.72,csapp,,0,0,0,,which they call a canary  that they built into the stack
Dialogue: 0,0:51:45.72,0:51:49.20,csapp,,0,0,0,, and some of you actually encountered this code already and looking at your bombs
Dialogue: 0,0:51:49.20,0:51:51.34,csapp,,0,0,0,,because we've been getting some questions about it
Dialogue: 0,0:51:52.52,0:51:55.32,csapp,,0,0,0,,so let me just give you an example here
Dialogue: 0,0:52:05.70,0:52:08.20,csapp,,0,0,0,,and this one's called buffdemo-sp
Dialogue: 0,0:52:08.20,0:52:11.28,csapp,,0,0,0,,because it's been compiled with what they call stack protector
Dialogue: 0,0:52:17.54,0:52:22.56,csapp,,0,0,0,,and this one on now it's the same code as before it's dis compiled a little bit differently
Dialogue: 0,0:52:23.14,0:52:26.70,csapp,,0,0,0,,what you'll find is I can give a string of length eight
Dialogue: 0,0:52:27.08,0:52:28.58,csapp,,0,0,0,,and not have a problem
Dialogue: 0,0:52:29.04,0:52:32.38,csapp,,0,0,0,,but if I now have nine characters
Dialogue: 0,0:52:33.00,0:52:38.80,csapp,,0,0,0,, it will dump out with this very strange exit error message
Dialogue: 0,0:52:39.42,0:52:41.86,csapp,,0,0,0,,that is an indication
Dialogue: 0,0:52:43.96,0:52:49.78,csapp,,0,0,0,,that it's detected I attempt to smash the stack 
Dialogue: 0,0:52:49.78,0:52:52.66,csapp,,0,0,0,,so buffer overflow is sometimes called stack smashing 
Dialogue: 0,0:52:53.68,0:52:59.58,csapp,,0,0,0,,so it detected somehow that even though my code was still the same old crappy code from before 
Dialogue: 0,0:53:00.70,0:53:03.96,csapp,,0,0,0,,of a very small buffer allocation and no protection 
Dialogue: 0,0:53:03.96,0:53:08.36,csapp,,0,0,0,,somehow the the system protected me from myself 
Dialogue: 0,0:53:10.30,0:53:15.66,csapp,,0,0,0,,and that's a by a relatively simple trick that's a fairly clever though 
Dialogue: 0,0:53:17.40,0:53:19.62,csapp,,0,0,0,,what they call stack canary 
Dialogue: 0,0:53:20.36,0:53:27.32,csapp,,0,0,0,,so that the term canary comes back from a back in the coal mining days of old 
Dialogue: 0,0:53:27.68,0:53:33.38,csapp,,0,0,0,,before they had very good ways of measuring things they take a bird down with them in a cage 
Dialogue: 0,0:53:33.92,0:53:40.64,csapp,,0,0,0,,and a canary is a property that's very susceptible to dying 
Dialogue: 0,0:53:42.06,0:53:44.96,csapp,,0,0,0,,if there's nothing if there's methane gas present 
Dialogue: 0,0:53:44.96,0:53:48.84,csapp,,0,0,0,,so these miners would be down there working and they'd see their bird 
Dialogue: 0,0:53:49.56,0:53:52.92,csapp,,0,0,0,,keel over and say oh we got a problem here let's get out fast 
Dialogue: 0,0:53:53.42,0:53:57.14,csapp,,0,0,0,,so that's why they call it a canary in a coal mine sometimes 
Dialogue: 0,0:53:57.14,0:54:00.60,csapp,,0,0,0,,some kind of warning signal that that something's not not right here
Dialogue: 0,0:54:01.82,0:54:08.28,csapp,,0,0,0,,and in general we see a GCC if you invoke it with a stack protector
Dialogue: 0,0:54:08.28,0:54:09.90,csapp,,0,0,0,, nowadays that's the default 
Dialogue: 0,0:54:10.82,0:54:15.48,csapp,,0,0,0,,so even without you saying anything this code will get built into it
Dialogue: 0,0:54:18.62,0:54:21.80,csapp,,0,0,0,,and so let's look at at what that canary code looks like 
Dialogue: 0,0:54:21.80,0:54:24.84,csapp,,0,0,0,,and how it does its thing it's really pretty clever as I said 
Dialogue: 0,0:54:25.24,0:54:29.24,csapp,,0,0,0,,and some of you have already observed this strange kind of memory reference 
Dialogue: 0,0:54:29.34,0:54:34.46,csapp,,0,0,0,,in a register reference in the code and your boom labs 
Dialogue: 0,0:54:34.46,0:54:39.08,csapp,,0,0,0,,because it was compiled with this deck protecting enabled  because that's the default 
Dialogue: 0,0:54:40.26,0:54:48.36,csapp,,0,0,0,,and so in particular what this code shows is it's allocating as before 24 bytes on the stack 
Dialogue: 0,0:54:49.22,0:54:53.92,csapp,,0,0,0,,but now it's getting some number and we'll talk in a second what that means 
Dialogue: 0,0:54:54.42,0:55:01.22,csapp,,0,0,0,,and storing it at position 8 offset from the stack pointer 
Dialogue: 0,0:55:01.80,0:55:06.42,csapp,,0,0,0,,and then the rest of the code and then it zeros it out  that's not to worry 
Dialogue: 0,0:55:06.64,0:55:12.36,csapp,,0,0,0,,and then it looks like the your previous code that it's passing a pointer to the stack
Dialogue: 0,0:55:13.14,0:55:15.82,csapp,,0,0,0,,top of the stack as the argument to get us 
Dialogue: 0,0:55:17.04,0:55:21.66,csapp,,0,0,0,,and get us it gets called and then put s gets called 
Dialogue: 0,0:55:22.28,0:55:28.80,csapp,,0,0,0,,but now there's some more code here that is it involves this strange-looking register
Dialogue: 0,0:55:29.22,0:55:33.82,csapp,,0,0,0,, and then there's some kind of test and then if that test fails
Dialogue: 0,0:55:34.64,0:55:40.72,csapp,,0,0,0,, it will call this a code that you just saw printed out this error message 
Dialogue: 0,0:55:42.68,0:55:44.76,csapp,,0,0,0,,so let's see what that all means
Dialogue: 0,0:55:45.00,0:55:51.30,csapp,,0,0,0,,what that means is that at offset 8 from the stack pointer 
Dialogue: 0,0:55:51.30,0:55:54.70,csapp,,0,0,0,,it's putting in 8 bytes a value
Dialogue: 0,0:55:55.52,0:55:59.84,csapp,,0,0,0,, that it's retrieving from a special register 
Dialogue: 0,0:55:59.84,0:56:07.84,csapp,,0,0,0,,so FS is a reference to a type of register that was created for the original 8086 
Dialogue: 0,0:56:07.84,0:56:12.26,csapp,,0,0,0,,and is now completely obsolete but it's still there for backward compatibility mode 
Dialogue: 0,0:56:12.78,0:56:18.64,csapp,,0,0,0,,but what it is it and I actually I looked and I've never fully been able to find the documentation on it
Dialogue: 0,0:56:19.16,0:56:21.90,csapp,,0,0,0,, it's able to read from a part of memory
Dialogue: 0,0:56:22.40,0:56:28.08,csapp,,0,0,0,, a set of values that you can't otherwise get to
Dialogue: 0,0:56:28.56,0:56:35.70,csapp,,0,0,0,,and so that's the Khmer canary it's getting a somehow it's grabbing eight bytes from somewhere 
Dialogue: 0,0:56:36.42,0:56:38.62,csapp,,0,0,0,,storing it as this canary value 
Dialogue: 0,0:56:40.08,0:56:43.82,csapp,,0,0,0,,and then if you give like a seven character input 
Dialogue: 0,0:56:45.32,0:56:50.06,csapp,,0,0,0,,so you would affect the canary and so what happens when it returns from
Dialogue: 0,0:56:51.96,0:56:57.60,csapp,,0,0,0,, the two calls from gets and puts  before it exits 
Dialogue: 0,0:56:57.60,0:57:05.12,csapp,,0,0,0,,what it's trying to detect is has anything as this buffer somehow overflowed 
Dialogue: 0,0:57:05.50,0:57:09.90,csapp,,0,0,0,,and potentially at risk of of corrupting some other part of the stack 
Dialogue: 0,0:57:10.52,0:57:16.14,csapp,,0,0,0,,so basically what it does is it retrieves back from the stack 
Dialogue: 0,0:57:16.54,0:57:19.06,csapp,,0,0,0,,what is the current value of this canary 
Dialogue: 0,0:57:19.62,0:57:26.50,csapp,,0,0,0,,and it's comparing it to what it should be  by retrieving that back from this special region 
Dialogue: 0,0:57:26.94,0:57:29.94,csapp,,0,0,0,,and if they're equal it says fine
Dialogue: 0,0:57:30.34,0:57:35.54,csapp,,0,0,0,, but if they're not equal it's detecting this got corrupted so just like the canary in the coalmine
Dialogue: 0,0:57:35.96,0:57:40.94,csapp,,0,0,0,,if these bytes get corrupted in any form it's an indication that something went wrong 
Dialogue: 0,0:57:42.42,0:57:48.52,csapp,,0,0,0,,now that example shows that if I have a seven characters string 
Dialogue: 0,0:57:48.88,0:57:51.34,csapp,,0,0,0,,then I'm not going to corrupt the canary 
Dialogue: 0,0:57:52.42,0:57:55.70,csapp,,0,0,0,,but you notice I just got away with an eight character string 
Dialogue: 0,0:57:57.62,0:58:03.20,csapp,,0,0,0,,so let me just see what's going on here
Dialogue: 0,0:58:30.60,0:58:32.54,csapp,,0,0,0,,okay I want a character e-string right 
Dialogue: 0,0:58:35.30,0:58:36.60,csapp,,0,0,0,,oh wait wait wait
Dialogue: 0,0:58:42.74,0:58:47.20,csapp,,0,0,0,,ah sorry I have to look I don't have the code in front of me so I have to look at
Dialogue: 0,0:58:52.98,0:59:00.20,csapp,,0,0,0,,so anyways here's where it's subtracting 24 from the stack pointer 
Dialogue: 0,0:59:00.76,0:59:04.80,csapp,,0,0,0,,and then the next instruction is retrieving this canary value 
Dialogue: 0,0:59:04.80,0:59:09.88,csapp,,0,0,0,,so let's figure out what the canary is right now we are at
Dialogue: 0,0:59:16.25,0:59:20.00,csapp,,0,0,0,,72f so we're at the first instruction here
Dialogue: 0,0:59:25.84,0:59:39.48,csapp,,0,0,0,,let's do another step
Dialogue: 0,0:59:40.06,0:59:41.74,csapp,,0,0,0,,so this is the canary 
Dialogue: 0,0:59:44.46,0:59:48.96,csapp,,0,0,0,,and it's you'll see actually when from one run to another you get a different value of it
Dialogue: 0,0:59:49.04,0:59:52.82,csapp,,0,0,0,,so it's purposely put in there in a way that it's unpredictable
Dialogue: 0,0:59:53.42,0:59:56.94,csapp,,0,0,0,, the one thing you'll notice is that the lower bite is zeroes 
Dialogue: 0,0:59:57.80,1:00:04.78,csapp,,0,0,0,,and so apparently they knew that it's so common to have suta off-by-one bugs with strings 
Dialogue: 0,1:00:04.78,1:00:08.42,csapp,,0,0,0,,where you don't allocate enough space for the null Terminator 
Dialogue: 0,1:00:08.82,1:00:10.46,csapp,,0,0,0,,that they said well rather
Dialogue: 0,1:00:10.94,1:00:16.08,csapp,,0,0,0,,than having a canary that will detect that bite being corrupted we'll just sort of give that bite away
Dialogue: 0,1:00:16.96,1:00:21.76,csapp,,0,0,0,, and so that's why it's letting me type in eight characters 
Dialogue: 0,1:00:21.84,1:00:26.28,csapp,,0,0,0,,and it's overriding this low order byte of the canary later on 
Dialogue: 0,1:00:26.76,1:00:28.96,csapp,,0,0,0,,but that's not going to affect anything
Dialogue: 0,1:00:53.44,1:00:59.60,csapp,,0,0,0,,strategic but let's give it a 9 characters 10 character string  a 9 character string
Dialogue: 0,1:01:52.17,1:01:54.78,csapp,,0,0,0,,all right charts mark
Dialogue: 0,1:01:55.12,1:02:01.14,csapp,,0,0,0,, oh well I'm not finding it where I thought it would be 
Dialogue: 0,1:02:01.34,1:02:08.58,csapp,,0,0,0,,anyways oh this will crop this deck 
Dialogue: 0,1:02:08.80,1:02:12.20,csapp,,0,0,0,,but what I showing you the main idea is the Canaries some value
Dialogue: 0,1:02:12.20,1:02:15.18,csapp,,0,0,0,, that gets pulled out and it will vary from one time to the next 
Dialogue: 0,1:02:16.00,1:02:20.72,csapp,,0,0,0,,and it's letting you get away with eight characters plus the null Terminator 
Dialogue: 0,1:02:20.92,1:02:23.90,csapp,,0,0,0,,but anything more and it will detect that corruption
Dialogue: 0,1:02:38.60,1:02:44.16,csapp,,0,0,0,,okay so now we've seen three different protection well for one is write better code 
Dialogue: 0,1:02:46.30,1:02:51.50,csapp,,0,0,0,,but there's three protections that are done by the system that have nothing to do with your code
Dialogue: 0,1:02:51.74,1:02:58.24,csapp,,0,0,0,, right one is to randomize the stack position 
Dialogue: 0,1:02:58.26,1:03:01.20,csapp,,0,0,0,,so it's harder to figure out where the start addresses are 
Dialogue: 0,1:03:01.72,1:03:07.48,csapp,,0,0,0,,the second is to make the stack so it's not executable so you can't put code on that 
Dialogue: 0,1:03:08.04,1:03:12.20,csapp,,0,0,0,,and then the third is to use a stack canary or other mechanisms to detect
Dialogue: 0,1:03:13.00,1:03:15.68,csapp,,0,0,0,, a potential buffer overflow at the source 
Dialogue: 0,1:03:16.94,1:03:22.34,csapp,,0,0,0,,so now there's another attack that was developed in response to some of these 
Dialogue: 0,1:03:25.00,1:03:30.02,csapp,,0,0,0,,that is still often successful it's called return I did programming 
Dialogue: 0,1:03:30.42,1:03:33.26,csapp,,0,0,0,,and for your attack lab you're going to be doing these attacks too
Dialogue: 0,1:03:33.26,1:03:36.10,csapp,,0,0,0,,that's why the attack lab is different than the old lab
Dialogue: 0,1:03:36.10,1:03:41.22,csapp,,0,0,0,,way of the old web justed code injection exploits now you're doing both code injection 
Dialogue: 0,1:03:41.79,1:03:43.56,csapp,,0,0,0,,and return oriented programming 
Dialogue: 0,1:03:44.38,1:03:51.12,csapp,,0,0,0,,so the idea this is if you are a hacker you're frustrated 
Dialogue: 0,1:03:51.12,1:03:58.72,csapp,,0,0,0,,because of these these three techniques stack randomization non-executable stack and Canaries
Dialogue: 0,1:03:59.10,1:04:07.48,csapp,,0,0,0,, well I can't fix the canary problem that actually the canary is a pretty secure technique
Dialogue: 0,1:04:07.58,1:04:12.28,csapp,,0,0,0,, there's very I've never seen anyone able to bypass a stet canary 
Dialogue: 0,1:04:13.04,1:04:15.90,csapp,,0,0,0,,but the other two you can do it using this technique 
Dialogue: 0,1:04:16.44,1:04:20.48,csapp,,0,0,0,,and the strategy is so we don't know where the stack is
Dialogue: 0,1:04:21.42,1:04:23.26,csapp,,0,0,0,, but we could still 
Dialogue: 0,1:04:24.04,1:04:27.74,csapp,,0,0,0,,but we know where the code is because you saw in that example the code 
Dialogue: 0,1:04:28.26,1:04:33.94,csapp,,0,0,0,,my layout randomization was shifting the stack positions in the heap positions 
Dialogue: 0,1:04:34.54,1:04:40.34,csapp,,0,0,0,,but it wasn't changing either global variables or or the code itself
Dialogue: 0,1:04:41.32,1:04:50.04,csapp,,0,0,0,,so what if I can find some code that sort of already there in the existing part of the program 
Dialogue: 0,1:04:50.60,1:04:55.30,csapp,,0,0,0,,and I'll use that instead of my own code that I've injected 
Dialogue: 0,1:04:55.98,1:05:00.94,csapp,,0,0,0,,and of course in general you're not going to find exactly lying there the exact program 
Dialogue: 0,1:05:00.94,1:05:05.76,csapp,,0,0,0,,you want to execute that will cause whatever harm you intend to do 
Dialogue: 0,1:05:06.50,1:05:09.74,csapp,,0,0,0,,because that's not usually compiled into most programs 
Dialogue: 0,1:05:09.76,1:05:15.34,csapp,,0,0,0,,but if I could set a string together little segments of code 
Dialogue: 0,1:05:15.90,1:05:22.54,csapp,,0,0,0,,and somehow put together a series of little sequences of code
Dialogue: 0,1:05:22.78,1:05:24.86,csapp,,0,0,0,, maybe I can get something useful done 
Dialogue: 0,1:05:25.54,1:05:28.38,csapp,,0,0,0,,and so that's the idea of this return oriented programming 
Dialogue: 0,1:05:28.94,1:05:33.38,csapp,,0,0,0,,and the idea of it is to find what are known as gadgets 
Dialogue: 0,1:05:34.28,1:05:40.52,csapp,,0,0,0,,and a gadget is a sequence of bytes  that are represent part of the executable program
Dialogue: 0,1:05:40.86,1:05:47.38,csapp,,0,0,0,, where the last byte this is x86 talking here  has a hex value c3 
Dialogue: 0,1:05:47.60,1:05:56.64,csapp,,0,0,0,,which is how the RET instruction the return instruction is encoded  in x86 both ia-32 and x64 
Dialogue: 0,1:05:59.04,1:06:01.32,csapp,,0,0,0,,and so as an example
Dialogue: 0,1:06:02.20,1:06:05.48,csapp,,0,0,0,,on the easy case is where there's some function 
Dialogue: 0,1:06:07.00,1:06:12.96,csapp,,0,0,0,,and it implements some operation that I might find useful as an attacker to be able to do 
Dialogue: 0,1:06:13.48,1:06:18.16,csapp,,0,0,0,,so for example this function is computing a times B plus C 
Dialogue: 0,1:06:18.94,1:06:25.64,csapp,,0,0,0,,and if I look at just the last two instructions from there one of them is a la which is performing addition 
Dialogue: 0,1:06:26.50,1:06:29.58,csapp,,0,0,0,,and the other is doing a return 
Dialogue: 0,1:06:29.92,1:06:33.90,csapp,,0,0,0,,so I can think of this this good old five bunk byte chunk
Dialogue: 0,1:06:34.26,1:06:40.24,csapp,,0,0,0,, is a way if I could get some data in registers R di and RDX 
Dialogue: 0,1:06:40.92,1:06:44.34,csapp,,0,0,0,,then I could compute their sum and stick it in %rax
Dialogue: 0,1:06:44.48,1:06:47.12,csapp,,0,0,0,,so imagine taking your program you're trying to execute 
Dialogue: 0,1:06:47.46,1:06:49.40,csapp,,0,0,0,,and breaking it up into these good old fragments 
Dialogue: 0,1:06:49.76,1:06:55.10,csapp,,0,0,0,,and you want to somehow find little block of code somewhere to implement each of these fragments
Dialogue: 0,1:06:55.96,1:07:00.52,csapp,,0,0,0,, and then the interesting part is because they each end in C 3 this return
Dialogue: 0,1:07:00.84,1:07:04.50,csapp,,0,0,0,, it has is it well let me get to that in it 
Dialogue: 0,1:07:05.12,1:07:10.96,csapp,,0,0,0,,so that's sort of the obvious way that you pull out this is an addition which you'd expect 
Dialogue: 0,1:07:10.96,1:07:13.04,csapp,,0,0,0,,because that was in the original C code 
Dialogue: 0,1:07:13.92,1:07:19.52,csapp,,0,0,0,,but here's an example of a gadget that has nothing to do with the original C code 
Dialogue: 0,1:07:19.80,1:07:26.14,csapp,,0,0,0,,it just happens to match the bite pattern of of some existing code 
Dialogue: 0,1:07:26.66,1:07:36.04,csapp,,0,0,0,,so this function seems to not do anything too terribly useful  from a hackers point of view 
Dialogue: 0,1:07:36.70,1:07:39.46,csapp,,0,0,0,,but if you look at this particular byte sequence 
Dialogue: 0,1:07:39.56,1:07:43.82,csapp,,0,0,0,,that happens to encode the instruction move Q are %rax to %rdi
Dialogue: 0,1:07:44.56,1:07:46.44,csapp,,0,0,0,,and C 3 encodes repped 
Dialogue: 0,1:07:47.14,1:07:51.68,csapp,,0,0,0,,so and you can see if this is at address for d9
Dialogue: 0,1:07:52.26,1:07:55.48,csapp,,0,0,0,,that's for da for DB for DC
Dialogue: 0,1:07:55.50,1:08:00.06,csapp,,0,0,0,, so at address 4004DC
Dialogue: 0,1:08:00.48,1:08:06.84,csapp,,0,0,0,, if you could start executing here it would first do a move and then it would do a return 
Dialogue: 0,1:08:07.62,1:08:13.66,csapp,,0,0,0,,so I'm sort of taking advantage of the fact in x86 it's this buy donated instruction sequence 
Dialogue: 0,1:08:14.36,1:08:23.34,csapp,,0,0,0,,and if I sort of go off the aligned instructions I can often find useful things to do 
Dialogue: 0,1:08:24.48,1:08:25.96,csapp,,0,0,0,,so that's what's called a gadget 
Dialogue: 0,1:08:26.00,1:08:30.23,csapp,,0,0,0,,and you might ask well what's so special about having them end in a return
Dialogue: 0,1:08:30.86,1:08:36.06,csapp,,0,0,0,,well imagine I could fill up my buffer instead of with executable code
Dialogue: 0,1:08:36.48,1:08:39.58,csapp,,0,0,0,, I could fill it up with a series of gadget addresses 
Dialogue: 0,1:08:41.72,1:08:46.02,csapp,,0,0,0,,so each gadget then is some series of bytes where the final byte is c3 
Dialogue: 0,1:08:49.92,1:08:52.34,csapp,,0,0,0,,and I'll actually position this 
Dialogue: 0,1:08:53.10,1:08:56.18,csapp,,0,0,0,,and not the oppositionists at some place 
Dialogue: 0,1:08:56.18,1:09:02.22,csapp,,0,0,0,,where you're actually going to do the initial return instruction of from before 
Dialogue: 0,1:09:02.32,1:09:08.84,csapp,,0,0,0,,so if I can somehow get the program to return execute a rest 
Dialogue: 0,1:09:09.34,1:09:14.48,csapp,,0,0,0,,right now what it will do is return will pick an address off of the stack 
Dialogue: 0,1:09:15.08,1:09:18.02,csapp,,0,0,0,,pop an address and begin executing
Dialogue: 0,1:09:18.02,1:09:20.14,csapp,,0,0,0,,so that will start this code executing
Dialogue: 0,1:09:20.50,1:09:23.58,csapp,,0,0,0,,and it will hit the c3 the RET instruction at the end 
Dialogue: 0,1:09:24.24,1:09:29.18,csapp,,0,0,0,,which will again take a address pop it off the stack and begin executing 
Dialogue: 0,1:09:29.20,1:09:31.92,csapp,,0,0,0,,so we'll start executing the second gadget 
Dialogue: 0,1:09:32.26,1:09:38.68,csapp,,0,0,0,,and so you'll see what will happen is we're effectively concatenating these pieces of code together 
Dialogue: 0,1:09:38.98,1:09:44.24,csapp,,0,0,0,,where it's using a rep to get from one part the end of one gadget to the start of the next 
Dialogue: 0,1:09:44.82,1:09:47.40,csapp,,0,0,0,,and so that's why it's called return oriented programming
Dialogue: 0,1:09:47.88,1:09:52.64,csapp,,0,0,0,,it's a way to instead of sequencing programs using a program counter like you normally do 
Dialogue: 0,1:09:53.16,1:09:59.42,csapp,,0,0,0,,your sequencing programs using the sort of peculiar behavior of this particular x86 
Dialogue: 0,1:10:00.68,1:10:04.62,csapp,,0,0,0,,how returns work and in that program 
Dialogue: 0,1:10:04.84,1:10:09.80,csapp,,0,0,0,,and remember there's enough x86 out there that if I can find a way to attack them 
Dialogue: 0,1:10:10.36,1:10:14.18,csapp,,0,0,0,,I'm in pretty I'm in a pretty good place
Dialogue: 0,1:10:15.50,1:10:19.32,csapp,,0,0,0,, it's also possible to attack other processors this way -
Dialogue: 0,1:10:19.32,1:10:22.12,csapp,,0,0,0,, it's just particularly nice on x86
Dialogue: 0,1:10:23.06,1:10:25.60,csapp,,0,0,0,,so that's the idea of return oriented programming 
Dialogue: 0,1:10:25.60,1:10:33.24,csapp,,0,0,0,,and you'll do this yourself you'll find gadgets string them together to do different things in the attack way 
Dialogue: 0,1:10:35.60,1:10:42.70,csapp,,0,0,0,,but I'll point out that this still doesn't so that 
Dialogue: 0,1:10:43.40,1:10:52.16,csapp,,0,0,0,,this stack canary idea is still successful detecting a buffer overflows  fairly effectively 
Dialogue: 0,1:10:52.16,1:10:54.82,csapp,,0,0,0,,so in your attack lab for example 
Dialogue: 0,1:10:55.22,1:11:00.68,csapp,,0,0,0,,we've carefully compiled the code to make it vulnerable to these attacks 
Dialogue: 0,1:11:01.62,1:11:05.16,csapp,,0,0,0,,otherwise it would be a lot harder web 
Dialogue: 0,1:11:05.78,1:11:12.34,csapp,,0,0,0,,like if you could do this you could probably go into the dark world and be very successful 
Dialogue: 0,1:11:15.34,1:11:21.48,csapp,,0,0,0,,so we're actually sort of exposing the vulnerability 
Dialogue: 0,1:11:21.48,1:11:26.22,csapp,,0,0,0,,but in the the first part of the lab you're using code injection attacks 
Dialogue: 0,1:11:26.22,1:11:31.78,csapp,,0,0,0,,so we've had to disable stack randomization and also make the stack X cutable 
Dialogue: 0,1:11:32.26,1:11:39.32,csapp,,0,0,0,,so we had to sort of button the return rated programming  we reenable that 
Dialogue: 0,1:11:39.50,1:11:44.62,csapp,,0,0,0,,so that the stack is not executable it keeps jumping around randomly 
Dialogue: 0,1:11:45.22,1:11:47.62,csapp,,0,0,0,,but we've turned off the stack canary 
Dialogue: 0,1:11:47.62,1:11:49.84,csapp,,0,0,0,,so you'll be able to overflow the buffer
Dialogue: 0,1:11:50.48,1:11:55.68,csapp,,0,0,0,,and put in your gadget addresses and build up attacks that way 
Dialogue: 0,1:11:57.48,1:12:02.78,csapp,,0,0,0,,so I think you'll find by actually doing it you'll earn a lot more than you can by just hearing about it 
Dialogue: 0,1:12:05.10,1:12:07.44,csapp,,0,0,0,,oh you might ask why do we teach you this stuff right 
Dialogue: 0,1:12:07.96,1:12:10.54,csapp,,0,0,0,,and if we supposed to teach you to be good and not evil 
Dialogue: 0,1:12:11.12,1:12:17.86,csapp,,0,0,0,, well there's a couple reasons one is you're going to learn a lot about machine program execution 
Dialogue: 0,1:12:18.10,1:12:22.12,csapp,,0,0,0,,and how stacks work and how byte instructions are encoded and stuff like that 
Dialogue: 0,1:12:22.64,1:12:28.42,csapp,,0,0,0,,you'll use the tools GDB object dump and all those even more than you did with the bomb lab
Dialogue: 0,1:12:28.42,1:12:34.72,csapp,,0,0,0,,so you'll learn a lot the other is we assume that you will work for forces of 
Dialogue: 0,1:12:34.72,1:12:40.86,csapp,,0,0,0,, but to be a good person you also know what the bet have to know what the bad people do 
Dialogue: 0,1:12:40.86,1:12:48.44,csapp,,0,0,0,,so part of it is to become more effective as a force for good 
Dialogue: 0,1:12:51.44,1:12:54.80,csapp,,0,0,0,,okay so the final thing to talk about today is unions
Dialogue: 0,1:12:55.58,1:13:02.00,csapp,,0,0,0,, and the observation about a union NC is the Declaration of it looks a lot like a struct 
Dialogue: 0,1:13:03.14,1:13:07.04,csapp,,0,0,0,,where there's these different fields and they're named and they can have different types
Dialogue: 0,1:13:07.06,1:13:11.38,csapp,,0,0,0,, and there can be pointers to unions and all that stuff 
Dialogue: 0,1:13:11.86,1:13:14.52,csapp,,0,0,0,,but they're actually totally different what they do 
Dialogue: 0,1:13:15.08,1:13:21.22,csapp,,0,0,0,,you recall with a struct what happens is it allocates enough memory for all the fields to coexist
Dialogue: 0,1:13:22.30,1:13:28.32,csapp,,0,0,0,, and potentially adding padding bytes for what a union does is it 
Dialogue: 0,1:13:29.20,1:13:33.40,csapp,,0,0,0,,only K allocates enough storage for the maximum field in it 
Dialogue: 0,1:13:33.74,1:13:37.20,csapp,,0,0,0,,and it assumes that you're only going to be using one of the possible fields 
Dialogue: 0,1:13:37.76,1:13:43.60,csapp,,0,0,0,,and it will literally a store on top of it these fields get stored on top of each other 
Dialogue: 0,1:13:43.60,1:13:49.50,csapp,,0,0,0,,so that if you try to use multiple fields you can mess things up
Dialogue: 0,1:13:50.18,1:13:52.88,csapp,,0,0,0,,and it's not for that purpose of doing multiple values 
Dialogue: 0,1:13:52.88,1:13:57.66,csapp,,0,0,0,,it's for the purpose of for example if I know I'm only going to use one of these 
Dialogue: 0,1:13:58.20,1:14:05.28,csapp,,0,0,0,,or it's another also a way to create essentially an alias that will let you reference memory in different ways 
Dialogue: 0,1:14:07.02,1:14:11.10,csapp,,0,0,0,,so for example in your data lab you are using 
Dialogue: 0,1:14:12.44,1:14:18.16,csapp,,0,0,0,,you were manipulating the bit level representations of floating point numbers 
Dialogue: 0,1:14:18.74,1:14:22.88,csapp,,0,0,0,,and in our code that would then convert that to an actual float 
Dialogue: 0,1:14:23.22,1:14:24.66,csapp,,0,0,0,,we used a union 
Dialogue: 0,1:14:25.20,1:14:33.32,csapp,,0,0,0,,where the Union is either to view this field of four bytes is an unsigned or is a float 
Dialogue: 0,1:14:33.76,1:14:46.69,csapp,,0,0,0,,and so I can convert from unsigned to its float representation by just storing the unsigned value  in this Union 
Dialogue: 0,1:14:46.88,1:14:48.92,csapp,,0,0,0,,and retrieving it as if it were float 
Dialogue: 0,1:14:49.36,1:14:53.64,csapp,,0,0,0,,and this is a fundamentally different operation than casting
Dialogue: 0,1:14:53.64,1:14:57.68,csapp,,0,0,0,, because you recall when you take a unsigned value and you cast it to a float 
Dialogue: 0,1:14:58.02,1:14:59.28,csapp,,0,0,0,,you actually change the bits 
Dialogue: 0,1:14:59.32,1:15:07.27,csapp,,0,0,0,,you change it into the floating point number that's the closest a match to this particular number
Dialogue: 0,1:15:07.27,1:15:11.22,csapp,,0,0,0,, it would be the equivalent of the function you implemented float underscore u2f 
Dialogue: 0,1:15:12.14,1:15:17.94,csapp,,0,0,0,,but this one actually doesn't change bits it just changes the numeric value changes quite a bit 
Dialogue: 0,1:15:19.04,1:15:26.80,csapp,,0,0,0,,so it's a useful technique to do that to be able to override the the type system and get two bit representations 
Dialogue: 0,1:15:28.78,1:15:32.54,csapp,,0,0,0,,and this actually turns out to be one of the places to where byte ordering 
Dialogue: 0,1:15:32.54,1:15:35.62,csapp,,0,0,0,,will show up in programs if you're not careful 
Dialogue: 0,1:15:37.36,1:15:42.44,csapp,,0,0,0,,so in particular with this Union I can view a block of eight bytes 
Dialogue: 0,1:15:42.46,1:15:49.06,csapp,,0,0,0,,as either eight characters for shorts two ents or one long 
Dialogue: 0,1:15:49.64,1:15:53.88,csapp,,0,0,0,,and on a 64-bit machine like is shown here where along is 64 bits 
Dialogue: 0,1:15:54.54,1:16:03.32,csapp,,0,0,0,,you'll see that you're you're able to look at things as either as a the individual bites making it up
Dialogue: 0,1:16:04.00,1:16:07.44,csapp,,0,0,0,, or some longer aggregation of those bites 
Dialogue: 0,1:16:08.56,1:16:11.94,csapp,,0,0,0,,and you'll actually find that depending on what machine you run it on 
Dialogue: 0,1:16:12.34,1:16:17.32,csapp,,0,0,0,,you'll get a different result because of the byte ordering of the different machines 
Dialogue: 0,1:16:17.88,1:16:22.50,csapp,,0,0,0,,so this goes through it what happens when you run on different machines 
Dialogue: 0,1:16:23.28,1:16:26.42,csapp,,0,0,0,,but you'll you'll notice in particular that 
Dialogue: 0,1:16:27.92,1:16:31.28,csapp,,0,0,0,,on an i-32 machine a 32-bit machine
Dialogue: 0,1:16:33.62,1:16:38.92,csapp,,0,0,0,, it's coming off in in this byte pattern f3f2f1f0 
Dialogue: 0,1:16:39.94,1:16:46.34,csapp,,0,0,0,,and on a Sun back when they existed you'd get the opposite because of the byte ordering 
Dialogue: 0,1:16:47.06,1:16:50.60,csapp,,0,0,0,,and now on an x86 64 where a 
Dialogue: 0,1:16:51.20,1:16:57.60,csapp,,0,0,0,,along is 64 bits you get eight bytes 
Dialogue: 0,1:16:58.20,1:17:02.42,csapp,,0,0,0,,and you can also determine from this if you look carefully that it's in 
Dialogue: 0,1:17:02.84,1:17:07.28,csapp,,0,0,0,,it's a little endian order because this is the we significant byte is F 0 
Dialogue: 0,1:17:08.10,1:17:10.30,csapp,,0,0,0,,which is the first byte F 0
Dialogue: 0,1:17:11.12,1:17:16.68,csapp,,0,0,0,, so it's also way to to get to the low level bytes
Dialogue: 0,1:17:16.74,1:17:23.06,csapp,,0,0,0,, but when you use this kind of thing you're sort of intentionally telling the  the C compiler
Dialogue: 0,1:17:23.62,1:17:27.76,csapp,,0,0,0,, trust me I know what I'm doing you don't have to protect me from myself 
Dialogue: 0,1:17:28.14,1:17:30.92,csapp,,0,0,0,,and so if you're not careful you can write code where 
Dialogue: 0,1:17:30.92,1:17:33.40,csapp,,0,0,0,,because of a byte ordering problem or something like that 
Dialogue: 0,1:17:33.80,1:17:36.64,csapp,,0,0,0,, won't run properly on some machines
Dialogue: 0,1:17:38.36,1:17:41.12,csapp,,0,0,0,, so just to summarize then we looked on it
Dialogue: 0,1:17:41.70,1:17:44.92,csapp,,0,0,0,,we've looked then at the three compound types in C
Dialogue: 0,1:17:44.92,1:17:48.80,csapp,,0,0,0,, the ways you can aggregate smaller types into larger ones 
Dialogue: 0,1:17:48.80,1:17:54.56,csapp,,0,0,0,,you can make an array of identical elements indexed by a number the position 
Dialogue: 0,1:17:54.90,1:18:00.76,csapp,,0,0,0,,and that usually turns into some kind of scaled computation to get to the particular place 
Dialogue: 0,1:18:01.60,1:18:05.66,csapp,,0,0,0,,we've seen structures where it's a fixed number of fields 
Dialogue: 0,1:18:06.16,1:18:09.82,csapp,,0,0,0,,but the fields can be of different type and the reference by their names
Dialogue: 0,1:18:10.20,1:18:14.92,csapp,,0,0,0,,and that usually turns into some type of displacement off of the original position 
Dialogue: 0,1:18:15.58,1:18:21.76,csapp,,0,0,0,,and then a union is just a way of sort of piling up in one place 
Dialogue: 0,1:18:21.91,1:18:24.48,csapp,,0,0,0,,of what a number of different fields 
Dialogue: 0,1:18:24.76,1:18:28.38,csapp,,0,0,0,,and so all it does is ellicott the maximum number of bytes 
Dialogue: 0,1:18:28.72,1:18:33.14,csapp,,0,0,0,,for that and doesn't create enough space for them all to be there at the same time 
Dialogue: 0,1:18:34.94,1:18:40.19,csapp,,0,0,0,,okay that's it for today then [Applause]
