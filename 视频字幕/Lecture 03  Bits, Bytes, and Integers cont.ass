[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video File: ../../../Desktop/csapp/Lecture 03  Bits, Bytes, and Integers cont.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 832
Active Line: 843
Video Position: 137556

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FF0000,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.04,csapp,,0,0,0,,I guess one thing I I and the rest of the staff request is that you
Dialogue: 0,0:00:05.60,0:00:08.90,csapp,,0,0,0,, whenever you have a question you first read the book.
Dialogue: 0,0:00:08.90,0:00:14.44,csapp,,0,0,0,,then you reread the assignment and you maybe reread it again and then you ask us
Dialogue: 0,0:00:14.44,0:00:18.02,csapp,,0,0,0,, because a lot of the questions we're getting are ones 
Dialogue: 0,0:00:18.02,0:00:21.42,csapp,,0,0,0,,where we just say look at this page of the book 
Dialogue: 0,0:00:21.42,0:00:23.92,csapp,,0,0,0,,look at this paragraph of the assignment  
Dialogue: 0,0:00:24.30,0:00:27.92,csapp,,0,0,0,,look at this part of the file that you were given
Dialogue: 0,0:00:28.40,0:00:34.12,csapp,,0,0,0,, and so I mean there's a lot of stuff and I understand how
Dialogue: 0,0:00:34.16,0:00:38.40,csapp,,0,0,0,,sometimes it's easy to miss things so not saying don't ever ask questions
Dialogue: 0,0:00:38.40,0:00:41.90,csapp,,0,0,0,, but just before you ask your questions try and figure out
Dialogue: 0,0:00:41.90,0:00:46.84,csapp,,0,0,0,,if I really should have come through the resources I have available to see
Dialogue: 0,0:00:46.84,0:00:49.62,csapp,,0,0,0,, if the answer to my question is can be found there
Dialogue: 0,0:00:50.38,0:00:54.54,csapp,,0,0,0,, so anyways enjoy the lab 
Dialogue: 0,0:00:55.38,0:01:02.32,csapp,,0,0,0,,so today is a suit a second part of a two-part lecture on integers and integer arithmetic
Dialogue: 0,0:01:02.32,0:01:05.98,csapp,,0,0,0,, last time we looked at representations about
Dialogue: 0,0:01:05.98,0:01:12.52,csapp,,0,0,0,, how bit patterns can be interpreted is either of unsigned numbers meaning
Dialogue: 0,0:01:12.52,0:01:17.94,csapp,,0,0,0,, they range between 0 and 2 to the word size minus 1 
Dialogue: 0,0:01:18.62,0:01:24.28,csapp,,0,0,0,,or as two's complement numbers which is the most compliment usual way to represent 
Dialogue: 0,0:01:24.28,0:01:26.16,csapp,,0,0,0,,what are sometimes called signed numbers ones
Dialogue: 0,0:01:26.54,0:01:28.56,csapp,,0,0,0,,ones it can be either negative or positive
Dialogue: 0,0:01:29.08,0:01:33.00,csapp,,0,0,0,,and by the way there are other ways to represent signed numbers out there but
Dialogue: 0,0:01:33.38,0:01:38.72,csapp,,0,0,0,,two's complement is so so overwhelmingly the most used system 
Dialogue: 0,0:01:38.72,0:01:40.40,csapp,,0,0,0,,that that's what we concentrate on 
Dialogue: 0,0:01:41.50,0:01:46.14,csapp,,0,0,0,,today what we'll do is that now go beyond the representations of 
Dialogue: 0,0:01:46.14,0:01:51.08,csapp,,0,0,0,,these values to talk about arithmetic operations on them and some of their properties
Dialogue: 0,0:01:52.50,0:01:56.12,csapp,,0,0,0,, and what we'll do in general is talk about the unsigned case
Dialogue: 0,0:01:56.12,0:01:59.90,csapp,,0,0,0,, which is in some ways easier to understand and more intuitive
Dialogue: 0,0:02:00.16,0:02:02.24,csapp,,0,0,0,, and then talk about the two's complement case
Dialogue: 0,0:02:02.96,0:02:05.52,csapp,,0,0,0,, so the basic rule on this is 
Dialogue: 0,0:02:05.70,0:02:13.80,csapp,,0,0,0,,if you take two numbers that range between up to the maximum value of an unsigned number
Dialogue: 0,0:02:13.80,0:02:20.10,csapp,,0,0,0,,add them that in principle you might need to get an extra bit to represent that sum
Dialogue: 0,0:02:20.10,0:02:24.70,csapp,,0,0,0,, if you want to represent the true sum the sort of integer sum of those two numbers 
Dialogue: 0,0:02:25.32,0:02:27.02,csapp,,0,0,0,,because you've doubling it 
Dialogue: 0,0:02:27.18,0:02:33.68,csapp,,0,0,0,,and unfortunately we can't just go out and add more bits to your computer indefinitely
Dialogue: 0,0:02:33.68,0:02:36.66,csapp,,0,0,0,,so we just stop it at some point and say
Dialogue: 0,0:02:37.04,0:02:42.38,csapp,,0,0,0,, well whatever bit happened to be in that sort of next bit position
Dialogue: 0,0:02:42.38,0:02:45.04,csapp,,0,0,0,, we're just going to drop it and pretend it doesn't exist
Dialogue: 0,0:02:45.66,0:02:50.86,csapp,,0,0,0,, and say that the result of addition is just whatever the W bit pattern you get 
Dialogue: 0,0:02:51.26,0:02:54.06,csapp,,0,0,0,,if you only consider the first W bits out of it 
Dialogue: 0,0:02:54.80,0:03:00.02,csapp,,0,0,0,,with no warning no messages no error
Dialogue: 0,0:03:00.02,0:03:02.74,csapp,,0,0,0,, or anything this is just it happens silently
Dialogue: 0,0:03:04.68,0:03:12.68,csapp,,0,0,0,, so for a T's complement this is not such a hard thing to understand
Dialogue: 0,0:03:12.88,0:03:15.40,csapp,,0,0,0,, it can be thought of as just modular arithmetic
Dialogue: 0,0:03:15.58,0:03:18.40,csapp,,0,0,0,, computing modulo the two to the word size
Dialogue: 0,0:03:18.88,0:03:23.04,csapp,,0,0,0,, so I'm going to use some examples and this time I've got them worked out a little more carefully
Dialogue: 0,0:03:23.04,0:03:25.54,csapp,,0,0,0,,so I won't get mixed up as much 
Dialogue: 0,0:03:25.90,0:03:28.74,csapp,,0,0,0,,and we'll use a word size of 4 here 
Dialogue: 0,0:03:29.02,0:03:36.04,csapp,,0,0,0,,and as I mentioned last time it really helps with this to work do the examples with small word sizes 
Dialogue: 0,0:03:36.44,0:03:41.10,csapp,,0,0,0,,to get a your intuition for it rather than trying to write out 
Dialogue: 0,0:03:41.10,0:03:44.62,csapp,,0,0,0,,32-bit numbers or 64-bit numbers is something like that
Dialogue: 0,0:03:45.16,0:03:47.42,csapp,,0,0,0,, so if you think about in the unsigned case
Dialogue: 0,0:03:52.24,0:04:03.32,csapp,,0,0,0,, a 4-bit number means that it will range between 0 and 2^4-1 or 15 right
Dialogue: 0,0:04:04.00,0:04:09.44,csapp,,0,0,0,,so let's just do a few examples of cases where it overflows
Dialogue: 0,0:04:10.83,0:04:14.68,csapp,,0,0,0,, so if you add 13 to 5
Dialogue: 0,0:04:20.80,0:04:23.38,csapp,,0,0,0,,first of all you know I assume already that 
Dialogue: 0,0:04:23.38,0:04:26.32,csapp,,0,0,0,,you just add binary numbers the way you learned in school 
Dialogue: 0,0:04:26.80,0:04:31.38,csapp,,0,0,0,,of just doing carries and so forth except it's all modulo two 
Dialogue: 0,0:04:31.38,0:04:41.74,csapp,,0,0,0,,so this is 0 carry 1 1, 0  carry 1,0 carry 1.
Dialogue: 0,0:04:42.56,0:04:48.66,csapp,,0,0,0,,so in principle to represent the sum which is this is five so to represent 18
Dialogue: 0,0:04:49.46,0:04:51.56,csapp,,0,0,0,,you need five bits not four 
Dialogue: 0,0:04:52.54,0:04:58.96,csapp,,0,0,0,,but we're just going to conveniently drop that number and say that this is actually a 2
Dialogue: 0,0:04:59.78,0:05:03.48,csapp,,0,0,0,,which of course is what 18 modules of 16 is
Dialogue: 0,0:05:04.76,0:05:07.44,csapp,,0,0,0,,so the unsigned case is really pretty straightforward
Dialogue: 0,0:05:12.80,0:05:15.98,csapp,,0,0,0,,and we can visualize this in this pictures in the book too
Dialogue: 0,0:05:16.64,0:05:22.54,csapp,,0,0,0,, by seeing if you are representing on the x and y axis 
Dialogue: 0,0:05:22.54,0:05:29.90,csapp,,0,0,0,,what they call U and V are values between 0 and 15 the range of possible unsigned numbers 
Dialogue: 0,0:05:30.24,0:05:34.68,csapp,,0,0,0,,and if we were to add those we could get a sum that's up to as much as 30
Dialogue: 0,0:05:35.88,0:05:39.52,csapp,,0,0,0,,which would in principle require five bits to represent
Dialogue: 0,0:05:40.72,0:05:45.16,csapp,,0,0,0,, but what we'll do is we'll just by dropping that most significant bit 
Dialogue: 0,0:05:45.16,0:05:47.00,csapp,,0,0,0,,what we do is sort of create a cliff 
Dialogue: 0,0:05:47.52,0:05:51.24,csapp,,0,0,0,,that when you roll over from 15 to 16
Dialogue: 0,0:05:51.44,0:05:53.84,csapp,,0,0,0,, instead it drops all the way down to 0 
Dialogue: 0,0:05:54.34,0:05:56.58,csapp,,0,0,0,,and that's referred to as an overflow
Dialogue: 0,0:05:57.24,0:06:02.92,csapp,,0,0,0,, and then from there we'll build up to the maximum value here will be 14
Dialogue: 0,0:06:03.20,0:06:06.06,csapp,,0,0,0,, which is 30 - 16 
Dialogue: 0,0:06:06.28,0:06:10.24,csapp,,0,0,0,,so what we've done is basically as this picture shows when we overflow
Dialogue: 0,0:06:10.78,0:06:15.18,csapp,,0,0,0,, we effectively subtract off 2^W from the sum
Dialogue: 0,0:06:15.70,0:06:20.20,csapp,,0,0,0,, and keep it within the representable range of W bit numbers
Dialogue: 0,0:06:21.26,0:06:22.96,csapp,,0,0,0,, so that's an unsigned 
Dialogue: 0,0:06:24.02,0:06:28.66,csapp,,0,0,0,,two's complement,the first thing I want to convince you of
Dialogue: 0,0:06:29.06,0:06:34.92,csapp,,0,0,0,,is it two's complement addition looks just like a regular edition
Dialogue: 0,0:06:36.02,0:06:43.48,csapp,,0,0,0,, in other words I can perform a subtraction and addition of subtraction of numbers 
Dialogue: 0,0:06:43.74,0:06:47.38,csapp,,0,0,0,,by using this two's complement representation for negative numbers so
Dialogue: 0,0:06:48.04,0:06:51.40,csapp,,0,0,0,,so well let me just show you some examples of that 
Dialogue: 0,0:06:57.54,0:07:00.52,csapp,,0,0,0,,so first of all remember that what range of values 
Dialogue: 0,0:07:00.52,0:07:03.80,csapp,,0,0,0,,what's the smallest number that could be representatively the 4 bit 
Dialogue: 0,0:07:04.32,0:07:07.60,csapp,,0,0,0,,the most negative number 4 bit two's complement number
Dialogue: 0,0:07:09.10,0:07:10.10,csapp,,0,0,0,, -8 
Dialogue: 0,0:07:12.18,0:07:15.88,csapp,,0,0,0,,and the largest +7 thank you 
Dialogue: 0,0:07:18.70,0:07:21.96,csapp,,0,0,0,,so let's just do some examples if we took 
Dialogue: 0,0:07:26.64,0:07:33.98,csapp,,0,0,0,,this number 1 1 0 1 as a two's complement number is -3 
Dialogue: 0,0:07:35.12,0:07:43.26,csapp,,0,0,0,,and we add it to 5 five we'll get what we got before 
Dialogue: 0,0:07:51.50,0:07:56.26,csapp,,0,0,0,,and we're not good at we're going to ignore whatever carry bit it is and so the result is -
Dialogue: 0,0:07:58.06,0:08:00.40,csapp,,0,0,0,, I'm going behold that's what 5-3 
Dialogue: 0,0:08:00.40,0:08:04.00,csapp,,0,0,0,,so it seems like magic because it is
Dialogue: 0,0:08:05.98,0:08:09.12,csapp,,0,0,0,, Two's and that's why part of the reason why I choose complement is to
Dialogue: 0,0:08:09.28,0:08:12.46,csapp,,0,0,0,, the most commonly used way of representing signed numbers
Dialogue: 0,0:08:12.46,0:08:17.14,csapp,,0,0,0,,because the same hardware the same algorithms that are used for doing
Dialogue: 0,0:08:18.23,0:08:23.42,csapp,,0,0,0,,addition in work for either unsigned or two's complement numbers
Dialogue: 0,0:08:31.70,0:08:36.40,csapp,,0,0,0,,and this works as well just to show you
Dialogue: 0,0:08:36.84,0:08:42.28,csapp,,0,0,0,,if the overflow goes if the resulting thumb is goes the other way
Dialogue: 0,0:08:45.86,0:08:50.28,csapp,,0,0,0,, so if I have - 3 and - 5 and + 3 
Dialogue: 0,0:08:51.10,0:08:53.06,csapp,,0,0,0,,and I add those together
Dialogue: 0,0:09:03.58,0:09:07.64,csapp,,0,0,0,,ok,1 1 1 0 which is -2 
Dialogue: 0,0:09:10.16,0:09:16.56,csapp,,0,0,0,,so again if you use the same patterns for the same rule for addition
Dialogue: 0,0:09:17.62,0:09:22.10,csapp,,0,0,0,,as you do with the unsigned case you'll get two's complement arithmetic
Dialogue: 0,0:09:24.10,0:09:29.18,csapp,,0,0,0,, so what smoke in a few cases where the two's complement overflows
Dialogue: 0,0:09:36.04,0:09:55.02,csapp,,0,0,0,,so if we take -3 and -6 
Dialogue: 0,0:09:55.86,0:10:00.22,csapp,,0,0,0,,and we add them together we'll get 1 1 1 0 
Dialogue: 0,0:10:00.22,0:10:03.92,csapp,,0,0,0,,we're going to drop off the carry which is what?
Dialogue: 0,0:10:05.14,0:10:05.96,csapp,,0,0,0,,7 
Dialogue: 0,0:10:08.84,0:10:11.18,csapp,,0,0,0,,so we've added two negative numbers 
Dialogue: 0,0:10:11.70,0:10:16.46,csapp,,0,0,0,,and it's become positive and that's referred to as a negative overflow
Dialogue: 0,0:10:23.20,0:10:26.22,csapp,,0,0,0,, and the reason of course is the number -9
Dialogue: 0,0:10:26.90,0:10:32.72,csapp,,0,0,0,,I can't be represented in a 4-bit two's complement number so
Dialogue: 0,0:10:34.12,0:10:35.96,csapp,,0,0,0,, it  overflowed
Dialogue: 0,0:10:37.34,0:10:44.88,csapp,,0,0,0,,you'll notice that the +7 of cause differs from -9 by 16 and that's not next
Dialogue: 0,0:10:46.30,0:10:48.96,csapp,,0,0,0,,and then going the other direction
Dialogue: 0,0:10:49.26,0:11:09.20,csapp,,0,0,0,, if we had two large positive numbers so if we had 7 & 5
Dialogue: 0,0:11:09.54,0:11:11.86,csapp,,0,0,0,,we'll get -6 
Dialogue: 0,0:11:12.82,0:11:22.34,csapp,,0,0,0,,so this was 7 + 5 is -4   
Dialogue: 0,0:11:26.50,0:11:28.94,csapp,,0,0,0,,and so this is referred to as positive overflow 
Dialogue: 0,0:11:28.94,0:11:42.14,csapp,,0,0,0,,we've taken two positive numbers and added them together and gotten a negative result
Dialogue: 0,0:11:42.14,0:11:43.44,csapp,,0,0,0,, and you could see this
Dialogue: 0,0:11:43.44,0:11:49.20,csapp,,0,0,0,, by the way if you think about this addition we took 7 and 5 would be 12
Dialogue: 0,0:11:49.54,0:11:53.22,csapp,,0,0,0,,this is the bit level representation of twelve
Dialogue: 0,0:11:53.74,0:11:56.66,csapp,,0,0,0,, it's just that because this is now the sign bit 
Dialogue: 0,0:11:57.72,0:12:01.04,csapp,,0,0,0,,we think of that as -4 not +12 
Dialogue: 0,0:12:04.56,0:12:08.90,csapp,,0,0,0,,and so that's the the idea of two's complement overflow
Dialogue: 0,0:12:09.66,0:12:12.62,csapp,,0,0,0,,and you can see there's two different cases here 
Dialogue: 0,0:12:13.48,0:12:20.28,csapp,,0,0,0,,one is where the number that the sum was if we looked at the true sum 
Dialogue: 0,0:12:20.90,0:12:25.82,csapp,,0,0,0,,the number that you'd get for example twelve is too big to represent
Dialogue: 0,0:12:25.82,0:12:30.22,csapp,,0,0,0,,so when we think of that as a two's complement number it becomes now a negative number
Dialogue: 0,0:12:30.50,0:12:32.08,csapp,,0,0,0,, so that's positive overflow
Dialogue: 0,0:12:32.60,0:12:36.54,csapp,,0,0,0,, similarly if we have two negative numbers and we add them together
Dialogue: 0,0:12:36.54,0:12:40.84,csapp,,0,0,0,, so that the sum is too small to negative to represent 
Dialogue: 0,0:12:41.26,0:12:44.52,csapp,,0,0,0,,then those become positive numbers that's negative overflow
Dialogue: 0,0:12:45.24,0:12:47.22,csapp,,0,0,0,, and you can see that in this picture
Dialogue: 0,0:12:47.86,0:12:51.26,csapp,,0,0,0,, the same idea as before except there's three regions 
Dialogue: 0,0:12:51.86,0:12:59.58,csapp,,0,0,0,,this is the and by the way now you'll see our numbers range between -8 and +7 
Dialogue: 0,0:13:00.54,0:13:08.40,csapp,,0,0,0,,and the some two's complement also range between -8 and +7 
Dialogue: 0,0:13:09.56,0:13:14.86,csapp,,0,0,0,,but there's these three regions one is the where everything is fine
Dialogue: 0,0:13:15.86,0:13:18.64,csapp,,0,0,0,,it's within the representable range 
Dialogue: 0,0:13:18.98,0:13:25.72,csapp,,0,0,0,,the other is where the sum was so far toward the negative side that it becomes positive
Dialogue: 0,0:13:26.16,0:13:30.60,csapp,,0,0,0,, or where it's so high on the positive side that it becomes negative
Dialogue: 0,0:13:34.06,0:13:42.86,csapp,,0,0,0,,and so part of data lab you'll learn to understand these in quite precisely
Dialogue: 0,0:13:43.26,0:13:46.54,csapp,,0,0,0,, but then let's see idea it's a little bit counterintuitive to say 
Dialogue: 0,0:13:47.14,0:13:52.10,csapp,,0,0,0,,you know somehow I can accept the idea that modular arithmetic for unsigned numbers
Dialogue: 0,0:13:52.10,0:13:57.02,csapp,,0,0,0,,there's some sort of mathematical beauty to a modular arithmetic
Dialogue: 0,0:13:57.50,0:14:03.84,csapp,,0,0,0,, and this is looks like kind of useless right
Dialogue: 0,0:14:03.84,0:14:08.30,csapp,,0,0,0,, from a from operational characteristic 
Dialogue: 0,0:14:08.66,0:14:13.70,csapp,,0,0,0,,but it's the way it is and we're stuck with it
Dialogue: 0,0:14:15.90,0:14:19.36,csapp,,0,0,0,,and multiplication is basically the same idea
Dialogue: 0,0:14:19.36,0:14:22.56,csapp,,0,0,0,, in fact all the operations are the basically the same idea that
Dialogue: 0,0:14:22.98,0:14:25.29,csapp,,0,0,0,, if you can't represent it within the word size
Dialogue: 0,0:14:25.29,0:14:28.04,csapp,,0,0,0,,you just take the lower W bits 
Dialogue: 0,0:14:28.58,0:14:34.76,csapp,,0,0,0,,so all this complicated notation here is just a way of saying
Dialogue: 0,0:14:34.76,0:14:38.76,csapp,,0,0,0,, in principle if you take two W bit numbers and multiply them together
Dialogue: 0,0:14:39.32,0:14:45.66,csapp,,0,0,0,, you may need a the result may require as much as 2 times W bits to represent
Dialogue: 0,0:14:46.36,0:14:48.89,csapp,,0,0,0,, before addition its w+1
Dialogue: 0,0:14:49.38,0:14:51.40,csapp,,0,0,0,,multiplication you actually have to double
Dialogue: 0,0:14:51.40,0:14:54.64,csapp,,0,0,0,, because you're potentially squaring the largest number
Dialogue: 0,0:14:55.02,0:14:59.08,csapp,,0,0,0,,and so again we don't want to just keep 
Dialogue: 0,0:14:59.46,0:15:03.92,csapp,,0,0,0,,doubling our word size over and over again we'll run out of bits very quickly that way 
Dialogue: 0,0:15:04.20,0:15:07.08,csapp,,0,0,0,,and so we just truncate it at W bits 
Dialogue: 0,0:15:13.10,0:15:18.32,csapp,,0,0,0,,for the unsigned case it's again modular arithmetic
Dialogue: 0,0:15:18.32,0:15:21.92,csapp,,0,0,0,, it's something that you can kind of understand and believe 
Dialogue: 0,0:15:22.50,0:15:29.18,csapp,,0,0,0,,but for twos and so again let's just do a few examples
Dialogue: 0,0:15:29.18,0:15:35.32,csapp,,0,0,0,,and I won't try and work out multiplying in binary is like multiplying in decimal
Dialogue: 0,0:15:35.76,0:15:39.72,csapp,,0,0,0,,you do a big table and it takes a long time so I won't try to do that 
Dialogue: 0,0:15:40.30,0:15:44.30,csapp,,0,0,0,,but let me just show a few examples 
Dialogue: 0,0:15:53.68,0:15:59.20,csapp,,0,0,0,,so if I multiply 3 x 5 is of cause equal to 15 
Dialogue: 0,0:16:00.06,0:16:06.22,csapp,,0,0,0,,and in an unsigned number I can represent that right 
Dialogue: 0,0:16:06.80,0:16:08.46,csapp,,0,0,0,,so that's okay
Dialogue: 0,0:16:13.60,0:16:16.32,csapp,,0,0,0,,but if I multiply a 5x5
Dialogue: 0,0:16:22.40,0:16:25.40,csapp,,0,0,0,,then that would have representation 
Dialogue: 0,0:16:28.04,0:16:31.26,csapp,,0,0,0,,if I were to think about it as possibly as many as 8 bits 
Dialogue: 0,0:16:31.26,0:16:39.80,csapp,,0,0,0,,it would have a representation with an extra bit 
Dialogue: 0,0:16:40.50,0:16:42.42,csapp,,0,0,0,,and I'm going to throw this part away 
Dialogue: 0,0:16:42.74,0:16:44.40,csapp,,0,0,0,,and so I'd call that 9 
Dialogue: 0,0:16:45.28,0:16:47.98,csapp,,0,0,0,,which of cause is equal to 25 mod 16 
Dialogue: 0,0:16:54.84,0:17:01.16,csapp,,0,0,0,,and so that's the general idea of it is regardless of whatever's in this upper part of the word
Dialogue: 0,0:17:01.30,0:17:05.26,csapp,,0,0,0,,the product I'm just going to discard that and only look at the lower one
Dialogue: 0,0:17:05.78,0:17:09.70,csapp,,0,0,0,,and life gets a little more interesting with the two's complement case
Dialogue: 0,0:17:10.60,0:17:12.28,csapp,,0,0,0,, so let's look at what that does 
Dialogue: 0,0:17:14.98,0:17:16.86,csapp,,0,0,0,,and the answer is 
Dialogue: 0,0:17:18.24,0:17:19.94,csapp,,0,0,0,,even a little bit stranger 
Dialogue: 0,0:17:19.94,0:17:25.88,csapp,,0,0,0,,and that you not only trunk throw away whatever high order bits happen to be there
Dialogue: 0,0:17:26.34,0:17:32.42,csapp,,0,0,0,, but whatever bit gets left in this position will determine whether it's a positive or a negative result 
Dialogue: 0,0:17:33.45,0:17:39.88,csapp,,0,0,0,,even though with completely irrespective of the signs of the original two operands
Dialogue: 0,0:17:40.96,0:17:44.46,csapp,,0,0,0,,so that can make you go all over the place
Dialogue: 0,0:18:02.60,0:18:07.70,csapp,,0,0,0,,so if we had 5 x 4 of 20 
Dialogue: 0,0:18:08.94,0:18:24.08,csapp,,0,0,0,,that would be represented in this 8-bit form like so 
Dialogue: 0,0:18:24.68,0:18:28.92,csapp,,0,0,0,,and we just call that 4 right
Dialogue: 0,0:18:29.40,0:18:30.84,csapp,,0,0,0,,because we throwing this away
Dialogue: 0,0:18:31.34,0:18:41.64,csapp,,0,0,0,,but if we did 5 x 5 as we saw before that's represented like this
Dialogue: 0,0:18:50.22,0:18:51.38,csapp,,0,0,0,,and that sum
Dialogue: 0,0:18:52.72,0:18:54.08,csapp,,0,0,0,, now becomes 
Dialogue: 0,0:18:54.28,0:18:55.64,csapp,,0,0,0,,so we're throwing away this 
Dialogue: 0,0:18:56.08,0:19:02.08,csapp,,0,0,0,,and this becomes our sign bit so the result is a -8 + 1= -7
Dialogue: 0,0:19:05.70,0:19:11.38,csapp,,0,0,0,,so you see this is a similar to an example we showed at the beginning of the first lecture 
Dialogue: 0,0:19:11.38,0:19:16.18,csapp,,0,0,0,,that you can have two positive numbers and multiply them and get a negative result
Dialogue: 0,0:19:18.08,0:19:20.94,csapp,,0,0,0,,and because of the sort of quirks of this overflow
Dialogue: 0,0:19:20.94,0:19:21.66,csapp,,0,0,0,, question there.
Dialogue: 0,0:19:24.68,0:19:27.98,csapp,,0,0,0,,oh I'm just taking 25 and writing it in binary 
Dialogue: 0,0:19:30.28,0:19:34.68,csapp,,0,0,0,,yeah if you want to you know you start with the two numbers 
Dialogue: 0,0:19:36.82,0:19:40.62,csapp,,0,0,0,,I'm not going to do well actually this one's an easy one there's a trick for this 
Dialogue: 0,0:19:41.20,0:19:44.00,csapp,,0,0,0,,if you want to know multiply a number by a power of 2
Dialogue: 0,0:19:44.50,0:19:49.94,csapp,,0,0,0,,we're going to show that later you just shift it left by two positions
Dialogue: 0,0:19:54.92,0:19:56.22,csapp,,0,0,0,, so that one's an easy one 
Dialogue: 0,0:19:56.22,0:20:00.86,csapp,,0,0,0,,otherwise you have to write out the table and sum all the results and all that stuff 
Dialogue: 0,0:20:02.42,0:20:06.32,csapp,,0,0,0,,I prefer to what computers do that
Dialogue: 0,0:20:14.40,0:20:19.20,csapp,,0,0,0,,and again this two's complement stuff one interesting feature is 
Dialogue: 0,0:20:19.70,0:20:22.84,csapp,,0,0,0,,that it works for our negative numbers too 
Dialogue: 0,0:20:23.82,0:20:27.56,csapp,,0,0,0,,if you do this trick of throwing away the high-order bits 
Dialogue: 0,0:20:28.24,0:20:33.10,csapp,,0,0,0,,and you'll have overflow cases like before because you're throwing away information 
Dialogue: 0,0:20:33.10,0:20:38.74,csapp,,0,0,0,,but the lower bits if the number is representable you'll get the right result 
Dialogue: 0,0:20:38.74,0:20:41.64,csapp,,0,0,0,,so let me just demonstrate to that to you
Dialogue: 0,0:20:45.26,0:20:47.32,csapp,,0,0,0,, so this is -3 
Dialogue: 0,0:20:48.18,0:20:53.40,csapp,,0,0,0,,but you remember that this is equivalent to 13 as an unsigned number
Dialogue: 0,0:20:54.78,0:21:05.78,csapp,,0,0,0,,and this is -2 which is equivalent to 14 as an unsigned number 
Dialogue: 0,0:21:06.78,0:21:13.54,csapp,,0,0,0,,so now if we multiply 13 x 14 you get 182
Dialogue: 0,0:21:15.24,0:21:18.60,csapp,,0,0,0,, and that has a hex representation of B6
Dialogue: 0,0:21:28.76,0:21:34.24,csapp,,0,0,0,,and so just looking at the low-order for bits are 0 1 1 0 is 6 
Dialogue: 0,0:21:34.90,0:21:39.44,csapp,,0,0,0,,and indeed that's -3 x -2 is 6
Dialogue: 0,0:21:39.72,0:21:43.98,csapp,,0,0,0,,so the point being oh and I'm waving my hands here 
Dialogue: 0,0:21:43.98,0:21:46.60,csapp,,0,0,0,,because I don't want to go through all the details 
Dialogue: 0,0:21:46.92,0:21:50.80,csapp,,0,0,0,,but two's complement multiplication also gives you
Dialogue: 0,0:21:51.88,0:21:54.70,csapp,,0,0,0,,if you can do it using the exact same rules
Dialogue: 0,0:21:55.48,0:21:59.39,csapp,,0,0,0,, and as you do for unsigned multiplication the exact same hardware 
Dialogue: 0,0:21:59.74,0:22:04.88,csapp,,0,0,0,,I should mention that and there are instructions in the computer 
Dialogue: 0,0:22:04.88,0:22:09.10,csapp,,0,0,0,,in ways that you can get the upper word of a multiplication too 
Dialogue: 0,0:22:09.50,0:22:12.70,csapp,,0,0,0,,and those the bit patterns are different depending on whether 
Dialogue: 0,0:22:12.70,0:22:16.46,csapp,,0,0,0,,it's treated as a Two's complement number versus unsigned 
Dialogue: 0,0:22:16.46,0:22:20.64,csapp,,0,0,0,,so these typically different instructions for doing that computation
Dialogue: 0,0:22:20.94,0:22:27.72,csapp,,0,0,0,, but 99% of the time or more you just are looking at this lower part of the product 
Dialogue: 0,0:22:27.72,0:22:31.36,csapp,,0,0,0,,and that's the same whether it's a two's complement or an unsigned
Dialogue: 0,0:22:33.42,0:22:38.12,csapp,,0,0,0,, and it handles negative numbers positive but it has these overflow characteristics
Dialogue: 0,0:22:43.42,0:22:50.38,csapp,,0,0,0,,so as I was talking about there's a trick we can do for multiplying by a power-of-2
Dialogue: 0,0:22:50.80,0:22:52.98,csapp,,0,0,0,,which is just to shift the number to the left 
Dialogue: 0,0:22:53.32,0:22:56.42,csapp,,0,0,0,,and you'll often see that when you have in your code
Dialogue: 0,0:22:56.76,0:23:01.16,csapp,,0,0,0,, I want to multiply some number by 4 you'll write it in your C code 
Dialogue: 0,0:23:01.44,0:23:04.12,csapp,,0,0,0,,if you look at the assembly code you'll see that what
Dialogue: 0,0:23:04.18,0:23:08.42,csapp,,0,0,0,,the compiler generated is just says oh just shift it left by 2 
Dialogue: 0,0:23:09.22,0:23:11.98,csapp,,0,0,0,,so in general and you could see why this is true 
Dialogue: 0,0:23:11.98,0:23:34.04,csapp,,0,0,0,,by the way if you think of the number as the sum of the bits
Dialogue: 0,0:23:34.04,0:23:38.32,csapp,,0,0,0,,where X sub I is the if--but and X is the number it represents
Dialogue: 0,0:23:38.88,0:23:43.92,csapp,,0,0,0,,if I want to if I shift everything left by 2
Dialogue: 0,0:23:44.12,0:23:50.30,csapp,,0,0,0,,what I'm effectively doing is increasing their weight by that number of positions 
Dialogue: 0,0:23:51.16,0:23:55.98,csapp,,0,0,0,,so let's just shift by one if I shift everything to the left by one 
Dialogue: 0,0:24:01.26,0:24:05.90,csapp,,0,0,0,,which we write like this and see two left two less symbols 
Dialogue: 0,0:24:10.36,0:24:15.72,csapp,,0,0,0,,it's like taking that sum but now weighting the bits by two to the i+1 by one more 
Dialogue: 0,0:24:16.12,0:24:18.46,csapp,,0,0,0,,and of cause that's equal to twice 
Dialogue: 0,0:24:19.24,0:24:20.90,csapp,,0,0,0,,what the original sum was
Dialogue: 0,0:24:23.72,0:24:25.12,csapp,,0,0,0,, and so we double the number 
Dialogue: 0,0:24:27.48,0:24:34.88,csapp,,0,0,0,,and that works also even if you shift things
Dialogue: 0,0:24:35.06,0:24:38.62,csapp,,0,0,0,,so that you lose some bits right they they shift off to the left 
Dialogue: 0,0:24:39.10,0:24:46.18,csapp,,0,0,0,,all you're doing is the way multiplication works anyhow of truncating to W bit product so
Dialogue: 0,0:24:46.52,0:24:52.64,csapp,,0,0,0,,you'll see this as I mentioned quite often in in compiled code machine level code. 
Dialogue: 0,0:24:52.64,0:24:56.70,csapp,,0,0,0,,that they're doing shifts where you might expect them to be doing multiplications
Dialogue: 0,0:24:57.14,0:24:59.64,csapp,,0,0,0,,and the reason for that as an optimization is 
Dialogue: 0,0:24:59.98,0:25:03.60,csapp,,0,0,0,,historically the multiplication instruction took a lot longer
Dialogue: 0,0:25:03.78,0:25:09.04,csapp,,0,0,0,,than a shift instruction say one clock cycle to do a shift 
Dialogue: 0,0:25:09.54,0:25:15.60,csapp,,0,0,0,,and it used to be like 11 12 13 clock cycles to do a multiplication
Dialogue: 0,0:25:15.92,0:25:18.46,csapp,,0,0,0,,nowadays like on computers 
Dialogue: 0,0:25:20.28,0:25:24.44,csapp,,0,0,0,,we use the shark machines it only takes three clock cycles to do multiplication
Dialogue: 0,0:25:24.44,0:25:27.46,csapp,,0,0,0,,because they added a lot of hardware to do that 
Dialogue: 0,0:25:27.96,0:25:31.78,csapp,,0,0,0,,but three clock cycles is still more time than one 
Dialogue: 0,0:25:32.18,0:25:36.42,csapp,,0,0,0,,and so when you can get away with a shift it's generally a better idea
Dialogue: 0,0:25:36.42,0:25:41.20,csapp,,0,0,0,,and the compiler has its own kind of judgment calls on
Dialogue: 0,0:25:41.20,0:25:46.36,csapp,,0,0,0,,when is it more efficient to substitute one up for another
Dialogue: 0,0:25:51.36,0:25:53.54,csapp,,0,0,0,, did we uh did I lose ground here
Dialogue: 0,0:26:00.74,0:26:10.14,csapp,,0,0,0,, okay so the idea that if we want to multiply something by 2^k
Dialogue: 0,0:26:10.44,0:26:12.58,csapp,,0,0,0,,we just shift it left by k bit
Dialogue: 0,0:26:19.04,0:26:25.04,csapp,,0,0,0,, it turns out that the same almost works for dividing by 2 as well 
Dialogue: 0,0:26:25.04,0:26:32.98,csapp,,0,0,0,,that if you want to divide something by a power-of-2 you can shift it right by this in the same general
Dialogue: 0,0:26:33.52,0:26:36.56,csapp,,0,0,0,,the only thing that becomes a little bit quirky is well 
Dialogue: 0,0:26:36.92,0:26:42.12,csapp,,0,0,0,,what if the number you have is not actually divisible by that power-of-2 
Dialogue: 0,0:26:51.36,0:26:55.02,csapp,,0,0,0,,so for example if we had the number 0 1 
Dialogue: 0,0:26:58.14,0:27:01.58,csapp,,0,0,0,,I want. I'm going to use this 
Dialogue: 0,0:27:07.48,0:27:09.74,csapp,,0,0,0,,yeah so that's 6
Dialogue: 0,0:27:10.90,0:27:17.46,csapp,,0,0,0,,so if we shift it right by one we'll get 0 0 1 0
Dialogue: 0,0:27:19.88,0:27:21.26,csapp,,0,0,0,, 1 1 thank you
Dialogue: 0,0:27:22.12,0:27:26.06,csapp,,0,0,0,,which is 3 and that's 6/3=2
Dialogue: 0,0:27:26.28,0:27:27.76,csapp,,0,0,0,, if we shift that again
Dialogue: 0,0:27:32.10,0:27:37.78,csapp,,0,0,0,,we'll get 1 but of cause you know that three-halves or 1.5 
Dialogue: 0,0:27:39.24,0:27:46.08,csapp,,0,0,0,,the rule on integer division is you round it down round it toward 0 
Dialogue: 0,0:27:47.40,0:27:49.96,csapp,,0,0,0,,and so that goes to 1 so
Dialogue: 0,0:27:50.90,0:27:54.40,csapp,,0,0,0,,this is what the unsigned case works fine
Dialogue: 0,0:27:55.30,0:28:00.80,csapp,,0,0,0,, the signed case which I don't have a slide for
Dialogue: 0,0:28:05.84,0:28:09.80,csapp,,0,0,0,, is a little bit less of pretty 
Dialogue: 0,0:28:11.34,0:28:17.28,csapp,,0,0,0,,oh well first of all you notice if it's a positive number the shifting rights going to be the right
Dialogue: 0,0:28:18.44,0:28:20.20,csapp,,0,0,0,,just as is for unsigned
Dialogue: 0,0:28:20.34,0:28:28.08,csapp,,0,0,0,,but let's take a number that is negative 
Dialogue: 0,0:28:28.52,0:28:34.70,csapp,,0,0,0,,so this is -6 right
Dialogue: 0,0:28:34.82,0:28:40.42,csapp,,0,0,0,,now here's where remember I told you in the previous lecture
Dialogue: 0,0:28:40.42,0:28:42.48,csapp,,0,0,0,, there's two ways to do shifting there is
Dialogue: 0,0:28:42.88,0:28:45.80,csapp,,0,0,0,,there's logical shifting where you fill in with 0
Dialogue: 0,0:28:46.22,0:28:49.80,csapp,,0,0,0,,and arithmetic shifting where you fill in with 1 
Dialogue: 0,0:28:50.68,0:28:56.92,csapp,,0,0,0,,and guess where arithmetic shifting comes in this is it 
Dialogue: 0,0:28:57.42,0:29:00.68,csapp,,0,0,0,,when you want to preserve the sign of a number 
Dialogue: 0,0:29:00.70,0:29:04.92,csapp,,0,0,0,,while you're dividing it by power-of-2 you want arithmetic shifts
Dialogue: 0,0:29:05.64,0:29:09.94,csapp,,0,0,0,,so if we shift this by one we'll keep that sign bit 
Dialogue: 0,0:29:10.64,0:29:15.48,csapp,,0,0,0,,and then copy the other ones over right
Dialogue: 0,0:29:15.50,0:29:21.16,csapp,,0,0,0,,so we just preserve this bit here and copied the other ones over
Dialogue: 0,0:29:22.36,0:29:28.10,csapp,,0,0,0,, and this is -3 and so that's good 
Dialogue: 0,0:29:28.84,0:29:31.32,csapp,,0,0,0,,but now if we shift again arithmetic
Dialogue: 0,0:29:34.44,0:29:42.24,csapp,,0,0,0,, we will get what? -2
Dialogue: 0,0:29:42.64,0:29:46.52,csapp,,0,0,0,,I can see you guys need to know how to negate numbers right
Dialogue: 0,0:29:46.52,0:29:49.46,csapp,,0,0,0,,you don't know that so I'll show you in a second
Dialogue: 0,0:29:50.02,0:29:53.94,csapp,,0,0,0,,so here is a little bit problematic that we shifted 
Dialogue: 0,0:29:54.88,0:29:56.86,csapp,,0,0,0,,we want to divide by two 
Dialogue: 0,0:29:58.08,0:30:01.76,csapp,,0,0,0,,but the rule should be the same that you should round toward zero 
Dialogue: 0,0:30:02.10,0:30:04.86,csapp,,0,0,0,,and what this is doing is it's rounding toward 
Dialogue: 0,0:30:05.32,0:30:11.04,csapp,,0,0,0,,minus infinity it's rounding toward a more negative number than the the true thing
Dialogue: 0,0:30:12.76,0:30:15.10,csapp,,0,0,0,,and so there's a little cute little trick
Dialogue: 0,0:30:17.08,0:30:23.08,csapp,,0,0,0,, that says before you shift before you divide by a power-of-2 before you do the shift
Dialogue: 0,0:30:23.90,0:30:25.22,csapp,,0,0,0,,you should add a bias 
Dialogue: 0,0:30:31.64,0:30:34.00,csapp,,0,0,0,,which in this case would just be one 
Dialogue: 0,0:30:34.00,0:30:36.06,csapp,,0,0,0,,you know and I'll tell you where that comes from
Dialogue: 0,0:30:36.48,0:30:45.70,csapp,,0,0,0,, and so if we add those numbers together we'll get 1 1 1 0 right
Dialogue: 0,0:30:46.10,0:30:52.78,csapp,,0,0,0,,and now when we do the shift on that we'll get 1 1 1 1
Dialogue: 0,0:30:53.74,0:30:55.24,csapp,,0,0,0,,and that's -1 
Dialogue: 0,0:30:55.64,0:30:59.30,csapp,,0,0,0,,so there's a trick and you'll again you'll see the compiler doing this where 
Dialogue: 0,0:31:00.00,0:31:04.14,csapp,,0,0,0,,you have in your code divided by 16 and we'll add a bias 
Dialogue: 0,0:31:04.38,0:31:07.60,csapp,,0,0,0,,and then it will do a right shift instead of calling division 
Dialogue: 0,0:31:07.72,0:31:13.68,csapp,,0,0,0,,and by the way division really really is slow even on a modern computer like what you have
Dialogue: 0,0:31:13.98,0:31:19.00,csapp,,0,0,0,,the shark machines it takes 30 plus Hawk cycles 
Dialogue: 0,0:31:19.44,0:31:23.14,csapp,,0,0,0,,so anytime the compiler can avoid figure out a trick 
Dialogue: 0,0:31:23.14,0:31:26.86,csapp,,0,0,0,,that does it with shifting and tweaking things around it will 
Dialogue: 0,0:31:28.14,0:31:31.38,csapp,,0,0,0,,oh so I realize I should tell you 
Dialogue: 0,0:31:31.38,0:31:36.64,csapp,,0,0,0,,there's a couple ways you can negate a number 
Dialogue: 0,0:31:36.64,0:31:41.58,csapp,,0,0,0,,that are handy to know if you ever have to do it in your head or on paper
Dialogue: 0,0:31:43.70,0:31:46.74,csapp,,0,0,0,, and the standard way is what's called complement and increment
Dialogue: 0,0:31:47.26,0:31:51.88,csapp,,0,0,0,,so this is how do I go from X to -X
Dialogue: 0,0:31:52.68,0:31:59.44,csapp,,0,0,0,,so if I have a number and I want to negate it
Dialogue: 0,0:31:59.48,0:32:04.82,csapp,,0,0,0,,whether it's currently a negative number or it's a positive number the same trick works 
Dialogue: 0,0:32:05.08,0:32:07.86,csapp,,0,0,0,,what I'll do is complement it meaning I'll flip all the bits 
Dialogue: 0,0:32:11.64,0:32:18.98,csapp,,0,0,0,,and then I'll add one to that 
Dialogue: 0,0:32:18.98,0:32:25.32,csapp,,0,0,0,, and do the regular sum
Dialogue: 0,0:32:25.32,0:32:30.61,csapp,,0,0,0,, and so this is 6 this is -6
Dialogue: 0,0:32:31.48,0:32:33.24,csapp,,0,0,0,,so if you ever have to do it by hand
Dialogue: 0,0:32:33.24,0:32:36.54,csapp,,0,0,0,,that's the way to do it complement and increment  and it goes the other way
Dialogue: 0,0:32:37.02,0:32:52.02,csapp,,0,0,0,,you'll see if I compliment this and I increment it I'll get back to my previous number 
Dialogue: 0,0:32:52.02,0:32:53.44,csapp,,0,0,0,,so that's a trick 
Dialogue: 0,0:32:56.28,0:32:59.68,csapp,,0,0,0,,that is pretty much only useful when you do things on the blackboard 
Dialogue: 0,0:32:59.88,0:33:02.60,csapp,,0,0,0,,or when you have to solve a problem in data lab
Dialogue: 0,0:33:13.02,0:33:21.36,csapp,,0,0,0,,so anyways the this idea of doing a using up shifting to the right to do power-of-2 division
Dialogue: 0,0:33:21.36,0:33:25.58,csapp,,0,0,0,, is actually that's the whole justification for arithmetic shifting in the first place 
Dialogue: 0,0:33:25.98,0:33:31.68,csapp,,0,0,0,,which by the way in and see there's no fixed requirement 
Dialogue: 0,0:33:31.68,0:33:35.88,csapp,,0,0,0,,for how shifting works in c for signed numbers 
Dialogue: 0,0:33:35.88,0:33:38.20,csapp,,0,0,0,,for unsigned it has to be a logical shift 
Dialogue: 0,0:33:38.74,0:33:43.50,csapp,,0,0,0,,sign numbers the C standard says there's no fixed definition
Dialogue: 0,0:33:43.74,0:33:48.56,csapp,,0,0,0,, the reality is on our machines most machines just about every machine out there 
Dialogue: 0,0:33:49.24,0:33:53.12,csapp,,0,0,0,,when it's a two's complement number when it's a negative 
Dialogue: 0,0:33:53.12,0:33:55.14,csapp,,0,0,0,,where it's the signed number it's two's complement
Dialogue: 0,0:33:55.40,0:33:58.12,csapp,,0,0,0,, and when you do a shift it will be an earth metic shift
Dialogue: 0,0:34:07.22,0:34:11.44,csapp,,0,0,0,,so getting back to them summarizing this integer arithmetic 
Dialogue: 0,0:34:11.90,0:34:15.79,csapp,,0,0,0,,you see that first of all whether it's signed your unsigned
Dialogue: 0,0:34:16.22,0:34:21.64,csapp,,0,0,0,,the addition or multiplication operations are the same
Dialogue: 0,0:34:22.00,0:34:25.84,csapp,,0,0,0,,whether it's a unsigned number or two's complement 
Dialogue: 0,0:34:27.06,0:34:31.02,csapp,,0,0,0,,and it works the negative stuff works out 
Dialogue: 0,0:34:31.58,0:34:33.98,csapp,,0,0,0,,as long as you don't have an overflow 
Dialogue: 0,0:34:34.38,0:34:36.56,csapp,,0,0,0,,and you can end up with an overflow 
Dialogue: 0,0:34:38.48,0:34:43.02,csapp,,0,0,0,,only one type of overflow for unsigned and two types for signed numbers
Dialogue: 0,0:34:43.64,0:34:48.26,csapp,,0,0,0,, but it's not like they just overflow on generate random numbers 
Dialogue: 0,0:34:48.26,0:34:54.24,csapp,,0,0,0,,there is some a pattern to what result what they are and how they can be interpreted
Dialogue: 0,0:35:01.72,0:35:07.46,csapp,,0,0,0,,so we I talked about this a little bit last time and gave this example similar to this 
Dialogue: 0,0:35:07.46,0:35:09.58,csapp,,0,0,0,,but let me go over it a little bit more
Dialogue: 0,0:35:10.94,0:35:17.18,csapp,,0,0,0,,one thing you might think of wow if this unsigned and signed stuff gets so murky 
Dialogue: 0,0:35:17.18,0:35:19.98,csapp,,0,0,0,,and we saw some funny examples last time
Dialogue: 0,0:35:20.34,0:35:24.92,csapp,,0,0,0,, maybe we should just banished unsigned numbers from the universe
Dialogue: 0,0:35:25.40,0:35:27.12,csapp,,0,0,0,, and only allow two's complement
Dialogue: 0,0:35:27.44,0:35:31.92,csapp,,0,0,0,,and that's exactly the rule that was adopted for example in Java 
Dialogue: 0,0:35:31.92,0:35:34.24,csapp,,0,0,0,,they said is too weird 
Dialogue: 0,0:35:35.98,0:35:38.86,csapp,,0,0,0,,what let's just say every number is two's complement
Dialogue: 0,0:35:39.22,0:35:47.92,csapp,,0,0,0,, the only trick they did was they put in a triple right shift 
Dialogue: 0,0:35:51.18,0:35:54.52,csapp,,0,0,0,,means logical shift this is Java this is not C
Dialogue: 0,0:36:02.16,0:36:12.40,csapp,,0,0,0,, whereas the double is a arithmetic  
Dialogue: 0,0:36:13.74,0:36:18.00,csapp,,0,0,0,,so because they realized there's a lot of cute little times 
Dialogue: 0,0:36:18.00,0:36:20.18,csapp,,0,0,0,,when you want to play tricks with things 
Dialogue: 0,0:36:20.50,0:36:22.94,csapp,,0,0,0,,and you need that logical right shift 
Dialogue: 0,0:36:23.96,0:36:29.52,csapp,,0,0,0,,so that's actually one approach or other more modern languages and C are saying
Dialogue: 0,0:36:29.82,0:36:31.92,csapp,,0,0,0,,it's okay to have signed and unsigned
Dialogue: 0,0:36:32.16,0:36:35.42,csapp,,0,0,0,,but we don't want them sort of mysteriously being cast back 
Dialogue: 0,0:36:35.42,0:36:38.82,csapp,,0,0,0,,and forth in ways that the programmer  might not recognize
Dialogue: 0,0:36:38.82,0:36:43.70,csapp,,0,0,0,, and so you have to explicitly do a cast rather than implicitly
Dialogue: 0,0:36:44.24,0:36:45.86,csapp,,0,0,0,, and I think that's the better approach
Dialogue: 0,0:36:45.86,0:36:49.74,csapp,,0,0,0,, but C as I mentioned does this implicit casting
Dialogue: 0,0:36:50.00,0:36:55.28,csapp,,0,0,0,,and so as we saw for last time what happens with this program when you run it
Dialogue: 0,0:36:59.15,0:37:08.89,csapp,,0,0,0,,to count down through an array do you remember?
Dialogue: 0,0:37:09.24,0:37:14.94,csapp,,0,0,0,,well as I if it's unsigned what will happen with this test 
Dialogue: 0,0:37:16.58,0:37:19.64,csapp,,0,0,0,,it always succeeds so the thing will be in an infinite loop
Dialogue: 0,0:37:20.18,0:37:22.68,csapp,,0,0,0,,actually what will happen is it will try to access 
Dialogue: 0,0:37:23.38,0:37:27.66,csapp,,0,0,0,,I will go down to 0 and then it will wrap around to become
Dialogue: 0,0:37:28.22,0:37:30.14,csapp,,0,0,0,, the largest possible unsigned number 
Dialogue: 0,0:37:30.14,0:37:34.08,csapp,,0,0,0,,which is probably way out of bounds and it will give a memory error 
Dialogue: 0,0:37:35.34,0:37:37.64,csapp,,0,0,0,,but it won't do what's supposed to be 
Dialogue: 0,0:37:37.82,0:37:39.64,csapp,,0,0,0,,and as I mentioned before these things 
Dialogue: 0,0:37:39.64,0:37:42.67,csapp,,0,0,0,,there is a lot of sneaky ways this problem can show up
Dialogue: 0,0:37:43.00,0:37:44.90,csapp,,0,0,0,, in ways you might never think of 
Dialogue: 0,0:37:45.28,0:37:52.08,csapp,,0,0,0,,so for example the operator sizeof is defined
Dialogue: 0,0:37:52.34,0:37:55.16,csapp,,0,0,0,,to say how big a particular datatype is
Dialogue: 0,0:37:55.86,0:37:57.38,csapp,,0,0,0,,it's a very useful operator
Dialogue: 0,0:37:57.38,0:38:03.48,csapp,,0,0,0,, but it's its return value is a what's called a size underscore t 
Dialogue: 0,0:38:03.48,0:38:07.12,csapp,,0,0,0,,which is defined to be a long unsigned number
Dialogue: 0,0:38:07.70,0:38:12.88,csapp,,0,0,0,, and so if we just throw in a constant like this
Dialogue: 0,0:38:13.14,0:38:17.02,csapp,,0,0,0,, then this subtraction we have a sign in is now int
Dialogue: 0,0:38:17.54,0:38:19.60,csapp,,0,0,0,,but sizeof is unsigned 
Dialogue: 0,0:38:19.86,0:38:23.38,csapp,,0,0,0,,and so it will cast that to be unsigned implicitly 
Dialogue: 0,0:38:24.15,0:38:28.06,csapp,,0,0,0,,and when you compare it to 0 you'll have the same problem as before
Dialogue: 0,0:38:29.40,0:38:35.00,csapp,,0,0,0,, so just to show you that these things can sneak in very tricky ways
Dialogue: 0,0:38:35.46,0:38:41.86,csapp,,0,0,0,,so one way to do that then is just don't use unsigned like 
Dialogue: 0,0:38:41.92,0:38:47.84,csapp,,0,0,0,, and make sure if this is a a possible
Dialogue: 0,0:38:48.26,0:38:51.36,csapp,,0,0,0,,unsigned number you cast it to signed
Dialogue: 0,0:38:51.70,0:38:54.34,csapp,,0,0,0,,you make sure this is recognized and signed
Dialogue: 0,0:38:54.94,0:38:57.72,csapp,,0,0,0,, but there's another way that actually
Dialogue: 0,0:38:57.96,0:39:02.40,csapp,,0,0,0,, at least there's a fellow over the software engineering Institute named Robert Secord
Dialogue: 0,0:39:03.02,0:39:06.52,csapp,,0,0,0,, who has written the books that are suited to considered the
Dialogue: 0,0:39:09.22,0:39:12.88,csapp,,0,0,0,, this the gold standard for how to write secure code 
Dialogue: 0,0:39:13.20,0:39:16.82,csapp,,0,0,0,,he works for this organization called the computer emergency response team
Dialogue: 0,0:39:16.82,0:39:24.72,csapp,,0,0,0,, which is out there tracking down bad things going on in computer security 
Dialogue: 0,0:39:25.18,0:39:30.20,csapp,,0,0,0,,and one of the things he and others have done is to try and come up with standards
Dialogue: 0,0:39:30.20,0:39:36.04,csapp,,0,0,0,, so that people who write programs will you know avoid some of the pitfalls
Dialogue: 0,0:39:36.04,0:39:40.74,csapp,,0,0,0,, that make their programs vulnerable to the security of was to attack
Dialogue: 0,0:39:41.24,0:39:44.62,csapp,,0,0,0,, and so his recommended technique is when I first saw this 
Dialogue: 0,0:39:44.62,0:39:46.70,csapp,,0,0,0,,it was so counterintuitive to me
Dialogue: 0,0:39:47.46,0:39:52.36,csapp,,0,0,0,,it hardly made sense right 
Dialogue: 0,0:39:52.48,0:39:55.62,csapp,,0,0,0,,so you start and again this is all unsigned arithmetic
Dialogue: 0,0:39:55.84,0:39:58.18,csapp,,0,0,0,, so I'm starting to count down
Dialogue: 0,0:39:58.42,0:40:01.50,csapp,,0,0,0,,and my test is when I is less than count
Dialogue: 0,0:40:02.40,0:40:05.62,csapp,,0,0,0,,so here's the thing I started off smaller than count 
Dialogue: 0,0:40:06.14,0:40:10.58,csapp,,0,0,0,,and it's only being decremented so when would this test ever fail
Dialogue: 0,0:40:10.58,0:40:15.68,csapp,,0,0,0,,[student question]
Dialogue: 0,0:40:15.84,0:40:17.92,csapp,,0,0,0,,when it overflows when it wraps around
Dialogue: 0,0:40:18.26,0:40:23.30,csapp,,0,0,0,, right when I goes from zero and counts down to what would now be you max
Dialogue: 0,0:40:24.28,0:40:27.82,csapp,,0,0,0,,this test will fail which is exactly when you want it to stop 
Dialogue: 0,0:40:28.60,0:40:33.58,csapp,,0,0,0,,and his observation is and in C with signed numbers there's no guarantee 
Dialogue: 0,0:40:33.82,0:40:35.60,csapp,,0,0,0,,on what happens with overflowing 
Dialogue: 0,0:40:35.68,0:40:39.68,csapp,,0,0,0,,as I said most people just assume it's going to be two's complement 
Dialogue: 0,0:40:39.68,0:40:41.64,csapp,,0,0,0,,but if you really want to be careful 
Dialogue: 0,0:40:41.90,0:40:45.04,csapp,,0,0,0,,you shouldn't assume anything outside of the C standard 
Dialogue: 0,0:40:45.30,0:40:47.24,csapp,,0,0,0,,and if you're trying to write secure code
Dialogue: 0,0:40:47.54,0:40:51.12,csapp,,0,0,0,, it's probably a good idea to be cautious be conservative 
Dialogue: 0,0:40:52.16,0:40:55.46,csapp,,0,0,0,,on the other hand the C standard guarantees 
Dialogue: 0,0:40:55.94,0:41:00.50,csapp,,0,0,0,,it that unsigned arithmetic will be modular arithmetic so it guarantees 
Dialogue: 0,0:41:00.68,0:41:05.48,csapp,,0,0,0,,if you subtract one from zero you'll get the largest number that could be represented 
Dialogue: 0,0:41:05.96,0:41:09.16,csapp,,0,0,0,,so it will be okay
Dialogue: 0,0:41:09.36,0:41:13.02,csapp,,0,0,0,,and in fact he recommends instead of using unsigned 
Dialogue: 0,0:41:13.02,0:41:16.92,csapp,,0,0,0,,which is on our machines just a 32-bit value
Dialogue: 0,0:41:17.86,0:41:21.92,csapp,,0,0,0,, that you call it a size_t which is a 64-bit value
Dialogue: 0,0:41:22.44,0:41:26.64,csapp,,0,0,0,, and so and write your code the way that I showed you 
Dialogue: 0,0:41:27.74,0:41:29.48,csapp,,0,0,0,,so I've actually started doing this 
Dialogue: 0,0:41:29.98,0:41:33.50,csapp,,0,0,0,,and once you kind of get used to it it it's an OK way to write code
Dialogue: 0,0:41:33.50,0:41:36.42,csapp,,0,0,0,,but it's very strange-looking initial
Dialogue: 0,0:41:37.43,0:41:44.14,csapp,,0,0,0,,one thing I'll point out is 
Dialogue: 0,0:41:44.24,0:41:50.64,csapp,,0,0,0,,what would happen if count were a signed number int
Dialogue: 0,0:41:52.08,0:41:57.50,csapp,,0,0,0,,and it were you were up and it was less than zero what would happen here
Dialogue: 0,0:42:01.80,0:42:04.58,csapp,,0,0,0,,so I less than count what would happen
Dialogue: 0,0:42:05.06,0:42:10.72,csapp,,0,0,0,, [student question] 
Dialogue: 0,0:42:10.72,0:42:14.46,csapp,,0,0,0,,right and so it become a very large positive number 
Dialogue: 0,0:42:14.86,0:42:17.58,csapp,,0,0,0,,and this test would almost certainly succeed
Dialogue: 0,0:42:17.86,0:42:20.58,csapp,,0,0,0,, so you have the same this code doesn't avoid the pitfall 
Dialogue: 0,0:42:21.00,0:42:22.93,csapp,,0,0,0,,it just shifts it to saying
Dialogue: 0,0:42:23.26,0:42:28.12,csapp,,0,0,0,,you better make sure you don't you know just for this case beforehand
Dialogue: 0,0:42:28.52,0:42:30.46,csapp,,0,0,0,,before you get into it 
Dialogue: 0,0:42:32.48,0:42:37.56,csapp,,0,0,0,,so I think part of it is the observation 
Dialogue: 0,0:42:37.56,0:42:41.14,csapp,,0,0,0,,that man if you want to be careful and write code that 
Dialogue: 0,0:42:41.66,0:42:46.94,csapp,,0,0,0,,that is guaranteed correct no matter what implementation goes on 
Dialogue: 0,0:42:46.94,0:42:50.48,csapp,,0,0,0,,as long as it's within the CIE standard it's pretty tricky business 
Dialogue: 0,0:42:50.48,0:43:00.31,csapp,,0,0,0,,question up there [student question]yes
Dialogue: 0,0:43:01.10,0:43:04.42,csapp,,0,0,0,,which is unfortunate right 
Dialogue: 0,0:43:04.42,0:43:06.22,csapp,,0,0,0,,so yes that's exactly the rule 
Dialogue: 0,0:43:06.22,0:43:10.88,csapp,,0,0,0,,that it's implicitly silently the C compiler doesn't give any warnings
Dialogue: 0,0:43:11.24,0:43:14.48,csapp,,0,0,0,, you'll never know it cast it to unsigned and
Dialogue: 0,0:43:14.90,0:43:20.62,csapp,,0,0,0,, as these examples show when you stare at that code and you think about it
Dialogue: 0,0:43:21.36,0:43:23.26,csapp,,0,0,0,, it's really easy to have bugs
Dialogue: 0,0:43:23.26,0:43:26.16,csapp,,0,0,0,,that you just you can look at it a thousand times 
Dialogue: 0,0:43:26.14,0:43:28.22,csapp,,0,0,0,,and not realize that it's a bug
Dialogue: 0,0:43:28.38,0:43:33.73,csapp,,0,0,0,,it's a very and there's examples these examples in the book of
Dialogue: 0,0:43:33.73,0:43:39.34,csapp,,0,0,0,,of security flaws in sort of very important library software
Dialogue: 0,0:43:39.64,0:43:44.73,csapp,,0,0,0,, due to this problem exactly
Dialogue: 0,0:43:45.26,0:43:49.52,csapp,,0,0,0,,so part of the reason we teach in the course is just so you appreciate that
Dialogue: 0,0:43:49.54,0:43:54.86,csapp,,0,0,0,,this is a quirk in this and see that again
Dialogue: 0,0:43:54.86,0:43:59.84,csapp,,0,0,0,,99% of the time you'll never even it won't bother you at all
Dialogue: 0,0:43:59.84,0:44:03.50,csapp,,0,0,0,, but there will be some oddball cases that you can get in trouble with 
Dialogue: 0,0:44:08.30,0:44:11.44,csapp,,0,0,0,,so the other place that you'll find 
Dialogue: 0,0:44:12.50,0:44:16.82,csapp,,0,0,0,,unsigned arithmetic unsigned representation use voice first of all 
Dialogue: 0,0:44:17.30,0:44:19.06,csapp,,0,0,0,,when you're doing modular arithmetic
Dialogue: 0,0:44:19.06,0:44:24.46,csapp,,0,0,0,, which is for example the way most encryption algorithms work
Dialogue: 0,0:44:25.24,0:44:28.56,csapp,,0,0,0,, or when you're using the bits not to represent numbers 
Dialogue: 0,0:44:28.56,0:44:32.20,csapp,,0,0,0,,but to represent sets the way I described it before 
Dialogue: 0,0:44:32.66,0:44:39.36,csapp,,0,0,0,,then you don't want it it's easiest to just think of that as unsigned numbers
Dialogue: 0,0:44:44.66,0:44:48.16,csapp,,0,0,0,, okay so the final thing to talk about today is 
Dialogue: 0,0:44:48.72,0:44:52.86,csapp,,0,0,0,,some of the low-level representations of numbers within memory 
Dialogue: 0,0:44:53.94,0:45:00.12,csapp,,0,0,0,,and the main point is when you are running a program on a computer
Dialogue: 0,0:45:02.38,0:45:09.38,csapp,,0,0,0,,from the programming perspective either r not just as a C programmer
Dialogue: 0,0:45:09.96,0:45:13.20,csapp,,0,0,0,, in your mind the memory is just this big array of bytes
Dialogue: 0,0:45:13.82,0:45:17.34,csapp,,0,0,0,,that's numbered from 0 up to some maximum number 
Dialogue: 0,0:45:17.80,0:45:22.54,csapp,,0,0,0,,so for example in the machines we're using the 64-bit machines
Dialogue: 0,0:45:24.12,0:45:27.68,csapp,,0,0,0,,I'll an address is represented in 64 bits
Dialogue: 0,0:45:29.18,0:45:31.28,csapp,,0,0,0,,but in fact the maximum address
Dialogue: 0,0:45:31.76,0:45:37.10,csapp,,0,0,0,,you're allowed to use in current machines is a 47 bits
Dialogue: 0,0:45:37.94,0:45:42.48,csapp,,0,0,0,, and to the 47th is still a pretty big number 
Dialogue: 0,0:45:42.48,0:45:48.36,csapp,,0,0,0,,so that's more memory than anyone's able to buy right now anyhow 
Dialogue: 0,0:45:48.38,0:45:50.26,csapp,,0,0,0,,and so it's a reasonable restriction 
Dialogue: 0,0:45:50.26,0:45:57.76,csapp,,0,0,0,,but the point is that logically your program thinks that it has a of that many bytes 
Dialogue: 0,0:45:58.90,0:46:07.24,csapp,,0,0,0,,let's try and figure out how big to xlvii is anyone know it off the top of their head
Dialogue: 0,0:46:07.24,0:46:13.56,csapp,,0,0,0,, so there's a trick if you want to get an approximate idea
Dialogue: 0,0:46:14.70,0:46:21.44,csapp,,0,0,0,,which is to say that 2^10 which is 1024 
Dialogue: 0,0:46:22.64,0:46:25.90,csapp,,0,0,0,,is approximately equal to 10^3
Dialogue: 0,0:46:28.20,0:46:30.16,csapp,,0,0,0,,you say oh well that's really helpful 
Dialogue: 0,0:46:30.32,0:46:35.30,csapp,,0,0,0,,what it means is that 10 bits worth of number
Dialogue: 0,0:46:35.80,0:46:40.14,csapp,,0,0,0,, is about the same as three decimal digits all right
Dialogue: 0,0:46:40.64,0:46:53.94,csapp,,0,0,0,,so for example 2^20 is around 10^6
Dialogue: 0,0:46:55.16,0:46:59.24,csapp,,0,0,0,,2^30 it's around 10^9
Dialogue: 0,0:47:00.92,0:47:05.18,csapp,,0,0,0,,2^40 it's around 10^12 
Dialogue: 0,0:47:07.06,0:47:09.60,csapp,,0,0,0,,and so that would tell you that 
Dialogue: 0,0:47:10.46,0:47:22.56,csapp,,0,0,0,,2^48 47 is around 128 times 10^12 which is 128 terabytes right  tera 10^12
Dialogue: 0,0:47:23.28,0:47:28.14,csapp,,0,0,0,,so if you just want to say you know get a quick figure 4 
Dialogue: 0,0:47:28.38,0:47:30.56,csapp,,0,0,0,,and of course these are approximations
Dialogue: 0,0:47:31.02,0:47:33.28,csapp,,0,0,0,, but if you just want to get a quick handle on 
Dialogue: 0,0:47:33.44,0:47:38.78,csapp,,0,0,0,,how big a number you know what's range of values can I represent with so many bits of it 
Dialogue: 0,0:47:38.96,0:47:41.32,csapp,,0,0,0,,this is a really easy trick to do that 
Dialogue: 0,0:47:42.40,0:47:48.42,csapp,,0,0,0,,so the point is a 128 terabytes is a lot 
Dialogue: 0,0:47:50.42,0:47:54.72,csapp,,0,0,0,,you can buy disk drives a couple of disk drives will do that for you
Dialogue: 0,0:47:54.72,0:48:00.28,csapp,,0,0,0,,but you couldn't buy enough DRAM on a normal budget to get that kind of memory
Dialogue: 0,0:48:00.78,0:48:06.06,csapp,,0,0,0,, so that's the the current range of values but logically when you run a program
Dialogue: 0,0:48:06.58,0:48:09.62,csapp,,0,0,0,, it thinks that it has that possible range 
Dialogue: 0,0:48:09.62,0:48:11.52,csapp,,0,0,0,,now it doesn't really
Dialogue: 0,0:48:11.68,0:48:14.79,csapp,,0,0,0,, and in fact what happens is that the operating system
Dialogue: 0,0:48:14.79,0:48:18.96,csapp,,0,0,0,,only allows certain regions within that memory to be referenced 
Dialogue: 0,0:48:19.38,0:48:24.48,csapp,,0,0,0,,and other regions if you try to access them it will create a it will signal an error
Dialogue: 0,0:48:24.48,0:48:26.28,csapp,,0,0,0,,what they call a segmentation fault 
Dialogue: 0,0:48:27.16,0:48:30.32,csapp,,0,0,0,,but logically at least it's as if you have this big array of bytes 
Dialogue: 0,0:48:30.82,0:48:33.96,csapp,,0,0,0,,now in reality and we'll go into this when we talk about
Dialogue: 0,0:48:33.96,0:48:37.74,csapp,,0,0,0,, how the memory system is works in virtual memory
Dialogue: 0,0:48:41.40,0:48:45.00,csapp,,0,0,0,, there's this very complex combination of hardware and software
Dialogue: 0,0:48:45.22,0:48:48.50,csapp,,0,0,0,,begins the program this image of a very large
Dialogue: 0,0:48:48.82,0:48:52.48,csapp,,0,0,0,,what you call flat space just a big array of bytes 
Dialogue: 0,0:48:52.80,0:48:57.86,csapp,,0,0,0,,when in reality it's shuffling between different regions of your memory 
Dialogue: 0,0:48:57.86,0:49:02.26,csapp,,0,0,0,,and even between your memory and your disk drive on your computer
Dialogue: 0,0:49:02.64,0:49:09.16,csapp,,0,0,0,, to make it implement this particular idea
Dialogue: 0,0:49:09.16,0:49:10.83,csapp,,0,0,0,,that you have this big array of bytes
Dialogue: 0,0:49:11.40,0:49:16.84,csapp,,0,0,0,,and that's all handled as I said by the operating system by the computer hardware
Dialogue: 0,0:49:17.12,0:49:22.12,csapp,,0,0,0,, and it's largely invisible even to the machine level programmer even people writing assembly code 
Dialogue: 0,0:49:29.40,0:49:34.34,csapp,,0,0,0,,you'll often hear the term word size and it can get very confusing confusing nowadays
Dialogue: 0,0:49:34.34,0:49:38.40,csapp,,0,0,0,,because there's no really fixed idea of what a word size is 
Dialogue: 0,0:49:38.92,0:49:42.70,csapp,,0,0,0,,but roughly speaking the word size should be
Dialogue: 0,0:49:42.68,0:49:47.30,csapp,,0,0,0,, whatever the largest number is that or
Dialogue: 0,0:49:49.16,0:49:54.70,csapp,,0,0,0,, the range that sort of signifies how big a pointer is in this language 
Dialogue: 0,0:49:55.12,0:50:00.36,csapp,,0,0,0,,or Hardware wise the largest sort of chunk of hardware for which
Dialogue: 0,0:50:00.36,0:50:05.10,csapp,,0,0,0,,there's standard support for storing it for arithmetic operations and so forth 
Dialogue: 0,0:50:05.66,0:50:08.24,csapp,,0,0,0,,so when we say it's a 64-bit machine
Dialogue: 0,0:50:08.68,0:50:15.26,csapp,,0,0,0,, what we mean is that it it regular and routinely manipulate 64-bit values
Dialogue: 0,0:50:15.64,0:50:17.80,csapp,,0,0,0,, err on arithmetic operations
Dialogue: 0,0:50:18.04,0:50:24.27,csapp,,0,0,0,, and also it has a pointers or the values of of addresses are 64-bit
Dialogue: 0,0:50:24.68,0:50:32.16,csapp,,0,0,0,,even if for right now only 47 of those bits are usable it's still considered a 64-bit machine
Dialogue: 0,0:50:33.20,0:50:42.78,csapp,,0,0,0,, one thing that strange is in one of the features of of machines such as we have 
Dialogue: 0,0:50:48.24,0:50:54.06,csapp,,0,0,0,,huh is that if I compile a program using GCC is the standard compiler
Dialogue: 0,0:50:54.52,0:51:03.80,csapp,,0,0,0,, I can specify either I want it to be 64 bit code or 32 bit code as a flag 
Dialogue: 0,0:51:07.22,0:51:11.66,csapp,,0,0,0,,and it will actually generate two different kinds of object code as a result
Dialogue: 0,0:51:12.18,0:51:15.14,csapp,,0,0,0,, and we'll talk in about these later
Dialogue: 0,0:51:15.46,0:51:22.76,csapp,,0,0,0,,but for right now the point is the hardware itself doesn't necessarily define what the word size is 
Dialogue: 0,0:51:23.70,0:51:27.58,csapp,,0,0,0,,it's a combination of the hardware and the compiler  that determines 
Dialogue: 0,0:51:27.58,0:51:31.08,csapp,,0,0,0,,what is the word size being used in this particular program
Dialogue: 0,0:51:31.62,0:51:36.02,csapp,,0,0,0,, and that code can be run on the point is a 64 bit machine
Dialogue: 0,0:51:36.02,0:51:39.04,csapp,,0,0,0,, such as we have and most machines are nowadays
Dialogue: 0,0:51:39.28,0:51:46.54,csapp,,0,0,0,, can insert of a backward compatibility a style also executes 32-bit code 
Dialogue: 0,0:51:51.00,0:51:55.05,csapp,,0,0,0,,and as we also saw one of the other features is
Dialogue: 0,0:51:55.05,0:51:58.22,csapp,,0,0,0,,even though it's a 64 bit word size the data type int 
Dialogue: 0,0:51:59.22,0:52:03.42,csapp,,0,0,0,,without any other qualifiers to it is just 32 bit 
Dialogue: 0,0:52:03.56,0:52:07.24,csapp,,0,0,0,,so the sort of this mixture of how big things are
Dialogue: 0,0:52:07.24,0:52:09.76,csapp,,0,0,0,,so when people just say word or word size
Dialogue: 0,0:52:10.62,0:52:15.04,csapp,,0,0,0,,and let's say give a precise definition that's not a very meaningful term
Dialogue: 0,0:52:15.44,0:52:18.56,csapp,,0,0,0,,and we'll sort of throw it around when we mean sort of a generic 
Dialogue: 0,0:52:18.56,0:52:23.50,csapp,,0,0,0,,chunk of bits without trying to assume that it has a particular number of bits to it
Dialogue: 0,0:52:35.70,0:52:39.84,csapp,,0,0,0,,yes so one of the things is if we ever get to 64-bit words 
Dialogue: 0,0:52:41.10,0:52:48.04,csapp,,0,0,0,,it will be 16 petabytes 18 petabytes depending on how you define 
Dialogue: 0,0:52:48.04,0:52:54.86,csapp,,0,0,0,,when you those numbers get big but the error due to this approximation gets more significant 
Dialogue: 0,0:52:55.70,0:52:59.04,csapp,,0,0,0,,but something times 10^15 bytes 
Dialogue: 0,0:52:59.16,0:53:04.64,csapp,,0,0,0,,but right now we can only get to 128 times 10 to the 12 
Dialogue: 0,0:53:12.12,0:53:17.08,csapp,,0,0,0,,so anyways the idea that that the memory itself is a series of bytes
Dialogue: 0,0:53:17.68,0:53:23.16,csapp,,0,0,0,,but we can group those into blocks of words of different word sizes 
Dialogue: 0,0:53:23.56,0:53:28.40,csapp,,0,0,0,,and the way we do that is usually by assuming that
Dialogue: 0,0:53:29.26,0:53:34.82,csapp,,0,0,0,,the address of the word is the lowest valued address in it 
Dialogue: 0,0:53:35.16,0:53:38.18,csapp,,0,0,0,,and we also will generally try to align these 
Dialogue: 0,0:53:38.72,0:53:46.88,csapp,,0,0,0,,so that for example a 32-bit word would be a line 
Dialogue: 0,0:53:46.88,0:53:52.18,csapp,,0,0,0,,so its first byte its lowest byte has all zeros in the fruit stuff
Dialogue: 0,0:53:58.50,0:54:01.92,csapp,,0,0,0,,in the first five bit positions right no
Dialogue: 0,0:54:02.44,0:54:05.62,csapp,,0,0,0,,no 32 4 I'm sorry the low is 2 bytes 
Dialogue: 0,0:54:06.70,0:54:15.52,csapp,,0,0,0,,right so as this example shows their address is 0 4 8  and 12
Dialogue: 0,0:54:15.52,0:54:18.20,csapp,,0,0,0,, they should have really written this in hex and set at C 
Dialogue: 0,0:54:19.78,0:54:22.04,csapp,,0,0,0,,I guess these are all in decimal anyhow 
Dialogue: 0,0:54:22.94,0:54:26.64,csapp,,0,0,0,,so yeah these are decimal numbers so 0 4 8 12 
Dialogue: 0,0:54:27.00,0:54:31.30,csapp,,0,0,0,,so you see these are on multiples of 4 of bit boundaries
Dialogue: 0,0:54:31.94,0:54:35.48,csapp,,0,0,0,, and same way the 64-bit words are on multiples of 8 
Dialogue: 0,0:54:35.98,0:54:39.96,csapp,,0,0,0,,and those are known as aligned words and will generally will see that 
Dialogue: 0,0:54:39.96,0:54:42.48,csapp,,0,0,0,,the compiler works pretty hard to keep things aligned
Dialogue: 0,0:54:42.92,0:54:45.22,csapp,,0,0,0,,because the hardware runs more efficiently that way 
Dialogue: 0,0:54:45.90,0:54:50.14,csapp,,0,0,0,,but the main point is that we can just take as many bytes
Dialogue: 0,0:54:50.14,0:54:54.86,csapp,,0,0,0,,as we want and collect them together and call it a word for whatever word size we need
Dialogue: 0,0:54:56.44,0:55:00.00,csapp,,0,0,0,,and as we think we saw a variant of this table before 
Dialogue: 0,0:55:00.00,0:55:02.66,csapp,,0,0,0,,but this is machines we'll be working on that
Dialogue: 0,0:55:04.14,0:55:07.16,csapp,,0,0,0,, the standard int is still only 32 bits
Dialogue: 0,0:55:07.62,0:55:11.22,csapp,,0,0,0,, but if we qualify something as being wrong 
Dialogue: 0,0:55:11.70,0:55:15.03,csapp,,0,0,0,,then it will be 64 bits and will tend to do that
Dialogue: 0,0:55:15.72,0:55:19.22,csapp,,0,0,0,,there's two different floating-point representations that we'll talk about
Dialogue: 0,0:55:19.62,0:55:22.60,csapp,,0,0,0,,and then the main feature of a 64 bit machine
Dialogue: 0,0:55:22.82,0:55:28.12,csapp,,0,0,0,, is it has an 8 byte or 64 bit pointer as compared to 32 
Dialogue: 0,0:55:30.38,0:55:35.24,csapp,,0,0,0,,now there's one other kind of detail that says ok 
Dialogue: 0,0:55:35.24,0:55:37.90,csapp,,0,0,0,,so if a word has multiple bytes in it 
Dialogue: 0,0:55:38.40,0:55:41.28,csapp,,0,0,0,,what order should those bytes be should it be the 
Dialogue: 0,0:55:43.14,0:55:45.72,csapp,,0,0,0,,and there's two basic ways this could go one
Dialogue: 0,0:55:46.04,0:55:51.40,csapp,,0,0,0,,one is that you put the bytes in what's known as little endian order meaning that 
Dialogue: 0,0:55:51.40,0:55:54.82,csapp,,0,0,0,,the first byte and the word is the least significant byte 
Dialogue: 0,0:55:54.82,0:56:00.18,csapp,,0,0,0,,then the next and the final byte in the word is the most significant
Dialogue: 0,0:56:00.64,0:56:03.84,csapp,,0,0,0,,or you can flip that around and 
Dialogue: 0,0:56:03.84,0:56:11.54,csapp,,0,0,0,,those are called little-endian and big-endian is the sort of terms for that
Dialogue: 0,0:56:11.54,0:56:19.40,csapp,,0,0,0,,which comes from English book called Gulliver's Travels
Dialogue: 0,0:56:19.40,0:56:21.94,csapp,,0,0,0,,which didn't anticipate computers at all
Dialogue: 0,0:56:22.32,0:56:25.44,csapp,,0,0,0,,but it's an interesting story of how that comes about
Dialogue: 0,0:56:26.02,0:56:31.18,csapp,,0,0,0,,so in out there in the world you'll find both types of machines big-Endian and little-Endian machines 
Dialogue: 0,0:56:31.80,0:56:36.40,csapp,,0,0,0,,it turns out that increasingly it's getting hard to find big-Endian machines
Dialogue: 0,0:56:36.96,0:56:40.52,csapp,,0,0,0,, so little Endian all of x86 is good Endian
Dialogue: 0,0:56:41.70,0:56:44.74,csapp,,0,0,0,, and it turns out ARM processors like 
Dialogue: 0,0:56:44.74,0:56:50.14,csapp,,0,0,0,,what you have in almost every cell phone here is an ARM processor 
Dialogue: 0,0:56:51.32,0:56:56.92,csapp,,0,0,0,,and the hardware those can actually be configured to run either way big-endian or little-endian 
Dialogue: 0,0:56:57.50,0:57:01.90,csapp,,0,0,0,,but when you're running it on any of the standard operating systems 
Dialogue: 0,0:57:01.90,0:57:08.08,csapp,,0,0,0,,that run on ARM processors then it's running little Endian 
Dialogue: 0,0:57:08.76,0:57:14.80,csapp,,0,0,0,,so there used to be a brand called Sun Microsystems and they were fairly common on campus 
Dialogue: 0,0:57:15.56,0:57:21.26,csapp,,0,0,0,,and then back in the Macintosh before they were x86 processors
Dialogue: 0,0:57:21.76,0:57:23.92,csapp,,0,0,0,, they ran one called the PowerPC
Dialogue: 0,0:57:25.42,0:57:27.36,csapp,,0,0,0,, and that was a big endian machine
Dialogue: 0,0:57:27.36,0:57:30.15,csapp,,0,0,0,, but those are long in the distant past
Dialogue: 0,0:57:30.80,0:57:33.72,csapp,,0,0,0,,the Internet's about the only place out there
Dialogue: 0,0:57:33.90,0:57:40.10,csapp,,0,0,0,, when you send packets over the internet and you want to send it of 32-bit words
Dialogue: 0,0:57:40.30,0:57:42.90,csapp,,0,0,0,, they're actually sent in big endian order and so
Dialogue: 0,0:57:43.14,0:57:46.98,csapp,,0,0,0,, at the network interface you have to translate between those two 
Dialogue: 0,0:57:48.40,0:57:51.60,csapp,,0,0,0,,so again just to illustrate what I mean by this
Dialogue: 0,0:57:51.96,0:57:57.64,csapp,,0,0,0,, is think of a byte value 4 byte value like this 
Dialogue: 0,0:57:58.00,0:58:03.32,csapp,,0,0,0,,and remember that the way we write numbers is we put the most significant to the left
Dialogue: 0,0:58:03.78,0:58:05.84,csapp,,0,0,0,,and the least significant to the right
Dialogue: 0,0:58:09.60,0:58:14.88,csapp,,0,0,0,, and so now with a big-endian instead of the intuitive one 
Dialogue: 0,0:58:15.62,0:58:17.74,csapp,,0,0,0,,from that perspective in that the bikes 
Dialogue: 0,0:58:17.74,0:58:23.10,csapp,,0,0,0,,if you write the words in memory from the smallest address up to the highest
Dialogue: 0,0:58:23.68,0:58:26.44,csapp,,0,0,0,,the big endian will sort of map to what you see
Dialogue: 0,0:58:26.92,0:58:30.88,csapp,,0,0,0,, whereas a little Endian will look confusing
Dialogue: 0,0:58:31.16,0:58:34.56,csapp,,0,0,0,, that you say 01 23 45 67
Dialogue: 0,0:58:34.56,0:58:39.06,csapp,,0,0,0,,because 67 is actually the least significant byte here
Dialogue: 0,0:58:39.06,0:58:41.68,csapp,,0,0,0,, and so that comes first in little-endian order 
Dialogue: 0,0:58:43.20,0:58:49.68,csapp,,0,0,0,,and so the it used to be people would get in passionate arguments about this 
Dialogue: 0,0:58:50.16,0:58:52.50,csapp,,0,0,0,,that's sort of in the distant past 
Dialogue: 0,0:58:53.04,0:58:55.36,csapp,,0,0,0,,but and people saying you know 
Dialogue: 0,0:58:55.36,0:59:04.14,csapp,,0,0,0,,and the main feature in some sort of argument of big Endian is's this feature here that
Dialogue: 0,0:59:04.46,0:59:06.94,csapp,,0,0,0,,when you look at it it's easier to write down
Dialogue: 0,0:59:07.54,0:59:09.38,csapp,,0,0,0,,but computers don't really care 
Dialogue: 0,0:59:09.50,0:59:13.00,csapp,,0,0,0,,they're happy either way and so they just want one convention or another 
Dialogue: 0,0:59:13.30,0:59:18.12,csapp,,0,0,0,,and like I said some hardware's can actually be a by a sort of flag 
Dialogue: 0,0:59:18.12,0:59:20.64,csapp,,0,0,0,,to flip it from  being big endian to little Endian
Dialogue: 0,0:59:21.12,0:59:23.06,csapp,,0,0,0,,but the reality is most of machines
Dialogue: 0,0:59:23.06,0:59:26.62,csapp,,0,0,0,, one counter you'll encounter a little endian machine days 
Dialogue: 0,0:59:27.68,0:59:29.42,csapp,,0,0,0,,but just to give you an example 
Dialogue: 0,0:59:29.94,0:59:33.84,csapp,,0,0,0,,results that I got from actual machines
Dialogue: 0,0:59:33.84,0:59:35.68,csapp,,0,0,0,,there used to be some machines around
Dialogue: 0,0:59:36.58,0:59:38.88,csapp,,0,0,0,,and so back in the old days I could run this
Dialogue: 0,0:59:38.88,0:59:42.66,csapp,,0,0,0,,I don't even know where to get a big endian machine anymore
Dialogue: 0,0:59:43.08,0:59:46.28,csapp,,0,0,0,, so these are sort of legacy results 
Dialogue: 0,0:59:47.92,0:59:52.44,csapp,,0,0,0,,but you'll see that the main feature is between a little Endian and a big endian machine
Dialogue: 0,0:59:52.74,0:59:56.76,csapp,,0,0,0,,when you have a integer the bytes get flipped around
Dialogue: 0,0:59:57.68,1:00:02.00,csapp,,0,0,0,, so that the least significant byte comes first in a little endian machine
Dialogue: 0,1:00:02.28,1:00:04.74,csapp,,0,0,0,, and last in a big endian machine
Dialogue: 0,1:00:05.74,1:00:08.72,csapp,,0,0,0,, and that's true with negative numbers as well
Dialogue: 0,1:00:09.28,1:00:14.28,csapp,,0,0,0,, that you'll get the the sign bits first in a big endian machine
Dialogue: 0,1:00:15.70,1:00:25.70,csapp,,0,0,0,,along you'll see that the only difference between a 32-bit machine a 64-bit machine
Dialogue: 0,1:00:25.70,1:00:30.70,csapp,,0,0,0,, is you have more zeros or more ones depending whether it's a positive or negative number 
Dialogue: 0,1:00:31.56,1:00:37.44,csapp,,0,0,0,,and again the a-sun and if I had access to a 64 bit machine
Dialogue: 0,1:00:37.66,1:00:41.24,csapp,,0,0,0,,Sun is now manufactured by a company called Oracle
Dialogue: 0,1:00:41.24,1:00:45.72,csapp,,0,0,0,, so in principle I could go get one of these machines and run this experiment
Dialogue: 0,1:00:46.00,1:00:48.96,csapp,,0,0,0,, but it's really not a very interesting experiment so I won't bother
Dialogue: 0,1:00:51.68,1:00:59.00,csapp,,0,0,0,,so in principle I could try it on a 64-bit Oracle machine and show you something different
Dialogue: 0,1:01:02.72,1:01:08.66,csapp,,0,0,0,, so one thing that it's kind of a useful tool the book goes through some examples of this 
Dialogue: 0,1:01:09.24,1:01:17.24,csapp,,0,0,0,,is a little program that will take a series of bytes starting at some position start
Dialogue: 0,1:01:17.86,1:01:21.16,csapp,,0,0,0,,and do it for however many bytes you request
Dialogue: 0,1:01:21.54,1:01:24.90,csapp,,0,0,0,, and just print out in hex format
Dialogue: 0,1:01:25.28,1:01:30.70,csapp,,0,0,0,,the two hex digits that represent that byte valve 
Dialogue: 0,1:01:31.94,1:01:36.54,csapp,,0,0,0,,and here this term pointer I'm using an unsigned care
Dialogue: 0,1:01:37.04,1:01:41.02,csapp,,0,0,0,, as a pointer type a sort of generic pointer type
Dialogue: 0,1:01:47.58,1:01:53.96,csapp,,0,0,0,,and so again if I run this on a x86 machine
Dialogue: 0,1:01:56.28,1:01:59.12,csapp,,0,0,0,, I'll oh and I'm also by the way printing out the actual address 
Dialogue: 0,1:01:59.26,1:02:03.30,csapp,,0,0,0,,this character is stored it to 
Dialogue: 0,1:02:03.74,1:02:09.42,csapp,,0,0,0,,and so you'll see that there is these addresses with a lot of 7Fs 
Dialogue: 0,1:02:10.22,1:02:15.02,csapp,,0,0,0,,what that means is it's in the upper end of this 47 bit address space
Dialogue: 0,1:02:15.02,1:02:16.76,csapp,,0,0,0,, if you work it through
Dialogue: 0,1:02:17.46,1:02:21.48,csapp,,0,0,0,,there's seven is three ones and then
Dialogue: 0,1:02:22.58,1:02:26.36,csapp,,0,0,0,,there's enough hex digits here to correspond to 
Dialogue: 0,1:02:27.12,1:02:29.72,csapp,,0,0,0,,so there's 11 hex digits beyond the seven 
Dialogue: 0,1:02:31.66,1:02:37.52,csapp,,0,0,0,,and you'll see that these addresses are at successive bytes bc bd be bf 
Dialogue: 0,1:02:38.24,1:02:42.98,csapp,,0,0,0,,and the values are 6d 3b 00 00 this is the least significant byte
Dialogue: 0,1:02:43.34,1:02:45.04,csapp,,0,0,0,,and these are the successive bytes 
Dialogue: 0,1:02:48.24,1:02:56.54,csapp,,0,0,0,,and similarly I can  use this to examine pointers of various sorts 
Dialogue: 0,1:02:56.54,1:03:01.60,csapp,,0,0,0,,and I can examine different values and just get their low-level byte representations
Dialogue: 0,1:03:02.18,1:03:05.76,csapp,,0,0,0,,and so I did this back when I could get to a Sun machine 
Dialogue: 0,1:03:05.78,1:03:07.92,csapp,,0,0,0,,it had one way of representing a pointer 
Dialogue: 0,1:03:08.30,1:03:10.66,csapp,,0,0,0,,and the main point is even across machines 
Dialogue: 0,1:03:10.66,1:03:14.02,csapp,,0,0,0,,whether it's a byte ordering or whatever
Dialogue: 0,1:03:14.44,1:03:17.52,csapp,,0,0,0,, you'll get different values for pointers there's no guarantee
Dialogue: 0,1:03:17.52,1:03:21.82,csapp,,0,0,0,, that when you load imputed a min to one machine  and run it
Dialogue: 0,1:03:22.04,1:03:28.06,csapp,,0,0,0,,that it will use the same addresses as that same programming running on a different machine
Dialogue: 0,1:03:28.06,1:03:32.38,csapp,,0,0,0,,even if actually they're identical hardware and operating system there can be variation
Dialogue: 0,1:03:33.44,1:03:39.22,csapp,,0,0,0,, because pointers aren't you you can't directly copy a pointer from one machine to another 
Dialogue: 0,1:03:41.24,1:03:47.48,csapp,,0,0,0,,on one thing about also is regardless of byte ordering
Dialogue: 0,1:03:47.48,1:03:51.32,csapp,,0,0,0,, the ordering of of characters is the same and 
Dialogue: 0,1:03:51.32,1:03:56.54,csapp,,0,0,0,,so a string in C is always represented by a series of bytes
Dialogue: 0,1:03:57.02,1:04:01.20,csapp,,0,0,0,,where the final byte is 0 note called null terminator
Dialogue: 0,1:04:01.50,1:04:08.06,csapp,,0,0,0,,and the individual bites correspond to the character codes for that number and
Dialogue: 0,1:04:08.36,1:04:12.92,csapp,,0,0,0,,and these character codes are just sometimes called ASCII format 
Dialogue: 0,1:04:13.68,1:04:15.78,csapp,,0,0,0,,which is a little bit old-fashioned by the way
Dialogue: 0,1:04:16.08,1:04:23.98,csapp,,0,0,0,, there's more modern character codes too that can represent non English alphabets 
Dialogue: 0,1:04:24.44,1:04:27.84,csapp,,0,0,0,,but the C standard is still back in the days of
Dialogue: 0,1:04:27.84,1:04:32.14,csapp,,0,0,0,,only supporting the the ASCII format
Dialogue: 0,1:04:32.14,1:04:33.14,csapp,,0,0,0,,question
Dialogue: 0,1:04:33.14,1:04:50.10,csapp,,0,0,0,, uh-huh yes 
Dialogue: 0,1:04:50.18,1:05:01.58,csapp,,0,0,0,,so this should have been...well no this is good so I'm casting
Dialogue: 0,1:05:01.88,1:05:05.00,csapp,,0,0,0,,I want to show the for bite size event
Dialogue: 0,1:05:05.24,1:05:07.00,csapp,,0,0,0,,for because this is an int I'm representing
Dialogue: 0,1:05:07.80,1:05:11.81,csapp,,0,0,0,, the pointer let's see the code where it's printing the pointer 
Dialogue: 0,1:05:12.20,1:05:19.68,csapp,,0,0,0,,all this notation %p is the directive to say print out a pointer proposed right
Dialogue: 0,1:05:20.18,1:05:25.74,csapp,,0,0,0,,and %X is the directive to print out a hex representation
Dialogue: 0,1:05:26.68,1:05:31.54,csapp,,0,0,0,, so it's printing out both the address the starting position of that particular byte
Dialogue: 0,1:05:31.90,1:05:34.66,csapp,,0,0,0,, and the value of that byte as two different things 
Dialogue: 0,1:05:34.90,1:05:36.90,csapp,,0,0,0,,does that answer your question
Dialogue: 0,1:05:37.04,1:05:51.98,csapp,,0,0,0,,yes ah 
Dialogue: 0,1:05:52.10,1:06:00.42,csapp,,0,0,0,,but remember show bytes is being given a pointer and a length 
Dialogue: 0,1:06:01.50,1:06:05.18,csapp,,0,0,0,,and so what this is and what it's saying is starting at that address
Dialogue: 0,1:06:05.76,1:06:09.02,csapp,,0,0,0,, print out the next series of bytes for me 
Dialogue: 0,1:06:09.02,1:06:11.22,csapp,,0,0,0,,how many bytes I asked for
Dialogue: 0,1:06:11.62,1:06:15.68,csapp,,0,0,0,, and in this case I'm creating a pointer to this integer
Dialogue: 0,1:06:15.90,1:06:22.26,csapp,,0,0,0,, but I want to show the the bytes in that integer the four bytes that make up that integer
Dialogue: 0,1:06:22.70,1:06:26.90,csapp,,0,0,0,, and that's why I'm giving it the number four here instead of eight is it
Dialogue: 0,1:06:26.90,1:06:32.84,csapp,,0,0,0,,[student question]
Dialogue: 0,1:06:32.84,1:06:34.62,csapp,,0,0,0,,yes it will be
Dialogue: 0,1:06:34.62,1:06:37.46,csapp,,0,0,0,, and that's fine because in this code
Dialogue: 0,1:06:37.84,1:06:43.78,csapp,,0,0,0,, it's I'm using the %P directive to designate how to print out the pointer 
Dialogue: 0,1:06:44.34,1:06:49.89,csapp,,0,0,0,,and that will print it as many bytes as it takes for that particular machine that it's running on
Dialogue: 0,1:06:50.74,1:06:53.64,csapp,,0,0,0,,so %P is actually a very handy directive
Dialogue: 0,1:06:53.64,1:06:57.64,csapp,,0,0,0,, if you have to print it addresses like for debugging purposes or something
Dialogue: 0,1:06:57.64,1:07:01.32,csapp,,0,0,0,, because it will automatically adapt to whatever machine it's running
Dialogue: 0,1:07:01.40,1:07:07.64,csapp,,0,0,0,,question
Dialogue: 0,1:07:07.78,1:07:11.15,csapp,,0,0,0,,well I've defined it to be an unsigned care here
Dialogue: 0,1:07:11.66,1:07:18.00,csapp,,0,0,0,,so type death is a way to introduce a name for some of datatype right 
Dialogue: 0,1:07:18.36,1:07:25.88,csapp,,0,0,0,,and so I've just declared a pointer quote pointer to refer to an unsigned care 
Dialogue: 0,1:07:26.36,1:07:34.34,csapp,,0,0,0,,if you did a void star it would not be happy with this reference here right 
Dialogue: 0,1:07:34.40,1:07:41.52,csapp,,0,0,0,,you can't reference a void star is just a way to pass around a generic pointer
Dialogue: 0,1:07:41.52,1:07:43.56,csapp,,0,0,0,, but you can't actually reference that element
Dialogue: 0,1:07:44.06,1:07:49.70,csapp,,0,0,0,, so what I'm basically doing is saying this reference is treat it like an array
Dialogue: 0,1:07:50.38,1:07:56.54,csapp,,0,0,0,, treat you treat my series of bytes is an array and print out each of the bytes in that array 
Dialogue: 0,1:08:01.26,1:08:07.16,csapp,,0,0,0,,and so here where I'm a is a number 
Dialogue: 0,1:08:07.42,1:08:11.18,csapp,,0,0,0,, and I'm taking the address of that integer 
Dialogue: 0,1:08:11.58,1:08:14.90,csapp,,0,0,0,,and casting it to be an unsigned care star 
Dialogue: 0,1:08:16.00,1:08:20.68,csapp,,0,0,0,,so sort of a generic slightly generic pointer but not quite as generic as void star
Dialogue: 0,1:08:21.58,1:08:26.50,csapp,,0,0,0,,and then printing it up was it good
Dialogue: 0,1:08:24.89,1:08:26.50,csapp,,0,0,0,,quite these are good questions 
Dialogue: 0,1:08:31.00,1:08:34.58,csapp,,0,0,0,,okay so the point being that strings are just strings 
Dialogue: 0,1:08:34.58,1:08:37.58,csapp,,0,0,0,,and that's the same from one machine to the next
Dialogue: 0,1:08:39.20,1:08:42.26,csapp,,0,0,0,, okay what soonish up today with some puzzles 
Dialogue: 0,1:08:42.26,1:08:46.48,csapp,,0,0,0,,and these have this annoying way of showing up on exams 
Dialogue: 0,1:08:46.84,1:08:50.66,csapp,,0,0,0,,so it's worth being able to do these kind of things 
Dialogue: 0,1:08:52.76,1:08:57.12,csapp,,0,0,0,,and you'll also notice I cleverly did not include the answers in the slides 
Dialogue: 0,1:09:00.84,1:09:04.36,csapp,,0,0,0,,so you can't just peek ahead and figure out what the answers are
Dialogue: 0,1:09:04.36,1:09:08.42,csapp,,0,0,0,, so let's just go through them but I actually worked them out to make sure I have the answers
Dialogue: 0,1:09:09.04,1:09:12.86,csapp,,0,0,0,, so if X and basically these are sort of statements 
Dialogue: 0,1:09:12.86,1:09:16.62,csapp,,0,0,0,,that you want to say these are either always true 
Dialogue: 0,1:09:17.02,1:09:19.82,csapp,,0,0,0,,and maybe there's some logic behind why it's always true 
Dialogue: 0,1:09:20.22,1:09:25.40,csapp,,0,0,0,,or it's possibly false and you won't have to give some example that would make that false 
Dialogue: 0,1:09:26.26,1:09:31.92,csapp,,0,0,0,,so let's go through these as many as we have time for  and see where we get to 
Dialogue: 0,1:09:31.92,1:09:35.56,csapp,,0,0,0,,so if I take X and I double it multiply it by 2
Dialogue: 0,1:09:35.98,1:09:41.43,csapp,,0,0,0,, if X who are negative and my guaranteed that 2x will be negative
Dialogue: 0,1:09:41.60,1:09:43.98,csapp,,0,0,0,,no so 
Dialogue: 0,1:09:44.68,1:09:49.82,csapp,,0,0,0,,by the way one general way to find counter examples is to try team  in 
Dialogue: 0,1:09:50.46,1:09:51.74,csapp,,0,0,0,,it's a really good one 
Dialogue: 0,1:09:52.40,1:09:57.44,csapp,,0,0,0,,and that works here right if I take team n which is one and a bunch of zeros I double it 
Dialogue: 0,1:09:57.96,1:10:02.90,csapp,,0,0,0,,it's like shifting it but left and it will become what 0 right is 
Dialogue: 0,1:10:05.12,1:10:09.58,csapp,,0,0,0,,and so again assume that X is at any negative number
Dialogue: 0,1:10:09.58,1:10:14.66,csapp,,0,0,0,, and UX is it's unsigned to any two's complement number
Dialogue: 0,1:10:15.08,1:10:19.20,csapp,,0,0,0,,and UX is what happens if I cast it to be unsigned 
Dialogue: 0,1:10:19.42,1:10:22.06,csapp,,0,0,0,,so as ux always you're greater than or equal to 0 
Dialogue: 0,1:10:22.06,1:10:25.72,csapp,,0,0,0,,yeah
Dialogue: 0,1:10:25.84,1:10:32.16,csapp,,0,0,0,,this is slightly more obscure if I take X and I mask off 7 
Dialogue: 0,1:10:32.16,1:10:34.78,csapp,,0,0,0,,you remember is the bit pattern 1 1 1 
Dialogue: 0,1:10:35.34,1:10:38.18,csapp,,0,0,0,,so if I mask off all but the lowest 3 bits 
Dialogue: 0,1:10:40.10,1:10:41.96,csapp,,0,0,0,,and I find that those are all ones 
Dialogue: 0,1:10:42.30,1:10:44.25,csapp,,0,0,0,,I'm already giving you the answer here
Dialogue: 0,1:10:44.25,1:10:47.08,csapp,,0,0,0,,and then I shift it left by 30 positions
Dialogue: 0,1:10:47.50,1:10:59.45,csapp,,0,0,0,,what can I say about the result
Dialogue: 0,1:10:59.84,1:11:06.00,csapp,,0,0,0,,so I know the x must finish with three ones right
Dialogue: 0,1:11:07.30,1:11:20.18,csapp,,0,0,0,, and I shift that by thirty
Dialogue: 0,1:11:20.18,1:11:25.24,csapp,,0,0,0,,and this these will be the only two bits that are left after the shifting 
Dialogue: 0,1:11:25.50,1:11:29.32,csapp,,0,0,0,,and they will be in the most significant position 
Dialogue: 0,1:11:29.32,1:11:33.02,csapp,,0,0,0,,so what can I say about that number is negative 
Dialogue: 0,1:11:33.34,1:11:37.51,csapp,,0,0,0,,so this is a true statement rather obscure but it is true
Dialogue: 0,1:11:37.51,1:11:45.60,csapp,,0,0,0,,is UX greater than -1
Dialogue: 0,1:11:45.64,1:11:50.66,csapp,,0,0,0,,it's almost true right 
Dialogue: 0,1:11:50.78,1:11:59.20,csapp,,0,0,0,,oh the one counterexample would be what zero
Dialogue: 0,1:11:59.26,1:12:03.40,csapp,,0,0,0,,well actually no you're right there's a lot of examples it's hardly ever true
Dialogue: 0,1:12:03.52,1:12:06.32,csapp,,0,0,0,,it's almost always false I was wrong 
Dialogue: 0,1:12:06.98,1:12:13.04,csapp,,0,0,0,,the only thing that would make it true would be XI it's never true
Dialogue: 0,1:12:13.20,1:12:15.78,csapp,,0,0,0,,[student laugh]
Dialogue: 0,1:12:15.78,1:12:16.88,csapp,,0,0,0,,  okay so it's never true 
Dialogue: 0,1:12:18.40,1:12:23.40,csapp,,0,0,0,,okay if X is greater than Y is -X less than -y
Dialogue: 0,1:12:35.24,1:12:39.38,csapp,,0,0,0,,No so by the way one thing we didn't really cover is 
Dialogue: 0,1:12:39.78,1:12:46.94,csapp,,0,0,0,,what is the negative of tea men 
Dialogue: 0,1:12:46.94,1:12:58.95,csapp,,0,0,0,,and to see that we can use our compliment  and income increment trick 
Dialogue: 0,1:12:58.95,1:13:04.82,csapp,,0,0,0,,so when you compliment and increment G min you get T min 
Dialogue: 0,1:13:05.22,1:13:08.90,csapp,,0,0,0,,and that's a why it's such a great counter example
Dialogue: 0,1:13:10.64,1:13:19.13,csapp,,0,0,0,, so in particular if Y is T min and X is something else
Dialogue: 0,1:13:19.92,1:13:26.30,csapp,,0,0,0,,then that left-hand part will be true but the right-hand part will not be true
Dialogue: 0,1:13:27.02,1:13:34.54,csapp,,0,0,0,,okay x*x greater than or equal to zero we've seen examples of that being false
Dialogue: 0,1:13:37.60,1:13:41.34,csapp,,0,0,0,,if X is this is kind of silly if X is greater than 0
Dialogue: 0,1:13:41.34,1:13:45.18,csapp,,0,0,0,, and Y is greater than 0 is X plus y greater than 0 no 
Dialogue: 0,1:13:47.24,1:13:53.79,csapp,,0,0,0,,if X is greater than or equal to 0 is minus X less than or equal to 0
Dialogue: 0,1:13:53.79,1:13:57.48,csapp,,0,0,0,,gotcha you're right it's true right
Dialogue: 0,1:13:58.12,1:14:06.03,csapp,,0,0,0,, because that but let's take it counter part if X is less than or equal to 0 is minus x squared equals 0
Dialogue: 0,1:14:06.90,1:14:14.82,csapp,,0,0,0,,team n right so right the point being that the largest any positive number can be represented as negative 
Dialogue: 0,1:14:15.40,1:14:19.46,csapp,,0,0,0,,but there's one negative number that can't be represented as positive 
Dialogue: 0,1:14:20.18,1:14:24.00,csapp,,0,0,0,,and so that asymmetry is why you get different answers to these
Dialogue: 0,1:14:25.44,1:14:31.76,csapp,,0,0,0,, if I take X and I look at -X and I shift them to the right by 31 
Dialogue: 0,1:14:33.60,1:14:35.20,csapp,,0,0,0,,am I going to get all ones
Dialogue: 0,1:14:36.44,1:14:48.08,csapp,,0,0,0,, this is a really weird statement
Dialogue: 0,1:14:48.90,1:14:51.02,csapp,,0,0,0,,so it actually kind of works right 
Dialogue: 0,1:14:51.48,1:15:02.56,csapp,,0,0,0,,if I take all zeros
Dialogue: 0,1:15:03.00,1:15:11.66,csapp,,0,0,0,,and I subtract one I'll get -1
Dialogue: 0,1:15:11.66,1:15:18.68,csapp,,0,0,0,,and I or them that works 
Dialogue: 0,1:15:19.52,1:15:26.26,csapp,,0,0,0,,so what's wrong with this what's that 
Dialogue: 0,1:15:27.62,1:15:32.82,csapp,,0,0,0,,oh but if I shift this to the right 31 places it's going to shift arithmetic
Dialogue: 0,1:15:32.84,1:15:43.24,csapp,,0,0,0,, what's that oh
Dialogue: 0,1:15:44.12,1:15:50.84,csapp,,0,0,0,,I see oh I'm sorry I already jumped ahead to a different puzzle
Dialogue: 0,1:15:52.94,1:15:59.01,csapp,,0,0,0,, X and  -X and I'm so you're right actually
Dialogue: 0,1:15:59.88,1:16:08.50,csapp,,0,0,0,,if the two numbers are 0 and I or those I get 0
Dialogue: 0,1:16:08.92,1:16:12.54,csapp,,0,0,0,, but you'll figure out you'll notice if it's anything non zero
Dialogue: 0,1:16:13.46,1:16:14.82,csapp,,0,0,0,,actually this will be true 
Dialogue: 0,1:16:16.12,1:16:18.04,csapp,,0,0,0,,and that's an interesting feature 
Dialogue: 0,1:16:18.26,1:16:22.04,csapp,,0,0,0,,so there's a couple other puzzles and I'll let you solve those on your own
Dialogue: 0,1:16:22.08,1:16:25.22,csapp,,0,0,0,, we're all set for today
