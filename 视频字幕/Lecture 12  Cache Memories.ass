[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Desktop/csapp/Lecture 12  Cache Memories.mp4
Video File: ../../../Desktop/csapp/Lecture 12  Cache Memories.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Video Position: 98

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: csapp,Source Han Sans CN,34,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:03.27,csapp,,0,0,0,,good afternoon everyone welcome to 213
Dialogue: 0,0:00:03.27,0:00:06.81,csapp,,0,0,0,,it's good to see you just a reminder
Dialogue: 0,0:00:06.81,0:00:10.79,csapp,,0,0,0,,that your attack lab is due tonight at
Dialogue: 0,0:00:10.79,0:00:14.70,csapp,,0,0,0,,11:59 p.m. you have one grace day for
Dialogue: 0,0:00:14.70,0:00:18.24,csapp,,0,0,0,,this for this lab and cache lab we'll go
Dialogue: 0,0:00:18.24,0:00:21.48,csapp,,0,0,0,,out it right about the same time now
Dialogue: 0,0:00:21.48,0:00:22.92,csapp,,0,0,0,,it's going to be a little tight for cash
Dialogue: 0,0:00:22.92,0:00:27.21,csapp,,0,0,0,,labs it'll be due next Thursday so you
Dialogue: 0,0:00:27.21,0:00:28.56,csapp,,0,0,0,,might want to you might want to get
Dialogue: 0,0:00:28.56,0:00:30.85,csapp,,0,0,0,,started on that soon
Dialogue: 0,0:00:30.85,0:00:34.50,csapp,,0,0,0,,b2 last lecture we learned about the
Dialogue: 0,0:00:34.50,0:00:36.84,csapp,,0,0,0,,memory hierarchy and the idea of caching
Dialogue: 0,0:00:36.84,0:00:38.73,csapp,,0,0,0,,today we're going to look at a very
Dialogue: 0,0:00:38.73,0:00:44.30,csapp,,0,0,0,,important kind of cache which is a which
Dialogue: 0,0:00:44.30,0:00:46.64,csapp,,0,0,0,,are which are called cache memories and
Dialogue: 0,0:00:46.64,0:00:49.35,csapp,,0,0,0,,they're they're very important to you as
Dialogue: 0,0:00:49.35,0:00:51.00,csapp,,0,0,0,,a programmer because they can have such
Dialogue: 0,0:00:51.00,0:00:52.73,csapp,,0,0,0,,a big impact on the performance of your
Dialogue: 0,0:00:52.73,0:00:55.23,csapp,,0,0,0,,program so if you know about these the
Dialogue: 0,0:00:55.23,0:00:56.94,csapp,,0,0,0,,existence of these cache memories and
Dialogue: 0,0:00:56.94,0:00:57.87,csapp,,0,0,0,,you know how they work
Dialogue: 0,0:00:57.87,0:01:00.69,csapp,,0,0,0,,as a programmer you'll be able to take
Dialogue: 0,0:01:00.69,0:01:07.54,csapp,,0,0,0,,advantage of that in your programs
Dialogue: 0,0:01:07.54,0:01:10.76,csapp,,0,0,0,,so last time we looked at that the
Dialogue: 0,0:01:10.76,0:01:13.01,csapp,,0,0,0,,memory hierarchy is a collection of
Dialogue: 0,0:01:13.01,0:01:20.62,csapp,,0,0,0,,storage devices with smaller costlier
Dialogue: 0,0:01:20.62,0:01:23.36,csapp,,0,0,0,,devices at the and faster devices at the
Dialogue: 0,0:01:23.36,0:01:29.06,csapp,,0,0,0,,top and slower cheaper and much larger
Dialogue: 0,0:01:29.06,0:01:32.45,csapp,,0,0,0,,devices at the at the bottom and then at
Dialogue: 0,0:01:32.45,0:01:36.22,csapp,,0,0,0,,each level in this hierarchy a the
Dialogue: 0,0:01:36.22,0:01:39.67,csapp,,0,0,0,,device at level K serves as a cache
Dialogue: 0,0:01:39.67,0:01:43.61,csapp,,0,0,0,,holds a subset of the blocks of that are
Dialogue: 0,0:01:43.61,0:01:46.10,csapp,,0,0,0,,contained in the device at the lower
Dialogue: 0,0:01:46.10,0:01:51.22,csapp,,0,0,0,,level at level K plus-1
Dialogue: 0,0:01:51.22,0:01:54.29,csapp,,0,0,0,,now recall the general idea of caching
Dialogue: 0,0:01:54.29,0:01:57.41,csapp,,0,0,0,,so we have a memory it's an array of
Dialogue: 0,0:01:57.41,0:01:59.86,csapp,,0,0,0,,bytes and it's it's we we break it up
Dialogue: 0,0:01:59.86,0:02:01.58,csapp,,0,0,0,,arbitrarily into a collection of blocks
Dialogue: 0,0:02:01.58,0:02:07.43,csapp,,0,0,0,,and these this memory is larger slower
Dialogue: 0,0:02:07.43,0:02:10.79,csapp,,0,0,0,,and cheaper and so it's and it's much
Dialogue: 0,0:02:10.79,0:02:12.98,csapp,,0,0,0,,larger than than a cache which is
Dialogue: 0,0:02:12.98,0:02:15.58,csapp,,0,0,0,,smaller faster and more expensive and
Dialogue: 0,0:02:15.58,0:02:18.11,csapp,,0,0,0,,which holds and which holds a subset of
Dialogue: 0,0:02:18.11,0:02:20.09,csapp,,0,0,0,,the blocks that are contained in the
Dialogue: 0,0:02:20.09,0:02:23.81,csapp,,0,0,0,,main memory and then blocks are copied
Dialogue: 0,0:02:23.81,0:02:25.54,csapp,,0,0,0,,back and forth between the cache in the
Dialogue: 0,0:02:25.54,0:02:27.65,csapp,,0,0,0,,memory in these block size transfer
Dialogue: 0,0:02:27.65,0:02:30.26,csapp,,0,0,0,,units so for example if our program
Dialogue: 0,0:02:30.26,0:02:33.92,csapp,,0,0,0,,requests a word that's in contained in
Dialogue: 0,0:02:33.92,0:02:40.37,csapp,,0,0,0,,block number 4 it asks the cache to to
Dialogue: 0,0:02:40.37,0:02:42.29,csapp,,0,0,0,,sent to return the word that's contained
Dialogue: 0,0:02:42.29,0:02:45.53,csapp,,0,0,0,,in block 4 the cache looks and it's at
Dialogue: 0,0:02:45.53,0:02:47.57,csapp,,0,0,0,,the blocks that it's the subset of the
Dialogue: 0,0:02:47.57,0:02:49.79,csapp,,0,0,0,,blocks that it's stored discovers that
Dialogue: 0,0:02:49.79,0:02:52.76,csapp,,0,0,0,,block 4 is not there so it asks the main
Dialogue: 0,0:02:52.76,0:02:55.51,csapp,,0,0,0,,memory to send it block 4 which it does
Dialogue: 0,0:02:55.51,0:02:58.25,csapp,,0,0,0,,and and then when it when that block
Dialogue: 0,0:02:58.25,0:03:01.51,csapp,,0,0,0,,arrives at the cache the cache stores it
Dialogue: 0,0:03:01.51,0:03:03.47,csapp,,0,0,0,,but potentially overwriting some
Dialogue: 0,0:03:03.47,0:03:06.86,csapp,,0,0,0,,existing block similarly if if our
Dialogue: 0,0:03:06.86,0:03:09.20,csapp,,0,0,0,,program asks for a data word if that's
Dialogue: 0,0:03:09.20,0:03:11.95,csapp,,0,0,0,,contained within block 10 the cache
Dialogue: 0,0:03:11.95,0:03:13.61,csapp,,0,0,0,,looks sees that it doesn't have that
Dialogue: 0,0:03:13.61,0:03:16.16,csapp,,0,0,0,,block so it requests that block for
Dialogue: 0,0:03:16.16,0:03:19.77,csapp,,0,0,0,,memory which copies it into the cache
Dialogue: 0,0:03:19.77,0:03:23.52,csapp,,0,0,0,,which overwrites an existing block now
Dialogue: 0,0:03:23.52,0:03:27.30,csapp,,0,0,0,,subsequently if if our program asks for
Dialogue: 0,0:03:27.30,0:03:30.42,csapp,,0,0,0,,a request or if our program references a
Dialogue: 0,0:03:30.42,0:03:32.73,csapp,,0,0,0,,word that's contained in block 10 for
Dialogue: 0,0:03:32.73,0:03:36.03,csapp,,0,0,0,,example then the cache then we have a
Dialogue: 0,0:03:36.03,0:03:38.19,csapp,,0,0,0,,hit and the cache can return that block
Dialogue: 0,0:03:38.19,0:03:40.92,csapp,,0,0,0,,immediately without going through the
Dialogue: 0,0:03:40.92,0:03:43.20,csapp,,0,0,0,,expensive operation of contacting memory
Dialogue: 0,0:03:43.20,0:03:45.66,csapp,,0,0,0,,and fetching that that block from memory
Dialogue: 0,0:03:45.66,0:03:52.58,csapp,,0,0,0,,now there's a very important class of of
Dialogue: 0,0:03:52.58,0:03:54.95,csapp,,0,0,0,,caches these so called cache memories
Dialogue: 0,0:03:54.95,0:03:58.50,csapp,,0,0,0,,which are contained in the CPU chip
Dialogue: 0,0:03:58.50,0:04:01.38,csapp,,0,0,0,,itself and are managed completely by
Dialogue: 0,0:04:01.38,0:04:03.51,csapp,,0,0,0,,Hardware and they're implemented using
Dialogue: 0,0:04:03.51,0:04:08.61,csapp,,0,0,0,,fast SRAM memories and the idea for this
Dialogue: 0,0:04:08.61,0:04:10.92,csapp,,0,0,0,,cache which is is right next to the
Dialogue: 0,0:04:10.92,0:04:14.67,csapp,,0,0,0,,register file is to hold frequently
Dialogue: 0,0:04:14.67,0:04:17.01,csapp,,0,0,0,,access blocks or blocks from main memory
Dialogue: 0,0:04:17.01,0:04:19.23,csapp,,0,0,0,,that are accessed frequently okay so
Dialogue: 0,0:04:19.23,0:04:21.63,csapp,,0,0,0,,hopefully because of the principle of
Dialogue: 0,0:04:21.63,0:04:25.83,csapp,,0,0,0,,locality most of our requests for data
Dialogue: 0,0:04:25.83,0:04:28.65,csapp,,0,0,0,,will actually be served out of this
Dialogue: 0,0:04:28.65,0:04:31.68,csapp,,0,0,0,,cache memory and a few cycles rather
Dialogue: 0,0:04:31.68,0:04:34.05,csapp,,0,0,0,,than in this that rather than from this
Dialogue: 0,0:04:34.05,0:04:41.40,csapp,,0,0,0,,slow main memory now cache memories are
Dialogue: 0,0:04:41.40,0:04:44.97,csapp,,0,0,0,,managed completely in Hardware so this
Dialogue: 0,0:04:44.97,0:04:47.64,csapp,,0,0,0,,means that the heart there's there has
Dialogue: 0,0:04:47.64,0:04:49.89,csapp,,0,0,0,,to be Hardware logic that knows how to
Dialogue: 0,0:04:49.89,0:04:52.19,csapp,,0,0,0,,look for blocks in the cache and
Dialogue: 0,0:04:52.19,0:04:54.15,csapp,,0,0,0,,determine whether or not a particular
Dialogue: 0,0:04:54.15,0:04:56.64,csapp,,0,0,0,,block is contained there so cache
Dialogue: 0,0:04:56.64,0:04:59.01,csapp,,0,0,0,,memories are have to be organized in a
Dialogue: 0,0:04:59.01,0:05:01.14,csapp,,0,0,0,,very kind of strict simple way so that
Dialogue: 0,0:05:01.14,0:05:03.33,csapp,,0,0,0,,the logic the lookup logic can be pretty
Dialogue: 0,0:05:03.33,0:05:07.35,csapp,,0,0,0,,simple so this is very all cache
Dialogue: 0,0:05:07.35,0:05:09.39,csapp,,0,0,0,,memories are organized within the
Dialogue: 0,0:05:09.39,0:05:13.80,csapp,,0,0,0,,following way you can think of that you
Dialogue: 0,0:05:13.80,0:05:16.23,csapp,,0,0,0,,can think of the cache as an array of s
Dialogue: 0,0:05:16.23,0:05:20.35,csapp,,0,0,0,,equals 2 to the S sets ok
Dialogue: 0,0:05:20.35,0:05:27.81,csapp,,0,0,0,,each set consists of e to the to e lines
Dialogue: 0,0:05:27.81,0:05:33.34,csapp,,0,0,0,,where each line consists of a block of B
Dialogue: 0,0:05:33.34,0:05:39.06,csapp,,0,0,0,,it equals 2 to the B bytes of data a
Dialogue: 0,0:05:39.06,0:05:44.29,csapp,,0,0,0,,valid bit which indicates whether these
Dialogue: 0,0:05:44.29,0:05:46.54,csapp,,0,0,0,,these data bits are actually that the
Dialogue: 0,0:05:46.54,0:05:47.98,csapp,,0,0,0,,bits and the data block are actually
Dialogue: 0,0:05:47.98,0:05:50.14,csapp,,0,0,0,,meaningful right it's possible they
Dialogue: 0,0:05:50.14,0:05:52.15,csapp,,0,0,0,,could just be random bits like you know
Dialogue: 0,0:05:52.15,0:05:53.55,csapp,,0,0,0,,when you first turn on the machine
Dialogue: 0,0:05:53.55,0:05:56.68,csapp,,0,0,0,,there's nothing in the cache but those
Dialogue: 0,0:05:56.68,0:05:58.54,csapp,,0,0,0,,bits will have values right that they'll
Dialogue: 0,0:05:58.54,0:05:59.98,csapp,,0,0,0,,lead to be ones or zeros but they won't
Dialogue: 0,0:05:59.98,0:06:02.41,csapp,,0,0,0,,actually correspond to data okay so the
Dialogue: 0,0:06:02.41,0:06:05.47,csapp,,0,0,0,,valid bit tells us if these if these be
Dialogue: 0,0:06:05.47,0:06:09.37,csapp,,0,0,0,,bytes actually mean anything and then
Dialogue: 0,0:06:09.37,0:06:11.35,csapp,,0,0,0,,there's some additional bits called the
Dialogue: 0,0:06:11.35,0:06:14.86,csapp,,0,0,0,,tag bits which will help us search for
Dialogue: 0,0:06:14.86,0:06:16.53,csapp,,0,0,0,,blocks which I'll show you in a minute
Dialogue: 0,0:06:16.53,0:06:19.26,csapp,,0,0,0,,now when we talk about our cache size
Dialogue: 0,0:06:19.26,0:06:23.35,csapp,,0,0,0,,we're referring to the number of data
Dialogue: 0,0:06:23.35,0:06:27.12,csapp,,0,0,0,,bytes that are contained in blocks and
Dialogue: 0,0:06:27.12,0:06:32.95,csapp,,0,0,0,,so each cache has there's s sets there's
Dialogue: 0,0:06:32.95,0:06:37.81,csapp,,0,0,0,,e e blocks per set and there's B bytes
Dialogue: 0,0:06:37.81,0:06:40.63,csapp,,0,0,0,,per block ok so the total cache size C
Dialogue: 0,0:06:40.63,0:06:46.36,csapp,,0,0,0,,is s times e times B ok now so there's a
Dialogue: 0,0:06:46.36,0:06:47.98,csapp,,0,0,0,,lot of terms to sort of keep straight
Dialogue: 0,0:06:47.98,0:06:51.01,csapp,,0,0,0,,and it's very easy to get to confuse the
Dialogue: 0,0:06:51.01,0:06:53.70,csapp,,0,0,0,,difference between lines and blocks and
Dialogue: 0,0:06:53.70,0:06:56.86,csapp,,0,0,0,,lines and sets okay so we'll go through
Dialogue: 0,0:06:56.86,0:06:59.50,csapp,,0,0,0,,some examples and hopefully these will
Dialogue: 0,0:06:59.50,0:07:01.15,csapp,,0,0,0,,see these will start to make more sense
Dialogue: 0,0:07:01.15,0:07:07.30,csapp,,0,0,0,,now let's look at in general how we how
Dialogue: 0,0:07:07.30,0:07:12.37,csapp,,0,0,0,,the cache Hardware implements a read so
Dialogue: 0,0:07:12.37,0:07:15.31,csapp,,0,0,0,,when our program accesses when our
Dialogue: 0,0:07:15.31,0:07:18.39,csapp,,0,0,0,,program executes an instruction that
Dialogue: 0,0:07:18.39,0:07:23.38,csapp,,0,0,0,,references some word in memory the the
Dialogue: 0,0:07:23.38,0:07:27.07,csapp,,0,0,0,,CPU sends that address to the cache and
Dialogue: 0,0:07:27.07,0:07:30.37,csapp,,0,0,0,,asks and it asks the cache to return the
Dialogue: 0,0:07:30.37,0:07:33.22,csapp,,0,0,0,,word
Dialogue: 0,0:07:33.22,0:07:37.60,csapp,,0,0,0,,the word at that address so the cash
Dialogue: 0,0:07:37.60,0:07:42.33,csapp,,0,0,0,,takes that address this would be a
Dialogue: 0,0:07:42.33,0:07:47.50,csapp,,0,0,0,,64-bit address in case of x86 64 and it
Dialogue: 0,0:07:47.50,0:07:51.07,csapp,,0,0,0,,it divides the address into a number of
Dialogue: 0,0:07:51.07,0:07:53.95,csapp,,0,0,0,,of regions which are which are
Dialogue: 0,0:07:53.95,0:07:55.75,csapp,,0,0,0,,determined by the organization of the
Dialogue: 0,0:07:55.75,0:07:58.39,csapp,,0,0,0,,cache okay they're determined by those
Dialogue: 0,0:07:58.39,0:08:03.43,csapp,,0,0,0,,parameters s sets the s the number of
Dialogue: 0,0:08:03.43,0:08:06.16,csapp,,0,0,0,,sets a the number of lines per set and B
Dialogue: 0,0:08:06.16,0:08:09.43,csapp,,0,0,0,,the size of each data block so the low
Dialogue: 0,0:08:09.43,0:08:12.55,csapp,,0,0,0,,order bits there are B low order bits
Dialogue: 0,0:08:12.55,0:08:15.58,csapp,,0,0,0,,which determine the offset in the block
Dialogue: 0,0:08:15.58,0:08:21.10,csapp,,0,0,0,,that that word starts at okay the next s
Dialogue: 0,0:08:21.10,0:08:25.66,csapp,,0,0,0,,fits are treated as an unsigned integer
Dialogue: 0,0:08:25.66,0:08:29.32,csapp,,0,0,0,,which serves as an index into the array
Dialogue: 0,0:08:29.32,0:08:31.84,csapp,,0,0,0,,of sets okay remember we just think of
Dialogue: 0,0:08:31.84,0:08:33.64,csapp,,0,0,0,,these as think of this cache as an array
Dialogue: 0,0:08:33.64,0:08:37.96,csapp,,0,0,0,,of set the set index bits provide the
Dialogue: 0,0:08:37.96,0:08:41.16,csapp,,0,0,0,,index into the into this array of sets
Dialogue: 0,0:08:41.16,0:08:46.06,csapp,,0,0,0,,and then all of the remaining bits all
Dialogue: 0,0:08:46.06,0:08:50.20,csapp,,0,0,0,,of the remaining T bits constitute what
Dialogue: 0,0:08:50.20,0:08:52.51,csapp,,0,0,0,,we call a tag which will help us when we
Dialogue: 0,0:08:52.51,0:08:55.87,csapp,,0,0,0,,do our search so the cache logic takes
Dialogue: 0,0:08:55.87,0:08:59.95,csapp,,0,0,0,,this address and it first extracts the
Dialogue: 0,0:08:59.95,0:09:03.52,csapp,,0,0,0,,the set index and uses that to as an
Dialogue: 0,0:09:03.52,0:09:05.83,csapp,,0,0,0,,index into this array to identify the
Dialogue: 0,0:09:05.83,0:09:09.61,csapp,,0,0,0,,set that if this block is in the set I'm
Dialogue: 0,0:09:09.61,0:09:12.94,csapp,,0,0,0,,sorry if the data word if the block that
Dialogue: 0,0:09:12.94,0:09:15.70,csapp,,0,0,0,,contains the data word at this address
Dialogue: 0,0:09:15.70,0:09:20.20,csapp,,0,0,0,,is in the cache it's going to be in the
Dialogue: 0,0:09:20.20,0:09:26.25,csapp,,0,0,0,,set denoted by the the set index okay
Dialogue: 0,0:09:26.25,0:09:29.86,csapp,,0,0,0,,so first it identifies which index to
Dialogue: 0,0:09:29.86,0:09:35.22,csapp,,0,0,0,,look in
Dialogue: 0,0:09:35.22,0:09:40.20,csapp,,0,0,0,,and then it checks the tag it checks all
Dialogue: 0,0:09:40.20,0:09:43.62,csapp,,0,0,0,,of the lines in that set to see if
Dialogue: 0,0:09:43.62,0:09:45.60,csapp,,0,0,0,,there's any any of those lines have a
Dialogue: 0,0:09:45.60,0:09:48.51,csapp,,0,0,0,,matching tag that a tag that matches the
Dialogue: 0,0:09:48.51,0:09:52.44,csapp,,0,0,0,,the T the tag bits and the address okay
Dialogue: 0,0:09:52.44,0:09:55.74,csapp,,0,0,0,,and if and it checks to see if the valid
Dialogue: 0,0:09:55.74,0:09:56.88,csapp,,0,0,0,,bit is turned on so if those two
Dialogue: 0,0:09:56.88,0:09:58.41,csapp,,0,0,0,,conditions holds if there's a line
Dialogue: 0,0:09:58.41,0:10:01.50,csapp,,0,0,0,,anywhere in the set as of where the
Dialogue: 0,0:10:01.50,0:10:04.32,csapp,,0,0,0,,valid bit is is is one and there's a
Dialogue: 0,0:10:04.32,0:10:07.95,csapp,,0,0,0,,matching tag then we have a hit okay
Dialogue: 0,0:10:07.95,0:10:09.60,csapp,,0,0,0,,then the block that we're looking for is
Dialogue: 0,0:10:09.60,0:10:17.16,csapp,,0,0,0,,contained in this set okay if we once we
Dialogue: 0,0:10:17.16,0:10:19.23,csapp,,0,0,0,,determine that with that we've we've
Dialogue: 0,0:10:19.23,0:10:21.87,csapp,,0,0,0,,identified the block then the cache uses
Dialogue: 0,0:10:21.87,0:10:24.81,csapp,,0,0,0,,that the low-order B bits to determine
Dialogue: 0,0:10:24.81,0:10:27.27,csapp,,0,0,0,,where that where the data we're
Dialogue: 0,0:10:27.27,0:10:29.76,csapp,,0,0,0,,interested in begins okay within that
Dialogue: 0,0:10:29.76,0:10:33.99,csapp,,0,0,0,,block all right let's look at a more
Dialogue: 0,0:10:33.99,0:10:36.81,csapp,,0,0,0,,specific example for a the simplest kind
Dialogue: 0,0:10:36.81,0:10:39.81,csapp,,0,0,0,,of cache which is when e equals one when
Dialogue: 0,0:10:39.81,0:10:44.07,csapp,,0,0,0,,there's only one line per set okay so a
Dialogue: 0,0:10:44.07,0:10:47.16,csapp,,0,0,0,,equal one one line per set this kind of
Dialogue: 0,0:10:47.16,0:10:52.41,csapp,,0,0,0,,cache is called a direct mapped cache so
Dialogue: 0,0:10:52.41,0:10:55.05,csapp,,0,0,0,,here we have s sets each set consists of
Dialogue: 0,0:10:55.05,0:10:57.99,csapp,,0,0,0,,a single line and now suppose our
Dialogue: 0,0:10:57.99,0:11:01.20,csapp,,0,0,0,,program references the data item and a
Dialogue: 0,0:11:01.20,0:11:04.73,csapp,,0,0,0,,particular address the CPU sense that
Dialogue: 0,0:11:04.73,0:11:07.86,csapp,,0,0,0,,address to the cache the cache takes
Dialogue: 0,0:11:07.86,0:11:09.68,csapp,,0,0,0,,that address breaks it up into these
Dialogue: 0,0:11:09.68,0:11:13.98,csapp,,0,0,0,,into these three fields in the in for
Dialogue: 0,0:11:13.98,0:11:16.35,csapp,,0,0,0,,this particular address the the block
Dialogue: 0,0:11:16.35,0:11:21.27,csapp,,0,0,0,,offset is four and the set index is one
Dialogue: 0,0:11:21.27,0:11:23.52,csapp,,0,0,0,,and then there's some tag bits which
Dialogue: 0,0:11:23.52,0:11:25.77,csapp,,0,0,0,,we'll just denote with with is a color
Dialogue: 0,0:11:25.77,0:11:31.31,csapp,,0,0,0,,pink so the cache extracts the set index
Dialogue: 0,0:11:31.31,0:11:34.38,csapp,,0,0,0,,which is one and then it uses that as as
Dialogue: 0,0:11:34.38,0:11:41.69,csapp,,0,0,0,,the index into the set
Dialogue: 0,0:11:41.69,0:11:43.76,csapp,,0,0,0,,and then it can just it just ignores all
Dialogue: 0,0:11:43.76,0:11:46.10,csapp,,0,0,0,,the other the sets if the block we're
Dialogue: 0,0:11:46.10,0:11:48.83,csapp,,0,0,0,,looking for is is in the cache it's
Dialogue: 0,0:11:48.83,0:11:50.65,csapp,,0,0,0,,going to be in this inset number one
Dialogue: 0,0:11:50.65,0:11:53.21,csapp,,0,0,0,,then it does the comparison of the tag
Dialogue: 0,0:11:53.21,0:11:55.82,csapp,,0,0,0,,bits and the valid bits and assume that
Dialogue: 0,0:11:55.82,0:11:57.95,csapp,,0,0,0,,they assume that valid bits on and that
Dialogue: 0,0:11:57.95,0:12:01.07,csapp,,0,0,0,,it matches then it looks at the block
Dialogue: 0,0:12:01.07,0:12:06.68,csapp,,0,0,0,,offset which is four and which tells it
Dialogue: 0,0:12:06.68,0:12:09.26,csapp,,0,0,0,,that the the four by four by ten suppose
Dialogue: 0,0:12:09.26,0:12:11.15,csapp,,0,0,0,,that that's what the instruction was was
Dialogue: 0,0:12:11.15,0:12:13.91,csapp,,0,0,0,,referencing the four byte in begins that
Dialogue: 0,0:12:13.91,0:12:17.27,csapp,,0,0,0,,offset for so now the cache takes takes
Dialogue: 0,0:12:17.27,0:12:20.30,csapp,,0,0,0,,this int and it sends it back to the to
Dialogue: 0,0:12:20.30,0:12:28.12,csapp,,0,0,0,,the CPU which puts it in the register
Dialogue: 0,0:12:28.12,0:12:32.03,csapp,,0,0,0,,okay if the tag doesn't match then the
Dialogue: 0,0:12:32.03,0:12:35.48,csapp,,0,0,0,,old-line if the tag doesn't match then
Dialogue: 0,0:12:35.48,0:12:39.11,csapp,,0,0,0,,there's a miss and in that case the
Dialogue: 0,0:12:39.11,0:12:41.93,csapp,,0,0,0,,cache has to fetch the block the
Dialogue: 0,0:12:41.93,0:12:44.66,csapp,,0,0,0,,corresponding block from memory and then
Dialogue: 0,0:12:44.66,0:12:48.28,csapp,,0,0,0,,overwrite this block in the line and
Dialogue: 0,0:12:48.28,0:12:51.08,csapp,,0,0,0,,then it can serve then it can fetch it
Dialogue: 0,0:12:51.08,0:12:53.72,csapp,,0,0,0,,can get the word out of out of the block
Dialogue: 0,0:12:53.72,0:12:57.86,csapp,,0,0,0,,and send it back to the processor okay
Dialogue: 0,0:12:57.86,0:12:59.27,csapp,,0,0,0,,now let me ask you a question just to
Dialogue: 0,0:12:59.27,0:13:01.25,csapp,,0,0,0,,see if kind of check to see if you're
Dialogue: 0,0:13:01.25,0:13:03.71,csapp,,0,0,0,,following along with this so if there's
Dialogue: 0,0:13:03.71,0:13:07.09,csapp,,0,0,0,,a Miss and the cache has two requests
Dialogue: 0,0:13:07.09,0:13:09.46,csapp,,0,0,0,,the block for memory
Dialogue: 0,0:13:09.46,0:13:11.93,csapp,,0,0,0,,fetch it from memory and then overwrite
Dialogue: 0,0:13:11.93,0:13:16.64,csapp,,0,0,0,,the the block in the current line does
Dialogue: 0,0:13:16.64,0:13:20.42,csapp,,0,0,0,,it also have to change the tag bits or
Dialogue: 0,0:13:20.42,0:13:23.42,csapp,,0,0,0,,do those stay the same so does the do
Dialogue: 0,0:13:23.42,0:13:26.93,csapp,,0,0,0,,the tag bits that were in this line get
Dialogue: 0,0:13:26.93,0:13:30.32,csapp,,0,0,0,,overwritten with a different value or is
Dialogue: 0,0:13:30.32,0:13:35.95,csapp,,0,0,0,,it the same same different
Dialogue: 0,0:13:35.95,0:13:44.32,csapp,,0,0,0,,say different now why would it be
Dialogue: 0,0:13:44.32,0:13:47.67,csapp,,0,0,0,,different
Dialogue: 0,0:13:47.67,0:13:55.69,csapp,,0,0,0,,we haven't changed yes I'm sorry
Dialogue: 0,0:13:55.69,0:14:01.99,csapp,,0,0,0,,oh it it almost certainly has different
Dialogue: 0,0:14:01.99,0:14:03.79,csapp,,0,0,0,,data but does it have a different
Dialogue: 0,0:14:03.79,0:14:12.85,csapp,,0,0,0,,address
Dialogue: 0,0:14:12.85,0:14:16.89,csapp,,0,0,0,,exactly it missed it missed because the
Dialogue: 0,0:14:16.89,0:14:19.50,csapp,,0,0,0,,tag it missed because the tag didn't
Dialogue: 0,0:14:19.50,0:14:21.41,csapp,,0,0,0,,match
Dialogue: 0,0:14:21.41,0:14:24.75,csapp,,0,0,0,,if the valid bit was false and the tag
Dialogue: 0,0:14:24.75,0:14:26.58,csapp,,0,0,0,,match then then that would also be a
Dialogue: 0,0:14:26.58,0:14:30.48,csapp,,0,0,0,,miss oh then you wouldn't okay that's
Dialogue: 0,0:14:30.48,0:14:33.75,csapp,,0,0,0,,right that's okay good good good okay
Dialogue: 0,0:14:33.75,0:14:38.78,csapp,,0,0,0,,great
Dialogue: 0,0:14:38.78,0:14:42.22,csapp,,0,0,0,,all right let me do a little let me do a
Dialogue: 0,0:14:42.22,0:14:46.74,csapp,,0,0,0,,really simple specific example of a how
Dialogue: 0,0:14:46.74,0:14:51.45,csapp,,0,0,0,,direct map cache works I want you to
Dialogue: 0,0:14:51.45,0:14:53.28,csapp,,0,0,0,,understand in real detail how this would
Dialogue: 0,0:14:53.28,0:14:54.91,csapp,,0,0,0,,work but I also want to make a point for
Dialogue: 0,0:14:54.91,0:14:58.02,csapp,,0,0,0,,about the weakness of direct mapped
Dialogue: 0,0:14:58.02,0:15:00.81,csapp,,0,0,0,,cache --is and why why you would want to
Dialogue: 0,0:15:00.81,0:15:05.28,csapp,,0,0,0,,have more than one line per set okay so
Dialogue: 0,0:15:05.28,0:15:07.89,csapp,,0,0,0,,we this is a really simple our met we
Dialogue: 0,0:15:07.89,0:15:10.95,csapp,,0,0,0,,have our memory system consists of 16
Dialogue: 0,0:15:10.95,0:15:12.48,csapp,,0,0,0,,bytes ok so it's not a very useful
Dialogue: 0,0:15:12.48,0:15:17.58,csapp,,0,0,0,,system with 4 bit addresses and and it's
Dialogue: 0,0:15:17.58,0:15:20.42,csapp,,0,0,0,,broken up into blocks of 2 bytes each
Dialogue: 0,0:15:20.42,0:15:25.38,csapp,,0,0,0,,our cache consists of 4 sets with one
Dialogue: 0,0:15:25.38,0:15:27.53,csapp,,0,0,0,,block per set
Dialogue: 0,0:15:27.53,0:15:32.42,csapp,,0,0,0,,now our 4 by our fort bit addresses
Dialogue: 0,0:15:32.42,0:15:36.69,csapp,,0,0,0,,because be equal to that's 2 to the 1 we
Dialogue: 0,0:15:36.69,0:15:38.97,csapp,,0,0,0,,only need 1 block offset bit right
Dialogue: 0,0:15:38.97,0:15:42.57,csapp,,0,0,0,,there's only 2 bytes in a block so the
Dialogue: 0,0:15:42.57,0:15:44.13,csapp,,0,0,0,,byte we're looking for is either at 0 or
Dialogue: 0,0:15:44.13,0:15:49.60,csapp,,0,0,0,,1 okay because we have 4 sets we need to
Dialogue: 0,0:15:49.60,0:15:52.95,csapp,,0,0,0,,set off set index bits and then the
Dialogue: 0,0:15:52.95,0:15:55.50,csapp,,0,0,0,,remaining bits are always tag bits in
Dialogue: 0,0:15:55.50,0:15:58.74,csapp,,0,0,0,,this case there's just one tag bed all
Dialogue: 0,0:15:58.74,0:16:01.44,csapp,,0,0,0,,right now let's let's suppose that our
Dialogue: 0,0:16:01.44,0:16:06.35,csapp,,0,0,0,,program executes instructions that
Dialogue: 0,0:16:06.35,0:16:09.57,csapp,,0,0,0,,reference the following memory address
Dialogue: 0,0:16:09.57,0:16:15.12,csapp,,0,0,0,,is 0 1 7 8 and 0 and these references
Dialogue: 0,0:16:15.12,0:16:17.55,csapp,,0,0,0,,are reads that they're reading one byte
Dialogue: 0,0:16:17.55,0:16:18.99,csapp,,0,0,0,,per read okay
Dialogue: 0,0:16:18.99,0:16:20.16,csapp,,0,0,0,,like I said this is a really simple
Dialogue: 0,0:16:20.16,0:16:22.68,csapp,,0,0,0,,system
Dialogue: 0,0:16:22.68,0:16:24.89,csapp,,0,0,0,,so let's look at what happens now we
Dialogue: 0,0:16:24.89,0:16:28.23,csapp,,0,0,0,,start out our tag our initially our our
Dialogue: 0,0:16:28.23,0:16:33.24,csapp,,0,0,0,,cache is empty valid bits are all set to
Dialogue: 0,0:16:33.24,0:16:37.82,csapp,,0,0,0,,zero and now the cache receives the
Dialogue: 0,0:16:37.82,0:16:42.11,csapp,,0,0,0,,request for the byte that's at address 0
Dialogue: 0,0:16:42.11,0:16:45.36,csapp,,0,0,0,,so it extracts the set index bits which
Dialogue: 0,0:16:45.36,0:16:49.52,csapp,,0,0,0,,in this case are 0 0 so these so it's
Dialogue: 0,0:16:49.52,0:16:54.80,csapp,,0,0,0,,going to look in set 0 for and in this
Dialogue: 0,0:16:54.80,0:16:56.75,csapp,,0,0,0,,case since valid is 0 it's just it's
Dialogue: 0,0:16:56.75,0:17:01.41,csapp,,0,0,0,,it's a Miss ok so it fetches that block
Dialogue: 0,0:17:01.41,0:17:06.36,csapp,,0,0,0,,from memory sticks the block so this
Dialogue: 0,0:17:06.36,0:17:10.40,csapp,,0,0,0,,memory this is the DS it this is using
Dialogue: 0,0:17:10.40,0:17:11.97,csapp,,0,0,0,,array notation for memory so this is
Dialogue: 0,0:17:11.97,0:17:15.31,csapp,,0,0,0,,like the the bytes that extend from
Dialogue: 0,0:17:15.31,0:17:20.00,csapp,,0,0,0,,offset 0 to offset 1 inclusive in memory
Dialogue: 0,0:17:20.00,0:17:25.25,csapp,,0,0,0,,the tag bit is 0 and the valid bit is 1
Dialogue: 0,0:17:25.25,0:17:28.19,csapp,,0,0,0,,ok now the next the next address that
Dialogue: 0,0:17:28.19,0:17:33.27,csapp,,0,0,0,,comes by is for address 1 well that's a
Dialogue: 0,0:17:33.27,0:17:36.05,csapp,,0,0,0,,hit right because we that block the
Dialogue: 0,0:17:36.05,0:17:38.66,csapp,,0,0,0,,block that contains the byte at address
Dialogue: 0,0:17:38.66,0:17:42.53,csapp,,0,0,0,,1 is already in the cache the tag and
Dialogue: 0,0:17:42.53,0:17:45.17,csapp,,0,0,0,,the tags match okay so we're good that's
Dialogue: 0,0:17:45.17,0:17:50.88,csapp,,0,0,0,,a hit you now we get address 7 so the
Dialogue: 0,0:17:50.88,0:17:54.27,csapp,,0,0,0,,cache extracts the set index bits which
Dialogue: 0,0:17:54.27,0:17:59.36,csapp,,0,0,0,,in this case are 1 1 or 4 or 3 rather
Dialogue: 0,0:17:59.36,0:18:03.05,csapp,,0,0,0,,looks in set 3 there's no valid bit so
Dialogue: 0,0:18:03.05,0:18:06.05,csapp,,0,0,0,,that's a Miss and it loads the the data
Dialogue: 0,0:18:06.05,0:18:07.97,csapp,,0,0,0,,from memory
Dialogue: 0,0:18:07.97,0:18:14.76,csapp,,0,0,0,,that spans bytes 6 & 7 in this case the
Dialogue: 0,0:18:14.76,0:18:18.89,csapp,,0,0,0,,the tag bit is 0 okay so we record that
Dialogue: 0,0:18:18.89,0:18:23.07,csapp,,0,0,0,,we record that in our metadata okay the
Dialogue: 0,0:18:23.07,0:18:27.24,csapp,,0,0,0,,next reference that comes by is 8 now 8
Dialogue: 0,0:18:27.24,0:18:32.10,csapp,,0,0,0,,has a set index of 0 0 0 but that's
Dialogue: 0,0:18:32.10,0:18:35.14,csapp,,0,0,0,,currently occupied by
Dialogue: 0,0:18:35.14,0:18:37.80,csapp,,0,0,0,,block zero one and we can tell that
Dialogue: 0,0:18:37.80,0:18:41.62,csapp,,0,0,0,,because address eight has a tag of one
Dialogue: 0,0:18:41.62,0:18:45.34,csapp,,0,0,0,,and the the existing block of the block
Dialogue: 0,0:18:45.34,0:18:47.98,csapp,,0,0,0,,at the earlier address at address zero
Dialogue: 0,0:18:47.98,0:18:51.40,csapp,,0,0,0,,has a tag of zero so that's a miss so
Dialogue: 0,0:18:51.40,0:18:54.07,csapp,,0,0,0,,now we have to go fetch the block
Dialogue: 0,0:18:54.07,0:18:58.63,csapp,,0,0,0,,containing byte number eight into memory
Dialogue: 0,0:18:58.63,0:19:01.39,csapp,,0,0,0,,so now we have bytes eight and nine and
Dialogue: 0,0:19:01.39,0:19:07.29,csapp,,0,0,0,,we in our new tag bed okay now the next
Dialogue: 0,0:19:07.29,0:19:14.11,csapp,,0,0,0,,instruction is for byte 0 and we just we
Dialogue: 0,0:19:14.11,0:19:16.33,csapp,,0,0,0,,just replaced we had that it we had that
Dialogue: 0,0:19:16.33,0:19:19.87,csapp,,0,0,0,,in our cache and we just replaced it so
Dialogue: 0,0:19:19.87,0:19:21.52,csapp,,0,0,0,,so it's another miss so that's
Dialogue: 0,0:19:21.52,0:19:25.00,csapp,,0,0,0,,unfortunate and it's the only reason we
Dialogue: 0,0:19:25.00,0:19:28.14,csapp,,0,0,0,,missed it is because we've got just one
Dialogue: 0,0:19:28.14,0:19:32.17,csapp,,0,0,0,,line per set right so we were forced to
Dialogue: 0,0:19:32.17,0:19:39.10,csapp,,0,0,0,,overwrite that that block containing
Dialogue: 0,0:19:39.10,0:19:42.42,csapp,,0,0,0,,bytes the block zero one when we when we
Dialogue: 0,0:19:42.42,0:19:48.16,csapp,,0,0,0,,missed on on block eight nine okay so
Dialogue: 0,0:19:48.16,0:19:50.50,csapp,,0,0,0,,this and you see there's plenty of room
Dialogue: 0,0:19:50.50,0:19:52.05,csapp,,0,0,0,,in our cache we've still got we've got
Dialogue: 0,0:19:52.05,0:19:55.30,csapp,,0,0,0,,two two lines that we haven't even
Dialogue: 0,0:19:55.30,0:19:58.00,csapp,,0,0,0,,access right so we've our cache is
Dialogue: 0,0:19:58.00,0:20:01.42,csapp,,0,0,0,,plenty big but just because of the sort
Dialogue: 0,0:20:01.42,0:20:04.24,csapp,,0,0,0,,of the low associativity of our cache
Dialogue: 0,0:20:04.24,0:20:06.94,csapp,,0,0,0,,and the the sort of the pattern the
Dialogue: 0,0:20:06.94,0:20:08.62,csapp,,0,0,0,,access pattern that we were presented
Dialogue: 0,0:20:08.62,0:20:11.50,csapp,,0,0,0,,with we've got a Miss that really was
Dialogue: 0,0:20:11.50,0:20:28.39,csapp,,0,0,0,,kind of unnecessary so oh yeah sorry
Dialogue: 0,0:20:28.39,0:20:32.24,csapp,,0,0,0,,six so when we referenced when we
Dialogue: 0,0:20:32.24,0:20:36.25,csapp,,0,0,0,,referenced a seven it's actually the
Dialogue: 0,0:20:36.25,0:20:40.16,csapp,,0,0,0,,it's at offset one in that block six
Dialogue: 0,0:20:40.16,0:20:42.74,csapp,,0,0,0,,seven okay since our blocks are two
Dialogue: 0,0:20:42.74,0:20:44.81,csapp,,0,0,0,,bytes they'll always start on an even
Dialogue: 0,0:20:44.81,0:20:51.20,csapp,,0,0,0,,multiple
Dialogue: 0,0:20:51.20,0:21:00.11,csapp,,0,0,0,,any other questions okay so this so this
Dialogue: 0,0:21:00.11,0:21:02.81,csapp,,0,0,0,,sort of is the reason why you have
Dialogue: 0,0:21:02.81,0:21:05.90,csapp,,0,0,0,,caches have higher associativity higher
Dialogue: 0,0:21:05.90,0:21:10.22,csapp,,0,0,0,,values of e so let's look at and and so
Dialogue: 0,0:21:10.22,0:21:15.41,csapp,,0,0,0,,for for values of e greater for values
Dialogue: 0,0:21:15.41,0:21:19.42,csapp,,0,0,0,,of e greater than greater than 1 we
Dialogue: 0,0:21:19.42,0:21:21.86,csapp,,0,0,0,,refer to them as a way so she set
Dialogue: 0,0:21:21.86,0:21:25.82,csapp,,0,0,0,,associative caches so here e equals 2 so
Dialogue: 0,0:21:25.82,0:21:30.53,csapp,,0,0,0,,it's a 2-way it's 2-way associative so
Dialogue: 0,0:21:30.53,0:21:33.11,csapp,,0,0,0,,let's let's suppose we have a 2-way a
Dialogue: 0,0:21:33.11,0:21:36.71,csapp,,0,0,0,,2-way associative cache so here we have
Dialogue: 0,0:21:36.71,0:21:39.89,csapp,,0,0,0,,we have our array of sets and now each
Dialogue: 0,0:21:39.89,0:21:43.43,csapp,,0,0,0,,set contains two lines ok instead of one
Dialogue: 0,0:21:43.43,0:21:49.22,csapp,,0,0,0,,line and suppose we're presented with an
Dialogue: 0,0:21:49.22,0:21:53.63,csapp,,0,0,0,,address with the following form we're
Dialogue: 0,0:21:53.63,0:21:56.03,csapp,,0,0,0,,looking for the word that begins at an
Dialogue: 0,0:21:56.03,0:22:03.04,csapp,,0,0,0,,off set of four inside our block at
Dialogue: 0,0:22:03.04,0:22:08.75,csapp,,0,0,0,,within set number one okay so the cache
Dialogue: 0,0:22:08.75,0:22:12.50,csapp,,0,0,0,,expects tracts that set index so this is
Dialogue: 0,0:22:12.50,0:22:18.07,csapp,,0,0,0,,set 0 this is set 1 this is set to
Dialogue: 0,0:22:18.07,0:22:21.83,csapp,,0,0,0,,throws away all the other sets and now
Dialogue: 0,0:22:21.83,0:22:28.34,csapp,,0,0,0,,in parallel it searches it searches the
Dialogue: 0,0:22:28.34,0:22:31.25,csapp,,0,0,0,,tags it searches for a matching tag in
Dialogue: 0,0:22:31.25,0:22:34.84,csapp,,0,0,0,,both of these both of these lines and
Dialogue: 0,0:22:34.84,0:22:37.43,csapp,,0,0,0,,ant a valid bit so if we get a matching
Dialogue: 0,0:22:37.43,0:22:41.60,csapp,,0,0,0,,tag and a valid bit true then we've got
Dialogue: 0,0:22:41.60,0:22:46.51,csapp,,0,0,0,,a a then we've got a hit
Dialogue: 0,0:22:46.51,0:22:54.05,csapp,,0,0,0,,now that yes yes
Dialogue: 0,0:22:54.05,0:22:58.57,csapp,,0,0,0,,oh it's a very good question so there's
Dialogue: 0,0:22:58.57,0:23:00.83,csapp,,0,0,0,,there's hardware logic that does that
Dialogue: 0,0:23:00.83,0:23:04.13,csapp,,0,0,0,,compare and it's and that's the reason
Dialogue: 0,0:23:04.13,0:23:06.71,csapp,,0,0,0,,that as as the number of as the
Dialogue: 0,0:23:06.71,0:23:08.75,csapp,,0,0,0,,associativity goes up that logic gets
Dialogue: 0,0:23:08.75,0:23:11.21,csapp,,0,0,0,,more and more expensive okay it's like
Dialogue: 0,0:23:11.21,0:23:13.64,csapp,,0,0,0,,something like you're kind of doing some
Dialogue: 0,0:23:13.64,0:23:18.23,csapp,,0,0,0,,kind of tree search and so that actually
Dialogue: 0,0:23:18.23,0:23:19.97,csapp,,0,0,0,,is the limit that's why I mean because
Dialogue: 0,0:23:19.97,0:23:22.76,csapp,,0,0,0,,in general right that if you take this
Dialogue: 0,0:23:22.76,0:23:27.49,csapp,,0,0,0,,to the limit there's just one set with
Dialogue: 0,0:23:27.49,0:23:30.05,csapp,,0,0,0,,there's just it's we call that a fully
Dialogue: 0,0:23:30.05,0:23:31.73,csapp,,0,0,0,,associative cache so there's just one
Dialogue: 0,0:23:31.73,0:23:35.06,csapp,,0,0,0,,set and now any block a block can go
Dialogue: 0,0:23:35.06,0:23:37.19,csapp,,0,0,0,,anywhere right there's no constraints
Dialogue: 0,0:23:37.19,0:23:40.01,csapp,,0,0,0,,now where you place a block but the
Dialogue: 0,0:23:40.01,0:23:43.04,csapp,,0,0,0,,because of the complexity of that that
Dialogue: 0,0:23:43.04,0:23:46.22,csapp,,0,0,0,,fully associative search those are very
Dialogue: 0,0:23:46.22,0:23:49.43,csapp,,0,0,0,,rare in fact you we do see we'll see
Dialogue: 0,0:23:49.43,0:23:52.13,csapp,,0,0,0,,fully associative caches caches but
Dialogue: 0,0:23:52.13,0:23:54.92,csapp,,0,0,0,,their software caches okay so in
Dialogue: 0,0:23:54.92,0:23:58.52,csapp,,0,0,0,,software and so the the complexity the
Dialogue: 0,0:23:58.52,0:24:03.11,csapp,,0,0,0,,hardware and sort of doesn't doesn't
Dialogue: 0,0:24:03.11,0:24:07.82,csapp,,0,0,0,,doesn't it it's not worth it's not worth
Dialogue: 0,0:24:07.82,0:24:09.35,csapp,,0,0,0,,the complexity of the hardware for the
Dialogue: 0,0:24:09.35,0:24:11.92,csapp,,0,0,0,,penalty of having a lower associativity
Dialogue: 0,0:24:11.92,0:24:14.78,csapp,,0,0,0,,okay but there are some systems later on
Dialogue: 0,0:24:14.78,0:24:18.59,csapp,,0,0,0,,when we study virtual memory the in a
Dialogue: 0,0:24:18.59,0:24:20.87,csapp,,0,0,0,,virtual memory system the DRAM serves as
Dialogue: 0,0:24:20.87,0:24:24.01,csapp,,0,0,0,,a cache for data stored on the disk and
Dialogue: 0,0:24:24.01,0:24:27.59,csapp,,0,0,0,,as we saw last time the penalty for a
Dialogue: 0,0:24:27.59,0:24:30.50,csapp,,0,0,0,,Miss if you have a cache on DRAM and you
Dialogue: 0,0:24:30.50,0:24:33.02,csapp,,0,0,0,,miss and you have to go to disk the
Dialogue: 0,0:24:33.02,0:24:35.75,csapp,,0,0,0,,penalty is huge for that and so because
Dialogue: 0,0:24:35.75,0:24:37.31,csapp,,0,0,0,,of that it's worth it's worthwhile
Dialogue: 0,0:24:37.31,0:24:41.93,csapp,,0,0,0,,having very complex searches search
Dialogue: 0,0:24:41.93,0:24:45.02,csapp,,0,0,0,,algorithms in particular in a virtual
Dialogue: 0,0:24:45.02,0:24:47.02,csapp,,0,0,0,,memory system that the DRAM is
Dialogue: 0,0:24:47.02,0:24:48.98,csapp,,0,0,0,,implements a fully associative cache
Dialogue: 0,0:24:48.98,0:24:51.11,csapp,,0,0,0,,where blocks from disk can go anywhere
Dialogue: 0,0:24:51.11,0:24:52.91,csapp,,0,0,0,,we'll get into that later when we look
Dialogue: 0,0:24:52.91,0:24:54.98,csapp,,0,0,0,,in in virtual memory but you're right
Dialogue: 0,0:24:54.98,0:24:57.44,csapp,,0,0,0,,you'll see in real systems nowadays that
Dialogue: 0,0:24:57.44,0:24:59.24,csapp,,0,0,0,,the number goes up right because feature
Dialogue: 0,0:24:59.24,0:25:02.18,csapp,,0,0,0,,sizes are going down and designers can
Dialogue: 0,0:25:02.18,0:25:04.34,csapp,,0,0,0,,afford to implement more expensive
Dialogue: 0,0:25:04.34,0:25:07.01,csapp,,0,0,0,,hardware but the the largest
Dialogue: 0,0:25:07.01,0:25:07.97,csapp,,0,0,0,,associativity are
Dialogue: 0,0:25:07.97,0:25:10.37,csapp,,0,0,0,,Intel systems that I know of is 16-way
Dialogue: 0,0:25:10.37,0:25:13.00,csapp,,0,0,0,,associative l3 caches and then the
Dialogue: 0,0:25:13.00,0:25:14.38,csapp,,0,0,0,,others are eight ways so she tips so
Dialogue: 0,0:25:14.38,0:25:15.25,csapp,,0,0,0,,that's sort of the order of magnitude
Dialogue: 0,0:25:15.25,0:25:21.01,csapp,,0,0,0,,that's state of the art right now okay
Dialogue: 0,0:25:21.01,0:25:23.75,csapp,,0,0,0,,so then once we've identified a match we
Dialogue: 0,0:25:23.75,0:25:26.96,csapp,,0,0,0,,use the set offset bits in this case
Dialogue: 0,0:25:26.96,0:25:30.11,csapp,,0,0,0,,we're accessing a short in so four is
Dialogue: 0,0:25:30.11,0:25:34.37,csapp,,0,0,0,,the offset within the block of this the
Dialogue: 0,0:25:34.37,0:25:36.28,csapp,,0,0,0,,two byte short int which then we can
Dialogue: 0,0:25:36.28,0:25:39.88,csapp,,0,0,0,,return to the processor alright so let's
Dialogue: 0,0:25:39.88,0:25:41.57,csapp,,0,0,0,,do that same simulation that we did
Dialogue: 0,0:25:41.57,0:25:45.01,csapp,,0,0,0,,before but this time with a two way
Dialogue: 0,0:25:45.01,0:25:48.50,csapp,,0,0,0,,associative cache now memory system is
Dialogue: 0,0:25:48.50,0:25:52.15,csapp,,0,0,0,,the same but now instead of one set we
Dialogue: 0,0:25:52.15,0:25:56.87,csapp,,0,0,0,,have two sets and I mean I'm sorry
Dialogue: 0,0:25:56.87,0:25:59.05,csapp,,0,0,0,,instead of four sets we have two sets so
Dialogue: 0,0:25:59.05,0:26:01.87,csapp,,0,0,0,,the cache this is the same sized cache
Dialogue: 0,0:26:01.87,0:26:03.52,csapp,,0,0,0,,but we're just going to organize it
Dialogue: 0,0:26:03.52,0:26:05.36,csapp,,0,0,0,,differently okay instead of one way
Dialogue: 0,0:26:05.36,0:26:09.13,csapp,,0,0,0,,instead of a direct mapped cache with
Dialogue: 0,0:26:09.13,0:26:11.14,csapp,,0,0,0,,four lines containing four lines one
Dialogue: 0,0:26:11.14,0:26:13.22,csapp,,0,0,0,,line per set we're going to implement a
Dialogue: 0,0:26:13.22,0:26:15.86,csapp,,0,0,0,,2-way associative cache where we have
Dialogue: 0,0:26:15.86,0:26:18.91,csapp,,0,0,0,,two sets with two lines per set okay so
Dialogue: 0,0:26:18.91,0:26:21.35,csapp,,0,0,0,,each case there's just four there's four
Dialogue: 0,0:26:21.35,0:26:26.99,csapp,,0,0,0,,total lines question
Dialogue: 0,0:26:26.99,0:26:31.23,csapp,,0,0,0,,like oh so that that comes in with the
Dialogue: 0,0:26:31.23,0:26:33.57,csapp,,0,0,0,,request somehow and I actually don't
Dialogue: 0,0:26:33.57,0:26:37.89,csapp,,0,0,0,,know the details of that it may I guess
Dialogue: 0,0:26:37.89,0:26:40.50,csapp,,0,0,0,,there so it could ask for just there
Dialogue: 0,0:26:40.50,0:26:42.24,csapp,,0,0,0,,could just be a default sighs maybe it's
Dialogue: 0,0:26:42.24,0:26:46.55,csapp,,0,0,0,,always it's always a 64-byte word and
Dialogue: 0,0:26:46.55,0:26:48.39,csapp,,0,0,0,,then the processor extracts that the
Dialogue: 0,0:26:48.39,0:26:50.64,csapp,,0,0,0,,current bits I actually don't know the
Dialogue: 0,0:26:50.64,0:26:53.52,csapp,,0,0,0,,details of that but it either comes in
Dialogue: 0,0:26:53.52,0:26:55.74,csapp,,0,0,0,,on the request or or there's a standard
Dialogue: 0,0:26:55.74,0:26:57.39,csapp,,0,0,0,,there's a standard size that the
Dialogue: 0,0:26:57.39,0:27:01.83,csapp,,0,0,0,,processor then parses out we'll just
Dialogue: 0,0:27:01.83,0:27:03.45,csapp,,0,0,0,,assume that the cache knows the what
Dialogue: 0,0:27:03.45,0:27:09.39,csapp,,0,0,0,,size to return yes how do you decide
Dialogue: 0,0:27:09.39,0:27:11.37,csapp,,0,0,0,,which block to replace that's that's a
Dialogue: 0,0:27:11.37,0:27:12.75,csapp,,0,0,0,,really good question so there's a lot of
Dialogue: 0,0:27:12.75,0:27:15.48,csapp,,0,0,0,,different algorithms the most the most
Dialogue: 0,0:27:15.48,0:27:18.17,csapp,,0,0,0,,common algorithm or a common algorithm
Dialogue: 0,0:27:18.17,0:27:21.57,csapp,,0,0,0,,is least recently used so by locality
Dialogue: 0,0:27:21.57,0:27:23.97,csapp,,0,0,0,,you you want to keep the you want to
Dialogue: 0,0:27:23.97,0:27:25.53,csapp,,0,0,0,,keep blocks in the cache that are being
Dialogue: 0,0:27:25.53,0:27:28.71,csapp,,0,0,0,,used a lot and so if a block isn't
Dialogue: 0,0:27:28.71,0:27:30.57,csapp,,0,0,0,,referenced for a long time by the
Dialogue: 0,0:27:30.57,0:27:32.67,csapp,,0,0,0,,principle of locality by sort of the
Dialogue: 0,0:27:32.67,0:27:35.91,csapp,,0,0,0,,inverse locality principle it's it's
Dialogue: 0,0:27:35.91,0:27:38.58,csapp,,0,0,0,,likely not to be addressed referenced in
Dialogue: 0,0:27:38.58,0:27:41.97,csapp,,0,0,0,,the near future so so that's one that's
Dialogue: 0,0:27:41.97,0:27:44.73,csapp,,0,0,0,,one algorithm that you just keep track
Dialogue: 0,0:27:44.73,0:27:47.73,csapp,,0,0,0,,of and and I'm not showing there needs
Dialogue: 0,0:27:47.73,0:27:49.86,csapp,,0,0,0,,to be additional bits in the line to
Dialogue: 0,0:27:49.86,0:27:52.29,csapp,,0,0,0,,sort of keep like sort of virtual
Dialogue: 0,0:27:52.29,0:27:55.17,csapp,,0,0,0,,timestamps that but that's that's a
Dialogue: 0,0:27:55.17,0:27:56.88,csapp,,0,0,0,,that's sort of the general way you do it
Dialogue: 0,0:27:56.88,0:27:59.76,csapp,,0,0,0,,just try to keep the things that are the
Dialogue: 0,0:27:59.76,0:28:02.19,csapp,,0,0,0,,blocks that are being accessed the most
Dialogue: 0,0:28:02.19,0:28:08.13,csapp,,0,0,0,,frequently most recently yes
Dialogue: 0,0:28:08.13,0:28:10.93,csapp,,0,0,0,,okay the question is what determines the
Dialogue: 0,0:28:10.93,0:28:13.78,csapp,,0,0,0,,block size that's determined by the
Dialogue: 0,0:28:13.78,0:28:16.45,csapp,,0,0,0,,design of the memory system so that's a
Dialogue: 0,0:28:16.45,0:28:19.66,csapp,,0,0,0,,that's that's a fixed parameter of the
Dialogue: 0,0:28:19.66,0:28:21.94,csapp,,0,0,0,,memory system so when the Intel
Dialogue: 0,0:28:21.94,0:28:25.33,csapp,,0,0,0,,designers decided to put cache memories
Dialogue: 0,0:28:25.33,0:28:28.00,csapp,,0,0,0,,on their processors they decided that
Dialogue: 0,0:28:28.00,0:28:38.40,csapp,,0,0,0,,the block size would be 64 bytes sorry
Dialogue: 0,0:28:38.40,0:28:42.79,csapp,,0,0,0,,so the block size comes the block size
Dialogue: 0,0:28:42.79,0:28:46.81,csapp,,0,0,0,,comes first then then you determine how
Dialogue: 0,0:28:46.81,0:28:50.23,csapp,,0,0,0,,big you want your cache to be okay and
Dialogue: 0,0:28:50.23,0:28:53.64,csapp,,0,0,0,,then and you determine the associativity
Dialogue: 0,0:28:53.64,0:28:56.47,csapp,,0,0,0,,okay and then once you've determined the
Dialogue: 0,0:28:56.47,0:28:58.39,csapp,,0,0,0,,associativity and you know how big your
Dialogue: 0,0:28:58.39,0:29:00.61,csapp,,0,0,0,,cache is then that determines the number
Dialogue: 0,0:29:00.61,0:29:01.99,csapp,,0,0,0,,of sets okay
Dialogue: 0,0:29:01.99,0:29:09.23,csapp,,0,0,0,,so basically all of those the
Dialogue: 0,0:29:09.23,0:29:15.80,csapp,,0,0,0,,the the number of lines and the cat and
Dialogue: 0,0:29:15.80,0:29:17.96,csapp,,0,0,0,,the capacity the number of lines per set
Dialogue: 0,0:29:17.96,0:29:20.39,csapp,,0,0,0,,is sort of a fixed high-level parameter
Dialogue: 0,0:29:20.39,0:29:22.82,csapp,,0,0,0,,design parameter the size of the cache
Dialogue: 0,0:29:22.82,0:29:25.67,csapp,,0,0,0,,is a is a is a high-level design
Dialogue: 0,0:29:25.67,0:29:27.86,csapp,,0,0,0,,parameter and then the number of sets
Dialogue: 0,0:29:27.86,0:29:30.65,csapp,,0,0,0,,then is induced from the from that okay
Dialogue: 0,0:29:30.65,0:29:36.44,csapp,,0,0,0,,yes
Dialogue: 0,0:29:36.44,0:29:43.22,csapp,,0,0,0,,ah that that's yeah how does so that's
Dialogue: 0,0:29:43.22,0:29:46.55,csapp,,0,0,0,,that's the replacement policy how does
Dialogue: 0,0:29:46.55,0:29:48.02,csapp,,0,0,0,,it so the question is how does it when
Dialogue: 0,0:29:48.02,0:29:49.49,csapp,,0,0,0,,there's multiple lines in a set how does
Dialogue: 0,0:29:49.49,0:29:51.74,csapp,,0,0,0,,it determine which to over overwrite and
Dialogue: 0,0:29:51.74,0:29:53.75,csapp,,0,0,0,,that was what that was the previous
Dialogue: 0,0:29:53.75,0:29:55.22,csapp,,0,0,0,,question probably maybe I should have
Dialogue: 0,0:29:55.22,0:29:57.80,csapp,,0,0,0,,repeated it so you try to pick a line
Dialogue: 0,0:29:57.80,0:30:01.04,csapp,,0,0,0,,that that was least recently used so
Dialogue: 0,0:30:01.04,0:30:03.85,csapp,,0,0,0,,lines lines that haven't been accessed
Dialogue: 0,0:30:03.85,0:30:05.78,csapp,,0,0,0,,recently are good candidates for
Dialogue: 0,0:30:05.78,0:30:07.88,csapp,,0,0,0,,replacement because because of the sort
Dialogue: 0,0:30:07.88,0:30:09.86,csapp,,0,0,0,,of inverse locality principle right that
Dialogue: 0,0:30:09.86,0:30:12.38,csapp,,0,0,0,,they haven't been inverse referenced
Dialogue: 0,0:30:12.38,0:30:14.03,csapp,,0,0,0,,recently chances are they won't be
Dialogue: 0,0:30:14.03,0:30:15.89,csapp,,0,0,0,,referenced again it
Dialogue: 0,0:30:15.89,0:30:20.51,csapp,,0,0,0,,oh yeah there's additional bits that I'm
Dialogue: 0,0:30:20.51,0:30:23.36,csapp,,0,0,0,,not showing here that you have to so so
Dialogue: 0,0:30:23.36,0:30:25.58,csapp,,0,0,0,,when you replace a line in the set if
Dialogue: 0,0:30:25.58,0:30:28.37,csapp,,0,0,0,,that data is has changed then it has to
Dialogue: 0,0:30:28.37,0:30:30.77,csapp,,0,0,0,,be written back to memory and that's
Dialogue: 0,0:30:30.77,0:30:35.78,csapp,,0,0,0,,another bit I haven't shown yes
Dialogue: 0,0:30:35.78,0:30:48.61,csapp,,0,0,0,,ah so the so yeah so this is a really
Dialogue: 0,0:30:48.61,0:30:52.04,csapp,,0,0,0,,this is really tricky parameter writing
Dialogue: 0,0:30:52.04,0:30:53.54,csapp,,0,0,0,,it's it's a it's a high level system
Dialogue: 0,0:30:53.54,0:30:56.19,csapp,,0,0,0,,parameter that's that it goes on for
Dialogue: 0,0:30:56.19,0:30:56.72,csapp,,0,0,0,,years
Dialogue: 0,0:30:56.72,0:30:59.72,csapp,,0,0,0,,so the idea you want to have blocks in
Dialogue: 0,0:30:59.72,0:31:03.29,csapp,,0,0,0,,order to exploit spatial locality right
Dialogue: 0,0:31:03.29,0:31:04.52,csapp,,0,0,0,,think about if you're going to go to the
Dialogue: 0,0:31:04.52,0:31:06.96,csapp,,0,0,0,,trouble of if you have a miss in cash
Dialogue: 0,0:31:06.96,0:31:09.26,csapp,,0,0,0,,and you're going to go to the trouble of
Dialogue: 0,0:31:09.26,0:31:11.48,csapp,,0,0,0,,going all the way to memory to get some
Dialogue: 0,0:31:11.48,0:31:14.51,csapp,,0,0,0,,data you want to you want to amortize
Dialogue: 0,0:31:14.51,0:31:17.24,csapp,,0,0,0,,the cost of fetching that data by
Dialogue: 0,0:31:17.24,0:31:20.24,csapp,,0,0,0,,fetching more than one byte that that's
Dialogue: 0,0:31:20.24,0:31:24.47,csapp,,0,0,0,,the motivation for blocks because by by
Dialogue: 0,0:31:24.47,0:31:26.26,csapp,,0,0,0,,the by the principle of locality in
Dialogue: 0,0:31:26.26,0:31:30.98,csapp,,0,0,0,,spatial locality in particular if you
Dialogue: 0,0:31:30.98,0:31:32.66,csapp,,0,0,0,,reference a word inside of a block
Dialogue: 0,0:31:32.66,0:31:34.25,csapp,,0,0,0,,chances are you're going to reference a
Dialogue: 0,0:31:34.25,0:31:36.05,csapp,,0,0,0,,nearby word which will also be an
Dialogue: 0,0:31:36.05,0:31:38.97,csapp,,0,0,0,,epilogue okay so blocks the whole
Dialogue: 0,0:31:38.97,0:31:42.26,csapp,,0,0,0,,purpose of blocks is to exploit spatial
Dialogue: 0,0:31:42.26,0:31:45.35,csapp,,0,0,0,,locality now if you make your block too
Dialogue: 0,0:31:45.35,0:31:49.01,csapp,,0,0,0,,small then you don't you don't amortize
Dialogue: 0,0:31:49.01,0:31:50.82,csapp,,0,0,0,,you don't get the same amortization
Dialogue: 0,0:31:50.82,0:31:53.22,csapp,,0,0,0,,right you maybe get one you bring the
Dialogue: 0,0:31:53.22,0:31:56.09,csapp,,0,0,0,,block in so there's a reference you get
Dialogue: 0,0:31:56.09,0:31:58.25,csapp,,0,0,0,,a miss you bring the block in there's
Dialogue: 0,0:31:58.25,0:32:00.05,csapp,,0,0,0,,another reference nearby you get a hit
Dialogue: 0,0:32:00.05,0:32:02.51,csapp,,0,0,0,,because the blocks in memory but then
Dialogue: 0,0:32:02.51,0:32:04.47,csapp,,0,0,0,,the next reference is in a different
Dialogue: 0,0:32:04.47,0:32:06.41,csapp,,0,0,0,,block because your block sizes are too
Dialogue: 0,0:32:06.41,0:32:09.23,csapp,,0,0,0,,small right so you kind of want to make
Dialogue: 0,0:32:09.23,0:32:12.21,csapp,,0,0,0,,blocks big as big as possible but
Dialogue: 0,0:32:12.21,0:32:13.95,csapp,,0,0,0,,without slowing the system down so if
Dialogue: 0,0:32:13.95,0:32:15.57,csapp,,0,0,0,,you made your block size too big it
Dialogue: 0,0:32:15.57,0:32:17.09,csapp,,0,0,0,,would just take too long to bring that
Dialogue: 0,0:32:17.09,0:32:22.97,csapp,,0,0,0,,block in plus plus now your blocks that
Dialogue: 0,0:32:22.97,0:32:24.72,csapp,,0,0,0,,your blocks are taking up bits in your
Dialogue: 0,0:32:24.72,0:32:27.38,csapp,,0,0,0,,cache memory so now there's no room for
Dialogue: 0,0:32:27.38,0:32:29.19,csapp,,0,0,0,,other blocks right so it's a really it's
Dialogue: 0,0:32:29.19,0:32:31.79,csapp,,0,0,0,,a really tricky design problem right and
Dialogue: 0,0:32:31.79,0:32:34.73,csapp,,0,0,0,,I if we're doing it taking an
Dialogue: 0,0:32:34.73,0:32:36.33,csapp,,0,0,0,,architecture class then we would we
Dialogue: 0,0:32:36.33,0:32:38.54,csapp,,0,0,0,,would sort of dive into the you know how
Dialogue: 0,0:32:38.54,0:32:40.85,csapp,,0,0,0,,how architects make those design
Dialogue: 0,0:32:40.85,0:32:43.04,csapp,,0,0,0,,decisions but in general that's what
Dialogue: 0,0:32:43.04,0:32:46.15,csapp,,0,0,0,,it's kind of a balancing act right
Dialogue: 0,0:32:46.15,0:32:54.45,csapp,,0,0,0,,were there any other questions yes
Dialogue: 0,0:32:54.45,0:32:58.35,csapp,,0,0,0,,Oh the question is every time there's a
Dialogue: 0,0:32:58.35,0:33:00.11,csapp,,0,0,0,,miss do you have to do you have to
Dialogue: 0,0:33:00.11,0:33:03.09,csapp,,0,0,0,,select a victim line and override it
Dialogue: 0,0:33:03.09,0:33:05.48,csapp,,0,0,0,,yeah I don't know of any caches that
Dialogue: 0,0:33:05.48,0:33:08.78,csapp,,0,0,0,,that don't do that now we'll see when we
Dialogue: 0,0:33:08.78,0:33:11.42,csapp,,0,0,0,,look at rights we'll see there's an
Dialogue: 0,0:33:11.42,0:33:13.91,csapp,,0,0,0,,option of whether we're only looking at
Dialogue: 0,0:33:13.91,0:33:16.08,csapp,,0,0,0,,reads right now but with rights that
Dialogue: 0,0:33:16.08,0:33:20.00,csapp,,0,0,0,,question does come up okay and if if you
Dialogue: 0,0:33:20.00,0:33:22.83,csapp,,0,0,0,,wait and in a couple of slides we'll go
Dialogue: 0,0:33:22.83,0:33:25.08,csapp,,0,0,0,,over we'll go over that any other
Dialogue: 0,0:33:25.08,0:33:30.09,csapp,,0,0,0,,questions okay so let's look at this
Dialogue: 0,0:33:30.09,0:33:33.04,csapp,,0,0,0,,this two-way associative cache now
Dialogue: 0,0:33:33.04,0:33:37.44,csapp,,0,0,0,,there's there's one block offset bit we
Dialogue: 0,0:33:37.44,0:33:39.05,csapp,,0,0,0,,only have two sets so that we only need
Dialogue: 0,0:33:39.05,0:33:41.87,csapp,,0,0,0,,one set index and then the remaining two
Dialogue: 0,0:33:41.87,0:33:44.70,csapp,,0,0,0,,bits are tagged so let's go through our
Dialogue: 0,0:33:44.70,0:33:48.38,csapp,,0,0,0,,trace so address zero has a set is in
Dialogue: 0,0:33:48.38,0:33:53.27,csapp,,0,0,0,,set zero right here that's a Miss so we
Dialogue: 0,0:33:53.27,0:34:00.38,csapp,,0,0,0,,load that into memory with the reference
Dialogue: 0,0:34:00.38,0:34:03.60,csapp,,0,0,0,,to address one that's in set zero and
Dialogue: 0,0:34:03.60,0:34:06.14,csapp,,0,0,0,,that's a hit because that that byte is
Dialogue: 0,0:34:06.14,0:34:09.72,csapp,,0,0,0,,in is in our block the reference to
Dialogue: 0,0:34:09.72,0:34:12.41,csapp,,0,0,0,,seven is a Miss that's in set one so we
Dialogue: 0,0:34:12.41,0:34:14.15,csapp,,0,0,0,,load that and we were just picking
Dialogue: 0,0:34:14.15,0:34:17.04,csapp,,0,0,0,,randomly pick one of these two over
Dialogue: 0,0:34:17.04,0:34:20.25,csapp,,0,0,0,,right because they're there the cache is
Dialogue: 0,0:34:20.25,0:34:22.95,csapp,,0,0,0,,empty the next reference is to address
Dialogue: 0,0:34:22.95,0:34:26.28,csapp,,0,0,0,,number eight which is in set zero now
Dialogue: 0,0:34:26.28,0:34:28.55,csapp,,0,0,0,,here's here's the difference between the
Dialogue: 0,0:34:28.55,0:34:30.56,csapp,,0,0,0,,direct mapped cache and this 2-way
Dialogue: 0,0:34:30.56,0:34:33.65,csapp,,0,0,0,,set-associative cache when we when we
Dialogue: 0,0:34:33.65,0:34:38.60,csapp,,0,0,0,,reference address eight that block has
Dialogue: 0,0:34:38.60,0:34:40.55,csapp,,0,0,0,,to the corresponding block has to go
Dialogue: 0,0:34:40.55,0:34:44.28,csapp,,0,0,0,,into set 0 because of this zero set
Dialogue: 0,0:34:44.28,0:34:46.74,csapp,,0,0,0,,index bit but we've got room now because
Dialogue: 0,0:34:46.74,0:34:48.41,csapp,,0,0,0,,we are set to have room for two lines
Dialogue: 0,0:34:48.41,0:34:51.96,csapp,,0,0,0,,instead of one so when we load that in
Dialogue: 0,0:34:51.96,0:34:55.04,csapp,,0,0,0,,well if we have an available empty slot
Dialogue: 0,0:34:55.04,0:34:56.39,csapp,,0,0,0,,we'll put it there we won't overwrite
Dialogue: 0,0:34:56.39,0:34:58.29,csapp,,0,0,0,,anything right so if possible always try
Dialogue: 0,0:34:58.29,0:35:02.94,csapp,,0,0,0,,to overwrite empty empty lines so now
Dialogue: 0,0:35:02.94,0:35:06.05,csapp,,0,0,0,,we've got in this set we've got block 0
Dialogue: 0,0:35:06.05,0:35:07.86,csapp,,0,0,0,,1 and block 8 9
Dialogue: 0,0:35:07.86,0:35:11.55,csapp,,0,0,0,,so when we get our reference to block to
Dialogue: 0,0:35:11.55,0:35:14.19,csapp,,0,0,0,,address zero whereas before with the
Dialogue: 0,0:35:14.19,0:35:16.14,csapp,,0,0,0,,when we had a conflict miss in the
Dialogue: 0,0:35:16.14,0:35:18.24,csapp,,0,0,0,,direct map cache now we can we can
Dialogue: 0,0:35:18.24,0:35:21.09,csapp,,0,0,0,,satisfy that that request it hits in
Dialogue: 0,0:35:21.09,0:35:22.29,csapp,,0,0,0,,memory and week and the cache can
Dialogue: 0,0:35:22.29,0:35:24.30,csapp,,0,0,0,,satisfy it from from the cache instead
Dialogue: 0,0:35:24.30,0:35:29.76,csapp,,0,0,0,,of going to memory okay so that makes
Dialogue: 0,0:35:29.76,0:35:39.27,csapp,,0,0,0,,sense okay now what about rights so
Dialogue: 0,0:35:39.27,0:35:41.30,csapp,,0,0,0,,there's multiple copies of the data
Dialogue: 0,0:35:41.30,0:35:44.22,csapp,,0,0,0,,right we're sub setting as we move up
Dialogue: 0,0:35:44.22,0:35:46.11,csapp,,0,0,0,,the hierarchy we're creating subsets of
Dialogue: 0,0:35:46.11,0:35:52.71,csapp,,0,0,0,,the data in the caches so what do we do
Dialogue: 0,0:35:52.71,0:35:58.35,csapp,,0,0,0,,if we do a write to a word within a
Dialogue: 0,0:35:58.35,0:36:03.00,csapp,,0,0,0,,block that's currently in the cache okay
Dialogue: 0,0:36:03.00,0:36:05.97,csapp,,0,0,0,,we have we have two options we can write
Dialogue: 0,0:36:05.97,0:36:08.67,csapp,,0,0,0,,that block immediately to memory right
Dialogue: 0,0:36:08.67,0:36:11.07,csapp,,0,0,0,,we're we've got a block that's like this
Dialogue: 0,0:36:11.07,0:36:12.90,csapp,,0,0,0,,big and we're updating a little chunk of
Dialogue: 0,0:36:12.90,0:36:17.13,csapp,,0,0,0,,it so we can we can either do the update
Dialogue: 0,0:36:17.13,0:36:18.81,csapp,,0,0,0,,and then flush it to memory immediately
Dialogue: 0,0:36:18.81,0:36:21.99,csapp,,0,0,0,,so that memory always mirrors the
Dialogue: 0,0:36:21.99,0:36:23.82,csapp,,0,0,0,,contents of memory always mirror the
Dialogue: 0,0:36:23.82,0:36:28.65,csapp,,0,0,0,,contents of the cache okay but that's
Dialogue: 0,0:36:28.65,0:36:31.14,csapp,,0,0,0,,expensive right I mean you know memory
Dialogue: 0,0:36:31.14,0:36:34.53,csapp,,0,0,0,,accesses are expensive the other so the
Dialogue: 0,0:36:34.53,0:36:36.33,csapp,,0,0,0,,other option is what what's called write
Dialogue: 0,0:36:36.33,0:36:36.96,csapp,,0,0,0,,back
Dialogue: 0,0:36:36.96,0:36:39.72,csapp,,0,0,0,,so in this case when we write to a block
Dialogue: 0,0:36:39.72,0:36:44.10,csapp,,0,0,0,,in the cache we don't we don't flush it
Dialogue: 0,0:36:44.10,0:36:47.79,csapp,,0,0,0,,to memory until we elect that particular
Dialogue: 0,0:36:47.79,0:36:50.19,csapp,,0,0,0,,line as a victim that's going to be
Dialogue: 0,0:36:50.19,0:36:54.09,csapp,,0,0,0,,overwritten and only then only then when
Dialogue: 0,0:36:54.09,0:36:56.43,csapp,,0,0,0,,we're just we sort of defer the writing
Dialogue: 0,0:36:56.43,0:36:58.37,csapp,,0,0,0,,to memory until the last possible minute
Dialogue: 0,0:36:58.37,0:37:02.34,csapp,,0,0,0,,we defer it until just before the cache
Dialogue: 0,0:37:02.34,0:37:04.71,csapp,,0,0,0,,would overwrite that that data block
Dialogue: 0,0:37:04.71,0:37:07.65,csapp,,0,0,0,,okay so that's called right back and for
Dialogue: 0,0:37:07.65,0:37:09.09,csapp,,0,0,0,,right back you need to have some an
Dialogue: 0,0:37:09.09,0:37:10.68,csapp,,0,0,0,,extra bit in the line that indicates
Dialogue: 0,0:37:10.68,0:37:12.68,csapp,,0,0,0,,whether that that blocks been written to
Dialogue: 0,0:37:12.68,0:37:16.05,csapp,,0,0,0,,so the algorithm is when when the cache
Dialogue: 0,0:37:16.05,0:37:18.06,csapp,,0,0,0,,identifies a particular line to
Dialogue: 0,0:37:18.06,0:37:21.27,csapp,,0,0,0,,overwrite it checks the dirty bit on
Dialogue: 0,0:37:21.27,0:37:21.66,csapp,,0,0,0,,that
Dialogue: 0,0:37:21.66,0:37:24.03,csapp,,0,0,0,,fine if it's set then it writes that
Dialogue: 0,0:37:24.03,0:37:29.28,csapp,,0,0,0,,data to back to disk okay if the if the
Dialogue: 0,0:37:29.28,0:37:30.99,csapp,,0,0,0,,data hasn't if that block hasn't been
Dialogue: 0,0:37:30.99,0:37:32.40,csapp,,0,0,0,,written there's no point there's no need
Dialogue: 0,0:37:32.40,0:37:34.47,csapp,,0,0,0,,to write it back because it's the same
Dialogue: 0,0:37:34.47,0:37:37.47,csapp,,0,0,0,,it has the same value as the copy of the
Dialogue: 0,0:37:37.47,0:37:43.31,csapp,,0,0,0,,block on disk okay now so what about so
Dialogue: 0,0:37:43.31,0:37:44.88,csapp,,0,0,0,,that's a right here now what happens if
Dialogue: 0,0:37:44.88,0:37:47.13,csapp,,0,0,0,,we have a right miss so we're doing a
Dialogue: 0,0:37:47.13,0:37:51.78,csapp,,0,0,0,,write to memory and the word that we're
Dialogue: 0,0:37:51.78,0:37:54.90,csapp,,0,0,0,,writing is is not contained in any block
Dialogue: 0,0:37:54.90,0:37:58.47,csapp,,0,0,0,,that's in our cache so we have two
Dialogue: 0,0:37:58.47,0:37:59.94,csapp,,0,0,0,,options we can do what's called write
Dialogue: 0,0:37:59.94,0:38:01.82,csapp,,0,0,0,,allocate so we can treat it if if
Dialogue: 0,0:38:01.82,0:38:03.99,csapp,,0,0,0,,there's a Miss we can do sort of the
Dialogue: 0,0:38:03.99,0:38:05.73,csapp,,0,0,0,,symmetric thing that we did with it with
Dialogue: 0,0:38:05.73,0:38:08.88,csapp,,0,0,0,,a hit which was create a new a newline
Dialogue: 0,0:38:08.88,0:38:11.06,csapp,,0,0,0,,possibly overwriting an existing line
Dialogue: 0,0:38:11.06,0:38:15.08,csapp,,0,0,0,,and then write in so we could so we
Dialogue: 0,0:38:15.08,0:38:17.60,csapp,,0,0,0,,could create that cache enter that cache
Dialogue: 0,0:38:17.60,0:38:20.01,csapp,,0,0,0,,line fetch it from memory and then do
Dialogue: 0,0:38:20.01,0:38:23.30,csapp,,0,0,0,,and then do the do the right okay so
Dialogue: 0,0:38:23.30,0:38:25.02,csapp,,0,0,0,,this is sort of symmetric to reads right
Dialogue: 0,0:38:25.02,0:38:28.55,csapp,,0,0,0,,then so every right if it misses when
Dialogue: 0,0:38:28.55,0:38:31.31,csapp,,0,0,0,,the write finishes the that block will
Dialogue: 0,0:38:31.31,0:38:33.69,csapp,,0,0,0,,be in the cache and if we do a
Dialogue: 0,0:38:33.69,0:38:36.18,csapp,,0,0,0,,subsequent read we get a hit okay so
Dialogue: 0,0:38:36.18,0:38:37.71,csapp,,0,0,0,,that's the reason you might want to do
Dialogue: 0,0:38:37.71,0:38:42.95,csapp,,0,0,0,,that the the other option is just to
Dialogue: 0,0:38:42.95,0:38:46.52,csapp,,0,0,0,,don't allocate a an entry in the cache
Dialogue: 0,0:38:46.52,0:38:48.27,csapp,,0,0,0,,don't allocate a new line just write
Dialogue: 0,0:38:48.27,0:38:52.55,csapp,,0,0,0,,write the data directly to memory you
Dialogue: 0,0:38:52.55,0:38:54.15,csapp,,0,0,0,,don't really need to understand the
Dialogue: 0,0:38:54.15,0:38:56.00,csapp,,0,0,0,,distinction between these two things
Dialogue: 0,0:38:56.00,0:38:59.27,csapp,,0,0,0,,different caches use different policies
Dialogue: 0,0:38:59.27,0:39:03.24,csapp,,0,0,0,,for your own mental model a good model
Dialogue: 0,0:39:03.24,0:39:05.25,csapp,,0,0,0,,to use is just to assume write back
Dialogue: 0,0:39:05.25,0:39:08.06,csapp,,0,0,0,,write allocate so just assume that we
Dialogue: 0,0:39:08.06,0:39:10.38,csapp,,0,0,0,,won't we won't copy the data to disk if
Dialogue: 0,0:39:10.38,0:39:12.80,csapp,,0,0,0,,there's a hit we won't write it back to
Dialogue: 0,0:39:12.80,0:39:15.74,csapp,,0,0,0,,disk until the last possible minute and
Dialogue: 0,0:39:15.74,0:39:17.94,csapp,,0,0,0,,every time there's a write miss what
Dialogue: 0,0:39:17.94,0:39:19.55,csapp,,0,0,0,,will create a new entry in the cache
Dialogue: 0,0:39:19.55,0:39:22.20,csapp,,0,0,0,,okay so that's that I think that's sort
Dialogue: 0,0:39:22.20,0:39:24.83,csapp,,0,0,0,,of the simplest model that and it's a
Dialogue: 0,0:39:24.83,0:39:26.46,csapp,,0,0,0,,reason it's a reasonable model that you
Dialogue: 0,0:39:26.46,0:39:28.71,csapp,,0,0,0,,can use regardless of the particular
Dialogue: 0,0:39:28.71,0:39:32.98,csapp,,0,0,0,,cache implementation
Dialogue: 0,0:39:32.98,0:39:35.36,csapp,,0,0,0,,now in a real system so far we've only
Dialogue: 0,0:39:35.36,0:39:36.92,csapp,,0,0,0,,looked at we've only assumed that
Dialogue: 0,0:39:36.92,0:39:39.35,csapp,,0,0,0,,there's a single cache but in a in real
Dialogue: 0,0:39:39.35,0:39:45.76,csapp,,0,0,0,,systems there's multiple multiple caches
Dialogue: 0,0:39:45.76,0:39:52.27,csapp,,0,0,0,,so modern core i7 Haswell architecture
Dialogue: 0,0:39:52.27,0:39:57.95,csapp,,0,0,0,,from Intel contains multiple processor
Dialogue: 0,0:39:57.95,0:40:01.16,csapp,,0,0,0,,cores so 4 is a typical number for like
Dialogue: 0,0:40:01.16,0:40:04.88,csapp,,0,0,0,,desktop systems 8 8 to 12 is typical for
Dialogue: 0,0:40:04.88,0:40:07.46,csapp,,0,0,0,,server class systems these processor
Dialogue: 0,0:40:07.46,0:40:09.19,csapp,,0,0,0,,cores can each execute their own
Dialogue: 0,0:40:09.19,0:40:11.32,csapp,,0,0,0,,independent instruction stream in
Dialogue: 0,0:40:11.32,0:40:16.69,csapp,,0,0,0,,parallel and each processor core can
Dialogue: 0,0:40:16.69,0:40:19.55,csapp,,0,0,0,,contains general-purpose registers which
Dialogue: 0,0:40:19.55,0:40:23.39,csapp,,0,0,0,,that's level 0 in the cache and then two
Dialogue: 0,0:40:23.39,0:40:27.56,csapp,,0,0,0,,different kinds of l1 caches the data
Dialogue: 0,0:40:27.56,0:40:31.76,csapp,,0,0,0,,cache the l1d cache and the eye cache is
Dialogue: 0,0:40:31.76,0:40:34.54,csapp,,0,0,0,,the L which is the instruction cache and
Dialogue: 0,0:40:34.54,0:40:38.36,csapp,,0,0,0,,these are these are fairly small 32 K
Dialogue: 0,0:40:38.36,0:40:40.16,csapp,,0,0,0,,bytes they're eight-way associative and
Dialogue: 0,0:40:40.16,0:40:43.04,csapp,,0,0,0,,they can be accessed in a very small
Dialogue: 0,0:40:43.04,0:40:47.69,csapp,,0,0,0,,number of cycles the next level of the
Dialogue: 0,0:40:47.69,0:40:51.25,csapp,,0,0,0,,hierarchy is is the L is an l2 cache
Dialogue: 0,0:40:51.25,0:40:56.56,csapp,,0,0,0,,which is still fairly small 256 K bytes
Dialogue: 0,0:40:56.56,0:41:00.32,csapp,,0,0,0,,same associativity and it has a slightly
Dialogue: 0,0:41:00.32,0:41:04.49,csapp,,0,0,0,,longer access time and and it's unified
Dialogue: 0,0:41:04.49,0:41:07.22,csapp,,0,0,0,,in the sense that the l2 cache contains
Dialogue: 0,0:41:07.22,0:41:11.72,csapp,,0,0,0,,both data and instructions ok so that's
Dialogue: 0,0:41:11.72,0:41:15.01,csapp,,0,0,0,,all within a single core on the chip and
Dialogue: 0,0:41:15.01,0:41:18.47,csapp,,0,0,0,,then also on the chip but external to
Dialogue: 0,0:41:18.47,0:41:20.21,csapp,,0,0,0,,all the cores and shared by all the
Dialogue: 0,0:41:20.21,0:41:24.23,csapp,,0,0,0,,cores is at l3 unified cache which is 8
Dialogue: 0,0:41:24.23,0:41:28.34,csapp,,0,0,0,,megabytes and 16 Way associative with an
Dialogue: 0,0:41:28.34,0:41:32.92,csapp,,0,0,0,,access time that's like 40 to 75 cycles
Dialogue: 0,0:41:32.92,0:41:37.67,csapp,,0,0,0,,so if if there's a Miss in l1 then the
Dialogue: 0,0:41:37.67,0:41:40.28,csapp,,0,0,0,,l1 sense or tries to sends a request to
Dialogue: 0,0:41:40.28,0:41:42.83,csapp,,0,0,0,,l2 to try to try to find the data in l2
Dialogue: 0,0:41:42.83,0:41:45.44,csapp,,0,0,0,,since l2 is a little bigger maybe maybe
Dialogue: 0,0:41:45.44,0:41:46.30,csapp,,0,0,0,,the data hasn't been
Dialogue: 0,0:41:46.30,0:41:49.27,csapp,,0,0,0,,flushed out of l2 yet if l2 can't find
Dialogue: 0,0:41:49.27,0:41:52.27,csapp,,0,0,0,,it it sends a request to l3 to see if
Dialogue: 0,0:41:52.27,0:41:56.63,csapp,,0,0,0,,they can find the data in l3 if l3 can't
Dialogue: 0,0:41:56.63,0:41:58.30,csapp,,0,0,0,,find it then it gives up and it goes off
Dialogue: 0,0:41:58.30,0:42:03.16,csapp,,0,0,0,,chip to to memory yes question
Dialogue: 0,0:42:03.16,0:42:07.03,csapp,,0,0,0,,yes name memory is this that's it's the
Dialogue: 0,0:42:07.03,0:42:10.40,csapp,,0,0,0,,DRAM built of DRAM chips it's it's
Dialogue: 0,0:42:10.40,0:42:12.61,csapp,,0,0,0,,separate it's in a separate separate set
Dialogue: 0,0:42:12.61,0:42:15.70,csapp,,0,0,0,,of chips on the motherboard connected by
Dialogue: 0,0:42:15.70,0:42:20.05,csapp,,0,0,0,,those that IO bridge that we and the bus
Dialogue: 0,0:42:20.05,0:42:22.18,csapp,,0,0,0,,various buses then that we talked about
Dialogue: 0,0:42:22.18,0:42:31.13,csapp,,0,0,0,,last time and for all different for all
Dialogue: 0,0:42:31.13,0:42:32.59,csapp,,0,0,0,,of these different caches that block
Dialogue: 0,0:42:32.59,0:42:41.59,csapp,,0,0,0,,size is 64 bytes now there's a number of
Dialogue: 0,0:42:41.59,0:42:43.24,csapp,,0,0,0,,different ways to I think about the
Dialogue: 0,0:42:43.24,0:42:47.86,csapp,,0,0,0,,performance of caches my most most
Dialogue: 0,0:42:47.86,0:42:50.77,csapp,,0,0,0,,common way is using a metric called the
Dialogue: 0,0:42:50.77,0:42:53.44,csapp,,0,0,0,,Miss rate so what this is the fraction
Dialogue: 0,0:42:53.44,0:42:58.06,csapp,,0,0,0,,of references that Miss so we're very so
Dialogue: 0,0:42:58.06,0:42:59.98,csapp,,0,0,0,,I thought and it's it's 1 minus the hit
Dialogue: 0,0:42:59.98,0:43:04.45,csapp,,0,0,0,,rate so typical for caches to work that
Dialogue: 0,0:43:04.45,0:43:08.02,csapp,,0,0,0,,Miss rate has to be pretty low and and
Dialogue: 0,0:43:08.02,0:43:10.67,csapp,,0,0,0,,fortunately because of locality these
Dialogue: 0,0:43:10.67,0:43:15.43,csapp,,0,0,0,,miss rates are low another another
Dialogue: 0,0:43:15.43,0:43:18.73,csapp,,0,0,0,,metric is the hit time so if if we do
Dialogue: 0,0:43:18.73,0:43:20.15,csapp,,0,0,0,,have a hit in the cache how long does it
Dialogue: 0,0:43:20.15,0:43:23.29,csapp,,0,0,0,,actually take to sort of look up the you
Dialogue: 0,0:43:23.29,0:43:24.85,csapp,,0,0,0,,know do the lookup to determine that
Dialogue: 0,0:43:24.85,0:43:26.20,csapp,,0,0,0,,there was a hit and then return the
Dialogue: 0,0:43:26.20,0:43:32.08,csapp,,0,0,0,,value okay so for for l1 and in an Intel
Dialogue: 0,0:43:32.08,0:43:34.60,csapp,,0,0,0,,system this is four clock cycles ten
Dialogue: 0,0:43:34.60,0:43:38.26,csapp,,0,0,0,,clock cycles for l2 and then there's an
Dialogue: 0,0:43:38.26,0:43:40.81,csapp,,0,0,0,,additional cost if so you always have to
Dialogue: 0,0:43:40.81,0:43:42.46,csapp,,0,0,0,,pay the hit time right the hit time is
Dialogue: 0,0:43:42.46,0:43:45.92,csapp,,0,0,0,,the best you can do but if you have a
Dialogue: 0,0:43:45.92,0:43:49.98,csapp,,0,0,0,,Miss then it's you pay the hit time
Dialogue: 0,0:43:49.98,0:43:52.03,csapp,,0,0,0,,because you have to do the search and
Dialogue: 0,0:43:52.03,0:43:52.84,csapp,,0,0,0,,eventually you're going to have to
Dialogue: 0,0:43:52.84,0:43:54.67,csapp,,0,0,0,,return the word back to the requester
Dialogue: 0,0:43:54.67,0:43:56.95,csapp,,0,0,0,,but you then you have this additional
Dialogue: 0,0:43:56.95,0:43:58.64,csapp,,0,0,0,,cost which you have to go which is going
Dialogue: 0,0:43:58.64,0:43:59.69,csapp,,0,0,0,,to the the memory
Dialogue: 0,0:43:59.69,0:44:02.56,csapp,,0,0,0,,ready to fetch the data okay so that
Dialogue: 0,0:44:02.56,0:44:04.91,csapp,,0,0,0,,that Miss penalty that's what called
Dialogue: 0,0:44:04.91,0:44:08.56,csapp,,0,0,0,,miss penalty is on the order of hundreds
Dialogue: 0,0:44:08.56,0:44:11.72,csapp,,0,0,0,,of cycles for main memory but at other
Dialogue: 0,0:44:11.72,0:44:14.35,csapp,,0,0,0,,levels of the hierarchy it can be huge
Dialogue: 0,0:44:14.35,0:44:16.57,csapp,,0,0,0,,so the miss penalty if you if you have a
Dialogue: 0,0:44:16.57,0:44:17.85,csapp,,0,0,0,,cache in main memory
Dialogue: 0,0:44:17.85,0:44:20.48,csapp,,0,0,0,,that's caching blocks that are stored on
Dialogue: 0,0:44:20.48,0:44:28.67,csapp,,0,0,0,,disk the the Miss penalty is enormous so
Dialogue: 0,0:44:28.67,0:44:31.25,csapp,,0,0,0,,it's kind of interesting if you think
Dialogue: 0,0:44:31.25,0:44:35.08,csapp,,0,0,0,,about it that performance is the
Dialogue: 0,0:44:35.08,0:44:36.31,csapp,,0,0,0,,performance of these systems is very
Dialogue: 0,0:44:36.31,0:44:38.39,csapp,,0,0,0,,sensitive to the miss rate much more
Dialogue: 0,0:44:38.39,0:44:41.75,csapp,,0,0,0,,sensitive than you would think and in
Dialogue: 0,0:44:41.75,0:44:47.66,csapp,,0,0,0,,fact 99% hit rate is twice as good as a
Dialogue: 0,0:44:47.66,0:45:06.05,csapp,,0,0,0,,97 percent hit rate yes
Dialogue: 0,0:45:06.05,0:45:09.64,csapp,,0,0,0,,yeah they hit so the question is does
Dialogue: 0,0:45:09.64,0:45:11.92,csapp,,0,0,0,,the hit time include the time tax to
Dialogue: 0,0:45:11.92,0:45:14.26,csapp,,0,0,0,,access the tag and yes so the hit time
Dialogue: 0,0:45:14.26,0:45:17.14,csapp,,0,0,0,,is the time it takes to just to search
Dialogue: 0,0:45:17.14,0:45:20.85,csapp,,0,0,0,,to determine if that item is is is in
Dialogue: 0,0:45:20.85,0:45:38.39,csapp,,0,0,0,,the cache and then return it
Dialogue: 0,0:45:38.39,0:45:43.65,csapp,,0,0,0,,yeah so the yeah so the the miss the
Dialogue: 0,0:45:43.65,0:45:45.36,csapp,,0,0,0,,Miss penalty is the time it takes for
Dialogue: 0,0:45:45.36,0:45:48.06,csapp,,0,0,0,,the cash to fetch the data from memory
Dialogue: 0,0:45:48.06,0:45:50.64,csapp,,0,0,0,,so that's all the latency you know going
Dialogue: 0,0:45:50.64,0:45:53.07,csapp,,0,0,0,,across the buses the time it takes the
Dialogue: 0,0:45:53.07,0:45:55.83,csapp,,0,0,0,,memory to respond to the requests the
Dialogue: 0,0:45:55.83,0:45:57.99,csapp,,0,0,0,,time it takes the data to flow back over
Dialogue: 0,0:45:57.99,0:46:01.44,csapp,,0,0,0,,the buses back to the the cache so the
Dialogue: 0,0:46:01.44,0:46:03.09,csapp,,0,0,0,,time for a Miss is going to be the hit
Dialogue: 0,0:46:03.09,0:46:08.87,csapp,,0,0,0,,time plus the Miss penalty that clear
Dialogue: 0,0:46:08.87,0:46:12.90,csapp,,0,0,0,,so I mean imagine suppose there's a hit
Dialogue: 0,0:46:12.90,0:46:14.91,csapp,,0,0,0,,time of one cycle and a Miss penalty of
Dialogue: 0,0:46:14.91,0:46:16.44,csapp,,0,0,0,,100 cycles that those are reasonable
Dialogue: 0,0:46:16.44,0:46:20.28,csapp,,0,0,0,,numbers so the the average acts I asked
Dialogue: 0,0:46:20.28,0:46:23.36,csapp,,0,0,0,,access time if you have 97 percent hits
Dialogue: 0,0:46:23.36,0:46:27.87,csapp,,0,0,0,,it's the hit time plus the percentage of
Dialogue: 0,0:46:27.87,0:46:30.33,csapp,,0,0,0,,misses times the Miss penalty so that's
Dialogue: 0,0:46:30.33,0:46:32.42,csapp,,0,0,0,,four cycles for the average access time
Dialogue: 0,0:46:32.42,0:46:35.34,csapp,,0,0,0,,but if we just increase the the hit rate
Dialogue: 0,0:46:35.34,0:46:39.66,csapp,,0,0,0,,by two percent the average access time
Dialogue: 0,0:46:39.66,0:46:46.32,csapp,,0,0,0,,drops by fifty percent a factor of two
Dialogue: 0,0:46:46.32,0:46:49.75,csapp,,0,0,0,,all right so why why is this stuff
Dialogue: 0,0:46:49.75,0:46:51.28,csapp,,0,0,0,,important why why should you care about
Dialogue: 0,0:46:51.28,0:46:55.03,csapp,,0,0,0,,it so cash is that we as we've seen are
Dialogue: 0,0:46:55.03,0:46:56.66,csapp,,0,0,0,,these these they're automatic they're
Dialogue: 0,0:46:56.66,0:46:59.39,csapp,,0,0,0,,all built in hardware there's no part of
Dialogue: 0,0:46:59.39,0:47:03.79,csapp,,0,0,0,,the sort of the visible instruction set
Dialogue: 0,0:47:03.79,0:47:06.97,csapp,,0,0,0,,that lets you manipulate caches and your
Dialogue: 0,0:47:06.97,0:47:11.86,csapp,,0,0,0,,assembly machine codons programs so that
Dialogue: 0,0:47:11.86,0:47:13.83,csapp,,0,0,0,,it all happens behind the scenes
Dialogue: 0,0:47:13.83,0:47:18.95,csapp,,0,0,0,,automatically in hardware but if you
Dialogue: 0,0:47:18.95,0:47:20.39,csapp,,0,0,0,,know how kit if you know about the
Dialogue: 0,0:47:20.39,0:47:21.89,csapp,,0,0,0,,existence of caches and you have this
Dialogue: 0,0:47:21.89,0:47:23.53,csapp,,0,0,0,,general idea of how you can work how
Dialogue: 0,0:47:23.53,0:47:26.11,csapp,,0,0,0,,they work then you can write code that's
Dialogue: 0,0:47:26.11,0:47:30.25,csapp,,0,0,0,,cache friendly in the sense that your
Dialogue: 0,0:47:30.25,0:47:33.25,csapp,,0,0,0,,code will will have a higher higher miss
Dialogue: 0,0:47:33.25,0:47:36.04,csapp,,0,0,0,,rate than code that that isn't cache
Dialogue: 0,0:47:36.04,0:47:40.91,csapp,,0,0,0,,friendly so the idea is to you want to
Dialogue: 0,0:47:40.91,0:47:44.63,csapp,,0,0,0,,focus on making the common case go fast
Dialogue: 0,0:47:44.63,0:47:47.02,csapp,,0,0,0,,don't spend your time on code that sort
Dialogue: 0,0:47:47.02,0:47:48.49,csapp,,0,0,0,,of code that doesn't get execute very
Dialogue: 0,0:47:48.49,0:47:51.49,csapp,,0,0,0,,much so look at look at the most
Dialogue: 0,0:47:51.49,0:47:54.52,csapp,,0,0,0,,commonly called functions and then
Dialogue: 0,0:47:54.52,0:47:56.08,csapp,,0,0,0,,within those functions look at the inner
Dialogue: 0,0:47:56.08,0:47:57.38,csapp,,0,0,0,,loops of those functions because it's
Dialogue: 0,0:47:57.38,0:47:58.99,csapp,,0,0,0,,the inner loops that are executing the
Dialogue: 0,0:47:58.99,0:48:01.43,csapp,,0,0,0,,most right so you can as a first
Dialogue: 0,0:48:01.43,0:48:04.16,csapp,,0,0,0,,approximation you can just ignore sort
Dialogue: 0,0:48:04.16,0:48:05.83,csapp,,0,0,0,,of stuff if you have nested loops you
Dialogue: 0,0:48:05.83,0:48:08.18,csapp,,0,0,0,,can ignore stuff that's going on in the
Dialogue: 0,0:48:08.18,0:48:10.21,csapp,,0,0,0,,outer loops and just focus on the code
Dialogue: 0,0:48:10.21,0:48:13.03,csapp,,0,0,0,,in the inner loop now what you want to
Dialogue: 0,0:48:13.03,0:48:14.74,csapp,,0,0,0,,do is try to minimize the misses in the
Dialogue: 0,0:48:14.74,0:48:18.79,csapp,,0,0,0,,inner loop okay so repeated references
Dialogue: 0,0:48:18.79,0:48:21.91,csapp,,0,0,0,,to a variable is variables are good
Dialogue: 0,0:48:21.91,0:48:24.14,csapp,,0,0,0,,especially if those are local variables
Dialogue: 0,0:48:24.14,0:48:26.26,csapp,,0,0,0,,right so remember if you declare a local
Dialogue: 0,0:48:26.26,0:48:29.63,csapp,,0,0,0,,variable and see the compiler can put
Dialogue: 0,0:48:29.63,0:48:32.56,csapp,,0,0,0,,that in a register right if you're
Dialogue: 0,0:48:32.56,0:48:35.15,csapp,,0,0,0,,referencing global variables maybe not
Dialogue: 0,0:48:35.15,0:48:36.79,csapp,,0,0,0,,the compiler doesn't know what's going
Dialogue: 0,0:48:36.79,0:48:39.89,csapp,,0,0,0,,on so it can't put that ref it can't put
Dialogue: 0,0:48:39.89,0:48:42.73,csapp,,0,0,0,,the reference to that variable to see in
Dialogue: 0,0:48:42.73,0:48:46.40,csapp,,0,0,0,,a register okay so repeated references
Dialogue: 0,0:48:46.40,0:48:48.68,csapp,,0,0,0,,to local variables stored on the stack
Dialogue: 0,0:48:48.68,0:48:51.44,csapp,,0,0,0,,are good because those will get turned
Dialogue: 0,0:48:51.44,0:48:53.71,csapp,,0,0,0,,into register accesses you'll never go
Dialogue: 0,0:48:53.71,0:48:57.31,csapp,,0,0,0,,to memory okay also stride one accesses
Dialogue: 0,0:48:57.31,0:48:59.39,csapp,,0,0,0,,two arrays are good
Dialogue: 0,0:48:59.39,0:49:01.16,csapp,,0,0,0,,and they're good because of the
Dialogue: 0,0:49:01.16,0:49:03.92,csapp,,0,0,0,,existence of these blocks right so the
Dialogue: 0,0:49:03.92,0:49:05.60,csapp,,0,0,0,,only way you'd know that stride one
Dialogue: 0,0:49:05.60,0:49:07.34,csapp,,0,0,0,,references our good is if you knew that
Dialogue: 0,0:49:07.34,0:49:12.05,csapp,,0,0,0,,caches have the 64-byte blocks okay so
Dialogue: 0,0:49:12.05,0:49:15.11,csapp,,0,0,0,,the and stride one one reference will
Dialogue: 0,0:49:15.11,0:49:17.72,csapp,,0,0,0,,have half the Miss rate as a stride to
Dialogue: 0,0:49:17.72,0:49:21.68,csapp,,0,0,0,,reference because if you're doing stride
Dialogue: 0,0:49:21.68,0:49:24.95,csapp,,0,0,0,,one references the first reference to a
Dialogue: 0,0:49:24.95,0:49:28.07,csapp,,0,0,0,,word and a block will miss but then
Dialogue: 0,0:49:28.07,0:49:32.06,csapp,,0,0,0,,subsequent references will hit right and
Dialogue: 0,0:49:32.06,0:49:33.68,csapp,,0,0,0,,you'll hit if you're doing a stride one
Dialogue: 0,0:49:33.68,0:49:35.35,csapp,,0,0,0,,reference you're going to hit every
Dialogue: 0,0:49:35.35,0:49:38.54,csapp,,0,0,0,,every word in that block if your drive
Dialogue: 0,0:49:38.54,0:49:40.13,csapp,,0,0,0,,if you're doing stride two references
Dialogue: 0,0:49:40.13,0:49:41.30,csapp,,0,0,0,,you're only going to hit every other
Dialogue: 0,0:49:41.30,0:49:44.09,csapp,,0,0,0,,word right so you'll only get you'll get
Dialogue: 0,0:49:44.09,0:49:46.07,csapp,,0,0,0,,sort of half the so you'll missed at
Dialogue: 0,0:49:46.07,0:49:53.95,csapp,,0,0,0,,twice the rate so
Dialogue: 0,0:49:53.95,0:49:55.86,csapp,,0,0,0,,so basically the point I want to make to
Dialogue: 0,0:49:55.86,0:49:59.17,csapp,,0,0,0,,you is that our understanding of caches
Dialogue: 0,0:49:59.17,0:50:03.13,csapp,,0,0,0,,allow us to sort of quantify this this
Dialogue: 0,0:50:03.13,0:50:05.10,csapp,,0,0,0,,qualitative notion of locality that we
Dialogue: 0,0:50:05.10,0:50:06.67,csapp,,0,0,0,,developed the last time right the last
Dialogue: 0,0:50:06.67,0:50:08.89,csapp,,0,0,0,,time we looked at we said if it's doing
Dialogue: 0,0:50:08.89,0:50:10.78,csapp,,0,0,0,,stride one references that's good if
Dialogue: 0,0:50:10.78,0:50:14.38,csapp,,0,0,0,,it's if we're doing if we're accessing
Dialogue: 0,0:50:14.38,0:50:16.45,csapp,,0,0,0,,the same variable over and over that's
Dialogue: 0,0:50:16.45,0:50:19.80,csapp,,0,0,0,,good but if we understand caches now we
Dialogue: 0,0:50:19.80,0:50:25.53,csapp,,0,0,0,,can quantify it in terms of miss rate
Dialogue: 0,0:50:25.53,0:50:28.35,csapp,,0,0,0,,all right so let's finish up the rest of
Dialogue: 0,0:50:28.35,0:50:29.61,csapp,,0,0,0,,the class we're going to look at the
Dialogue: 0,0:50:29.61,0:50:31.96,csapp,,0,0,0,,performance impact of caches on your
Dialogue: 0,0:50:31.96,0:50:35.04,csapp,,0,0,0,,code okay and why why you need to why
Dialogue: 0,0:50:35.04,0:50:36.43,csapp,,0,0,0,,you need to know about these things and
Dialogue: 0,0:50:36.43,0:50:41.65,csapp,,0,0,0,,that the impact that they can have so
Dialogue: 0,0:50:41.65,0:50:45.33,csapp,,0,0,0,,there's a very interesting function this
Dialogue: 0,0:50:45.33,0:50:46.78,csapp,,0,0,0,,actually plotted on the cover of your
Dialogue: 0,0:50:46.78,0:50:50.02,csapp,,0,0,0,,your text book that we call the memory
Dialogue: 0,0:50:50.02,0:50:52.45,csapp,,0,0,0,,Mountain I learned about this from a
Dialogue: 0,0:50:52.45,0:50:55.00,csapp,,0,0,0,,graduate student here at Carnegie Mellon
Dialogue: 0,0:50:55.00,0:50:56.53,csapp,,0,0,0,,back in the 90s who developed this
Dialogue: 0,0:50:56.53,0:50:58.99,csapp,,0,0,0,,notion made Tom Stricker
Dialogue: 0,0:50:58.99,0:51:01.99,csapp,,0,0,0,,and what it is it's a the memory
Dialogue: 0,0:51:01.99,0:51:05.71,csapp,,0,0,0,,Mountain plots a measure called read
Dialogue: 0,0:51:05.71,0:51:08.44,csapp,,0,0,0,,through put or read bandwidth which is
Dialogue: 0,0:51:08.44,0:51:10.72,csapp,,0,0,0,,the number of bytes read from memory so
Dialogue: 0,0:51:10.72,0:51:13.68,csapp,,0,0,0,,if you have four if you have a loop and
Dialogue: 0,0:51:13.68,0:51:16.51,csapp,,0,0,0,,you're scanning over a vector so you
Dialogue: 0,0:51:16.51,0:51:19.21,csapp,,0,0,0,,have a vector of say say double words
Dialogue: 0,0:51:19.21,0:51:22.59,csapp,,0,0,0,,and you're reading those elements from a
Dialogue: 0,0:51:22.59,0:51:24.97,csapp,,0,0,0,,vector one after the other the read
Dialogue: 0,0:51:24.97,0:51:26.58,csapp,,0,0,0,,throughput is the number of megabytes
Dialogue: 0,0:51:26.58,0:51:28.86,csapp,,0,0,0,,per second that you can that you can
Dialogue: 0,0:51:28.86,0:51:31.96,csapp,,0,0,0,,perform that task at and the memory
Dialogue: 0,0:51:31.96,0:51:35.17,csapp,,0,0,0,,Mountain plots read throughput as a
Dialogue: 0,0:51:35.17,0:51:37.35,csapp,,0,0,0,,function of the temporal and spatial
Dialogue: 0,0:51:37.35,0:51:41.95,csapp,,0,0,0,,locality in that loop okay so in a sense
Dialogue: 0,0:51:41.95,0:51:45.01,csapp,,0,0,0,,it's looking at a wide range of locality
Dialogue: 0,0:51:45.01,0:51:48.46,csapp,,0,0,0,,options or characteristics in a program
Dialogue: 0,0:51:48.46,0:51:50.55,csapp,,0,0,0,,and it's plotting the performance of
Dialogue: 0,0:51:50.55,0:51:53.89,csapp,,0,0,0,,that memory system on that across that
Dialogue: 0,0:51:53.89,0:51:56.14,csapp,,0,0,0,,range as a two-dimensional function so
Dialogue: 0,0:51:56.14,0:51:58.23,csapp,,0,0,0,,in some ways the memory Mountain is a
Dialogue: 0,0:51:58.23,0:52:00.81,csapp,,0,0,0,,kind of a fingerprint right every system
Dialogue: 0,0:52:00.81,0:52:03.46,csapp,,0,0,0,,has its own unique memory Mountain that
Dialogue: 0,0:52:03.46,0:52:05.34,csapp,,0,0,0,,we can measure right by writing a simple
Dialogue: 0,0:52:05.34,0:52:07.04,csapp,,0,0,0,,program
Dialogue: 0,0:52:07.04,0:52:12.44,csapp,,0,0,0,,and so the idea here is that to
Dialogue: 0,0:52:12.44,0:52:15.62,csapp,,0,0,0,,construct the memory Mountain we write a
Dialogue: 0,0:52:15.62,0:52:35.20,csapp,,0,0,0,,program called test
Dialogue: 0,0:52:35.20,0:52:51.20,csapp,,0,0,0,,oh shoot
Dialogue: 0,0:52:51.20,0:53:03.36,csapp,,0,0,0,,for some reason it's not okay all right
Dialogue: 0,0:53:03.36,0:53:05.78,csapp,,0,0,0,,so when we when we when we build a
Dialogue: 0,0:53:05.78,0:53:08.41,csapp,,0,0,0,,memory Mountain we're given a vector
Dialogue: 0,0:53:08.41,0:53:12.20,csapp,,0,0,0,,that consists of a collection of double
Dialogue: 0,0:53:12.20,0:53:20.32,csapp,,0,0,0,,words and then we write a loop that
Dialogue: 0,0:53:20.32,0:53:22.79,csapp,,0,0,0,,reads those words that read some number
Dialogue: 0,0:53:22.79,0:53:40.10,csapp,,0,0,0,,of words in this case
Dialogue: 0,0:53:40.10,0:53:42.50,csapp,,0,0,0,,hmm
Dialogue: 0,0:53:42.50,0:53:47.98,csapp,,0,0,0,,there we go so it reads it reads Elam's
Dialogue: 0,0:53:47.98,0:53:50.51,csapp,,0,0,0,,number of elements right so we've got
Dialogue: 0,0:53:50.51,0:53:52.61,csapp,,0,0,0,,each of these double word elements with
Dialogue: 0,0:53:52.61,0:53:57.08,csapp,,0,0,0,,a stride of of stride okay so if we have
Dialogue: 0,0:53:57.08,0:54:03.14,csapp,,0,0,0,,a stride of one I know that was kind of
Dialogue: 0,0:54:03.14,0:54:05.42,csapp,,0,0,0,,redundant huh so if we have a stride of
Dialogue: 0,0:54:05.42,0:54:11.39,csapp,,0,0,0,,one then we'll we'll have our loop wills
Dialogue: 0,0:54:11.39,0:54:13.97,csapp,,0,0,0,,was sort of looped through and read
Dialogue: 0,0:54:13.97,0:54:16.34,csapp,,0,0,0,,these elements until we've read Elam's
Dialogue: 0,0:54:16.34,0:54:19.04,csapp,,0,0,0,,number of those elements okay and then
Dialogue: 0,0:54:19.04,0:54:22.52,csapp,,0,0,0,,we'll do it again and then that warms up
Dialogue: 0,0:54:22.52,0:54:26.21,csapp,,0,0,0,,the cache then we do it again and do
Dialogue: 0,0:54:26.21,0:54:29.06,csapp,,0,0,0,,exactly the same thing so if we're doing
Dialogue: 0,0:54:29.06,0:54:32.09,csapp,,0,0,0,,this with a stride of two then we would
Dialogue: 0,0:54:32.09,0:54:35.86,csapp,,0,0,0,,be reading we would read this word zero
Dialogue: 0,0:54:35.86,0:54:46.52,csapp,,0,0,0,,or LM - LM 4 and so on okay so well then
Dialogue: 0,0:54:46.52,0:54:48.65,csapp,,0,0,0,,what all we're doing we're just for wide
Dialogue: 0,0:54:48.65,0:54:51.74,csapp,,0,0,0,,range of strides and a wide range of
Dialogue: 0,0:54:51.74,0:54:55.79,csapp,,0,0,0,,sizes we're scanning over this vector
Dialogue: 0,0:54:55.79,0:54:58.91,csapp,,0,0,0,,and just recording how long it takes to
Dialogue: 0,0:54:58.91,0:55:01.25,csapp,,0,0,0,,to do that read and then convert we
Dialogue: 0,0:55:01.25,0:55:04.03,csapp,,0,0,0,,convert that into megabytes per second
Dialogue: 0,0:55:04.03,0:55:08.24,csapp,,0,0,0,,and in order to I just wanted to show
Dialogue: 0,0:55:08.24,0:55:09.83,csapp,,0,0,0,,you this this is we don't need we're not
Dialogue: 0,0:55:09.83,0:55:13.09,csapp,,0,0,0,,going to go into detail about this but
Dialogue: 0,0:55:13.09,0:55:16.76,csapp,,0,0,0,,this is actually how I generated the the
Dialogue: 0,0:55:16.76,0:55:19.13,csapp,,0,0,0,,cover on the book and in order to in
Dialogue: 0,0:55:19.13,0:55:21.65,csapp,,0,0,0,,order to use to exploit the parallelism
Dialogue: 0,0:55:21.65,0:55:24.23,csapp,,0,0,0,,inside the intel processor like you
Dialogue: 0,0:55:24.23,0:55:25.94,csapp,,0,0,0,,learned about last week there's there's
Dialogue: 0,0:55:25.94,0:55:28.16,csapp,,0,0,0,,a lot of parallel functional units in
Dialogue: 0,0:55:28.16,0:55:33.05,csapp,,0,0,0,,order to exploit those i i did 4x4 loop
Dialogue: 0,0:55:33.05,0:55:35.42,csapp,,0,0,0,,unrolling so I'm actually doing sort of
Dialogue: 0,0:55:35.42,0:55:39.29,csapp,,0,0,0,,four scans in parallel but the general
Dialogue: 0,0:55:39.29,0:55:40.91,csapp,,0,0,0,,idea is just what I've showed you here
Dialogue: 0,0:55:40.91,0:55:45.17,csapp,,0,0,0,,and this this 4x4 this 4x4 loop
Dialogue: 0,0:55:45.17,0:55:48.17,csapp,,0,0,0,,unrolling is just an optimization but I
Dialogue: 0,0:55:48.17,0:55:49.37,csapp,,0,0,0,,wanted to show it to you because it
Dialogue: 0,0:55:49.37,0:55:51.74,csapp,,0,0,0,,actually it's the exact same principles
Dialogue: 0,0:55:51.74,0:55:53.83,csapp,,0,0,0,,you learned about last week when
Dialogue: 0,0:55:53.83,0:55:55.94,csapp,,0,0,0,,Professor Brian talked about
Dialogue: 0,0:55:55.94,0:56:00.34,csapp,,0,0,0,,code optimization so what we do is we we
Dialogue: 0,0:56:00.34,0:56:01.81,csapp,,0,0,0,,call this test function with these
Dialogue: 0,0:56:01.81,0:56:05.48,csapp,,0,0,0,,various ranges of Elam's and stride and
Dialogue: 0,0:56:05.48,0:56:07.78,csapp,,0,0,0,,then we measure the performance and we
Dialogue: 0,0:56:07.78,0:56:10.46,csapp,,0,0,0,,get this beautiful picture this
Dialogue: 0,0:56:10.46,0:56:12.34,csapp,,0,0,0,,beautiful function to me it's beautiful
Dialogue: 0,0:56:12.34,0:56:14.05,csapp,,0,0,0,,I don't know does it look beautiful to
Dialogue: 0,0:56:14.05,0:56:27.58,csapp,,0,0,0,,you so on the Z our z axis is plotting
Dialogue: 0,0:56:27.58,0:56:29.78,csapp,,0,0,0,,read throughput in megabytes per second
Dialogue: 0,0:56:29.78,0:56:35.00,csapp,,0,0,0,,ranging from 2000 megabytes per second
Dialogue: 0,0:56:35.00,0:56:42.85,csapp,,0,0,0,,up to 16,000 megabytes per second this
Dialogue: 0,0:56:42.85,0:56:49.28,csapp,,0,0,0,,this axis is measuring is stride so
Dialogue: 0,0:56:49.28,0:56:54.57,csapp,,0,0,0,,going from stride 1 up to stride 12 and
Dialogue: 0,0:56:54.57,0:56:59.80,csapp,,0,0,0,,this axis is so as we as we increase
Dialogue: 0,0:56:59.80,0:57:03.10,csapp,,0,0,0,,stride we're decreasing the spatial
Dialogue: 0,0:57:03.10,0:57:09.14,csapp,,0,0,0,,locality alright
Dialogue: 0,0:57:09.14,0:57:12.92,csapp,,0,0,0,,and this axis is the size axis so we're
Dialogue: 0,0:57:12.92,0:57:17.32,csapp,,0,0,0,,going from I think 16 K up to 128
Dialogue: 0,0:57:17.32,0:57:19.67,csapp,,0,0,0,,megabytes so this is the number of
Dialogue: 0,0:57:19.67,0:57:21.17,csapp,,0,0,0,,elements we're going to read each pass
Dialogue: 0,0:57:21.17,0:57:29.47,csapp,,0,0,0,,through so as we as we increase the size
Dialogue: 0,0:57:29.47,0:57:32.63,csapp,,0,0,0,,we're sort of decreasing the impact of
Dialogue: 0,0:57:32.63,0:57:37.13,csapp,,0,0,0,,temporal locality because word as we
Dialogue: 0,0:57:37.13,0:57:38.90,csapp,,0,0,0,,increase the size there's fewer and
Dialogue: 0,0:57:38.90,0:57:40.97,csapp,,0,0,0,,fewer caches in our hierarchy can hold
Dialogue: 0,0:57:40.97,0:57:46.69,csapp,,0,0,0,,all that data and so this so we've got
Dialogue: 0,0:57:46.69,0:57:49.22,csapp,,0,0,0,,spatial locality decreasing in this
Dialogue: 0,0:57:49.22,0:57:51.33,csapp,,0,0,0,,direction and temporal locality
Dialogue: 0,0:57:51.33,0:57:55.01,csapp,,0,0,0,,decreasing in this direction so as a
Dialogue: 0,0:57:55.01,0:57:57.76,csapp,,0,0,0,,programmer what you want to do you want
Dialogue: 0,0:57:57.76,0:58:00.61,csapp,,0,0,0,,to be up here right good spatial
Dialogue: 0,0:58:00.61,0:58:03.17,csapp,,0,0,0,,locality good temporal locality because
Dialogue: 0,0:58:03.17,0:58:06.31,csapp,,0,0,0,,you can get like 14 gigabytes per second
Dialogue: 0,0:58:06.31,0:58:09.71,csapp,,0,0,0,,measure agreed throughput you don't want
Dialogue: 0,0:58:09.71,0:58:12.92,csapp,,0,0,0,,to be down here which is only about 100
Dialogue: 0,0:58:12.92,0:58:14.42,csapp,,0,0,0,,megabytes per second where you're
Dialogue: 0,0:58:14.42,0:58:16.51,csapp,,0,0,0,,reading out of memory right so the
Dialogue: 0,0:58:16.51,0:58:18.58,csapp,,0,0,0,,difference between reading all of your
Dialogue: 0,0:58:18.58,0:58:23.29,csapp,,0,0,0,,data from memory and reor reading it
Dialogue: 0,0:58:23.29,0:58:26.80,csapp,,0,0,0,,from some part of the the caches is huge
Dialogue: 0,0:58:26.80,0:58:28.80,csapp,,0,0,0,,it's enormous
Dialogue: 0,0:58:28.80,0:58:31.64,csapp,,0,0,0,,ok so because you're 213 students you'll
Dialogue: 0,0:58:31.64,0:58:34.03,csapp,,0,0,0,,be up here and all the students that
Dialogue: 0,0:58:34.03,0:58:38.26,csapp,,0,0,0,,didn't take 213 they'll be down here and
Dialogue: 0,0:58:38.26,0:58:40.40,csapp,,0,0,0,,I've actually had I've actually had
Dialogue: 0,0:58:40.40,0:58:43.64,csapp,,0,0,0,,people several people write back to tell
Dialogue: 0,0:58:43.64,0:58:45.33,csapp,,0,0,0,,me about their experiences you know in
Dialogue: 0,0:58:45.33,0:58:48.20,csapp,,0,0,0,,internships and jobs after they left CMU
Dialogue: 0,0:58:48.20,0:58:50.29,csapp,,0,0,0,,where they were given some code that
Dialogue: 0,0:58:50.29,0:58:53.75,csapp,,0,0,0,,that was down here and they recognized
Dialogue: 0,0:58:53.75,0:58:55.73,csapp,,0,0,0,,the locality issues and they got it
Dialogue: 0,0:58:55.73,0:58:57.95,csapp,,0,0,0,,you know better up here or close at
Dialogue: 0,0:58:57.95,0:59:00.71,csapp,,0,0,0,,least better
Dialogue: 0,0:59:00.71,0:59:04.40,csapp,,0,0,0,,so this is this this picture this
Dialogue: 0,0:59:04.40,0:59:06.05,csapp,,0,0,0,,so-called memory mountain has all kinds
Dialogue: 0,0:59:06.05,0:59:08.56,csapp,,0,0,0,,of interesting features first of all
Dialogue: 0,0:59:08.56,0:59:10.28,csapp,,0,0,0,,there's these what I call ridges of
Dialogue: 0,0:59:10.28,0:59:13.49,csapp,,0,0,0,,temporal locality where these ridges see
Dialogue: 0,0:59:13.49,0:59:14.86,csapp,,0,0,0,,these Ridge lines if you think of this
Dialogue: 0,0:59:14.86,0:59:16.30,csapp,,0,0,0,,is like a mountain you see this
Dialogue: 0,0:59:16.30,0:59:19.78,csapp,,0,0,0,,Ridgeline and you see this Ridgeline and
Dialogue: 0,0:59:19.78,0:59:22.22,csapp,,0,0,0,,here's another Ridgeline and then here's
Dialogue: 0,0:59:22.22,0:59:24.41,csapp,,0,0,0,,a here's another one these correspond to
Dialogue: 0,0:59:24.41,0:59:25.97,csapp,,0,0,0,,different levels in the hierarchy so
Dialogue: 0,0:59:25.97,0:59:27.85,csapp,,0,0,0,,this this top Ridgeline is where you're
Dialogue: 0,0:59:27.85,0:59:31.49,csapp,,0,0,0,,reading directly out of l1 and it should
Dialogue: 0,0:59:31.49,0:59:35.11,csapp,,0,0,0,,be perfectly flat and it's so fast that
Dialogue: 0,0:59:35.11,0:59:37.19,csapp,,0,0,0,,we're getting like measurement jitter
Dialogue: 0,0:59:37.19,0:59:40.49,csapp,,0,0,0,,performance jitter right but it's it's
Dialogue: 0,0:59:40.49,0:59:43.09,csapp,,0,0,0,,and this little drop-off here is a
Dialogue: 0,0:59:43.09,0:59:44.96,csapp,,0,0,0,,measurement artifact it it should it
Dialogue: 0,0:59:44.96,0:59:46.64,csapp,,0,0,0,,shouldn't be there it should be it
Dialogue: 0,0:59:46.64,0:59:48.31,csapp,,0,0,0,,should be flat and go all the way to the
Dialogue: 0,0:59:48.31,0:59:55.64,csapp,,0,0,0,,wall back here and then here this this
Dialogue: 0,0:59:55.64,0:59:58.35,csapp,,0,0,0,,ridge line is where we're accessing l2
Dialogue: 0,0:59:58.35,1:00:02.69,csapp,,0,0,0,,this is where we're accessing l3 and and
Dialogue: 0,1:00:02.69,1:00:04.73,csapp,,0,0,0,,here's what we're accessing mostly from
Dialogue: 0,1:00:04.73,1:00:07.46,csapp,,0,0,0,,memory so you have these ridges of
Dialogue: 0,1:00:07.46,1:00:09.44,csapp,,0,0,0,,temporal locality and then you have
Dialogue: 0,1:00:09.44,1:00:11.56,csapp,,0,0,0,,these slopes of decreasing spatial
Dialogue: 0,1:00:11.56,1:00:14.92,csapp,,0,0,0,,locality so you see the slope here as
Dialogue: 0,1:00:14.92,1:00:18.17,csapp,,0,0,0,,work so as we're moving from the from
Dialogue: 0,1:00:18.17,1:00:21.84,csapp,,0,0,0,,the top of the slope down to the bottom
Dialogue: 0,1:00:21.84,1:00:24.82,csapp,,0,0,0,,we're decreasing our spatial locality so
Dialogue: 0,1:00:24.82,1:00:26.56,csapp,,0,0,0,,we're getting less benefit for these
Dialogue: 0,1:00:26.56,1:00:29.27,csapp,,0,0,0,,blocks that we're bringing in all right
Dialogue: 0,1:00:29.27,1:00:31.54,csapp,,0,0,0,,so you can see the we're getting less
Dialogue: 0,1:00:31.54,1:00:34.06,csapp,,0,0,0,,benefit out of the cost that we went
Dialogue: 0,1:00:34.06,1:00:36.23,csapp,,0,0,0,,through of importing of fetching these
Dialogue: 0,1:00:36.23,1:00:40.78,csapp,,0,0,0,,blocks and once the stride hits the
Dialogue: 0,1:00:40.78,1:00:44.51,csapp,,0,0,0,,block size now every reference is
Dialogue: 0,1:00:44.51,1:00:46.36,csapp,,0,0,0,,hitting a different block and so and
Dialogue: 0,1:00:46.36,1:00:47.90,csapp,,0,0,0,,then it flattens out then you get you're
Dialogue: 0,1:00:47.90,1:00:49.52,csapp,,0,0,0,,getting noes benefit from spatial
Dialogue: 0,1:00:49.52,1:00:55.33,csapp,,0,0,0,,locality and similarly here is where
Dialogue: 0,1:00:55.33,1:00:57.98,csapp,,0,0,0,,this this this slope is where we're
Dialogue: 0,1:00:57.98,1:01:02.27,csapp,,0,0,0,,reading from l3 and and and it flattens
Dialogue: 0,1:01:02.27,1:01:04.64,csapp,,0,0,0,,out always they always flatten out at
Dialogue: 0,1:01:04.64,1:01:08.24,csapp,,0,0,0,,the at the block size which is a stride
Dialogue: 0,1:01:08.24,1:01:09.77,csapp,,0,0,0,,these are double words right so it's
Dialogue: 0,1:01:09.77,1:01:13.32,csapp,,0,0,0,,stride of eight is
Dialogue: 0,1:01:13.32,1:01:15.45,csapp,,0,0,0,,64 bytes so once you exceed a stride of
Dialogue: 0,1:01:15.45,1:01:17.89,csapp,,0,0,0,,eight then you're no longer you're
Dialogue: 0,1:01:17.89,1:01:19.74,csapp,,0,0,0,,missing every time in it in a different
Dialogue: 0,1:01:19.74,1:01:24.78,csapp,,0,0,0,,block there's this this interesting this
Dialogue: 0,1:01:24.78,1:01:26.14,csapp,,0,0,0,,one puzzled me for a while
Dialogue: 0,1:01:26.14,1:01:29.84,csapp,,0,0,0,,you might be wondering like how come
Dialogue: 0,1:01:29.84,1:01:32.67,csapp,,0,0,0,,like over here is we increase the size
Dialogue: 0,1:01:32.67,1:01:37.38,csapp,,0,0,0,,we can sort of we're sort of getting the
Dialogue: 0,1:01:37.38,1:01:39.60,csapp,,0,0,0,,we're sort of as we increase the size
Dialogue: 0,1:01:39.60,1:01:42.03,csapp,,0,0,0,,we're doing most of our references out
Dialogue: 0,1:01:42.03,1:01:44.85,csapp,,0,0,0,,of caches that are lower in the cache
Dialogue: 0,1:01:44.85,1:01:49.15,csapp,,0,0,0,,hierarchy okay but except when we're
Dialogue: 0,1:01:49.15,1:01:53.34,csapp,,0,0,0,,doing stride one references you can see
Dialogue: 0,1:01:53.34,1:01:57.00,csapp,,0,0,0,,all the way up to right at the end right
Dialogue: 0,1:01:57.00,1:02:01.32,csapp,,0,0,0,,before it exceeds the size of l3 it's
Dialogue: 0,1:02:01.32,1:02:06.99,csapp,,0,0,0,,flat okay and it's it's running at the
Dialogue: 0,1:02:06.99,1:02:09.21,csapp,,0,0,0,,l2 rate alright so here's the l1 rate
Dialogue: 0,1:02:09.21,1:02:10.59,csapp,,0,0,0,,and then it drops off and then it's
Dialogue: 0,1:02:10.59,1:02:14.17,csapp,,0,0,0,,running at a constant l2 rate until the
Dialogue: 0,1:02:14.17,1:02:17.89,csapp,,0,0,0,,data no longer fits in l3 so I think
Dialogue: 0,1:02:17.89,1:02:19.71,csapp,,0,0,0,,what's going on here is that the the
Dialogue: 0,1:02:19.71,1:02:23.79,csapp,,0,0,0,,hardware the cache the the cache the l2
Dialogue: 0,1:02:23.79,1:02:27.78,csapp,,0,0,0,,cache hardware is recognizing or maybe
Dialogue: 0,1:02:27.78,1:02:30.43,csapp,,0,0,0,,it's an l1 but some some some logic in
Dialogue: 0,1:02:30.43,1:02:32.65,csapp,,0,0,0,,that in the cache system is recognizing
Dialogue: 0,1:02:32.65,1:02:35.61,csapp,,0,0,0,,the stride one reference pattern right
Dialogue: 0,1:02:35.61,1:02:38.04,csapp,,0,0,0,,because it sees all the addresses it's
Dialogue: 0,1:02:38.04,1:02:40.20,csapp,,0,0,0,,rough it's recognizing that stride one
Dialogue: 0,1:02:40.20,1:02:42.51,csapp,,0,0,0,,pattern and then it's aggressively
Dialogue: 0,1:02:42.51,1:02:47.22,csapp,,0,0,0,,prefetching from l3 into l2 so that
Dialogue: 0,1:02:47.22,1:02:49.98,csapp,,0,0,0,,those so it's fetching ahead of time
Dialogue: 0,1:02:49.98,1:02:51.72,csapp,,0,0,0,,it's anticipating it's saying look I've
Dialogue: 0,1:02:51.72,1:02:54.19,csapp,,0,0,0,,gotten five stride one references in a
Dialogue: 0,1:02:54.19,1:02:56.07,csapp,,0,0,0,,row I'm going to go grab a whole bunch
Dialogue: 0,1:02:56.07,1:02:58.29,csapp,,0,0,0,,of blocks and load them all up because
Dialogue: 0,1:02:58.29,1:03:01.22,csapp,,0,0,0,,by the principle of spatial locality
Dialogue: 0,1:03:01.22,1:03:04.32,csapp,,0,0,0,,those blocks those blocks are going to
Dialogue: 0,1:03:04.32,1:03:07.29,csapp,,0,0,0,,be referenced in the near future so this
Dialogue: 0,1:03:07.29,1:03:08.73,csapp,,0,0,0,,was really neat and this only happened
Dialogue: 0,1:03:08.73,1:03:10.15,csapp,,0,0,0,,within the last couple years so the
Dialogue: 0,1:03:10.15,1:03:12.36,csapp,,0,0,0,,Intel engineers are always hard at work
Dialogue: 0,1:03:12.36,1:03:17.65,csapp,,0,0,0,,and maybe by the time the time we do the
Dialogue: 0,1:03:17.65,1:03:20.07,csapp,,0,0,0,,next the next edition of the memory
Dialogue: 0,1:03:20.07,1:03:23.25,csapp,,0,0,0,,Mountain those systems will recognize
Dialogue: 0,1:03:23.25,1:03:26.30,csapp,,0,0,0,,stride 2 and you know other stride
Dialogue: 0,1:03:26.30,1:03:29.33,csapp,,0,0,0,,- but from this data it appears that
Dialogue: 0,1:03:29.33,1:03:36.74,csapp,,0,0,0,,it's only recognizing stride one ok so
Dialogue: 0,1:03:36.74,1:03:42.11,csapp,,0,0,0,,you can real you we can improve the
Dialogue: 0,1:03:42.11,1:03:43.79,csapp,,0,0,0,,spatial and temporal locality of our
Dialogue: 0,1:03:43.79,1:03:47.23,csapp,,0,0,0,,programs in several different ways that
Dialogue: 0,1:03:47.23,1:03:50.03,csapp,,0,0,0,,one way to improve the spatial locality
Dialogue: 0,1:03:50.03,1:03:53.03,csapp,,0,0,0,,is to rearrange loops and I'll use
Dialogue: 0,1:03:53.03,1:03:56.54,csapp,,0,0,0,,matrix multiplication as an example so
Dialogue: 0,1:03:56.54,1:04:00.02,csapp,,0,0,0,,here's a sort of a simple matrix
Dialogue: 0,1:04:00.02,1:04:03.89,csapp,,0,0,0,,multiplication in code where we're
Dialogue: 0,1:04:03.89,1:04:07.91,csapp,,0,0,0,,multiplying a times B and adding it
Dialogue: 0,1:04:07.91,1:04:12.26,csapp,,0,0,0,,we're taking what's in of the IJ element
Dialogue: 0,1:04:12.26,1:04:17.69,csapp,,0,0,0,,of C and then to that we're adding the
Dialogue: 0,1:04:17.69,1:04:21.17,csapp,,0,0,0,,sum the inner product of Rho I of a and
Dialogue: 0,1:04:21.17,1:04:26.45,csapp,,0,0,0,,the row J a column J of B okay and then
Dialogue: 0,1:04:26.45,1:04:28.73,csapp,,0,0,0,,so we're going through and for each IJ
Dialogue: 0,1:04:28.73,1:04:32.09,csapp,,0,0,0,,in this matrix C we're computing an
Dialogue: 0,1:04:32.09,1:04:37.30,csapp,,0,0,0,,inner product and then creating that sum
Dialogue: 0,1:04:37.30,1:04:40.79,csapp,,0,0,0,,so we can actually turns out there's a
Dialogue: 0,1:04:40.79,1:04:41.90,csapp,,0,0,0,,lot of different ways to do matrix
Dialogue: 0,1:04:41.90,1:04:44.96,csapp,,0,0,0,,multiply and this is we can permute
Dialogue: 0,1:04:44.96,1:04:48.83,csapp,,0,0,0,,these these loops in any of six
Dialogue: 0,1:04:48.83,1:04:51.74,csapp,,0,0,0,,different possible permutations so this
Dialogue: 0,1:04:51.74,1:04:54.71,csapp,,0,0,0,,is a permutation where it's I followed
Dialogue: 0,1:04:54.71,1:04:56.84,csapp,,0,0,0,,by J followed by K but five other
Dialogue: 0,1:04:56.84,1:05:02.48,csapp,,0,0,0,,possibilities are feasible and so we can
Dialogue: 0,1:05:02.48,1:05:04.58,csapp,,0,0,0,,actually analyze those those different
Dialogue: 0,1:05:04.58,1:05:07.10,csapp,,0,0,0,,permutations and predict which one will
Dialogue: 0,1:05:07.10,1:05:10.52,csapp,,0,0,0,,have the best performance okay so what
Dialogue: 0,1:05:10.52,1:05:11.90,csapp,,0,0,0,,we'll do is we'll look at the inner loop
Dialogue: 0,1:05:11.90,1:05:17.24,csapp,,0,0,0,,and we'll look at the access pattern of
Dialogue: 0,1:05:17.24,1:05:19.36,csapp,,0,0,0,,the inner loops and it's in the access
Dialogue: 0,1:05:19.36,1:05:24.81,csapp,,0,0,0,,pattern on arrays C a and B
Dialogue: 0,1:05:24.81,1:05:29.31,csapp,,0,0,0,,okay so let's look at the ijk
Dialogue: 0,1:05:29.31,1:05:31.80,csapp,,0,0,0,,implementation that I just showed you so
Dialogue: 0,1:05:31.80,1:05:34.97,csapp,,0,0,0,,as always we focus on the inner loop and
Dialogue: 0,1:05:34.97,1:05:39.33,csapp,,0,0,0,,if you notice this inner loop is doing a
Dialogue: 0,1:05:39.33,1:05:43.56,csapp,,0,0,0,,row wise access of column a and a column
Dialogue: 0,1:05:43.56,1:05:46.23,csapp,,0,0,0,,wise access I'm sorry a row wise access
Dialogue: 0,1:05:46.23,1:05:50.19,csapp,,0,0,0,,of array a and column wise access of a
Dialogue: 0,1:05:50.19,1:05:55.05,csapp,,0,0,0,,row B so row wise of a column wise of B
Dialogue: 0,1:05:55.05,1:05:56.88,csapp,,0,0,0,,we don't really care about C because
Dialogue: 0,1:05:56.88,1:05:58.50,csapp,,0,0,0,,it's out it's not in the inner loop
Dialogue: 0,1:05:58.50,1:06:04.71,csapp,,0,0,0,,okay so just ignore that so given our
Dialogue: 0,1:06:04.71,1:06:06.72,csapp,,0,0,0,,assumption that we can hold in this case
Dialogue: 0,1:06:06.72,1:06:10.41,csapp,,0,0,0,,we're assuming that we can hold for four
Dialogue: 0,1:06:10.41,1:06:13.26,csapp,,0,0,0,,of these integer elements in a in one
Dialogue: 0,1:06:13.26,1:06:17.16,csapp,,0,0,0,,block so the row wise access which has
Dialogue: 0,1:06:17.16,1:06:18.99,csapp,,0,0,0,,good spatial locality will miss one
Dialogue: 0,1:06:18.99,1:06:21.84,csapp,,0,0,0,,every four accesses okay the very first
Dialogue: 0,1:06:21.84,1:06:23.97,csapp,,0,0,0,,reference will miss and then the next
Dialogue: 0,1:06:23.97,1:06:26.07,csapp,,0,0,0,,three will hit and then the next
Dialogue: 0,1:06:26.07,1:06:27.33,csapp,,0,0,0,,reference after that will hit a new
Dialogue: 0,1:06:27.33,1:06:31.34,csapp,,0,0,0,,block okay so so one out of four
Dialogue: 0,1:06:31.34,1:06:34.38,csapp,,0,0,0,,references to a will miss but because
Dialogue: 0,1:06:34.38,1:06:36.75,csapp,,0,0,0,,the access pattern for B is column wise
Dialogue: 0,1:06:36.75,1:06:40.38,csapp,,0,0,0,,every every act every reference to B
Dialogue: 0,1:06:40.38,1:06:43.44,csapp,,0,0,0,,will miss okay so the average number of
Dialogue: 0,1:06:43.44,1:06:45.27,csapp,,0,0,0,,misses per loop iteration is one point
Dialogue: 0,1:06:45.27,1:06:49.47,csapp,,0,0,0,,two five okay the ji K version is
Dialogue: 0,1:06:49.47,1:06:56.58,csapp,,0,0,0,,exactly the same pattern ki J is a
Dialogue: 0,1:06:56.58,1:06:59.88,csapp,,0,0,0,,little different here we're doing row
Dialogue: 0,1:06:59.88,1:07:04.20,csapp,,0,0,0,,wise access of B and a row wise access
Dialogue: 0,1:07:04.20,1:07:06.45,csapp,,0,0,0,,of C so that's good right so now we've
Dialogue: 0,1:07:06.45,1:07:09.12,csapp,,0,0,0,,got stride one accesses on both B and C
Dialogue: 0,1:07:09.12,1:07:12.42,csapp,,0,0,0,,and the reference to a is outside of the
Dialogue: 0,1:07:12.42,1:07:16.38,csapp,,0,0,0,,loop so we don't care about it so so
Dialogue: 0,1:07:16.38,1:07:18.33,csapp,,0,0,0,,both B and C will miss one quarter of
Dialogue: 0,1:07:18.33,1:07:21.48,csapp,,0,0,0,,the time okay so the total average
Dialogue: 0,1:07:21.48,1:07:23.37,csapp,,0,0,0,,number of misses per loop iteration will
Dialogue: 0,1:07:23.37,1:07:27.78,csapp,,0,0,0,,be 0.5 that's pretty good and I KJ has
Dialogue: 0,1:07:27.78,1:07:31.80,csapp,,0,0,0,,the same similar behavior now J ki is
Dialogue: 0,1:07:31.80,1:07:36.00,csapp,,0,0,0,,sort of the exact opposite j ki does
Dialogue: 0,1:07:36.00,1:07:38.16,csapp,,0,0,0,,column wise access of a
Dialogue: 0,1:07:38.16,1:07:40.86,csapp,,0,0,0,,and column-wise access of seaso right we
Dialogue: 0,1:07:40.86,1:07:45.05,csapp,,0,0,0,,know that's a stinker right and and we
Dialogue: 0,1:07:45.05,1:07:47.04,csapp,,0,0,0,,qualitative well you know it's bad and
Dialogue: 0,1:07:47.04,1:07:50.34,csapp,,0,0,0,,we can compute that it will miss a one
Dialogue: 0,1:07:50.34,1:07:52.92,csapp,,0,0,0,,time per loop iteration so that will be
Dialogue: 0,1:07:52.92,1:07:54.81,csapp,,0,0,0,,two total of two misses per iteration
Dialogue: 0,1:07:54.81,1:07:59.04,csapp,,0,0,0,,and kji has the same bad pattern okay so
Dialogue: 0,1:07:59.04,1:08:02.49,csapp,,0,0,0,,if we look at all these permutations you
Dialogue: 0,1:08:02.49,1:08:07.14,csapp,,0,0,0,,can see that ijk and ji k miss 1.25 have
Dialogue: 0,1:08:07.14,1:08:12.78,csapp,,0,0,0,,1.25 mrs. K IJ has 0.5 misses and j ki
Dialogue: 0,1:08:12.78,1:08:16.43,csapp,,0,0,0,,has two misses so clearly it looks like
Dialogue: 0,1:08:16.43,1:08:20.40,csapp,,0,0,0,,ki J and its brethren are the best
Dialogue: 0,1:08:20.40,1:08:23.76,csapp,,0,0,0,,option the only difference is that k k
Dialogue: 0,1:08:23.76,1:08:25.83,csapp,,0,0,0,,IJ has this additional store so there
Dialogue: 0,1:08:25.83,1:08:27.21,csapp,,0,0,0,,might be a question that is that going
Dialogue: 0,1:08:27.21,1:08:28.98,csapp,,0,0,0,,to create is that going to slow things
Dialogue: 0,1:08:28.98,1:08:34.89,csapp,,0,0,0,,down well it turns out in systems in any
Dialogue: 0,1:08:34.89,1:08:37.95,csapp,,0,0,0,,kind storage systems rights are much
Dialogue: 0,1:08:37.95,1:08:41.49,csapp,,0,0,0,,easier to deal with them reads can you
Dialogue: 0,1:08:41.49,1:08:43.43,csapp,,0,0,0,,think about why that might be true
Dialogue: 0,1:08:43.43,1:08:45.33,csapp,,0,0,0,,so writes you have a lot more
Dialogue: 0,1:08:45.33,1:08:51.96,csapp,,0,0,0,,flexibility than you do with reads
Dialogue: 0,1:08:51.96,1:08:56.80,csapp,,0,0,0,,I mean yes
Dialogue: 0,1:08:56.80,1:08:59.56,csapp,,0,0,0,,that's exactly so you can you have
Dialogue: 0,1:08:59.56,1:09:01.03,csapp,,0,0,0,,options you can do you can write back
Dialogue: 0,1:09:01.03,1:09:04.46,csapp,,0,0,0,,defer you can defer writing until the
Dialogue: 0,1:09:04.46,1:09:06.28,csapp,,0,0,0,,value the value that you're written is
Dialogue: 0,1:09:06.28,1:09:08.53,csapp,,0,0,0,,actually used but when you read an item
Dialogue: 0,1:09:08.53,1:09:11.02,csapp,,0,0,0,,you're stuck you can't do anything until
Dialogue: 0,1:09:11.02,1:09:13.57,csapp,,0,0,0,,until you get that data so it turns out
Dialogue: 0,1:09:13.57,1:09:15.55,csapp,,0,0,0,,that that rights don't really that this
Dialogue: 0,1:09:15.55,1:09:17.21,csapp,,0,0,0,,additional store doesn't really hurt us
Dialogue: 0,1:09:17.21,1:09:21.50,csapp,,0,0,0,,and so when we measure these on a modern
Dialogue: 0,1:09:21.50,1:09:24.78,csapp,,0,0,0,,system you can see that that the Kate
Dialogue: 0,1:09:24.78,1:09:28.81,csapp,,0,0,0,,kij which has the the fewest number of
Dialogue: 0,1:09:28.81,1:09:31.69,csapp,,0,0,0,,misses has you see we're getting like
Dialogue: 0,1:09:31.69,1:09:34.63,csapp,,0,0,0,,one miss what we're plotting here is
Dialogue: 0,1:09:34.63,1:09:36.82,csapp,,0,0,0,,cycles per interloop iteration so each
Dialogue: 0,1:09:36.82,1:09:39.52,csapp,,0,0,0,,each iteration is taking about one cycle
Dialogue: 0,1:09:39.52,1:09:44.02,csapp,,0,0,0,,which is really good this i JK pattern
Dialogue: 0,1:09:44.02,1:09:45.77,csapp,,0,0,0,,which is kind of the intermediate 1.2
Dialogue: 0,1:09:45.77,1:09:48.34,csapp,,0,0,0,,misses that's sort of in between and the
Dialogue: 0,1:09:48.34,1:09:50.48,csapp,,0,0,0,,JK I which has two misses per iteration
Dialogue: 0,1:09:50.48,1:09:53.86,csapp,,0,0,0,,is the worst ok so what's interesting is
Dialogue: 0,1:09:53.86,1:09:56.15,csapp,,0,0,0,,we could actually just by doing a little
Dialogue: 0,1:09:56.15,1:09:58.88,csapp,,0,0,0,,bit of analysis simple analysis we could
Dialogue: 0,1:09:58.88,1:10:01.13,csapp,,0,0,0,,actually predict what this what this
Dialogue: 0,1:10:01.13,1:10:06.09,csapp,,0,0,0,,graph would look like okay in the last
Dialogue: 0,1:10:06.09,1:10:08.69,csapp,,0,0,0,,last ten minutes of the class we're
Dialogue: 0,1:10:08.69,1:10:10.28,csapp,,0,0,0,,going to look at how to improve temporal
Dialogue: 0,1:10:10.28,1:10:12.98,csapp,,0,0,0,,locality now so what we did with with
Dialogue: 0,1:10:12.98,1:10:15.55,csapp,,0,0,0,,when we rearranged our loops with in the
Dialogue: 0,1:10:15.55,1:10:17.15,csapp,,0,0,0,,matrix multiplication what we were doing
Dialogue: 0,1:10:17.15,1:10:19.52,csapp,,0,0,0,,was in improving our spatial locality
Dialogue: 0,1:10:19.52,1:10:23.03,csapp,,0,0,0,,right but we didn't we didn't really do
Dialogue: 0,1:10:23.03,1:10:24.32,csapp,,0,0,0,,anything to improve the temporal
Dialogue: 0,1:10:24.32,1:10:26.63,csapp,,0,0,0,,locality to improve temporal locality
Dialogue: 0,1:10:26.63,1:10:27.73,csapp,,0,0,0,,you have to use a technique called
Dialogue: 0,1:10:27.73,1:10:30.98,csapp,,0,0,0,,blocking and this is important to
Dialogue: 0,1:10:30.98,1:10:32.32,csapp,,0,0,0,,understand because you're going to need
Dialogue: 0,1:10:32.32,1:10:35.36,csapp,,0,0,0,,it in your cache lab for one thing but
Dialogue: 0,1:10:35.36,1:10:36.84,csapp,,0,0,0,,it's also a very general technique
Dialogue: 0,1:10:36.84,1:10:39.32,csapp,,0,0,0,,anytime you need any time you're having
Dialogue: 0,1:10:39.32,1:10:45.19,csapp,,0,0,0,,issues with temporal locality okay so
Dialogue: 0,1:10:45.19,1:10:47.00,csapp,,0,0,0,,we're not going to go into too much
Dialogue: 0,1:10:47.00,1:10:48.77,csapp,,0,0,0,,detail this code but what I did I
Dialogue: 0,1:10:48.77,1:10:53.51,csapp,,0,0,0,,rewrote the matrix multiply so that it
Dialogue: 0,1:10:53.51,1:10:55.07,csapp,,0,0,0,,operates you know a two-dimensional
Dialogue: 0,1:10:55.07,1:10:56.44,csapp,,0,0,0,,matrix that you can really just think of
Dialogue: 0,1:10:56.44,1:10:58.73,csapp,,0,0,0,,it as a contiguous array of bytes so I
Dialogue: 0,1:10:58.73,1:11:00.88,csapp,,0,0,0,,just rewrote this code to operate on a
Dialogue: 0,1:11:00.88,1:11:02.75,csapp,,0,0,0,,contiguous array one-dimensional array
Dialogue: 0,1:11:02.75,1:11:04.96,csapp,,0,0,0,,and then I'm doing the indexing
Dialogue: 0,1:11:04.96,1:11:08.38,csapp,,0,0,0,,explicitly here so here at CI times n
Dialogue: 0,1:11:08.38,1:11:10.97,csapp,,0,0,0,,plus J this is an N by n matrix
Dialogue: 0,1:11:10.97,1:11:13.85,csapp,,0,0,0,,so what I'm doing is I'm I'm accessing
Dialogue: 0,1:11:13.85,1:11:15.83,csapp,,0,0,0,,the I'm computing where the I throw
Dialogue: 0,1:11:15.83,1:11:18.59,csapp,,0,0,0,,starts and then I'm going to the J
Dialogue: 0,1:11:18.59,1:11:21.17,csapp,,0,0,0,,column of that row and then accessing
Dialogue: 0,1:11:21.17,1:11:28.67,csapp,,0,0,0,,that element all right so let's but it's
Dialogue: 0,1:11:28.67,1:11:31.64,csapp,,0,0,0,,the same idea as before so let's look at
Dialogue: 0,1:11:31.64,1:11:34.43,csapp,,0,0,0,,the Miss rate for this this is just our
Dialogue: 0,1:11:34.43,1:11:36.83,csapp,,0,0,0,,original this is our original unblocked
Dialogue: 0,1:11:36.83,1:11:40.10,csapp,,0,0,0,,matrix multiplied so what we're doing is
Dialogue: 0,1:11:40.10,1:11:45.98,csapp,,0,0,0,,we're we're computing C 0 0 and we're
Dialogue: 0,1:11:45.98,1:11:48.14,csapp,,0,0,0,,doing that by taking an inner product of
Dialogue: 0,1:11:48.14,1:11:52.87,csapp,,0,0,0,,row 0 and column 0 oops
Dialogue: 0,1:11:52.87,1:11:56.99,csapp,,0,0,0,,so if you look at the we're assuming
Dialogue: 0,1:11:56.99,1:11:59.09,csapp,,0,0,0,,that the cache the cache blocks holds
Dialogue: 0,1:11:59.09,1:12:00.71,csapp,,0,0,0,,eight doubles and that the matrix
Dialogue: 0,1:12:00.71,1:12:03.14,csapp,,0,0,0,,elements are doubles then we're going to
Dialogue: 0,1:12:03.14,1:12:06.65,csapp,,0,0,0,,miss one eighth of the time okay so in
Dialogue: 0,1:12:06.65,1:12:11.99,csapp,,0,0,0,,the first iteration we're going to miss
Dialogue: 0,1:12:11.99,1:12:15.65,csapp,,0,0,0,,the first iteration does n of these
Dialogue: 0,1:12:15.65,1:12:16.16,csapp,,0,0,0,,things
Dialogue: 0,1:12:16.16,1:12:18.68,csapp,,0,0,0,,and since we're missing n over eight of
Dialogue: 0,1:12:18.68,1:12:23.24,csapp,,0,0,0,,the time what we're missing one block
Dialogue: 0,1:12:23.24,1:12:28.43,csapp,,0,0,0,,for every eight eight references for
Dialogue: 0,1:12:28.43,1:12:31.10,csapp,,0,0,0,,each for the first iteration we're going
Dialogue: 0,1:12:31.10,1:12:34.88,csapp,,0,0,0,,to miss n over eight and since there's n
Dialogue: 0,1:12:34.88,1:12:36.98,csapp,,0,0,0,,for each element for each block I'm
Dialogue: 0,1:12:36.98,1:12:42.68,csapp,,0,0,0,,sorry and then oh so this is the number
Dialogue: 0,1:12:42.68,1:12:44.48,csapp,,0,0,0,,of blocks and the number of misses and
Dialogue: 0,1:12:44.48,1:12:46.37,csapp,,0,0,0,,then we have n elements so that the
Dialogue: 0,1:12:46.37,1:12:49.48,csapp,,0,0,0,,total number of misses is nine over n
Dialogue: 0,1:12:49.48,1:12:51.77,csapp,,0,0,0,,divided by eight misses for the first
Dialogue: 0,1:12:51.77,1:12:54.62,csapp,,0,0,0,,iteration okay
Dialogue: 0,1:12:54.62,1:12:57.77,csapp,,0,0,0,,the second iteration will have the same
Dialogue: 0,1:12:57.77,1:12:59.15,csapp,,0,0,0,,number of misses because of our
Dialogue: 0,1:12:59.15,1:13:01.34,csapp,,0,0,0,,assumptions about the the size of this
Dialogue: 0,1:13:01.34,1:13:05.12,csapp,,0,0,0,,array so this these rows are way too big
Dialogue: 0,1:13:05.12,1:13:07.07,csapp,,0,0,0,,to fit in the cache so we never get any
Dialogue: 0,1:13:07.07,1:13:11.48,csapp,,0,0,0,,we don't get any temporal locality okay
Dialogue: 0,1:13:11.48,1:13:14.48,csapp,,0,0,0,,so the total number of misses is nine n
Dialogue: 0,1:13:14.48,1:13:16.52,csapp,,0,0,0,,over eight times the number of elements
Dialogue: 0,1:13:16.52,1:13:18.14,csapp,,0,0,0,,that we're updating which is N squared
Dialogue: 0,1:13:18.14,1:13:21.41,csapp,,0,0,0,,okay so our total misses is nine over 8
Dialogue: 0,1:13:21.41,1:13:24.76,csapp,,0,0,0,,times n cubed
Dialogue: 0,1:13:24.76,1:13:27.19,csapp,,0,0,0,,now let's rewrite the code to use
Dialogue: 0,1:13:27.19,1:13:31.09,csapp,,0,0,0,,blocking and so you can look at this
Dialogue: 0,1:13:31.09,1:13:33.53,csapp,,0,0,0,,code later but it's much simpler just
Dialogue: 0,1:13:33.53,1:13:37.09,csapp,,0,0,0,,just to look at it pictorially so what
Dialogue: 0,1:13:37.09,1:13:40.94,csapp,,0,0,0,,what we're doing instead of updating one
Dialogue: 0,1:13:40.94,1:13:44.53,csapp,,0,0,0,,element at a time we're updating a sub
Dialogue: 0,1:13:44.53,1:13:49.78,csapp,,0,0,0,,block a B by B sub block and we're doing
Dialogue: 0,1:13:49.78,1:13:52.51,csapp,,0,0,0,,that just totally analogously to when
Dialogue: 0,1:13:52.51,1:13:56.75,csapp,,0,0,0,,our original case where B equal 1 this
Dialogue: 0,1:13:56.75,1:14:00.65,csapp,,0,0,0,,this B by B sub block and C is computed
Dialogue: 0,1:14:00.65,1:14:03.59,csapp,,0,0,0,,by taking an inner product of the sub
Dialogue: 0,1:14:03.59,1:14:08.53,csapp,,0,0,0,,blocks of a set of sub blocks in an a
Dialogue: 0,1:14:08.53,1:14:12.59,csapp,,0,0,0,,with a set of sub blocks in B and for
Dialogue: 0,1:14:12.59,1:14:14.03,csapp,,0,0,0,,each one of those we're doing a little
Dialogue: 0,1:14:14.03,1:14:15.73,csapp,,0,0,0,,mini matrix multiplication so we're
Dialogue: 0,1:14:15.73,1:14:20.42,csapp,,0,0,0,,taking we're taking this sub block times
Dialogue: 0,1:14:20.42,1:14:23.86,csapp,,0,0,0,,this sub block plus the second sub block
Dialogue: 0,1:14:23.86,1:14:29.26,csapp,,0,0,0,,of a times the second sub block of of B
Dialogue: 0,1:14:29.26,1:14:32.36,csapp,,0,0,0,,plus the third sub block of a times the
Dialogue: 0,1:14:32.36,1:14:35.11,csapp,,0,0,0,,third sub block of B and so on okay so
Dialogue: 0,1:14:35.11,1:14:36.92,csapp,,0,0,0,,we're doing the same inner product
Dialogue: 0,1:14:36.92,1:14:39.17,csapp,,0,0,0,,operation but instead of scalars we're
Dialogue: 0,1:14:39.17,1:14:41.21,csapp,,0,0,0,,doing it with these little sub these
Dialogue: 0,1:14:41.21,1:14:46.03,csapp,,0,0,0,,little tiny matrices ok all right so
Dialogue: 0,1:14:46.03,1:14:49.40,csapp,,0,0,0,,let's look at let's look at what happens
Dialogue: 0,1:14:49.40,1:14:53.86,csapp,,0,0,0,,to the Miss rate when we do this so
Dialogue: 0,1:14:53.86,1:15:00.96,csapp,,0,0,0,,there's there's n over B blocks in in
Dialogue: 0,1:15:00.96,1:15:07.21,csapp,,0,0,0,,any row or column and since there's B
Dialogue: 0,1:15:07.21,1:15:11.17,csapp,,0,0,0,,squared items in each block B times B
Dialogue: 0,1:15:11.17,1:15:13.88,csapp,,0,0,0,,there's B squared over 8 misses for each
Dialogue: 0,1:15:13.88,1:15:18.77,csapp,,0,0,0,,block okay
Dialogue: 0,1:15:18.77,1:15:21.48,csapp,,0,0,0,,and so then and then since there's
Dialogue: 0,1:15:21.48,1:15:24.35,csapp,,0,0,0,,there's n over B blocks in each matrix
Dialogue: 0,1:15:24.35,1:15:27.38,csapp,,0,0,0,,and there's two matrices there's two to
Dialogue: 0,1:15:27.38,1:15:32.71,csapp,,0,0,0,,n over B times B squared over 8 misses
Dialogue: 0,1:15:32.71,1:15:35.78,csapp,,0,0,0,,for this first iteration so that that
Dialogue: 0,1:15:35.78,1:15:41.06,csapp,,0,0,0,,works out to be an NB divided by 4 and
Dialogue: 0,1:15:41.06,1:15:44.15,csapp,,0,0,0,,the second iteration has the same as the
Dialogue: 0,1:15:44.15,1:15:47.30,csapp,,0,0,0,,same miss sort of same miss rate so the
Dialogue: 0,1:15:47.30,1:15:50.54,csapp,,0,0,0,,total number of misses is the number of
Dialogue: 0,1:15:50.54,1:15:54.94,csapp,,0,0,0,,the number of misses for each iteration
Dialogue: 0,1:15:54.94,1:16:00.32,csapp,,0,0,0,,x times the number of elements in C that
Dialogue: 0,1:16:00.32,1:16:03.41,csapp,,0,0,0,,we're updating okay which is n over B
Dialogue: 0,1:16:03.41,1:16:07.19,csapp,,0,0,0,,squared so that all works out too it's
Dialogue: 0,1:16:07.19,1:16:13.19,csapp,,0,0,0,,still in its n cube divided by 4 B so in
Dialogue: 0,1:16:13.19,1:16:16.48,csapp,,0,0,0,,our first case with no blocking although
Dialogue: 0,1:16:16.48,1:16:17.66,csapp,,0,0,0,,that the number of misses is
Dialogue: 0,1:16:17.66,1:16:20.57,csapp,,0,0,0,,asymptotically the same but there's this
Dialogue: 0,1:16:20.57,1:16:22.64,csapp,,0,0,0,,pretty this big difference in the
Dialogue: 0,1:16:22.64,1:16:24.53,csapp,,0,0,0,,constant factor so for no blocking it's
Dialogue: 0,1:16:24.53,1:16:28.07,csapp,,0,0,0,,9 over 8 for blocking it's 1 over 4b
Dialogue: 0,1:16:28.07,1:16:30.02,csapp,,0,0,0,,we're now we can we can just sort of
Dialogue: 0,1:16:30.02,1:16:33.89,csapp,,0,0,0,,drive that down by by increasing the
Dialogue: 0,1:16:33.89,1:16:35.75,csapp,,0,0,0,,block size so this gives us some some
Dialogue: 0,1:16:35.75,1:16:41.30,csapp,,0,0,0,,control but we still we have we can't
Dialogue: 0,1:16:41.30,1:16:43.07,csapp,,0,0,0,,make the block the blocks too big
Dialogue: 0,1:16:43.07,1:16:44.86,csapp,,0,0,0,,because we need to fit three blocks in
Dialogue: 0,1:16:44.86,1:16:50.87,csapp,,0,0,0,,cache at any one point in time ok so the
Dialogue: 0,1:16:50.87,1:16:52.13,csapp,,0,0,0,,reason this is a dramatic difference
Dialogue: 0,1:16:52.13,1:16:57.73,csapp,,0,0,0,,right and the reason for this is that by
Dialogue: 0,1:16:57.73,1:16:59.00,csapp,,0,0,0,,doing the blocking we're sort of
Dialogue: 0,1:16:59.00,1:17:01.79,csapp,,0,0,0,,exploiting once we load a block into
Dialogue: 0,1:17:01.79,1:17:03.59,csapp,,0,0,0,,memory we're sort of reusing its items
Dialogue: 0,1:17:03.59,1:17:05.45,csapp,,0,0,0,,over and over again so we're exploiting
Dialogue: 0,1:17:05.45,1:17:09.59,csapp,,0,0,0,,more temporal locality and matrix
Dialogue: 0,1:17:09.59,1:17:11.15,csapp,,0,0,0,,multiplication has this into this
Dialogue: 0,1:17:11.15,1:17:14.39,csapp,,0,0,0,,implicit locality because the
Dialogue: 0,1:17:14.39,1:17:16.64,csapp,,0,0,0,,computation is order n cubed but the
Dialogue: 0,1:17:16.64,1:17:20.42,csapp,,0,0,0,,size of the data is n squared right so
Dialogue: 0,1:17:20.42,1:17:23.35,csapp,,0,0,0,,so we must be reusing some data items
Dialogue: 0,1:17:23.35,1:17:25.52,csapp,,0,0,0,,right the problem with our scalar
Dialogue: 0,1:17:25.52,1:17:27.71,csapp,,0,0,0,,approach is that we we were when we were
Dialogue: 0,1:17:27.71,1:17:29.71,csapp,,0,0,0,,reusing them they weren't in the cache
Dialogue: 0,1:17:29.71,1:17:32.67,csapp,,0,0,0,,ok
Dialogue: 0,1:17:32.67,1:17:38.96,csapp,,0,0,0,,all right so the point that I wanted to
Dialogue: 0,1:17:38.96,1:17:41.36,csapp,,0,0,0,,make with you is that cache memories
Dialogue: 0,1:17:41.36,1:17:42.73,csapp,,0,0,0,,although they're they're sort of
Dialogue: 0,1:17:42.73,1:17:46.42,csapp,,0,0,0,,built-in automatic hardware storage
Dialogue: 0,1:17:46.42,1:17:49.09,csapp,,0,0,0,,devices and you can't really control
Dialogue: 0,1:17:49.09,1:17:52.96,csapp,,0,0,0,,them if you know about them you can take
Dialogue: 0,1:17:52.96,1:17:55.52,csapp,,0,0,0,,advantage of your knowledge and exploit
Dialogue: 0,1:17:55.52,1:17:57.59,csapp,,0,0,0,,exploit them and make your code run
Dialogue: 0,1:17:57.59,1:18:00.48,csapp,,0,0,0,,faster okay and the way you do this is
Dialogue: 0,1:18:00.48,1:18:05.96,csapp,,0,0,0,,like I said focus on the inner loops do
Dialogue: 0,1:18:05.96,1:18:09.05,csapp,,0,0,0,,is try to do try to do accesses that our
Dialogue: 0,1:18:09.05,1:18:12.50,csapp,,0,0,0,,stride one and try to maximize to to
Dialogue: 0,1:18:12.50,1:18:14.80,csapp,,0,0,0,,maximize spatial locality and try to
Dialogue: 0,1:18:14.80,1:18:17.63,csapp,,0,0,0,,maximize temporal locality by reusing
Dialogue: 0,1:18:17.63,1:18:19.30,csapp,,0,0,0,,local variables which can then be put
Dialogue: 0,1:18:19.30,1:18:23.00,csapp,,0,0,0,,into registers okay so that's it for
Dialogue: 0,1:18:23.00,1:18:24.92,csapp,,0,0,0,,today good luck with your attack lab if
Dialogue: 0,1:18:24.92,1:18:27.59,csapp,,0,0,0,,you haven't finished it and don't forget
Dialogue: 0,1:18:27.59,1:18:31.63,csapp,,0,0,0,,to get started on cache lab this weekend
